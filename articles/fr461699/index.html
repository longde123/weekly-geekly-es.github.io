<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔉 📉 📙 Volcanic Piglet, ou do-it-yourself SQL 🤺 🦈 💇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La collecte, le stockage, la conversion et la présentation des données sont les principaux défis auxquels sont confrontés les ingénieurs de données. L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Volcanic Piglet, ou do-it-yourself SQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/461699/"><p><img src="https://habrastorage.org/webt/sl/pt/ay/slptaynsfh2p62e4epxcf6_xfaw.jpeg"></p><br><p>  La collecte, le stockage, la conversion et la présentation des données sont les principaux défis auxquels sont confrontés les ingénieurs de données.  Le département Business Intelligence Badoo reçoit et traite plus de 20 milliards d'événements envoyés depuis les appareils des utilisateurs par jour, soit 2 To de données entrantes. </p><br><p>  L'étude et l'interprétation de toutes ces données ne sont pas toujours une tâche triviale, il devient parfois nécessaire d'aller au-delà des capacités des bases de données toutes faites.  Et si vous avez le courage et décidé de faire quelque chose de nouveau, vous devez d'abord vous familiariser avec les principes de fonctionnement des solutions existantes. </p><br><p>  En un mot, développeurs curieux et forts d'esprit, cet article est adressé.  Vous y trouverez une description du modèle traditionnel d'exécution de requêtes dans des bases de données relationnelles en utilisant le langage de démonstration PigletQL comme exemple. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Table des matières </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contexte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structure d'interpréteur SQL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèle de volcan et exécution de requête</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PigletQL</a> <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lexique et analyseur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyseur sémantique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Compilation de requêtes dans une vue intermédiaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Réalisation d'une présentation intermédiaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les opérateurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemples de travaux</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusions</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Littérature</a> </li></ul><br><h1 id="predystoriya">  Contexte </h1><br><p>  Notre groupe d'ingénieurs est engagé dans les backends et les interfaces, offrant des opportunités d'analyse et de recherche de données au sein de l'entreprise (en passant, nous nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">développons</a> ).  Nos outils standard sont une base de données distribuée de dizaines de serveurs (Exasol) et un cluster Hadoop pour des centaines de machines (Hive et Presto). </p><br><p>  La plupart des requêtes vers ces bases de données sont analytiques, c'est-à-dire affectant des centaines de milliers à des milliards d'enregistrements.  Leur exécution prend des minutes, des dizaines de minutes voire des heures, selon la solution utilisée et la complexité de la demande.  Avec le travail manuel de l'utilisateur-analyste, ce temps est considéré comme acceptable, mais ne convient pas à la recherche interactive via l'interface utilisateur. </p><br><p>  Au fil du temps, nous avons mis en évidence les requêtes analytiques populaires et les requêtes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qui sont difficiles à définir en termes de</a> SQL, et avons développé pour elles de petites bases de données spécialisées.  Ils stockent un sous-ensemble de données dans un format adapté aux algorithmes de compression légers (par exemple, streamvbyte), ce qui vous permet de stocker des données sur une seule machine pendant plusieurs jours et d'exécuter des requêtes en quelques secondes. </p><br><p>  Les premières langues de requête pour ces données et leurs interprètes ont été implémentées sur une intuition, nous avons dû les affiner constamment, et chaque fois cela prenait un temps inacceptable. </p><br><p>  Les langages de requête n'étaient pas suffisamment flexibles, bien qu'il n'y ait aucune raison évidente de limiter leurs capacités.  En conséquence, nous nous sommes tournés vers l'expérience des développeurs d'interprètes SQL, grâce auxquels nous avons pu résoudre partiellement les problèmes qui se sont posés. </p><br><p>  Ci-dessous, je parlerai du modèle d'exécution de requête le plus courant dans les bases de données relationnelles - Volcano.  Le code source de l'interpréteur du dialecte SQL primitif, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PigletQL</a> , est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">joint à l'article</a> , de sorte que toutes les personnes intéressées peuvent facilement se familiariser avec les détails du référentiel. </p><br><h1 id="struktura-interpretatora-sql">  Structure d'interpréteur SQL </h1><br><p> <a href=""><img src="https://habrastorage.org/webt/cw/gc/jr/cwgcjrjdybx4snxrzxqmyh4tu9c.jpeg" alt="Structure d'interprète"></a> </p><br><p>  Les bases de données les plus populaires fournissent une interface aux données sous la forme d'un langage de requête SQL déclaratif.  Une requête sous la forme d'une chaîne est convertie par l'analyseur en une description de la requête, semblable à une arborescence de syntaxe abstraite.  Il est possible d'exécuter des requêtes simples déjà à ce stade, cependant, pour optimiser les transformations et l'exécution ultérieure, cette représentation n'est pas pratique.  Dans les bases de données que je connais, des représentations intermédiaires sont introduites à ces fins. </p><br><p>  L'algèbre relationnelle est devenue un modèle de représentations intermédiaires.  Il s'agit d'un langage dans lequel les transformations ( <em>opérateurs</em> ) effectuées sur les données sont explicitement décrites: sélection d'un sous-ensemble de données selon un prédicat, combinaison de données provenant de différentes sources, etc. De plus, l'algèbre relationnelle est une algèbre au sens mathématique, c'est-à-dire un grand nombre d'équivalents transformations.  Par conséquent, il est pratique d'effectuer des transformations d'optimisation sur une requête sous la forme d'un arbre d'opérateurs d'algèbre relationnelle. </p><br><p>  Il existe des différences importantes entre les représentations internes dans les bases de données et l'algèbre relationnelle d'origine, il est donc plus correct de l'appeler <em>algèbre logique</em> . </p><br><p>  La vérification de la validité d'une requête est généralement effectuée lors de la compilation de la représentation initiale de la requête en opérateurs d'algèbre logique et correspond au stade de l'analyse sémantique dans les compilateurs conventionnels.  Le rôle de la table des symboles dans les bases de données est joué par <em>le répertoire de base de données</em> , qui stocke des informations sur le schéma et les métadonnées de la base de données: tables, colonnes de table, index, droits d'utilisateur, etc. </p><br><p>  Par rapport aux interprètes à usage général, les interprètes de base de données ont une particularité de plus: les différences de volume de données et les méta-informations sur les données auxquelles les requêtes sont censées être adressées.  Dans les tables ou les relations en termes d'algèbre relationnelle, il peut y avoir une quantité différente de données, sur certaines colonnes ( <em>attributs de</em> relation) des index peuvent être construits, etc. Autrement dit, selon le schéma de la base de données et la quantité de données dans les tables, la requête doit être effectuée par différents algorithmes et utilisez-les dans un ordre différent. </p><br><p>  Pour résoudre ce problème, une autre représentation intermédiaire est introduite - <em>l'algèbre physique</em> .  Selon la disponibilité des index sur les colonnes, la quantité de données dans les tables et la structure de l'arbre d'algèbre logique, différentes formes de l'arbre d'algèbre physique sont proposées, parmi lesquelles la meilleure option est choisie.  C'est cet arbre qui est affiché dans la base de données sous forme de plan de requête.  Dans les compilateurs conventionnels, cette étape correspond conditionnellement aux étapes d'allocation de registre, de planification et de sélection d'instructions. </p><br><p>  La dernière étape du travail de l'interprète est directement l'exécution de l'arbre d'opérateurs d'algèbre physique. </p><br><h1 id="model-volcano-i-ispolnenie-zaprosov">  Modèle de volcan et exécution de requête </h1><br><p>  Les interprètes physiques d'algèbre ont toujours été utilisés dans des bases de données commerciales fermées, mais la littérature académique se réfère généralement à l'optimiseur expérimental Volcano, développé au début des années 90. </p><br><p>  Dans le modèle du volcan, chaque opérateur d'un arbre d'algèbre physique se transforme en une structure à trois fonctions: ouvrir, ensuite, fermer.  En plus des fonctions, l'opérateur contient un état de fonctionnement - état.  La fonction open initie l'état de l'instruction, la fonction suivante retourne soit le <em>tuple</em> suivant (tuple anglais), soit NULL, s'il n'y a plus de tuples, la fonction close termine l'instruction: </p><br><p><img src="https://habrastorage.org/webt/oj/rs/td/ojrstdsuwcja-qrhljipd3cooeu.jpeg"></p><br><p>  Les opérateurs peuvent être imbriqués pour former un arbre d'opérateurs d'algèbre physique.  Ainsi, chaque opérateur itère sur les tuples d'une relation existant sur un support réel ou d'une relation virtuelle formée en énumérant les tuples d'opérateurs imbriqués: </p><br><p><img src="https://habrastorage.org/webt/qv/pk/pj/qvpkpjoiusjmjxvxj6xlp_lci3y.jpeg"></p><br><p>  En termes de langages modernes de haut niveau, l'arborescence de ces opérateurs est une cascade d'itérateurs. </p><br><p>  Même les interpréteurs de requêtes industriels dans les SGBD relationnels sont repoussés du modèle Volcano, c'est pourquoi je l'ai pris comme base de l'interpréteur PigletQL. </p><br><h1 id="pigletql">  PigletQL </h1><br><p><img src="https://habrastorage.org/webt/j9/sq/4w/j9sq4wdaertiyjii_h-vnxihrak.jpeg"></p><br><p>  Pour démontrer le modèle, j'ai développé l'interpréteur du langage de requête limité <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PigletQL</a> .  Il est écrit en C, prend en charge la création de tables dans le style de SQL, mais est limité à un seul type - entiers positifs 32 bits.  Toutes les tables sont en mémoire.  Le système fonctionne dans un seul thread et n'a pas de mécanisme de transaction. </p><br><p>  Il n'y a pas d'optimiseur dans PigletQL et les requêtes SELECT sont compilées directement dans l'arborescence d'opérateurs d'algèbre physique.  Les requêtes restantes (CREATE TABLE et INSERT) fonctionnent directement à partir des vues internes principales. </p><br><p>  Exemple de session utilisateur dans PigletQL: </p><br><pre><code class="plaintext hljs">&gt; ./pigletql &gt; CREATE TABLE tab1 (col1,col2,col3); &gt; INSERT INTO tab1 VALUES (1,2,3); &gt; INSERT INTO tab1 VALUES (4,5,6); &gt; SELECT col1,col2,col3 FROM tab1; col1 col2 col3 1 2 3 4 5 6 rows: 2 &gt; SELECT col1 FROM tab1 ORDER BY col1 DESC; col1 4 1 rows: 2</code> </pre> <br><h2 id="leksicheskiy-i-sintaksicheskiy-analizatory">  Lexique et analyseur </h2><br><p>  PigletQL est un langage très simple, et sa mise en œuvre n'était pas requise aux étapes de l'analyse lexicale et d'analyse. </p><br><p>  L'analyseur lexical est écrit à la main.  Un objet analyseur ( <a href="">scanner_t</a> ) est créé à partir de la chaîne de requête, qui distribue les jetons un par un: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scanner_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">token_t</span></span> scanner_next(<span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner);</code> </pre> <br><p>  L'analyse est effectuée à l'aide de la méthode de descente récursive.  Tout d'abord, l'objet <a href="">parser_t</a> est <a href="">créé</a> qui, après avoir reçu l'analyseur lexical (scanner_t), remplit l'objet query_t avec des informations sur la requête: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span> *query_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parser_t</span></span> *parser_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>;</code> </pre> <br><p>  Le résultat de l'analyse dans query_t est l'un des trois types de requête pris en charge par PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> query_tag { QUERY_SELECT, QUERY_CREATE_TABLE, QUERY_INSERT, } query_tag; <span class="hljs-comment"><span class="hljs-comment">/* * ... query_select_t, query_create_table_t, query_insert_t definitions ... **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_t</span></span></span><span class="hljs-class"> {</span></span> query_tag tag; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> select; <span class="hljs-keyword"><span class="hljs-keyword">query_create_table_t</span></span> create_table; <span class="hljs-keyword"><span class="hljs-keyword">query_insert_t</span></span> insert; } as; } <span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span>;</code> </pre> <br><p>  Le type de requête le plus complexe dans PigletQL est SELECT.  Il correspond à la <a href="">structure de</a> données <a href="">query_select_t</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_select_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Attributes to output */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> attr_names[MAX_ATTR_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> attr_num; <span class="hljs-comment"><span class="hljs-comment">/* Relations to get tuples from */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rel_name_t</span></span> rel_names[MAX_REL_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> rel_num; <span class="hljs-comment"><span class="hljs-comment">/* Predicates to apply to tuples */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicates[MAX_PRED_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pred_num; <span class="hljs-comment"><span class="hljs-comment">/* Pick an attribute to sort by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> has_order; <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> order_by_attr; <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> order_type; } <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span>;</code> </pre> <br><p>  La structure contient une description de la requête (un tableau d'attributs demandés par l'utilisateur), une liste de sources de données - relations, un tableau de prédicats filtrant les tuples et des informations sur l'attribut utilisé pour trier les résultats. </p><br><h2 id="semanticheskiy-analizator">  Analyseur sémantique </h2><br><p>  La phase d'analyse sémantique en SQL standard implique la vérification de l'existence des tables et des colonnes répertoriées dans les tables et la vérification des types dans les expressions de requête.  Pour les vérifications liées aux tables et aux colonnes, le répertoire de la base de données est utilisé, où toutes les informations sur la structure des données sont stockées. </p><br><p>  Il n'y a pas d'expressions complexes dans PigletQL, donc la vérification des requêtes se réduit à la vérification des métadonnées de catalogue des tables et des colonnes.  Les requêtes SELECT, par exemple, sont <a href="">validées</a> par la fonction <a href="">validate_select</a> .  Je vais l'apporter sous forme abrégée: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* All the relations should exist */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; rel_i &lt; query-&gt;rel_num; rel_i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (catalogue_get_relation(cat, query-&gt;rel_names[rel_i])) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: relation '%s' does not exist\n"</span></span>, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Relation names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rel_names_unique(query-&gt;rel_names, query-&gt;rel_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attribute names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!attr_names_unique(query-&gt;attr_names, query-&gt;attr_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attributes should be present in relations listed */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ORDER BY attribute should be available in the list of attributes chosen */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Predicate attributes should be available in the list of attributes projected */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  Si la demande est valide, l'étape suivante consiste à compiler l'arborescence d'analyse en une arborescence d'opérateurs. </p><br><h2 id="kompilyaciya-zaprosov-v-promezhutochnoe-predstavlenie">  Compilation de requêtes dans une vue intermédiaire </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/b3/7i/6a/b37i6a7mfq9z6adzpkmdpcuunls.jpeg"></a> </p><br><p>  Dans les interpréteurs SQL à part entière, il existe généralement deux représentations intermédiaires: l'algèbre logique et physique. </p><br><p>  Un interpréteur PigletQL simple exécute les requêtes CREATE TABLE et INSERT directement à partir de ses arbres d'analyse, c'est-à- <a href="">dire les structures</a> <a href="">query_create_table_t</a> et <a href="">query_insert_t</a> .  Les requêtes SELECT plus complexes sont compilées en une seule représentation intermédiaire, qui sera exécutée par l'interpréteur. </p><br><p>  L'arbre des opérateurs est construit à partir des feuilles jusqu'à la racine dans la séquence suivante: </p><br><ol><li><p>  Dans la partie droite de la requête ("... FROM relation1, relation2, ..."), les noms des relations souhaitées sont obtenus, pour chacun desquels une instruction scan est créée. </p><br></li><li><p>  En extrayant les tuples des relations, les opérateurs de scan sont combinés en un arbre binaire à gauche via l'opérateur de jointure. </p><br></li><li><p>  Les attributs demandés par l'utilisateur ("SELECT attr1, attr2, ...") sont sélectionnés par l'énoncé de projet. </p><br></li><li><p>  Si des prédicats sont spécifiés ("... WHERE a = 1 AND b&gt; 10 ..."), alors l'instruction select est ajoutée à l'arborescence ci-dessus. </p><br></li><li><p>  Si la méthode de tri du résultat est spécifiée ("... ORDER BY attr1 DESC"), alors l'opérateur de tri est ajouté en haut de l'arborescence. </p><br></li></ol><br><p>  Compilation en <a href="">code</a> PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *compile_select(<span class="hljs-keyword"><span class="hljs-keyword">catalogue_t</span></span> *cat, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> *query) { <span class="hljs-comment"><span class="hljs-comment">/* Current root operator */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 1. Scan ops */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 2. Join ops*/</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); root_op = scan_op_create(rel); rel_i += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; rel_i &lt; query-&gt;rel_num; rel_i++) { rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op = scan_op_create(rel); root_op = join_op_create(root_op, scan_op); } } <span class="hljs-comment"><span class="hljs-comment">/* 3. Project */</span></span> root_op = proj_op_create(root_op, query-&gt;attr_names, query-&gt;attr_num); <span class="hljs-comment"><span class="hljs-comment">/* 4. Select */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;pred_num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *select_op = select_op_create(root_op); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pred_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; pred_i &lt; query-&gt;pred_num; pred_i++) { <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicate = query-&gt;predicates[pred_i]; <span class="hljs-comment"><span class="hljs-comment">/* Add a predicate to the select operator */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } root_op = select_op; } <span class="hljs-comment"><span class="hljs-comment">/* 5. Sort */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;has_order) root_op = sort_op_create(root_op, query-&gt;order_by_attr, query-&gt;order_type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root_op; }</code> </pre> <br><p>  Une fois l'arbre formé, des transformations d'optimisation sont généralement effectuées, mais PigletQL passe immédiatement à l'étape d'exécution de la représentation intermédiaire. </p><br><h2 id="ispolnenie-promezhutochnogo-predstavleniya">  Réalisation d'une présentation intermédiaire </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/q7/dj/xe/q7djxezm_g_dcjund49iztea5ec.jpeg"></a> </p><br><p>  Le modèle Volcano implique une interface pour travailler avec les opérateurs à travers trois opérations communes d'ouverture / de fermeture / de fermeture.  Essentiellement, chaque instruction Volcano est un itérateur à partir duquel les tuples sont «tirés» un par un, donc cette approche de l'exécution est également appelée modèle pull. </p><br><p>  Chacun de ces itérateurs peut lui-même appeler les mêmes fonctions que les itérateurs imbriqués, créer des tables temporaires avec des résultats intermédiaires et convertir les tuples entrants. </p><br><p>  Exécution de <a href="">requêtes SELECT</a> dans PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Compile the operator tree: */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = compile_select(cat, query); <span class="hljs-comment"><span class="hljs-comment">/* Eval the tree: */</span></span> { root_op-&gt;open(root_op-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> tuples_received = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = root_op-&gt;next(root_op-&gt;state))) { <span class="hljs-comment"><span class="hljs-comment">/* attribute list for the first row only */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tuples_received == <span class="hljs-number"><span class="hljs-number">0</span></span>) dump_tuple_header(tuple); <span class="hljs-comment"><span class="hljs-comment">/* A table of tuples */</span></span> dump_tuple(tuple); tuples_received++; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"rows: %zu\n"</span></span>, tuples_received); root_op-&gt;close(root_op-&gt;state); } root_op-&gt;destroy(root_op); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  La requête est d'abord compilée par la fonction compile_select, qui renvoie la racine de l'arborescence des opérateurs, après quoi les mêmes fonctions d'ouverture / suivante / de fermeture sont appelées sur l'opérateur racine.  Chaque appel à next renvoie soit le tuple suivant soit NULL.  Dans ce dernier cas, cela signifie que tous les tuples ont été extraits et que la fonction d'itérateur de fermeture doit être appelée. </p><br><p>  Les tuples résultants sont recalculés et sortis par la table dans le flux de sortie standard. </p><br><h2 id="operatory">  Les opérateurs </h2><br><p>  La chose la plus intéressante à propos de PigletQL est l'arborescence des opérateurs.  Je vais montrer l'appareil de certains d'entre eux. </p><br><p>  <a href="">Les</a> opérateurs ont une <a href="">interface</a> commune et se composent de pointeurs vers la fonction d'ouverture / suivante / de fermeture et d'une fonction de destruction supplémentaire, qui libère les ressources de l'arborescence entière de l'opérateur à la fois: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_open)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *(*op_next)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_close)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_destroy)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">operator_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *op)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* The operator itself is just 4 pointers to related ops and operator state */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_t</span></span></span><span class="hljs-class"> {</span></span> op_open open; op_next next; op_close close; op_destroy destroy; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state; } ;</code> </pre> <br><p>  En plus des fonctions, l'opérateur peut contenir un état interne arbitraire (pointeur d'état). </p><br><p>  Ci-dessous j'analyserai le dispositif de deux opérateurs intéressants: le scan le plus simple et la création d'un tri de relation intermédiaire. </p><br><h3 id="operator-scan">  Instruction de scan </h3><br><p>  L'instruction qui démarre une requête est scan.  Il passe en revue tous les tuples de la relation.  <a href="">L'état interne de l'analyse</a> est un pointeur sur la relation d'où les tuples seront récupérés, l'index du tuple suivant dans la relation et une structure de lien vers le tuple actuel transmis à l'utilisateur: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* A reference to the relation being scanned */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation; <span class="hljs-comment"><span class="hljs-comment">/* Next tuple index to retrieve from the relation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> next_tuple_i; <span class="hljs-comment"><span class="hljs-comment">/* A structure to be filled with references to tuple data */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> current_tuple; } <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>;</code> </pre> <br><p>  Pour créer l'état d'une instruction d'analyse, vous avez besoin d'une relation source;  tout le reste (pointeurs vers les fonctions correspondantes) est déjà connu: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *op = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*op)); assert(op); *op = (<span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span>) { .open = scan_op_open, .next = scan_op_next, .close = scan_op_close, .destroy = scan_op_destroy, }; <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *state = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*state)); assert(state); *state = (<span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>) { .relation = relation, .next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.tag = TUPLE_SOURCE, .current_tuple.as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.as.source.relation = relation, }; op-&gt;state = state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op; }</code> </pre> <br><p>  Opérations d'ouverture / fermeture dans le cas d'une réinitialisation de l'analyse renvoie au premier élément de la relation: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><p>  L'appel suivant retourne soit le tuple suivant, soit NULL s'il n'y a plus de tuples dans la relation: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *scan_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;next_tuple_i &gt;= op_state-&gt;relation-&gt;tuple_num) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_source_t</span></span> *source_tuple = &amp;op_state-&gt;current_tuple.as.source; source_tuple-&gt;tuple_i = op_state-&gt;next_tuple_i; op_state-&gt;next_tuple_i++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;op_state-&gt;current_tuple; }</code> </pre><br><h3 id="operator-sort">  Instruction de tri </h3><br><p>  L'instruction sort produit des tuples dans l'ordre spécifié par l'utilisateur.  Pour ce faire, créez une relation temporaire avec des tuples obtenus à partir d'opérateurs imbriqués et triez-la. </p><br><p>  <a href="">L'état interne de l'</a> opérateur: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sort_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source; <span class="hljs-comment"><span class="hljs-comment">/* Attribute to sort tuples by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> sort_attr_name; <span class="hljs-comment"><span class="hljs-comment">/* Sort order, descending or ascending */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> sort_order; <span class="hljs-comment"><span class="hljs-comment">/* Temporary relation to be used for sorting*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *tmp_relation; <span class="hljs-comment"><span class="hljs-comment">/* Relation scan op */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *tmp_relation_scan_op; } <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span>;</code> </pre> <br><p>  Le tri est effectué selon les attributs spécifiés dans la demande (sort_attr_name et sort_order) sur le rapport temporel (tmp_relation).  Tout cela se produit lorsque la fonction open est appelée: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source = op_state-&gt;source; <span class="hljs-comment"><span class="hljs-comment">/* Materialize a table to be sorted */</span></span> source-&gt;open(source-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = source-&gt;next(source-&gt;state))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation = relation_create_for_tuple(tuple); assert(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation_scan_op = scan_op_create(op_state-&gt;tmp_relation); } relation_append_tuple(op_state-&gt;tmp_relation, tuple); } source-&gt;close(source-&gt;state); <span class="hljs-comment"><span class="hljs-comment">/* Sort it */</span></span> relation_order_by(op_state-&gt;tmp_relation, op_state-&gt;sort_attr_name, op_state-&gt;sort_order); <span class="hljs-comment"><span class="hljs-comment">/* Open a scan op on it */</span></span> op_state-&gt;tmp_relation_scan_op-&gt;open(op_state-&gt;tmp_relation_scan_op-&gt;state); }</code> </pre> <br><p>  L'énumération des éléments de la relation temporaire est effectuée par l'opérateur temporaire tmp_relation_scan_op: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *sort_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op_state-&gt;tmp_relation_scan_op-&gt;next(op_state-&gt;tmp_relation_scan_op-&gt;state);; }</code> </pre><br><p>  La relation temporaire est désallouée dans la fonction close: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-comment"><span class="hljs-comment">/* If there was a tmp relation - destroy it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation_scan_op-&gt;close(op_state-&gt;tmp_relation_scan_op-&gt;state); scan_op_destroy(op_state-&gt;tmp_relation_scan_op); relation_destroy(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } }</code> </pre><br><p>  Ici, vous pouvez voir clairement pourquoi les opérations de tri sur des colonnes sans index peuvent prendre beaucoup de temps. </p><br><h2 id="primery-raboty">  Exemples de travaux </h2><br><p>  Je vais donner quelques exemples de requêtes PigletQL et les arbres d'algèbre physique correspondants. </p><br><p>  L'exemple le plus simple où tous les tuples d'une relation sont sélectionnés: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1; a1 1 4 rows: 2 &gt;</code> </pre> <br><p>  Pour les requêtes les plus simples, seules les tuples de récupération de la relation de scan sont utilisées et la sélection du seul attribut de projet à partir des tuples: </p><br><p><img src="https://habrastorage.org/webt/3n/63/oa/3n63oa4mcglybfftogb195rdxko.jpeg"></p><br><p>  Choisir des tuples avec un prédicat: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 where a1 &gt; 3; a1 4 rows: 1 &gt;</code> </pre> <br><p>  Les prédicats sont exprimés par l'instruction select: </p><br><p><img src="https://habrastorage.org/webt/h8/82/r7/h882r7yfruh0orjlenqkb-o6lzk.jpeg"></p><br><p>  Sélection de tuples avec tri: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 order by a1 desc; a1 4 1 rows: 2</code> </pre> <br><p>  L'opérateur de tri de numérisation dans l'appel ouvert crée ( <em>matérialise</em> ) une relation temporaire, y place tous les tuples entrants et trie le tout.  Après cela, dans les prochains appels, il déduit les tuples de la relation temporaire dans l'ordre spécifié par l'utilisateur: </p><br><p><img src="https://habrastorage.org/webt/oq/ec/ap/oqecap_w6sdwv3-d7fckp2lfeyo.jpeg"></p><br><p>  Combinaison de tuples de deux relations avec un prédicat: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; create table rel2 (a4,a5,a6); &gt; insert into rel2 values (7,8,6); &gt; insert into rel2 values (9,10,6); &gt; select a1,a2,a3,a4,a5,a6 from rel1, rel2 where a3=a6; a1 a2 a3 a4 a5 a6 4 5 6 7 8 6 4 5 6 9 10 6 rows: 2</code> </pre> <br><p>  L'opérateur de jointure dans PigletQL n'utilise aucun algorithme complexe, mais forme simplement un produit cartésien à partir des ensembles de tuples des sous-arbres gauche et droit.  C'est très inefficace, mais pour un interprète de démonstration, cela fera: </p><br><p><img src="https://habrastorage.org/webt/if/ct/zp/ifctzpcu29dnns3ijm3bwlckzyk.jpeg"></p><br><h1 id="vyvody">  Conclusions </h1><br><p>  En conclusion, je note que si vous faites un interprète d'un langage similaire à SQL, alors vous devriez probablement prendre l'une des nombreuses bases de données relationnelles disponibles.  Des milliers d'années-personnes ont été investies dans des optimiseurs modernes et des interprètes de requêtes de bases de données populaires, et il faut des années pour développer même les bases de données à usage général les plus simples. </p><br><p>  Le langage de démonstration PigletQL imite le travail de l'interpréteur SQL, mais en réalité nous n'utilisons que des éléments individuels de l'architecture Volcano et uniquement pour ces (rares!) Types de requêtes difficiles à exprimer dans le cadre du modèle relationnel. </p><br><p>  Néanmoins, je le répète: même une connaissance superficielle de l'architecture de tels interprètes est utile dans les cas où il est nécessaire de travailler de manière flexible avec les flux de données. </p><br><h1 id="literatura">  Littérature </h1><br><p>  Si vous êtes intéressé par les problèmes de base du développement de bases de données, alors les livres valent mieux que «Implémentation du système de base de données» (Garcia-Molina H., Ullman JD, Widom J., 2000), vous ne trouverez pas. </p><br><p>  Son seul inconvénient est une orientation théorique.  Personnellement, j'aime quand des exemples concrets de code ou même un projet de démonstration sont attachés au matériel.  Pour cela, vous pouvez vous référer au livre «Conception et implémentation de base de données» (Sciore E., 2008), qui fournit le code complet d'une base de données relationnelle en Java. </p><br><p>  Les bases de données relationnelles les plus populaires utilisent encore des variations sur le thème du volcan.  La publication originale est écrite dans une langue très accessible et peut être facilement trouvée sur Google Scholar: "Volcano - un système d'évaluation de requête extensible et parallèle" (Graefe G., 1994). </p><br><p>  Bien que les interprètes SQL aient beaucoup changé en détail au cours des dernières décennies, la structure très générale de ces systèmes n'a pas changé depuis très longtemps.  Vous pouvez vous en faire une idée dans un article de synthèse du même auteur, «Techniques d'évaluation des requêtes pour les grandes bases de données» (Graefe G. 1993). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461699/">https://habr.com/ru/post/fr461699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461689/index.html">Développeur IoT Identification</a></li>
<li><a href="../fr461691/index.html">Comment nous fermons les vulnérabilités dans Astra Linux Special Edition OS</a></li>
<li><a href="../fr461693/index.html">Compilation croisée d'OpenCV 4 pour Raspberry Pi et BeagleBone Black</a></li>
<li><a href="../fr461695/index.html">Stage VFX</a></li>
<li><a href="../fr461697/index.html">Intelligence de la bière</a></li>
<li><a href="../fr461703/index.html">Rapports de micropas dans le travail d'un programmeur</a></li>
<li><a href="../fr461707/index.html">Les Aventures des Malvari Insaisissables, Partie V: Plus de Scriptlets DDE et COM</a></li>
<li><a href="../fr461709/index.html">À quoi s'attendre si vous souhaitez devenir développeur iOS</a></li>
<li><a href="../fr461713/index.html">4 façons d'économiser sur les sauvegardes cloud</a></li>
<li><a href="../fr461715/index.html">Peur et dégoût en tant que Techdir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>