<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîâ üìâ üìô Volcanic Piglet, ou do-it-yourself SQL ü§∫ ü¶à üíáüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La collecte, le stockage, la conversion et la pr√©sentation des donn√©es sont les principaux d√©fis auxquels sont confront√©s les ing√©nieurs de donn√©es. L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Volcanic Piglet, ou do-it-yourself SQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/461699/"><p><img src="https://habrastorage.org/webt/sl/pt/ay/slptaynsfh2p62e4epxcf6_xfaw.jpeg"></p><br><p>  La collecte, le stockage, la conversion et la pr√©sentation des donn√©es sont les principaux d√©fis auxquels sont confront√©s les ing√©nieurs de donn√©es.  Le d√©partement Business Intelligence Badoo re√ßoit et traite plus de 20 milliards d'√©v√©nements envoy√©s depuis les appareils des utilisateurs par jour, soit 2 To de donn√©es entrantes. </p><br><p>  L'√©tude et l'interpr√©tation de toutes ces donn√©es ne sont pas toujours une t√¢che triviale, il devient parfois n√©cessaire d'aller au-del√† des capacit√©s des bases de donn√©es toutes faites.  Et si vous avez le courage et d√©cid√© de faire quelque chose de nouveau, vous devez d'abord vous familiariser avec les principes de fonctionnement des solutions existantes. </p><br><p>  En un mot, d√©veloppeurs curieux et forts d'esprit, cet article est adress√©.  Vous y trouverez une description du mod√®le traditionnel d'ex√©cution de requ√™tes dans des bases de donn√©es relationnelles en utilisant le langage de d√©monstration PigletQL comme exemple. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Table des mati√®res </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contexte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structure d'interpr√©teur SQL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mod√®le de volcan et ex√©cution de requ√™te</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PigletQL</a> <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lexique et analyseur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyseur s√©mantique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Compilation de requ√™tes dans une vue interm√©diaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©alisation d'une pr√©sentation interm√©diaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les op√©rateurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemples de travaux</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusions</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Litt√©rature</a> </li></ul><br><h1 id="predystoriya">  Contexte </h1><br><p>  Notre groupe d'ing√©nieurs est engag√© dans les backends et les interfaces, offrant des opportunit√©s d'analyse et de recherche de donn√©es au sein de l'entreprise (en passant, nous nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©veloppons</a> ).  Nos outils standard sont une base de donn√©es distribu√©e de dizaines de serveurs (Exasol) et un cluster Hadoop pour des centaines de machines (Hive et Presto). </p><br><p>  La plupart des requ√™tes vers ces bases de donn√©es sont analytiques, c'est-√†-dire affectant des centaines de milliers √† des milliards d'enregistrements.  Leur ex√©cution prend des minutes, des dizaines de minutes voire des heures, selon la solution utilis√©e et la complexit√© de la demande.  Avec le travail manuel de l'utilisateur-analyste, ce temps est consid√©r√© comme acceptable, mais ne convient pas √† la recherche interactive via l'interface utilisateur. </p><br><p>  Au fil du temps, nous avons mis en √©vidence les requ√™tes analytiques populaires et les requ√™tes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qui sont difficiles √† d√©finir en termes de</a> SQL, et avons d√©velopp√© pour elles de petites bases de donn√©es sp√©cialis√©es.  Ils stockent un sous-ensemble de donn√©es dans un format adapt√© aux algorithmes de compression l√©gers (par exemple, streamvbyte), ce qui vous permet de stocker des donn√©es sur une seule machine pendant plusieurs jours et d'ex√©cuter des requ√™tes en quelques secondes. </p><br><p>  Les premi√®res langues de requ√™te pour ces donn√©es et leurs interpr√®tes ont √©t√© impl√©ment√©es sur une intuition, nous avons d√ª les affiner constamment, et chaque fois cela prenait un temps inacceptable. </p><br><p>  Les langages de requ√™te n'√©taient pas suffisamment flexibles, bien qu'il n'y ait aucune raison √©vidente de limiter leurs capacit√©s.  En cons√©quence, nous nous sommes tourn√©s vers l'exp√©rience des d√©veloppeurs d'interpr√®tes SQL, gr√¢ce auxquels nous avons pu r√©soudre partiellement les probl√®mes qui se sont pos√©s. </p><br><p>  Ci-dessous, je parlerai du mod√®le d'ex√©cution de requ√™te le plus courant dans les bases de donn√©es relationnelles - Volcano.  Le code source de l'interpr√©teur du dialecte SQL primitif, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PigletQL</a> , est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">joint √† l'article</a> , de sorte que toutes les personnes int√©ress√©es peuvent facilement se familiariser avec les d√©tails du r√©f√©rentiel. </p><br><h1 id="struktura-interpretatora-sql">  Structure d'interpr√©teur SQL </h1><br><p> <a href=""><img src="https://habrastorage.org/webt/cw/gc/jr/cwgcjrjdybx4snxrzxqmyh4tu9c.jpeg" alt="Structure d'interpr√®te"></a> </p><br><p>  Les bases de donn√©es les plus populaires fournissent une interface aux donn√©es sous la forme d'un langage de requ√™te SQL d√©claratif.  Une requ√™te sous la forme d'une cha√Æne est convertie par l'analyseur en une description de la requ√™te, semblable √† une arborescence de syntaxe abstraite.  Il est possible d'ex√©cuter des requ√™tes simples d√©j√† √† ce stade, cependant, pour optimiser les transformations et l'ex√©cution ult√©rieure, cette repr√©sentation n'est pas pratique.  Dans les bases de donn√©es que je connais, des repr√©sentations interm√©diaires sont introduites √† ces fins. </p><br><p>  L'alg√®bre relationnelle est devenue un mod√®le de repr√©sentations interm√©diaires.  Il s'agit d'un langage dans lequel les transformations ( <em>op√©rateurs</em> ) effectu√©es sur les donn√©es sont explicitement d√©crites: s√©lection d'un sous-ensemble de donn√©es selon un pr√©dicat, combinaison de donn√©es provenant de diff√©rentes sources, etc. De plus, l'alg√®bre relationnelle est une alg√®bre au sens math√©matique, c'est-√†-dire un grand nombre d'√©quivalents transformations.  Par cons√©quent, il est pratique d'effectuer des transformations d'optimisation sur une requ√™te sous la forme d'un arbre d'op√©rateurs d'alg√®bre relationnelle. </p><br><p>  Il existe des diff√©rences importantes entre les repr√©sentations internes dans les bases de donn√©es et l'alg√®bre relationnelle d'origine, il est donc plus correct de l'appeler <em>alg√®bre logique</em> . </p><br><p>  La v√©rification de la validit√© d'une requ√™te est g√©n√©ralement effectu√©e lors de la compilation de la repr√©sentation initiale de la requ√™te en op√©rateurs d'alg√®bre logique et correspond au stade de l'analyse s√©mantique dans les compilateurs conventionnels.  Le r√¥le de la table des symboles dans les bases de donn√©es est jou√© par <em>le r√©pertoire de base de donn√©es</em> , qui stocke des informations sur le sch√©ma et les m√©tadonn√©es de la base de donn√©es: tables, colonnes de table, index, droits d'utilisateur, etc. </p><br><p>  Par rapport aux interpr√®tes √† usage g√©n√©ral, les interpr√®tes de base de donn√©es ont une particularit√© de plus: les diff√©rences de volume de donn√©es et les m√©ta-informations sur les donn√©es auxquelles les requ√™tes sont cens√©es √™tre adress√©es.  Dans les tables ou les relations en termes d'alg√®bre relationnelle, il peut y avoir une quantit√© diff√©rente de donn√©es, sur certaines colonnes ( <em>attributs de</em> relation) des index peuvent √™tre construits, etc. Autrement dit, selon le sch√©ma de la base de donn√©es et la quantit√© de donn√©es dans les tables, la requ√™te doit √™tre effectu√©e par diff√©rents algorithmes et utilisez-les dans un ordre diff√©rent. </p><br><p>  Pour r√©soudre ce probl√®me, une autre repr√©sentation interm√©diaire est introduite - <em>l'alg√®bre physique</em> .  Selon la disponibilit√© des index sur les colonnes, la quantit√© de donn√©es dans les tables et la structure de l'arbre d'alg√®bre logique, diff√©rentes formes de l'arbre d'alg√®bre physique sont propos√©es, parmi lesquelles la meilleure option est choisie.  C'est cet arbre qui est affich√© dans la base de donn√©es sous forme de plan de requ√™te.  Dans les compilateurs conventionnels, cette √©tape correspond conditionnellement aux √©tapes d'allocation de registre, de planification et de s√©lection d'instructions. </p><br><p>  La derni√®re √©tape du travail de l'interpr√®te est directement l'ex√©cution de l'arbre d'op√©rateurs d'alg√®bre physique. </p><br><h1 id="model-volcano-i-ispolnenie-zaprosov">  Mod√®le de volcan et ex√©cution de requ√™te </h1><br><p>  Les interpr√®tes physiques d'alg√®bre ont toujours √©t√© utilis√©s dans des bases de donn√©es commerciales ferm√©es, mais la litt√©rature acad√©mique se r√©f√®re g√©n√©ralement √† l'optimiseur exp√©rimental Volcano, d√©velopp√© au d√©but des ann√©es 90. </p><br><p>  Dans le mod√®le du volcan, chaque op√©rateur d'un arbre d'alg√®bre physique se transforme en une structure √† trois fonctions: ouvrir, ensuite, fermer.  En plus des fonctions, l'op√©rateur contient un √©tat de fonctionnement - √©tat.  La fonction open initie l'√©tat de l'instruction, la fonction suivante retourne soit le <em>tuple</em> suivant (tuple anglais), soit NULL, s'il n'y a plus de tuples, la fonction close termine l'instruction: </p><br><p><img src="https://habrastorage.org/webt/oj/rs/td/ojrstdsuwcja-qrhljipd3cooeu.jpeg"></p><br><p>  Les op√©rateurs peuvent √™tre imbriqu√©s pour former un arbre d'op√©rateurs d'alg√®bre physique.  Ainsi, chaque op√©rateur it√®re sur les tuples d'une relation existant sur un support r√©el ou d'une relation virtuelle form√©e en √©num√©rant les tuples d'op√©rateurs imbriqu√©s: </p><br><p><img src="https://habrastorage.org/webt/qv/pk/pj/qvpkpjoiusjmjxvxj6xlp_lci3y.jpeg"></p><br><p>  En termes de langages modernes de haut niveau, l'arborescence de ces op√©rateurs est une cascade d'it√©rateurs. </p><br><p>  M√™me les interpr√©teurs de requ√™tes industriels dans les SGBD relationnels sont repouss√©s du mod√®le Volcano, c'est pourquoi je l'ai pris comme base de l'interpr√©teur PigletQL. </p><br><h1 id="pigletql">  PigletQL </h1><br><p><img src="https://habrastorage.org/webt/j9/sq/4w/j9sq4wdaertiyjii_h-vnxihrak.jpeg"></p><br><p>  Pour d√©montrer le mod√®le, j'ai d√©velopp√© l'interpr√©teur du langage de requ√™te limit√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PigletQL</a> .  Il est √©crit en C, prend en charge la cr√©ation de tables dans le style de SQL, mais est limit√© √† un seul type - entiers positifs 32 bits.  Toutes les tables sont en m√©moire.  Le syst√®me fonctionne dans un seul thread et n'a pas de m√©canisme de transaction. </p><br><p>  Il n'y a pas d'optimiseur dans PigletQL et les requ√™tes SELECT sont compil√©es directement dans l'arborescence d'op√©rateurs d'alg√®bre physique.  Les requ√™tes restantes (CREATE TABLE et INSERT) fonctionnent directement √† partir des vues internes principales. </p><br><p>  Exemple de session utilisateur dans PigletQL: </p><br><pre><code class="plaintext hljs">&gt; ./pigletql &gt; CREATE TABLE tab1 (col1,col2,col3); &gt; INSERT INTO tab1 VALUES (1,2,3); &gt; INSERT INTO tab1 VALUES (4,5,6); &gt; SELECT col1,col2,col3 FROM tab1; col1 col2 col3 1 2 3 4 5 6 rows: 2 &gt; SELECT col1 FROM tab1 ORDER BY col1 DESC; col1 4 1 rows: 2</code> </pre> <br><h2 id="leksicheskiy-i-sintaksicheskiy-analizatory">  Lexique et analyseur </h2><br><p>  PigletQL est un langage tr√®s simple, et sa mise en ≈ìuvre n'√©tait pas requise aux √©tapes de l'analyse lexicale et d'analyse. </p><br><p>  L'analyseur lexical est √©crit √† la main.  Un objet analyseur ( <a href="">scanner_t</a> ) est cr√©√© √† partir de la cha√Æne de requ√™te, qui distribue les jetons un par un: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scanner_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">token_t</span></span> scanner_next(<span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner);</code> </pre> <br><p>  L'analyse est effectu√©e √† l'aide de la m√©thode de descente r√©cursive.  Tout d'abord, l'objet <a href="">parser_t</a> est <a href="">cr√©√©</a> qui, apr√®s avoir re√ßu l'analyseur lexical (scanner_t), remplit l'objet query_t avec des informations sur la requ√™te: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span> *query_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parser_t</span></span> *parser_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>;</code> </pre> <br><p>  Le r√©sultat de l'analyse dans query_t est l'un des trois types de requ√™te pris en charge par PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> query_tag { QUERY_SELECT, QUERY_CREATE_TABLE, QUERY_INSERT, } query_tag; <span class="hljs-comment"><span class="hljs-comment">/* * ... query_select_t, query_create_table_t, query_insert_t definitions ... **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_t</span></span></span><span class="hljs-class"> {</span></span> query_tag tag; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> select; <span class="hljs-keyword"><span class="hljs-keyword">query_create_table_t</span></span> create_table; <span class="hljs-keyword"><span class="hljs-keyword">query_insert_t</span></span> insert; } as; } <span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span>;</code> </pre> <br><p>  Le type de requ√™te le plus complexe dans PigletQL est SELECT.  Il correspond √† la <a href="">structure de</a> donn√©es <a href="">query_select_t</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_select_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Attributes to output */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> attr_names[MAX_ATTR_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> attr_num; <span class="hljs-comment"><span class="hljs-comment">/* Relations to get tuples from */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rel_name_t</span></span> rel_names[MAX_REL_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> rel_num; <span class="hljs-comment"><span class="hljs-comment">/* Predicates to apply to tuples */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicates[MAX_PRED_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pred_num; <span class="hljs-comment"><span class="hljs-comment">/* Pick an attribute to sort by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> has_order; <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> order_by_attr; <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> order_type; } <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span>;</code> </pre> <br><p>  La structure contient une description de la requ√™te (un tableau d'attributs demand√©s par l'utilisateur), une liste de sources de donn√©es - relations, un tableau de pr√©dicats filtrant les tuples et des informations sur l'attribut utilis√© pour trier les r√©sultats. </p><br><h2 id="semanticheskiy-analizator">  Analyseur s√©mantique </h2><br><p>  La phase d'analyse s√©mantique en SQL standard implique la v√©rification de l'existence des tables et des colonnes r√©pertori√©es dans les tables et la v√©rification des types dans les expressions de requ√™te.  Pour les v√©rifications li√©es aux tables et aux colonnes, le r√©pertoire de la base de donn√©es est utilis√©, o√π toutes les informations sur la structure des donn√©es sont stock√©es. </p><br><p>  Il n'y a pas d'expressions complexes dans PigletQL, donc la v√©rification des requ√™tes se r√©duit √† la v√©rification des m√©tadonn√©es de catalogue des tables et des colonnes.  Les requ√™tes SELECT, par exemple, sont <a href="">valid√©es</a> par la fonction <a href="">validate_select</a> .  Je vais l'apporter sous forme abr√©g√©e: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* All the relations should exist */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; rel_i &lt; query-&gt;rel_num; rel_i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (catalogue_get_relation(cat, query-&gt;rel_names[rel_i])) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: relation '%s' does not exist\n"</span></span>, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Relation names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rel_names_unique(query-&gt;rel_names, query-&gt;rel_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attribute names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!attr_names_unique(query-&gt;attr_names, query-&gt;attr_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attributes should be present in relations listed */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ORDER BY attribute should be available in the list of attributes chosen */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Predicate attributes should be available in the list of attributes projected */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  Si la demande est valide, l'√©tape suivante consiste √† compiler l'arborescence d'analyse en une arborescence d'op√©rateurs. </p><br><h2 id="kompilyaciya-zaprosov-v-promezhutochnoe-predstavlenie">  Compilation de requ√™tes dans une vue interm√©diaire </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/b3/7i/6a/b37i6a7mfq9z6adzpkmdpcuunls.jpeg"></a> </p><br><p>  Dans les interpr√©teurs SQL √† part enti√®re, il existe g√©n√©ralement deux repr√©sentations interm√©diaires: l'alg√®bre logique et physique. </p><br><p>  Un interpr√©teur PigletQL simple ex√©cute les requ√™tes CREATE TABLE et INSERT directement √† partir de ses arbres d'analyse, c'est-√†- <a href="">dire les structures</a> <a href="">query_create_table_t</a> et <a href="">query_insert_t</a> .  Les requ√™tes SELECT plus complexes sont compil√©es en une seule repr√©sentation interm√©diaire, qui sera ex√©cut√©e par l'interpr√©teur. </p><br><p>  L'arbre des op√©rateurs est construit √† partir des feuilles jusqu'√† la racine dans la s√©quence suivante: </p><br><ol><li><p>  Dans la partie droite de la requ√™te ("... FROM relation1, relation2, ..."), les noms des relations souhait√©es sont obtenus, pour chacun desquels une instruction scan est cr√©√©e. </p><br></li><li><p>  En extrayant les tuples des relations, les op√©rateurs de scan sont combin√©s en un arbre binaire √† gauche via l'op√©rateur de jointure. </p><br></li><li><p>  Les attributs demand√©s par l'utilisateur ("SELECT attr1, attr2, ...") sont s√©lectionn√©s par l'√©nonc√© de projet. </p><br></li><li><p>  Si des pr√©dicats sont sp√©cifi√©s ("... WHERE a = 1 AND b&gt; 10 ..."), alors l'instruction select est ajout√©e √† l'arborescence ci-dessus. </p><br></li><li><p>  Si la m√©thode de tri du r√©sultat est sp√©cifi√©e ("... ORDER BY attr1 DESC"), alors l'op√©rateur de tri est ajout√© en haut de l'arborescence. </p><br></li></ol><br><p>  Compilation en <a href="">code</a> PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *compile_select(<span class="hljs-keyword"><span class="hljs-keyword">catalogue_t</span></span> *cat, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> *query) { <span class="hljs-comment"><span class="hljs-comment">/* Current root operator */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 1. Scan ops */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 2. Join ops*/</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); root_op = scan_op_create(rel); rel_i += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; rel_i &lt; query-&gt;rel_num; rel_i++) { rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op = scan_op_create(rel); root_op = join_op_create(root_op, scan_op); } } <span class="hljs-comment"><span class="hljs-comment">/* 3. Project */</span></span> root_op = proj_op_create(root_op, query-&gt;attr_names, query-&gt;attr_num); <span class="hljs-comment"><span class="hljs-comment">/* 4. Select */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;pred_num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *select_op = select_op_create(root_op); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pred_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; pred_i &lt; query-&gt;pred_num; pred_i++) { <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicate = query-&gt;predicates[pred_i]; <span class="hljs-comment"><span class="hljs-comment">/* Add a predicate to the select operator */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } root_op = select_op; } <span class="hljs-comment"><span class="hljs-comment">/* 5. Sort */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;has_order) root_op = sort_op_create(root_op, query-&gt;order_by_attr, query-&gt;order_type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root_op; }</code> </pre> <br><p>  Une fois l'arbre form√©, des transformations d'optimisation sont g√©n√©ralement effectu√©es, mais PigletQL passe imm√©diatement √† l'√©tape d'ex√©cution de la repr√©sentation interm√©diaire. </p><br><h2 id="ispolnenie-promezhutochnogo-predstavleniya">  R√©alisation d'une pr√©sentation interm√©diaire </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/q7/dj/xe/q7djxezm_g_dcjund49iztea5ec.jpeg"></a> </p><br><p>  Le mod√®le Volcano implique une interface pour travailler avec les op√©rateurs √† travers trois op√©rations communes d'ouverture / de fermeture / de fermeture.  Essentiellement, chaque instruction Volcano est un it√©rateur √† partir duquel les tuples sont ¬´tir√©s¬ª un par un, donc cette approche de l'ex√©cution est √©galement appel√©e mod√®le pull. </p><br><p>  Chacun de ces it√©rateurs peut lui-m√™me appeler les m√™mes fonctions que les it√©rateurs imbriqu√©s, cr√©er des tables temporaires avec des r√©sultats interm√©diaires et convertir les tuples entrants. </p><br><p>  Ex√©cution de <a href="">requ√™tes SELECT</a> dans PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Compile the operator tree: */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = compile_select(cat, query); <span class="hljs-comment"><span class="hljs-comment">/* Eval the tree: */</span></span> { root_op-&gt;open(root_op-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> tuples_received = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = root_op-&gt;next(root_op-&gt;state))) { <span class="hljs-comment"><span class="hljs-comment">/* attribute list for the first row only */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tuples_received == <span class="hljs-number"><span class="hljs-number">0</span></span>) dump_tuple_header(tuple); <span class="hljs-comment"><span class="hljs-comment">/* A table of tuples */</span></span> dump_tuple(tuple); tuples_received++; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"rows: %zu\n"</span></span>, tuples_received); root_op-&gt;close(root_op-&gt;state); } root_op-&gt;destroy(root_op); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  La requ√™te est d'abord compil√©e par la fonction compile_select, qui renvoie la racine de l'arborescence des op√©rateurs, apr√®s quoi les m√™mes fonctions d'ouverture / suivante / de fermeture sont appel√©es sur l'op√©rateur racine.  Chaque appel √† next renvoie soit le tuple suivant soit NULL.  Dans ce dernier cas, cela signifie que tous les tuples ont √©t√© extraits et que la fonction d'it√©rateur de fermeture doit √™tre appel√©e. </p><br><p>  Les tuples r√©sultants sont recalcul√©s et sortis par la table dans le flux de sortie standard. </p><br><h2 id="operatory">  Les op√©rateurs </h2><br><p>  La chose la plus int√©ressante √† propos de PigletQL est l'arborescence des op√©rateurs.  Je vais montrer l'appareil de certains d'entre eux. </p><br><p>  <a href="">Les</a> op√©rateurs ont une <a href="">interface</a> commune et se composent de pointeurs vers la fonction d'ouverture / suivante / de fermeture et d'une fonction de destruction suppl√©mentaire, qui lib√®re les ressources de l'arborescence enti√®re de l'op√©rateur √† la fois: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_open)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *(*op_next)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_close)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_destroy)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">operator_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *op)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* The operator itself is just 4 pointers to related ops and operator state */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_t</span></span></span><span class="hljs-class"> {</span></span> op_open open; op_next next; op_close close; op_destroy destroy; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state; } ;</code> </pre> <br><p>  En plus des fonctions, l'op√©rateur peut contenir un √©tat interne arbitraire (pointeur d'√©tat). </p><br><p>  Ci-dessous j'analyserai le dispositif de deux op√©rateurs int√©ressants: le scan le plus simple et la cr√©ation d'un tri de relation interm√©diaire. </p><br><h3 id="operator-scan">  Instruction de scan </h3><br><p>  L'instruction qui d√©marre une requ√™te est scan.  Il passe en revue tous les tuples de la relation.  <a href="">L'√©tat interne de l'analyse</a> est un pointeur sur la relation d'o√π les tuples seront r√©cup√©r√©s, l'index du tuple suivant dans la relation et une structure de lien vers le tuple actuel transmis √† l'utilisateur: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* A reference to the relation being scanned */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation; <span class="hljs-comment"><span class="hljs-comment">/* Next tuple index to retrieve from the relation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> next_tuple_i; <span class="hljs-comment"><span class="hljs-comment">/* A structure to be filled with references to tuple data */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> current_tuple; } <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>;</code> </pre> <br><p>  Pour cr√©er l'√©tat d'une instruction d'analyse, vous avez besoin d'une relation source;  tout le reste (pointeurs vers les fonctions correspondantes) est d√©j√† connu: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *op = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*op)); assert(op); *op = (<span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span>) { .open = scan_op_open, .next = scan_op_next, .close = scan_op_close, .destroy = scan_op_destroy, }; <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *state = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*state)); assert(state); *state = (<span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>) { .relation = relation, .next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.tag = TUPLE_SOURCE, .current_tuple.as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.as.source.relation = relation, }; op-&gt;state = state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op; }</code> </pre> <br><p>  Op√©rations d'ouverture / fermeture dans le cas d'une r√©initialisation de l'analyse renvoie au premier √©l√©ment de la relation: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><p>  L'appel suivant retourne soit le tuple suivant, soit NULL s'il n'y a plus de tuples dans la relation: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *scan_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;next_tuple_i &gt;= op_state-&gt;relation-&gt;tuple_num) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_source_t</span></span> *source_tuple = &amp;op_state-&gt;current_tuple.as.source; source_tuple-&gt;tuple_i = op_state-&gt;next_tuple_i; op_state-&gt;next_tuple_i++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;op_state-&gt;current_tuple; }</code> </pre><br><h3 id="operator-sort">  Instruction de tri </h3><br><p>  L'instruction sort produit des tuples dans l'ordre sp√©cifi√© par l'utilisateur.  Pour ce faire, cr√©ez une relation temporaire avec des tuples obtenus √† partir d'op√©rateurs imbriqu√©s et triez-la. </p><br><p>  <a href="">L'√©tat interne de l'</a> op√©rateur: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sort_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source; <span class="hljs-comment"><span class="hljs-comment">/* Attribute to sort tuples by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> sort_attr_name; <span class="hljs-comment"><span class="hljs-comment">/* Sort order, descending or ascending */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> sort_order; <span class="hljs-comment"><span class="hljs-comment">/* Temporary relation to be used for sorting*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *tmp_relation; <span class="hljs-comment"><span class="hljs-comment">/* Relation scan op */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *tmp_relation_scan_op; } <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span>;</code> </pre> <br><p>  Le tri est effectu√© selon les attributs sp√©cifi√©s dans la demande (sort_attr_name et sort_order) sur le rapport temporel (tmp_relation).  Tout cela se produit lorsque la fonction open est appel√©e: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source = op_state-&gt;source; <span class="hljs-comment"><span class="hljs-comment">/* Materialize a table to be sorted */</span></span> source-&gt;open(source-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = source-&gt;next(source-&gt;state))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation = relation_create_for_tuple(tuple); assert(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation_scan_op = scan_op_create(op_state-&gt;tmp_relation); } relation_append_tuple(op_state-&gt;tmp_relation, tuple); } source-&gt;close(source-&gt;state); <span class="hljs-comment"><span class="hljs-comment">/* Sort it */</span></span> relation_order_by(op_state-&gt;tmp_relation, op_state-&gt;sort_attr_name, op_state-&gt;sort_order); <span class="hljs-comment"><span class="hljs-comment">/* Open a scan op on it */</span></span> op_state-&gt;tmp_relation_scan_op-&gt;open(op_state-&gt;tmp_relation_scan_op-&gt;state); }</code> </pre> <br><p>  L'√©num√©ration des √©l√©ments de la relation temporaire est effectu√©e par l'op√©rateur temporaire tmp_relation_scan_op: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *sort_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op_state-&gt;tmp_relation_scan_op-&gt;next(op_state-&gt;tmp_relation_scan_op-&gt;state);; }</code> </pre><br><p>  La relation temporaire est d√©sallou√©e dans la fonction close: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-comment"><span class="hljs-comment">/* If there was a tmp relation - destroy it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation_scan_op-&gt;close(op_state-&gt;tmp_relation_scan_op-&gt;state); scan_op_destroy(op_state-&gt;tmp_relation_scan_op); relation_destroy(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } }</code> </pre><br><p>  Ici, vous pouvez voir clairement pourquoi les op√©rations de tri sur des colonnes sans index peuvent prendre beaucoup de temps. </p><br><h2 id="primery-raboty">  Exemples de travaux </h2><br><p>  Je vais donner quelques exemples de requ√™tes PigletQL et les arbres d'alg√®bre physique correspondants. </p><br><p>  L'exemple le plus simple o√π tous les tuples d'une relation sont s√©lectionn√©s: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1; a1 1 4 rows: 2 &gt;</code> </pre> <br><p>  Pour les requ√™tes les plus simples, seules les tuples de r√©cup√©ration de la relation de scan sont utilis√©es et la s√©lection du seul attribut de projet √† partir des tuples: </p><br><p><img src="https://habrastorage.org/webt/3n/63/oa/3n63oa4mcglybfftogb195rdxko.jpeg"></p><br><p>  Choisir des tuples avec un pr√©dicat: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 where a1 &gt; 3; a1 4 rows: 1 &gt;</code> </pre> <br><p>  Les pr√©dicats sont exprim√©s par l'instruction select: </p><br><p><img src="https://habrastorage.org/webt/h8/82/r7/h882r7yfruh0orjlenqkb-o6lzk.jpeg"></p><br><p>  S√©lection de tuples avec tri: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 order by a1 desc; a1 4 1 rows: 2</code> </pre> <br><p>  L'op√©rateur de tri de num√©risation dans l'appel ouvert cr√©e ( <em>mat√©rialise</em> ) une relation temporaire, y place tous les tuples entrants et trie le tout.  Apr√®s cela, dans les prochains appels, il d√©duit les tuples de la relation temporaire dans l'ordre sp√©cifi√© par l'utilisateur: </p><br><p><img src="https://habrastorage.org/webt/oq/ec/ap/oqecap_w6sdwv3-d7fckp2lfeyo.jpeg"></p><br><p>  Combinaison de tuples de deux relations avec un pr√©dicat: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; create table rel2 (a4,a5,a6); &gt; insert into rel2 values (7,8,6); &gt; insert into rel2 values (9,10,6); &gt; select a1,a2,a3,a4,a5,a6 from rel1, rel2 where a3=a6; a1 a2 a3 a4 a5 a6 4 5 6 7 8 6 4 5 6 9 10 6 rows: 2</code> </pre> <br><p>  L'op√©rateur de jointure dans PigletQL n'utilise aucun algorithme complexe, mais forme simplement un produit cart√©sien √† partir des ensembles de tuples des sous-arbres gauche et droit.  C'est tr√®s inefficace, mais pour un interpr√®te de d√©monstration, cela fera: </p><br><p><img src="https://habrastorage.org/webt/if/ct/zp/ifctzpcu29dnns3ijm3bwlckzyk.jpeg"></p><br><h1 id="vyvody">  Conclusions </h1><br><p>  En conclusion, je note que si vous faites un interpr√®te d'un langage similaire √† SQL, alors vous devriez probablement prendre l'une des nombreuses bases de donn√©es relationnelles disponibles.  Des milliers d'ann√©es-personnes ont √©t√© investies dans des optimiseurs modernes et des interpr√®tes de requ√™tes de bases de donn√©es populaires, et il faut des ann√©es pour d√©velopper m√™me les bases de donn√©es √† usage g√©n√©ral les plus simples. </p><br><p>  Le langage de d√©monstration PigletQL imite le travail de l'interpr√©teur SQL, mais en r√©alit√© nous n'utilisons que des √©l√©ments individuels de l'architecture Volcano et uniquement pour ces (rares!) Types de requ√™tes difficiles √† exprimer dans le cadre du mod√®le relationnel. </p><br><p>  N√©anmoins, je le r√©p√®te: m√™me une connaissance superficielle de l'architecture de tels interpr√®tes est utile dans les cas o√π il est n√©cessaire de travailler de mani√®re flexible avec les flux de donn√©es. </p><br><h1 id="literatura">  Litt√©rature </h1><br><p>  Si vous √™tes int√©ress√© par les probl√®mes de base du d√©veloppement de bases de donn√©es, alors les livres valent mieux que ¬´Impl√©mentation du syst√®me de base de donn√©es¬ª (Garcia-Molina H., Ullman JD, Widom J., 2000), vous ne trouverez pas. </p><br><p>  Son seul inconv√©nient est une orientation th√©orique.  Personnellement, j'aime quand des exemples concrets de code ou m√™me un projet de d√©monstration sont attach√©s au mat√©riel.  Pour cela, vous pouvez vous r√©f√©rer au livre ¬´Conception et impl√©mentation de base de donn√©es¬ª (Sciore E., 2008), qui fournit le code complet d'une base de donn√©es relationnelle en Java. </p><br><p>  Les bases de donn√©es relationnelles les plus populaires utilisent encore des variations sur le th√®me du volcan.  La publication originale est √©crite dans une langue tr√®s accessible et peut √™tre facilement trouv√©e sur Google Scholar: "Volcano - un syst√®me d'√©valuation de requ√™te extensible et parall√®le" (Graefe G., 1994). </p><br><p>  Bien que les interpr√®tes SQL aient beaucoup chang√© en d√©tail au cours des derni√®res d√©cennies, la structure tr√®s g√©n√©rale de ces syst√®mes n'a pas chang√© depuis tr√®s longtemps.  Vous pouvez vous en faire une id√©e dans un article de synth√®se du m√™me auteur, ¬´Techniques d'√©valuation des requ√™tes pour les grandes bases de donn√©es¬ª (Graefe G. 1993). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461699/">https://habr.com/ru/post/fr461699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461689/index.html">D√©veloppeur IoT Identification</a></li>
<li><a href="../fr461691/index.html">Comment nous fermons les vuln√©rabilit√©s dans Astra Linux Special Edition OS</a></li>
<li><a href="../fr461693/index.html">Compilation crois√©e d'OpenCV 4 pour Raspberry Pi et BeagleBone Black</a></li>
<li><a href="../fr461695/index.html">Stage VFX</a></li>
<li><a href="../fr461697/index.html">Intelligence de la bi√®re</a></li>
<li><a href="../fr461703/index.html">Rapports de micropas dans le travail d'un programmeur</a></li>
<li><a href="../fr461707/index.html">Les Aventures des Malvari Insaisissables, Partie V: Plus de Scriptlets DDE et COM</a></li>
<li><a href="../fr461709/index.html">√Ä quoi s'attendre si vous souhaitez devenir d√©veloppeur iOS</a></li>
<li><a href="../fr461713/index.html">4 fa√ßons d'√©conomiser sur les sauvegardes cloud</a></li>
<li><a href="../fr461715/index.html">Peur et d√©go√ªt en tant que Techdir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>