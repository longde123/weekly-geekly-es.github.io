<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📬 ◽️ 👩🏽‍⚕️ 使用OpenCV创建GIF 🗃️ 👨🏽‍🍳 👨🏼‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本教程将向您展示如何使用OpenCV，Python和ImageMagick创建动画GIF。 然后结合这些方法，用OpenCV创建一个模因生成器！ 

 我们所有人都需要时常大笑。 也许找到lulza的最好方法是使用模因。 我的一些最爱： 



- 青蛙青蛙（Kermit the Frog）：“但这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用OpenCV创建GIF</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429024/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/g1/sx/hd/g1sxhdlqfra2bohbg5d7yjliv6g.gif"></div><br><br> 本教程将向您展示如何使用OpenCV，Python和ImageMagick创建动画GIF。 然后结合这些方法，用OpenCV创建一个模因生成器！ <br><br> 我们所有人都需要时常大笑。 也许找到lulza的最好方法是使用模因。 我的一些最爱： <br><br><ul><li> 青蛙青蛙（Kermit the Frog）：“但这不关我的事” </li><li> 脾气暴躁的猫 </li><li> 史诗失败 </li><li> 好家伙格雷格 </li></ul><br>  <b>但是对我个人而言，这些模因无法与“与之达成协议”模因（“与之达成协议”或“自己理解”）相提并论，本文开头给出了一个例子。</b> <br><a name="habracut"></a><br> 通常在以下情况下使用： <br><br><ol><li> 作为对不同意您已完成/说过的事情的人的回答或反对（“与之达成协议”） </li><li> 戴上眼镜就像您要离开一样，让一个人独自面对问题（“自己了解”） </li></ol><br> 几年前，我在作者的博客上读了一篇有趣的文章，我不记得如何使用计算机视觉生成此类模因。 上周我在任何地方都找不到此指南，因此，作为博客，计算机视觉专家和模因专家，我决定自己编写一个教程！  （顺便说一句，如果您不小心知道了原始出处，请告诉我，以便感谢作者<b>。UPD：</b>刚刚从Kirk Kaiser的博客<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MakeArtWithPython中</a>找到了原始文章）。 <br><br> 在OpenCV上开发模因生成器将教会我们许多宝贵的实践技能，包括： <br><br><ol><li> 使用深度学习技术的人脸检测 </li><li> 使用dlib库检测面部标志并提取眼睛区域 </li><li> 如何根据收到的信息计算眼睛之间的旋转角度 </li><li> 最后，如何使用OpenCV生成动画GIF（在ImageMagick的帮助下） </li></ol><br> 该指南应该既有趣又有趣-同时教会您在现实世界中有用的宝贵的计算机视觉编程技能。 <br><br><h1> 使用OpenCV创建GIF </h1><br> 在指南的第一部分，我们将讨论该项目的必要条件和依赖关系，包括开发环境的正确配置。 <br><br> 然后考虑我们的OpenCV GIF生成器的项目/目录结构。 <br><br> 一旦了解了项目结构，我们将考虑：1）我们的配置文件；  2）Python脚本，负责使用OpenCV创建GIF。 <br><br> 最后，我们将根据流行的模因“ Deal With It”评估该计划的结果。 <br><br><h4> 先决条件和依赖项 </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/ad6/c3e/193/ad6c3e193373bc04c877e60070d73071.png"><br>  <b>图</b>  <b>1.我们将使用OpenCV，dlib和ImageMagick创建GIF</b> <br><br><h3>  Opencv和dlib </h3><br> 需要OpenCV来确定帧中的面孔和基本的图像处理。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如果</a>系统上未安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenCV，请</a>遵循我的一份<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenCV安装指南</a> 。 <br><br> 我们使用Dlib来检测面部标志，这使我们能够在脸上找到两只眼睛并戴上太阳镜。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用此指令安装dlib</a> 。 <br><br><h4> 影像魔术师 </h4><br> 如果您不熟悉<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ImageMagick</a> ，那就白费了。 它是具有许多图像处理功能的跨平台命令行工具。 <br><br> 您是否要使用一个命令将PNG / JPG转换为PDF？ 没问题 <br><br> 您需要从几张图像中制作多页PDF？ 轻松一点 <br><br> 需要绘制多边形，直线和其他形状吗？ 这是可能的。 <br><br> 如何使用一个命令对所有图片进行批处理颜色分级或调整其大小？ 为此，您无需在Python中为OpenCV编写几行。 <br><br>  ImageMagick还可以从任何图像生成GIF。 <br><br> 要在Ubuntu（或Raspbian）上安装ImageMagick，只需使用apt： <br><br> 使用OpenCVShell创建GIF <br><br><pre><code class="bash hljs">$ sudo apt-get install imagemagick</code> </pre> <br> 在macOS上，您可以使用HomeBrew： <br><br><pre> <code class="bash hljs">$ brew install imagemagick</code> </pre> <br><h4> 不实用 </h4><br> 在大多数文章，课程和书籍中，我都使用方便的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">imutils</a>图像处理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">包</a> 。 它使用pip安装在系统或虚拟环境中： <br><br><pre> <code class="bash hljs">$ pip install imutils</code> </pre> <br><h2> 项目结构 </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e42/281/af0/e42281af07fb94c9ae60a526098f662d.png"><br>  <i><font color="gray">图</font></i>  <i><font color="gray">2.项目结构包括两个目录，一个配置文件和一个Python脚本</font></i> <br><br> 我们的项目中有两个目录： <br><br><ul><li>  <code>images/</code> ：我们要为其制作动画GIF的输入图像的示例。 我发现了一些图像，但可以随意添加自己的图像。 </li><li>  <code>assets/</code> ：此文件夹包含我们的脸部检测器，脸部界标检测器以及所有图像和相关蒙版。 有了这些资产，我们将把点和文本放在第一个文件夹中的原始图像上。 </li></ul><br> 由于大量的可配置参数，我决定创建一个JSON配置文件，该文件：1）将有助于参数的编辑；  2）将需要更少的命令行参数。 该项目所需的所有配置参数都包含在<code>config.json</code> 。 <br><br> 考虑<code>config.json</code>和<code>create_gif.py</code>的内容。 <br><br><a name="1"></a>  <font color="gray">注意事项</font>  <font color="gray">每。： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">注册后将</a>发布有关计算机视觉，机器学习和OpenCV的项目代码和17页的手册（镜像： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源代码</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">manual</a> ）。</font> <br><br><h2> 使用OpenCV生成GIF </h2><br> 因此，让我们继续并开始创建我们的OpenCV GIF生成器！ <br><br><h4>  JSON配置文件内容 </h4><br> 让我们从JSON配置文件开始，然后继续使用Python脚本。 <br><br> 打开一个新的<code>config.json</code>文件，并插入以下键/值对： <br><br> 使用OpenCVPython创建GIF <br><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"face_detector_prototxt"</span></span>: <span class="hljs-string"><span class="hljs-string">"assets/deploy.prototxt"</span></span>, <span class="hljs-string"><span class="hljs-string">"face_detector_weights"</span></span>: <span class="hljs-string"><span class="hljs-string">"assets/res10_300x300_ssd_iter_140000.caffemodel"</span></span>, <span class="hljs-string"><span class="hljs-string">"landmark_predictor"</span></span>: <span class="hljs-string"><span class="hljs-string">"assets/shape_predictor_68_face_landmarks.dat"</span></span>,</code> </pre> <br> 这些是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">深度学习</a>中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenCV人脸检测器</a>模型文件。 <br><br> 最后一行是dlib人脸预测器的路径。 <br><br> 现在，我们有了一些图像文件的路径： <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"sunglasses"</span></span>: <span class="hljs-string"><span class="hljs-string">"assets/sunglasses.png"</span></span>, <span class="hljs-string"><span class="hljs-string">"sunglasses_mask"</span></span>: <span class="hljs-string"><span class="hljs-string">"assets/sunglasses_mask.png"</span></span>, <span class="hljs-string"><span class="hljs-string">"deal_with_it"</span></span>: <span class="hljs-string"><span class="hljs-string">"assets/deal_with_it.png"</span></span>, <span class="hljs-string"><span class="hljs-string">"deal_with_it_mask"</span></span>: <span class="hljs-string"><span class="hljs-string">"assets/deal_with_it_mask.png"</span></span>,</code> </pre> <br> 这些是我们的太阳镜，文本和与之匹配的蒙版的路径，如下所示。 <br><br> 首先，花式太阳镜和口罩： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/c4c/647/c18c4c6471e203aedea66a80c9080192.png"></div><br>  <i><font color="gray">图</font></i>  <i><font color="gray">3.您不喜欢带像素的眼镜吗？</font></i>  <i><font color="gray">刚忍受</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58b/91a/d9c/58b91ad9c2e66238b3f3ac22fe1ee439.png"></div><br>  <i><font color="gray">图</font></i>  <i><font color="gray">4.您不明白为什么需要戴太阳眼镜的口罩？</font></i>  <i><font color="gray">只需忍受它-或阅读本文的其余部分以获取答案。</font></i> <br><br> 现在我们的文字是“ DEAL WITH IT”和掩码： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec3/4e4/923/ec34e4923e2d05a5b33c065de8f5af66.png"></div><br>  <i><font color="gray">图</font></i>  <i><font color="gray">5.您讨厌Helvetica Neue Condensed吗？</font></i>  <i><font color="gray">处理它</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6c/f70/819/c6cf708198bda68d849029b3ded02265.png"></div><br>  <i><font color="gray">图</font></i>  <i><font color="gray">6：使用此遮罩可以在文本周围绘制边框。</font></i>  <i><font color="gray">哦，也许您不想，想要边界吗？</font></i>  <i><font color="gray">好吧，忍受它</font></i> <br><br> 需要使用遮罩才能将相应的图像覆盖在照片上：我们将在以后处理。 <br><br> 现在为模因生成器设置一些参数： <br><br><pre> <code class="python hljs"> <span class="hljs-string"><span class="hljs-string">"min_confidence"</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">"steps"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-string"><span class="hljs-string">"delay"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"final_delay"</span></span>: <span class="hljs-number"><span class="hljs-number">250</span></span>, <span class="hljs-string"><span class="hljs-string">"loop"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"temp_dir"</span></span>: <span class="hljs-string"><span class="hljs-string">"temp"</span></span> }</code> </pre> <br> 以下是每个参数的定义： <br><br><ul><li>  <code>min_confidence</code> ：所需的最小面部检测概率。 </li><li>  <code>steps</code> ：最终动画中的帧数。 每个“步骤”都将太阳镜从上边界向下移动到目标（即，眼睛）。 </li><li>  <code>delay</code> ：帧之间的延迟，以百分之一秒为单位。 </li><li>  <code>final_delay</code> ：最后一帧的延迟，以百分之一秒为单位（在此情况下很有用，因为我们希望文本显示的时间比其余帧的显示时间长）。 </li><li>  <code>loop</code> ：零值表示GIF永远重复，否则为动画的重复次数指定一个正整数。 </li><li>  <code>temp_dir</code> ：创建最终GIF之前将在其中存储每个帧的临时目录。 </li></ul><br><h4> 模因，GIF和OpenCV </h4><br> 我们创建了JSON配置文件，现在让我们继续进行实际代码。 <br><br> 打开一个新文件，将其命名为<code>create_gif.py</code>并粘贴以下代码： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    from imutils import face_utils from imutils import paths import numpy as np import argparse import imutils import shutil import json import dlib import cv2 import sys import os</span></span></code> </pre> <br> 在这里，我们导入必要的包。 特别是，我们将使用imutils，dlib和OpenCV。 要安装这些依赖项，请参阅上面的“先决条件和依赖项”部分。 <br><br> 现在该脚本具有必需的包，因此<code>overlay_image</code>定义<code>overlay_image</code>函数： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">overlay_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bg, fg, fgMask, coords)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     (, )  #    (sH, sW) = fg.shape[:2] (x, y) = coords #          #  ,   , **  # ,    overlay = np.zeros(bg.shape, dtype="uint8") overlay[y:y + sH, x:x + sW] = fg # - , **  ** # ,    ,    # ,       alpha = np.zeros(bg.shape[:2], dtype="uint8") alpha[y:y + sH, x:x + sW] = fgMask alpha = np.dstack([alpha] * 3) #  -   , #   - output = alpha_blend(overlay, bg, alpha) #   return output</span></span></code> </pre> <br>  <code>overlay_image</code>函数在<code>coords</code>坐标<i>（</i>坐标<i>（x，y）</i> ）处在背景图像（ <code>bg</code> ）的顶部强加一个前景（ <code>fg</code> ），从而在前景蒙版<code>fgMask</code>实现了alpha透明性。 <br><br> 要熟悉OpenCV的基础知识（例如使用遮罩），请务必阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本指南</a> 。 <br><br> 要完成混合过程，请执行Alpha混合： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alpha_blend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fg, bg, alpha)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#  ,    - #        [0, 1] fg = fg.astype("float") bg = bg.astype("float") alpha = alpha.astype("float") / 255 #  - fg = cv2.multiply(alpha, fg) bg = cv2.multiply(1 - alpha, bg) #     ,    output = cv2.add(fg, bg) #   return output.astype("uint8")</span></span></code> </pre> <br> 该alpha混合实现也可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在LearnOpenCV博客上找到</a> 。 <br><br> 本质上，我们将前景，背景和Alpha通道转换为<i>[0，1]</i>范围内的浮点数。 然后我们执行Alpha混合，添加前景和背景以获得返回到调用函数的结果。 <br><br> 我们还将创建一个辅助函数，该函数允许使用ImageMagick和<code>convert</code>命令从一组图像路径生成GIF： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_gif</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inputPath, outputPath, delay, finalDelay, loop)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#        imagePaths = sorted(list(paths.list_images(inputPath))) #      lastPath = imagePaths[-1] imagePaths = imagePaths[:-1] #   imagemagick 'convert'  #  GIF      #   ( ) cmd = "convert -delay {} {} -delay {} {} -loop {} {}".format( delay, " ".join(imagePaths), finalDelay, lastPath, loop, outputPath) os.system(cmd)</span></span></code> </pre> <br>  <code>create_gif</code>函数获取一组图像并将其收集到GIF动画中，并在帧和循环之间具有指定的延迟。  ImageMagick处理所有这一切-我们仅将<code>convert</code>命令包装在一个动态处理各种参数的函数中。 <br><br> 要查看可用的<code>convert</code>参数， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请参阅文档</a> 。 在这里，您将看到这个团队有多少功能！ <br><br> 特别是在此功能中，我们： <br><br><ul><li> 采取<code>imagePaths</code> 。 </li><li> 选择最后一张图像的路径，它将有一个单独的延迟。 </li><li> 重新分配<code>imagePaths</code>以排除最后一个路径。 </li><li> 我们将命令与命令行参数组合在一起，然后指示操作系统进行<code>convert</code>以创建GIF动画。 </li></ul><br> 为脚本分配自己的命令行参数： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ap = argparse.ArgumentParser() ap.add_argument("-c", "--config", required=True, help="path to configuration file") ap.add_argument("-i", "--image", required=True, help="path to input image") ap.add_argument("-o", "--output", required=True, help="path to output GIF") args = vars(ap.parse_args())</span></span></code> </pre> <br> 我们有三个在运行时处理的命令行参数： <br><br><ul><li>  <code>--config</code> ：JSON配置文件的路径。 我们在上一节中回顾了配置文件。 </li><li>  <code>--image</code> ：创建动画所依据的输入图像的路径（即检测面部，戴墨镜，然后输入文本）。 </li><li>  <code>--output</code> ：生成的GIF的路径。 </li></ul><br> 在命令行/终端上运行脚本时，每个参数都是必需的。 <br><br> 下载配置文件以及眼镜和相应的掩码： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    JSON, #     config = json.loads(open(args["config"]).read()) sg = cv2.imread(config["sunglasses"]) sgMask = cv2.imread(config["sunglasses_mask"]) #    (  ),   #  ,  ,     #   GIF- shutil.rmtree(config["temp_dir"], ignore_errors=True) os.makedirs(config["temp_dir"])</span></span></code> </pre> <br> 在这里，我们加载配置文件（将来可能会作为Python词典提供）。 然后装入墨镜和口罩。 <br><br> 如果以前的脚本中仍然有其他内容，请删除临时目录，然后重新创建空的临时目录。 临时文件夹将包含GIF动画中的每个单独的帧。 <br><br> 现在将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenCV深度学习人脸检测器</a>加载到内存中： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># load our OpenCV face detector and dlib facial landmark predictor print("[INFO] loading models...") detector = cv2.dnn.readNetFromCaffe(config["face_detector_prototxt"], config["face_detector_weights"]) predictor = dlib.shape_predictor(config["landmark_predictor"])</span></span></code> </pre> <br> 为此，请调用<code>cv2.dnn.readNetFromCaffe</code> 。  <code>dnn</code>模块仅在OpenCV 3.3或更高版本中可用。 人脸检测器将检测图像中是否存在人脸： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a91/d3a/0cd/a91d3a0cde3dcb3cac9799c823e47c8c.jpg"><br>  <i><font color="gray">图</font></i>  <i><font color="gray">7.使用OpenCV DNN进行面部检测器操作</font></i> <br><br> 然后加载<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dlib人脸界标预测器</a> 。 它使您可以定位单个结构：眼睛，眉毛，鼻子，嘴巴和下巴线： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/056/816/890/0568168909b7f01d2f70f6e58faa9ed9.jpg"><br>  <i><font color="gray">图</font></i>  <i><font color="gray">8. dlib发现的地标叠加在我的脸上</font></i> <br><br> 在此脚本的后面，我们仅提取眼睛区域。 <br><br> 继续前进，让我们找到面孔： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       image = cv2.imread(args["image"]) (H, W) = image.shape[:2] blob = cv2.dnn.blobFromImage(cv2.resize(image, (300, 300)), 1.0, (300, 300), (104.0, 177.0, 123.0)) #        print("[INFO] computing object detections...") detector.setInput(blob) detections = detector.forward() #       ,  #  ,      i = np.argmax(detections[0, 0, :, 2]) confidence = detections[0, 0, i, 2] #    if confidence &lt; config["min_confidence"]: print("[INFO] no reliable faces found") sys.exit(0)</span></span></code> </pre> <br> 在此块中，我们执行以下操作： <br><br><ul><li> 下载原始<code>image</code> 。 </li><li> 我们构造一个<code>blob</code>以发送到神经网络的面部检测器。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>介绍了OpenCV中的<code>blobFromImage</code>如何工作。 </li><li> 执行面部检测程序。 </li><li> 我们找到具有最高概率值的人，并将其与最小可接受概率阈值进行比较。 如果不符合条件，则退出脚本。 否则，请继续。 </li></ul><br> 现在，我们将提取人脸并计算界标： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   (x, y)  #    box = detections[0, 0, i, 3:7] * np.array([W, H, W, H]) (startX, startY, endX, endY) = box.astype("int") #    dlib    #       rect = dlib.rectangle(int(startX), int(startY), int(endX), int(endY)) shape = predictor(image, rect) shape = face_utils.shape_to_np(shape) #        ,  #     (lStart, lEnd) = face_utils.FACIAL_LANDMARKS_IDXS["left_eye"] (rStart, rEnd) = face_utils.FACIAL_LANDMARKS_IDXS["right_eye"] leftEyePts = shape[lStart:lEnd] rightEyePts = shape[rStart:rEnd]</span></span></code> </pre> <br> 要提取脸部并找到脸部界标，请执行以下操作： <br><br><ul><li> 我们提取脸部周围的边界框的坐标。 </li><li> 在dlib中创建一个<code>rectangle</code>对象并应用面本地化。 </li><li> 我们分别获取<code>leftEyePts</code>和<code>rightEyePts</code>的<i>（x，y）</i>坐标。 </li></ul><br> 给定眼睛的坐标，您可以计算出放置太阳镜的位置和方式： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       leftEyeCenter = leftEyePts.mean(axis=0).astype("int") rightEyeCenter = rightEyePts.mean(axis=0).astype("int") #      dY = rightEyeCenter[1] - leftEyeCenter[1] dX = rightEyeCenter[0] - leftEyeCenter[0] angle = np.degrees(np.arctan2(dY, dX)) - 180 #      ,  #      sg = imutils.rotate_bound(sg, angle) #     **  ,    #   —       # 90%       sgW = int((endX - startX) * 0.9) sg = imutils.resize(sg, width=sgW) #      ( ,   #  ),      #     - —   #       , #     sgMask = cv2.cvtColor(sgMask, cv2.COLOR_BGR2GRAY) sgMask = cv2.threshold(sgMask, 0, 255, cv2.THRESH_BINARY)[1] sgMask = imutils.rotate_bound(sgMask, angle) sgMask = imutils.resize(sgMask, width=sgW, inter=cv2.INTER_NEAREST)</span></span></code> </pre> <br> 首先，我们计算每只眼睛的中心，然后计算质心之间的角度。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">框架中的面部</a>水平<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对齐时</a>执行相同的操作。 <br><br> 现在，您可以旋转眼镜并调整其大小。 请注意，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>不是<code>rotate</code> ，而是<code>rotate</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">绑定函数</a> ，因此OpenCV不会修剪仿射变换后不可见的部分。 <br><br> 应用于眼镜的相同操作也适用于面罩。 但是首先，您需要将其转换为灰色阴影并进行二值化处理，因为遮罩始终是二进制的。 然后，我们以与眼镜相同的方式旋转并调整蒙版的大小。 <br><br>  <i><b>注意：</b>请注意，在调整遮罩大小时，我们对最近的相邻点使用插值，因为遮罩应该只有两个值（0和255）。</i>  <i>其他插值方法更美观，但不适用于蒙版。</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里，</a>您可以获得有关最近邻点插值的更多信息。</i> <br><br> 剩下的三个代码块为GIF动画创建框架： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    ,   #  N       #    steps = np.linspace(0, rightEyeCenter[1], config["steps"], dtype="int") # start looping over the steps for (i, y) in enumerate(steps): #      #  ,    **    #  ,       #   shiftX = int(sg.shape[1] * 0.25) shiftY = int(sg.shape[0] * 0.35) y = max(0, y - shiftY) # add the sunglasses to the image output = overlay_image(image, sg, sgMask, (rightEyeCenter[0] - shiftX, y))</span></span></code> </pre> <br> 眼镜从图像顶部掉落。 在每帧上，它们都靠近脸部显示，直到遮住眼睛为止。 使用JSON配置文件中的<code>"steps"</code>变量，我们为每个框架生成y坐标。 为此，我们无需花费太多精力即可使用NumPy的<code>linspace</code>函数。 <br><br> 从左到右稍微偏移的线条可能看起来有些奇怪，但是需要确保眼镜能覆盖整个眼睛，而不仅仅是移动到眼睛中心的位置。 我凭经验确定百分比以计算沿每个轴的偏移量。 下一行确保没有负值。 <br><br> 使用<code>overlay_image</code>函数， <code>overlay_image</code>生成最终的<code>output</code>帧。 <br><br> 现在，使用另一个蒙版应用文本“ DEAL WITH IT”： <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#    ,    #  "DEAL WITH IT"   if i == len(steps) - 1: #   "DEAL WITH IT"  , #   dwi = cv2.imread(config["deal_with_it"]) dwiMask = cv2.imread(config["deal_with_it_mask"]) dwiMask = cv2.cvtColor(dwiMask, cv2.COLOR_BGR2GRAY) dwiMask = cv2.threshold(dwiMask, 0, 255, cv2.THRESH_BINARY)[1] #       80%   #  oW = int(W * 0.8) dwi = imutils.resize(dwi, width=oW) dwiMask = imutils.resize(dwiMask, width=oW, inter=cv2.INTER_NEAREST) #  ,   ,  #   oX = int(W * 0.1) oY = int(H * 0.8) output = overlay_image(output, dwi, dwiMask, (oX, oY))</span></span></code> </pre> <br> 在最后一步，我们强加了文本，实际上是另一幅图像。 <br><br> 我决定使用图像，因为OpenCV字体的渲染功能非常有限。 另外，我想在文本周围添加阴影和边框，这也是OpenCV不知道的方法。 <br><br> 在此代码的其余部分中，我们将同时加载图像和蒙版，然后执行alpha混合以生成最终结果。 <br><br> 剩下的只是将每个帧保存到磁盘，并随后创建GIF动画： <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#      p = os.path.sep.join([config["temp_dir"], "{}.jpg".format( str(i).zfill(8))]) cv2.imwrite(p, output) #      ,     #   GIF- print("[INFO] creating GIF...") create_gif(config["temp_dir"], args["output"], config["delay"], config["final_delay"], config["loop"]) #  --    print("[INFO] cleaning up...") shutil.rmtree(config["temp_dir"], ignore_errors=True)</span></span></code> </pre> <br> 我们将结果写入磁盘。 生成所有帧后，我们调用<code>create_gif</code>函数来创建GIF动画文件。 请记住，这是一个将参数传递给ImageMagick <code>convert</code>命令行工具的外壳。 <br><br> 最后，删除临时输出目录和单个图像文件。 <br><br><h2> 结果 </h2><br> 现在最有趣的部分：让我们看看我们的模因生成器创建了什么！ <br><br> 确保<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载</a>源代码，示例图像和深度学习模型。 然后打开一个终端并运行以下命令： <br><br><pre> <code class="bash hljs">$ python create_gif.py --config config.json --image images/adrian.jpg \ --output adrian_out.gif [INFO] loading models... [INFO] computing object detections... [INFO] creating GIF... [INFO] cleaning up...</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/dca/b24/46e/dcab2446ec5dc96065e37a473375eea6.gif"><br>  <i><font color="gray">图9.使用此Python脚本由OpenCV和ImageMagick生成的GIF动画</font></i> <br><br> 在这里，您可以看到使用OpenCV和ImageMagick创建的GIF。 在其上执行以下操作： <br><br><ol><li> 正确检测我的脸。 </li><li> 眼睛的定位及其中心的计算。 </li><li> 眼镜正确落在脸上。 </li></ol><br> 我博客的读者知道我是侏罗纪公园的一个大书呆子，经常在我的书，课程和学习指南中提到它。 <br><br> 不喜欢<i>侏罗纪公园</i>吗？ <br><br> 好的，这是我的答案： <br><br><pre> <code class="bash hljs">$ python create_gif.py --config config.json --image images/adrian_jp.jpg \ --output adrian_jp_out.gif [INFO] loading models... [INFO] computing object detections... [INFO] creating GIF... [INFO] cleaning up...</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/da9/0d7/740/da90d7740e8ac813b9f99a727b9e04bc.gif"><br>  <i><font color="gray">图</font></i>  <i><font color="gray">10. OpenCV GIF动画基于最近侏罗纪世界2放映中的照片</font></i> <br><br> 在这里，我身着主题T恤参加了展览《侏罗纪世界：2》，上面放着一杯光，还有一本收藏书。 <br><br> 有趣的故事： <br><br> 五六年前，我和我的妻子参观了佛罗里达迪斯尼世界的Epcot中心主题公园。 <br><br> 我们决定出差，以摆脱康涅狄格州严酷的冬季和急需的阳光。 <br><br> 不幸的是，在佛罗里达州一直下着雨，温度几乎不超过10°C。 <br><br> 在加拿大花园附近，特丽莎（Trisha）拍了一张我的照片：她说我看上去像个吸血鬼，皮肤苍白，深色衣服和兜帽，背后是郁郁葱葱的花园： <br><br><pre> <code class="bash hljs">$ python create_gif.py --config config.json --image images/vampire.jpg \ --output vampire_out.gif [INFO] loading models... [INFO] computing object detections... [INFO] creating GIF... [INFO] cleaning up...</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/ad1/1ce/ca2/ad11ceca2ed48792a5aa28c0c8dc7f40.gif"><br>  <i><font color="gray">图</font></i>  <i><font color="gray">11.使用OpenCV和Python，您可以制作此模因或其他动画GIF</font></i> <br><br> 当天晚上，Trisha在社交网络上发布了一张照片-我不得不忍受。 <br><br> 参加了PyImageConf 2018的那些人（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阅读评论</a> ）知道我总是很喜欢开玩笑。 这是一个例子： <br><br>  <i>问题：为什么公鸡过马路？</i> <br><br><pre> <code class="bash hljs">$ python create_gif.py --config config.json --image images/rooster.jpg \ --output rooster_out.gif [INFO] loading models... [INFO] computing object detections... [INFO] creating GIF... [INFO] cleaning up...</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/5dd/e92/ef0/5dde92ef04cb35436e87b0b70cc5926d.gif"><br>  <i><font color="gray">图</font></i> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12.即使对比度低也可以识别出脸部，OpenCV会正确处理照片并</font></font></font></i> <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">放下</font></font></i> <font style="vertical-align: inherit;"><i><font color="gray"><font style="vertical-align: inherit;">墨镜</font></font></i><i><font style="vertical-align: inherit;">答案：我不会说答案-对此表示赞同。</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我们以良好的模因总结了本指南。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大约六年前，我和父亲收养了一只小猎犬吉玛。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，您可以看到Gemma在我的肩膀上：</font></font><br><br><pre> <code class="bash hljs">$ python create_gif.py --config config.json --image images/pupper.jpg \ --output pupper_out.gif [INFO] loading models... [INFO] computing object detections... [INFO] creating GIF... [INFO] cleaning up...</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/08a/b5a/728/08ab5a728e8bd48ac2550a2962e76165.gif"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图 </font><font style="vertical-align: inherit;">13. Gemma很好吃。</font><font style="vertical-align: inherit;">你不这样认为吗 </font><font style="vertical-align: inherit;">然后“顺其自然！” </font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同意她是可爱的吗？</font><font style="vertical-align: inherit;">处理它。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 有AttributeError错误吗？ </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不用担心！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果看到此错误：</font></font><br><br><pre> <code class="bash hljs">$ python create_gif.py --config config.json --image images/adrian.jpg \ --output adrian_out.gif ... Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"create_gif.py"</span></span>, line 142, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; (lStart, lEnd) = face_utils.FACIAL_LANDMARKS_IDXS[<span class="hljs-string"><span class="hljs-string">"left_eye"</span></span>] AttributeError: module <span class="hljs-string"><span class="hljs-string">'imutils.face_utils'</span></span> has no attribute <span class="hljs-string"><span class="hljs-string">'FACIAL_LANDMARKS_IDXS'</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ...那么您只需要更新imutils软件包： </font></font><br><br><pre> <code class="bash hljs">$ pip install --upgrade imutils Collecting imutils ... Successfully installed imutils-0.5.1</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">怎么了 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，它</font></font><code>imutils.face_utils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用内置于dlib中的68点地标检测器（如本文所述）。</font><font style="vertical-align: inherit;">有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个更快的5点检测器</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，现在也可以与imutils一起使用。</font><font style="vertical-align: inherit;">我最近更新了imutils以支持两个检测器（因此您可能会看到错误）。</font></font><br><br><h1> 总结 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在今天的教程中，您学习了如何使用OpenCV创建GIF。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使课程有趣，我们使用OpenCV生成了GIF动画“ Deal With It”，这是一个流行的模因（也是我的最爱），在几乎每个社交网站上都以一种或另一种形式出现。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此过程中，我们使用计算机视觉和深度学习解决了一些实际问题：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 身份识别 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 预测脸上的地标 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 识别面部区域（在这种情况下为眼睛） </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 计算眼睛之间的角度以对齐脸部 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用Alpha混合创建透明混合 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我们拍摄了一组生成的图像，并使用OpenCV和ImageMagick创建了动画GIF。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">希望您喜欢今天的教程！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您喜欢它，请发表评论，让我知道。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，如果您不喜欢它，没关系，就忍受它。</font></font> ;） </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN429024/">https://habr.com/ru/post/zh-CN429024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN429014/index.html">Git子树详细</a></li>
<li><a href="../zh-CN429016/index.html">沃尔沃和百度将共同开发无人驾驶汽车</a></li>
<li><a href="../zh-CN429018/index.html">为什么新的Gmail设计这么慢？</a></li>
<li><a href="../zh-CN429020/index.html">什么是流利的二传手</a></li>
<li><a href="../zh-CN429022/index.html">GridGain on Highload：在哪里可以讨论分布式DBMS，内存中和开源</a></li>
<li><a href="../zh-CN429028/index.html">科罗廖夫。 网络医学</a></li>
<li><a href="../zh-CN429030/index.html">Logomachine为每个评论提供免费徽标</a></li>
<li><a href="../zh-CN429032/index.html">Splunk Essentials for Financial Services Industry App，或Splunk如何进入金融分析市场</a></li>
<li><a href="../zh-CN429034/index.html">关于地下程序员的一些故事</a></li>
<li><a href="../zh-CN429036/index.html">相信我，我知道我在做什么：模块化机器人对任务执行环境的自适应</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>