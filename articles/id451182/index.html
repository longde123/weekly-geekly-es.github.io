<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ¤ ğŸ‘¨ğŸ¾â€ğŸ’¼ ğŸˆ¶ Bagaimana ukuran array C menjadi bagian dari antarmuka biner perpustakaan âœğŸ½ ğŸ‘§ğŸ» ğŸ‘¨ğŸ»â€ğŸš’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kebanyakan kompiler C memungkinkan Anda untuk mengakses array extern dengan batas yang tidak ditentukan, misalnya: 



 extern int external_array[]; i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana ukuran array C menjadi bagian dari antarmuka biner perpustakaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451182/"> Kebanyakan kompiler C memungkinkan Anda untuk mengakses array <code>extern</code> dengan batas yang tidak ditentukan, misalnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_get</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> external_array[index]; }</code> </pre> <br>  Definisi external_array mungkin ada di unit terjemahan lain dan mungkin terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Pertanyaannya adalah apa yang terjadi jika definisi yang terpisah ini berubah seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br>  Atau lebih: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <a name="habracut"></a><br>  Akankah antarmuka biner dipertahankan (asalkan ada mekanisme yang memungkinkan aplikasi untuk menentukan ukuran array pada saat run time)? <br><br>  Anehnya, pada banyak arsitektur, <i>meningkatkan ukuran array</i> melanggar kompatibilitas antarmuka biner (ABI).  Mengurangi ukuran array juga dapat menyebabkan masalah kompatibilitas.  Pada artikel ini, kita akan melihat lebih dekat kompatibilitas ABI dan menjelaskan cara menghindari masalah. <br><br><h1>  Tautan di bagian data dari file yang dapat dieksekusi </h1><br>  Untuk memahami bagaimana ukuran array menjadi bagian dari antarmuka biner, pertama-tama kita perlu memeriksa tautan di bagian data dari file yang dapat dieksekusi.  Tentu saja, detailnya tergantung pada arsitektur spesifik, dan di sini kita akan fokus pada arsitektur x86-64. <br><br>  Arsitektur x86-64 mendukung pengalamatan relatif terhadap penghitung program, yaitu akses ke variabel array global, seperti pada fungsi <code>array_get</code> ditunjukkan sebelumnya, dapat dikompilasi menjadi instruksi <code>movl</code> tunggal: <br><br><pre> <code class="cpp hljs">array_get: <span class="hljs-function"><span class="hljs-function">movl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">external_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(,%rdi,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, %eax ret</span></span></code> </pre> <br>  Dari ini, assembler membuat file objek di mana instruksi ditandai sebagai <code>R_X86_64_32S</code> . <br><br><pre> <code class="plaintext hljs">0000000000000000 : 0: mov 0x0(,%rdi,4),%eax 3: R_X86_64_32S external_array 7: retq</code> </pre> <br>  Langkah ini memberi tahu linker ( <code>ld</code> ) cara mengisi lokasi yang sesuai dari variabel <code>external_array</code> selama menautkan saat membuat executable. <br><br>  Ini memiliki dua konsekuensi penting. <br><br><ul><li>  Karena offset variabel ditentukan pada waktu pembangunan, pada waktu berjalan tidak ada overhead untuk menentukannya.  Satu-satunya harga adalah akses ke memori itu sendiri. <br></li><li>  Untuk menentukan offset, Anda perlu mengetahui ukuran semua data variabel.  Kalau tidak, tidak mungkin untuk menghitung format bagian data selama tata letak. </li></ul><br>  Untuk implementasi C yang berorientasi pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Executable dan Link Format (ELF)</a> , seperti pada GNU / Linux, referensi ke variabel <code>extern</code> tidak mengandung ukuran objek.  Dalam contoh <code>array_get</code> ukuran objek tidak diketahui bahkan oleh kompiler.  Faktanya, seluruh file assembler terlihat seperti ini (hanya mengabaikan informasi promosi dari <code>-fno-asynchronous-unwind-tables</code> , yang secara teknis diperlukan untuk kepatuhan psABI): <br><br><pre> <code class="plaintext hljs"> .file "get.c" .text .p2align 4,,15 .globl array_get .type array_get, @function array_get: movl external_array(,%rdi,4), %eax ret .size array_get, .-array_get .ident "GCC: (GNU) 8.3.1 20190223 (Red Hat 8.3.1-2)" .section .note.GNU-stack,"",@progbits</code> </pre> <br>  Tidak ada informasi ukuran untuk <code>external_array</code> dalam file assembler ini: referensi karakter hanya pada baris dengan instruksi <code>movl</code> , dan satu-satunya data numerik dalam instruksi adalah ukuran elemen array (tersirat oleh <code>movl</code> dikalikan dengan 4). <br><br>  Jika ELF memerlukan ukuran untuk variabel yang tidak terdefinisi, maka bahkan tidak mungkin untuk mengkompilasi fungsi <code>array_get</code> . <br><br>  Bagaimana linker mendapatkan ukuran karakter yang sebenarnya?  Dia melihat definisi simbol dan menggunakan informasi ukuran yang dia temukan di sana.  Ini memungkinkan kompiler untuk menghitung tata letak bagian data dan mengisi gerakan data dengan offset yang sesuai. <br><br><h1>  Objek ELF Umum </h1><br>  Implementasi C untuk ELF tidak mengharuskan programmer untuk menambahkan markup kode sumber untuk menunjukkan apakah suatu fungsi atau variabel terletak di objek saat ini (yang mungkin perpustakaan atau executable utama) atau di objek lain.  Tautan dan pemuat dinamis akan menangani ini. <br><br>  Pada saat yang sama, ada keinginan untuk file yang dapat dieksekusi untuk tidak mengurangi kinerja dengan mengubah model kompilasi.  Ini berarti bahwa ketika mengkompilasi kode sumber untuk program utama (yaitu, tanpa <code>-fPIC</code> , dan dalam kasus khusus ini tanpa <code>-fPIE</code> ), fungsi <code>array_get</code> dikompilasi ke <i>dalam</i> urutan perintah yang <i>persis sama</i> sebelum memperkenalkan objek dinamis yang dibagikan.  Selain itu, tidak masalah jika variabel <code>external_array</code> didefinisikan dalam file yang paling dasar yang dapat dieksekusi atau apakah ada objek bersama yang dimuat secara terpisah pada saat dijalankan.  Instruksi yang dibuat oleh kompiler sama dalam kedua kasus. <br><br>  Bagaimana ini mungkin?  Bagaimanapun, objek ELF umum adalah posisi-independen.  Mereka dimuat di <i>alamat acak yang tidak dapat diprediksi</i> saat runtime.  Namun, kompiler menghasilkan urutan kode mesin yang mengharuskan variabel-variabel ini ditempatkan pada <i>offset tetap yang dihitung selama penautan</i> , jauh sebelum program dimulai. <br><br>  Faktanya adalah bahwa hanya satu objek yang dimuat (file yang dapat dieksekusi utama) menggunakan offset tetap ini.  Semua objek lain (pemuat dinamis itu sendiri, pustaka runtime C, dan pustaka lain yang digunakan oleh program) dikompilasi dan dikompilasi sebagai objek yang sepenuhnya bebas posisi (PICs).  Untuk objek seperti itu, kompiler memuat alamat aktual setiap variabel dari tabel offset global (GOT).  Kita dapat melihat bundaran ini jika kita mengkompilasi contoh <code>-fPIC</code> dengan <code>-fPIC</code> , yang mengarah ke kode perakitan seperti itu: <br><br><pre> <code class="plaintext hljs">array_get: movq external_array@GOTPCREL(%rip), %rax movl (%rax,%rdi,4), %eax ret</code> </pre> <br>  Akibatnya, alamat variabel <code>external_array</code> tidak lagi hardcoded dan dapat diubah pada waktu berjalan dengan menginisialisasi catatan GOT dengan tepat.  Ini berarti bahwa pada saat dijalankan, definisi <code>external_array</code> dapat berada di objek bersama yang sama, objek bersama lainnya, atau program utama.  Loader dinamis akan menemukan definisi yang sesuai berdasarkan aturan pencarian karakter ELF dan menghubungkan referensi simbol yang tidak terdefinisi dengan definisi dengan memperbarui catatan GOT ke alamat sebenarnya. <br><br>  Kami kembali ke contoh asli, di mana fungsi <code>array_get</code> dalam program utama, sehingga alamat variabel ditentukan secara langsung.  Gagasan kunci yang diterapkan dalam tautan adalah bahwa program utama akan memberikan definisi variabel <code>external_array</code> , <i>bahkan jika itu sebenarnya didefinisikan dalam objek umum saat runtime</i> .  Alih-alih menentukan definisi awal variabel dalam objek bersama, loader dinamis akan memilih <i>salinan</i> variabel di bagian data file yang dapat dieksekusi. <br><br>  Ini memiliki dua konsekuensi penting.  Pertama-tama, ingat bahwa <code>external_array</code> didefinisikan sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Ada penginisialisasi di sini yang harus diterapkan pada definisi dalam file utama yang dapat dieksekusi.  Untuk melakukan ini, dalam file yang dapat dieksekusi utama, sebuah tautan ke lokasi salin dari simbol ditempatkan.  Perintah <code>readelf -rW</code> menunjukkannya sebagai memindahkan <code>R_X86_64_COPY</code> . <br><br><pre>  Bagian relokasi '.rela.dyn' pada offset 0x408 berisi 3 entri:
     Jenis Info Offset Nilai Simbol Nilai Simbol Nama + Tambah
 0000000000403ff0 0000000100000006 R_X86_64_GLOB_DAT 000000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
 0000000000403ff8 0000000200000006 R_X86_64_GLOB_DAT 000000000000000000 __gmon_start__ + 0
 0000000000404020 0000000300000005 R_X86_64_COPY 000000000000404020 external_array + 0 </pre><br>  Seperti gerakan lainnya, gerakan salin ditangani oleh pemuat dinamis.  Ini termasuk operasi penyalinan bitwise sederhana.  Target salinan ditentukan oleh offset perpindahan ( <code>0000000000404020</code> dalam contoh).  Sumber ditentukan pada saat runtime berdasarkan pada nama simbol ( <code>external_array</code> ) dan nilainya.  Saat membuat salinan, pemuat dinamis juga akan melihat ukuran karakter untuk mendapatkan jumlah byte yang perlu disalin.  Untuk membuat semua ini mungkin, simbol <code>external_array</code> secara otomatis diekspor dari file yang dapat dieksekusi sebagai simbol tertentu sehingga terlihat oleh loader dinamis pada saat run time.  Tabel simbol dinamis ( <code>.dynsym</code> ) mencerminkan ini, seperti yang ditunjukkan oleh perintah <code>readelf -sW</code> : <br><br><pre>  Tabel simbol '.dynsym' berisi 4 entri:
    Num: Nilai Ukuran Tipe Bind Vis Ndx Name
      0: 0000000000000000 0 NOTYPE DEFAULT LOKAL UND 
      1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.2.5 (2)
      2: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__
      3: 0000000000404020 12 OBJEK DEFAULT GLOBAL 22 external_array </pre><br>  Dari mana informasi tentang ukuran objek berasal (12 byte, dalam contoh ini)?  Linker membuka semua objek umum, mencari definisi dan mengambil informasi tentang ukurannya.  Seperti sebelumnya, ini memungkinkan penghubung untuk menghitung tata letak bagian data sehingga offset tetap dapat digunakan.  Sekali lagi, ukuran definisi di executable utama adalah tetap dan tidak dapat diubah pada saat dijalankan. <br><br>  Dynamic linker juga mengalihkan tautan simbolik dalam objek yang dibagikan ke salinan yang dipindahkan di executable utama.  Ini memastikan bahwa dalam keseluruhan program hanya ada satu salinan variabel, seperti semantik bahasa C. Jika tidak, jika variabel berubah setelah inisialisasi, pembaruan dari file yang dapat dieksekusi utama tidak akan terlihat oleh objek bersama dinamis dan sebaliknya. <br><br><h1>  Dampak pada kompatibilitas biner </h1><br>  Apa yang terjadi jika kita mengubah definisi <code>external_array</code> di objek bersama tanpa menautkan (atau mengkompilasi ulang) program utama?  Pertama, pertimbangkan untuk <i>menambahkan</i> elemen array. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br>  Ini akan menghasilkan peringatan dari loader dinamis saat runtime: <br><br> <code>main-program: Symbol `external_array' has different size in shared object, consider re-linking</code> <br> <br>  Program utama masih berisi definisi <code>external_array</code> dengan ruang hanya 12 byte.  Ini berarti bahwa salinan tidak lengkap: hanya tiga elemen pertama dari array yang disalin.  Akibatnya, akses ke elemen array <code>extern_array[3]</code> tidak ditentukan.  Pendekatan ini tidak hanya mempengaruhi program utama, tetapi juga seluruh kode dalam proses, karena semua referensi ke <code>extern_array</code> diarahkan ke definisi di program utama.  Ini termasuk objek generik yang memberikan definisi <code>extern_array</code> .  Dia mungkin tidak siap untuk menghadapi situasi di mana elemen array dalam definisinya sendiri telah menghilang. <br><br>  Bagaimana dengan mengubah arah yang berlawanan, menghapus elemen? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br>  Jika program menghindari mengakses elemen array <code>extern_array[2]</code> , karena entah bagaimana mendeteksi panjang array berkurang, maka ini akan berhasil.  Setelah array, ada beberapa memori yang tidak digunakan, tetapi ini tidak akan merusak program. <br><br>  Ini artinya kita mendapatkan aturan berikut: <br><br><ul><li>  Menambahkan elemen ke variabel array global melanggar kompatibilitas biner. <br></li><li>  Menghapus item dapat merusak kompatibilitas jika tidak ada mekanisme yang menghindari akses ke item yang dihapus. </li></ul><br>  Sayangnya, peringatan loader dinamis terlihat lebih tidak berbahaya daripada yang sebenarnya, dan untuk elemen jarak jauh tidak ada peringatan sama sekali. <br><br><h1>  Bagaimana menghindari situasi ini </h1><br>  Mendeteksi perubahan ABI cukup mudah dengan alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libabigail</a> . <br><br>  Cara termudah untuk menghindari situasi ini adalah dengan mengimplementasikan fungsi yang mengembalikan alamat array: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_external_array</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_array; }</code> </pre> <br>  Jika definisi array tidak dapat dibuat statis karena cara itu digunakan di perpustakaan, sebagai gantinya kita dapat menyembunyikan visibilitasnya dan juga mencegah ekspornya dan, karenanya, menghindari masalah pemotongan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] __attribute__ ((visibility (<span class="hljs-string"><span class="hljs-string">"hidden"</span></span>))) = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Semuanya jauh lebih rumit jika variabel array diekspor karena alasan kompatibilitas ke belakang.  Karena larik dari pustaka terpotong, program utama yang lama dengan definisi larik yang lebih pendek tidak akan dapat memberikan akses ke larik lengkap untuk kode klien baru jika digunakan dengan larik global yang sama.  Sebagai gantinya, fungsi akses dapat menggunakan array yang terpisah (statis atau tersembunyi), atau mungkin array terpisah untuk elemen yang ditambahkan di akhir.  Kerugiannya adalah bahwa tidak mungkin untuk menyimpan semuanya dalam array berkelanjutan jika variabel array diekspor untuk kompatibilitas mundur.  Desain antarmuka sekunder harus mencerminkan hal ini. <br><br>  Menggunakan kontrol versi karakter, Anda dapat mengekspor beberapa versi dengan ukuran berbeda, tidak pernah mengubah ukuran dalam versi tertentu.  Menggunakan model ini, program terkait baru akan selalu menggunakan versi terbaru, mungkin dengan ukuran terbesar.  Karena versi dan ukuran simbol diperbaiki oleh editor tautan secara bersamaan, mereka selalu konsisten.  Pustaka GNU C menggunakan pendekatan ini untuk variabel historis <code>sys_errlist</code> dan <code>sys_siglist</code> .  Namun, ini masih tidak menyediakan array kontinu tunggal. <br><br>  Semua hal dipertimbangkan, fungsi accessor (misalnya, fungsi <code>get_external_array</code> atas) adalah pendekatan terbaik untuk menghindari masalah kompatibilitas ABI ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451182/">https://habr.com/ru/post/id451182/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451172/index.html">Julia: fungsi dan struktur sebagai fungsi</a></li>
<li><a href="../id451174/index.html">Adaptasi program untuk ZX Spectrum ke TR-DOS dengan cara modern. Bagian 1</a></li>
<li><a href="../id451176/index.html">Berita dari dunia OpenStreetMap No. 458 (23/4/2019 - 04/09/2019)</a></li>
<li><a href="../id451178/index.html">Tes Kecelakaan Pendaratan Parasut Kru Naga</a></li>
<li><a href="../id451180/index.html">PCB menggantikan dua motor linier</a></li>
<li><a href="../id451184/index.html">Proyek Blue Moon Blue Moon: Orang-orang di Bulan pada tahun 2024</a></li>
<li><a href="../id451186/index.html">Repositori LINSTOR dan integrasinya dengan OpenNebula</a></li>
<li><a href="../id451188/index.html">Sberbank atau di sana dan kembali</a></li>
<li><a href="../id451196/index.html">Pemisahan profil pelanggan dan freelancer</a></li>
<li><a href="../id451198/index.html">Peran Augmented Reality Dan Virtual Reality Di NBA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>