<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚑 📅 🤰🏿 在Amazon Web Services SDK for .NET源代码中寻找错误 🤳🏿 👪 😊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="向所有批评他人代码的粉丝致以问候。 ：）今天，在我们的实验室中，新的研究材料是.NET的AWS开发工具包项目的源代码。 一次，我们写了一篇关于检查适用于C ++的AWS开发工具包的文章。 然后，没有什么特别有趣的。 让我们看看AWS SDK的.NET版本如何取悦我们。 这是再次展示PVS-Studi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Amazon Web Services SDK for .NET源代码中寻找错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/437516/"><p><img src="https://habrastorage.org/getpro/habr/post_images/188/292/f27/188292f271dd0648b09f848dbe66efa6.png" alt="图片1"></p><br> 向所有批评他人代码的粉丝致以问候。  ：）今天，在我们的实验室中，新的研究材料是.NET的AWS开发工具包项目的源代码。 一次，我们写了一篇关于检查适用于C ++的AWS开发工具包的文章。 然后，没有什么特别有趣的。 让我们看看AWS SDK的.NET版本如何取悦我们。 这是再次展示PVS-Studio分析仪功能以及使世界变得更加完美的好机会。 <br><a name="habracut"></a><br> 亚马逊网络服务（AWS）.NET SDK是一个开发人员工具包，旨在在AWS基础设施中创建基于.NET的应用程序，并大大简化了编写代码的过程。 该SDK包含适用于各种AWS服务的.NET API套件，例如Amazon S3，Amazon EC2，DynamoDB等。  SDK的源代码托管在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a> 。 <br><br> 正如我所说，有一次我们撰写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了一篇</a>有关检查适用于C ++的AWS开发工具包<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的文章</a> 。 文章的篇幅很小-在512万行代码中仅发现512个错误。 这次，我们要处理的代码量要大得多，其中包括约3.4万个cs文件，并且代码行的总数（不包括空行）是令人印象深刻的500万。 一小部分代码（664个cs文件中的20万行）落在测试中，我没有考虑它们。 <br><br> 如果SDK版本的.NET代码的质量与C ++的质量大致相同（每512 KLOC出现两个错误），那么我们应该得到的错误大约多10倍。 当然，这是一种非常不准确的计算方法，没有考虑语言功能和许多其他因素，但我认为读者现在不想钻研无聊的讨论。 相反，我建议直接得出结果。 <br><br> 使用PVS-Studio版本6.27进行验证。 令人难以置信的是，该分析器能够检测到适用于.NET代码的AWS开发工具包中约40个值得一提的错误。 这不仅表明SDK代码的质量很高（每512 KLOC大约有4个错误），而且表明PVS-Studio分析仪的C＃工作质量与C ++相当。 好结果！ <br><br> 适用于.NET的AWS开发工具包的作者很棒。 从一个项目到另一个项目，它们展示了惊人的代码质量。 这可以作为其他团队的榜样。 但是，如果我没有插入5个戈比，我当然不会成为静态分析器的开发人员。  :)我们已经与Amazon Lumberyard团队合作使用PVS-Studio。 但是由于这是一家非常庞大的公司，在世界各地都有许多分支机构，因此适用于.NET的AWS开发工具包很可能根本没有听说过PVS-Studio。 无论如何，在SDK代码中我都没有发现使用分析仪的任何迹象，尽管这并不意味着任何事情。 但是，团队至少要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用</a> Visual Studio内置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>分析器。 这很好，但是可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">增强</a>代码检查:)。 <br><br> 结果，我仍然设法在SDK代码中找到了一些错误，最后是时候分享这些错误了。 <br><br>  <b>逻辑错误</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3008</a> [CWE-563]连续两次为'this.linker.s3.region'变量分配值。 也许这是一个错误。 检查行：116，114。AWSSDK.DynamoDBv2.Net45 S3Link.cs 116 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br> 分析器警告重新分配相同变量的值。 从代码中可以清楚地看出，这是由于违反操作逻辑的错误引起的： <i>this.linker.s3.region</i>变量的值<i>将</i>始终等于<i>value</i> ，而不管<i>if</i>条件<i>（String.IsNullOrEmpty（value））如何</i> 。 在<i>if</i>块的主体中​​， <i>return</i>被跳过。 该代码需要固定如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  <b>无限递归</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3110</a> [CWE-674]'OnFailure'属性内可能无限递归。  AWSSDK.ElasticMapReduce.Net45 ResizeJobFlowStep.cs 171 <br><br><pre> <code class="cpp hljs">OnFailure? onFailure = null; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.OnFailure; } <span class="hljs-comment"><span class="hljs-comment">// &lt;= set { this.onFailure = value; } }</span></span></code> </pre> <br> 一个经典的错字示例，该示例<i>在OnFailure</i>属性的<i>get</i> <i>访问器中</i>导致无限递归。 代替返回私有字段的值， <i>onFailure</i>引用<i>OnFailure</i>属性。 更正的选项： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure = value; } }</code> </pre> <br> 您问：“它是如何工作的？” 到目前为止，没有办法。 该属性未在任何地方使用，但它是临时的。 某个时候，有人会开始使用它，肯定会得到意想不到的结果。 为避免出现此类拼写错误，建议不要使用仅在首字母大写不同的标识符。 <br><br> 此设计的另一个注意事项是使用与<i>OnFailure</i>类型的名称完全匹配的标识符。 从编译器的角度来看，这是完全可以接受的，但是它使人们对代码的理解更加困难。 <br><br> 另一个类似的错误： <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3110</a> [CWE-674]'SSES3'属性内可能存在无限递归。  AWSSDK.S3.Net45 InventoryEncryption.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SSES3 sSES3; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3 = value; } }</code> </pre> <br> 这种情况与上述情况相同。 仅在这里，访问<i>SSES3</i>属性<i>以</i>进行读取和写入时将发生无限递归。 更正的选项： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3 = value; } }</code> </pre> <br>  <b>正念测试</b> <br><br> 以下是热衷于使用“复制粘贴”技术的程序员的任务。 查看代码在Visual Studio编辑器中的外观，然后尝试查找错误。 <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bfa/71b/1ab/bfa71b1ab4af941c43e5349df51b1614.png" alt="图片3"></p><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3029彼此并排放置</a>的'if'语句的条件表达式相同。 检查行：91，95。AWSSDK.AppSync.Net45 CreateApiKeyResponseUnmarshaller.cs 91 <br><br> 我减少了<i>UnmarshallException</i>方法的主体，删除了所有不必要的部分。 现在您可以看到相同的检查接连进行： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override AmazonServiceException </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmarshallException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } .... }</code> </pre> <br> 似乎该错误不是严重的-只是一个额外的检查。 但是，当不执行某些必要的检查时，这种模式通常可以指示代码中更严重的问题。 <br><br> 代码中还有更多类似的错误。 <br><br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：75、79。AWSSDK.CloudDirectory.Net45 CreateSchemaResponseUnmarshaller.cs 75 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：105、109。AWSSDK.CloudDirectory.Net45 GetSchemaAsJsonResponseUnmarshaller.cs 105 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：201、205。AWSSDK.CodeCommit.Net45 PostCommentForPullRequestResponseUnmarshaller.cs 201 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：101，105。AWSSDK.CognitoIdentityProvider.Net45 VerifySoftwareTokenResponseUnmarshaller.cs 101 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：72，76。AWSSDK.Glue.Net45 UpdateConnectionResponseUnmarshaller.cs 72 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：123、127。AWSSDK.Neptune.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 123 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：167、171。AWSSDK.Neptune.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 167 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：127，131。AWSSDK.RDS.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 127 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：171、175。AWSSDK.RDS.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 171 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：99、103。AWSSDK.Rekognition.Net45 RecognizeCelebritiesResponseUnmarshaller.cs 99 </li></ul><br>  <b>你是什​​么</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3062</a>对象“ attributeName”用作其自身方法的参数。 考虑检查“包含”方法的第一个实际参数。  AWSSDK.MobileAnalytics.Net45 CustomEvent.cs 261 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Dictionary that stores attribute for this event only. /// &lt;/summary&gt; private Dictionary&lt;string,string&gt; _attributes = new Dictionary&lt;string,string&gt;(); /// &lt;summary&gt; /// Gets the attribute. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;The attribute. Return null of attribute doesn't /// exist.&lt;/returns&gt; public string GetAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } string ret = null; lock(_lock) { if(attributeName.Contains(attributeName)) // &lt;= ret = _attributes[attributeName]; } return ret; }</span></span></code> </pre> <br> 分析器在<i>GetAttribute</i>方法中检测到错误：检查字符串是否包含字符串本身。 从方法的描述中可以得出结论，如果（在<i>_attributes</i>字典中）找到了属性名称（ <i>attributeName</i>键），则应返回属性值，否则返回<i>null</i> 。 实际上，由于条件<i>attributeName.Contains（attributeName）</i>始终为true，因此尝试通过可能在字典中找不到的键返回值。 然后，将抛出<i>KeyNotFoundException</i>而不是返回<i>null</i> 。 <br><br> 让我们尝试修复此代码。 为了更好地了解如何执行此操作，请查看另一种方法： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Determines whether this instance has attribute the specified /// attributeName. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;Return true if the event has the attribute, else /// false.&lt;/returns&gt; public bool HasAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } bool ret = false; lock(_lock) { ret = _attributes.ContainsKey(attributeName); } return ret; }</span></span></code> </pre> <br> 此方法检查<i>_attributes</i>词典中是否<i>存在</i>属性名称（ <i>attributeName</i>键）。  <i>让我们</i>回到<i>GetAttribute</i>方法并修复错误： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attributeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(attributeName)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"attributeName"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret = null; lock(_lock) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_attributes.ContainsKey(attributeName)) ret = _attributes[attributeName]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br> 现在，该方法完全可以执行描述中所述的操作。 <br><br> 并对此代码片段再做一个小小的评论。 我注意到作者在使用<i>_attributes</i>字典时会使用<i>锁</i> 。 显然，这对于多线程访问是必需的，但是<i>锁</i>构造相当缓慢且麻烦。 在这种情况下，可以使用字典的线程安全版本-ConcurrentDictionary代替<i>字典</i> ，这样更方便。 然后，对<i>锁</i>的需求就消失了。 虽然，也许我不知道该项目的任何功能。 <br><br>  <b>可疑行为</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3063</a> [CWE-571]如果对条件表达式进行评估，则该条件表达式的一部分始终为true：string.IsNullOrEmpty（inferredIndexName）。  AWSSDK.DynamoDBv2.PCL ContextInternal.cs 802 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQueryIndexName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> inferredIndexName = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// &lt;= indexNames.Count &gt; 0) throw new InvalidOperationException("Local Secondary Index range key conditions are used but no index could be inferred from model. Specified index name = " + specifiedIndexName); .... }</span></span></code> </pre> <br> 分析器警告了该<i>字符串。IsNullOrEmpty（inferredIndexName）</i>检查。 确实，为字符串<i>inferredIndexName</i>分配了<i>null</i> ，然后此变量的值未在任何地方更改，然后出于某种原因检查了它是否为<i>null</i>或空字符串。 看起来可疑。 让我们仔细看一下给定的代码片段。 我故意没有减少它以更好地了解情况。 因此，在第一个<i>if语句中</i> （以及在下一个<i>if语句</i>中），以某种方式检查了<i>namedIndexName</i>变量。 根据检查结果，变量<i>inferredIndexName</i>会收到一个新值。 现在让我们注意第三个<i>if语句</i> 。 如果<i>indexNames.Count&gt; 0</i> ，则将执行该语句的主体（引发异常），因为条件的第一部分是<i>string.IsNullOrEmpty（</i> <i>inferredIndexName</i> <i>）</i>始终为true。 也许对变量<i>namedIndexName</i>和<i>inferredIndexName</i>只是简单地混淆了。 或第三次检查应该没有<i>其他内容</i> ，代表独立的<i>if语句</i> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; indexNames.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(....);</code> </pre> <br> 在这种情况下，很难给出关于修复此代码的选项的明确答案。 但是作者肯定有必要对其进行检查。 <br><br>  <b>NullReferenceException</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3095</a> [CWE-476]在对空值进行验证之前使用了“ conditionValues”对象。 检查行：228、238。AWSSDK.Core.Net45 JsonPolicyWriter.cs 228 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; .... if (conditionValues != null &amp;&amp; conditionValues.Count != 0) { .... } .... } }</span></span></code> </pre> <br> 该流派的经典作品。 使用变量<i>conditionValues时，</i>无需先检查<i>null</i> 。 而且，在代码中进一步执行了这种验证，但是为时已晚。  :) <br><br> 该代码可以固定如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count != <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... } }</code> </pre> <br> 在代码中发现了更多类似的错误。 <br><br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V3095 [CWE-476]在验证是否为null之前使用了“ ts.Listeners”对象。 检查行：140，143。AWSSDK.Core.Net45 Logger.Diagnostic.cs 140 </li><li>  V3095 [CWE-476]在验证是否为null之前，已使用'obj'对象。 检查行：743、745。AWSSDK.Core.Net45 JsonMapper.cs 743 </li><li>  V3095 [CWE-476]在对null进行验证之前，已使用'multipartUploadMultipartUploadpartsList'对象。 检查行：65，67。AWSSDK.S3.Net45 CompleteMultipartUploadRequestMarshaller.cs 65 </li></ul><br> 以下警告的含义非常相似，但情况与上述警告相反。 <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3125</a> [CWE-476]在验证为空后使用了“状态”对象。 检查行：139、127。AWSSDK.Core.Net45 RefreshingAWSCredentials.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } state.Expiration -= PreemptExpiryTime; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br> 其中一个代码段包含一个检查<i>状态</i>变量值是否等于<i>null的检查</i> 。 此外，根据代码， <i>状态</i>变量用于退订<i>PreemptExpiryTime</i>事件，并且不再检查<i>null是否</i>相等，并且<i>NullReferenceException是可能的</i> 。 更安全的代码选项： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != null) state.Expiration -= PreemptExpiryTime; .... }</code> </pre> <br> 代码中还有其他类似的错误。 <br><br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V3125 [CWE-476]在针对null验证了'wrappedRequest.Content'对象之后，使用了该对象。 检查行：395、383。AWSSDK.Core.Net45 HttpHandler.cs 395 </li><li>  V3125 [CWE-476]在对null进行验证之后，使用了“ datasetUpdates”对象。 检查行：477、437。AWSSDK.CognitoSync.Net45 Dataset.cs 477 </li><li>  V3125 [CWE-476]在对null进行验证之后，使用了'cORSConfigurationCORSConfigurationcORSRulesListValue'对象。 检查行：125、111。AWSSDK.S3.Net45 PutCORSConfigurationRequestMarshaller.cs 125 </li><li>  V3125 [CWE-476]在对null进行验证之后，使用了'lifecycleConfigurationLifecycleConfigurationrulesListValue'对象。 检查行：157，68。AWSSDK.S3.Net45 PutLifecycleConfigurationRequestMarshaller.cs 157 </li><li>  V3125 [CWE-476]在验证了null之后使用了“ this.Key”对象。 检查行：199、183。AWSSDK.S3.Net45 S3PostUploadRequest.cs 199 </li></ul><br>  <b>无可争议的现实</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3009</a> [CWE-393]奇怪的是，此方法始终返回一个相同的'true'值。  AWSSDK.Core.Net45 Lexer.cs 651 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State19</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'\\'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 该方法始终返回<i>true</i> 。 让我们看看这对于调用代码有多重要。 我跟踪了<i>State19</i>方法的使用。 他参与填充<i>fsm_handler_table</i>处理程序数组以及其他类似方法（从<i>State1</i>到<i>State28</i>分别有28个其名称）。 在此必须注意，除了<i>State19之外</i> ，还向其他一些处理程序发出了警告<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3009</a> [CWE-393]。 这些是处理程序： <i>State23，State26，State27，State28</i> 。 分析仪为其发出的警报： <br><br><ul><li>  V3009 [CWE-393]奇怪的是，此方法始终返回一个相同的“ true”值。  AWSSDK.Core.Net45 Lexer.cs 752 </li><li>  V3009 [CWE-393]奇怪的是，此方法始终返回一个相同的“ true”值。  AWSSDK.Core.Net45 Lexer.cs 810 </li><li>  V3009 [CWE-393]奇怪的是，此方法始终返回一个相同的“ true”值。  AWSSDK.Core.Net45 Lexer.cs 822 </li><li>  V3009 [CWE-393]奇怪的是，此方法始终返回一个相同的“ true”值。  AWSSDK.Core.Net45 Lexer.cs 834 </li></ul><br> 处理程序数组的声明和初始化如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StateHandler[] fsm_handler_table; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopulateFsmTables</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fsm_handler_table = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateHandler[<span class="hljs-number"><span class="hljs-number">28</span></span>] { State1, State2, .... State19, .... State23, .... State26, State27, State28 };</code> </pre> <br> 为了完整起见，让我们看一下其中一个处理程序的代码，分析器对此没有任何抱怨，例如<i>State2</i> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br> 这就是处理程序的调用方式： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextToken</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { handler = fsm_handler_table[state - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! handler (fsm_context)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new JsonException (input_char); .... } .... }</span></span></code> </pre> <br> 如您所见，如果返回<i>false</i> ，则将引发异常。 在我们的案例中，对于处理程序<i>State19，State23，State26，State27</i>和<i>State28，</i>这将永远不会发生。 看起来可疑。 另一方面，多达五个处理程序具有相似的行为（总是返回<i>true</i> ），所以这可能是有意的，而不是拼写错误的结果。 <br><br> 为什么我要详细介绍所有这些内容？ 从静态分析仪通常只能指示可疑设计的意义上说，这种情况非常有用。 即使是对项目没有足够知识的人（不是机器），花了很多时间研究代码，也仍然无法给出有关错误存在的详尽解答。 该代码必须由开发人员研究。 <br><br>  <b>毫无意义的检查</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a> [CWE-571]表达式'doLog'始终为true。  AWSSDK.Core.Net45 StoredProfileAWSCredentials.cs 235 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidCredentialsExistInSharedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var doLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InvalidDataException) { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doLog) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } .... }</span></span></code> </pre> <br> 注意<i>doLog</i>变量。 在使用<i>false</i>初始化之后，在代码中，此变量在所有情况下都将变为<i>true</i> 。 因此， <i>if（doLog）</i>检查始终为true。 也许在此方法的较早分支中，没有为<i>doLog</i>变量分配任何值，然后在验证时它可能包含初始化期间获得的<i>错误</i>值。 但是现在没有这样的分支。 <br><br> 另一个类似的错误： <br><br>  <b>PVS-Studio</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">警告</a> <b>：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a>表达式“！结果”始终为false。  353 AWSSDK.CognitoSync.PCL SQLiteLocalStorage.cs <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = PutValueHelper(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!result) &lt;= { _logger.DebugFormat(<span class="hljs-string"><span class="hljs-string">"{0}"</span></span>, @<span class="hljs-string"><span class="hljs-string">"Cognito Sync - SQLiteStorage - Put Value Failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { UpdateLastModifiedTimestamp(....); } .... }</code> </pre> <br> 分析器声称<i>结果</i>变量的值始终为<i>true</i> 。 仅当<i>PutValueHelper</i>方法始终返回<i>true时，</i>才有可能。 看一下这个方法： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValueHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record == null) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br> 实际上，该方法在任何情况下都将返回<i>true</i> 。 此外，分析仪对此方法发出警告。  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3009</a> [CWE-393]奇怪的是，此方法始终返回一个相同的'true'值。  SQLiteLocalStorage.cs 1016 <br><br> 在考虑<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3009的</a>其他错误时，我特意不提早发出此警告，但我将其保存为这种情况。 因此，分析仪正确地在调用代码中指示错误<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a> 。 <br><br>  <b>复制粘贴。</b>  <b>再来一次</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3001</a>在'||'的左侧和右侧有相同的子表达式'this.token == JsonToken.String' 操作员。  AWSSDK.Core.Net45 JsonReader.cs 343 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ObjectEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ArrayEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.String || <span class="hljs-comment"><span class="hljs-comment">// &lt;= this.token == JsonToken.Boolean || this.token == JsonToken.Double || this.token == JsonToken.Int || this.token == JsonToken.UInt || this.token == JsonToken.Long || this.token == JsonToken.ULong || this.token == JsonToken.Null || this.token == JsonToken.String // &lt;= )) { .... } .... }</span></span></code> </pre> <br> 将<i>this.token</i>字段与<i>JsonToken</i>枚举的<i>JsonToken.String</i>值进行双重比较。 比较之一可能包含不同的枚举值。 如果是这样，那么就犯了一个严重的错误。 <br><br>  <b>重构+粗心？</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3025</a> [CWE-685]格式错误。 调用“格式”功能时，期望格式项目的数量不同。 未使用的参数：AWSConfigs.AWSRegionKey。  AWSSDK.Core.Net45 AWSRegion.cs 116 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstanceProfileAWSRegion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(CultureInfo.InvariantCulture, <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>, AWSConfigs.AWSRegionKey)); } .... }</code> </pre> <br> 可能是<i>string.Format</i>方法的格式字符串先前包含输出说明符<i>{0}</i> ，已为其设置参数<i>AWSConfigs.AWSRegionKey</i> 。 然后更改了该行，指定符消失了，但是他们忘了删除该参数。 上面的代码片段可以正常工作，没有错误（相反的情况下会引发异常-没有参数的说明符），但是看起来很丑。 该代码应固定如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>); }</code> </pre> <br>  <b>不安全</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3083</a> [CWE-367]事件'mOnSyncSuccess'的不安全调用，可能会发生NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.CognitoSync.PCL Dataset.cs 827 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mOnSyncSuccess != null) { mOnSyncSuccess(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); } }</code> </pre> <br> 对事件处理程序进行不安全调用的一种相当常见的情况。 在检查<i>mOnSyncSuccess</i>变量为<i>null</i>到调用处理程序之间，可以取消订阅事件，其值将变为零。 发生这种情况的可能性很小，但最好使代码更安全： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ mOnSyncSuccess?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); }</code> </pre> <br> 代码中还有其他类似的错误。 <br><br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V3083 [CWE-367]事件'mOnSyncFailure'的不安全调用，可能会导致NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.CognitoSync.PCL Dataset.cs 839 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.PCL AmazonServiceClient.cs 332 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.PCL AmazonServiceClient.cs 344 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.PCL AmazonServiceClient.cs 357 </li><li>  V3083 [CWE-367]事件'mExceptionEvent'的不安全调用，可能为NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  366AWSSDK.Core.PCL AmazonServiceClient.cs </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.PCL AmazonWebServiceRequest.cs 78 </li><li>  V3083 [CWE-367]事件'OnRead'的不安全调用，可能会发生NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.PCL EventStream.cs 97 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.Android NetworkReachability.cs 57 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.Android NetworkReachability.cs 94 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.iOS NetworkReachability.cs 54 </li></ul><br>  <b>未完成的课程</b> <br><br>  <b>PVS-Studio</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">警告</a> <b>：</b>实现IEquatable &lt;T&gt;接口的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3126</a>类型“ JsonData”不会覆盖“ GetHashCode”方法。  AWSSDK.Core.Net45 JsonData.cs 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonData</span></span></span><span class="hljs-class"> :</span></span> IJsonWrapper, IEquatable&lt;JsonData&gt; { .... }</code> </pre> <br>  <i>JsonData</i>类包含许多代码，因此我没有完整介绍它，仅将自己限于声明。 此类确实不包含重写的<i>GetHashCode</i>方法，这是不安全的，因为在使用<i>JsonData</i>类型（例如，与集合一起使用）时，它可能导致错误的行为。 目前可能没有问题，但是使用这种类型的策略将来可能会改变。 该错误在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>中有更详细的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述</a> 。 <br><br>  <b>结论</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是我使用PVS-Studio静态分析器设法在适用于.NET的AWS开发工具包代码中检测到的所有有趣的错误。</font><font style="vertical-align: inherit;">我再次强调项目的质量。</font><font style="vertical-align: inherit;">我发现500万行代码中的错误很少。</font><font style="vertical-align: inherit;">尽管可能更全面地分析发出的警告，使我可以在此列表中添加更多错误。</font><font style="vertical-align: inherit;">但是我也很可能白白地将所描述的某些警告归因于错误。</font><font style="vertical-align: inherit;">在这种情况下，只有在检查代码上下文中的开发人员始终得出明确的结论。</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您想与说英语的读者分享这篇文章，请使用以下链接：Sergey Khrenov。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在.NET的Amazon Web Services SDK源代码中搜索错误</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN437516/">https://habr.com/ru/post/zh-CN437516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN437504/index.html">小组件：可能出什么问题？ 我们使用唯一责任原则</a></li>
<li><a href="../zh-CN437508/index.html">CVE-2019-6111和其他SCP漏洞</a></li>
<li><a href="../zh-CN437510/index.html">发送短信时会发生什么</a></li>
<li><a href="../zh-CN437512/index.html">什么是JavaScript中的纯函数？</a></li>
<li><a href="../zh-CN437514/index.html">在.NET的Amazon Web Services SDK源代码中搜索错误</a></li>
<li><a href="../zh-CN437518/index.html">甲虫袭击</a></li>
<li><a href="../zh-CN437520/index.html">“我的灯是一面镜子！ -说，给我看我的双重身份……”：设计一个好的框架，然后将第二个作为礼物</a></li>
<li><a href="../zh-CN437522/index.html">殖民地 第22章：最终决定</a></li>
<li><a href="../zh-CN437524/index.html">创建一个简单的国际象棋AI：5个简单步骤</a></li>
<li><a href="../zh-CN437526/index.html">WebGL中的体积渲染</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>