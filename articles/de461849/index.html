<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔣 👨🏿‍✈️ ⌛️ PVS-Studio warf einen Blick auf die Red Dead Redemption Engine - Bullet ✔️ 🧝🏼 👨🏾‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heutzutage, zum Beispiel für die Entwicklung von Spielen, besteht heutzutage keine Notwendigkeit mehr, die Physik von Objekten von Grund auf unabhängi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio warf einen Blick auf die Red Dead Redemption Engine - Bullet</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/461849/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d4/8af/4e2/0d48af4e201510deac9e3634151d647e.png" alt="Bild 4"></div><br>  Heutzutage, zum Beispiel für die Entwicklung von Spielen, besteht heutzutage keine Notwendigkeit mehr, die Physik von Objekten von Grund auf unabhängig zu implementieren, da es dafür eine große Anzahl von Bibliotheken gibt.  Bullet wurde einst in vielen AAA-Spielen, Virtual-Reality-Projekten, verschiedenen Simulationen und maschinellem Lernen aktiv eingesetzt.  Ja, und es wird noch heute verwendet, beispielsweise als eine der Red Dead Redemption- und Red Dead Redemption 2-Engines. Warum also nicht Bullet mit PVS-Studio überprüfen, um festzustellen, welche Fehler die statische Analyse in einem so großen Projekt erkennen kann? im Zusammenhang mit der Physiksimulation. <br><a name="habracut"></a><br>  Diese Bibliothek ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">frei verteilt</a> , so dass jeder sie optional in seinen Projekten verwenden kann.  Neben Red Dead Redemption wird diese Physik-Engine auch in der Filmindustrie verwendet, um Spezialeffekte zu erzeugen.  Zum Beispiel war er an den Dreharbeiten zu Sherlock Holmes durch Guy Ritchie beteiligt, um Kollisionen zu berechnen. <br><br>  Wenn dies Ihre erste Begegnung mit einem Artikel ist, in dem PVS-Studio Projekte überprüft, werde ich einen kleinen Exkurs machen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> ist ein statischer Code-Analysator, mit dessen Hilfe Fehler, Mängel und potenzielle Schwachstellen im Quellcode von C-, C ++ -, C # - und Java-Programmen gefunden werden können.  Die statische Analyse ist eine Art automatisierter Codeüberprüfungsprozess. <br><br><h2>  Zum Aufwärmen </h2><br>  <b>Beispiel 1:</b> <br><br>  Beginnen wir mit einem lustigen Fehler: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V624 In der</a> Konstante '3.141592538' liegt wahrscheinlich ein Druckfehler vor.  Erwägen Sie die Verwendung der M_PI-Konstante aus &lt;math.h&gt;.  PhysicsClientC_API.cpp 4109 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">B3_SHARED_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b3ComputeProjectionMatrixFOV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fov, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> yScale = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>((<span class="hljs-number"><span class="hljs-number">3.141592538</span></span> / <span class="hljs-number"><span class="hljs-number">180.0</span></span>) * fov / <span class="hljs-number"><span class="hljs-number">2</span></span>); .... }</code> </pre> <br>  Ein kleiner Tippfehler in der Zahl Pi (3.141592653 ...), bei dem die Zahl "6" an der 7. Stelle im Bruchteil fehlt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f83/42b/62f/f8342b62f2250ce927675fbbc1f40af7.png" alt="Bild 1"></div>  Möglicherweise führt der Fehler in der zehnmillionsten Dezimalstelle nicht zu konkreten Konsequenzen, aber Sie sollten die vorhandenen Bibliothekskonstanten ohne Tippfehler verwenden.  Für Pi gibt es eine <i>M_PI-</i> Konstante aus dem <i>math.h-</i> Header. <br><br><h2>  Kopieren Einfügen </h2><br>  <b>Beispiel 2:</b> <br><br>  Manchmal können Sie mit dem Analysegerät den Fehler indirekt finden.  So werden hier beispielsweise drei verwandte Argumente <i>halfExtentsX, halfExtentsY, halfExtentsZ</i> an die Funktion übergeben, letzteres wird jedoch nirgendwo in der Funktion verwendet.  Möglicherweise stellen Sie fest, dass beim Aufrufen der <i>addVertex-</i> Methode die Variable <i>halfExtentsY</i> zweimal verwendet wird.  Vielleicht ist dies ein Fehler beim Kopieren und Einfügen, und hier sollte ein vergessenes Argument verwendet werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V751 Der</a> Parameter 'halfExtentsZ' wird im Funktionskörper nicht verwendet.  TinyRenderer.cpp 375 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TinyRenderObjectData::createCube(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> halfExtentsX, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> halfExtentsY, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> halfExtentsZ, ....) { .... m_model-&gt;addVertex(halfExtentsX * cube_vertices_textured[i * <span class="hljs-number"><span class="hljs-number">9</span></span>], halfExtentsY * cube_vertices_textured[i * <span class="hljs-number"><span class="hljs-number">9</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>], halfExtentsY * cube_vertices_textured[i * <span class="hljs-number"><span class="hljs-number">9</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>], cube_vertices_textured[i * <span class="hljs-number"><span class="hljs-number">9</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>], ....); .... }</code> </pre> <br>  <b>Beispiel 3:</b> <br><br>  Der Analysator fand auch das folgende interessante Fragment, ich werde es zuerst in seiner ursprünglichen Form bringen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f03/4d3/6a0/f034d36a087d3705a4aaf5c1ca4ff54c.png" alt="Bild 11"></div><br>  Sehen Sie diese letzte Zeile? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97f/976/5f6/97f9765f6af6eef034ea0c541f6e95c1.png" alt="Bild 12"></div><br>  Es ist sehr seltsam, dass der Programmierer beschlossen hat, eine so lange Bedingung in eine Zeile zu schreiben.  Aber die Tatsache, dass sich höchstwahrscheinlich ein Fehler eingeschlichen hat, ist keineswegs überraschend. <br><br>  Der Analysator gab die folgenden Warnungen in dieser Zeile aus. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdrücke 'rotmat.Column1 (). Norm () &lt;1.0001'.  LinearR4.cpp 351 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdrücke '0.9999 &lt;rotmat.Column1 (). Norm ()'.  LinearR4.cpp 351 <br><br>  Wenn wir alles in einer visuellen „tabellarischen“ Form schreiben, wird klar, dass für <i>Spalte 1</i> dieselben Überprüfungen gelten.  Die letzten beiden Vergleiche zeigen, dass es <i>Spalte1</i> und <i>Spalte2 gibt</i> .  Höchstwahrscheinlich hätte der dritte und vierte Vergleich den Wert von <i>Spalte 2</i> überprüfen <i>müssen</i> . <br><br><pre> <code class="cpp hljs"> Column1().Norm() &lt; <span class="hljs-number"><span class="hljs-number">1.0001</span></span> &amp;&amp; <span class="hljs-number"><span class="hljs-number">0.9999</span></span> &lt; Column1().Norm() &amp;&amp; Column1().Norm() &lt; <span class="hljs-number"><span class="hljs-number">1.0001</span></span> &amp;&amp; <span class="hljs-number"><span class="hljs-number">0.9999</span></span> &lt; Column1().Norm() &amp;&amp;(Column1() ^ Column2()) &lt; <span class="hljs-number"><span class="hljs-number">0.001</span></span> &amp;&amp; (Column1() ^ Column2()) &gt; <span class="hljs-number"><span class="hljs-number">-0.001</span></span></code> </pre><br>  In dieser Form wird der gleiche Vergleich viel deutlicher. <br><br>  <b>Beispiel 4:</b> <br><br>  Fehler ähnlicher Art: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdrücke 'cs.m_fJacCoeffInv [0] == 0'.  b3CpuRigidBodyPipeline.cpp 169 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m_fJacCoeffInv[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b3SolveFriction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b3ContactConstraint4&amp; cs, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cs.m_fJacCoeffInv[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; cs.m_fJacCoeffInv[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  In diesem Fall wird dasselbe Array-Element doppelt geprüft.  Höchstwahrscheinlich sollte die Bedingung folgendermaßen aussehen: <i>cs.m_fJacCoeffInv [0] == 0 &amp;&amp; cs.m_fJacCoeffInv [1] == 0</i> .  Dies ist ein klassisches Beispiel für einen Fehler beim Kopieren und Einfügen. <br><br>  <b>Beispiel 5:</b> <br><br>  Ein weiteres Manko wurde entdeckt: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V517</a> Die Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Musters</a> 'if (A) {...} else if (A) {...}' wurde erkannt.  Es besteht die Wahrscheinlichkeit eines logischen Fehlers.  Überprüfen Sie die Zeilen: 79, 112. main.cpp 79 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (serviceResult &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { serviceResult = enet_host_service(client, &amp;event, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Error with servicing the client"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); } .... } .... }</code> </pre> <br>  Die Funktion <i>enet_host_service</i> , deren Ergebnis <i>serviceResult</i> zugewiesen <i>ist</i> , gibt eine zurück, wenn sie <i>erfolgreich ist,</i> und -1, wenn sie fehlschlägt.  Höchstwahrscheinlich <i>hätte der</i> Zweig <i>else if</i> auf den negativen Wert von <i>serviceResult reagieren sollen</i> , aber die Überprüfungsbedingung wurde dupliziert.  Dies ist höchstwahrscheinlich auch ein Fehler beim Kopieren und Einfügen. <br><br>  Eine ähnliche Analysatorwarnung, deren Beschreibung im Artikel nicht sinnvoll ist: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V517</a> Die Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Musters</a> 'if (A) {...} else if (A) {...}' wurde erkannt.  Es besteht die Wahrscheinlichkeit eines logischen Fehlers.  Überprüfen Sie die Zeilen: 151, 190. PhysicsClientUDP.cpp 151 <br><br><h2>  Über die Grenzen hinaus: Über die Grenzen des Arrays hinaus </h2><br>  <b>Beispiel 6:</b> <br><br>  Eines der unangenehmen Dinge, nach Fehlern zu suchen, ist das Verlassen des Arrays.  Oft tritt dieser Fehler aufgrund einer komplexen Indizierung in der Schleife auf. <br><br>  Hier ist in der Schleifenbedingung die Variable <i>dofIndex</i> von oben auf 128 und von <i>dof</i> auf 4 einschließlich begrenzt.  <i>M_desiredState</i> enthält aber auch nur 128 Elemente.  Infolgedessen kann der Index <i>[dofIndex + dof]</i> zum <i>Abfluss des</i> Arrays führen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V557</a> Array-Überlauf ist möglich.  Der Wert des Index 'dofIndex + dof' könnte 130 erreichen. PhysicsClientC_API.cpp 968 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_DEGREE_OF_FREEDOM 128 double m_desiredState[MAX_DEGREE_OF_FREEDOM]; B3_SHARED_API int b3JointControl(int dofIndex, double* forces, int dofCount, ....) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( (dofIndex &gt;= 0) &amp;&amp; (dofIndex </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; MAX_DEGREE_OF_FREEDOM ) &amp;&amp; dofCount &gt;= 0 &amp;&amp; dofCount &lt;= 4) { for (int dof = 0; dof &lt; dofCount; dof++) { command-&gt;m_sendState.m_desiredState[dofIndex+dof] = forces[dof]; .... } } .... }</span></span></span></span></code> </pre> <br>  <b>Beispiel 7:</b> <br><br>  Ein ähnlicher Fehler, aber jetzt führt die Summierung nicht zum Indizieren eines Arrays, sondern in einem Zustand.  Wenn der Dateiname so lang wie möglich ist, wird das Terminal Null außerhalb des Arrays geschrieben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Off-by-One-Fehler</a> ).  Natürlich ist die Variable <i>len</i> nur in Ausnahmefällen gleich <i>MAX_FILENAME_LENGTH</i> , aber dies beseitigt den Fehler nicht, sondern macht sein Auftreten einfach selten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V557</a> Array-Überlauf ist möglich.  Der Wert des 'len'-Index könnte 1024 erreichen. PhysicsClientC_API.cpp 5223 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_FILENAME_LENGTH MAX_URDF_FILENAME_LENGTH 1024 struct b3Profile { char m_name[MAX_FILENAME_LENGTH]; int m_durationInMicroSeconds; }; int len = strlen(name); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (len &gt;= 0 &amp;&amp; len </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; (MAX_FILENAME_LENGTH + 1)) { command-&gt;m_type = CMD_PROFILE_TIMING; strcpy(command-&gt;m_profile.m_name, name); command-&gt;m_profile.m_name[len] = 0; }</span></span></span></span></code> </pre> <br><h2>  Einmal messen - siebenmal schneiden </h2><br>  <b>Beispiel 8:</b> <br><br>  In Fällen, in denen Sie das Ergebnis einer bestimmten Funktion mehrmals verwenden oder wiederholt eine Variable verwenden müssen, auf die Sie über eine Reihe von Aufrufen zugreifen müssen, sollten Sie temporäre Variablen verwenden, um den Code zu optimieren und besser zu lesen.  Der Analysator hat mehr als 100 Stellen im Code gefunden, an denen eine solche Korrektur vorgenommen werden kann. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V807</a> Leistungsminderung.  Erstellen Sie einen Zeiger, um zu vermeiden, dass der Ausdruck 'm_app-&gt; m_renderer-&gt; getActiveCamera ()' wiederholt verwendet wird.  InverseKinematicsExample.cpp 315 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resetCamera</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { m_app-&gt;m_renderer-&gt;getActiveCamera()-&gt;setCameraDistance(dist); m_app-&gt;m_renderer-&gt;getActiveCamera()-&gt;setCameraPitch(pitch); m_app-&gt;m_renderer-&gt;getActiveCamera()-&gt;setCameraYaw(yaw); m_app-&gt;m_renderer-&gt;getActiveCamera()-&gt;setCameraPosition(....); } }</code> </pre> <br>  Hier wird dieselbe Aufrufkette wiederverwendet, die durch einen einzelnen Zeiger ersetzt werden kann. <br><br>  <b>Beispiel 9:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V810</a> Leistungsminderung.  Die Funktion 'btCos (euler_out.pitch)' wurde mehrmals mit identischen Argumenten aufgerufen.  Das Ergebnis sollte möglicherweise in einer temporären Variablen gespeichert werden, die dann beim Aufrufen der Funktion 'btAtan2' verwendet werden kann.  btMatrix3x3.h 576 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V810</a> Leistungsminderung.  Die Funktion 'btCos (euler_out2.pitch)' wurde mehrmals mit identischen Argumenten aufgerufen.  Das Ergebnis sollte möglicherweise in einer temporären Variablen gespeichert werden, die dann beim Aufrufen der Funktion 'btAtan2' verwendet werden kann.  btMatrix3x3.h 578 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEulerZYX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... euler_out.roll = btAtan2(m_el[<span class="hljs-number"><span class="hljs-number">2</span></span>].y() / btCos(euler_out.pitch), m_el[<span class="hljs-number"><span class="hljs-number">2</span></span>].z() / btCos(euler_out.pitch)); euler_out2.roll = btAtan2(m_el[<span class="hljs-number"><span class="hljs-number">2</span></span>].y() / btCos(euler_out2.pitch), m_el[<span class="hljs-number"><span class="hljs-number">2</span></span>].z() / btCos(euler_out2.pitch)); euler_out.yaw = btAtan2(m_el[<span class="hljs-number"><span class="hljs-number">1</span></span>].x() / btCos(euler_out.pitch), m_el[<span class="hljs-number"><span class="hljs-number">0</span></span>].x() / btCos(euler_out.pitch)); euler_out2.yaw = btAtan2(m_el[<span class="hljs-number"><span class="hljs-number">1</span></span>].x() / btCos(euler_out2.pitch), m_el[<span class="hljs-number"><span class="hljs-number">0</span></span>].x() / btCos(euler_out2.pitch)); } .... }</code> </pre><br>  In diesem Fall können Sie zwei Variablen erstellen und die von der Funktion <i>btCos</i> für <i>euler_out.pitch</i> und <i>euler_out2.pitch zurückgegebenen</i> Werte darin speichern, anstatt die Funktion für jedes Argument viermal aufzurufen. <br><br><h2>  Leck </h2><br>  <b>Beispiel 10:</b> <br><br>  Im Projekt wurden viele Fehler des folgenden Typs gefunden: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V773 Der</a> Sichtbarkeitsbereich des 'Importer'-Zeigers wurde beendet, ohne den Speicher freizugeben.  Ein Speicherverlust ist möglich.  SerializeSetup.cpp 94 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SerializeSetup::initPhysics() { .... btBulletWorldImporter* importer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> btBulletWorldImporter(m_dynamicsWorld); .... fclose(file); m_guiHelper-&gt;autogenerateGraphicsObjects(m_dynamicsWorld); }</code> </pre> <br>  Hier wurde kein Speicher vom <i>Importerzeiger</i> freigegeben.  Dies kann zu einem Speicherverlust führen.  Und für den physischen Motor kann dies ein schlechter Trend sein.  Um Leckagen zu vermeiden, reicht es aus, wenn die Variable nicht mehr benötigt wird, um den <i>Löschimporter</i> hinzuzufügen.  Aber natürlich ist es besser, intelligente Zeiger zu verwenden. <br><br><h2>  Hier sind deine Gesetze </h2><br>  <b>Beispiel 11:</b> <br><br>  Der folgende Fehler tritt im Code auf, da C ++ - Regeln nicht immer mit mathematischen Regeln oder dem „gesunden Menschenverstand“ übereinstimmen.  Beachten Sie selbst, wo sich der Fehler in einem kleinen Codeausschnitt befindet? <br><br><pre> <code class="cpp hljs">btAlignedObjectArray&lt;btFractureBody*&gt; m_fractureBodies; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> btFractureDynamicsWorld::fractureCallback() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numManifolds; i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f0 = m_fractureBodies.findLinearSearch(....); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f1 = m_fractureBodies.findLinearSearch(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f0 == f1 == m_fractureBodies.size()) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... } .... }</code> </pre> <br>  Der Analysator generiert die folgende Warnung: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V709</a> Verdächtiger Vergleich gefunden: 'f0 == f1 == m_fractureBodies.size ()'.  Denken Sie daran, dass 'a == b == c' nicht gleich 'a == b &amp;&amp; b == c' ist.  btFractureDynamicsWorld.cpp 483 <br><br>  Es scheint, dass die Bedingung prüft, <i>ob f0</i> gleich <i>f1</i> und gleich der Anzahl der Elemente in <i>m_fractureBodies ist</i> .  Es sieht so aus, als hätte dieser Vergleich prüfen sollen, ob sich <i>f0</i> und <i>f1</i> am Ende des Arrays <i>m_fractureBodies befinden</i> , da sie die Position des von der <i>findLinearSearch ()</i> -Methode gefundenen Objekts enthalten.  Tatsächlich wird dieser Ausdruck jedoch zu einem Test, um <i>festzustellen,</i> ob <i>f0</i> und <i>f1</i> gleich sind, und dann zu einer Überprüfung, ob <i>m_fractureBodies.size ()</i> gleich dem Ergebnis von <i>f0 == f1 ist</i> .  Infolgedessen wird der dritte Operand hier mit 0 oder 1 verglichen. <br><br>  Schöner Fehler!  Und zum Glück ziemlich selten.  Bisher haben wir sie nur in zwei offenen Projekten getroffen, und interessanterweise waren alle nur Spiel-Engines. <br><br>  <b>Beispiel 12:</b> <br><br>  Wenn Sie mit Zeichenfolgen arbeiten, ist es häufig besser, die von der <i>Zeichenfolgenklasse</i> bereitgestellten Funktionen zu verwenden.  In den folgenden beiden Fällen ist es daher besser, <i>strlen (MyStr.c_str ())</i> und <i>val = ""</i> durch <i>MyStr.length ()</i> bzw. <i>val.clear ()</i> zu ersetzen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V806</a> Verminderte Leistung.  Der Ausdruck der Art strlen (MyStr.c_str ()) kann als MyStr.length () umgeschrieben werden.  RobotLoggingUtil.cpp 213 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FILE* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createMinitaurLogFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* fileName, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; structTypes, ....)</span></span></span><span class="hljs-function"> </span></span>{ FILE* f = fopen(fileName, <span class="hljs-string"><span class="hljs-string">"wb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f) { .... fwrite(structTypes.c_str(), <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(structTypes.c_str()), <span class="hljs-number"><span class="hljs-number">1</span></span>, f); .... } .... }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V815</a> Leistungsminderung.  Ersetzen Sie den Ausdruck 'val = ""' durch 'val.clear ()'.  b3CommandLineArgs.h 40 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> val; .... val = <span class="hljs-string"><span class="hljs-string">""</span></span>; .... }</code> </pre> <br>  Es gab andere Warnungen, aber ich denke, Sie können aufhören.  Wie Sie sehen können, kann die statische Code-Analyse eine Vielzahl verschiedener Fehler aufdecken. <br><br>  Es ist interessant, über einmalige Projektprüfungen zu lesen, aber dies ist nicht der richtige Weg, um statische Code-Analysatoren zu verwenden.  Und darüber werden wir weiter unten sprechen. <br><br><h2>  Vor uns gefundene Fehler </h2><br>  Es war im Geiste des kürzlich erschienenen Artikels „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler, die bei der statischen Code-Analyse nicht gefunden werden, weil sie nicht verwendet wird</a> “ interessant, um zu versuchen, Fehler oder Mängel zu finden, die bereits behoben wurden, die der statische Analysator jedoch erkennen könnte. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e5/4ab/39d/0e54ab39d2d7d7dbd4d595d1032fe994.png" alt="Bild 2"></div><br>  Es gab nicht so viele Pull-Anforderungen im Repository, und viele davon beziehen sich auf die interne Logik der Engine.  Es gab aber auch Fehler, die der Analysator erkennen konnte. <br><br>  <b>Beispiel 13:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> m_deviceExtensions[B3_MAX_STRING_LENGTH]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b3OpenCLUtils_printDeviceInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cl_device_id device)</span></span></span><span class="hljs-function"> </span></span>{ b3OpenCLDeviceInfo info; b3OpenCLUtils::getDeviceInfo(device, &amp;info); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.m_deviceExtensions != <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } }</code> </pre> <br>  Der Bearbeitungskommentar besagt, dass das Array auf die Tatsache überprüft werden musste, dass es nicht leer ist. Stattdessen wurde eine sinnlose Zeigerprüfung durchgeführt, die immer true zurückgab.  Dies wird durch die Warnung PVS-Studio bei der ersten Art der Prüfung angezeigt: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V600</a> Überprüfen Sie den Zustand.  Der Zeiger 'info.m_deviceExtensions' ist immer ungleich NULL.  b3OpenCLUtils.cpp 551 <br><br>  <b>Beispiel 14:</b> <br><br>  Können Sie in der nächsten Funktion sofort herausfinden, wo das Problem liegt? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Matrix4x4::SetIdentity() { m12 = m13 = m14 = m21 = m23 = m24 = m13 = m23 = m41 = m42 = m43 = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; m11 = m22 = m33 = m44 = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; }</code> </pre> <br>  Der Analysator generiert die folgenden Warnungen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V570</a> Der Variable 'm23' wird zweimal derselbe Wert zugewiesen.  LinearR4.h 627 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V570</a> Der Variable 'm13' wird zweimal derselbe Wert zugewiesen.  LinearR4.h 627 <br><br>  Wiederholte Zuordnungen mit dieser Form der Aufzeichnung sind mit bloßem Auge schwer zu verfolgen, und infolgedessen haben einige Elemente der Matrix nicht den Anfangswert erhalten.  Dieser Fehler wurde in der tabellarischen Form des Zuordnungsdatensatzes behoben: <br><br><pre> <code class="cpp hljs">m12 = m13 = m14 = m21 = m23 = m24 = m31 = m32 = m34 = m41 = m42 = m43 = <span class="hljs-number"><span class="hljs-number">0.0</span></span>;</code> </pre><br>  <b>Beispiel 15:</b> <br><br>  Der folgende Fehler in einer der Bedingungen der Funktion <i>btSoftBody :: addAeroForceToNode ()</i> führte zu einem expliziten Fehler.  Gemäß dem Kommentar in der Pull-Anfrage wurden Kräfte von der falschen Seite auf Objekte ausgeübt. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eAeroModel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> _ { V_Point, V_TwoSided, .... END }; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> btSoftBody::addAeroForceToNode(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (btSoftBody::eAeroModel::V_TwoSided) { .... } .... } .... }</code> </pre> <br>  PVS-Studio konnte diesen Fehler auch finden und die folgende Warnung anzeigen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V768</a> Die Aufzählungskonstante 'V_TwoSided' wird als Variable eines Booleschen Typs verwendet.  btSoftBody.cpp 542 <br><br>  Die korrigierte Prüfung lautet wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_cfg.aeromodel == btSoftBody::eAeroModel::V_TwoSided) { .... }</code> </pre> <br>  Anstelle der Äquivalenz der Objekteigenschaft zu einem der Enumeratoren wurde der Enumerator <i>V_TwoSided</i> selbst überprüft. <br><br>  Es ist klar, dass ich nicht alle Pull-Anfragen angezeigt habe, da ich mir keine solche Aufgabe gestellt habe.  Ich wollte nur zeigen, dass die regelmäßige Verwendung eines statischen Code-Analysators Fehler sehr früh erkennen kann.  Dies ist der richtige Weg, um die statische Code-Analyse zu verwenden.  Die statische Analyse sollte in den DevOps-Prozess integriert sein und der Hauptfilter für Fehler sein.  All dies wird im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statische Analyse in den Prozess einbetten und keine Fehler damit suchen</a> " ausführlich beschrieben. <br><br><h2>  Fazit </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4a/dc3/388/a4adc33880ad2c22a88902ae54a7fa44.png" alt="Bild 6"></div><br>  Nach einigen Pull-Anforderungen zu urteilen, wird ein Projekt manchmal mit verschiedenen Code-Analyse-Tools überprüft. Die Änderungen werden jedoch nicht schrittweise, sondern in Gruppen und in großen Zeitintervallen vorgenommen.  In einigen Anfragen gibt ein Kommentar an, dass Änderungen nur vorgenommen wurden, um Warnungen zu unterdrücken.  Dieser Ansatz für die Verwendung von Analysen verringert die Nützlichkeit erheblich, da es sich um eine ständige Überprüfung des Projekts handelt, mit der Sie Fehler sofort beheben und nicht warten können, bis offensichtliche Fehler auftreten. <br><br>  Wenn Sie immer über die Neuigkeiten und Ereignisse unseres Teams informiert sein möchten, abonnieren Sie unsere sozialen Dienste.  Netzwerke: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Instagram</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vkontakte</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegramm</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> <br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Übersetzungslink: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio hat einen Blick in die Bullet Engine von Red Dead Redemption geworfen</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461849/">https://habr.com/ru/post/de461849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461831/index.html">StealthWatch: Bereitstellung und Anpassung. Teil 2</a></li>
<li><a href="../de461833/index.html">Verlieren Sie sich nicht in drei Kiefern: einer egozentrischen Darstellung der Umwelt</a></li>
<li><a href="../de461835/index.html">Wie Gantt-Diagramme das Projektmanagement vereinfachen und stärken</a></li>
<li><a href="../de461841/index.html">PVS-Studio untersuchte die Bullet Engine der Red Dead Redemption</a></li>
<li><a href="../de461845/index.html">Investitionen an der Börse als Mittel zur Erhaltung der Finanzen: 3 Arbeitsmethoden</a></li>
<li><a href="../de461851/index.html">Blockchain und Elektrizität</a></li>
<li><a href="../de461855/index.html">IT-Gehälter im ersten Halbjahr 2019: Laut Gehaltsrechner „My Circle“</a></li>
<li><a href="../de461859/index.html">Sie wissen nichts über Lebensmitteltechnologie</a></li>
<li><a href="../de461861/index.html">Office 365 Cloud-Sicherheit: Check Point CloudGuard SaaS-Test</a></li>
<li><a href="../de461865/index.html">Videokurs „Einführung in das Umkehren von Grund auf mit IDA PRO. Kapitel 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>