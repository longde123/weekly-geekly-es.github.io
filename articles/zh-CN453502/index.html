<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📱 ✋🏻 🙋🏼 我的耙子：从破烂到富裕 ⌨️ 👨🏾‍✈️ 🍅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="背景知识 


 我已经担任前端开发人员一年了。 我的第一个项目是“敌人”后端。 建立通信时，这并不是一个大问题。 


 但是在我们的情况下并非如此。 


 我们开发了代码，它依赖于后端向我们发送某些数据，某种结构和某种格式的事实。 而后端认为正常即可更改响应的内容-无需警告。 结果，我们花了几...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我的耙子：从破烂到富裕</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453502/"><h2 id="predystoriya"> 背景知识 </h2><br><p> 我已经担任前端开发人员一年了。 我的第一个项目是“敌人”后端。 建立通信时，这并不是一个大问题。 </p><br><p> 但是在我们的情况下并非如此。 </p><a name="habracut"></a><br><p> 我们开发了代码，它依赖于后端向我们发送某些数据，某种结构和某种格式的事实。 而后端认为正常即可更改响应的内容-无需警告。 结果，我们花了几个小时才能确定网站的某些部分为何停止工作。 </p><br><p> 我们意识到，在依赖后端发送给我们的数据之前，需要检查后端返回的内容。 我们从前端创建了一个任务，用于研究数据验证问题。 </p><br><p> 这项研究是委托给我的。 </p><br><p> 我已经列出了我想用于数据验证的工具清单。 </p><br><p> 最重要的选择点是以下几点： </p><br><ul><li> 验证的说明性描述（方案），它转换为返回true / false（有效，无效）的验证器函数 </li><li> 低进入门槛； </li><li> 验证数据与验证描述的相似性； </li><li>易于集成定制验证； </li><li> 易于集成自定义错误消息。 </li></ul><br><p> 结果，我查看了TOP-5（ajv，joi，roi ...），发现了许多验证库。 他们都很好。 但是在我看来，为了解决5％的复杂案件-他们注定95％的最常见案件相当冗长和笨重。 </p><br><p> 因此，我想：为什么不自己做一些适合我的事情。 <br> 四个月后，我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">四方</a>验证库的第七个版本问世了。 <br> 这是一个稳定的版本，经过全面测试，在npm上下载了11000次。 我们在一个广告系列中的三个项目中使用了三个月。 </p><br><p> 这三个月起了非常有用的作用。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">四方</a>展示了其所有优势。 后端没有数据问题。 每次他们更改答案时，我们都会立即出错。 查找错误原因的时间已大大减少。 几乎没有数据错误。 </p><br><p> 但是也发现了缺陷。 </p><br><p> 因此，我决定对其进行分析，并发布一个新版本，其中对开发过程中发生的所有错误进行了更正。 <br> 我将在下面讨论这些体系结构错误及其解决方案。 </p><br><h2 id="arhitekturnye-grabli"> 建筑耙 </h2><br><h3 id="stroko-tipizirovannyy-yazyk-shemy">  “ Stroko”-该方案的典型语言 </h3><br><p> 我将以该人的对象为例，介绍该方案的旧版本。 </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'null'</span></span>] }</code> </pre> <br><p> 此方案验证具有三个属性的对象：名称-必须是字符串，年龄-必须是数字，链接到LinkedIn中的帐户-必须为null（如果没有帐户）或字符串（如果有帐户）。 </p><br><p> 该方案满足了我对可读性，与经过验证的数据的相似性的要求，并且我认为学习编写此类方案的入门门槛并不高。 此外，可以使用打字稿中的类型定义轻松编写这样的方案： </p><br><pre> <code class="javascript hljs">type Person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string age: number linkedin: string | <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> <br><p>  （如您所见-这些更改很可能是装饰性的） </p><br><p> 当我做出决定时，最常用的验证选项应使用什么（例如，上面使用的那些选项）。 我选择使用-字符串，即验证者的名称。 </p><br><p> 但是字符串的问题在于它们不能用于编译器或错误分析器。 它们的字符串“数字”与“数字”没有太大区别。 </p><br><h3 id="reshenie"> 解决方案 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">四重奏</a> 8.0.0的新版本。 我决定从四重奏中删除-使用字符串作为方案中验证器的名称。 </p><br><p> 现在该图如下所示： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string age: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [v.string, <span class="hljs-literal"><span class="hljs-literal">null</span></span>] }</code> </pre> <br><p> 此更改具有两个主要优点： </p><br><ul><li> 编译器或错误分析器-能够检测方法名称是否拼写错误。 </li><li> 行-不再用作架构元素。 这意味着对于他们来说，您可以在库中选择新功能，下面将对其进行描述。 </li></ul><br><h3 id="podderzhka-typescript">  TypeScript支持 </h3><br><p> 通常，前七个版本是使用纯Javascript开发的。 当切换到带有Typescript的项目时，需要以某种方式适应它的库。 因此，编写了库的类型声明。 </p><br><p> 但这是一个缺点-添加功能或更改库的某些元素时，总是很容易忘记更新类型声明。 </p><br><p> 这类不便之处还包括： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p> 当我们在第（0）行上创建对象验证器时。 我们想检查第（1）行中来自后端的真实答案并处理错误。 在第（2）行中，该<code>person</code>类型为Person。 但这没有发生。 不幸的是，这种检查不是类型保护。 </p><br><h3 id="reshenie-1"> 解决方案 </h3><br><p> 我决定将整个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">四方</a>库重写为Typescript，以便编译器可以检查该库与类型的对应关系。 在此过程中，我们在返回编译的验证器的函数中添加了一个类型参数，该参数将确定此类型的验证器是什么类型的防护器。 </p><br><p> 一个示例如下所示： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p> 现在在第（2）行上， <code>person</code>属于<code>Person</code>类型。 </p><br><h3 id="chitaemost"> 易读性 </h3><br><p> 在两种情况下，代码读取效果很差：检查是否符合一组特定的值（检查枚举）和检查对象的其他属性。 </p><br><p>  a）检查枚举 <br> 最初，有一个主意，我认为是个好主意。 我们将通过在我们的对象中添加字段“性别”进行演示。 <br> 电路的旧版本如下所示： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(<span class="hljs-string"><span class="hljs-string">'male'</span></span>, <span class="hljs-string"><span class="hljs-string">'female'</span></span>) }</code> </pre> <br><p> 该选项可读性强。 但是像往常一样，一切都超出了计划。 <br> 例如，在程序中有一个已声明的枚举： </p><br><pre> <code class="javascript hljs">enum Sex { Male = <span class="hljs-string"><span class="hljs-string">'male'</span></span>, Female = <span class="hljs-string"><span class="hljs-string">'female'</span></span> }</code> </pre> <br><p> 自然，我想在电路内部使用它。 因此，当更改其中一个值（例如“ male”-&gt;“ m”，“ female”-&gt;“ f”）时，验证方案也应更改。 </p><br><p> 因此，几乎总是枚举验证是这样写的： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)) }</code> </pre> <br><p> 看起来很笨重。 </p><br><p>  b）验证对象的剩余属性 </p><br><p> 假设我们在对象中添加了这样的特征-它可以具有其他字段，但是所有字段都必须是指向社交网络的链接-这意味着它们必须为<code>null</code>或字符串。 </p><br><p> 旧方案如下所示： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)), ...v.rest([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null }</span></span></code> </pre> <br><p> 此项突出显示了剩余的属性-已列出的属性。 使用散布运算符更可能使想要了解此方案的人感到困惑。 </p><br><h3 id="reshenie-2"> 解决方案 </h3><br><p> 如上所述，字符串不再是验证方案的一部分。 仅有三种类型的Javascript值保留为验证方案。 对象-描述对象的验证方案。 描述数组-几个有效性选项。 功能（库生成或自定义）-用于所有其他验证选项。 </p><br><p> 此规定允许添加功能，从而可以多次提高电路的可读性。 </p><br><p> 实际上，如果我们想将值与字符串“ male”进行比较该怎么办。 除了值本身和字符串“ male”之外，我们真的需要了解其他信息吗？ </p><br><p> 因此，决定添加基本类型的值作为电路的元素。 因此，在方案中遇到原始值的地方，这意味着这是根据此方案创建的验证器应检查的有效值。 我最好举个例子： </p><br><p> 如果我们需要检查数字是否等于42。 然后我们这样写： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> check42 = v(<span class="hljs-number"><span class="hljs-number">42</span></span>) check42(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true check42(41) // =&gt; false check42(43) // =&gt; false check42('42') // =&gt; false</span></span></code> </pre> <br><p> 让我们看看这如何影响人员模式（不考虑其他属性）： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-comment"><span class="hljs-comment">// null is primitive value sex: ['male', 'female'] // 'male', 'female' are primitive values }</span></span></code> </pre> <br><p> 使用预定义的枚举，我们可以这样重写它： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex) <span class="hljs-comment"><span class="hljs-comment">// same as ['male', 'female'] }</span></span></code> </pre> <br><p> 在这种情况下，使用枚举方法和使用散布运算符将对象中的有效值作为参数插入此方法的形式，消除了不必要的礼节。 </p><br><p> 什么是原始值：数字，字符串，字符， <code>true</code> ， <code>false</code> ， <code>null</code>和<code>undefined</code> 。 </p><br><p> 也就是说，如果我们需要将这些值与它们进行比较，则只需使用这些值即可。 还有一个验证库-它会创建一个验证器，该验证器严格将值与方案中指定的值进行比较。 </p><br><p> 为了验证残差属性，选择对对象的所有其他字段使用特殊属性： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), [v.rest]: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string] }</code> </pre> <br><p> 因此，电路看起来更具可读性。 还有更多类似Typescript广告的广告。 </p><br><h3 id="svyazannost-validatora-s-funkciey-kotoraya-sozdala-ego"> 验证器与创建它的功能有关 </h3><br><p> 在旧版本中，错误说明不属于验证程序。 它们被添加到<code>v</code>函数内部的数组中。 </p><br><p> 以前，为了获得验证错误的解释，您必须拥有一个验证器（以进行检查）和v（以获取无效性的解释）。 所有这些看起来如下： <br><br>  a）我们在图中添加说明 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>) age: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>), <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v( v.enum(...Object.values(Sex)), <span class="hljs-string"><span class="hljs-string">'wrong sex value'</span></span> ), ...v.rest( v( [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong social networks link'</span></span> ) ) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null })</span></span></code> </pre> <br><p> 对于电路的任何元素-您可以使用v编译器函数的第二个参数添加对错误的解释。 </p><br><p>  b）清除说明数组 </p><br><p> 在验证之前，有必要清除此全局数组，在验证过程中所有说明都记录在其中。 </p><br><pre> <code class="javascript hljs">v.clearContext() <span class="hljs-comment"><span class="hljs-comment">// same as v.explanations = []</span></span></code> </pre> <br><p>  c）验证 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPersonValid = checkPerson(person)</code> </pre> <br><p> 在此检查过程中，如果发现有效性，则在创建电路的阶段-给出了解释，该解释位于<code>v.explanation</code>全局数组中。 </p><br><p>  d）错误处理 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPersonValid) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">'Invalid person response: '</span></span> + v.explanation.join(<span class="hljs-string"><span class="hljs-string">'; '</span></span>)) } <span class="hljs-comment"><span class="hljs-comment">// ex. Throws 'Invalid person response: wrong name; wrong age'</span></span></code> </pre> <br><p> 如您所见，这里有一个大问题。 因为如果我们要使用验证器而不是创建它的地方。 我们不仅需要将其传递给参数，还要传递创建它的函数。 因为数组位于其中，所以将在其中添加说明。 </p><br><h3 id="reshenie-3"> 解决方案 </h3><br><p> 该问题的解决方法如下：解释成为验证功能本身的一部分。 从其类型可以理解： <br> 类型Validator =（值：任何，解释？：任何[]）=&gt;布尔值 </p><br><p> 现在，如果您需要对错误进行解释，则将要添加解释的数组传递给该数组。 </p><br><p> 因此，验证器成为一个独立的单元。 还添加了一种方法，该方法可以将验证函数转换为以下函数：如果该值有效，则返回null；如果该值无效，则返回说明数组。 </p><br><p> 现在，带有说明的验证如下所示： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(v.string, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>), <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v(v.number, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>) sex: v(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), <span class="hljs-string"><span class="hljs-string">'wrong sex'</span></span>) [v.rest]: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong social network'</span></span>) }) <span class="hljs-comment"><span class="hljs-comment">// ... const explanations = [] if (!checkPerson(person, explanation)) { throw new TypeError('Wrong person: ' + explanations.join('; ')) } // OR const getExplanation = v.explain(checkPerson) const explanations = getExplanation(person) if (explanations) { throw new TypeError('Wrong person: ' + explanations.join('; ')) }</span></span></code> </pre> <br><h2 id="posleslovie"> 后记 </h2><br><p> 我强调了三个前提，因此必须重写所有内容： </p><br><ul><li> 希望人们在写台词时不会弄错 </li><li> 使用全局变量（在这种情况下，为v.explanation数组） </li><li> 在开发过程中使用小示例进行测试-没有显示在真正的大案例中使用时出现的问题。 </li></ul><br><p> 但是我很高兴对这些问题进行了分析，并且该版本已经在我们的项目中使用。 我希望它对我们有用，不少于上一个。 </p><br><p> 谢谢大家的阅读，希望我的经验对您有所帮助。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453502/">https://habr.com/ru/post/zh-CN453502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453484/index.html">4位BCD计数器</a></li>
<li><a href="../zh-CN453486/index.html">美国自由市场原则</a></li>
<li><a href="../zh-CN453490/index.html">来自OpenStreetMap No.461的世界新闻（05/14/2019-05/05/2019）</a></li>
<li><a href="../zh-CN453492/index.html">Trello公司使用语义建模技术的业务流程自动化</a></li>
<li><a href="../zh-CN453496/index.html">快乐的化学家，同事</a></li>
<li><a href="../zh-CN453508/index.html">没有智能手机的人</a></li>
<li><a href="../zh-CN453510/index.html">所有您自己：为UiPath RPA创建新操作的教程</a></li>
<li><a href="../zh-CN453512/index.html">风格转移</a></li>
<li><a href="../zh-CN453514/index.html">iOS上的介绍性优惠指南</a></li>
<li><a href="../zh-CN453516/index.html">自动化程度最小。 零部分。 规划中</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>