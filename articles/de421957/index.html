<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüöí ü§üüèº ü§≥ Wie Yandex Augmented Reality in Maps f√ºr iOS erstellt hat. Erfahrung mit ARKit üíù ‚öñÔ∏è ü§´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt weniger Menschen, die von Augmented Reality (AR) √ºberrascht werden k√∂nnen. F√ºr einige ist diese Technologie f√ºr ein paar Stunden mit einem Spi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Yandex Augmented Reality in Maps f√ºr iOS erstellt hat. Erfahrung mit ARKit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/421957/"><p>  Es gibt weniger Menschen, die von Augmented Reality (AR) √ºberrascht werden k√∂nnen.  F√ºr einige ist diese Technologie f√ºr ein paar Stunden mit einem Spielzeug verbunden.  Andere finden es praktischer. </p><br><p>  Mein Name ist Dmitry und ich entwickle Yandex.Maps f√ºr iOS.  Heute werde ich den Lesern von Habr erz√§hlen, wie wir Routing mit Augmented Reality erstellt haben.  Sie lernen auch die Funktionen der Verwendung des ARKit-Frameworks kennen, dank dessen die Einf√ºhrung von Augmented Reality nicht mehr nur Fachleuten auf dem Gebiet der Computer Vision vorbehalten ist. </p><br><img width="800" src="https://habrastorage.org/webt/zb/le/i2/zblei2e2hojscltqyw2l1k4csds.png"><br><p><a name="habracut"></a>  Im Jahr 2009 war das Esquire-Magazin das erste unter den Medien, das seinem Produkt Augmented-Reality-Unterst√ºtzung hinzuf√ºgte.  Auf dem Cover des Magazins stand ein Code, mit dem man Robert Downey Jr. "live" sehen konnte. </p><br><img src="https://habrastorage.org/webt/0v/-a/58/0v-a585aysdjqwyfrmtrbxgv05k.jpeg"><br><p>  Der Einsatz von AR in der Unterhaltungsindustrie war nicht darauf beschr√§nkt.  Ein anschauliches Beispiel war das 2016 ver√∂ffentlichte Spiel Pokemon Go.  Bis Juli dieses Jahres wurde es √ºber 16 Millionen Mal heruntergeladen.  Der Erfolg des Spiels f√ºhrte zur Entstehung zahlreicher Klone mit AR. </p><br><p>  Wichtige Ereignisse in der AR-Branche in den letzten Jahren k√∂nnen als Ank√ºndigungen von Google Glass und Microsoft Hololens angesehen werden.  Das Erscheinungsbild solcher Ger√§te zeigt den Vektor, in dem sich gro√üe Unternehmen bewegen. </p><br><p>  Apple war keine Ausnahme.  2017 f√ºhrte das Unternehmen das ARKit-Framework ein, dessen Bedeutung f√ºr die Branche kaum zu √ºbersch√§tzen ist.  Und wir werden ausf√ºhrlicher dar√ºber sprechen. </p><br><h2 id="arkit">  ARKit </h2><br><p>  Funktionen von ARKit, die die Verwendung von AR vereinfachen: </p><br><ul><li>  Mangel an speziellen Tags (Markern), </li><li>  Integration in vorhandene Apple 2D / 3D-Grafik-Frameworks - SceneKit, SpriteKit, Metal, </li><li>  hohe Genauigkeit bei der Bestimmung der Position und Ausrichtung des Ger√§ts im Raum, </li><li>  Kamera oder Sensoren m√ºssen nicht kalibriert werden. </li></ul><br><p>  Unter der Haube von ARKit befindet sich ein visuelles Tr√§gheits-Kilometerz√§hlersystem, das Daten mit den visuellen (Kamera) und tr√§gen (Beschleunigungsmesser, Gyroskop) Subsystemen des Ger√§ts kombiniert, um Position und Verschiebung auf der B√ºhne zu bestimmen.  Das Verbindungselement dieses Systems ist der Kalman-Filter - ein Algorithmus, der zu jedem Zeitpunkt die besten Messwerte der beiden Subsysteme ausw√§hlt und uns in Form unserer Position und Orientierung auf der B√ºhne zur Verf√ºgung stellt.  ARKit hat auch ein ‚ÄûVerst√§ndnis‚Äú f√ºr die Szene - wir k√∂nnen horizontale und vertikale Fl√§chen sowie die Lichtverh√§ltnisse der Szene definieren.  Wenn Sie der Szene ein Objekt hinzuf√ºgen, k√∂nnen Sie daher eine Standardbeleuchtung hinzuf√ºgen, wodurch das Objekt realistischer aussieht. </p><br><div class="spoiler">  <b class="spoiler_title">√úbrigens</b> <div class="spoiler_text"><p>  In K√ºrze wird die Framework-Version 2.0 ver√∂ffentlicht, in der neue Funktionen hinzugef√ºgt und die Positionierungsgenauigkeit erheblich verbessert werden. </p></div></div><br><p>  Mit ARKit konnten Entwickler hochwertige Augmented Reality in ihre Anwendungen einbetten und dabei viel weniger Aufwand betreiben.  Wir werden dies am Beispiel von Yandex.Maps demonstrieren. </p><br><h2 id="marshrutizaciya-s-ar-v-yandekskartah">  Routing mit AR auf Yandex.Maps </h2><br><p>  Normalerweise kommen nach der Ank√ºndigung der neuen Version von iOS viele Teams bei Yandex zusammen, um die M√∂glichkeit der Einf√ºhrung neuer Funktionen in ihre Anwendungen zu er√∂rtern.  Das Yandex.Mart-Team tat dasselbe.  Innerhalb eines Monats nach der Ank√ºndigung von ARKit haben wir h√§ufig dar√ºber gesprochen, wie es in Maps implementiert werden kann.  Welche Ideen haben wir nicht voneinander geh√∂rt!  Schnell kamen wir zu dem Schluss, dass eine der n√ºtzlichsten und oberfl√§chlichsten L√∂sungen die Verwendung von Augmented Reality beim Routing ist. </p><br><p>  Die Wahl dieser Idee war auf die Tatsache zur√ºckzuf√ºhren, dass viele Kartenbenutzer h√§ufig auf eine Situation sto√üen, in der Sie sich in einem unbekannten Bereich befinden und schnell entscheiden m√ºssen, wohin Sie gehen m√∂chten.  Der Standardansatz f√ºr den durchschnittlichen Kartenbenutzer besteht darin, die Anwendung zu √∂ffnen, eine Fu√üg√§ngerroute zu erstellen und an Ort und Stelle zu bestimmen, wohin er sich bewegen soll.  Die Idee, Augmented Reality in das Fu√üg√§ngerrouting einzuf√ºhren, besteht darin, den Benutzer vor unn√∂tigen Aktionen zu bewahren und sofort zu zeigen, wo Sie sich direkt √ºber dem Kamerabild bewegen m√ºssen. </p><br><p>  Zun√§chst m√∂chte ich ein paar Worte zum Routing sagen.  Was setze ich in dieses Konzept ein?  Unter dem Gesichtspunkt der Implementierung in einer mobilen Anwendung ist dies eine ziemlich standardm√§√üige Reihe von Schritten, die es dem Benutzer erm√∂glichen, von Punkt A nach Punkt B zu gelangen: </p><br><ul><li>  Auswahl der Abfahrts- und Ankunftspunkte, </li><li>  Empfangen einer Route in Form einer Reihe von Punkten in geografischen (Breiten-, L√§ngen-) Koordinaten, </li><li>  Anzeige auf der Karte der Routenlinie, </li><li>  Begleitung des Benutzers mit zus√§tzlichen Informationen w√§hrend der Fahrt entlang der Route. </li></ul><br><p>  Wir werden nicht auf die ersten beiden Punkte eingehen.  Ich kann nur sagen, dass wir die Route √ºber unsere plattform√ºbergreifende Bibliothek Yandex.Mapkit erhalten, die Ihnen auch in Form eines Pods zur Verf√ºgung steht.  Wie unterscheidet sich Augmented Reality Routing vom Standard Routing in Karten?  Der Hauptunterschied ist zun√§chst eine fast vollst√§ndig versteckte Karte.  Der Schwerpunkt liegt auf dem Bildschirmbereich mit dem Bild des Videostreams von der Kamera, dem zus√§tzliche visuelle Elemente √ºberlagert sind (Zielmarke, Hilfsmarke und Routenlinienbild).  Jedes dieser visuellen Elemente hat seine eigene semantische Last und seine eigene Logik (wann und wie es angezeigt werden soll).  Wir werden die Rolle jedes dieser Elemente sp√§ter genauer betrachten, aber jetzt schlage ich vor, die Aufgaben zu betrachten, die wir vor uns hatten: </p><br><ul><li>  lernen, Objekte in der ARKit-Szene zu positionieren und ihre geografischen Koordinaten zu kennen, </li><li>  Erfahren Sie, wie Sie die erforderliche Benutzeroberfl√§che in einer 3D-Szene mit ausreichender Leistung zeichnen. </li></ul><br><p>  Wir mussten die Koordinaten der Punkte von geografisch in die Koordinaten auf der B√ºhne konvertieren, ausw√§hlen, welche Punkte angezeigt werden sollen, und alle erforderlichen Benutzeroberfl√§chen √ºber dem Kamerabild an der richtigen Position anzeigen.  Aber alles stellte sich als etwas komplizierter heraus, als es auf den ersten Blick schien. </p><br><p>  Bevor ich mit der direkten Implementierung der Funktionen begann, wurde einem meiner Kollegen die Aufgabe √ºbertragen, einen Prototyp zu erstellen, der die M√∂glichkeit (oder Unm√∂glichkeit) zeigt, √§hnliche Funktionen mit einem zug√§nglichen Satz von Tools zu implementieren.  Zwei Wochen lang beobachteten wir, wie San Sanych mit einem Telefon in der Hand die Freifl√§chen des Freiraums und die nahe Umgebung unseres B√ºros pfl√ºgte und die Welt um uns herum durch das Prisma der Kamera betrachtete.  Als Ergebnis haben wir einen funktionierenden Prototyp erhalten, der jeden Punkt der Route als Markierung auf der B√ºhne mit einem Abstand dazu zeigt.  Mit Hilfe dieses Prototyps war es unter einer erfolgreichen Kombination von Umst√§nden m√∂glich, von der Arbeit zur U-Bahn zu gelangen und fast nie verloren zu gehen.  Im Ernst, er best√§tigte die M√∂glichkeit, die beabsichtigte Funktionalit√§t zu implementieren.  Es gab jedoch noch eine Reihe von Aufgaben, die unser Team noch l√∂sen musste. </p><br><p>  Alles begann mit dem Studium der Werkzeuge.  Zu diesem Zeitpunkt hatte nur eine Person im Team Erfahrung mit 3D-Grafiken.  Werfen wir einen kurzen Blick auf die Tools, mit denen sich jeder befassen muss, der √ºber die Implementierung solcher Ideen mit ARKit nachdenkt. </p><br><h2 id="instrumenty-i-api">  Tools und APIs </h2><br><p>  Die Hauptaufgabe beim Rendern von Objekten besteht darin, Szenenobjekte f√ºr das SceneKit-Framework zu erstellen und zu verwalten.  Mit dem Aufkommen von ARKit wurde dem Entwickler die ARSCNView-Klasse (der Nachkomme der SCNView-Klasse - die Basisklasse f√ºr die Arbeit mit der Szene in SceneKit) verf√ºgbar, die die meisten zeitaufw√§ndigen Aufgaben der Integration von ARKit und SceneKit l√∂st, n√§mlich: </p><br><ul><li>  Synchronisation der Position des Telefons im Raum mit der Position der Kamera auf der B√ºhne, </li><li>  Das Koordinatensystem der Szene stimmt mit dem Koordinatensystem ARKit √ºberein. </li><li>  Als Hintergrund der Szene wird der Videostream von der Kamera des Ger√§ts verwendet. </li></ul><br><p>  Das ARSCNView-Objekt stellt dem Entwickler auch ein Augmented-Reality-Sitzungsobjekt zur Verf√ºgung, das mit der erforderlichen Konfiguration gestartet, gestoppt oder mit dem Delegate-Objekt f√ºr verschiedene Ereignisse abonniert werden kann. </p><br><p>  Um der Szene Objekte hinzuzuf√ºgen, werden Erben oder direkt SCNNode-Objekte verwendet.  Diese Klasse repr√§sentiert eine Position (dreidimensionaler Vektor) im Koordinatensystem ihres √ºbergeordneten Elements.  Auf diese Weise erhalten wir einen Baum von Objekten in der Szene mit einer Wurzel in einem speziellen Objekt - dem Wurzelknoten unserer Szene.  Alles hier ist der Hierarchie der UIView-Objekte in UIKit sehr √§hnlich.  SCNNode-Objekte k√∂nnen auf der B√ºhne angezeigt werden, wenn sie Material und Beleuchtung hinzuf√ºgen. </p><br><p>  Um einer mobilen Anwendung Augmented Reality hinzuzuf√ºgen, m√ºssen Sie auch die Hauptobjekte der ARKit-API kennen.  Das wichtigste ist das Objekt der Augmented Reality-Sitzung - ARSession.  Dieses Objekt f√ºhrt die Datenverarbeitung durch und ist f√ºr den Lebenszyklus der Augmented Reality-Sitzung verantwortlich.  Der Zweck dieses Artikels besteht nicht darin, die Dokumentation von ARKit und SceneKit erneut zu erz√§hlen. Daher werde ich nicht √ºber alle verf√ºgbaren Konfigurationsparameter der Augmented Reality-Sitzung schreiben, sondern mich auf einen der wichtigsten Parameter der Konfiguration der Augmented Reality-Sitzung f√ºr Navigationsanwendungen konzentrieren - worldAlignment.  Dieser Parameter bestimmt die Richtung der Achsen der Szene zum Zeitpunkt der Initialisierung der Sitzung.  Im Allgemeinen erstellt ARKit beim Initialisieren einer Augmented-Reality-Sitzung ein Koordinatensystem mit einem Anfang an einem Punkt, der mit der aktuellen Position des Telefons im Raum √ºbereinstimmt, und lenkt die Achse dieses Systems abh√§ngig vom Wert der Eigenschaft woldAlignment.  In unserer Implementierung wird der SchwerkraftAndHeading-Wert verwendet, was bedeutet, dass die Achsen wie folgt ausgerichtet sind: die Y-Achse - entgegen der Schwerkraftrichtung, die Z-Achse - nach S√ºden und die X-Achse - nach Osten. </p><br><p><img src="https://habrastorage.org/webt/r7/cj/d5/r7cjd5acp__8jkrb83rfytbsnr4.png" alt="Weltausrichtung-Schwerkraft und √úberschrift"></p><br><p>  Bei einer guten Kombination von Umst√§nden werden die X / Z-Achsen zwar mit den Richtungen nach S√ºd / Ost ausgerichtet, aber aufgrund von Fehlern bei den Kompassablesungen k√∂nnen die Achsen in einem bestimmten Winkel zu der in der Dokumentation beschriebenen Richtung ausgerichtet werden.  Dies ist eines der Probleme, mit denen wir uns befassen mussten, aber dazu sp√§ter mehr. </p><br><p>  Nachdem wir die grundlegenden Tools untersucht haben, fassen wir zusammen: Beim Zuordnen einer Route mit SceneKit werden der Szene SCNNode-Objekte an den Positionen hinzugef√ºgt, die durch Konvertieren von geografischen Koordinaten in Szenenkoordinaten erhalten werden.  Bevor wir √ºber die Koordinatenkonvertierung und allgemein √ºber das Platzieren von Objekten in der Szene sprechen, wollen wir uns mit den Problemen beim Rendern von UI-Elementen befassen, vorausgesetzt, wir kennen die Position der Objekte auf der B√ºhne. </p><br><h1 id="metka-finisha">  Zielmarke </h1><br><p>  Das visuelle Hauptelement des Fu√üg√§ngerroutings mit Augmented Reality ist die Zielmarke, die den Endpunkt der Route anzeigt.  Ebenfalls √ºber der Markierung zeigen wir dem Benutzer die Entfernung zum Endpunkt der Route. </p><br><p><img src="https://habrastorage.org/webt/xw/94/hx/xw94hxwjiepqzhlov9hwmig1wee.jpeg" alt="Ziel-Ortsmarken-√úbersicht"></p><br><h2 id="razmer">  Gr√∂√üe </h2><br><p>  Als uns das Design dieses Tags zum ersten Mal gezeigt wurde, haben wir zuerst die Anforderungen f√ºr die Gr√∂√üe dieses Tags ber√ºcksichtigt.  Sie haben die Regeln der perspektivischen Projektion nicht befolgt.  Ich werde erkl√§ren, dass in den dreidimensionalen Engines, die zum Erstellen von Computerspielen verwendet werden, der ‚ÄûLook‚Äú mithilfe einer perspektivischen Projektion modelliert wird.  Nach den Regeln der perspektivischen Projektion werden entfernte Objekte in kleinerem Ma√üstab dargestellt, und parallele Linien sind im Allgemeinen nicht parallel.  Somit √§ndert sich die Projektionsgr√∂√üe des Objekts auf der Bildschirmebene linear (nimmt ab), wenn sich die Kamera vom Objekt in der Szene entfernt.  Aus der Beschreibung der Layouts folgt, dass die Gr√∂√üe der Markierung auf dem Bildschirm eine feste (maximale) Gr√∂√üe hat, wenn sie weniger als 50 m entfernt wird, und dann linear von 50 m auf 2 km abnimmt, wonach die minimale Gr√∂√üe unver√§ndert bleibt.  Solche Anforderungen sind offensichtlich auf die Benutzerfreundlichkeit zur√ºckzuf√ºhren.  Sie erm√∂glichen es dem Benutzer, den Endpunkt der Route niemals aus der Ansicht zu verlieren, sodass der Benutzer immer eine Vorstellung davon hat, wohin er sich bewegen soll. </p><br><p><img src="https://habrastorage.org/webt/zr/tm/lu/zrtmluh1rmc08_bop7wkkyak3z8.png" alt="Finish-ortsmarke-Besitze-anforderungen"></p><br><p>  Wir mussten verstehen, wie wir uns in den SceneKit-Projektionsmechanismus einklemmen konnten, der nach bestimmten Regeln funktionierte.  Ich m√∂chte sofort darauf hinweisen, dass wir ungef√§hr zwei Wochen Zeit hatten, um alles zu erledigen, sodass einfach keine Zeit blieb, eine eingehende Analyse verschiedener Ans√§tze zur L√∂sung der gestellten Probleme durchzuf√ºhren.  Jetzt ist es viel einfacher, unsere Entscheidungen zu analysieren und zu bewerten, und wir k√∂nnen daraus schlie√üen, dass die meisten getroffenen Entscheidungen richtig waren.  Das Erfordernis der Gr√∂√üe war tats√§chlich der erste Stolperstein.  Alle unten beschriebenen Probleme k√∂nnen sowohl mit SceneKit als auch mit UIKit gel√∂st werden.  Ich habe versucht, detailliert zu erkl√§ren, wie jedes der Probleme mit beiden Ans√§tzen gel√∂st werden kann.  Welchen Ansatz Sie verwenden, liegt bei Ihnen. </p><br><p>  Stellen wir uns vor, wir haben beschlossen, ein Finish-Label mit SceneKit zu implementieren.  Wenn wir ber√ºcksichtigen, dass die Beschriftung gem√§√ü den Layouts wie ein Kreis auf dem Bildschirm aussehen sollte, wird klar, dass das Beschriftungsobjekt in SceneKit eine Kugel sein sollte (da die Projektion der Kugel auf eine beliebige Ebene ein Kreis ist).  Damit die Projektion einen bestimmten Radius auf dem Bildschirm hat, der in den Anforderungen der Designer definiert ist, muss der Radius der Kugel zu jedem Zeitpunkt bekannt sein.  Wenn Sie also eine Kugel mit einem bestimmten Radius an einem bestimmten Punkt auf der Szene platzieren und ihren Radius st√§ndig aktualisieren, wenn Sie sich n√§hern oder wegbewegen, erhalten Sie jederzeit eine Projektion auf die Leinwand mit der erforderlichen Gr√∂√üe.  Der Algorithmus zum Bestimmen des Radius der Kugel zu einem beliebigen Zeitpunkt lautet wie folgt: </p><br><ol><li>  Definieren Sie die Position des Objekts auf der B√ºhne - den Mittelpunkt der Kugel. </li><li>  Suchen Sie die Projektion dieses Punkts auf der Bildschirmebene (mithilfe der SceneKit-API). </li><li>  Um die erforderliche Gr√∂√üe der Markierung auf dem Bildschirm zu bestimmen, ermitteln wir den Abstand von der Kamera zum Mittelpunkt der Kugel auf der B√ºhne. </li><li>  Wir bestimmen die erforderliche Gr√∂√üe auf dem Bildschirm anhand des Abstands zum Objekt anhand der im Entwurf beschriebenen Regeln. </li><li>  Wenn wir die Gr√∂√üe der Markierung auf dem Bildschirm (Durchmesser des Kreises) kennen, w√§hlen wir einen beliebigen Punkt auf diesem Kreis. </li><li>  Machen Sie die umgekehrte Projektion (unprojectPoint) des ausgew√§hlten Punktes. </li><li>  Wir finden die L√§nge des Vektors vom empfangenen Punkt auf der B√ºhne bis zum Mittelpunkt der Kugel. </li></ol><br><p>  Der erhaltene Wert der L√§nge des Vektors ist der gew√ºnschte Radius der Kugel. </p><br><p><img src="https://habrastorage.org/webt/go/2o/zu/go2ozuggr3zpucmewdrrybxbedy.png" alt="Finish-Ortsmarke-Gr√∂√üe-L√∂sung-Szenekit"></p><br><p>  Zum Zeitpunkt der Implementierung war es uns nicht m√∂glich, die Gr√∂√üe des Objekts in der Szene zu bestimmen, und wir haben beschlossen, die Zielmarke mit UIKit zu zeichnen.  In diesem Fall wiederholt der Algorithmus die Schritte 1 bis 5, wonach ein Kreis der gew√ºnschten Gr√∂√üe mit den UIKit-Werkzeugen auf dem Bildschirm mit der Mitte an dem in Schritt 2 erhaltenen Punkt gezeichnet wird.  Eine beispielhafte Implementierung eines Labels mit UIKit finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Ein paar Worte zum Code</b> <div class="spoiler_text"><p>  Am Ende des Artikels habe ich mehrere Links zu n√ºtzlichen und einfach interessanten Materialien gegeben, einschlie√ülich Beispielen, in denen Sie den realen Code, der die im Artikel vorgestellten Probleme l√∂st und die vorgestellten Algorithmen implementiert, detailliert betrachten k√∂nnen.  Meiner Meinung nach ist das Hauptinteresse der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prototyp der Fu√üg√§ngerf√ºhrung</a> , der alle Funktionen zusammenbringt, mit Ausnahme des Achseneinstellmechanismus, der nachstehend ausf√ºhrlich beschrieben wird. </p><br><p>  Der obige Code erhebt keinen Anspruch auf Optimalit√§t, Vollst√§ndigkeit und Produktionsqualit√§t =) </p></div></div><br><p>  Der Unterschied zwischen der Verwendung von SceneKit und UIKit in diesem Fall besteht auch darin, dass bei der Implementierung in SceneKit das SCNNode-Objekt f√ºr den Routenendpunkt (Zielmarke) mit Material und Geometrie erstellt wird, da es bei Verwendung von UIKit sichtbar sein muss Wir ben√∂tigen das Knotenobjekt ausschlie√ülich, um nach der Projektion auf die Bildschirmebene zu suchen (um die Mitte der Markierung auf dem Bildschirm zu bestimmen).  In diesem Fall m√ºssen Geometrie und Material nicht hinzugef√ºgt werden.  Beachten Sie, dass der Abstand zwischen der Kamera und dem SCNNode-Objekt des Endpunkts der Route auf zwei Arten ermittelt werden kann: anhand der geografischen Koordinaten der Punkte oder als L√§nge des Vektors zwischen den Punkten in der Szene.  Dies ist m√∂glich, weil das Kameraobjekt eine SCNNode-Eigenschaft ist.  Um den Kameraknoten zu erhalten, m√ºssen Sie auf die pointOfView-Eigenschaft unserer Szene verweisen. </p><br><p>  Wir haben gelernt, wie der Radius des Zielmarkierungsknotens zu einem beliebigen Zeitpunkt bei der Implementierung in SceneKit und die Position der Ansicht der Zielmarke bei Implementierung in UIKit bestimmt werden.  Es bleibt zu verstehen, wann es notwendig ist, diese Werte zu aktualisieren?  Dieser Ort ist die SCNSceneRendererDelegate-Objektmethode: </p><br><pre><code class="hljs objectivec">renderer(_ renderer: <span class="hljs-built_in"><span class="hljs-built_in">SCNSceneRenderer</span></span>, didRenderScene scene: <span class="hljs-built_in"><span class="hljs-built_in">SCNScene</span></span>, atTime time: TimeInterval)</code> </pre> <br><p>  Diese Methode wird nach jedem gerenderten Szenenbild aufgerufen.  Durch Aktualisieren der Eigenschaftswerte im Hauptteil dieser Methode erhalten wir eine korrekt angezeigte Endbeschriftung. </p><br><h2 id="animaciya">  Animation </h2><br><p>  Nachdem die Zielmarke in dev angezeigt wurde, f√ºgten wir dieser Marke eine Wellenanimation hinzu.  Ich denke, f√ºr die meisten iOS-Entwickler ist das Erstellen von Animationen keine gro√üe Sache.  Beim Nachdenken √ºber die Implementierungsmethode stie√üen wir jedoch auf das Problem, den Rahmen unserer Ansicht st√§ndig zu aktualisieren.  Beachten Sie, dass in den meisten F√§llen Animationen zu statischen UIView-Objekten hinzugef√ºgt werden.  Ein √§hnliches Problem - eine st√§ndige Aktualisierung des Radius der Knotengeometrie tritt bei der Implementierung mit SceneKit auf.  Tatsache ist, dass die pulsierende Animation auf die Animation der Gr√∂√üe des Kreises (f√ºr UIKit) und des Radius der Kugel (f√ºr SceneKit) hinausl√§uft.  Ja, ja, wir wissen, dass diese Art von Animation in UIKit mit CALayer ausgef√ºhrt werden kann. Zur Vereinfachung des Geschichtenerz√§hlens habe ich mich jedoch entschlossen, dieses Problem f√ºr zwei Frameworks symmetrisch zu betrachten.  Betrachten Sie eine Implementierung auf UIKit.  Wenn Sie dem vorhandenen Code, der den Ansichtsrahmen aktualisiert, Code hinzuf√ºgen, der denselben Frame animiert, wird die Animation durch explizites Festlegen des Frames unterbrochen.  Als L√∂sung f√ºr dieses Problem haben wir uns daher entschlossen, die Animation der Eigenschaft transform.scale.xy des UIView-Objekts zu verwenden.  Bei der Implementierung mit SceneKit m√ºssen Sie dem SCNNode-Objekt eine Animation der scale-Eigenschaft hinzuf√ºgen.  Das Sch√∂ne an der Verwendung von SceneKit in diesem Fall ist die Tatsache, dass es CoreAnimation vollst√§ndig unterst√ºtzt, sodass das Erlernen einer neuen API nicht erforderlich ist.  Der Code, der eine Animation √§hnlich der Beschriftungsanimation in Yandex.Maps implementiert, sieht ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="hljs objectivec">let animationGroup = <span class="hljs-built_in"><span class="hljs-built_in">CAAnimationGroup</span></span>.init() animationGroup.duration = <span class="hljs-number"><span class="hljs-number">1.0</span></span> animationGroup.repeatCount = .infinity let opacityAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>) opacityAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">1.0</span></span>) opacityAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">0.1</span></span>) let scaleAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"scale"</span></span>) scaleAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) scaleAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>)) animationGroup.animations = [opacityAnimation, scaleAnimation] finishNode.addAnimation(animationGroup, forKey: <span class="hljs-string"><span class="hljs-string">"animations"</span></span>)</code> </pre> <br><h2 id="bilbord">  Plakatwand </h2><br><p>  Am Anfang des Artikels erw√§hnte ich eine Werbetafel mit einem Abstand zum Endpunkt der Route, die im Wesentlichen ein Etikett mit Text ist, der sich immer √ºber der Zielmarke befindet.  Aus Tradition werde ich die Probleme skizzieren, die mit Implementierungen auf UIKit und SceneKit verbunden sind, und m√∂gliche L√∂sungen f√ºr jedes der Frameworks erl√§utern. </p><br><p>  Beginnen wir mit UIKit.  In diesem Fall handelt es sich bei der Werbetafel um ein regul√§res UILabel, bei dem der Text st√§ndig aktualisiert wird und die Entfernung zum Endpunkt der Route anzeigt.  Schauen wir uns das Problem an, mit dem wir konfrontiert sind. </p><br><p><img src="https://habrastorage.org/webt/in/ad/7t/inad7t6_f7xu3hskdge0--hka38.png" alt="Finish-Ortsmarke-Plakat-Problem-Uikit"></p><br><p>  Wenn Sie einem Rahmen eine Beschriftung zuweisen und dann das Telefon drehen, werden wir feststellen, dass sich der Rahmen nicht √§ndert (es w√§re seltsam, wenn dies nicht der Fall w√§re).  Gleichzeitig m√∂chten wir, dass das Etikett parallel zur Erdebene bleibt. </p><br><p><img src="https://habrastorage.org/webt/wq/7w/13/wq7w13m7byfynimnxcuxktdkpyi.png" alt="Finish-Ortsmarke-Plakat-Wunsch-Uikit"></p><br><p>  Ich denke, jeder versteht, dass wir beim √Ñndern der Ausrichtung des Ger√§ts das Etikett drehen m√ºssen, aber in welchem ‚Äã‚ÄãWinkel?  Wenn Sie die Imagination einschalten und sich alle Achsen der an diesem Prozess beteiligten Koordinatensysteme und Vektoren vorstellen, k√∂nnen wir schlie√üen, dass der Drehwinkel gleich dem Winkel zwischen der x-Achse des UIKit-Koordinatensystems und der Projektion der X-Achse des SceneKit-Koordinatensystems auf die Bildschirmebene ist. </p><br><p><img src="https://habrastorage.org/webt/cx/2p/6r/cx2p6rgc8dcat469mz75u1qitbs.png" alt="Finish-Ortsmarke-Plakat-L√∂sung-Uikit"></p><br><p>  Eine einfache Aufgabe, die erneut die N√ºtzlichkeit des Schulgeometriekurses unter Beweis stellte. </p><br><p>  Wenn Sie die Zielmarke mit SceneKit implementieren, m√ºssen Sie die Werbetafel h√∂chstwahrscheinlich mit SceneKit-Werkzeugen mit Abstand rendern. Dies bedeutet, dass Sie definitiv die Aufgabe haben, das SCNNode-Objekt immer auf die Kamera auszurichten.  Ich denke, das Problem wird klarer, wenn Sie sich das Bild ansehen: </p><br><p><img src="https://habrastorage.org/webt/ns/pz/we/nspzwezwp8erjsfxoit4un1pgie.png" alt="Finish-Placemark-Billboard-Problem-Scenekit"></p><br><p>  Dieses Problem wird mithilfe der SCNBillboardConstraint-API gel√∂st.  Wenn wir der Sammlung von Konstraten unseres Knotens eine Konstante mit einer freien Achse Y hinzuf√ºgen, erhalten wir einen Knoten, der sich um die Y-Achse seines Koordinatensystems dreht, um immer zur Kamera ausgerichtet zu sein.  Die einzige Aufgabe des Entwicklers besteht darin, diesen Knoten auf der richtigen H√∂he zu platzieren, damit die Werbetafel mit dem Abstand f√ºr den Benutzer immer sichtbar ist. </p><br><pre> <code class="hljs objectivec">let billboardConstraint = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardConstraint</span></span>() billboardConstraint.freeAxes = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardAxis</span></span>.Y finishNode.constraints = [billboardConstraint]</code> </pre> <br><h1 id="vspomogatelnaya-metka">  Assistent Tag </h1><br><p>  Als eines der Hauptmerkmale des Fu√üg√§ngerroutings mit Augmented Reality betrachten wir innerhalb des Teams ein Zusatzetikett - ein spezielles visuelles Element, das auf dem Bildschirm angezeigt wird, wenn der Endpunkt der Route die Sichtbarkeitszone verl√§sst und dem Benutzer zeigt, wo das Telefon gedreht werden muss, damit das Etikett auf dem Bildschirm angezeigt wird Ziellinie. </p><br><p><img src="https://habrastorage.org/webt/ze/8x/wg/ze8xwgjihp8s2g9wl15r3epoui0.png" alt="Finish-Placemark-Hinweis-√úbersicht"></p><br><p>  Ich bin sicher, dass viele der Leser in einigen Spielen auf √§hnliche Funktionen gesto√üen sind, meistens auf Sch√ºtzen.  Was f√ºr eine √úberraschung unser Team war, als wir dieses UI-Element in den Layouts sahen.  Ich muss sofort sagen, dass die korrekte Implementierung einer solchen Funktion m√∂glicherweise mehr als eine Stunde Experimentieren erfordert, aber das Endergebnis ist die aufgewendete Zeit wert.  Wir haben zun√§chst Anforderungen definiert, n√§mlich: </p><br><ul><li>  Bei jeder Ausrichtung des Ger√§ts bewegt sich das Etikett entlang der Bildschirmr√§nder. </li><li>  Wenn sich der Benutzer um 180 Grad zum Endpunkt der Route gedreht hat, wird die Beschriftung am unteren Bildschirmrand angezeigt. </li><li>  Zu jedem Zeitpunkt sollte das Abbiegen in Richtung der Markierung die k√ºrzeste Abbiegung zum Endpunkt der Route sein. </li></ul><br><p>  Nachdem wir die Anforderungen beschrieben hatten, begannen wir mit der Implementierung.  Fast sofort kamen wir zu dem Schluss, dass das Rendern mit UIKit erfolgen w√ºrde.  Das Hauptproblem bei der Implementierung war die Bestimmung des Zentrums dieses Etiketts zu jedem Zeitpunkt.  Nach Pr√ºfung der Zielmarke sollte eine solche Aufgabe keine Schwierigkeiten verursachen, daher werde ich nicht n√§her auf ihre L√∂sung eingehen.  In dem Artikel werde ich nur eine Beschreibung des Algorithmus zur Auswahl der Mitte des Hilfsetiketts geben, und den Quellcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Suchzentrum-Algorithmus Suchalgorithmus: </p><br><ol><li>  Erstellen Sie ein SCNNode-Objekt f√ºr den Routenendpunkt mit einer Position in der Szene, die sich aus der geografischen Koordinate des Punkts ergibt. </li><li>  Finden Sie die Projektion eines Punktes auf der Bildschirmebene. </li><li>  Finden Sie den Schnittpunkt des Segments von der Mitte des Bildschirms bis zum Punkt der gefundenen Projektion mit den Segmenten der Grenzen des Bildschirms im Koordinatensystem des Bildschirms. </li></ol><br><p><img src="https://habrastorage.org/webt/pm/77/-v/pm77-vmlq5p6zmi7qe0yfkm7rvo.png" alt="Finish-Placemark-Hinweis-L√∂sung"></p><br><p>  Der gefundene Schnittpunkt ist das gew√ºnschte Zentrum der Hilfsmarke.  In Analogie zu dem Code, der die Endetikettenparameter aktualisiert, haben wir den Code, der das Hilfsetikett rendert, in die oben bereits erw√§hnte Delegate-Methode eingef√ºgt. </p><br><h1 id="poliliniya-marshruta">  Polylinie weiterleiten </h1><br><p>  Nachdem der Benutzer eine Route erstellt und die Zielmarke auf dem Bildschirm gesehen hat, kann er sie erreichen, indem er sich nur in Richtung der Markierung orientiert. Das Routing wird jedoch so genannt, weil es dem Benutzer die Route anzeigt.  Wir dachten, dass es sehr seltsam w√§re, die Funktionalit√§t des Fu√üg√§ngerroutings zu reduzieren, ohne die Routenanzeige von der AR-Version auszuschlie√üen.  Um die Routenlinie zu visualisieren, wurde beschlossen, eine Reihe von Pfeilen anzuzeigen, die sich entlang der Route bewegen.  In diesem Fall waren die Designer davon √ºberzeugt, dass die Pfeile beim Wegbewegen praktisch verschwinden w√ºrden (die Gr√∂√üe w√ºrde durch die Regeln der perspektivischen Projektion bestimmt), und es wurde beschlossen, SceneKit f√ºr die Implementierung zu verwenden. </p><br><p>  Bevor Sie mit der Beschreibung der Implementierung fortfahren, ist zu beachten, dass die Pfeile konstruktionsbedingt einen Abstand von 3 m voneinander haben sollten.  Wenn Sie die Anzahl der Objekte (Pfeile) sch√§tzen, die mit einer ungef√§hr 1 km langen Route gerendert werden m√ºssen, sind es ungef√§hr 330 Teile.  Gleichzeitig wird jedem Objekt eine Bewegungsanimation entlang seines Streckenabschnitts hinzugef√ºgt.  Beachten Sie, dass die Pfeile, die in einem Abstand von etwa 100 bis 150 Metern von der Position der Kamera auf der B√ºhne entfernt sind, aufgrund ihrer geringen Gr√∂√üe praktisch unsichtbar sind.  Unter Ber√ºcksichtigung dieser Faktoren wurde beschlossen, nicht alle Objekte anzuzeigen, sondern nur diejenigen, die nicht mehr als 100 Meter entlang der Routenlinie vom Benutzer entfernt wurden, und den angezeigten Satz von Objekten regelm√§√üig zu aktualisieren.  Wir zeigen eine ausreichende Menge an visuellen Informationen an, wodurch unn√∂tige SceneKit-Berechnungen vermieden und der Akku des Benutzers geschont werden. </p><br><p><img src="https://habrastorage.org/webt/q3/fz/r6/q3fzr6zbcifepwqzs9gwncj8-3k.png" alt="Route-Polylinien-√úbersicht"></p><br><p>  Schauen wir uns die wichtigsten Schritte an, die wir ausf√ºhren mussten, um das Endergebnis zu erhalten: </p><br><ul><li>  Auswahl des Routenabschnitts, f√ºr den die Grundelemente angezeigt werden sollen, </li><li>  Erstellung von 3D-Modellen, </li><li>  Animationserstellung </li><li>  Update beim Fahren entlang einer Route. </li></ul><br><h2 id="vybor-uchastka-dlya-otobrazheniya">  Ausw√§hlen eines anzuzeigenden Diagramms </h2><br><p>  Wie oben erw√§hnt, werden keine Pfeile f√ºr die gesamte Route angezeigt, sondern der optimale Abschnitt f√ºr die Anzeige ausgew√§hlt.  Die Auswahl eines Segments zu einem beliebigen Zeitpunkt besteht darin, das n√§chstgelegene Routensegment (die Route ist eine Folge von Segmenten / Segmenten) zur aktuellen Position des Benutzers zu finden und Segmente vom n√§chstgelegenen zum Endpunkt der Route auszuw√§hlen, bis ihre Gesamtl√§nge 100 Meter √ºberschreitet. </p><br><p><img src="https://habrastorage.org/webt/ay/_r/jr/ay_rjrcnkgtufpecvwezfyv0b_g.png" alt="route-polyline-route-part-auswahl"></p><br><h2 id="sozdanie-3d-modeli">  3D-Modellerstellung </h2><br><p>  Lassen Sie uns den Prozess der Erstellung eines 3D-Modells genauer betrachten.  In den meisten F√§llen m√ºssen Sie zum Erstellen eines einfachen 3D-Modells (wie unserem Pfeil) lediglich einen beliebigen 3D-Editor √∂ffnen, einige Zeit damit verbringen, ihn zu beherrschen und dieses Modell darin zu erstellen.  Wenn die Jungs aus Ihrem Team Erfahrung in der 3D-Modellierung haben oder Zeit haben, um beispielsweise 3DMax zu lernen (und es muss gekauft werden), dann haben Sie unglaublich viel Gl√ºck.  Leider hatte zum Zeitpunkt der Implementierung dieser Funktion keiner von uns besondere Erfahrungen, es gab keine freie Zeit f√ºr Schulungen, so dass wir sozusagen mit improvisierten Mitteln ein Modell erstellen mussten.  Ich meine die Beschreibung des Modells im Code.  Alles begann mit der Pr√§sentation eines 3D-Modells in Form von Dreiecken.  Dann mussten wir die Koordinaten der Eckpunkte dieser Dreiecke manuell im Koordinatensystem des Modells finden und dann ein Array von Indizes der Eckpunkte der Dreiecke erstellen.  Mit diesen Daten k√∂nnen wir die erforderliche Geometrie direkt in SceneKit erstellen.  Sie k√∂nnen beispielsweise ein √§hnliches Modell wie das unsere erstellen: </p><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARSCNArrowGeometry</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SCNGeometry</span></span></span></span> { convenience init(material: SCNMaterial) { let vertices: [<span class="hljs-type"><span class="hljs-type">SCNVector3</span></span>] = [ <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>), // <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.10</span></span>, <span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.22</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, -<span class="hljs-number"><span class="hljs-number">0.39</span></span>), // <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.10</span></span>, -<span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>), // <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.10</span></span>, <span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.22</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, -<span class="hljs-number"><span class="hljs-number">0.39</span></span>), // <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.10</span></span>, -<span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">11</span></span> ] let sources: [<span class="hljs-type"><span class="hljs-type">SCNGeometrySource</span></span>] = [<span class="hljs-type"><span class="hljs-type">SCNGeometrySource</span></span>(<span class="hljs-type"><span class="hljs-type">vertices</span></span>: <span class="hljs-type"><span class="hljs-type">vertices</span></span>)] let indices: [<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span><span class="hljs-number"><span class="hljs-number">32</span></span>] = [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] let geometryElements = [<span class="hljs-type"><span class="hljs-type">SCNGeometryElement</span></span>(<span class="hljs-type"><span class="hljs-type">indices</span></span>: <span class="hljs-type"><span class="hljs-type">indices</span></span>, <span class="hljs-type"><span class="hljs-type">primitiveType</span></span>: <span class="hljs-type"><span class="hljs-type">.triangles</span></span>)] self.init(sources: sources, elements: geometryElements) self.materials = [<span class="hljs-type"><span class="hljs-type">material</span></span>] } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> func arrowBlue() -&gt; SCNGeometry { let material = SCNMaterial() material.diffuse.contents = UIColor.blue material.lightingModel = .constant <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ARSCNArrowGeometry(material: material) }</code> </pre> <br><p>  Das Endergebnis sieht folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/xp/ms/ov/xpmsovmunineo54tl2dh_7tkjqi.png" alt="Route-Polylinien-Pfeil-Modell"></p><br><h2 id="animaciya-linii-marshruta">  Routenlinienanimation </h2><br><p>  Der n√§chste Schritt auf dem Weg zur Anzeige einer animierten Linie der Route war die Erstellung der Animation selbst.  Aber wie kann die Animation realisiert werden, die in der endg√ºltigen Form so aussieht, als ob der Pfeil seine Bewegung am Startpunkt des ausgew√§hlten Abschnitts der Route beginnt und entlang der Route bis zum Ende dieses Abschnitts ‚Äûschwebt‚Äú? </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/k3myOucSs8I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Ich werde nicht alle m√∂glichen Wege beschreiben, um eine solche Animation zu erstellen, sondern ich werde n√§her auf die von uns gew√§hlte Methode eingehen.  Nachdem ein Abschnitt der Route ausgew√§hlt wurde, teilen wir ihn in Abschnitte gleicher L√§nge auf - Abschnitte der Animation eines Pfeils.  Jeder dieser Abschnitte ist farblich hervorgehoben und hat eine L√§nge, die dem Abstand zwischen den Pfeilen entspricht. </p><br><p><img src="https://habrastorage.org/webt/-t/rg/_1/-trg_11cxxxv3affm0cm3g3ur60.png" alt="route-polyline-route-part-partitioning"></p><br><p>  Zu Beginn jedes Abschnitts erstellen wir das SCNNode-Objekt des Pfeils, dessen Animation darin besteht, sich entlang seines Abschnitts zu bewegen. </p><br><p><img src="https://habrastorage.org/webt/db/dc/cd/dbdccdds7qldg5d-2hbujicqrgm.png" alt="Route-Polylinien-Pfeile-Anfangsposition"></p><br><p>  Wie Sie sehen k√∂nnen, besteht der Animationsabschnitt manchmal aus einem Segment, manchmal aus zwei oder mehr.  Es h√§ngt alles von der Stufe (in unserem Fall - 3 Meter) zwischen den Pfeilen und den Koordinaten der Punkte ab, aus denen die Route besteht. </p><br><p>  Eine Pfeilanimation besteht aus zwei Schritten: </p><br><ul><li>  Aussehen in der Ausgangsposition mit dem Anfangsdrehwinkel, </li><li>  eine Folge von Offsets entlang von Segmenten mit Rotationen an den Verbindungspunkten der Segmente. </li></ul><br><p>  Schematisch sieht es so aus: </p><br><p><img src="https://habrastorage.org/webt/f6/ha/7s/f6ha7sdwzchpv28sekjopugnrwo.png" alt="Route-Polylinien-Pfeil-Anitaion-Schritte"></p><br><p>  Es schien uns der einfachste Weg zu sein, eine solche Animation mithilfe der SCNAction-API zu implementieren - einer deklarativen API, mit der Sie bequem sequentielle, gruppierte und sich wiederholende Animationen erstellen k√∂nnen.  Sie k√∂nnen sich die Implementierung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> genauer ansehen.  Aufgrund der Tatsache, dass jeder Pfeil seine Animation am Startpunkt des Animationsabschnitts des n√§chsten Pfeils beendet, wird der Eindruck einer kontinuierlichen Bewegung des Pfeils entlang des gesamten ausgew√§hlten Abschnitts der Route erzeugt. </p><br><p>  In diesem Zusammenhang schlage ich vor, die Betrachtung verschiedener Aspekte des Renderns abzuschlie√üen und zum Hauptteil √ºberzugehen - der Bestimmung der Positionen von Objekten auf der B√ºhne anhand der geografischen Koordinaten der Objekte. </p><br><h1 id="opredelenie-pozicii-obekta-na-scene">  Bestimmen der Position eines Objekts in der Szene </h1><br><p>  Wir beginnen das Gespr√§ch √ºber die Bestimmung der Position eines Objekts in der Szene unter Ber√ºcksichtigung von Koordinatensystemen, deren Konvertierung erfolgen muss.  Es gibt nur 2 davon: </p><br><ul><li>  geod√§tische (oder der Einfachheit halber geografische) Koordinaten - die Position von Objekten (Routenpunkten) in der realen Welt, </li><li>  Kartesische Koordinaten - die Position von Objekten in der Szene (in ARKit).  Denken Sie daran, dass das Koordinatensystem der Szene mit dem Koordinatensystem ARKit √ºbereinstimmt (bei Verwendung von ARSCNView). </li></ul><br><p>  Die √úbersetzung von einem Koordinatensystem in ein anderes und umgekehrt ist m√∂glich, da die Koordinaten in ARKit in Metern gemessen werden und der Versatz zwischen zwei geod√§tischen Koordinaten mit gro√üer Genauigkeit in den Versatz in Metern entlang der X- und Z-Achse des ARKit-Koordinatensystems bei kleinen Vers√§tzen √ºbersetzt werden kann.  Ich m√∂chte Sie daran erinnern, dass geod√§tische Koordinaten Punkte mit einem bestimmten L√§ngen- und Breitengrad sind. </p><br><p>  Erinnern wir uns an so wichtige Konzepte aus dem Verlauf der Geographie wie Parallelen und Meridiane und ihre grundlegenden Eigenschaften: </p><br><ul><li>  <strong>Parallel</strong> ist eine Linie mit einem Breitengrad.  Die L√§ngen der verschiedenen Parallelen sind unterschiedlich. </li><li>  <strong>Meridian</strong> - eine Linie mit einem L√§ngengrad.  Die L√§ngen aller Meridiane sind gleich. </li></ul><br><p>  Nun wollen wir sehen, wie Sie den Versatz in Metern zwischen zwei geod√§tischen Koordinaten mit Koordinaten berechnen k√∂nnen <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ inline (lat_1, lon_1)">  und <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ inline (lat_2, lon_2)">  :: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a44/a8c/946/a44a8c946ea2dc906e48fe45dae1a432.svg" alt="\ Delta x = \ Delta lon \ times meterInLonDegree (lat_ {0})">  , <img src="https://habrastorage.org/getpro/habr/post_images/96a/036/d49/96a036d490185172d1ac79635788e31b.svg" alt="\ Delta z = \ Delta lat \ times meterInLatDegree"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8f5/438/3f1/8f54383f1775fe7105087c4ff5891a18.svg" alt="meterInLonDegree (\ alpha) = \ frac {2 \ pi R_ \ text {landet} \ cos \ left (\ alpha \ right)} {360 ^ {¬∞}}">  , <img src="https://habrastorage.org/getpro/habr/post_images/afa/9ec/76a/afa9ec76ae9ee9dfdf5228c8ace8c603.svg" alt="meterInLatDegree = \ frac {2 \ pi R_ \ text {Lands}} {360 ^ {¬∞}}"></p><br><div class="spoiler">  <b class="spoiler_title">Erkl√§rung</b> <div class="spoiler_text"><p>  Die Verschiebung in geod√§tischen Koordinaten wird nur bei kleinen Verschiebungen linear auf Meter abgebildet.  Bei gro√üen Verschiebungen ist es notwendig, das Integral ehrlich zu nehmen. </p></div></div><br><p>  Nachdem wir den Versatz von einem Koordinatensystem in ein anderes verschieben k√∂nnen, m√ºssen wir uns f√ºr einen Referenzpunkt entscheiden - einen Punkt, f√ºr den die geografische Koordinate und die Koordinate in ARKit (Koordinate auf der B√ºhne) gleichzeitig bekannt sind.  Nachdem wir einen solchen Punkt gefunden haben, k√∂nnen wir die Koordinate jedes Objekts auf der B√ºhne bestimmen, seine geografische Koordinate kennen und die obigen Formeln verwenden. </p><br><p>  Betrachten Sie zur Verdeutlichung ein Beispiel: <br>  Zu Beginn der Augmented Reality-Sitzung haben wir CoreLocation nach unserer geografischen Koordinate gefragt und diese sofort erhalten - <img src="https://habrastorage.org/getpro/habr/post_images/fda/ae2/64a/fdaae264a0f9dd176411b6ff5755bff4.svg" alt="\ inline (lat_0, lon_0)">  .  Unter Hinweis darauf, dass der Ursprung des ARKit-Koordinatensystems zu Beginn der Sitzung an dem Punkt liegt, an dem sich das Ger√§t befindet, haben wir den Referenzpunkt erhalten, da wir die geografische Koordinate und die Koordinate in der Szene kennen <img src="https://habrastorage.org/getpro/habr/post_images/24e/b89/0e6/24eb890e6f1f8beac2b3c3cecfd8fe48.svg" alt="\ inline (x_0, y_0, z_0) = (0,0,0)">  .  Lassen Sie uns die Koordinate auf der Szene des Objekts mit einer geografischen Koordinate finden <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ inline (lat_1, lon_1)">  .  Suchen Sie dazu den Versatz in Metern zwischen der geografischen Koordinate des Objekts und der geografischen Koordinate unseres Referenzpunkts und f√ºgen Sie den gefundenen Versatz zur Koordinate in der Szene des Referenzpunkts hinzu.  Die resultierende Koordinate in der Szene ist die gew√ºnschte. </p><br><p><img src="https://habrastorage.org/webt/t5/n7/c7/t5n7c7_5qzbakweb9xcaal2ai0u.png" alt="Koordinaten-Konvertierungs-Objekt-Position-auf-Szene"></p><br><p>  Ich stelle fest, dass die auf diese Weise gefundene Position auf der Szene nur dann der Position des Objekts in der realen Welt entspricht, wenn die X / Z-Achse des Szenenkoordinatensystems mit den Richtungen nach S√ºd / Ost ausgerichtet ist.  Die Achsenausrichtung sollte theoretisch erreicht werden, indem das Flag worldAlignment auf gravitiAndHeading gesetzt wird.  Aber wie ich zu Beginn des Beitrags sagte, ist dies bei weitem nicht immer der Fall. </p><br><p>  Betrachten wir die Methode zur Bestimmung des Referenzpunkts genauer.  Zu diesem Zweck f√ºhren wir das Konzept der <strong>Sch√§tzung ein</strong> - eine Reihe von geografischen Koordinaten und Koordinaten auf der B√ºhne. </p><br><p><img src="https://habrastorage.org/webt/gl/lu/ap/glluap6lmes0g1o2q124jkyb4y0.png" alt="Koordinaten-Umrechnung-Sch√§tzung-Definition"></p><br><p>  Das oben vorgeschlagene Verfahren zur Bestimmung des Referenzpunktes wird m√∂glicherweise nicht immer verwendet.  Zum Zeitpunkt des Starts einer Augmented-Reality-Sitzung kann eine Anforderung zur CLLocation eines Benutzers nicht sofort ausgef√ºhrt werden, au√üerdem kann die Genauigkeit der erhaltenen Koordinate einen gro√üen Fehler aufweisen.  Es w√§re richtiger, SceneKit nach einer Position auf der B√ºhne zu fragen, wenn wir den Wert von CoreLocation erhalten.  In diesem Fall werden die Komponenten der resultierenden Sch√§tzung tats√§chlich gleichzeitig erhalten, und wir haben die M√∂glichkeit, eine der Sch√§tzungen als Referenzpunkt zu verwenden.  Bei der Arbeit mit ARKit steigt der Offset-Fehler mit der Zeit an. Apple empfiehlt daher nicht, ARKit als Navigationswerkzeug zu verwenden. </p><br><p>  Als wir beschlossen, Fu√üg√§ngerrouting mit Augmented Reality zu implementieren, haben wir ein wenig nach den damals existierenden L√∂sungen gesucht und ARKit f√ºr √§hnliche Aufgaben verwendet. Dabei sind wir auf das ARKit + CoreLocation-Framework gesto√üen.  Die Idee dieses Frameworks war, dass wir dank ARKit den Standort des Benutzers genauer bestimmen k√∂nnen als wenn wir ausschlie√ülich CoreLocation verwenden. </p><br><p>  ARKit + CoreLocation-Konzept: </p><br><ul><li>  beim Empfang von CLLocation von CLLocationManager <br><ul><li>  Fordern Sie mit scene.pointOfView.worldPosition eine Position in der Szene an </li><li>  Speichern Sie dieses Koordinatenpaar (Sch√§tzung) im Puffer </li></ul></li><li>  Holen Sie sich bei Bedarf den genauen Standort <br><ul><li>  W√§hlen Sie die beste Sch√§tzung </li><li>  Berechnen Sie den Versatz zwischen der aktuellen Position auf der B√ºhne und der Position auf der B√ºhne der besten Sch√§tzung </li><li>         </li></ul></li></ul><br><p>          ,   ,   CoreLocation,       . </p><br><p>   ,   ¬´ ¬ª.   ,      . </p><br><p>     (,    ): </p><br><ul><li>    (  horizontalAccuracy), </li><li>       , </li><li>        100    . </li></ul><br><p>          CoreLocation   .    ,     ,     CoreLocation   ,             100    . </p><br><p>       ,           . ,             ,        ( 100 ). </p><br><h1 id="korrektirovka-sistemy-koordinat">    </h1><br><p>       ,   X/Z   ARKit        /   . ARKit    ,       ,            . </p><br><div class="spoiler">  <b class="spoiler_title">Warum?</b> <div class="spoiler_text"><p>   ,       (,   IKEA,            ),       Y   ARKit ‚Äì        ,                   .        gravity   worldAlignment. </p></div></div><br><p>    ,          .        ,     ,            ,        .         .        AR     .        ,  ,    ,   ,  .       AR. </p><br><h2 id="opredelenie-ugla-korrekcii">    </h2><br><p>    ,      .  ,     <img src="https://habrastorage.org/getpro/habr/post_images/593/7e3/1a5/5937e31a59e1e414d1a9305d5826e3aa.svg" alt="\inline t_1">    CLLocationManager   <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\inline (lat_1,lon_1)">      ‚Äî <img src="https://habrastorage.org/getpro/habr/post_images/1bc/c49/846/1bcc49846ef09e14c8b3855a701f4b9f.svg" alt="\inline (x_1,z_1)">  .     <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\inline t_2">      CLLocationManager ‚Äî <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\inline (lat_2,lon_2)">     <img src="https://habrastorage.org/getpro/habr/post_images/ed3/051/02d/ed305102d4e86b54584281d6590b0492.svg" alt="\inline (x_2,z_2)">  entsprechend. </p><br><p>      ARKit ‚Äî <img src="https://habrastorage.org/getpro/habr/post_images/9a1/682/65e/9a168265ec4504ebe5356d7a9803a313.svg" alt="\inline (\Delta x,\Delta z)">    2     CoreLocation    <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\inline t_2">  .   <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\inline (lat_2,lon_2)">    <img src="https://habrastorage.org/getpro/habr/post_images/0ad/186/b97/0ad186b971730a033bc621b7144413d2.svg" alt="\inline (lat_{2calc},lon_{2calc})">  .      ,    CoreLocation        .      .        ARKit     /. </p><br><p><img src="https://habrastorage.org/webt/kp/cy/jc/kpcyjc9rjyxrnlnmzaved-ytw8m.png" alt="coordinates-conversion-correction-angle-problem"></p><br><p>          ARKit      Y?          .         : </p><br><ol><li>      , </li><li>  , </li><li>     , </li><li>        , </li><li>     . </li></ol><br><p>   .   .   CLLocationManager'    ,               (  ),       (  ). </p><br><div class="spoiler"> <b class="spoiler_title">   ?</b> <div class="spoiler_text"><p>            .      ,     ,         .     , ,    GPS . </p></div></div><br><p>       1, 2       : <img src="https://habrastorage.org/getpro/habr/post_images/1a3/078/c21/1a3078c2199432c003ffc50a749fbb66.svg" alt="\inline initialBearing(1,2)">  und <img src="https://habrastorage.org/getpro/habr/post_images/2e5/fc3/325/2e5fc3325cde601c4f4c59dae3576b62.svg" alt="\inline initialBearing(1,2_{calc})">  wo <img src="https://habrastorage.org/getpro/habr/post_images/993/049/474/9930494747afd3ba004e0f512635539e.svg" alt="\inline 2_{calc}"> ‚Äì    2,      ARKit.   <img src="https://habrastorage.org/getpro/habr/post_images/937/c05/90c/937c0590c7c66d7762185d852a9adf1c.svg" alt="\inline initialBearing(a,b)">   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> (  Bearing). </p><br><p><img src="https://habrastorage.org/webt/wp/lf/lv/wplflvaucl_3ntt7x-of1_pmj2q.png" alt="coordinates-conversion-correction-angle-calculation-for-pair"></p><br><p>                  .    ,        ? ,        ,  ,        ,         .          ,      ,    ,   horizontalAccuracy.  ,   ,          ,   .                    : </p><br><p><img src="https://habrastorage.org/webt/3m/qc/_k/3mqc_krnknduxupcmianxsturym.png" alt="coordinates-conversion-correction-angle-calculation-error"></p><br><p>  ,   ,                 . </p><br><p>    . ,          .  Zum Beispiel: </p><br><ul><li>  N     , </li><li>       , </li><li> M      (  ?). </li></ul><br><p>  ,    ,    ,    ,       (),              .                ,  .    ,     ,           .   ,    ,     (    ).               . </p><br><p>  ,                . ,     ,      (          ,           ,     ). </p><br><h2 id="testirovanie">  Testen </h2><br><p> ,      .  ,     ,    ,     .      2 : </p><br><ul><li>     , </li><li>        . </li></ul><br><p>  -      , ,   ,      ,         . </p><br><p>                .  , ,  100  CLLocation,          .   ,     , ,  10  (       10 ).            ?        ,        "".   ,        .    ,        ,       ,    .   ,       ,     .      ,      CoreLocation.     ,     .  ,      . </p><br><p>       .     ,            .   ,     (,       ),          ,       0 . ,    ,    . </p><br><p>       " ".              .      ,        ,     ,       ,        CLLocation,        ,            .        (         )       . </p><br><p>    ,           ARKit. </p><br><p><img src="https://habrastorage.org/webt/wv/qd/8i/wvqd8ikrpgvslsgndlmvmss13yu.png" alt="correction-angle-calculation-alg-testing-street-before-correction"></p><br><p> ,       . </p><br><p><img src="https://habrastorage.org/webt/jx/qb/aq/jxqbaqs21nprxhb6zhfueipyj2s.png" alt="correction-angle-calculation-alg-testing-street-after-correction"></p><br><p>    ( 3-4 )           ,    . </p><br><p><img src="https://habrastorage.org/webt/fd/1n/ct/fd1nctm6j9slks4r8rfhmmvkjz8.png" alt="correction-angle-calculation-alg-testing-street-after-last-correction"></p><br><p>          JS,       AR  CoreLocation. </p><br><p><img src="https://habrastorage.org/webt/4e/gk/2r/4egk2rlbx_5aloj-tc-2rcxqoaq.png" alt="correction-angle-calculation-alg-testing-tracks"></p><br><p>              ‚Äî     gravity   worldAlignment      .      ,          .              . </p><br><h1 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h1><br><p>      Slack, ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,  ,         .                      AR.  .       AR  AppStore  2017 . ,      . </p><br><h1 id="poleznye-ssylki">  N√ºtzliche Links </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> </li><li> ARKit+CoreLocation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   ARKit</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> AR   </a> </li></ul><br><p>      ,           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> .</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421957/">https://habr.com/ru/post/de421957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421945/index.html">Google und Mastercard schlie√üen ein geheimes Gesch√§ft ab, um Eink√§ufe in Gesch√§ften zu verfolgen</a></li>
<li><a href="../de421947/index.html">Willkommen zum Android Devs Meetup am 8. September</a></li>
<li><a href="../de421949/index.html">Selbstmordkommando Wie wir die heftigsten Nachwuchsentwickler rekrutieren</a></li>
<li><a href="../de421953/index.html">Summ3r 0f h4ck: Sommerpraktikum bei Digital Security</a></li>
<li><a href="../de421955/index.html">Der Senat will keine Roboter, die vom Bier abgelenkt werden. Und wor√ºber kann man am Freitag noch schreiben?</a></li>
<li><a href="../de421959/index.html">Was tun, wenn ‚Äûdies‚Äú die Kontextverbindung verliert?</a></li>
<li><a href="../de421961/index.html">Erstellen einer Demo f√ºr ein altes Telefon - AONDEMO</a></li>
<li><a href="../de421963/index.html">Buchhaltung und Buchhalter: ihre Rolle in der Organisation</a></li>
<li><a href="../de421965/index.html">‚ÄûNeben der Arbeit arbeite ich noch‚Äú - 10 Fragen an den Programmierer, dritte Ausgabe</a></li>
<li><a href="../de421967/index.html">Kinderspielzeug auf logischen Elementen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>