<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçê üê£ üåΩ Uma agulha em uma pilha de sess√µes ou uma express√£o regular por c√≥digo üê® üóíÔ∏è üèóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="17 bilh√µes de eventos, 60 milh√µes de sess√µes de usu√°rios e um grande n√∫mero de datas virtuais ocorrem diariamente no Badoo. Cada evento √© armazenado o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uma agulha em uma pilha de sess√µes ou uma express√£o regular por c√≥digo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/433054/"><p><img src="https://habrastorage.org/webt/kz/rl/nu/kzrlnugblhii_j4jrsqzdk9fsgo.jpeg"></p><br><p>  17 bilh√µes de eventos, 60 milh√µes de sess√µes de usu√°rios e um grande n√∫mero de datas virtuais ocorrem diariamente no Badoo.  Cada evento √© armazenado ordenadamente em bancos de dados relacionais para posterior an√°lise no SQL e al√©m. </p><br><p>  Bancos de dados transacionais distribu√≠dos modernos com dezenas de terabytes de dados - um verdadeiro milagre da engenharia.  Mas o SQL, como a personifica√ß√£o da √°lgebra relacional na maioria das implementa√ß√µes padr√£o, ainda n√£o nos permite formular consultas em termos de tuplas ordenadas. </p><br><p>  No √∫ltimo artigo de uma s√©rie sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√°quinas</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">virtuais</a> , falarei sobre uma abordagem alternativa para encontrar sess√µes interessantes - o mecanismo de express√£o regular ( <a href="">Pig Match</a> ), que √© definido para sequ√™ncias de eventos. </p><br><p>  M√°quina virtual, bytecode e compilador est√£o inclu√≠dos gratuitamente! </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte I, Introdut√≥ria</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte Dois, Otimizando</a> <br>  Parte III, aplicada (atual) </p><br><h1 id="o-sobytiyah-i-sessiyah">  Sobre eventos e sess√µes </h1><br><p>  Suponha que j√° tenhamos um data warehouse que permita visualizar r√°pida e sequencialmente os eventos de cada uma das sess√µes do usu√°rio. </p><br><p> Queremos encontrar sess√µes por solicita√ß√µes como "contar todas as sess√µes em que h√° uma subsequ√™ncia especificada de eventos", "encontrar partes de uma sess√£o descrita por um determinado padr√£o", "retornar a parte da sess√£o que ocorreu ap√≥s um determinado padr√£o" ou "contar quantas sess√µes atingiram certas partes modelo ".  Isso pode ser √∫til para v√°rios tipos de an√°lise: pesquisa de sess√µes suspeitas, an√°lise de funil, etc. </p><br><p>  As subsequ√™ncias desejadas devem ser descritas de alguma forma.  Em sua forma mais simples, essa tarefa √© semelhante a encontrar uma substring em um texto;  queremos ter uma ferramenta mais poderosa - express√µes regulares.  As implementa√ß√µes modernas de mecanismos de express√£o regular costumam usar (voc√™ adivinhou!) M√°quinas virtuais. </p><br><p>  A cria√ß√£o de pequenas m√°quinas virtuais para combinar sess√µes com express√µes regulares ser√° discutida abaixo.  Mas primeiro, esclareceremos as defini√ß√µes. </p><br><p>  <em>Um evento</em> consiste em um tipo de evento, hora, contexto e um conjunto de atributos espec√≠ficos para cada tipo. </p><br><p>  <em>O tipo</em> e o <em>contexto de</em> cada evento s√£o n√∫meros inteiros de listas predefinidas.  Se tudo estiver claro com os tipos de eventos, o contexto ser√°, por exemplo, o n√∫mero da tela na qual o evento especificado ocorreu. </p><br><p>  <em>Um atributo de</em> evento √© um n√∫mero inteiro arbitr√°rio cujo significado √© determinado pelo tipo de evento.  Um evento pode n√£o ter atributos ou pode haver v√°rios. </p><br><p>  <em>Uma sess√£o</em> √© uma sequ√™ncia de eventos classificados por hora. </p><br><p>  Mas vamos finalmente ao que interessa.  O zumbido, como se costuma dizer, diminuiu, e eu fui para o palco. </p><br><h1 id="sravnivaem-po-bumazhke">  Compare em um peda√ßo de papel </h1><br><p><img src="https://habrastorage.org/webt/gu/ec/dw/guecdwuc3rhjl1oc6cvuk-4ec9k.jpeg"></p><br><p>  Um recurso desta m√°quina virtual √© a passividade em rela√ß√£o aos eventos de entrada.  N√£o queremos manter a sess√£o inteira na mem√≥ria e permitir que a m√°quina virtual alterne independentemente de evento para evento.  Em vez disso, alimentaremos os eventos da sess√£o na m√°quina virtual, um por um. </p><br><p>  Vamos definir fun√ß√µes de interface: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">matcher *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *matcher)</span></span></span></span>;</code> </pre> <br><p>  Se tudo estiver claro com as fun√ß√µes matcher_create e matcher_destroy, vale a pena comentar o matcher_accept.  A fun√ß√£o matcher_accept recebe uma inst√¢ncia da m√°quina virtual e o pr√≥ximo evento (32 bits, onde 16 bits para o tipo de evento e 16 bits para o contexto) e retorna um c√≥digo explicando o que o c√≥digo do usu√°rio deve fazer a seguir: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { <span class="hljs-comment"><span class="hljs-comment">//       MATCH_NEXT, //    ,      MATCH_OK, //       ,      MATCH_FAIL, //     MATCH_ERROR, } match_result;</span></span></code> </pre><br><p>  Opcodes da m√°quina virtual: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> matcher_opcode { <span class="hljs-comment"><span class="hljs-comment">//  ,      OP_ABORT, //      ( -  ) OP_NAME, //     ( -  ) OP_SCREEN, //    OP_NEXT, //    OP_MATCH, } matcher_opcode;</span></span></code> </pre><br><p>  O loop principal de uma m√°quina virtual: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next_event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_OP() \ (*m-&gt;ip++) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_ARG() \ ((void)(m-&gt;ip += 2), (m-&gt;ip[-2] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 8) + m-&gt;ip[-1]) for (;;) { uint8_t instruction = NEXT_OP(); switch (instruction) { case OP_ABORT:{ return MATCH_ERROR; } case OP_NAME:{ uint16_t name = NEXT_ARG(); if (event_name(next_event) != name) return MATCH_FAIL; break; } case OP_SCREEN:{ uint16_t screen = NEXT_ARG(); if (event_screen(next_event) != screen) return MATCH_FAIL; break; } case OP_NEXT:{ return MATCH_NEXT; } case OP_MATCH:{ return MATCH_OK; } default:{ return MATCH_ERROR; } } } #undef NEXT_OP #undef NEXT_ARG }</span></span></span></span></code> </pre> <br><p>  Nesta vers√£o simples, nossa m√°quina virtual combina sequencialmente o padr√£o descrito pelo bytecode com os eventos recebidos.  Como tal, isso simplesmente n√£o √© uma compara√ß√£o muito concisa dos <em>prefixos de</em> duas linhas: o modelo desejado e a linha de entrada. </p><br><p>  Prefixos s√£o prefixos, mas queremos encontrar os padr√µes desejados n√£o apenas no in√≠cio, mas tamb√©m em um local arbitr√°rio na sess√£o.  A solu√ß√£o ing√™nua √© reiniciar a correspond√™ncia de cada evento da sess√£o.  Mas isso implica a visualiza√ß√£o m√∫ltipla de cada um dos eventos e a ingest√£o de beb√™s algor√≠tmicos. </p><br><p>  <a href="">O exemplo</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro artigo da</a> s√©rie, na verdade, simula o rein√≠cio de uma correspond√™ncia usando a revers√£o (retrocesso em ingl√™s).  O c√≥digo no exemplo parece, √© claro, mais fino que o fornecido aqui, mas o problema n√£o desapareceu: cada um dos eventos ter√° que ser verificado muitas vezes. </p><br><p>  Voc√™ n√£o pode viver assim. </p><br><h1 id="ya-esche-raz-ya-i-snova-ya">  Eu, eu de novo e eu de novo </h1><br><p><img src="https://habrastorage.org/webt/bq/ue/gt/bquegtp3mpd4rxv65f1fk-svdjk.jpeg"></p><br><p>  Vamos esbo√ßar mais uma vez o problema: precisamos combinar o modelo com os eventos recebidos, iniciando a partir de cada um dos eventos iniciando uma nova compara√ß√£o.  Ent√£o, por que n√£o fazemos exatamente isso?  Deixe a m√°quina virtual acompanhar os eventos recebidos em v√°rios segmentos! </p><br><p>  Para fazer isso, precisamos obter uma nova entidade - um fluxo.  Cada thread armazena um √∫nico ponteiro - para a instru√ß√£o atual: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matcher_thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; } matcher_thread;</code> </pre><br><p>  Naturalmente, agora na pr√≥pria m√°quina virtual n√£o armazenaremos o ponteiro expl√≠cito.  Ele ser√° substitu√≠do por duas listas de threads (mais sobre elas abaixo): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matcher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *bytecode; <span class="hljs-comment"><span class="hljs-comment">/* Threads to be processed using the current event */</span></span> matcher_thread current_threads[MAX_THREAD_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> current_thread_num; <span class="hljs-comment"><span class="hljs-comment">/* Threads to be processed using the event to follow */</span></span> matcher_thread next_threads[MAX_THREAD_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> next_thread_num; } matcher;</code> </pre><br><p>  E aqui est√° o loop principal atualizado: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next_event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_OP(thread) \ (*(thread).ip++) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_ARG(thread) \ ((void)((thread).ip += 2), ((thread).ip[-2] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 8) + (thread).ip[-1]) /*         - */ add_current_thread(m, initial_thread(m)); //         for (size_t thread_i = 0; thread_i &lt; m-&gt;current_thread_num; thread_i++ ) { matcher_thread current_thread = m-&gt;current_threads[thread_i]; bool thread_done = false; while (!thread_done) { uint8_t instruction = NEXT_OP(current_thread); switch (instruction) { case OP_ABORT:{ return MATCH_ERROR; } case OP_NAME:{ uint16_t name = NEXT_ARG(current_thread); //  ,      ,    //     next_threads,    if (event_name(next_event) != name) thread_done = true; break; } case OP_SCREEN:{ uint16_t screen = NEXT_ARG(current_thread); if (event_screen(next_event) != screen) thread_done = true; break; } case OP_NEXT:{ //    , ..      // next_threads add_next_thread(m, current_thread); thread_done = true; break; } case OP_MATCH:{ return MATCH_OK; } default:{ return MATCH_ERROR; } } } } /*      ,    */ swap_current_and_next(m); return MATCH_NEXT; #undef NEXT_OP #undef NEXT_ARG }</span></span></span></span></code> </pre><br><p>  Em cada evento recebido, primeiro adicionamos um novo segmento √† lista current_threads, verificando o modelo desde o in√≠cio, ap√≥s o qual come√ßamos a rastrear a lista current_threads, seguindo cada ponteiro seguindo as instru√ß√µes. </p><br><p>  Se uma instru√ß√£o NEXT for encontrada, o encadeamento ser√° colocado na lista next_threads, ou seja, aguarda o recebimento do pr√≥ximo evento. </p><br><p>  Se o padr√£o de encadeamento n√£o corresponder ao evento recebido, esse encadeamento simplesmente n√£o ser√° adicionado √† lista next_threads. </p><br><p>  A instru√ß√£o MATCH sai imediatamente da fun√ß√£o, relatando um c√≥digo de retorno que o padr√£o corresponde √† sess√£o. </p><br><p>  Ap√≥s a conclus√£o do rastreamento da lista de threads, as listas atual e seguinte s√£o trocadas. </p><br><p>  Na verdade, √© tudo.  Podemos dizer que estamos literalmente fazendo o que quer√≠amos: ao mesmo tempo, estamos verificando v√°rios modelos, lan√ßando um novo processo de correspond√™ncia para cada um dos eventos da sess√£o. </p><br><h1 id="mnozhestvennye-lichnosti-i-vetvleniya-v-shablonah">  V√°rias identidades e ramifica√ß√µes em modelos </h1><br><p><img src="https://habrastorage.org/webt/8l/gv/-e/8lgv-e5bp1xhv0ksukeacrhasaq.jpeg"></p><br><p>  Procurar um modelo que descreva uma sequ√™ncia linear de eventos √©, obviamente, √∫til, mas queremos obter express√µes regulares completas.  E os fluxos que criamos no est√°gio anterior tamb√©m s√£o √∫teis aqui. </p><br><p>  Suponha que desejemos encontrar uma sequ√™ncia de dois ou tr√™s eventos que nos interessem, algo como uma express√£o regular nas linhas: "a? Bc".  Nesta sequ√™ncia, o s√≠mbolo "a" √© opcional.  Como express√°-lo em bytecode?  F√°cil! </p><br><p>  Podemos iniciar <em>dois</em> threads, um para cada caso: com o s√≠mbolo "a" e sem ele.  Para isso, introduzimos uma instru√ß√£o adicional (do tipo SPLIT addr1, addr2), que inicia dois threads a partir dos endere√ßos especificados.  Al√©m do SPLIT, o JUMP tamb√©m √© √∫til para n√≥s, que simplesmente continua a execu√ß√£o com a instru√ß√£o especificada no argumento direto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> matcher_opcode { OP_ABORT, OP_NAME, OP_SCREEN, OP_NEXT, <span class="hljs-comment"><span class="hljs-comment">//     OP_JUMP, //         OP_SPLIT, OP_MATCH, //     OP_NUMBER_OF_OPS, } matcher_opcode;</span></span></code> </pre> <br><p>  O loop em si e o restante das instru√ß√µes n√£o mudam - apenas apresentamos dois novos manipuladores: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... case OP_JUMP:{ /*   ,      */ uint16_t offset = NEXT_ARG(current_thread); add_current_thread(m, create_thread(m, offset)); break; } case OP_SPLIT:{ /*        */ uint16_t left_offset = NEXT_ARG(current_thread); uint16_t right_offset = NEXT_ARG(current_thread); add_current_thread(m, create_thread(m, left_offset)); add_current_thread(m, create_thread(m, right_offset)); break; } // ...</span></span></code> </pre><br><p>  Observe que as instru√ß√µes adicionam threads √† lista atual, ou seja, continuam funcionando no contexto do evento atual.  O segmento no qual ocorreu a ramifica√ß√£o n√£o entra na lista dos seguintes segmentos. </p><br><p>  A coisa mais surpreendente sobre essa m√°quina virtual de express√£o regular √© que nossos threads e este par de instru√ß√µes s√£o suficientes para expressar quase todas as constru√ß√µes geralmente aceitas ao combinar strings. </p><br><h1 id="regulyarnye-vyrazheniya-na-sobytiyah">  Express√µes regulares em eventos </h1><br><p>  Agora que temos uma m√°quina virtual e ferramentas adequadas para isso, podemos lidar com a sintaxe de nossas express√µes regulares. </p><br><p>  A grava√ß√£o manual de opcodes para programas mais graves se cansa rapidamente.  Da √∫ltima vez, n√£o fiz um analisador completo, mas o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usu√°rio</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">true grue</a> mostrou os recursos de sua biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">raddsl usando a minil√≠ngua PigletC</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> .  Fiquei t√£o impressionado com a brevidade do c√≥digo que, com a ajuda do raddsl, escrevi um pequeno compilador de express√µes regulares de strings em cem ou duzentos em Python.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O compilador</a> e as instru√ß√µes para seu uso est√£o no GitHub.  O resultado do compilador na linguagem assembly √© entendido por um utilit√°rio que l√™ dois arquivos (um programa para uma m√°quina virtual e uma lista de eventos da sess√£o para verifica√ß√£o). </p><br><p>  Para come√ßar, nos restringimos ao tipo e contexto do evento.  O tipo de evento √© indicado por um √∫nico n√∫mero;  se voc√™ precisar especificar um contexto, especifique-o atrav√©s de dois pontos.  O exemplo mais simples: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "13" # ,     13 NEXT NAME 13 MATCH</code> </pre> <br><p>  Agora um exemplo com contexto: </p><br><pre> <code class="plaintext hljs">python regexp/regexp.py "13:12" #  13,  12 NEXT NAME 13 SCREEN 12 MATCH</code> </pre> <br><p>  Eventos sucessivos devem ser separados de alguma forma (por exemplo, por espa√ßos): </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "13 11 10:9" 08:40:52 NEXT NAME 13 NEXT NAME 11 NEXT NAME 10 SCREEN 9 MATCH</code> </pre> <br><p>  Modelo mais interessante: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "12|13" SPLIT L0 L1 L0: NEXT NAME 12 JUMP L2 L1: NEXT NAME 13 L2: MATCH</code> </pre> <br><p>  Preste aten√ß√£o nas linhas que terminam com dois pontos.  Essas s√£o tags.  A instru√ß√£o SPLIT cria dois threads que continuam a execu√ß√£o dos r√≥tulos L0 e L1, e o JUMP no final do primeiro ramo de execu√ß√£o simplesmente prossegue para o final do ramo. </p><br><p>  Voc√™ pode escolher entre cadeias de express√µes mais verdadeiramente agrupando subseq√º√™ncias entre par√™nteses: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "(1 2 3)|4" SPLIT L0 L1 L0: NEXT NAME 1 NEXT NAME 2 NEXT NAME 3 JUMP L2 L1: NEXT NAME 4 L2: MATCH</code> </pre> <br><p>  Um evento arbitr√°rio √© indicado por um ponto: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py ". 1" NEXT NEXT NAME 1 MATCH</code> </pre> <br><p>  Se queremos mostrar que a subsequ√™ncia √© opcional, colocamos um ponto de interroga√ß√£o depois dela: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1 2 3? 4" NEXT NAME 1 NEXT NAME 2 SPLIT L0 L1 L0: NEXT NAME 3 L1: NEXT NAME 4 MATCH</code> </pre> <br><p>  Obviamente, v√°rias repeti√ß√µes regulares (mais ou asterisco) tamb√©m s√£o comuns em express√µes regulares: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1+ 2" L0: NEXT NAME 1 SPLIT L0 L1 L1: NEXT NAME 2 MATCH</code> </pre> <br><p>  Aqui, simplesmente executamos a instru√ß√£o SPLIT v√°rias vezes, iniciando novos threads em cada ciclo. </p><br><p>  Da mesma forma com um asterisco: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1* 2" L0: SPLIT L1 L2 L1: NEXT NAME 1 JUMP L0 L2: NEXT NAME 2 MATCH</code> </pre> <br><p><img src="https://habrastorage.org/webt/g-/ud/3s/g-ud3s00i4ccyhf4lp5huusjlyu.jpeg"></p><br><h1 id="perspektiva">  Perspectiva </h1><br><p>  Outras extens√µes para a m√°quina virtual descrita podem ser √∫teis. </p><br><p>  Por exemplo, ele pode ser facilmente expandido verificando os atributos do evento.  Para um sistema real, suponho usar uma sintaxe como ‚Äú1: 2 {3: 4, 5:&gt; 3}‚Äù, o que significa: evento 1 no contexto 2 com o atributo 3 com valor 4 e com o valor 5 maior que 3. Atributos aqui voc√™ pode simplesmente transmiti-lo em uma matriz para a fun√ß√£o matcher_accept. </p><br><p>  Se voc√™ tamb√©m passar o intervalo de tempo entre os eventos para matcher_accept, poder√° adicionar uma sintaxe ao idioma do modelo que permite pular o tempo entre os eventos: "1 mindelta (120) 2", o que significa: evento 1, per√≠odo de pelo menos 120 segundos, evento 2 Combinado com a preserva√ß√£o de uma subsequ√™ncia, isso permite coletar informa√ß√µes sobre o comportamento do usu√°rio entre duas subsequ√™ncias de eventos. </p><br><p>  Outras coisas √∫teis que s√£o relativamente f√°ceis de adicionar s√£o: preservar subsequ√™ncias de express√µes regulares, separar operadores √°vidos e comuns de asteriscos e mais, e assim por diante.  Em termos da teoria dos aut√¥matos, nossa m√°quina virtual √© um aut√¥mato finito n√£o determin√≠stico, cuja implementa√ß√£o n√£o √© dif√≠cil de fazer. </p><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p>  Nosso sistema foi desenvolvido para interfaces de usu√°rio r√°pidas, portanto, o mecanismo de armazenamento de sess√µes √© auto-escrito e otimizado especificamente para a passagem por todas as sess√µes.  Todos os bilh√µes de eventos divididos em sess√µes s√£o comparados com os padr√µes em segundos em um √∫nico servidor. </p><br><p>  Se a velocidade n√£o for t√£o cr√≠tica para voc√™, um sistema semelhante pode ser projetado como uma extens√£o para um sistema de armazenamento de dados mais padr√£o, como um banco de dados relacional tradicional ou um sistema de arquivos distribu√≠do. </p><br><p>  A prop√≥sito, nas vers√µes mais recentes do <a href="">padr√£o SQL, um</a> recurso semelhante ao descrito no artigo j√° apareceu, e bancos de dados individuais ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Oracle</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vertica</a> ) j√° o implementaram.  O Yandex ClickHouse, por sua vez, implementa sua pr√≥pria linguagem semelhante a SQL, mas tamb√©m possui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fun√ß√µes semelhantes</a> . </p><br><p>  Distraindo-me de eventos e express√µes regulares, quero repetir que a aplicabilidade das m√°quinas virtuais √© muito mais ampla do que parece √† primeira vista.  Essa t√©cnica √© adequada e amplamente utilizada em todos os casos em que √© necess√°rio distinguir claramente entre as primitivas que o mecanismo do sistema entende e o subsistema "front", ou seja, por exemplo, alguma linguagem de programa√ß√£o ou DSL. </p><br><p>  Isso conclui uma s√©rie de artigos sobre os v√°rios usos de int√©rpretes de bytecode e m√°quinas virtuais.  Espero que os leitores de Habr tenham gostado da s√©rie e, √© claro, ficarei feliz em responder a quaisquer perguntas sobre o assunto. </p><br><h1 id="neformalnyy-spisok-literatury">  Refer√™ncias informais </h1><br><p>  Os int√©rpretes de bytecode para linguagens de programa√ß√£o s√£o um t√≥pico espec√≠fico e h√° relativamente pouca literatura sobre eles.  Pessoalmente, gostei do livro Virtual Machines de Ian Craig, apesar de descrever n√£o tanto a implementa√ß√£o de int√©rpretes quanto as m√°quinas abstratas - os modelos matem√°ticos subjacentes a v√°rias linguagens de programa√ß√£o. </p><br><p>  Em um sentido mais amplo, outro livro √© dedicado √†s m√°quinas virtuais - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúM√°quinas Virtuais: Plataformas Flex√≠veis para Sistemas e Processos‚Äù</a> ("M√°quinas Virtuais: Plataformas Vers√°teis para Sistemas e Processos").  Esta √© uma introdu√ß√£o aos v√°rios aplicativos de virtualiza√ß√£o, cobrindo a virtualiza√ß√£o de linguagens, processos e arquiteturas de computadores em geral. </p><br><p>  Os aspectos pr√°ticos do desenvolvimento de mecanismos de express√£o regular raramente s√£o discutidos na literatura popular sobre compiladores.  O Pig Match e o exemplo do primeiro artigo s√£o baseados em id√©ias de uma incr√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√©rie de artigos de</a> Russ Cox, um dos desenvolvedores do mecanismo Google RE2. </p><br><p>  A teoria das express√µes regulares √© apresentada em todos os livros acad√™micos sobre compiladores.  √â costume se referir ao famoso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Livro dos Drag√µes"</a> , mas eu recomendaria come√ßar pelo link acima. </p><br><p>  Enquanto trabalhava neste artigo, usei pela primeira vez um sistema interessante para o r√°pido desenvolvimento de compiladores para o Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">raddsl</a> , que pertence √† caneta do usu√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">true-grue</a> (obrigado, Peter!).  Se voc√™ se deparar com a tarefa de criar um prot√≥tipo de uma linguagem ou desenvolver rapidamente algum tipo de DSL, preste aten√ß√£o nela. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433054/">https://habr.com/ru/post/pt433054/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433044/index.html">O c√≥digo fonte do OpenJDK cont√©m muitos palavr√µes</a></li>
<li><a href="../pt433046/index.html">Toda a verdade sobre o RTOS. Artigo 25. Canais de Dados: Introdu√ß√£o e Servi√ßos B√°sicos</a></li>
<li><a href="../pt433048/index.html">Como 2019 mudar√° as lojas russas</a></li>
<li><a href="../pt433050/index.html">De projetista de aeronaves a programador em um ano, ou como se tornar um Jedi</a></li>
<li><a href="../pt433052/index.html">snap & flatpack - trag√©dia das comunidades</a></li>
<li><a href="../pt433056/index.html">Minist√©rio das Comunica√ß√µes aperta regras para software com elementos de origem estrangeira</a></li>
<li><a href="../pt433058/index.html">Quinteto como uma entidade b√°sica para descrever uma √°rea de assunto</a></li>
<li><a href="../pt433060/index.html">Por que n√£o acredito em marcas de micropigmenta√ß√£o</a></li>
<li><a href="../pt433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Compare C√¢meras CFTV</a></li>
<li><a href="../pt433064/index.html">Gerenciamento de incidentes: "voc√™ n√£o pode desistir" ou a arte de colocar v√≠rgulas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>