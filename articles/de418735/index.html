<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⌨️ 📳 🛋️ Konzentration auf Eigentum 💎 🧑🏽 🤴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis Übersetzer: Der Datensatz ist vom 13. Mai 2014 datiert, sodass einige Details, einschließlich des Quellcodes, möglicherweise nicht dem aktuell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konzentration auf Eigentum</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418735/"><p>  <em>Hinweis</em>  <em>Übersetzer: Der Datensatz ist vom 13. Mai 2014 datiert, sodass einige Details, einschließlich des Quellcodes, möglicherweise nicht dem aktuellen Stand der Dinge entsprechen.</em>  <em>Die Antwort auf die Frage, warum die Übersetzung eines so langjährigen Beitrags erforderlich ist, wird der Wert seines Inhalts sein, um ein Verständnis für eines der grundlegenden Konzepte der Rust-Sprache wie die Sprachkompetenz zu entwickeln.</em> </p><br><p>  Mit der Zeit wurde ich überzeugt, dass es besser wäre, die Unterscheidung zwischen veränderlichen und unveränderlichen lokalen Variablen in Rust aufzugeben.  Zumindest viele Menschen stehen diesem Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">skeptisch</a> gegenüber.  Ich wollte meine Position öffentlich darlegen.  Ich werde verschiedene Motive nennen: philosophisch, technisch und praktisch, sowie mich der Hauptverteidigung des gegenwärtigen Systems zuwenden.  (Hinweis: Ich habe dies als Rust RFC angesehen, aber entschieden, dass der Ton für einen Blog-Beitrag besser ist, und ich habe jetzt keine Zeit, ihn neu zu schreiben.) </p><a name="habracut"></a><br><h2 id="poyasnenie">  Erklärung </h2><br><p>  Ich habe diesen Artikel ziemlich entschlossen geschrieben und glaube, dass die Linie, die ich verteidige, korrekt sein wird.  Wenn wir das aktuelle System jedoch nicht vollständig unterstützen, ist dies keine Katastrophe oder ähnliches.  Es hat seine Vorteile und insgesamt finde ich es ziemlich angenehm.  Ich denke nur, wir können es verbessern. </p><br><h2 id="odnim-slovom">  In einem Wort </h2><br><p> Ich möchte die Unterscheidung zwischen unveränderlichen und veränderlichen lokalen Variablen aufheben und <code>&amp;mut</code> Zeiger auf <code>&amp;my</code> , <code>&amp;only</code> oder <code>&amp;uniq</code> (das <code>&amp;uniq</code> für mich keinen Unterschied).  Wenn es nur kein Schlüsselwort <code>mut</code> gäbe. </p><br><h2 id="filosofskiy-motiv">  Philosophisches Motiv </h2><br><p>  Der Hauptgrund, warum ich dies tun möchte, ist, dass ich glaube, dass dies die Sprache konsistenter und verständlicher macht.  Dies wird uns im Wesentlichen von der Diskussion über <em>Veränderlichkeit</em> zur <em>Verwendung von Aliasnamen</em> (die ich als "Teilen" bezeichnen werde, siehe unten) neu ausrichten. </p><br><p>  Variabilität wird zu einer Folge der Einzigartigkeit: „Sie können jederzeit alles ändern, auf das Sie einen eindeutigen Zugriff haben. Freigegebene Daten sind normalerweise unveränderlich. Bei Bedarf können Sie sie jedoch mithilfe eines Zelltyps ändern.“ </p><br><p>  Mit anderen Worten, im Laufe der Zeit wurde mir klar, dass Probleme mit Datenrennen und Speichersicherheit auftreten, wenn Sie sowohl Aliase als auch Veränderlichkeit verwenden.  Ein funktionaler Ansatz zur Lösung dieses Problems besteht darin, die Veränderlichkeit zu beseitigen.  Rusts Ansatz wäre es, die Verwendung von Aliasen zu entfernen.  Dies gibt uns eine Geschichte, die erzählt werden kann und die uns hilft, sie herauszufinden. </p><br><p>  Ein Hinweis zur Terminologie: Ich denke, wir sollten die <em>Verwendung von Aliasen</em> als <em>Trennung bezeichnen</em> ( <em>Anmerkung</em> <em>des</em> <em>Übersetzers: Im Folgenden wird überall anstelle von "Aliasing" "Teilen" im Sinne von "Trennung" oder "gemeinsames Eigentum" verwendet, da weder "Verwendung von Aliasen", " Weder "Pseudonymisierung" gibt ein Verständnis dafür, worum es geht</em> .  In der Vergangenheit haben wir dies aufgrund seiner Multithread-Referenzen vermieden.  Wenn wir jedoch die von mir vorgeschlagenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenparallelisierungspläne</a> implementieren, ist diese Konnotation nicht völlig unangemessen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angesichts der engen Beziehung</a> zwischen Speichersicherheit und Datenrennsport möchte ich diese Konnotation wirklich fördern. </p><br><h2 id="obrazovatelnyy-motiv">  Bildungsmotiv </h2><br><p>  Ich denke, die aktuellen Regeln sind schwieriger zu verstehen, als sie sein sollten.  Es ist zum Beispiel nicht offensichtlich, dass <code>&amp;mut T</code> keine gemeinsame Eigentümerschaft impliziert.  Darüber hinaus impliziert die Bezeichnung <code>&amp;mut T</code> , dass <code>&amp;T</code> keine Mutabilität impliziert, die aufgrund von Typen wie <code>Cell</code> nicht ganz genau ist.  Und es ist unmöglich, sich darauf zu einigen, wie man sie nennt ("veränderbare / unveränderliche Links" sind am häufigsten, aber das ist nicht ganz richtig). </p><br><p>  Im Gegensatz dazu scheint ein Typ wie <code>&amp;my T</code> oder <code>&amp;only T</code> die Erklärung zu vereinfachen.  Dies ist eine <em>eindeutige Verbindung</em> - natürlich können Sie nicht zwei von ihnen zwingen, auf dieselbe Stelle zu zeigen.  Und <em>Veränderlichkeit</em> ist eine orthogonale Sache: Sie beruht auf Einzigartigkeit, gilt aber auch für Zellen.  Und der <code>&amp;T</code> Typ ist genau das Gegenteil, ein <em>gemeinsamer Link</em> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC PR # 58</a> bietet eine Reihe ähnlicher Argumente.  Ich werde sie hier nicht wiederholen. </p><br><h2 id="prakticheskiy-motiv">  Praktisches Motiv </h2><br><p>  Derzeit besteht eine Lücke zwischen geliehenen Zeigern, die entweder gemeinsam genutzt oder veränderbar + eindeutig sein können, und lokalen Variablen, die immer eindeutig, aber veränderlich oder unveränderlich sein können.  Das Endergebnis davon ist, dass Benutzer <code>mut</code> Anzeigen zu Dingen <code>mut</code> sollten, die nicht direkt bearbeitet werden können. </p><br><h3 id="lokalnye-peremennye-ne-mogut-byt-smodelirovany-s-ispolzovaniem-ssylok">  Lokale Variablen können nicht mithilfe von Referenzen modelliert werden </h3><br><p>  Dieses Phänomen tritt auf, weil Verknüpfungen nicht so aussagekräftig sind wie lokale Variablen.  Dies verhindert im Allgemeinen die Abstraktion.  Lassen Sie mich einige Beispiele geben, um zu erklären, was ich meine.  Stellen Sie sich vor, ich habe eine Umgebungsstruktur, in der ein Zeiger auf einen Fehlerzähler gespeichert ist: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span></span> { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Jetzt kann ich Instanzen dieser Struktur erstellen (und verwenden): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  OK, stellen Sie sich jetzt vor, ich möchte den Code, der <code>env.errors</code> ändert, in eine separate Funktion <code>env.errors</code> .  Ich könnte denken, da die <code>env</code> Variable nicht als veränderbar deklariert ist, kann ich den unveränderlichen <code>&amp;</code> link verwenden: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;env); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span></span>(env: &amp;Env) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  } }</span></span></code> </pre> <br><p>  Aber das ist nicht so.  Das Problem ist, dass <code>&amp;Env</code> ein Typ mit gemeinsamem Besitz ist ( <em>Anmerkung des Übersetzers: Wie Sie wissen, kann mehr als eine unveränderliche Objektreferenz gleichzeitig vorhanden sein</em> ), und daher erscheint <code>env.errors</code> in einem Bereich, der einen separaten Besitz des <code>env</code> Objekts ermöglicht.  Damit dieser Code funktioniert, muss ich <code>env</code> als veränderbar deklarieren und den <code>&amp;mut</code> Link ( <em>Anmerkung des Übersetzers: <code>&amp;mut</code> ) verwenden, um dem Compiler mitzuteilen, dass <code>env</code> eindeutig im Besitz ist, da jeweils nur eine veränderbare Objektreferenz vorhanden sein kann und Datenrennen ausgeschlossen sind. aber <code>mut</code> weil Sie keinen veränderlichen Verweis auf ein unveränderliches Objekt erstellen können</em> ): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env);</code> </pre> <br><p>  Dieses Problem tritt auf, weil wir wissen, dass lokale Variablen eindeutig sind, aber wir können dieses Wissen nicht in eine geliehene Referenz einfügen, ohne es veränderbar zu machen. </p><br><p>  Dieses Problem tritt an einer Reihe anderer Stellen auf.  Bisher haben wir auf unterschiedliche Weise darüber geschrieben, aber ich bin weiterhin von dem Gefühl verfolgt, dass es sich um eine Pause handelt, die einfach nicht sein sollte. </p><br><h3 id="proverka-tipov-primenitelno-k-zamykaniyam">  Typprüfung auf Verschlüsse </h3><br><p>  Wir mussten diese Einschränkung bei Schließungen umgehen.  Verschlüsse <em>sind</em> in Strukturen wie <code>Env</code> <em>meist</em> offen, aber nicht ganz.  Dies liegt daran, dass ich nicht verlangen möchte, dass lokale Variablen <code>mut</code> deklariert werden, wenn sie über <code>&amp;mut</code> in einem Abschluss verwendet werden.  Mit anderen Worten, nehmen Sie einen Code, zum Beispiel: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { do_something(|| *errors += <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p>  Ein Ausdruck, der den Abschluss beschreibt, erstellt tatsächlich eine Instanz der <code>Env</code> Struktur: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClosureEnv</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt; { errors: &amp;uniq &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Überprüfen Sie den <code>&amp;uniq</code> Link.  Dies kann der Endbenutzer nicht eingeben.  Es bedeutet einen "eindeutigen, aber nicht unbedingt veränderlichen" Zeiger.  Dies ist erforderlich, um die Typprüfung zu bestehen.  Wenn der Benutzer versuchen würde, diese Struktur manuell zu schreiben, müsste er <code>&amp;mut &amp;mut usize</code> schreiben, was wiederum erfordern würde, dass der <code>mut errors: &amp;mut usize</code> als <code>mut errors: &amp;mut usize</code> deklariert wird <code>mut errors: &amp;mut usize</code> . </p><br><h3 id="nezapakovannye-zamykaniya-i-procedury">  Ausgepackte Verschlüsse und Verfahren </h3><br><p>  Ich gehe davon aus, dass diese Einschränkung ein Problem für ausgepackte Verschlüsse ist.  Lassen Sie mich auf das Design eingehen, über das ich nachgedacht habe.  Grundsätzlich war die Idee, dass der Ausdruck <code>||</code>  entspricht einem neuen Strukturtyp, der eines der Merkmale <code>Fn</code> implementiert: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fn</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnMut</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnOnce</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); }</code> </pre> <br><p>  Der genaue Typ wird ab heute entsprechend dem erwarteten Typ ausgewählt.  In diesem Fall können Verbraucher von Schließungen eines von zwei Dingen schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: T) { ... }</code> </pre> <br><p>  Wir ... wollen wahrscheinlich die Syntax <code>FnMut(usize) -&gt; usize</code> , vielleicht Zucker wie <code>FnMut(usize) -&gt; usize</code> oder | usize | speichern  -&gt; usize etc.  Es ist nicht so wichtig, es ist wichtig, dass wir den Abschluss <em>nach Wert übergeben</em> .  Bitte beachten Sie, dass es gemäß den aktuellen DST-Regeln (Dynamically-Sized Types) zulässig ist, einen Typ als Wert als Argument an das <code>FnMut&lt;usize, usize&gt;</code> . Daher ist das Argument <code>FnMut&lt;usize, usize&gt;</code> eine gültige Sommerzeit und kein Problem. </p><br><p>  <em>Nebenbei</em> : Dieses Projekt ist nicht abgeschlossen, und ich werde alle Details in einer separaten Nachricht beschreiben. </p><br><p>  Das Problem ist, dass ein <code>&amp;mut</code> Link erforderlich ist, um einen Abschluss aufzurufen.  Da der Abschluss als Wert übergeben wird, müssen Benutzer erneut <code>mut</code> schreiben, wo er fehl am Platz aussieht: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  Dies ist das gleiche Problem wie im obigen <code>Env</code> Beispiel: Was hier <em>tatsächlich</em> passiert, ist, dass das <code>FnMut</code> nur eine <em>eindeutige</em> Verknüpfung wünscht, aber da es nicht Teil des Typsystems ist, fordert es eine <em>veränderbare</em> Verknüpfung an. </p><br><p>  Jetzt können wir das vielleicht auf verschiedene Arten umgehen.  Eine Option, die wir tun könnten, ist <code>||</code>  Die Syntax würde sich nicht zu einem „bestimmten Strukturtyp“ erweitern, sondern zu einem „Strukturtyp oder einem Zeiger auf einen Strukturtyp, wie durch Typinferenz vorgegeben“.  In diesem Fall könnte der Anrufer schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  Ich möchte nicht sagen, dass dies das Ende der Welt ist.  Dies ist jedoch ein weiterer Schritt vorwärts in den wachsenden Verzerrungen, die wir durchlaufen müssen, um diese Lücke zwischen lokalen Variablen und Referenzen aufrechtzuerhalten. </p><br><h3 id="drugie-chasti-api">  Andere API-Teile </h3><br><p>  Ich habe keine erschöpfende Studie durchgeführt, aber dieser Unterschied macht sich natürlich anderswo bemerkbar.  Um beispielsweise aus <code>Socket</code> zu lesen, benötige ich einen eindeutigen Zeiger, daher muss ich ihn als veränderbar deklarieren.  Daher funktioniert dies manchmal nicht: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> socket = Socket::new(); socket.read() <span class="hljs-comment"><span class="hljs-comment">// :   </span></span></code> </pre> <br><p>  Nach meinem Vorschlag würde ein solcher Code natürlich gut funktionieren.  Sie würden immer noch eine Fehlermeldung erhalten, wenn Sie versuchen würden, von <code>&amp;Socket</code> zu lesen, aber dann würde es so etwas wie "Es ist unmöglich, einen eindeutigen Link zu einem gemeinsam genutzten Link zu erstellen" lesen, was ich persönlich für verständlicher halte. </p><br><h2 id="no-razve-nam-ne-nuzhen-mut-dlya-bezopasnosti">  Aber brauchen wir nicht <code>mut</code> für die Sicherheit? </h2><br><p>  Nein, überhaupt nicht.  Rust-Programme wären gleich gut, wenn Sie nur alle Bindungen als <code>mut</code> deklarieren würden.  Der Compiler ist perfekt in der Lage zu verfolgen, welche lokalen Variablen sich zu einem bestimmten Zeitpunkt ändern - gerade weil sie für die aktuelle Funktion <em>lokal</em> sind.  Was das Typensystem wirklich interessiert, ist die Einzigartigkeit. </p><br><p>  Die Bedeutung, die ich in den aktuellen Regeln für die Anwendung von <code>mut</code> sehe, und ich werde nicht leugnen, dass es Wert hat, ist in erster Linie, dass sie helfen, die Absicht zu erklären.  Das heißt, wenn ich den Code lese, weiß ich, welche Variablen neu zugewiesen werden können.  Andererseits verbringe ich auch viel Zeit damit, C ++ - Code zu lesen, und ehrlich gesagt habe ich nie bemerkt, dass dies ein großer Stolperstein ist.  (Gleiches gilt für die Zeit, die ich mit dem Lesen von Code in Java, JavaScript, Python oder Ruby verbracht habe.) </p><br><p>  Es stimmt auch, dass ich manchmal Fehler finde, weil ich die Variable als <code>mut</code> deklariert und vergessen habe, sie zu ändern.  Ich denke, wir könnten ähnliche Vorteile mit anderen, aggressiveren Überprüfungen erzielen (zum Beispiel ändert sich keine der Variablen, die in der Schleifenbedingung verwendet werden, im Körper der Schleife).  Ich persönlich kann mich nicht erinnern, mit der umgekehrten Situation konfrontiert zu sein: Wenn der Compiler sagt, dass etwas veränderbar sein sollte, bedeutet dies im Grunde immer, dass ich das <code>mut</code> Schlüsselwort irgendwo vergessen habe.  (Denken Sie daran: Wann haben Sie das letzte Mal auf einen Compilerfehler bezüglich einer ungültigen Änderung reagiert, indem Sie etwas anderes getan haben, als den Code neu zu strukturieren, um die Änderung gültig zu machen?) </p><br><h2 id="alternativy">  Alternativen </h2><br><p>  Ich sehe drei Alternativen zum aktuellen System: </p><br><ol><li>  Die, die ich vorgestellt habe, in der Sie einfach „Veränderlichkeit“ wegwerfen und nur die Einzigartigkeit verfolgen. </li><li>  Eine, bei der Sie drei Referenztypen haben: <code>&amp;</code> , <code>&amp;uniq</code> und <code>&amp;mut</code> .  (Wie ich schrieb, ist dies tatsächlich das Typensystem, das wir heute haben, zumindest aus der Sicht eines Kreditprüfers.) </li><li><p>  Eine strengere Option, bei der Nicht-Mut-Variablen immer als getrennt betrachtet werden.  Dies würde bedeuten, dass Sie schreiben müssten: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> p = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors; <span class="hljs-comment"><span class="hljs-comment">// ,  `p`   ,  `mut`. *p += 1;</span></span></code> </pre> <br><p>  Sie müssen <code>p</code> als <code>mut</code> deklarieren, da sonst die Variable als getrennt betrachtet wird, obwohl es sich um eine lokale Variable handelt. Daher ist das Ändern von <code>*p</code> nicht zulässig.  Was in diesem Schema seltsam ist, ist, dass die lokale Variable KEINEN separaten Besitz zulässt, und wir wissen es mit Sicherheit, denn wenn Sie versuchen, ihren Alias ​​zu erstellen, bewegt sie sich, der Destruktor startet darauf usw.  Das heißt, wir haben immer noch das Konzept "besessen", das sich von "erlaubt kein separates Eigentum" unterscheidet. </p><br><p>  Wenn wir andererseits dieses System beschreiben und sagen, dass die Veränderlichkeit über <code>&amp;mut</code> Zeiger vererbt wird, ohne über das gemeinsame Eigentum zu stottern, könnte dies sinnvoll sein. </p><br></li></ol><br><p>  Von diesen dreien bevorzuge ich definitiv Nr. 1.  Es ist das einfachste, und jetzt interessiert mich am meisten, wie wir Rust vereinfachen können, indem wir seinen Charakter bewahren.  Ansonsten bevorzuge ich die, die wir gerade haben. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Grundsätzlich finde ich, dass die aktuellen Regeln zur Veränderlichkeit einen gewissen Wert haben, aber sie sind teuer.  Sie sind eine Art fließende Abstraktion: Das heißt, sie erzählen eine einfache Geschichte, die sich tatsächlich als unvollständig herausstellt.  Dies führt zu Verwirrung, wenn Menschen von einem anfänglichen Verständnis, in dem <code>&amp;mut</code> die Funktionsweise von Mutabilität widerspiegelt, zu einem vollständigen Verständnis <code>mut</code> : Manchmal wird <code>mut</code> nur benötigt, um die Eindeutigkeit sicherzustellen, und manchmal wird Mutabilität ohne das Schlüsselwort <code>mut</code> . </p><br><p>  Darüber hinaus müssen wir mit Vorsicht handeln, um die Fiktion aufrechtzuerhalten, die <code>mut</code> Mutabilität und nicht Einzigartigkeit bedeutet.  Wir haben Sonderfälle hinzugefügt, in denen der Kreditnehmer nach Schließungen suchen kann.  Wir müssen die Regeln bezüglich <code>&amp;mut</code> Mutabilität im Allgemeinen komplexer gestalten.  Wir müssen entweder <code>mut</code> zu den Closures hinzufügen, damit wir sie aufrufen können, oder die Syntax der Closures auf weniger offensichtliche Weise öffnen.  Usw. </p><br><p>  Am Ende wird alles zu einer komplexeren Sprache als Ganzes.  Anstatt nur über gemeinsames Eigentum und Einzigartigkeit nachzudenken, sollte der Benutzer über gemeinsames Eigentum und Veränderlichkeit nachdenken, und beide sind irgendwie durcheinander. </p><br><p>  Ich denke nicht, dass es das wert ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418735/">https://habr.com/ru/post/de418735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418723/index.html">Patch AndroidX</a></li>
<li><a href="../de418725/index.html">Magische Konstante</a></li>
<li><a href="../de418727/index.html">Wo und wie man in Graph-Einbettungen kommt</a></li>
<li><a href="../de418729/index.html">Alles, wonach Sie lange in einer Version gefragt haben - CLion 2018.2</a></li>
<li><a href="../de418733/index.html">Visualisierung der Kommentare von YouTube-Kanälen internationaler und lokaler Touhou-Communities</a></li>
<li><a href="../de418737/index.html">Laserablation, Telluritglas und Dotierstoff Er2O3</a></li>
<li><a href="../de418739/index.html">Additive Technology Center: Industrielle 3D-Drucker 3D-Systeme, Stratasys, SLM, EOS</a></li>
<li><a href="../de418741/index.html">Fügen Sie die Verschlüsselung hinzu und drücken Sie auf reguläres SIP</a></li>
<li><a href="../de418743/index.html">Geschichte des ersten Platzes im ML Boot Camp VI</a></li>
<li><a href="../de418747/index.html">Problemlösung: Wie können Probleme in einem Team effektiv gelöst werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>