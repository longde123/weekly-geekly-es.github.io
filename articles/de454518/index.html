<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüé§ üë®üèª‚Äç‚öïÔ∏è üåº Wasmer: Die schnellste Go-Bibliothek zum Ausf√ºhren von WebAssembly-Code üëãüèº üòû üë©üèø‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebAssembly (wasm) ist ein portables bin√§res Anweisungsformat. Der gleiche Code-Wasm-Code kann in jeder Umgebung ausgef√ºhrt werden. Um diese Aussage z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wasmer: Die schnellste Go-Bibliothek zum Ausf√ºhren von WebAssembly-Code</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/454518/">  WebAssembly (wasm) ist ein portables bin√§res Anweisungsformat.  Der gleiche Code-Wasm-Code kann in jeder Umgebung ausgef√ºhrt werden.  Um diese Aussage zu unterst√ºtzen, muss jede Sprache, Plattform und jedes System in der Lage sein, solchen Code auszuf√ºhren, um ihn so schnell und sicher wie m√∂glich zu machen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/6b/ba/7g/6bba7gvszh2fqjm_zupvfk90fea.png"></a> <a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wasmer</a> ist eine in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust</a> geschriebene Wasm-Laufzeit.  Nat√ºrlich kann der Wasmer in jeder Rust-Anwendung verwendet werden.  Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, sagt, dass er und andere Teilnehmer des Wasmer-Projekts diese Wasm-Code-Laufzeit erfolgreich in anderen Sprachen implementiert haben: <br><br><ul><li>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C und C ++ wird</a> dies durch Bindungen implementiert. </li><li>  In PHP ist es eine Erweiterung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">php-ext-wasm</a> . </li><li>  In Python ist dies ein in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyPi</a> ver√∂ffentlichtes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wasmer-</a> Paket, an dem im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python-Ext-Wasm-Repository gearbeitet wird</a> . </li><li>  In Ruby ist dies das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wasmer-</a> Juwel, das auf RubyGems zu finden ist.  Der Code befindet sich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ruby-Ext-Wasm-Repository</a> . </li></ul><br>  Hier werden wir √ºber ein neues Projekt sprechen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">go-ext-wasm</a> , eine Bibliothek f√ºr Go, die zur Ausf√ºhrung von bin√§rem Wasm-Code entwickelt wurde.  Wie sich herausstellte, ist das go-ext-wasm-Projekt viel schneller als andere √§hnliche L√∂sungen.  Aber lasst uns nicht weiterkommen.  Beginnen wir mit einer Geschichte dar√ºber, wie man mit ihm arbeitet. <br><br><h2>  <font color="#3AC1EF">Wasm-Funktionen von Go aus aufrufen</font> </h2><br>  Installieren Sie den Wasmer zun√§chst in einer Go-Umgebung (mit CGO-Unterst√ºtzung). <br><br><pre><code class="go hljs">export CGO_ENABLED=<span class="hljs-number"><span class="hljs-number">1</span></span>; export CC=gcc; <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> install github.com/wasmerio/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-ext-wasm/wasmer</code> </pre> <br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">go-ext-wasm-Projekt</a> ist eine regul√§re Go-Bibliothek.  Bei der Arbeit mit dieser Bibliothek wird das <code>import "github.com/wasmerio/go-ext-wasm/wasmer"</code> . <br><br>  Jetzt lass uns √ºben.  Wir werden ein einfaches Programm schreiben, das in wasm kompiliert wird.  Wir werden daf√ºr zum Beispiel Rust verwenden: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> {   x + y }</code> </pre> <br>  Wir rufen die Datei mit dem Programm <code>simple.rs</code> . Als Ergebnis des Kompilierens dieses Programms erhalten wir die Datei <a href="">simple.wasm</a> . <br><br>  Das folgende in Go geschriebene Programm f√ºhrt die <code>sum</code> aus der WASM-Datei aus und √ºbergibt ihr die Zahlen 5 und 37 als Argumente: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (   <span class="hljs-string"><span class="hljs-string">"fmt"</span></span>   wasm <span class="hljs-string"><span class="hljs-string">"github.com/wasmerio/go-ext-wasm/wasmer"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-comment"><span class="hljs-comment">//   WebAssembly.   bytes, _ := wasm.ReadBytes("simple.wasm")   //    WebAssembly.   instance, _ := wasm.NewInstance(bytes)   defer instance.Close()   //    `sum`   WebAssembly.   sum := instance.Exports["sum"]   //        Go.   //   ,      ,  .   result, _ := sum(5, 37)   fmt.Println(result) // 42! }</span></span></code> </pre> <br>  Hier ruft ein in Go geschriebenes Programm eine Funktion aus einer WASM-Datei auf, die durch Kompilieren von in Rust geschriebenem Code erhalten wurde. <br><br>  Das Experiment war also ein Erfolg. Wir haben den WebAssembly-Code in Go erfolgreich ausgef√ºhrt.  Es ist zu beachten, dass die Datentypkonvertierung automatisiert ist.  Diese Go-Werte, die an den Wasm-Code √ºbergeben werden, werden in WebAssembly-Typen umgewandelt.  Was die wasm-Funktion zur√ºckgibt, wird in Go-Typen umgewandelt.  Daher sieht das Arbeiten mit Funktionen aus WASM-Dateien in Go genauso aus wie das Arbeiten mit normalen Go-Funktionen. <br><br><h2>  <font color="#3AC1EF">Rufen Sie Go-Funktionen aus dem WebAssembly-Code auf</font> </h2><br>  Wie wir im vorherigen Beispiel gesehen haben, k√∂nnen WebAssembly-Module Funktionen exportieren, die von au√üen aufgerufen werden k√∂nnen.  Dies ist der Mechanismus, mit dem Wasm-Code in verschiedenen Umgebungen ausgef√ºhrt werden kann. <br><br>  Gleichzeitig k√∂nnen WebAssembly-Module selbst mit importierten Funktionen arbeiten.  Betrachten Sie das folgende in Rust geschriebene Programm. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add1</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { sum(x, y) } + <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  <code>import.rs</code> Sie die Datei mit <code>import.rs</code> .  Wenn Sie es in WebAssembly kompilieren, erhalten Sie Code, den Sie <a href="">hier finden</a> . <br><br>  Die exportierte Funktion <code>add1</code> ruft die <code>sum</code> .  Es gibt keine Implementierung dieser Funktion, nur ihre Signatur ist in der Datei definiert.  Dies ist die sogenannte externe Funktion.  F√ºr WebAssembly ist dies eine importierte Funktion.  Die Implementierung muss importiert werden. <br><br>  Wir implementieren die <code>sum</code> mit Go.  Daf√ºr m√ºssen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cgo verwenden</a> .  Hier ist der resultierende Code.  Einige Kommentare, die Beschreibungen der Hauptcodefragmente sind, sind nummeriert.  Im Folgenden werden wir ausf√ºhrlicher dar√ºber sprechen. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-comment"><span class="hljs-comment">// // 1.    `sum` (   cgo). // // #include &lt;stdlib.h&gt; // // extern int32_t sum(void *context, int32_t x, int32_t y); import "C" import (   "fmt"   wasm "github.com/wasmerio/go-ext-wasm/wasmer"   "unsafe" ) // 2.    `sum`    ( cgo). //export sum func sum(context unsafe.Pointer, x int32, y int32) int32 {   return x + y } func main() {   //   WebAssembly.   bytes, _ := wasm.ReadBytes("import.wasm")   // 3.     WebAssembly.   imports, _ := wasm.NewImports().Append("sum", sum, C.sum)   // 4.     WebAssembly  .   instance, _ := wasm.NewInstanceWithImports(bytes, imports)   //    WebAssembly.   defer instance.Close()   //    `add1`   WebAssembly.   add1 := instance.Exports["add1"]   //   .   result, _ := add1(1, 2)   fmt.Println(result)   // add1(1, 2)   // = sum(1 + 2) + 1   // = 1 + 2 + 1   // = 4   // QED }</span></span></code> </pre> <br>  Lassen Sie uns diesen Code analysieren: <br><br><ol><li>  Die Signatur der <code>sum</code> ist in C definiert (siehe Kommentar zum <code>import "C"</code> ). </li><li>  Die Implementierung der <code>sum</code> ist in Go definiert (beachten Sie die Zeile <code>//export</code> - dieser Mechanismus, mit dem cgo die Verbindung von in Go geschriebenem Code mit in C geschriebenem Code herstellt). </li><li>  <code>NewImports</code> ist eine API zum Erstellen von WebAssembly-Importen.  In diesem Code ist <code>"sum"</code> der Name der von WebAssembly importierten Funktion, <code>sum</code> ist der Zeiger auf die Go-Funktion und <code>C.sum</code> ist der Zeiger auf die cgo-Funktion. </li><li>  Und schlie√ülich ist <code>NewInstanceWithImports</code> ein Konstruktor, mit dem ein WebAssembly-Modul mit Importen initialisiert werden kann. </li></ol><br><h2>  <font color="#3AC1EF">Daten aus dem Speicher lesen</font> </h2><br>  Die WebAssembly-Instanz verf√ºgt √ºber einen linearen Speicher.  Lassen Sie uns dar√ºber sprechen, wie Daten daraus gelesen werden.  Beginnen wir wie gewohnt mit dem Rust-Code, den wir <code>memory.rs</code> nennen. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_hello</span></span></span></span>() -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> {   <span class="hljs-string"><span class="hljs-string">b"Hello, World!\0"</span></span>.as_ptr() }</code> </pre> <br>  Das Ergebnis der Kompilierung dieses Codes befindet sich in der Datei <code>memory.wasm</code> , die unten verwendet wird. <br><br>  Die Funktion <code>return_hello</code> gibt einen Zeiger auf eine Zeichenfolge zur√ºck.  Die Zeile endet wie in C mit einem Nullzeichen. <br><br>  Gehen Sie jetzt zur Go-Seite: <br><br><pre> <code class="go hljs">bytes, _ := wasm.ReadBytes(<span class="hljs-string"><span class="hljs-string">"memory.wasm"</span></span>) instance, _ := wasm.NewInstance(bytes) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> instance.Close() <span class="hljs-comment"><span class="hljs-comment">//    `return_hello`. //      . result, _ := instance.Exports["return_hello"]() //      . pointer := result.ToI32() //    . memory := instance.Memory.Data() fmt.Println(string(memory[pointer : pointer+13])) // Hello, World!</span></span></code> </pre> <br>  Die Funktion <code>return_hello</code> gibt einen Zeiger als <code>i32</code> Wert zur√ºck.  Wir erhalten diesen Wert durch Aufrufen von <code>ToI32</code> .  Dann erhalten wir die Daten aus dem Speicher mit <code>instance.Memory.Data()</code> . <br><br>  Diese Funktion gibt den Speicherbereich der WebAssembly-Instanz zur√ºck.  Sie k√∂nnen es wie jedes Go-Slice verwenden. <br><br>  Gl√ºcklicherweise kennen wir die L√§nge der Zeile, die wir lesen m√∂chten. Um die erforderlichen Informationen zu lesen, reicht es aus, das <code>memory[pointer : pointer+13]</code> verwenden.  Dann werden die gelesenen Daten in eine Zeichenfolge konvertiert. <br><br>  <a href="">Hier ist</a> ein Beispiel, das erweiterte Speichermechanismen bei Verwendung des WebAssembly-Codes von Go zeigt. <br><br><h2>  <font color="#3AC1EF">Benchmarks</font> </h2><br>  Das go-ext-wasm-Projekt verf√ºgt, wie wir gerade gesehen haben, √ºber eine praktische API.  Jetzt ist es Zeit, √ºber seine Leistung zu sprechen. <br><br>  Im Gegensatz zu PHP oder Ruby bietet die Go-Welt bereits L√∂sungen f√ºr die Arbeit mit Wasm-Code.  Insbesondere sprechen wir √ºber folgende Projekte: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leben</a> aus Perlin Network - WebAssembly-Interpreter. </li><li>  Go Interpreter's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wagon</a> ist ein WebAssembly-Interpreter und ein Toolkit. </li></ul><br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Material</a> des php-ext-wasm-Projekts verwendete den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n-K√∂rper-</a> Algorithmus, um die Leistung zu untersuchen.  Es gibt viele andere Algorithmen, mit denen die Leistung von Codeausf√ºhrungsumgebungen untersucht werden kann.  Dies ist beispielsweise der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fibonacci-</a> Algorithmus (rekursive Version) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Pollard-œÅ-Algorithmus,</a> die in Life verwendet werden.  Dies ist der Snappy-Komprimierungsalgorithmus.  Letzteres funktioniert erfolgreich mit Go-Ext-Wasm, aber nicht mit Life oder Wagon.  Infolgedessen wurde er aus dem Testset entfernt.  Testcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  W√§hrend der Tests wurden die neuesten Versionen der Forschungsprojekte verwendet.  Dies sind n√§mlich Life 20190521143330-57f3819c2df0 und Wagon 0.4.0. <br><br>  Die in der Tabelle angegebenen Zahlen geben die Durchschnittswerte wieder, die nach 10 Teststarts erhalten wurden.  In der Studie wurde das 2016 MacBook Pro 15 "mit einem Intel Core i7 2,9-GHz-Prozessor und 16 GB Speicher verwendet. <br><br>  Die Testergebnisse werden entlang der X-Achse gem√§√ü den Testtypen gruppiert.  Die Y-Achse zeigt die Zeit in Millisekunden an, die erforderlich ist, um den Test abzuschlie√üen.  Je kleiner der Indikator, desto besser. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/810/8c2/321/8108c23213493ab6ade095909770b58e.png"><br>  <i><font color="#999999">Leistungsvergleich von Wasmer, Wagon und Life mit Implementierungen verschiedener Algorithmen</font></i> <br><br>  Life- und Wagon-Plattformen liefern im Durchschnitt ungef√§hr die gleichen Ergebnisse.  Wasmer ist im Durchschnitt 72-mal schneller. <br><br>  Es ist wichtig zu beachten, dass Wasmer drei Backends unterst√ºtzt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Singlepass</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cranelift</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM</a> .  Das Standard-Backend in der Go-Bibliothek ist Cranelift ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> erfahren Sie mehr dar√ºber).  Die Verwendung von LLVM bietet eine Leistung, die nahezu nativ ist. Es wurde jedoch beschlossen, mit Cranelift zu beginnen, da dieses Backend das beste Verh√§ltnis zwischen Kompilierungszeit und Programmausf√ºhrungszeit bietet. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> k√∂nnen Sie √ºber verschiedene Backends lesen, deren Vor- und Nachteile und in welchen Situationen es besser ist, sie zu verwenden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Das Open-Source-Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">go-ext-wasm</a> ist eine neue Go-Bibliothek, mit der bin√§rer Wasm-Code ausgef√ºhrt werden kann.  Es enth√§lt eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wasmer-Laufzeit</a> .  Die erste Version enth√§lt APIs, deren Bedarf am h√§ufigsten auftritt. <br>  Leistungstests zeigten, dass Wasmer im Durchschnitt 72-mal schneller ist als Life and Wagon. <br><br>  <b>Liebe Leser!</b>  Planen Sie, die M√∂glichkeit zu nutzen, Wasm-Code in Go mit go-ext-wasm auszuf√ºhren? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454518/">https://habr.com/ru/post/de454518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454506/index.html">Entropic - Neue Registrierung f√ºr verteilte Pakete f√ºr Node.js.</a></li>
<li><a href="../de454508/index.html">Portieren von Desktop-Anwendungen nach .NET Core</a></li>
<li><a href="../de454512/index.html">Fr√ºhst√ºcksbericht mit Charles Weatherly, Autor des Kultbuchs Etudes for Programmers</a></li>
<li><a href="../de454514/index.html">Entwicklung eines einfachen Musiksynthesizers auf ATMEGA8</a></li>
<li><a href="../de454516/index.html">Wie man guten Text f√ºr 200 Rubel bekommt</a></li>
<li><a href="../de454520/index.html">Richtlinien zum Schreiben von sauberem JavaScript-Code</a></li>
<li><a href="../de454522/index.html">Node.js: Verwalten des Speichers, der f√ºr Anwendungen verf√ºgbar ist, die in Containern ausgef√ºhrt werden</a></li>
<li><a href="../de454524/index.html">Reparatur von Stirnb√§ndern Samsung Level On Pro</a></li>
<li><a href="../de454530/index.html">DJI hat einen Oktokopter entwickelt, der Filme machen kann</a></li>
<li><a href="../de454532/index.html">Ich werde ein Wort √ºber den technischen Ansatz sagen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>