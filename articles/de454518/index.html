<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🎤 👨🏻‍⚕️ 🌼 Wasmer: Die schnellste Go-Bibliothek zum Ausführen von WebAssembly-Code 👋🏼 😞 👩🏿‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebAssembly (wasm) ist ein portables binäres Anweisungsformat. Der gleiche Code-Wasm-Code kann in jeder Umgebung ausgeführt werden. Um diese Aussage z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wasmer: Die schnellste Go-Bibliothek zum Ausführen von WebAssembly-Code</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/454518/">  WebAssembly (wasm) ist ein portables binäres Anweisungsformat.  Der gleiche Code-Wasm-Code kann in jeder Umgebung ausgeführt werden.  Um diese Aussage zu unterstützen, muss jede Sprache, Plattform und jedes System in der Lage sein, solchen Code auszuführen, um ihn so schnell und sicher wie möglich zu machen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/6b/ba/7g/6bba7gvszh2fqjm_zupvfk90fea.png"></a> <a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wasmer</a> ist eine in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust</a> geschriebene Wasm-Laufzeit.  Natürlich kann der Wasmer in jeder Rust-Anwendung verwendet werden.  Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, sagt, dass er und andere Teilnehmer des Wasmer-Projekts diese Wasm-Code-Laufzeit erfolgreich in anderen Sprachen implementiert haben: <br><br><ul><li>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C und C ++ wird</a> dies durch Bindungen implementiert. </li><li>  In PHP ist es eine Erweiterung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">php-ext-wasm</a> . </li><li>  In Python ist dies ein in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyPi</a> veröffentlichtes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wasmer-</a> Paket, an dem im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python-Ext-Wasm-Repository gearbeitet wird</a> . </li><li>  In Ruby ist dies das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wasmer-</a> Juwel, das auf RubyGems zu finden ist.  Der Code befindet sich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ruby-Ext-Wasm-Repository</a> . </li></ul><br>  Hier werden wir über ein neues Projekt sprechen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">go-ext-wasm</a> , eine Bibliothek für Go, die zur Ausführung von binärem Wasm-Code entwickelt wurde.  Wie sich herausstellte, ist das go-ext-wasm-Projekt viel schneller als andere ähnliche Lösungen.  Aber lasst uns nicht weiterkommen.  Beginnen wir mit einer Geschichte darüber, wie man mit ihm arbeitet. <br><br><h2>  <font color="#3AC1EF">Wasm-Funktionen von Go aus aufrufen</font> </h2><br>  Installieren Sie den Wasmer zunächst in einer Go-Umgebung (mit CGO-Unterstützung). <br><br><pre><code class="go hljs">export CGO_ENABLED=<span class="hljs-number"><span class="hljs-number">1</span></span>; export CC=gcc; <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> install github.com/wasmerio/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-ext-wasm/wasmer</code> </pre> <br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">go-ext-wasm-Projekt</a> ist eine reguläre Go-Bibliothek.  Bei der Arbeit mit dieser Bibliothek wird das <code>import "github.com/wasmerio/go-ext-wasm/wasmer"</code> . <br><br>  Jetzt lass uns üben.  Wir werden ein einfaches Programm schreiben, das in wasm kompiliert wird.  Wir werden dafür zum Beispiel Rust verwenden: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> {   x + y }</code> </pre> <br>  Wir rufen die Datei mit dem Programm <code>simple.rs</code> . Als Ergebnis des Kompilierens dieses Programms erhalten wir die Datei <a href="">simple.wasm</a> . <br><br>  Das folgende in Go geschriebene Programm führt die <code>sum</code> aus der WASM-Datei aus und übergibt ihr die Zahlen 5 und 37 als Argumente: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (   <span class="hljs-string"><span class="hljs-string">"fmt"</span></span>   wasm <span class="hljs-string"><span class="hljs-string">"github.com/wasmerio/go-ext-wasm/wasmer"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-comment"><span class="hljs-comment">//   WebAssembly.   bytes, _ := wasm.ReadBytes("simple.wasm")   //    WebAssembly.   instance, _ := wasm.NewInstance(bytes)   defer instance.Close()   //    `sum`   WebAssembly.   sum := instance.Exports["sum"]   //        Go.   //   ,      ,  .   result, _ := sum(5, 37)   fmt.Println(result) // 42! }</span></span></code> </pre> <br>  Hier ruft ein in Go geschriebenes Programm eine Funktion aus einer WASM-Datei auf, die durch Kompilieren von in Rust geschriebenem Code erhalten wurde. <br><br>  Das Experiment war also ein Erfolg. Wir haben den WebAssembly-Code in Go erfolgreich ausgeführt.  Es ist zu beachten, dass die Datentypkonvertierung automatisiert ist.  Diese Go-Werte, die an den Wasm-Code übergeben werden, werden in WebAssembly-Typen umgewandelt.  Was die wasm-Funktion zurückgibt, wird in Go-Typen umgewandelt.  Daher sieht das Arbeiten mit Funktionen aus WASM-Dateien in Go genauso aus wie das Arbeiten mit normalen Go-Funktionen. <br><br><h2>  <font color="#3AC1EF">Rufen Sie Go-Funktionen aus dem WebAssembly-Code auf</font> </h2><br>  Wie wir im vorherigen Beispiel gesehen haben, können WebAssembly-Module Funktionen exportieren, die von außen aufgerufen werden können.  Dies ist der Mechanismus, mit dem Wasm-Code in verschiedenen Umgebungen ausgeführt werden kann. <br><br>  Gleichzeitig können WebAssembly-Module selbst mit importierten Funktionen arbeiten.  Betrachten Sie das folgende in Rust geschriebene Programm. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add1</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { sum(x, y) } + <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  <code>import.rs</code> Sie die Datei mit <code>import.rs</code> .  Wenn Sie es in WebAssembly kompilieren, erhalten Sie Code, den Sie <a href="">hier finden</a> . <br><br>  Die exportierte Funktion <code>add1</code> ruft die <code>sum</code> .  Es gibt keine Implementierung dieser Funktion, nur ihre Signatur ist in der Datei definiert.  Dies ist die sogenannte externe Funktion.  Für WebAssembly ist dies eine importierte Funktion.  Die Implementierung muss importiert werden. <br><br>  Wir implementieren die <code>sum</code> mit Go.  Dafür müssen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cgo verwenden</a> .  Hier ist der resultierende Code.  Einige Kommentare, die Beschreibungen der Hauptcodefragmente sind, sind nummeriert.  Im Folgenden werden wir ausführlicher darüber sprechen. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-comment"><span class="hljs-comment">// // 1.    `sum` (   cgo). // // #include &lt;stdlib.h&gt; // // extern int32_t sum(void *context, int32_t x, int32_t y); import "C" import (   "fmt"   wasm "github.com/wasmerio/go-ext-wasm/wasmer"   "unsafe" ) // 2.    `sum`    ( cgo). //export sum func sum(context unsafe.Pointer, x int32, y int32) int32 {   return x + y } func main() {   //   WebAssembly.   bytes, _ := wasm.ReadBytes("import.wasm")   // 3.     WebAssembly.   imports, _ := wasm.NewImports().Append("sum", sum, C.sum)   // 4.     WebAssembly  .   instance, _ := wasm.NewInstanceWithImports(bytes, imports)   //    WebAssembly.   defer instance.Close()   //    `add1`   WebAssembly.   add1 := instance.Exports["add1"]   //   .   result, _ := add1(1, 2)   fmt.Println(result)   // add1(1, 2)   // = sum(1 + 2) + 1   // = 1 + 2 + 1   // = 4   // QED }</span></span></code> </pre> <br>  Lassen Sie uns diesen Code analysieren: <br><br><ol><li>  Die Signatur der <code>sum</code> ist in C definiert (siehe Kommentar zum <code>import "C"</code> ). </li><li>  Die Implementierung der <code>sum</code> ist in Go definiert (beachten Sie die Zeile <code>//export</code> - dieser Mechanismus, mit dem cgo die Verbindung von in Go geschriebenem Code mit in C geschriebenem Code herstellt). </li><li>  <code>NewImports</code> ist eine API zum Erstellen von WebAssembly-Importen.  In diesem Code ist <code>"sum"</code> der Name der von WebAssembly importierten Funktion, <code>sum</code> ist der Zeiger auf die Go-Funktion und <code>C.sum</code> ist der Zeiger auf die cgo-Funktion. </li><li>  Und schließlich ist <code>NewInstanceWithImports</code> ein Konstruktor, mit dem ein WebAssembly-Modul mit Importen initialisiert werden kann. </li></ol><br><h2>  <font color="#3AC1EF">Daten aus dem Speicher lesen</font> </h2><br>  Die WebAssembly-Instanz verfügt über einen linearen Speicher.  Lassen Sie uns darüber sprechen, wie Daten daraus gelesen werden.  Beginnen wir wie gewohnt mit dem Rust-Code, den wir <code>memory.rs</code> nennen. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_hello</span></span></span></span>() -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> {   <span class="hljs-string"><span class="hljs-string">b"Hello, World!\0"</span></span>.as_ptr() }</code> </pre> <br>  Das Ergebnis der Kompilierung dieses Codes befindet sich in der Datei <code>memory.wasm</code> , die unten verwendet wird. <br><br>  Die Funktion <code>return_hello</code> gibt einen Zeiger auf eine Zeichenfolge zurück.  Die Zeile endet wie in C mit einem Nullzeichen. <br><br>  Gehen Sie jetzt zur Go-Seite: <br><br><pre> <code class="go hljs">bytes, _ := wasm.ReadBytes(<span class="hljs-string"><span class="hljs-string">"memory.wasm"</span></span>) instance, _ := wasm.NewInstance(bytes) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> instance.Close() <span class="hljs-comment"><span class="hljs-comment">//    `return_hello`. //      . result, _ := instance.Exports["return_hello"]() //      . pointer := result.ToI32() //    . memory := instance.Memory.Data() fmt.Println(string(memory[pointer : pointer+13])) // Hello, World!</span></span></code> </pre> <br>  Die Funktion <code>return_hello</code> gibt einen Zeiger als <code>i32</code> Wert zurück.  Wir erhalten diesen Wert durch Aufrufen von <code>ToI32</code> .  Dann erhalten wir die Daten aus dem Speicher mit <code>instance.Memory.Data()</code> . <br><br>  Diese Funktion gibt den Speicherbereich der WebAssembly-Instanz zurück.  Sie können es wie jedes Go-Slice verwenden. <br><br>  Glücklicherweise kennen wir die Länge der Zeile, die wir lesen möchten. Um die erforderlichen Informationen zu lesen, reicht es aus, das <code>memory[pointer : pointer+13]</code> verwenden.  Dann werden die gelesenen Daten in eine Zeichenfolge konvertiert. <br><br>  <a href="">Hier ist</a> ein Beispiel, das erweiterte Speichermechanismen bei Verwendung des WebAssembly-Codes von Go zeigt. <br><br><h2>  <font color="#3AC1EF">Benchmarks</font> </h2><br>  Das go-ext-wasm-Projekt verfügt, wie wir gerade gesehen haben, über eine praktische API.  Jetzt ist es Zeit, über seine Leistung zu sprechen. <br><br>  Im Gegensatz zu PHP oder Ruby bietet die Go-Welt bereits Lösungen für die Arbeit mit Wasm-Code.  Insbesondere sprechen wir über folgende Projekte: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leben</a> aus Perlin Network - WebAssembly-Interpreter. </li><li>  Go Interpreter's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wagon</a> ist ein WebAssembly-Interpreter und ein Toolkit. </li></ul><br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Material</a> des php-ext-wasm-Projekts verwendete den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n-Körper-</a> Algorithmus, um die Leistung zu untersuchen.  Es gibt viele andere Algorithmen, mit denen die Leistung von Codeausführungsumgebungen untersucht werden kann.  Dies ist beispielsweise der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fibonacci-</a> Algorithmus (rekursive Version) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Pollard-ρ-Algorithmus,</a> die in Life verwendet werden.  Dies ist der Snappy-Komprimierungsalgorithmus.  Letzteres funktioniert erfolgreich mit Go-Ext-Wasm, aber nicht mit Life oder Wagon.  Infolgedessen wurde er aus dem Testset entfernt.  Testcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Während der Tests wurden die neuesten Versionen der Forschungsprojekte verwendet.  Dies sind nämlich Life 20190521143330-57f3819c2df0 und Wagon 0.4.0. <br><br>  Die in der Tabelle angegebenen Zahlen geben die Durchschnittswerte wieder, die nach 10 Teststarts erhalten wurden.  In der Studie wurde das 2016 MacBook Pro 15 "mit einem Intel Core i7 2,9-GHz-Prozessor und 16 GB Speicher verwendet. <br><br>  Die Testergebnisse werden entlang der X-Achse gemäß den Testtypen gruppiert.  Die Y-Achse zeigt die Zeit in Millisekunden an, die erforderlich ist, um den Test abzuschließen.  Je kleiner der Indikator, desto besser. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/810/8c2/321/8108c23213493ab6ade095909770b58e.png"><br>  <i><font color="#999999">Leistungsvergleich von Wasmer, Wagon und Life mit Implementierungen verschiedener Algorithmen</font></i> <br><br>  Life- und Wagon-Plattformen liefern im Durchschnitt ungefähr die gleichen Ergebnisse.  Wasmer ist im Durchschnitt 72-mal schneller. <br><br>  Es ist wichtig zu beachten, dass Wasmer drei Backends unterstützt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Singlepass</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cranelift</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM</a> .  Das Standard-Backend in der Go-Bibliothek ist Cranelift ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> erfahren Sie mehr darüber).  Die Verwendung von LLVM bietet eine Leistung, die nahezu nativ ist. Es wurde jedoch beschlossen, mit Cranelift zu beginnen, da dieses Backend das beste Verhältnis zwischen Kompilierungszeit und Programmausführungszeit bietet. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> können Sie über verschiedene Backends lesen, deren Vor- und Nachteile und in welchen Situationen es besser ist, sie zu verwenden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Das Open-Source-Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">go-ext-wasm</a> ist eine neue Go-Bibliothek, mit der binärer Wasm-Code ausgeführt werden kann.  Es enthält eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wasmer-Laufzeit</a> .  Die erste Version enthält APIs, deren Bedarf am häufigsten auftritt. <br>  Leistungstests zeigten, dass Wasmer im Durchschnitt 72-mal schneller ist als Life and Wagon. <br><br>  <b>Liebe Leser!</b>  Planen Sie, die Möglichkeit zu nutzen, Wasm-Code in Go mit go-ext-wasm auszuführen? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454518/">https://habr.com/ru/post/de454518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454506/index.html">Entropic - Neue Registrierung für verteilte Pakete für Node.js.</a></li>
<li><a href="../de454508/index.html">Portieren von Desktop-Anwendungen nach .NET Core</a></li>
<li><a href="../de454512/index.html">Frühstücksbericht mit Charles Weatherly, Autor des Kultbuchs Etudes for Programmers</a></li>
<li><a href="../de454514/index.html">Entwicklung eines einfachen Musiksynthesizers auf ATMEGA8</a></li>
<li><a href="../de454516/index.html">Wie man guten Text für 200 Rubel bekommt</a></li>
<li><a href="../de454520/index.html">Richtlinien zum Schreiben von sauberem JavaScript-Code</a></li>
<li><a href="../de454522/index.html">Node.js: Verwalten des Speichers, der für Anwendungen verfügbar ist, die in Containern ausgeführt werden</a></li>
<li><a href="../de454524/index.html">Reparatur von Stirnbändern Samsung Level On Pro</a></li>
<li><a href="../de454530/index.html">DJI hat einen Oktokopter entwickelt, der Filme machen kann</a></li>
<li><a href="../de454532/index.html">Ich werde ein Wort über den technischen Ansatz sagen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>