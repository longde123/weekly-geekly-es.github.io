<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ó ü§≤üèº üë®üèª Verwenden von Waves Smart Accounts und Smart Assets in Finanzinstrumenten ‚õπüèø ü§≤üèº ‚ùóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem fr√ºheren Artikel haben wir uns mit mehreren F√§llen der Verwendung von Smart Accounts in Unternehmen befasst - einschlie√ülich Auktionen und Tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von Waves Smart Accounts und Smart Assets in Finanzinstrumenten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/443836/"><img src="https://habrastorage.org/webt/og/ub/mr/ogubmruoxy2myy1xvnnh64axnec.png" alt="Bild"><br><br>  <i>In einem fr√ºheren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel haben</a> wir uns mit mehreren F√§llen der Verwendung von Smart Accounts in Unternehmen befasst - einschlie√ülich Auktionen und Treueprogrammen.</i> <i><br></i>  <i>Heute werden wir dar√ºber sprechen, wie intelligente Konten und intelligente Verm√∂genswerte die Transparenz und Zuverl√§ssigkeit von Finanzinstrumenten wie Optionen, Futures und Rechnungen erh√∂hen k√∂nnen.</i> <i><br></i> <a name="habracut"></a><br>  <b>Option</b> <br><br>  Eine Option ist ein Umtauschvertrag, der dem K√§ufer das Recht gibt, einen Verm√∂genswert zu einem bestimmten Preis oder vor einem bestimmten Datum zu kaufen, ihn jedoch nicht dazu verpflichtet. <br><br>  Die Aus√ºbung der Option kann wie folgt erfolgen: <br><br>  Wir verwenden ein Smart Asset f√ºr die Optionen selbst als Tool und ein Smart Account f√ºr den Teilnehmer, der als Austausch fungiert und Optionen ausgibt.  Das B√∂rsenmitglied verspricht, einen bestimmten Betrag eines bestimmten Verm√∂genswerts zum Preis zu verkaufen (Verkaufspreis zwischen den H√∂hen der Bl√∂cke expirationStart und expirationEnd). <br><br>  Im Code des Smart Assets √ºberpr√ºfen wir einfach, ob es nur zwischen den angegebenen H√∂hen gehandelt wird, und wir √ºberpr√ºfen nichts anderes. Wir √ºberlassen die gesamte Verantwortung f√ºr die Einhaltung der Regeln dem Code des B√∂rsenteilnehmers. <br><br>  <b><i>Smart Asset Code:</i></b> <br><br><pre><code class="scala hljs">let expirationStart = <span class="hljs-number"><span class="hljs-number">100000</span></span> let expirationEnd = <span class="hljs-number"><span class="hljs-number">101440</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> some : <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> | <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; height &gt; expirationStart &amp;&amp; height &lt;= expirationEnd <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <i>Wir gehen davon aus, dass die Aktionen wie folgt sind: Das B√∂rsenmitglied verkauft Optionen f√ºr den Kauf eines Verm√∂genswerts, und der Rest der Teilnehmer kann diese Optionen √ºbertragen oder handeln.</i>  <i>Um von seinem Kaufrecht Gebrauch zu machen, muss ein potenzieller K√§ufer die gew√ºnschte Anzahl von Optionen auf das Konto des Verk√§ufers, dh des B√∂rsenteilnehmers, √ºbertragen.</i>  <i>Anschlie√üend schreibt er Informationen √ºber die abgeschlossene √úberweisung in den Kontostatus des Exchange-Mitglieds und erst dann kann ExchangeTransaction die angegebenen Kauf- und Verkaufsbedingungen durchlaufen.</i> <i><br><br></i>  <i>Im Code des Smart-Kontos m√ºssen wir sicherstellen, dass jede ExchangeTransaction, die f√ºr den endg√ºltigen Kauf-Verkaufs-Vorgang durchlaufen wird, die angegebenen Bedingungen erf√ºllt und der Teilnehmer genau die Anzahl der Einheiten kauft, die er auf das Konto des Exchange-Teilnehmers gesendet hat.</i>  <i>Ein potenzieller K√§ufer muss die korrekte DataTransaction √ºber die √úbertragung senden, damit das Austauschmitglied doppelte Ausgaben vermeiden kann.</i>  <i>Bei dieser DataTransaction legt der K√§ufer einen Schl√ºssel an, der seiner Adresse entspricht. Dies entspricht der Anzahl der Optionen, die auf das Konto des B√∂rsenmitglieds √ºbertragen wurden, dh der Anzahl der Asset-Einheiten, die er kaufen kann.</i> <br><br>  <b><i>Smart Account Code:</i></b> <br><br><pre> <code class="scala hljs">#         #  sellPrice    expirationStart  expirationEnd let expirationStart = <span class="hljs-number"><span class="hljs-number">100000</span></span> let expirationEnd = <span class="hljs-number"><span class="hljs-number">101440</span></span> let sellPrice = <span class="hljs-number"><span class="hljs-number">10000</span></span> let amountAsset = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let priceAsset = base58<span class="hljs-symbol"><span class="hljs-symbol">'9jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #<span class="hljs-type"><span class="hljs-type">ID</span></span> - let optionsAsset = base58<span class="hljs-symbol"><span class="hljs-symbol">'7jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> dataTx : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #    -   (<span class="hljs-type"><span class="hljs-type">ID</span></span> ) let units = extract(getInteger(dataTx.data, dataTx.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) # -    let e = transactionById(dataTx.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>]) # <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> e { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> transferTx : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; #,       (transferTx.recipient == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) &amp;&amp; #,         <span class="hljs-type"><span class="hljs-type">ID</span></span> dataTx.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key == toBase58String(transferTx.sender.bytes) &amp;&amp; sigVerify(dataTx.bodyBytes, dataTx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], transferTx.senderPublicKey) &amp;&amp; #,         (units == transferTx.amount) &amp;&amp; #,     - (transferTx.assetId == optionsAsset) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } &amp;&amp; size(dataTx.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, dataTx.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) &amp;&amp; height &gt; expirationStart &amp;&amp; height &lt;= expirationEnd <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> order : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #,         let correctAssetPair = order.assetPair.amountAsset == amountAsset &amp;&amp; order.assetPair.priceAsset == priceAsset let correctPrice = order.price == sellPrice # -   let d = transactionById(order.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> d{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> dataTx : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let buyOrderSender = dataTx.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key toBase58String(order.sender.bytes) == buyOrderSender &amp;&amp; order.amount == extract(getInteger(dataTx.data, buyOrderSender)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } &amp;&amp; order.sender == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &amp;&amp; correctAssetPair &amp;&amp; correctPrice &amp;&amp; height &gt; expirationStart &amp;&amp; height &lt;= expirationEnd <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <b>Smart Account Futures</b> <br><br>  Im Gegensatz zu einer Option sind Futures (Futures-Kontrakte) kein Recht, sondern die Verpflichtung des K√§ufers, einen Verm√∂genswert zu einem bestimmten Zeitpunkt in der Zukunft zu einem festen Preis zu kaufen. <br><br>  Im Allgemeinen √§hnelt die Implementierung der Futures der Implementierung einer Option.  Hier fungiert ein Smart Asset als Futures. <br><br>  Sie m√ºssen auch sicherstellen, dass sowohl der K√§ufer als auch der Verk√§ufer die Bestellung unterschreiben.  Futures ist eine Verpflichtung, die in jedem Fall erf√ºllt werden muss.  Dies bedeutet, dass jeder Netzwerkteilnehmer, wenn ein Verk√§ufer oder ein Teilnehmer seine Verpflichtungen ablehnt, eine Transaktion senden und so Futures ausf√ºhren kann. <br><br>  Das Smart Asset Script steuert alle TransferTransaction- und ExchangeTransaction-Asset-Futures und genehmigt sie nur, wenn das kaufende Mitglied eine Bestellung f√ºr den zuk√ºnftigen Kauf von Asset-Futures vom Exchange-Mitglied erstellt hat. <br><br>  Diese Bestellung muss g√ºltig sein und die Bedingungen erf√ºllen, unter denen die Futures ausgegeben werden.  Um eine Bestellung zu √ºberpr√ºfen, k√∂nnen Sie alle Felder zusammen mit der Byte-Darstellung der unterschriebenen Bestellung in den Status des K√§uferkontos eingeben und dann von au√üen validieren. <br><br>  Derzeit enth√§lt RIDE keine native Funktion zum Parsen von Transaktionsbytes, sondern alle f√ºr die Implementierung erforderlichen Tools.  Daher k√∂nnen Entwickler versuchen, diese Funktion selbst zu implementieren. <br><br>  <b>Multi-Signed Account / Escrow</b> <br><br>  Ein Konto mit einer Mehrfachsignatur erm√∂glicht es mehreren Benutzern, Assets gemeinsam zu verwalten (Transaktionen mit Assets k√∂nnen beispielsweise nur m√∂glich sein, wenn drei von vier Benutzern Signaturen haben).  Um Konten mit Mehrfachsignatur in der RIDE-Sprache zu erstellen, k√∂nnen wir Transaktionsnachweise verwenden. <br><br>  Ein Konto mit einer Mehrfachsignatur kann auch f√ºr ein Treuhandkonto verwendet werden, auf dem das Geld gespeichert wird, bis die Vertragsparteien ihren Verpflichtungen nachkommen. <br><br><pre> <code class="scala hljs">let alicePubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpM</span></span>M' let bobPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VD</span></span>F' let cooperPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5c</span></span>D' #,     let aliceSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], alicePubKey)) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let bobSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>], bobPubKey)) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let cooperSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>], cooperPubKey)) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> #        aliceSigned + bobSigned + cooperSigned &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  <b>Token-Managed Registry (TCR)</b> <br><br>  Auf vielen Blockchain-Plattformen besteht das Problem toxischer Verm√∂genswerte.  Beispielsweise kann jede Adresse, die eine Provision gezahlt hat, ein Asset auf Waves erstellen. <br><br>  Die von Token-Inhabern generierte Token Curated Registry (TCR) hilft bei der L√∂sung des Problems des Schutzes von Benutzern und der Blockchain vor toxischen Assets. <br><br>  Um f√ºr das Hinzuf√ºgen eines bestimmten Tokens zur Liste zu stimmen, setzt der Inhaber seinen Einsatz von Token an der Gesamtzahl der ausgegebenen Token.  Ein Token wird in die Registrierung aufgenommen, wenn die meisten Inhaber daf√ºr gestimmt haben. <br><br>  In unserem Beispiel erlauben wir dem Benutzer, das Token der Liste zur Pr√ºfung (w√§hrend des "Herausforderungszeitraums") durch den Schl√ºssel des Status "Schl√ºssel = Asset-Name" hinzuzuf√ºgen, nur wenn der aktuelle Wert count = 0 ist. <br><br>  Au√üerdem muss der Benutzer in der Brieftasche einen Kontostand ungleich Null f√ºr dieses Token haben.  Dann folgt der Abstimmungszeitraum, in dem der Benutzer f√ºr jedes Asset in seiner Brieftasche eine Stimme abgeben kann, jedoch nur einmal, was eine Bewertung von 1 bis 10 ergibt. Die Stimmen der Benutzer werden durch Schl√ºssel der Form Benutzeradresse + Asset-ID dargestellt. <br><br><pre> <code class="scala hljs">let asset = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let addingStartHeight = <span class="hljs-number"><span class="hljs-number">1000</span></span> let votingStartHeight = <span class="hljs-number"><span class="hljs-number">2000</span></span> let votingEndHeight = <span class="hljs-number"><span class="hljs-number">3000</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) #     let address = addressFromPublicKey(tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(height &gt; addingStartHeight) then( <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(height &lt; votingStartHeight) then( #adding #,        let hasTokens = assetBalance(address, asset) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> size(t.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> #,        &amp;&amp; !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(asset))) #,   -    <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; extract(getInteger(t.data, toBase58String(asset))) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; hasTokens ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(height &lt; votingEndHeight) then ( #voting #          let currentAmount = extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(asset))) let newAmount = extract(getInteger(t.data, toBase58String(asset))) let betString = toBase58String(address.bytes) + toBase58String(asset) #,          let noBetBefore = !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, betString)) let isBetCorrect = extract(getInteger(t.data, betString)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; extract(getInteger(t.data, betString)) &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span> #,       let hasTokens = assetBalance(address, asset) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> #    size(t.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(asset))) &amp;&amp; newAmount == currentAmount + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; noBetBefore &amp;&amp; isBetCorrect &amp;&amp; hasTokens ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> ) &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <b>Abonnementgeb√ºhr</b> <br><br>  In diesem Beispiel wird die Verwendung von Smart Accounts in Betracht gezogen, um regelm√§√üige Zahlungen f√ºr ein Produkt oder eine Dienstleistung in festgelegten Intervallen zu leisten - eine ‚Äûmonatliche Geb√ºhr‚Äú. <br>  Wenn ein Benutzer ein Smart-Konto (durch Transaktionsnachweise) mit einer ID TransferTransaction mit dem erforderlichen √úberweisungsbetrag bereitstellt, kann er {Schl√ºssel: Adresse, Wert: <b>Wahr</b> } in den Kontostatus schreiben. <br><br>  Dies bedeutet, dass der Benutzer das Abonnement f√ºr das Produkt oder die Dienstleistung best√§tigt.  Wenn das Abonnement abl√§uft, kann jeder Netzwerkbenutzer den entsprechenden Schl√ºssel im Status auf <b>false setzen</b> . <br><br><pre> <code class="scala hljs">let subscriptionPeriod = <span class="hljs-number"><span class="hljs-number">44000</span></span> let signature = tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>] let pk = tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let requiredAmount = <span class="hljs-number"><span class="hljs-number">100000</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #    let lastPaymentHeight = extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key + <span class="hljs-string"><span class="hljs-string">"_lastPayment"</span></span>)) size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].value == <span class="hljs-string"><span class="hljs-string">"false"</span></span> &amp;&amp; lastPaymentHeight + subscriptionPeriod &lt; height || ( let address = d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key # -  <span class="hljs-type"><span class="hljs-type">ID</span></span>,    let ttx = transactionById(d.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>]) size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].value == <span class="hljs-string"><span class="hljs-string">"true"</span></span> &amp;&amp; d.data[<span class="hljs-number"><span class="hljs-number">1</span></span>].key == address + <span class="hljs-string"><span class="hljs-string">"_lastPayment"</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> ttx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; d.data[<span class="hljs-number"><span class="hljs-number">1</span></span>].value == transactionHeightById(purchase.id) &amp;&amp; toBase58String(purchase.sender.bytes) == address &amp;&amp; purchase.amount == requiredAmount &amp;&amp; purchase.recipient == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> #,   waves &amp;&amp; !isDefined(purchase.assetId) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <b>Abstimmung</b> <br><br>  Intelligente Konten k√∂nnen verwendet werden, um Abstimmungen in der Blockchain zu implementieren.  Ein Beispiel w√§re eine Abstimmung f√ºr den besten Botschafterbericht im Rahmen des Botschafterprogramms.  Der Kontostatus wird als Plattform zum Aufzeichnen von Stimmen f√ºr die eine oder andere Option verwendet. <br><br>  In diesem Beispiel ist die Abstimmung nur f√ºr diejenigen zul√§ssig, die spezielle Abstimmungsmarken gekauft haben.  Der Teilnehmer sendet im Voraus eine DataTransaction mit einem Paar von (Schl√ºssel, Wert) = (purchaseTransactionId, buyTransactionId).  Das Festlegen eines anderen Werts f√ºr diesen Schl√ºssel ist nicht zul√§ssig.  Mit Ihrer Adresse und Abstimmungsoption k√∂nnen Sie DataEntry nur einmal installieren.  Abstimmungen sind nur w√§hrend des festgelegten Zeitraums m√∂glich. <br><br><pre> <code class="scala hljs">let asset = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let address = addressFromPublicKey(tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) let votingStartHeight = <span class="hljs-number"><span class="hljs-number">2000</span></span> let votingEndHeight = <span class="hljs-number"><span class="hljs-number">3000</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; (height &gt; votingStartHeight &amp;&amp; height &lt; votingEndHeight) &amp;&amp; #,      sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &amp;&amp; #,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key == toBase58String(address.bytes)) then ( #       let purchaseTx = transactionById(t.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let correctSender = purchase.sender == t.sender let correctAsset = purchase.assetId == asset let correctPrice = purchase.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == t.id correctSender &amp;&amp; correctAsset &amp;&amp; correctPrice &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> size(t.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, t.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <b>Wechsel</b> <br><br>  Ein Wechsel ist eine schriftliche Verpflichtung, nach der eine Partei der anderen Partei zum Zeitpunkt des Antrags oder zu einem festgelegten Zeitpunkt einen festen Betrag zahlen muss. <br><br>  In unserem Beispiel wird ein Smart Account verwendet, dessen Ablaufdatum dem Zahlungsdatum der Rechnung entspricht. <br><br><pre> <code class="scala hljs">let expiration = <span class="hljs-number"><span class="hljs-number">100000</span></span> let amount = <span class="hljs-number"><span class="hljs-number">10</span></span> let asset = base58<span class="hljs-symbol"><span class="hljs-symbol">'9jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let <span class="hljs-type"><span class="hljs-type">Bob</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3NBVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8') let <span class="hljs-type"><span class="hljs-type">Alice</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3PNX6XwMeEXaaP1rf5MCk8weYeF7z2vJZB</span></span>g') <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; (t.assetId == asset)&amp;&amp; (t.amount == amount)&amp;&amp; (t.sender == <span class="hljs-type"><span class="hljs-type">Bob</span></span>)&amp;&amp; (t.recipient == <span class="hljs-type"><span class="hljs-type">Alice</span></span>)&amp;&amp; (sigVerify(t.bodyBytes, t.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], t.senderPublicKey))&amp;&amp; (height &gt;= expiration) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <b>Kaution</b> <br><br>  Einzahlung - Platzierung von Geldern bei einer Bank unter bestimmten Bedingungen (Laufzeit, Prozentsatz). <br>  In unserem Beispiel erf√ºllt ein Smart Account die Funktion einer Bank.  Nach einer bestimmten Anzahl von Bl√∂cken, die der Laufzeit der Einzahlung entspricht, kann der Benutzer sein Geld mit einem Prozentsatz zur√ºckgeben.  Das Skript legt die H√∂he des Blocks fest (finalHeight), wonach der Benutzer Geld vom Konto abheben kann. <br><br>  heightUnit - Die Anzahl der Bl√∂cke in einer Zeiteinheit (z. B. Monat, Jahr usw.).  Zuerst suchen wir nach einem Eintrag mit einem Paar (Schl√ºssel, Wert) = (initialTransferTransaction, futureDataTransaction).  Anschlie√üend muss der Benutzer TransferTransaction mit den korrekten Informationen √ºber den Betrag der Einzahlung und die f√ºr den Zeitraum der Einzahlung aufgelaufenen Zinsen senden.  Diese Informationen werden mit der urspr√ºnglichen TransferTransaction verglichen, die im aktuellen TransferTransaction-Proof enthalten ist.  DepositDivisor ist die Zahl, die umgekehrt zum Anteil der Einzahlung ist (wenn die Einzahlung mit 10% akzeptiert wird, betr√§gt der Anteil der Einzahlung 0,1 und DepositDevisor = 1 / 0,1 = 10). <br><br><pre> <code class="scala hljs">let depositDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> let heightUnit = <span class="hljs-number"><span class="hljs-number">1000</span></span> let finalHeight = <span class="hljs-number"><span class="hljs-number">100000</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; #    <span class="hljs-type"><span class="hljs-type">ID</span></span>     let depositHeight = extract(transactionHeightById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #   let purchaseTx = transactionById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> deposit : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let correctSender = deposit.sender == e.sender #,        +  let correctAmount = deposit.amount + deposit.amount / depositDivisor * (height - depositHeight) / heightUnit == e.amount let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(deposit.id))) == e.id correctSender &amp;&amp; correctProof &amp;&amp; correctAmount <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } &amp;&amp; finalHeight &lt;= height <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre><br>  Im dritten und letzten Artikel dieser Reihe werden wir uns mit weiteren Optionen f√ºr die Verwendung intelligenter Assets befassen, einschlie√ülich des Einfrierens und Einschr√§nkens von Transaktionen f√ºr bestimmte Adressen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443836/">https://habr.com/ru/post/de443836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443824/index.html">5 Gr√ºnde, auf den 3D-Druck von Metallprodukten umzusteigen</a></li>
<li><a href="../de443826/index.html">Veralterung von Unterrichtsmaterialien verhindern</a></li>
<li><a href="../de443828/index.html">Die Urspr√ºnge der Startup-Kultur: Wie die fr√ºhen Erfolgsgeschichten den modernen Zustand der Tech-Industrie pr√§gten</a></li>
<li><a href="../de443830/index.html">Tesla stellte das neue Modell Y vor - Details, Fotos von der Pr√§sentation und Eindr√ºcke der Probefahrt</a></li>
<li><a href="../de443834/index.html">Runet um die Jahrtausendwende: Woran erinnern Sie sich?</a></li>
<li><a href="../de443838/index.html">Erstellen Sie automatisch Konten aus AD in der Zimbra Collaboration Suite</a></li>
<li><a href="../de443840/index.html">Univention Corporate Server (UCS) - Installation eines einfachen und bequemen LDAP-Servers mit einem Webpanel und dessen Verbindung mit Nextcloud</a></li>
<li><a href="../de443842/index.html">Sind wir agil oder agil?</a></li>
<li><a href="../de443844/index.html">OpenSSL Strategic Architecture</a></li>
<li><a href="../de443846/index.html">Zugriff auf den Linux-Server mit dem Python Telegram-Bot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>