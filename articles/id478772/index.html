<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•Œ â†•ï¸ ğŸ˜¯ Tekstur konvolusional ğŸ¤š ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸš•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Memperbarui tekstur sendiri 
 Ketika dimungkinkan untuk memparalelkan simulasi atau memberikan tugas, biasanya yang terbaik adalah menjalankannya dala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tekstur konvolusional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478772/"><h2>  Memperbarui tekstur sendiri </h2><br>  Ketika dimungkinkan untuk memparalelkan simulasi atau memberikan tugas, biasanya yang terbaik adalah menjalankannya dalam GPU.  Pada artikel ini, saya akan menjelaskan teknik yang menggunakan fakta ini untuk membuat trik visual yang mengesankan dengan overhead kinerja rendah.  Semua efek yang akan saya tunjukkan diimplementasikan menggunakan tekstur yang, ketika diperbarui, " <em>render yourself</em> ";  tekstur diperbarui ketika bingkai baru diberikan, dan keadaan tekstur berikutnya sepenuhnya tergantung pada keadaan sebelumnya.  Pada tekstur ini, Anda dapat menggambar, menyebabkan perubahan tertentu, dan tekstur itu sendiri, secara langsung atau tidak langsung, dapat digunakan untuk membuat animasi yang menarik.  Saya menyebutnya <em>tekstur konvolusional</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/756/a1a/005/756a1a0051471cbe895a8883d89efadd.jpg"></div><br>  <i>Gambar 1: konvolusi buffering ganda</i> <br><br>  Sebelum melanjutkan, kita perlu menyelesaikan satu masalah: tekstur tidak dapat dibaca dan ditulis pada saat yang sama, API grafik seperti OpenGL dan DirectX tidak mengizinkan ini.  Karena keadaan tekstur selanjutnya tergantung pada yang sebelumnya, kita perlu mengatasi keterbatasan ini.  Saya perlu membaca dari tekstur yang berbeda, bukan dari yang saya tulis. <br><br>  Solusinya adalah <em>buffering ganda</em> .  Gambar 1 menunjukkan cara kerjanya: pada kenyataannya, alih-alih satu tekstur, ada dua, tetapi satu ditulis ke dan satu dibaca dari yang lain.  Tekstur yang sedang ditulis disebut <em>buffer belakang</em> , dan tekstur yang diberikan disebut <em>buffer depan</em> .  Karena tes konvolusional adalah "ditulis untuk dirinya sendiri," buffer sekunder di setiap frame menulis ke buffer primer, dan kemudian primer diberikan atau digunakan untuk rendering.  Dalam bingkai berikutnya, peran berubah dan buffer primer sebelumnya digunakan sebagai sumber untuk buffer utama berikutnya. <br><a name="habracut"></a><br>  Dengan merender keadaan sebelumnya ke tekstur lilitan baru menggunakan fragmen shader (atau <em>pixel shader</em> ) memberikan efek dan animasi yang menarik.  Shader menentukan bagaimana kondisi berubah.  Kode sumber untuk semua contoh dari artikel (dan juga yang lain) dapat ditemukan di <a href="https://github.com/jobtalle/ConvolutionalTextures">repositori di GitHub</a> . <br><br><h2>  Contoh aplikasi sederhana </h2><br>  Untuk mendemonstrasikan teknik ini, saya memilih simulasi yang terkenal di mana, ketika memperbarui, keadaan sepenuhnya tergantung pada keadaan sebelumnya: <em>permainan Conway "Life"</em> .  Simulasi ini dilakukan dalam kotak kotak, masing-masing sel yang hidup atau mati.  Aturan untuk status sel berikut sederhana: <br><br><ul><li>  Jika sel hidup memiliki kurang dari dua tetangga, tetapi menjadi mati. </li><li>  Jika sel hidup memiliki dua atau tiga tetangga yang hidup, ia tetap hidup. </li><li>  Jika sel hidup memiliki lebih dari tiga tetangga yang hidup, maka ia menjadi mati. </li><li>  Jika sel mati memiliki tiga tetangga yang hidup, itu menjadi hidup. </li></ul><br>  Untuk mengimplementasikan permainan ini sebagai tekstur konvolusional, saya menafsirkan tekstur sebagai kisi-kisi permainan, dan shader merender berdasarkan aturan di atas.  Pixel transparan adalah sel mati, dan piksel putih buram adalah sel hidup.  Implementasi interaktif ditunjukkan di bawah ini.  Untuk mengakses GPU, saya menggunakan <a href=""><em>myr.js</em></a> , yang membutuhkan <em>WebGL 2</em> .  Sebagian besar browser modern (misalnya, Chrome dan Firefox) dapat bekerja dengannya, tetapi jika demo tidak berfungsi, maka kemungkinan besar browser tidak mendukungnya.  Gunakan mouse (atau layar sentuh) [dalam artikel asli] untuk menggambar sel-sel hidup pada tekstur. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SQ3EKUPm8FY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Kode shader fragmen (dalam GLSL, karena saya menggunakan WebGL untuk rendering) ditunjukkan di bawah ini.  Pertama, saya menerapkan fungsi <code>get</code> , yang memungkinkan saya membaca piksel dari offset tertentu dari yang sekarang.  Variabel <code>pixelSize</code> adalah vektor 2D standar yang mengandung offset UV dari setiap piksel, dan fungsi <code>get</code> menggunakannya untuk membaca sel tetangga.  Kemudian fungsi <code>main</code> menentukan warna sel baru berdasarkan keadaan saat ini ( <code>live</code> ) dan jumlah tetangga yang hidup. <br><br><pre> <code class="cpp hljs">uniform sampler2D source; uniform lowp vec2 pixelSize; in mediump vec2 uv; layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out lowp vec4 color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(texture(source, uv + pixelSize * vec2(dx, dy)).r); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> live = get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbors = get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; (neighbors == <span class="hljs-number"><span class="hljs-number">2</span></span> || neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>)) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Tekstur konvolusional sederhana lainnya adalah <em>permainan dengan pasir yang jatuh</em> , di mana pengguna dapat melemparkan pasir berwarna-warni ke TKP, yang jatuh dan membentuk gunung.  Meskipun implementasinya sedikit lebih rumit, aturannya lebih sederhana: <br><br><ul><li>  Jika tidak ada pasir di bawah butiran pasir, maka ia jatuh satu piksel ke bawah. </li><li>  Jika ada pasir di bawah butiran pasir, tetapi bisa meluncur ke bawah 45 derajat ke kiri atau ke kanan, maka ia akan melakukannya. </li></ul><br>  Manajemen dalam contoh ini sama dengan di game "Life".  Karena di bawah aturan seperti itu, pasir dapat jatuh pada kecepatan hanya satu piksel per bingkai untuk sedikit mempercepat proses, tekstur per bingkai diperbarui tiga kali.  Kode sumber aplikasi ada di <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/sand.html">sini</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MV10ScILiAY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Satu langkah ke depan </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Saluran</b> </td><td>  <b>Aplikasi</b> </td></tr><tr><td>  Merah </td><td>  Tinggi gelombang </td></tr><tr><td>  Hijau </td><td>  Kecepatan gelombang </td></tr><tr><td>  Biru </td><td>  <i>Tidak digunakan</i> </td></tr><tr><td>  Alfa </td><td>  <i>Tidak digunakan</i> </td></tr></tbody></table></div><br>  <i>Gambar 2: Gelombang Pixel.</i> <br><br>  Contoh di atas menggunakan tekstur konvolusional secara langsung;  isinya dirender ke layar sebagaimana adanya.  Jika Anda mengartikan gambar hanya sebagai piksel, maka batas penggunaan teknik ini sangat terbatas, tetapi berkat peralatan modern mereka dapat diperluas.  Alih-alih menghitung piksel sebagai warna, saya akan menafsirkannya sedikit berbeda, yang dapat digunakan untuk membuat animasi dari tekstur lain atau model 3D. <br><br>  Pertama, saya akan menafsirkan tekstur convolutional sebagai peta ketinggian.  Tekstur akan mensimulasikan <em>gelombang</em> dan <em>getaran</em> pada bidang air, dan hasilnya akan digunakan untuk membuat refleksi dan gelombang teduh.  Kami tidak lagi diharuskan membaca tekstur sebagai gambar, sehingga kami dapat menggunakan pikselnya untuk menyimpan informasi apa pun.  Dalam kasus water shader, saya akan menyimpan tinggi gelombang di saluran merah, dan pulsa gelombang di saluran hijau, seperti yang ditunjukkan pada Gambar 2. Saluran biru dan alfa belum digunakan.  Gelombang dibuat dengan menggambar bintik-bintik merah pada tekstur konvolusional. <br><br>  Saya tidak akan mempertimbangkan metodologi untuk memperbarui peta ketinggian, yang saya pinjam dari situs web <em>Hugo Elias</em> , yang tampaknya telah menghilang dari Internet.  Dia juga belajar tentang algoritma ini dari penulis yang tidak dikenal dan mengimplementasikannya dalam C untuk dieksekusi di CPU.  Kode sumber untuk aplikasi di bawah ini ada di <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/water.html">sini</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/h8GjEGMV8AE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Di sini saya menggunakan peta ketinggian hanya untuk mengimbangi tekstur dan menambahkan bayangan, tetapi dalam dimensi ketiga, aplikasi yang jauh lebih menarik dapat diimplementasikan.  Ketika tekstur konvolusional ditafsirkan oleh shader verteks, bidang datar dibagi dapat didistorsi untuk membuat gelombang tiga dimensi.  Anda dapat menerapkan naungan dan pencahayaan biasa ke bentuk yang dihasilkan. <br><br>  Perlu dicatat bahwa piksel dalam tekstur konvolusional dari contoh yang ditunjukkan di atas terkadang menyimpan nilai yang sangat kecil yang tidak boleh hilang karena kesalahan pembulatan.  Oleh karena itu, saluran warna tekstur ini harus memiliki resolusi yang lebih tinggi, dan bukan standar 8 bit.  Dalam contoh ini, saya meningkatkan ukuran setiap saluran warna menjadi 16 bit, yang memberikan hasil yang cukup akurat.  Jika Anda tidak menyimpan piksel, Anda sering perlu meningkatkan akurasi tekstur.  Untungnya, API grafik modern mendukung fitur ini. <br><br><h2>  Kami menggunakan semua saluran </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Saluran</b> </td><td>  <b>Aplikasi</b> </td></tr><tr><td>  Merah </td><td>  X offset </td></tr><tr><td>  Hijau </td><td>  Y offset </td></tr><tr><td>  Biru </td><td>  Kecepatan X </td></tr><tr><td>  Alfa </td><td>  Y offset </td></tr></tbody></table></div><br>  <i>Gambar 3: Rumput pixel.</i> <br><br>  Dalam contoh air, hanya saluran merah dan hijau yang digunakan, tetapi dalam contoh berikutnya, kami akan menerapkan keempatnya.  Bidang dengan rumput (atau pohon) disimulasikan, yang dapat dipindahkan menggunakan kursor.  Gambar 3 menunjukkan data apa yang disimpan dalam piksel.  Offset disimpan di saluran merah dan hijau, dan kecepatan disimpan di saluran biru dan alfa.  Kecepatan ini diperbarui untuk bergeser ke posisi istirahat dengan gerakan gelombang yang secara bertahap memudar. <br><br>  Dalam contoh dengan air, membuat gelombang cukup sederhana: bintik-bintik dapat digambarkan pada tekstur, dan alpha blending memberikan bentuk yang halus.  Anda dapat dengan mudah membuat beberapa tempat yang tumpang tindih.  Dalam contoh ini, semuanya lebih rumit karena saluran alfa sudah digunakan.  Kami tidak dapat menggambar tempat dengan nilai alfa 1 di tengah dan 0 dari tepi, karena ini akan memberi rumput impuls yang tidak perlu (karena impuls vertikal disimpan di saluran alpha).  Dalam hal ini, shader terpisah ditulis untuk menggambarkan efek pada tekstur konvolusional.  Shader ini memastikan bahwa alpha blending tidak menghasilkan efek yang tidak terduga. <br><br>  Kode sumber aplikasi dapat ditemukan di <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/grass.html">sini</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oBqQL7HViLE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Rumput dibuat dalam 2D, tetapi efeknya akan bekerja di lingkungan 3D.  Alih-alih perpindahan piksel, simpul digeser, yang juga lebih cepat.  Juga, dengan bantuan puncak, efek lain dapat direalisasikan: kekuatan cabang yang berbeda - rumput menekuk dengan mudah dengan sedikit angin, dan pohon yang kuat berfluktuasi hanya selama badai. <br><br>  Meskipun ada banyak algoritma dan bayangan untuk menciptakan efek angin dan perpindahan vegetasi, pendekatan ini memiliki keuntungan serius: menggambar efek pada tekstur konvolusional adalah proses yang sangat murah.  Jika efeknya diterapkan dalam permainan, maka pergerakan vegetasi dapat ditentukan oleh ratusan pengaruh berbeda.  Tidak hanya karakter utama, tetapi juga semua benda, hewan, dan gerakan dapat mempengaruhi dunia dengan mengorbankan biaya yang tidak signifikan. <br><br><h2>  Kasing dan kekurangan penggunaan lainnya </h2><br>  Anda dapat membuat banyak aplikasi teknologi lainnya, misalnya: <br><br><ul><li>  Menggunakan tekstur konvolusional, Anda dapat mensimulasikan kecepatan angin.  Pada teksturnya, Anda bisa menggambar rintangan yang membuat udara mengelilinginya.  Partikel (hujan, salju, dan daun) dapat menggunakan tekstur ini untuk terbang di sekitar rintangan. </li><li>  Anda dapat mensimulasikan penyebaran asap atau api. </li><li>  Teksturnya bisa menyandikan ketebalan lapisan salju atau pasir.  Jejak dan interaksi lainnya dengan layer dapat membuat penyok dan cetakan pada layer. </li></ul><br>  Saat menggunakan metode ini, ada kesulitan dan keterbatasan: <br><br><ul><li>  Sulit untuk menyesuaikan animasi dengan mengubah frame rate.  Misalnya, dalam aplikasi dengan pasir jatuh, butiran pasir jatuh pada kecepatan konstan - satu piksel per pembaruan.  Solusi yang mungkin adalah memperbarui tekstur konvolusional dengan frekuensi konstan, mirip dengan cara kerja sebagian besar mesin fisik;  mesin fisika berjalan pada frekuensi konstan, dan hasilnya diinterpolasi. </li><li>  Mentransfer data ke GPU adalah proses yang cepat dan mudah, namun mendapatkan kembali data tidak mudah.  Ini berarti bahwa sebagian besar efek yang dihasilkan oleh teknik ini searah;  mereka ditransfer ke GPU, dan GPU melakukan tugasnya tanpa intervensi dan umpan balik lebih lanjut.  Jika saya ingin menanamkan panjang gelombang dari contoh air dalam perhitungan fisik (misalnya, sehingga kapal akan terombang-ambing bersama dengan ombak), maka saya akan membutuhkan nilai dari tekstur konvolusional.  Mengambil data tekstur dari GPU adalah proses yang sangat lambat yang tidak perlu dilakukan secara real time.  Solusi untuk masalah ini dapat berupa penerapan dua simulasi: satu dengan resolusi tinggi untuk grafik air sebagai tekstur convolutional, yang lain dengan resolusi rendah dalam CPU untuk fisika air.  Jika algoritmenya sama, maka perbedaan mungkin cukup dapat diterima. </li></ul><br>  Demo dalam artikel ini dapat lebih dioptimalkan.  Dalam contoh rumput, Anda dapat menggunakan tekstur dengan resolusi jauh lebih rendah tanpa cacat nyata;  ini akan banyak membantu dalam adegan besar.  Pengoptimalan lain: Anda dapat menggunakan kecepatan refresh yang lebih rendah, misalnya, di setiap frame keempat, atau seperempat per frame (karena teknik ini tidak menyebabkan masalah dengan pembaruan tersegmentasi).  Untuk mempertahankan frame rate yang halus, kondisi konvolusional sebelumnya dan saat ini dapat diinterpolasi. <br><br>  Karena tekstur konvolusional menggunakan buffer ganda internal, Anda dapat menggunakan kedua tekstur pada saat yang sama untuk rendering.  Buffer primer adalah keadaan saat ini, dan yang kedua adalah yang sebelumnya.  Ini dapat berguna untuk menginterpolasi tekstur dari waktu ke waktu atau untuk menghitung turunan untuk nilai tekstur. <br><br><h2>  Kesimpulan </h2><br>  GPU, terutama dalam program 2D, sering menganggur.  Meskipun tampaknya hanya dapat digunakan dalam rendering adegan 3D yang kompleks, teknik yang ditunjukkan dalam artikel ini menunjukkan setidaknya satu cara lain untuk menggunakan kekuatan GPU.  Dengan menggunakan kapabilitas GPU yang dikembangkan, Anda dapat menerapkan efek dan animasi yang menarik yang biasanya terlalu mahal untuk CPU. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478772/">https://habr.com/ru/post/id478772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478752/index.html">Sejarah Sistem Kontrol Versi</a></li>
<li><a href="../id478758/index.html">Panduan tag UTM yang luar biasa: cara mencari tahu dari mana pengguna berasal</a></li>
<li><a href="../id478760/index.html">"Nol" neraka dan bagaimana keluar dari situ</a></li>
<li><a href="../id478764/index.html">Kesalahan JavaScript: memperbaiki, memproses, memperbaiki</a></li>
<li><a href="../id478766/index.html">Kustomisasi pemetaan pengendali Spring MVC</a></li>
<li><a href="../id478774/index.html">Suasana Tahun Baru dari Arduino dan tongkat</a></li>
<li><a href="../id478788/index.html">Di kerajaan tertentu, tidak dalam kondisi "melonjak". Laporan Yandex</a></li>
<li><a href="../id478790/index.html">Julia dan semantik distribusi</a></li>
<li><a href="../id478796/index.html">Sarjana di AS: Cara Tidak Konvensional ke Sekolah Menengah Atas</a></li>
<li><a href="../id478798/index.html">Graphene, yang masih belum bisa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>