<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚰 🧜 ⬜️ Raspberry Pi + CentOS = نقطة اتصال Wi-Fi (أو موجه التوت في قبعة حمراء) 📠 👨🏼‍🚒 🍠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="لدى الإنترنت ثروة من المعلومات حول إنشاء نقاط وصول Wi-Fi تعتمد على جهاز كمبيوتر Raspberry أحادي اللوحة. كقاعدة عامة ، فإنه يعني استخدام نظام التشغيل ا...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Raspberry Pi + CentOS = نقطة اتصال Wi-Fi (أو موجه التوت في قبعة حمراء)</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458994/" style=";text-align:right;direction:rtl"> لدى الإنترنت ثروة من المعلومات حول إنشاء نقاط وصول Wi-Fi تعتمد على جهاز كمبيوتر Raspberry أحادي اللوحة.  كقاعدة عامة ، فإنه يعني استخدام نظام التشغيل الأصلي لـ Raspberry - Raspbian. <br><br>  لكوني متمسكًا بالأنظمة المعتمدة على RPM ، لم أستطع تجاوز هذه المعجزة الصغيرة ولا أجرب CentOS المفضلة لدي على ذلك. <br><br>  توفر هذه المقالة إرشادات حول إنشاء جهاز توجيه Wi-Fi 5 جيجاهرتز / AC من Raspberry Pi 3 Model B + استنادًا إلى نظام التشغيل CentOS.  سيكون هناك العديد من الحيل القياسية ، ولكن غير معروفة ، وكمكافأة - رسم للاتصال بأجهزة Wi-Fi إضافية "التوت" ، مما يتيح لها العمل في وقت واحد في عدة أوضاع (2.4 + 5GHz). <br><br><img src="https://habrastorage.org/webt/mp/yb/fz/mpybfz6gzojqkaftnuljhpzx5da.png" alt="صورة"><br>  <sub><i>(مزيج من الصور من حرية الوصول)</i></sub> <br><a name="habracut"></a><br>  نلاحظ على الفور أن بعض السرعات الكونية لن تعمل.  أضغط 100 ميغابت بحد أقصى من "التوت" الخاص بي على الهواء ، وهذا يغطي سرعة مزود الإنترنت الخاص بي.  لماذا نحتاج إلى مثل هذا التيار المتردد البطيء ، حتى لو كان من الناحية النظرية N يمكنك الحصول على نصف غيغا بايت؟  إذا طرحت هذا السؤال ، فانتقل إلى المتجر للحصول على جهاز توجيه حقيقي به ثماني هوائيات خارجية. <br><br><h1 style=";text-align:right;direction:rtl">  0. ما هو المطلوب </h1><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  في الواقع ، "منتج التوت" من العيار نفسه: Pi 3 Model B + (لتحقيق سرعات وقنوات بسرعة 5 جيجاهرتز المطلوبة) ؛ <br></li><li style=";text-align:right;direction:rtl">  microSD الصلبة&gt; = 4GB ؛ <br></li><li style=";text-align:right;direction:rtl">  محطة عمل Linux مع قارئ / قارئ microSD ؛ <br></li><li style=";text-align:right;direction:rtl">  وجود مهارات كافية في لينكس ، والمادة هي المهوس المعدة ؛ <br></li><li style=";text-align:right;direction:rtl">  اتصال شبكة سلكية (eth0) بين Raspberry و Linux ، خادم DHCP يعمل على الشبكة المحلية ، والوصول إلى الإنترنت من كلا الجهازين. <br></li></ul><br>  تعليق قصير على النقطة الأخيرة.  "ما الذي جاء أولاً ، بيضة أو ..." كيفية صنع جهاز توجيه Wi-Fi في غياب أي معدات الوصول إلى الإنترنت؟  دعنا نترك هذا التمرين الترفيهي خارج نطاق المقالة ونفترض ببساطة أن توت العليق متصل بالشبكة المحلية عن طريق الأسلاك ولديه اتصال بالإنترنت.  في هذه الحالة ، لسنا بحاجة إلى تلفزيون إضافي ومعالج لإعداد التوت. <br><br><h1 style=";text-align:right;direction:rtl">  1. تثبيت CentOS </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">صفحة المشروع الرئيسية</a> <br><br>  في وقت كتابة هذا التقرير ، كانت نسخة العمل من CentOS على الجهاز 32 بت.  في مكان ما في شبكة الويب العالمية الواسعة ، صادفت آراء حول تدهور أداء أنظمة التشغيل هذه على بنية ARM 64 بت بقدر 20٪.  سأترك هذه النقطة دون تعليق. <br><br>  على نظام Linux ، قم بتنزيل الحد الأدنى من الصور باستخدام " <b>-RaspberryPI-</b> " kernel واكتبها على microSD: <br><br><pre style=";text-align:right;direction:rtl"><code class="plaintext hljs"># xzcat CentOS-Userland-7-armv7hl-RaspberryPI-Minimal-1810-sda.raw.xz | \ dd of=/dev/mmcblk0 bs=4M # sync</code> </pre> <br>  قبل استخدام الصورة ، احذف قسم SWAP منه ، وقم بتوسيع الجذر إلى وحدة التخزين المتوفرة بأكملها والتخلص من SELinux.  الخوارزمية بسيطة: قم بعمل نسخة من الجذر على Linux ، وحذف جميع الأقسام من microSD باستثناء الأول (/ boot) ، وقم بإنشاء جذر جديد وإرجاع محتوياته من النسخة. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">مثال على الإجراءات الضرورية (إخراج وحدة التحكم القاسية)</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># mount /dev/mmcblk0p3 /mnt # cd /mnt # tar cfz ~/pi.tgz . --no-selinux # cd # umount /mnt</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># parted /dev/mmcblk0 (parted) unit s (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 2 1370112s 2369535s 999424s primary linux-swap(v1) 3 2369536s 5298175s 2928640s primary ext4 5298176s 31116287s 25818112s Free Space (parted) rm 3 (parted) rm 2 (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 1370112s 31116287s 29746176s Free Space (parted) mkpart Partition type? primary/extended? primary File system type? [ext2]? ext4 Start? 1370112s End? 31116287s (parted) set Partition number? 2 Flag to Invert? lba New state? on/[off]? off (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 2 1370112s 31116287s 29746176s primary ext4 (parted) quit</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># mkfs.ext4 /dev/mmcblk0p2 mke2fs 1.44.6 (5-Mar-2019) /dev/mmcblk0p2 contains a swap file system labelled '_swap' Proceed anyway? (y,N) y Discarding device blocks: done Creating filesystem with 3718272 4k blocks and 930240 inodes Filesystem UUID: 6a1a0694-8196-4724-a58d-edde1f189b31 Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208 Allocating group tables: done Writing inode tables: done Creating journal (16384 blocks): done Writing superblocks and filesystem accounting information: done # mount /dev/mmcblk0p2 /mnt # tar xfz ~/pi.tgz -C /mnt --no-selinux</code> </pre><br>  بعد تفريغ محتويات قسم الجذر ، حان الوقت لإجراء بعض التغييرات عليه. <br><br>  تعطيل SELinux في <b>/ كزاز الرضع / الخ / selinux / التكوين</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">SELINUX=disabled</code> </pre><br>  نقوم بتحرير <b>/ mnt / etc / fstab</b> ، مع ترك اثنين فقط من إدخالات القسم فيه: boot (/ boot ، دون تغيير) والجذر (قم بتغيير قيمة UUID ، والتي يمكن العثور عليها عن طريق فحص إخراج الأمر blkid على Linux): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">UUID=6a1a0694-8196-4724-a58d-edde1f189b31 / ext4 defaults,noatime 0 0 UUID=6938-F4F2 /boot vfat defaults,noatime 0 0</code> </pre><br>  أخيرًا ، نقوم بتغيير معلمات تمهيد kernel: تحديد الموقع الجديد لقسم الجذر ، وتعطيل إخراج معلومات تصحيح الأخطاء (اختياريًا) وحظر kernel من تعيين عناوين IPv6 على واجهات الشبكة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cd # umount /mnt # mount /dev/mmcblk0p1 /mnt</code> </pre><br>  <b>نأتي</b> محتويات <b>/mnt/cmdline.txt</b> إلى النموذج التالي (سطر واحد بدون الواصلة): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait quiet ipv6.disable_ipv6=1</code> </pre><br>  الانتهاء: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cd # umount /mnt # sync</code> </pre><br></div></div><br>  نحن نعيد ترتيب microSD في "Malinka" ، ونشغلها ونحصل على وصول إلى الشبكة عبر ssh (root / centos). <br><br><h1 style=";text-align:right;direction:rtl">  2. تكوين CentOS </h1><br>  الحركات الثلاث الأولى التي لا تتزعزع: <b>passwd</b> ، <b>yum -y update</b> ، <b>إعادة التشغيل</b> . <br><br>  نعطي إدارة الشبكة إلى <b>networkd</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># yum install systemd-networkd # systemctl enable systemd-networkd # systemctl disable NetworkManager # chkconfig network off</code> </pre><br>  قم <b>بإنشاء</b> الملف (إلى جانب الدلائل) <b>/etc/systemd/network/eth0.network</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[Match] Name=eth0 [Network] DHCP=ipv4</code> </pre><br>  نعيد تشغيل "التوت" ونحصل مجددًا على وصول الشبكة إليه عبر ssh (يمكن أن يتغير عنوان IP).  لاحظ أن <b>/etc/resolv.conf</b> ، الذي تم إنشاؤه مسبقًا بواسطة Network Manager ، يُستخدم.  لذلك ، في حالة وجود مشاكل مع حل ، تحرير محتوياته.  لن نستخدم <b>systemd حلها</b> . <br><br>  نزيل "الزائدة عن الحاجة" ، نصلح ونزيد من سرعة تحميل نظام التشغيل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># systemctl set-default multi-user.target # yum remove GeoIP Network* aic* alsa* cloud-utils-growpart \ cronie* dhc* firewal* initscripts iwl* kexec* logrotate \ postfix rsyslog selinux-pol* teamd wpa_supplicant</code> </pre><br>  من يحتاج إلى <b>cron</b> والذي لا يهضم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مؤقتات systemd</a> المدمجة ، يمكنه تثبيت المفقود.  <b>/ var / log -</b> وابحث من خلال <b>journalctl</b> .  إذا كنت بحاجة إلى سجل سجل (بشكل افتراضي ، يتم تخزين المعلومات فقط من لحظة بدء تشغيل النظام): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># mkdir /var/log/journal # systemd-tmpfiles --create --prefix /var/log/journal # systemctl restart systemd-journald # vi /etc/systemd/journald.conf</code> </pre><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">تعطيل استخدام IPv6 بواسطة الخدمات الأساسية (إذا لزم الأمر)</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  <b>/ etc / ssh / sshd_config</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">AddressFamily inet</code> </pre><br>  <b>/ etc / sysconfig / chronyd</b> : <br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">OPTIONS="-4"</code> </pre><br></div></div><br>  أهمية الوقت على "التوت" هو شيء مهم.  نظرًا لأن "خارج الصندوق" لا تتوفر لديه القدرة على حفظ الحالة الحالية للساعة عند إعادة التشغيل ، فأنت بحاجة إلى التزامن.  <b>لقد</b> تم بالفعل تثبيت البرنامج الخفي الجيد والسريع لهذا - <b>chrony</b> - ويبدأ تلقائيًا.  يمكنك تغيير خوادم NTP إلى التالي. <br><br>  <b>/etc/chrony.conf</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">server 0.ru.pool.ntp.org iburst server 1.ru.pool.ntp.org iburst server 2.ru.pool.ntp.org iburst server 3.ru.pool.ntp.org iburst</code> </pre><br>  سوف نستخدم <b>الخدعة</b> لتعيين المنطقة الزمنية.  نظرًا لأن هدفنا هو إنشاء جهاز توجيه Wi-Fi يعمل بترددات 5 جيجا هرتز ، فإننا نستعد مقدمًا لمفاجآت <b>المنظم</b> : <br><blockquote style=";text-align:right;direction:rtl">  # yum معلومات crda <br>  ملخص: البرنامج الخفي للامتثال التنظيمي للشبكات اللاسلكية 802.11 <br></blockquote><br>  هذا التصميم الحاقد ، الذي يركز ، من بين أمور أخرى ، على المنطقة الزمنية ، "يحظر" استخدام (في روسيا) للترددات والقنوات 5 جيجاهرتز بأرقام "كبيرة".  الحيلة هي تعيين المنطقة الزمنية دون استخدام أسماء البر الرئيسي / المدينة ، أي بدلاً من: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># timedatectl set-timezone Europe/Moscow</code> </pre><br>  دنت: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># timedatectl set-timezone Etc/GMT-3</code> </pre><br>  واللمسات الأخيرة في تصفيفة الشعر للنظام: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># hostnamectl set-hostname router</code> </pre><br>  <b>/root/.bash_profile</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">. . . # User specific environment and startup programs export PROMPT_COMMAND="echo -n $(($(&lt;/sys/class/thermal/thermal_zone0/temp) / 1000))\'C\ " export LANG=en_US.UTF-8 export PATH=$PATH:$HOME/bin</code> </pre><br><h1 style=";text-align:right;direction:rtl">  3. إضافات CentOS </h1><br>  كل ما قيل أعلاه يمكن اعتباره إرشادات كاملة لتثبيت "الفانيليا" CentOS على Raspberry Pi.  يجب أن يكون لديك جهاز كمبيوتر يتم إعادة تشغيله في أقل من 10 ثوانٍ ، ويستخدم أقل من 15 ميغابايت من ذاكرة الوصول العشوائي و 1.5 غيغابايت من microSD (في الواقع أقل من 1 غيغابايت بسبب عدم اكتمال / التمهيد ، لكننا سنكون صادقين في النهاية): <br><img src="https://habrastorage.org/webt/mu/0g/cf/mu0gcfyiokq0x_2dysrb1ieh0ke.jpeg"><br><br><img src="https://habrastorage.org/webt/xx/l3/_g/xxl3_gukovfw0zawwvvy8ua0dtw.jpeg"><br><br><img src="https://habrastorage.org/webt/wt/yc/-9/wtyc-9erdcdx-rvqnnjite7c9ru.jpeg"><br><br>  لتثبيت برنامج نقطة وصول Wi-Fi على هذا النظام ، ستحتاج إلى زيادة طفيفة في قدرات توزيع CentOS القياسي.  بادئ ذي بدء ، "ضخ" برنامج التشغيل (البرامج الثابتة) لمحول Wi-Fi المدمج.  الصفحة الرئيسية للمشروع تقول: <br><blockquote style=";text-align:right;direction:rtl">  واي فاي على التوت 3B و 3 B + <br><br>  لا يُسمح بتوزيع ملفات البرامج الثابتة Raspberry PI 3B / 3B + بواسطة CentOS Project.  يمكنك استخدام المقالات التالية لفهم المشكلة والحصول على البرامج الثابتة وإعداد wifi. <br></blockquote><br>  ما لا يستطيع مشروع CentOS القيام به ليس ممنوعًا منا للاستخدام الشخصي.  نحن نستبدل البرامج الثابتة للتوزيع في Wi-Fi في CentOS بالبرنامج المقابل من مطوري Broadcom (نفس النقط الثنائية المكروهة ...).  هذا ، على وجه الخصوص ، سوف يسمح باستخدام AC في وضع نقطة الوصول. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">ترقية البرامج الثابتة لشبكة Wi-Fi</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  اكتشفنا طراز الجهاز وإصدار البرامج الثابتة الحالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># journalctl | grep $(basename $(readlink /sys/class/net/wlan0/device/driver)) Jan 01 04:00:03 router kernel: brcmfmac: F1 signature read @0x18000000=0x15264345 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_fw_map_chip_to_name: using brcm/brcmfmac43455-sdio.bin for chip 0x004345(17221) rev 0x000006 Jan 01 04:00:03 router kernel: usbcore: registered new interface driver brcmfmac Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: Firmware version = wl0: Mar 1 2015 07:29:38 version 7.45.18 (r538002) FWID 01-6a2c8ad4 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: CLM version = API: 12.2 Data: 7.14.8 Compiler: 1.24.9 ClmImport: 1.24.9 Creation: 2014-09-02 03:05:33 Inc Data: 7.17.1 Inc Compiler: 1.26.11 Inc ClmImport: 1.26.11 Creation: 2015-03-01 07:22:34</code> </pre><br>  نرى أن إصدار البرنامج الثابت هو 7.45.18 بتاريخ 03/01/2015 ، ونتذكر مجموعة الأرقام التالية: <b>43455</b> (brcmfmac43455-sdio.bin). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قم بتنزيل الصورة الحالية لـ Raspbian</a> .  يمكن للأشخاص كسول كتابة الصورة إلى microSD ومن هناك التقاط الملفات مع البرامج الثابتة.  ويمكنك تحميل القسم الجذر للصورة في Linux ونسخ القسم الذي تحتاجه من هناك: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># wget https://downloads.raspberrypi.org/raspbian_lite_latest # unzip -p raspbian_lite_latest &gt; raspbian.img # fdisk -l raspbian.img Disk raspbian.img: 2 GiB, 2197815296 bytes, 4292608 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x17869b7d Device Boot Start End Sectors Size Id Type raspbian.img1 8192 532480 524289 256M c W95 FAT32 (LBA) raspbian.img2 540672 4292607 3751936 1.8G 83 Linux # mount -t ext4 -o loop,offset=$((540672 * 512)) raspbian.img /mnt # cp -fv /mnt/lib/firmware/brcm/*43455* ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.bin' -&gt; ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.clm_blob' -&gt; ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.txt' -&gt; ... # umount /mnt</code> </pre><br>  يجب نسخ ملفات البرامج الثابتة الناتجة لمحول Wi-Fi باستبدال "التوت" في الدليل <b>/ usr / lib / firmware / brcm /</b> <br><br>  نعيد تشغيل جهاز التوجيه في المستقبل ونبتسم بدلاً من ذلك: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># journalctl | grep $(basename $(readlink /sys/class/net/wlan0/device/driver)) Jan 01 04:00:03 router kernel: brcmfmac: F1 signature read @0x18000000=0x15264345 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_fw_map_chip_to_name: using brcm/brcmfmac43455-sdio.bin for chip 0x004345(17221) rev 0x000006 Jan 01 04:00:03 router kernel: usbcore: registered new interface driver brcmfmac Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: Firmware version = wl0: Feb 27 2018 03:15:32 version 7.45.154 (r684107 CY) FWID 01-4fbe0b04 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: CLM version = API: 12.2 Data: 9.10.105 Compiler: 1.29.4 ClmImport: 1.36.3 Creation: 2018-03-09 18:56:28</code> </pre><br>  الإصدار: 7.45.154 من 02.27.2018. <br></div></div><br>  وبالطبع EPEL: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cat &gt; /etc/yum.repos.d/epel.repo &lt;&lt; EOF [epel] name=Epel rebuild for armhfp baseurl=https://armv7.dev.centos.org/repodir/epel-pass-1/ enabled=1 gpgcheck=0 EOF # yum clean all # rm -rfv /var/cache/yum # yum update</code> </pre><br><h1 style=";text-align:right;direction:rtl">  4. تكوين الشبكة والتحديات القادمة </h1><br>  كما اتفقنا أعلاه ، يتم توصيل "Malinka" بواسطة "سلك" إلى الشبكة المحلية.  لنفترض أن مزودًا يوفر الوصول إلى الإنترنت بنفس الطريقة تمامًا: يتم إصدار عنوان على شبكة عامة بشكل حيوي بواسطة خادم DHCP (يمكن ربطه بـ MAC).  في هذه الحالة ، بعد الإعداد النهائي لـ "التوت" ، يكفي "توصيل" كبل الموفر به وكل شيء جاهز.  إذن باستخدام <b>systemd-networkd</b> هو موضوع مقال منفصل ولا يعتبر هنا. <br><br>  تعد واجهة (واجهات) Wi-Fi في Raspberry شبكة محلية ، ومحول Ethernet المدمج (eth0) خارجي.  نحن نرقم الشبكة المحلية بشكل ثابت ، على سبيل المثال: 192.168.0.0/24.  عنوان مالينكا: 192.168.0.1.  في شبكة خارجية (الإنترنت) سيعمل خادم DHCP. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مشكلة توحيد التسمية</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">والمبرمج الغواتيمالي الشهير</a> هما مشكلتان تنتظران كل من يشارك في تكوين واجهات وخدمات الشبكة في توزيعات systemd. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">الفوضى الموازية (الانحدار الغنائي)</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  جعل Lennart Pottering برنامجه <b>systemd</b> جيدًا.  يقوم هذا النظام بإطلاق برامج أخرى بسرعة لدرجة أنه ، بعد أن لم يتح له الوقت الكافي للوصول إلى رشدهم من صافرة الحكم ، يتعثر ويسقط في البداية دون أن يبدأ مساره الخاص بالعقبات. <br><br>  ولكن على محمل الجد ، فإن الموازنة القوية للعمليات التي تم إطلاقها في بداية systemd-OS هي نوع من "جسر الحمير" لبرامج تشغيل LSB التسلسلية المختبرة.  لحسن الحظ ، تبين أن عملية "الفوضى الموازية" هذه بسيطة ، على الرغم من أن الحقيقة ليست واضحة دائمًا. <br></div></div><br>  نخلق واجهات جسر افتراضية بأسماء ثابتة: <b>lan</b> و <b>wan</b> .  سنقوم بربط محول (مهايئات) Wi-Fi بالمحول الأول ، و eth0 من "التوت" بالآخر. <br><br>  <b>/etc/systemd/network/lan.netdev</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[NetDev] Name=lan Kind=bridge</code> </pre><br>  <b>/etc/systemd/network/lan.network</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[Match] Name=lan [Network] Address=192.168.0.1/24 IPForward=yes</code> </pre><br>  <b>/etc/systemd/network/wan.netdev</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[NetDev] Name=wan Kind=bridge #MACAddress=xx:xx:xx:xx:xx:xx</code> </pre><br>  <b>/etc/systemd/network/wan.network</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[Match] Name=wan [Network] DHCP=ipv4 IPForward=yes</code> </pre><br>  <b>IPForward = yes</b> يلغي الحاجة إلى التلميح إلى النواة عبر sysctl لتمكين التوجيه. <br>  <b>MACAddress =</b> uncomment وتغيير إذا لزم الأمر. <br><br>  أولاً ، نحن نربط eth0.  تذكر "مشكلة التوحيد" واستخدم فقط عنوان MAC الخاص بهذه الواجهة ، والذي يمكنك اكتشافه ، على سبيل المثال ، مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cat /sys/class/net/eth0/address</code> </pre><br>  إنشاء <b>/etc/systemd/network/eth.network</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[Match] MACAddress=b8:27:eb:xx:xx:xx [Network] Bridge=wan</code> </pre><br>  احذف ملف التكوين eth0 السابق ، وأعد تشغيل "التوت" واحصل على وصول إلى الشبكة (من المرجح أن يتغير عنوان IP): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># rm -fv /etc/systemd/network/eth0.network # reboot</code> </pre><br><h1 style=";text-align:right;direction:rtl">  5. DNSMASQ </h1><br>  لتصنيع نقاط وصول Wi-Fi ، لم يتم اختراع شيء أفضل من الزوجين <b>الحلوين</b> من <b>dnsmasq</b> + <b>hostapd</b> .  في رأيي <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">إذا نسيت أي شخص ، ثم ...</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">hostapd</a> هو الشيء الذي يدير محولات Wi-Fi (على وجه الخصوص ، سيحتاج الأمر إلى ربطها بالشبكة الافتراضية <b>لتوت</b> العليق) ، فهو يرخص ويسجل العملاء اللاسلكيين. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">dnsmasq</a> - تكوين مكدس شبكة العملاء: يوفر عناوين IP وخوادم DNS وبوابة افتراضية وما شابه ذلك. <br></div></div><br>  نبدأ مع dnsmasq: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># yum install dnsmasq</code> </pre><br>  قالب <b>/etc/resolv.conf</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">nameserver 1.1.1.1 nameserver 1.0.0.1 nameserver 8.8.8.8 nameserver 8.8.4.4 nameserver 77.88.8.8 nameserver 77.88.8.1 domain router.local search router.local</code> </pre><br>  تحريره لترضيك. <br><br>  أضيق <b>الحدود</b> / <b>الخ</b> / <b>dnsmasq.conf</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">domain-needed bogus-priv interface=lan bind-dynamic expand-hosts domain=# dhcp-range=192.168.0.100,192.168.0.199,255.255.255.0,24h conf-dir=/etc/dnsmasq.d</code> </pre><br>  "السحر" هنا هو المعلمة <b>المرتبطة الديناميكية</b> ، والتي تخبر dnsmasq daemon أن تنتظر <b>الواجهة = lan</b> لتظهر في النظام ، وليس للإغماء من أي هجوم بالوحدة الفخر بعد البداية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># systemctl enable dnsmasq # systemctl start dnsmasq; journalctl -f</code> </pre><br><h1 style=";text-align:right;direction:rtl">  6. HOSTAPD </h1><br>  أخيرًا ، تكوينات hostapd السحرية.  ليس لدي أدنى شك في أن شخصًا ما يقرأ هذه المقالة بحثًا عن هذه الخطوط العزيزة على وجه التحديد. <br><br>  قبل تثبيت hostapd ، تحتاج إلى التعامل مع "مشكلة التوحيد".  يمكن لمحول Wi-Fi المدمج في wlan0 تغيير اسمه بسهولة إلى wlan1 عند توصيل أجهزة Wi-Fi USB إضافية.  لذلك ، سوف نقوم بإصلاح أسماء الواجهات بالطريقة التالية: سنأتي بأسماء فريدة من المحولات (اللاسلكية) ونربطها بعناوين MAC. <br><br>  لمحول Wi-Fi المدمج ، والذي لا يزال wlan0: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cat /sys/class/net/wlan0/address b8:27:eb:xx:xx:xx</code> </pre><br>  إنشاء <b>/etc/systemd/network/wl0.link</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[Match] MACAddress=b8:27:eb:xx:xx:xx [Link] Name=wl0</code> </pre><br>  الآن سنكون متأكدين من أن <b>wl0</b> هو شبكة Wi-Fi المدمجة.  نحن إعادة تشغيل "التوت" لرؤية هذا. <br><br>  تعيين: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># yum install hostapd wireless-tools</code> </pre><br>  ملف التكوين <b>/etc/hostapd/hostapd.conf</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">ssid=rpi wpa_passphrase=1234567890 channel=36 country_code=US interface=wl0 bridge=lan driver=nl80211 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP macaddr_acl=0 hw_mode=a wmm_enabled=1 # N ieee80211n=1 require_ht=1 ht_capab=[MAX-AMSDU-3839][HT40+][SHORT-GI-20][SHORT-GI-40][DSSS_CCK-40] # AC ieee80211ac=1 require_vht=1 ieee80211d=0 ieee80211h=0 vht_capab=[MAX-AMSDU-3839][SHORT-GI-80] vht_oper_chwidth=1 vht_oper_centr_freq_seg0_idx=42</code> </pre><br>  دون أن ننسى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">GKChP</a> لمدة دقيقة ، فإننا نغير المعلمات التي نحتاجها <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ونبحث</a> يدويًا عن الأداء: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># hostapd /etc/hostapd/hostapd.conf</code> </pre><br>  ستبدأ hostapd بشكل تفاعلي ، وترجمة حالتها إلى وحدة التحكم.  في حالة عدم وجود أخطاء ، يمكن بالفعل توصيل العملاء الذين يدعمون وضع AC بنقطة الوصول.  لإيقاف hostapd - Ctrl-C. <br><br>  يبقى لتشمل hostapd في بدء تشغيل النظام.  إذا كنت تتصرف بشكل قياسي (systemctl enable hostapd) ، فبعد إعادة التشغيل التالية ، يمكنك الحصول على "شيطان في دم" شيطان مع تشخيص " <b>واجهة wl0 غير موجودة</b> ".  نتيجة "الفوضى المتوازية" ، انتهى hostapd بشكل أسرع من العثور على محول لاسلكي. <br><br>  الإنترنت مليء بالأدوية: من المهلة القسرية قبل بدء البرنامج الخفي (لبضع دقائق) ، إلى الخفي الآخر الذي يراقب ظهور الواجهة و (إعادة) يبدأ لوحة المضيف.  الحلول تعمل تمامًا ، لكنها قبيحة بشكل رهيب.  نحن ندعو إلى مساعدة النظام العظيم من خلال "أهدافه" و " <s>المهام</s> " "التبعيات". <br><br>  انسخ ملف خدمة التوزيع إلى <b>/etc/systemd/system/hostapd.service</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cp -fv /usr/lib/systemd/system/hostapd.service /etc/systemd/system</code> </pre><br>  وإحضار محتوياته إلى النموذج التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[Unit] Description=Hostapd IEEE 802.11 AP, IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator After=sys-subsystem-net-devices-wl0.device BindsTo=sys-subsystem-net-devices-wl0.device [Service] Type=forking PIDFile=/run/hostapd.pid ExecStart=/usr/sbin/hostapd /etc/hostapd/hostapd.conf -P /run/hostapd.pid -B [Install] WantedBy=sys-subsystem-net-devices-wl0.device</code> </pre><br>  يتمثل سحر ملف الخدمة المحدّث في ربط hostapd ديناميكيًا بهدف جديد - واجهة wl0.  عندما تظهر الواجهة ، يبدأ البرنامج الخفي ؛ وعندما يختفي ، يتوقف.  كل شيء على الإنترنت - دون إعادة تشغيل النظام.  لا سيما هذه التقنية ستكون مفيدة عند الاتصال بمحول USB واي فاي "التوت". <br><br>  الآن يمكنك: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># systemctl enable hostapd # reboot</code> </pre><br><h1 style=";text-align:right;direction:rtl">  7. IPTABLES </h1><br>  "شتا ؟؟؟"  © نعم ، نعم!  لا <b>systemd</b> .  لا يجمع حديثًا (في شكل <b>firewalld</b> ) ، وهو ما يفعل الشيء نفسه في النهاية. <br><br>  نحن نستخدم <b>iptables</b> القديمة الجيدة ، التي ستقوم خدماتها بعد بدايتها بتحميل قواعد الشبكة على النواة وإغلاقها بهدوء دون أن تبقى مقيمة وبدون استهلاك الموارد.  يحتوي Systemd على <b>IPMasquerade =</b> أنيق ، لكننا <b>سنستمر في</b> تكليف iptables بترجمة العنوان (NAT) وجدار الحماية. <br><br>  تعيين: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># yum install iptables-services # systemctl enable iptables ip6tables</code> </pre><br>  أفضل تخزين تكوين iptables كبرنامج نصي (مثال): <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # Disable IPv6 # ip6tables --flush ip6tables --delete-chain ip6tables --policy INPUT DROP ip6tables --policy FORWARD DROP ip6tables --policy OUTPUT DROP ip6tables-save &gt; /etc/sysconfig/ip6tables systemctl restart ip6tables # # Cleaning # iptables -F iptables -X iptables -t nat -F iptables -t nat -X iptables -t mangle -F iptables -t mangle -X iptables -P INPUT DROP iptables -P OUTPUT ACCEPT iptables -P FORWARD ACCEPT # # Loopback, lan # iptables -A INPUT -i lo -j ACCEPT iptables -A INPUT -i lan -j ACCEPT # # Ping, Established # iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # # NAT # iptables -t nat -A POSTROUTING -o wan -j MASQUERADE # # Saving # iptables-save &gt; /etc/sysconfig/iptables systemctl restart iptables</span></span></code> </pre><br>  ننفذ النص أعلاه ونفقد القدرة على إنشاء روابط ssh سلكية جديدة مع "Malinka".  هذا صحيح ، لقد صنعنا جهاز توجيه Wi-Fi ، حيث يُحظر الوصول إلى "عبر الإنترنت" افتراضيًا - الآن فقط "عبر الهواء".  نقوم بتوصيل كابل مزود إيثرنت وبدء تصفح! <br><br><h1 style=";text-align:right;direction:rtl">  8. المكافأة: + 2.4 جيجا هرتز </h1><br>  عندما قمت بتجميع أول جهاز توجيه لـ Raspberry من الرسم الموضح أعلاه ، اكتشفت في مزرعتي عددًا من الأدوات الذكية ، نظرًا لقيود التصميم الخاصة بها ، لم تتمكن شبكة Wi-Fi من رؤية "التوت" على الإطلاق.  لم تكن عملية إعادة تكوين جهاز التوجيه للعمل في 802.11b / g / n مثل الرياضي ، لأن السرعة القصوى "عبر الأثير" في هذه الحالة لم تتجاوز 40 ميغابت في الثانية ، ويوفر موفر خدمة الإنترنت المفضل لدي 100 (عبر الكابل). <br><br>  في الواقع ، تم بالفعل اختراع حل للمشكلة: واجهة Wi-Fi ثانية تعمل بسرعة 2.4 جيجاهرتز ونقطة وصول ثانية.  في أقرب كشك ، اشتريت ليست الأولى ، ولكن الثانية USB Wi-Fi "صفارة" التي جاءت لي.  تعذب البائع من أسئلة حول الشرائح والتوافق مع Linux ARM-cores وإمكانية العمل في وضع AP (بدأ لأول مرة). <br><br>  نقوم بتكوين "صفارة" عن طريق القياس مع محول Wi-Fi المدمج. <br><br>  أولاً ، قم بإعادة تسميته إلى <b>wl1</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cat /sys/class/net/wlan0/address b0:6e:bf:xx:xx:xx</code> </pre><br>  <b>/etc/systemd/network/wl1.link</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[Match] MACAddress=b0:6e:bf:xx:xx:xx [Link] Name=wl1</code> </pre><br>  سنعهد بإدارة واجهة Wi-Fi الجديدة إلى برنامج خفي hostapd منفصل ، والذي سيبدأ ويتوقف اعتمادًا على وجود "صفارة" محددة بدقة في النظام: wl1. <br><br>  ملف التكوين <b>/etc/hostapd/hostapd2.conf</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">ssid=rpi2 wpa_passphrase=1234567890 #channel=1 #channel=6 channel=11 interface=wl1 bridge=lan driver=nl80211 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP macaddr_acl=0 hw_mode=g wmm_enabled=1 # N ieee80211n=1 require_ht=1 ht_capab=[HT40][SHORT-GI-20][SHORT-GI-40][DSSS_CCK-40]</code> </pre><br>  تعتمد محتويات هذا الملف مباشرة على طراز مهايئ USB Wi-Fi ، وبالتالي فإن نسخة / لصق تافهة يمكن أن تخذلك. <br><br>  انسخ ملف خدمة التوزيع إلى <b>/etc/systemd/system/hostapd2.service</b> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cp -fv /usr/lib/systemd/system/hostapd.service /etc/systemd/system/hostapd2.service</code> </pre><br>  وإحضار محتوياته إلى النموذج التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[Unit] Description=Hostapd IEEE 802.11 AP, IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator After=sys-subsystem-net-devices-wl1.device BindsTo=sys-subsystem-net-devices-wl1.device [Service] Type=forking PIDFile=/run/hostapd2.pid ExecStart=/usr/sbin/hostapd /etc/hostapd/hostapd2.conf -P /run/hostapd2.pid -B [Install] WantedBy=sys-subsystem-net-devices-wl1.device</code> </pre><br>  يبقى تضمين مثيل جديد من hostapd: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># systemctl enable hostapd2</code> </pre><br>  هذا كل شئ!  اسحب الصفارة والتوت نفسه ، وانظر إلى الشبكات اللاسلكية المحيطة. <br><br>  وأخيرًا ، أرغب في التحذير من جودة مهايئ USB Wi-Fi ومورد طاقة التوت.  متصلة "صافرة ساخنة" ، في بعض الأحيان يمكن أن يسبب "تعليق التوت" بسبب مشاكل كهربائية قصيرة الأجل. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar458994/">https://habr.com/ru/post/ar458994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar458984/index.html">كيفية إنشاء التطبيق الأول للتداول في البورصة: 3 خطوات أولية</a></li>
<li><a href="../ar458986/index.html">وصفات PostgreSQL: التحويل من HTML وعناوين URL إلى PDF و PS</a></li>
<li><a href="../ar458988/index.html">التركيب ، أو ما تحتاج إلى معرفته لتصبح فنان السطح. الجزء 4. النماذج ، والقواعد الطبيعية ، واكتساح</a></li>
<li><a href="../ar458990/index.html">وقف متحمس مع التعليقات في التعليمات البرمجية</a></li>
<li><a href="../ar458992/index.html">الانتباه للدمى وتنفيذها في كراس</a></li>
<li><a href="../ar458996/index.html">Inyerface المستخدم - كيف لا تعذب المستخدم</a></li>
<li><a href="../ar459000/index.html">كيف حاولت تحسين Halo 2 ، لكن دمرته تقريبًا</a></li>
<li><a href="../ar459002/index.html">كيفية تكوين HTTPS - سوف يساعدك SSL Configuration Generator</a></li>
<li><a href="../ar459004/index.html">خوارزمية التشفير الجندب: فقط عن المجمع</a></li>
<li><a href="../ar459012/index.html">إنشاء تطبيق ل Bitrix24 من الصفر</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>