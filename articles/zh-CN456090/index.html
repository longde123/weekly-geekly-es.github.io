<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏻 🤱🏻 🗼 Unity中的单元测试简介 💇🏽 🐥 💬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您是否对Unity中的单元测试工作感到好奇？ 不确定总体上是什么单元测试？ 如果您对这些问题的回答是肯定的，那么本教程将对您有所帮助。 从中您将学到有关单元测试的以下内容： 



- 这是什么 
- 它的好处 
- 优缺点 
- 使用Test Runner在Unity中的工作方式 
- 如何编写和...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity中的单元测试简介</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456090/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b63/9d9/71f/b639d971f3e2a10105d91bb3c94fdbb1.jpg" alt="图片"></div><br> 您是否对Unity中的单元测试工作感到好奇？ 不确定总体上是什么单元测试？ 如果您对这些问题的回答是肯定的，那么本教程将对您有所帮助。 从中您将学到有关单元测试的以下内容： <br><br><ul><li> 这是什么 </li><li> 它的好处 </li><li> 优缺点 </li><li> 使用Test Runner在Unity中的工作方式 </li><li> 如何编写和执行将要测试的单元测试 </li></ul><br><blockquote>  <em>注意</em> ：本教程假定您熟悉C＃语言和Unity中的开发基础。 如果您不熟悉Unity，请首先<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">查看此引擎上的其他教程</a> 。 </blockquote><h2> 什么是单元测试？ </h2><br> 在深入研究代码之前，重要的是要清楚地了解什么是单元测试。 简而言之，单元测试就是测试...单元。 <br><br>  <em>单元测试</em> （理想情况下）旨在测试单独的代码单元。  “单元”的组成可能会有所不同，但是请务必记住，单元测试必须一次精确地测试一个“元素”。 <br><a name="habracut"></a><br> 需要创建单元测试，以验证特定场景中的一小段逻辑代码是否按预期运行。 在开始编写自己的单元测试之前，这可能很难理解，因此让我们看一个示例： <br><br> 您已经编写了一种允许用户输入名称的方法。 编写该方法时，名称中不允许使用数字，并且名称本身只能包含十个或更少的字符。 您的方法拦截每个键的击键，并将相应的字符添加到<code>name</code>字段： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateNameWithCharacter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">: character</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (!Char.IsLetter(char)) { return; } // 2 if (name.Length &gt; 10) { return; } // 3 name += character; }</span></span></code> </pre> <br> 这是怎么回事： <br><br><ol><li> 如果字符不是字母，则代码会预先存在该函数，并且不会将字符添加到字符串中。 </li><li> 如果名称长度为十个或更多字符，则该代码不允许用户添加其他字符。 </li><li> 如果通过了这两项检查，则代码将在名称的末尾添加一个字符。 </li></ol><br> 可以测试此单元，因为它是所执行工作的“模块”。 单元测试<i>强制执行</i>方法逻辑。 <br><br><h2> 单元测试示例 </h2><br> 我们如何为<code>UpdateNameWithCharacter</code>方法编写单元测试？ <br><br> 在开始实施这些单元测试之前，我们需要仔细考虑这些测试的功能，并为其命名。 <br><br> 看一下下面的单元测试名称示例。 从名称中可以清楚地看出它们进行了检查： <br><br> <code>UpdateNameDoesntAllowCharacterAddingToNameIfNameIsTenOrMoreCharactersInLength</code> <br> <br> <code>UpdateNameAllowsLettersToBeAddedToName</code> <br> <br> <code>UpdateNameDoesntAllowNonLettersToBeAddedToName</code> <br> <br> 从这些测试方法的名称中，我们看到我们确实检查了工作的“单元”是否由<code>UpdateNameWithCharacter</code>方法<code>UpdateNameWithCharacter</code> 。 这些测试名称似乎太长且太详细，但对我们来说却很好。 <br><br> 您编写的每个单元测试都是一组测试的一部分。  <em>测试套件</em>包含与功能逻辑组相关的所有单元测试（例如，“战斗单元测试”）。 如果套件中的任何测试均未通过测试，则整个测试套件将失败。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/1e7/0ed/20d1e70ed7231be0c0cfd5f6f082751c.png"></div><br><h2> 游戏发布 </h2><br> 打开<em>Crashteroids Starter项目</em> （您可以<a href="">从此处</a>下载），然后从<em>Assets / RW / Scenes</em>文件夹中打开<em>Game</em>场景。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/029/6fd/316/0296fd31696c7e75eeea4ec626709277.jpg"></div><br> 单击“ <em>播放”</em>以启动Crashteroids，然后单击“ <em>开始游戏”</em>按钮。 使用键盘上的<em>左右</em>箭头移动飞船。 <br><br> 要发射激光束，请按<em>空格键</em> 。 如果光束撞击小行星，则分数将增加一。 如果小行星与飞船相撞，飞船将爆炸并结束游戏（具有重新开始的能力）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/cea/c40/c2fceac408455035e41f3c9c268ff448.jpg"></div><br> 试着玩一点，并确保小行星与飞船相撞后出现题为游戏结束的文字。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/55f/fa6/0b555ffa69f33fb09fb17204197af889.jpg"></div><br><h2>  Unity Test Runner入门 </h2><br> 现在我们知道了游戏的运行方式，是时候编写单元测试以验证所有功能都可以正常工作了。 因此，如果您（或其他人）决定更新游戏，则可以确保该更新不会破坏以前可用的任何功能。 <br><br> 要编写测试，您首先需要了解Unity Test Runner。  <em>Test Runner</em>可让您运行测试并检查测试是否成功通过。 要打开Unity Test Runner，请选择<em>窗口▸General▸Test Runner</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f48/f31/aa4/f48f31aa4fc16c486b2161c75ba772af.jpg"></div><br> 在新窗口中打开“测试运行器”后，您可以通过单击“测试运行器”窗口并将其<em>拖动</em>到“场景”窗口旁边的位置来简化生活。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/25b/408/e1025b408f785453827a962ce33aff67.gif"></div><br><h2> 准备NUnit和测试文件夹 </h2><br>  Test Runner是Unity提供的单元测试功能，但它使用<em>NUnit</em>框架。 当您开始更认真地使用单元测试时，建议您学习<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NUnit</a>上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wiki</a>以了解更多信息。 本文将讨论您首次需要的所有内容。 <br><br> 要运行测试，我们首先需要创建一个测试文件夹，其中将存储测试类。 <br><br> 在“ <em>项目”</em>窗口中<em>，</em>选择<em>RW</em>文件夹。 查看“ <em>测试运行器”</em>窗口，并确保选择了<em>PlayMode</em> 。 <br><br> 单击名为<em>创建PlayMode测试程序文件夹</em>的按钮。 您将看到一个新文件夹出现在RW文件夹中。 我们对标准名称<em>Tests</em>感到满意，因此您只需按<em>Enter</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f5/be4/df3/5f5be4df386c8f262c4a3c257b55319f.gif"></div><br> 您可能想知道Test Runner中这两个不同的选项卡是什么。 <br><br>  <em>PlayMode</em>选项卡用于在Play模式（实时运行游戏）中进行的测试。  “ <em>EditMode”</em>选项卡上的测试在“播放”模式之外运行，这对于在Inspector中测试诸如自定义行为之类的操作很方便。 <br><br> 在本教程中，我们将介绍PlayMode测试。 但是，当您感到舒适时，可以尝试在EditMode中进行测试。  <em>在本教程中使用Test Runner时，请始终确保选择了PlayMode选项卡</em> 。 <br><br><h2> 测试套件中有什么？ </h2><br> 如上所述，单元测试是一种功能，用于测试一小段特定代码的行为。 由于单元测试是一种方法，要运行它，它必须在类文件中。 <br><br>  Test Runner绕过所有测试类文件并从中执行单元测试。 包含单元测试的类文件称为测试套件。 <br><br> 在测试套件中，我们在逻辑上将测试细分。 我们必须将测试代码分成单独的逻辑集（例如，一组物理测试和一组战斗）。 在本教程中，我们只需要一组测试，是时候创建一个了。 <br><br><h2> 准备测试程序集和测试套件 </h2><br> 选择“ <em>测试”</em>文件夹，然后在“ <em>测试运行器”</em>窗口中，单击“ <em>在当前文件夹中创建测试脚本”</em>按钮。 命名新的<em>TestSuite</em>文件。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/0ab/968/c640ab968dfd79a3c72e2a99bc5daa2c.gif"></div><br> 除了新的C＃文件之外，Unity引擎还创建了另一个名为<em>Tests.asmdef的</em>文件。 这是<em>程序集定义文件</em> ，用于向Unity显示测试文件的依赖项所在的位置。 这是必需的，因为完成的应用程序代码与测试代码分开包含。 <br><br> 如果遇到Unity无法找到测试文件或测试的情况，请确保有一个包含测试套件的程序集定义文件。 下一步是配置它。 <br><br> 为了使测试代码能够访问游戏类，我们将创建一个类代码的程序集，并在“测试”程序集中设置链接。 单击<em>脚本</em>文件夹将其选中。 右键单击该文件夹，然后选择<em>创建▸装配定义</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b8/24c/84a/5b824c84ad6686493c41951751030b8d.jpg"></div><br> 将文件命名为<em>GameAssembly</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/bd6/c96/21bbd6c968426c23ea7839dd9f747355.png"></div><br> 单击“ <em>测试”</em>文件夹，然后单击“ <em>测试</em> ”构建定义文件。 在<em>检查器中，</em>单击“ <em>装配体定义参考”</em>标题下的<em>加号</em>按钮。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/fc3/d13/4befc3d13ea67e5ec94b707d04582a3d.png"></div><br> 您将看到“ <em>缺少参考”</em>字段。 单击该字段旁边的<em>点</em>以打开选择窗口。 选择<em>GameAssembly</em>文件。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/990/57f/72799057fe5ff62ba5c997d5ec2a7563.jpg"></div><br> 您应该在链接部分中看到GameAssembly程序集文件。 单击“ <em>应用”</em>按钮以保存这些更改。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a16/bf5/259/a16bf525984f2f23b819d9b2d0e37a2b.png"></div><br> 如果不执行这些步骤，则将无法在单元测试文件中引用游戏的类文件。 处理完之后，您可以继续执行代码。 <br><br><h2> 我们编写第一个单元测试 </h2><br> 双击<em>TestSuite</em>脚本以在代码编辑器中将其打开。 将所有代码替换为： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.TestTools; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NUnit.Framework; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestSuite</span></span> { }</code> </pre> <br> 我们需要编写哪些测试？ 坦白说，即使在像Crashteroids这样的小游戏中，您也可以编写很多测试来验证所有功能是否正常运行。 在本教程中，我们仅将自己限制在关键领域：碰撞识别和基本游戏机制。 <br><br><blockquote>  <em>注意</em> ：在生产级别编写产品的单元测试时，您应该花足够的时间来考虑需要在代码的所有方面进行测试的所有边界情况。 </blockquote><br> 作为第一个测试，很高兴检查小行星是否真的在向下移动。 如果他们离开船，他们将很难与船相撞！ 将以下方法和私有变量添加到<em>TestSuite</em>脚本中： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Game game; <span class="hljs-comment"><span class="hljs-comment">// 1 [UnityTest] public IEnumerator AsteroidsMoveDown() { // 2 GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;("Prefabs/Game")); game = gameGameObject.GetComponent&lt;Game&gt;(); // 3 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); // 4 float initialYPos = asteroid.transform.position.y; // 5 yield return new WaitForSeconds(0.1f); // 6 Assert.Less(asteroid.transform.position.y, initialYPos); // 7 Object.Destroy(game.gameObject); }</span></span></code> </pre> <br> 只有几行代码，但是它们却做了很多事情。 因此，让我们停下来处理每个部分： <br><br><ol><li> 这是<em>一个属性</em> 。 属性定义特定的编译器行为。 该属性告诉Unity编译器代码是单元测试。 因此，启动测试时它将出现在“测试运行器”中。 </li><li> 创建一个游戏实例。 其他所有内容都嵌入在游戏中，因此当我们创建游戏时，它将包含需要测试的所有内容。 在生产环境中，很可能所有元素都不会位于同一预制件中。 因此，您将需要重新创建场景中所需的所有对象。 </li><li> 在这里，我们创建了一个小行星，以便我们可以监视它是否在移动。  <code>SpawnAsteroid</code>方法返回创建的小行星的实例。  Asteroid组件具有<code>Move</code>方法（如果您好奇运动的工作原理，可以查看<em>RW / Scripts</em>中的<em>Asteroid</em> <em>脚本</em> ）。 </li><li> 为了确保小行星已经向下移动，必须跟踪起始位置。 </li><li> 所有Unity单元测试都是协程，因此您需要添加软收益。 我们还添加了0.1秒的时间步长，以模拟小行星应该向下移动的时间流逝。 如果不需要模拟时间步长，则可以返回null。 </li><li> 这是<em>断言</em>阶段，在该阶段中我们声称小行星的位置小于初始位置（也就是说，它已经向下移动）。 了解断言是单元测试的重要组成部分，并且NUnit提供了各种断言方法。 通过或不通过测试由此行确定。 </li><li> 当然，没有人会因为测试完成后留下的混乱而责骂您，但是其他测试可能会因此而失败。 在单元测试之后清理（删除或重置）代码总是很重要的，这样，当您运行下一个单元测试时，就不会留下任何可能影响该测试的工件。 我们只需删除游戏对象就足够了，因为对于每次测试，我们都会创建一个全新的游戏实例。 </li></ol><br><h2> 通过测试 </h2><br> 好吧，您编写了第一个单元测试，但是您如何知道它是否有效？ 当然，有了Test Runner！ 在“测试运行器”窗口中，用箭头展开所有行。 您应该在列表中看到带有灰色圆圈的<code>AsteroidsMoveDown</code>测试： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/5d4/05a/d4c5d405a1aa5aded204806790a07233.jpg"></div><br> 灰色圆圈表示测试尚未完成。 如果测试已开始并通过，则旁边会显示一个绿色箭头。 如果测试失败，则会在其旁边显示一个红色的X，单击<em>RunAll</em>按钮运行测试。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d45/da5/8c9/d45da58c99e0db679578aabab6e5601b.jpg"></div><br> 这将创建一个临时场景并运行测试。 完成后，您应该看到测试已通过。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/640/16b/19e/64016b19e01a68544a1644b61ffb5c57.jpg"></div><br> 您已经成功编写了第一个单元测试，说明所创建的小行星正在向下移动。 <br><br><blockquote>  <em>注意</em> ：在开始编写自己的单元测试之前，您需要了解要测试的实现。 如果您对正在测试的逻辑如何工作感到好奇，请研究<em>RW / Scripts</em>文件夹中的代码。 </blockquote><br><h2> 使用集成测试 </h2><br> 在深入探讨单元测试的难题之前，是时候告诉您什么是集成测试以及它们与单元测试有何不同。 <br><br>  <em>集成测试</em>是验证代码的“模块”如何协同工作的测试。  “模块”是另一个模糊术语。 一个重要的区别是集成测试必须在实际生产中（即玩家真正玩游戏时）测试软件的操作。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f01/824/6f3/f018246f3658664a77104a1fa1dc045b.png"></div><br> 假设您制作了一款战斗游戏，其中有一名玩家杀死了怪物。 您可以创建一个集成测试，以确保当玩家杀死100个敌人时，成就被打开（“成就”）。 <br><br> 此测试将影响几个代码模块。 它最有可能涉及物理引擎（冲突识别），敌人调度员（跟踪敌人的健康和处理损伤以及传递给其他相关事件）以及跟踪所有触发事件（例如，“怪物被杀死”）的事件跟踪器。 然后，当需要解锁成就时，他可以致电成就经理。 <br><br> 集成测试将模拟玩家杀死100个怪物并检查成就是否已解锁。 它与单元测试有很大的不同，因为它测试可协同工作的大型代码组件。 <br><br> 在本教程中，我们将不学习集成测试，但这应该显示工作单元（以及为什么要对其进行统一测试）与代码模块（以及为什么要对其进行集成测试）之间的区别。 <br><br><h2> 将测试添加到测试套件 </h2><br> 下一次测试将测试飞船与小行星碰撞时游戏的结束。 在代码<em>编辑器中</em>打开<em>TestSuite的情况下</em> ，将以下所示的测试添加到第一个单元测试下并保存文件： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameOverOccursOnAsteroidCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); Game game = gameGameObject.GetComponent&lt;Game&gt;(); GameObject asteroid = game.GetSpawner().SpawnAsteroid(); <span class="hljs-comment"><span class="hljs-comment">//1 asteroid.transform.position = game.GetShip().transform.position; //2 yield return new WaitForSeconds(0.1f); //3 Assert.True(game.isGameOver); Object.Destroy(game.gameObject); }</span></span></code> </pre> <br> 在之前的测试中，我们已经看到了大部分代码，但是有一些区别： <br><br><ol><li> 我们迫使小行星与飞船相撞，从而使小行星明显地具有与飞船相同的位置。 这将造成他们的Hitbox发生碰撞，并导致游戏结束。 如果您好奇此代码的工作方式，请查看Scripts文件夹中的<em>Ship</em> ， <em>Game</em>和<em>Asteroid</em>文件。 </li><li> 物理引擎的碰撞事件触发需要时间步长，因此返回0.1秒的延迟。 </li><li> 该语句为true，并验证Game脚本中的<code>gameOver</code>标志为true。 在游戏操作中，该标志在舰船被摧毁时为真，也就是说，我们进行测试以确保在舰船被摧毁后将其设置为true。 </li></ol><br> 返回到“测试运行器”窗口，您将看到一个新的单元测试出现在这里。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/f52/b28/4a8f52b2875ca90a37b74348435e3da5.jpg"></div><br> 这次我们将运行这个而不是整个测试套件。 单击<em>GameOverOccursOnAsteroidCollision</em> ，然后单击“ <em>运行所选”</em>按钮。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e2/0f5/fbd/7e20f5fbd8b4a8a6ff849fea66c90ed1.jpg"></div><br> 瞧，我们通过了另一项测试。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/966/02f/869/96602f869c59d8218407a7ce2e57df7d.jpg"></div><br><h2> 调整和销毁阶段 </h2><br> 您可能已经注意到，在我们的两个测试中，有重复的代码：创建Game对象的位置和设置Game脚本的链接的位置： <br><br><pre> <code class="cs hljs">GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;();</code> </pre> <br> 您还将注意到在Game对象的销毁中有重复： <br><br><pre> <code class="cs hljs">Object.Destroy(game.gameObject);</code> </pre> <br> 测试时，这种情况经常发生。 当涉及到运行单元测试时，实际上有两个阶段： <em>设置</em>阶段和<em>拆卸</em>阶段。 <br><br>  Setup方法中的所有代码将在单元测试之前（在此集合中）执行，而Tear Down方法中的所有代码将在单元测试之后（在此集合中）执行。 <br><br> 现在是时候通过将设置和拆卸代码移至特殊方法来简化我们的生活。 打开代码编辑器，并在第一个[UnityTest]属性之前，在<em>TestSuite</em>文件的开头添加以下代码： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SetUp</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;(); }</code> </pre> <br>  <code>SetUp</code>属性指示在每次测试<code>SetUp</code>之前都会调用此方法。 <br><br> 然后添加以下方法并保存文件： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TearDown</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Teardown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Object.Destroy(game.gameObject); }</code> </pre> <br>  <code>TearDown</code>属性指示在每次测试<code>TearDown</code>后调用此方法。 <br><br> 准备好设置和销毁代码后，请删除这些方法中存在的代码行，并将其替换为对相应方法的调用。 之后，代码将如下所示： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestSuite</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Game game; [SetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;(); } [TearDown] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Teardown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Object.Destroy(game.gameObject); } [UnityTest] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsteroidsMoveDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject asteroid = game.GetSpawner().SpawnAsteroid(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> initialYPos = asteroid.transform.position.y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1f</span></span></span></span></span><span class="hljs-function">)</span></span>; Assert.Less(asteroid.transform.position.y, initialYPos); } [UnityTest] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameOverOccursOnAsteroidCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = game.GetShip().transform.position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1f</span></span></span></span></span><span class="hljs-function">)</span></span>; Assert.True(game.isGameOver); } }</code> </pre> <br><h2> 测试游戏结束和激光射击 </h2><br> 准备好简化生活的调整和销毁方法之后，我们可以开始添加使用它们的新测试。 下一个测试是验证玩家单击<em>New Game</em>时<em>gameOver bool</em>的值<em>是否为</em> true。 在文件末尾添加这样的测试并保存： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewGameRestartsGame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 game.isGameOver = true; game.NewGame(); //2 Assert.False(game.isGameOver); yield return null; }</span></span></code> </pre> <br> 这对您来说应该已经很熟悉了，但是以下几点值得一提： <br><br><ol><li> 这段代码为<code>gameOver</code>布尔标志为true做好了测试准备。 调用<code>NewGame</code>方法时，必须再次将标志设置为<code>false</code> 。 </li><li> 在这里，我们认为bool <code>isGameOver</code>是<code>false</code> ，在调用新游戏时应该为true。 </li></ol><br> 返回Test Runner，您应该看到有一个新的测试<em>NewGameRestartsGame</em> 。 像我们之前一样运行此测试，您将看到它成功运行： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b63/9d9/71f/b639d971f3e2a10105d91bb3c94fdbb1.jpg"></div><br><h2> 激光束声明 </h2><br> 下一个测试是增加船发射的激光束飞起来的测试（类似于我们编写的第一个单元测试）。 在编辑器中打开<em>TestSuite</em>文件。 添加以下方法并保存文件： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LaserMovesUp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject laser = game.GetShip().SpawnLaser(); // 2 float initialYPos = laser.transform.position.y; yield return new WaitForSeconds(0.1f); // 3 Assert.Greater(laser.transform.position.y, initialYPos); }</span></span></code> </pre> <br> 这是这段代码的作用： <br><br><ol><li> 获取到从船舶发射的激光束的链接。 </li><li> 记录起始位置，以便我们可以验证其是否向上移动。 </li><li> 该陈述与<code>AsteroidsMoveDown</code>单元测试的陈述一致，只是现在我们声称该值更大（即激光器向上移动）。 </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存文件并返回到测试运行器。</font><font style="vertical-align: inherit;">运行</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LaserMovesUp</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试</font><font style="vertical-align: inherit;">并观察其</font><em><font style="vertical-align: inherit;">如何</font></em><font style="vertical-align: inherit;">通过：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/a15/242/2cea152426f82ea491345ead3f0eaa94.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，您应该已经开始了解一切工作原理，因此该添加最后两个测试并完成本教程了。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 验证激光会摧毁小行星 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我们将确保当被击中时，激光会摧毁小行星。</font><font style="vertical-align: inherit;">打开编辑器，将</font><font style="vertical-align: inherit;">以下测试</font><font style="vertical-align: inherit;">添加到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestSuite</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的末尾</font><font style="vertical-align: inherit;">，然后保存文件：</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LaserDestroysAsteroid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = Vector3.zero; GameObject laser = game.GetShip().SpawnLaser(); laser.transform.position = Vector3.zero; yield return new WaitForSeconds(0.1f); // 2 UnityEngine.Assertions.Assert.IsNull(asteroid); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 运作方式如下： </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们创建一个小行星和一个激光束，并将它们分配给相同的位置以触发碰撞。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是具有重要区别的特殊测试。</font><font style="vertical-align: inherit;">看到我们为此测试明确使用了</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityEngine.Assertions</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吗？</font><font style="vertical-align: inherit;">这是因为在Unity是一类特殊</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的空</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从“正常»零类不同。</font><font style="vertical-align: inherit;">NUnit框架语句</font></font><code>Assert.IsNull()</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不适</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于Unity的null检查。</font><font style="vertical-align: inherit;">在Unity中检查null时，必须显式使用UnityEngine.Assertions.Assert，而不是从NUnit声明。</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回测试运行程序并运行新测试。</font><font style="vertical-align: inherit;">您会看到一个绿色的图标，取悦我们。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/80f/1b2/27580f1b206647e0a2fd09c43577ee8f.jpg"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 测试还是不测试-这就是问题所在 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">坚持单元测试的决定不是一个容易的决定，不应轻易掉以轻心。但是，测试的好处值得付出努力。甚至有一个开发方法，所谓的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试驱动开发</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（测试驱动开发，TDD）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在TDD的框架内工作，您在编写应用程序逻辑本身之前先编写测试。首先，创建测试，确保程序未通过测试，然后仅编写旨在通过测试的代码。这可能是一种非常不同的编码方法，但是可以确保以适合测试的方式编写代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在开始下一个项目时，请记住这一点。但是，现在是时候编写您自己的单元测试了，为此您需要一个我们提供给您的游戏。</font></font><br><br><blockquote> <em></em> :    —    ,    .   ,           .    «» ,   ,      .   ,             .        ,        .       ,     ,            . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 测试可能是一笔大投资，因此请考虑在项目中添加单元测试的优点和缺点： </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单元测试的优势 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单元测试具有许多重要的优点，其中包括： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可以确信该方法的行为符合预期。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用作学习代码库的新手的文档（单元测试非常适合教学）。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使您以可测试的方式编写代码。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 允许更快地隔离和修复错误。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 它不允许将来的更新将新的错误添加到旧的工作代码中（它们称为回归错误）。 </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单元测试的缺点 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，您可能没有时间或预算进行单元测试。</font><font style="vertical-align: inherit;">这里是要考虑的缺点：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编写测试可能比代码本身花费更长的时间。 </font></font></li><li>       . </li><li>      . </li><li> ,        . </li><li>         ,    -. </li><li>     (       ),       . </li><li> -    . </li><li> UI  . </li><li>           . </li><li>              . </li></ul><br><h2>  ,       </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在该写最后一个测试了。</font><font style="vertical-align: inherit;">打开代码编辑器，将以下代码添加到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestSuite</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件的末尾</font><font style="vertical-align: inherit;">并保存：</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyedAsteroidRaisesScore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = Vector3.zero; GameObject laser = game.GetShip().SpawnLaser(); laser.transform.position = Vector3.zero; yield return new WaitForSeconds(0.1f); // 2 Assert.AreEqual(game.score, 1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一项重要的测试，可以验证玩家摧毁小行星时得分是否会提高。</font><font style="vertical-align: inherit;">这是由以下内容组成的：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们创建一个小行星和一个激光束，并将它们放在一个位置。</font><font style="vertical-align: inherit;">因此，发生碰撞，触发得分增加。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 声明game.score现在为1（而不是开头的0）。 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保存代码，然后返回“测试运行器”以运行上一个测试，并查看它是否运行了游戏： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/d4c/0ee/e5dd4c0ee4ad72e21a180621c65c11ba.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">太棒了！</font><font style="vertical-align: inherit;">所有测试均通过。</font></font><br><br><h2> 接下来要去哪里？ </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中，我们检查了大量信息。</font><font style="vertical-align: inherit;">如果您想将您的工作与最终项目进行比较，请在</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存档中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行查看，</font><font style="vertical-align: inherit;">本文开头也提供了指向该链接的链接。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本教程中，您学习了什么是单元测试以及如何在Unity中编写它们。</font><font style="vertical-align: inherit;">此外，您编写了六个成功通过代码的单元测试，并熟悉了单元测试的一些优缺点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感到自信？</font><font style="vertical-align: inherit;">然后，您可以编写更多测试。</font><font style="vertical-align: inherit;">检查游戏的类文件，并尝试为代码的其他部分编写单元测试。</font><font style="vertical-align: inherit;">考虑为以下情况添加测试：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 触摸飞船时，每种类型的小行星都将导致游戏结束。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 开始新游戏将重置分数。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 船的左右移动正常。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您想增加对单元测试的了解，那么值得探索</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖项</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">框架</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">实现，</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">以使用模拟对象</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这样可以大大简化测试设置。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另请阅读</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUnit文档，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以了解有关NUnit框架的更多信息。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并随时在论坛上分享您的想法和问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试成功！</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456090/">https://habr.com/ru/post/zh-CN456090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456078/index.html">公司对网络连接的冲突的预测</a></li>
<li><a href="../zh-CN456082/index.html">我们如何制定个性化产品推荐</a></li>
<li><a href="../zh-CN456084/index.html">Kubernetes 1.15：亮点概述</a></li>
<li><a href="../zh-CN456086/index.html">iOS故事板：优缺点分析，最佳做法</a></li>
<li><a href="../zh-CN456088/index.html">大数据分析问题</a></li>
<li><a href="../zh-CN456092/index.html">七个令人不安的迹象表明您依赖天气，即使您不这样认为</a></li>
<li><a href="../zh-CN456094/index.html">我们阅读了数据手册2：STM32上的SPI; STM8上的PWM定时器和中断</a></li>
<li><a href="../zh-CN456096/index.html">极客时间平均读者在云中徘徊时的行为</a></li>
<li><a href="../zh-CN456100/index.html">现在采用新包装-M.2格式的金士顿A400急于上市</a></li>
<li><a href="../zh-CN456102/index.html">易于在C / C ++中进行报告</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>