<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖌️ 💑 👩🏾‍🤝‍👨🏽 Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 2 🚴🏾 👨🏽‍🚒 🧑🏾‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terinspirasi oleh kemenangan parsing pertama dengan deskripsi adegan pulau dari kartun Moana Disney, saya melangkah lebih jauh ke dalam studi pengguna...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417445/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/b62/44e/1c6b6244e438a4f3a7431ba49f089525.jpg" alt="gambar"></div><br>  Terinspirasi oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemenangan</a> parsing <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> dengan deskripsi adegan pulau dari kartun <em>Moana</em> Disney, saya melangkah lebih jauh ke dalam studi penggunaan memori.  Banyak yang masih bisa dilakukan dengan lead time, tetapi saya memutuskan akan bermanfaat untuk menyelidiki dulu situasinya. <br><br>  Saya memulai penyelidikan runtime dengan statistik pbrt bawaan;  pbrt memiliki pengaturan manual untuk alokasi memori yang signifikan untuk melacak penggunaan memori, dan setelah rendering selesai, laporan alokasi memori ditampilkan.  Inilah laporan alokasi memori untuk adegan ini awalnya: <br><br> <code> <br> BVH- 9,01  <br>  1,44  <br> MIP- 2,00  <br>   11,02 </code> <br> <br>  Adapun runtime, statistik bawaan ternyata singkat dan hanya melaporkan alokasi memori untuk objek yang diketahui berukuran 24 GB.  <code>top</code> mengatakan bahwa sebenarnya sekitar 70 GB memori digunakan, yaitu, 45 GB tidak diperhitungkan dalam statistik.  Penyimpangan kecil cukup dapat dimengerti: pengalokasi memori dinamis membutuhkan ruang tambahan untuk mendaftarkan penggunaan sumber daya, beberapa hilang karena fragmentasi, dan sebagainya.  Tapi 45 GB?  Sesuatu yang buruk pasti bersembunyi di sini. <br><a name="habracut"></a><br>  Untuk memahami apa yang kami lewatkan (dan untuk memastikan bahwa kami melacak dengan benar), saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">massif</a> untuk melacak alokasi aktual dari memori dinamis.  Agak lambat, tapi setidaknya itu bekerja dengan baik. <br><br><h2>  Primitif </h2><br>  Hal pertama yang saya temukan ketika melacak massif adalah dua baris kode yang mengalokasikan instance dari kelas dasar <code>Primitive</code> , yang tidak diperhitungkan dalam statistik, dalam memori.  Pengawasan kecil yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cukup mudah untuk diperbaiki</a> .  Setelah itu, kita melihat yang berikut: <br><br> <code>Primitives 24,67 </code> <br> <br>  Ups  Jadi apa itu primitif, dan mengapa semua ingatan ini? <br><br>  pbrt membedakan antara <code>Shape</code> , yaitu geometri murni (bola, segitiga, dll.) dan <code>Primitive</code> , yang merupakan kombinasi dari geometri, material, kadang-kadang fungsi radiasi dan medium yang terlibat di dalam dan di luar permukaan geometri. <br><br>  Ada <a href="">beberapa opsi untuk</a> kelas dasar <code>Primitive</code> : <code>GeometricPrimitive</code> , yang merupakan kasus standar: "vanilla" kombinasi geometri, material, dll., Serta <code>TransformedPrimitive</code> , yang merupakan primitif dengan transformasi yang diterapkan padanya, baik sebagai instance dari objek atau untuk memindahkan primitif dengan transformasi yang berubah seiring waktu.  Ternyata dalam adegan ini kedua jenis ini adalah pemborosan ruang. <br><br><h3>  GeometricPrimitive: 50% Ruang Tambahan </h3><br>  <em>Catatan: beberapa asumsi yang salah dibuat dalam analisis ini;</em>  <em>mereka direvisi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos keempat seri</a> .</em> <br><br>  4,3 GB digunakan pada <code>GeometricPrimitive</code> .  Sangat lucu untuk hidup di dunia di mana 4,3 GB RAM yang digunakan bukan masalah terbesar Anda, tetapi mari kita lihat dari mana kami mendapat 4,3 GB dari <code>GeometricPrimitive</code> .  Berikut adalah bagian-bagian yang relevan dari definisi kelas: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GeometricPrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Material&gt; material; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface; };</code> </pre> <br>  Kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pointer ke vtable</a> , tiga pointer lagi, dan kemudian <code>MediumInterface</code> berisi dua pointer lagi dengan ukuran total 48 byte.  Hanya ada beberapa jerat pemancar cahaya dalam adegan ini, jadi <code>areaLight</code> hampir selalu merupakan pointer nol, dan tidak ada lingkungan yang mempengaruhi adegan, sehingga kedua pointer <code>mediumInterface</code> juga nol.  Jadi, jika kita memiliki implementasi khusus dari kelas <code>Primitive</code> , yang dapat digunakan tanpa adanya fungsi radiasi dan medium, kita akan menghemat hampir setengah ruang disk yang ditempati oleh <code>GeometricPrimitive</code> - dalam kasus kami, sekitar 2 GB. <br><br>  Namun, saya tidak memperbaikinya dan menambahkan implementasi <code>Primitive</code> baru ke pbrt.  Kami berusaha untuk meminimalkan perbedaan antara kode sumber pbrt-v3 pada github dan sistem yang dijelaskan dalam buku saya, karena alasan yang sangat sederhana - menjaga mereka dalam sinkronisasi membuatnya mudah untuk membaca buku dan bekerja dengan kode tersebut.  Dalam hal ini, saya memutuskan bahwa implementasi <code>Primitive</code> sepenuhnya baru, yang tidak pernah disebutkan dalam buku ini, akan terlalu berbeda.  Tetapi perbaikan ini pasti akan muncul di versi baru pbrt. <br><br>  Sebelum melanjutkan, mari kita lakukan tes render: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/b62/44e/1c6b6244e438a4f3a7431ba49f089525.jpg"></div><br>  <i>Pantai dari pulau dari film "Moana" disajikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pbrt-v3</a> dengan resolusi 2048x858 dan 256 sampel per piksel.</i>  <i>Total waktu render pada instance 12-core / 24-thread dari Google Compute Engine dengan frekuensi 2 GHz dengan versi terbaru dari pbrt-v3 adalah 2 jam 25 menit 43 detik.</i> <br><br><h3>  TransformedPrimitive: 95% Wasted Space </h3><br>  Memori yang dialokasikan di bawah 4,3 GB <code>GeometricPrimitive</code> adalah hit yang cukup menyakitkan, tetapi bagaimana dengan 17,4 GB di bawah <code>TransformedPrimitive</code> ? <br><br>  Seperti disebutkan di atas, <code>TransformedPrimitive</code> digunakan baik untuk transformasi dengan perubahan waktu, dan untuk instance objek.  Dalam kedua kasus, kita perlu menerapkan transformasi tambahan ke <code>Primitive</code> ada.  Hanya ada dua anggota di kelas <code>TransformedPrimitive</code> : <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Primitive&gt; primitive; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatedTransform PrimitiveToWorld;</code> </pre> <br>  Sejauh ini bagus: pointer ke primitif dan transformasi yang berubah seiring waktu.  Tetapi apa yang sebenarnya disimpan di <code>AnimatedTransform</code> ? <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Transform *startTransform, *endTransform; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Float startTime, endTime; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> actuallyAnimated; Vector3f T[<span class="hljs-number"><span class="hljs-number">2</span></span>]; Quaternion R[<span class="hljs-number"><span class="hljs-number">2</span></span>]; Matrix4x4 S[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRotation; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DerivativeTerm</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... Float kc, kx, ky, kz; }; DerivativeTerm c1[3], c2[3], c3[3], c4[3], c5[3];</span></span></code> </pre> <br>  Selain pointer ke dua matriks transisi dan waktu yang terkait dengannya, ada juga dekomposisi matriks menjadi komponen pengangkutan, rotasi, dan penskalaan, serta nilai yang telah dihitung sebelumnya yang digunakan untuk membatasi volume yang ditempati oleh kotak-kotak yang bergerak (lihat bagian 2.4.9 dari buku kami. <em>Rendering Berbasis Fisik</em> ).  Semua ini menambahkan hingga 456 byte. <br><br>  Tapi <em>tidak ada yang bergerak</em> dalam adegan ini.  Dari sudut pandang transformasi untuk instance objek, kita memerlukan satu pointer ke transformasi, dan nilai untuk dekomposisi dan kotak pembatas bergerak tidak diperlukan.  (Yaitu, hanya 8 byte yang diperlukan).  Jika Anda membuat implementasi <code>Primitive</code> terpisah untuk instance objek tetap, 17,4 GB dikompresi total menjadi 900 MB (!). <br><br>  Sedangkan untuk <code>GeometricPrimitive</code> , memperbaikinya adalah perubahan non-sepele dibandingkan dengan apa yang dijelaskan dalam buku ini, jadi kami juga akan menundanya ke versi pbrt berikutnya.  Setidaknya kita sekarang mengerti apa yang terjadi dengan kekacauan memori <code>Primitive</code> 24,7 GB. <br><br><h2>  Masalah dengan Cache Konversi </h2><br>  Blok terbesar berikutnya dari memori yang tidak terhitung yang didefinisikan oleh massif adalah <code>TransformCache</code> , yang menempati sekitar 16 GB.  (Berikut ini tautan ke <a href="">implementasi semula</a> .) Idenya adalah bahwa matriks transformasi yang sama sering digunakan beberapa kali dalam adegan, jadi yang terbaik adalah memiliki satu salinannya dalam memori, sehingga semua elemen yang menggunakannya hanya menyimpan pointer ke hal yang sama. konversi. <br><br>  <code>TransformCache</code> menggunakan <code>std::map</code> untuk menyimpan cache, dan massif melaporkan bahwa 6 dari 16 GB digunakan untuk simpul pohon hitam-merah di <code>std::map</code> .  Ini banyak sekali: 60% dari volume ini digunakan untuk transformasi itu sendiri.  Mari kita lihat deklarasi untuk distribusi ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Transform, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;Transform *, Transform *&gt;&gt; cache;</code> </pre> <br>  Di sini, pekerjaan dilakukan dengan sempurna: <code>Transform</code> sepenuhnya digunakan sebagai kunci untuk distribusi.  Bahkan yang lebih baik, <code>Transform</code> pbrt menyimpan dua matriks 4x4 (matriks transformasi dan matriks terbaliknya), yang menghasilkan 128 byte yang disimpan di setiap simpul pohon.  Semua ini benar-benar tidak perlu untuk nilai yang disimpan untuknya. <br><br>  Mungkin struktur seperti itu cukup normal di dunia di mana penting bagi kita bahwa matriks transformasi yang sama digunakan dalam ratusan atau ribuan primitif, dan secara umum tidak ada banyak matriks transformasi.  Tetapi untuk adegan dengan sekelompok matriks transformasi yang sebagian besar unik, seperti dalam kasus kami, ini hanya pendekatan yang mengerikan. <br><br>  Selain fakta bahwa ruang tersebut terbuang untuk kunci, pencarian di <code>std::map</code> untuk melintasi pohon merah-hitam melibatkan banyak operasi penunjuk, jadi sepertinya logis untuk mencoba sesuatu yang sama sekali baru.  Untungnya, sedikit yang ditulis tentang <code>TransformCache</code> di buku ini, sehingga sepenuhnya dapat diterima untuk menulis ulang sepenuhnya. <br><br>  Dan terakhir, sebelum kita mulai: setelah memeriksa tanda tangan metode <code>Lookup()</code> , masalah lain menjadi jelas: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Transform &amp;t, Transform **tCached, Transform **tCachedInverse)</span></span></span></span></code> </pre> <br>  Ketika fungsi panggilan menyediakan <code>Transform</code> , cache menyimpan dan mengembalikan pointer konversi sama dengan yang diteruskan, tetapi juga melewati matriks invers.  Untuk memungkinkan ini, dalam implementasi asli, ketika menambahkan transformasi ke cache, matriks terbalik selalu dihitung dan disimpan sehingga dapat dikembalikan. <br><br>  Yang bodoh di sini adalah sebagian besar rekan panggilan yang menggunakan cache transformasi tidak meminta atau menggunakan matriks invers.  Artinya, berbagai jenis memori terbuang sia-sia pada transformasi terbalik yang tidak dapat diterapkan. <br><br>  Dalam <a href="">implementasi baru</a> , peningkatan berikut ditambahkan: <br><br><ul><li>  Menggunakan tabel hash untuk mempercepat pencarian dan tidak memerlukan penyimpanan apa pun selain array <code>Transform *</code> , yang, pada dasarnya, mengurangi jumlah memori yang digunakan untuk nilai yang benar-benar diperlukan untuk menyimpan semua <code>Transform</code> . </li><li>  Tanda tangan dari metode pencarian sekarang terlihat seperti <code>Transform *Lookup(const Transform <br> &amp;t)</code> <code>Transform *Lookup(const Transform <br> &amp;t)</code>  <code>Transform *Lookup(const Transform <br> &amp;t)</code> ;  di satu tempat di mana fungsi panggilan ingin mendapatkan matriks terbalik dari cache, itu hanya memanggil <code>Lookup()</code> dua kali. </li></ul><br>  Untuk hashing, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi hash FNV1a</a> .  Setelah implementasi, saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting Aras pada fungsi hash</a> ;  mungkin saya seharusnya menggunakan xxHash atau CityHash karena kinerjanya lebih baik;  mungkin suatu hari nanti rasa maluku akan menang dan aku akan memperbaikinya. <br><br>  Berkat implementasi <code>TransformCache</code> baru, waktu startup sistem secara keseluruhan telah menurun secara signifikan - hingga 21 menit 42 detik.  Artinya, kami menyimpan 5 menit 7 detik, atau dipercepat 1,27 kali.  Selain itu, penggunaan memori yang lebih efisien telah mengurangi ruang yang ditempati oleh matriks transformasi dari 16 menjadi 5,7 GB, yang hampir sama dengan jumlah data yang disimpan.  Ini memungkinkan kami untuk tidak mencoba mengambil keuntungan dari fakta bahwa mereka sebenarnya tidak proyektif, dan untuk menyimpan matriks 3x4 bukannya 4x4.  (Dalam kasus biasa, saya akan skeptis akan pentingnya optimasi semacam ini, tetapi di sini ini akan menyelamatkan kita lebih dari satu gigabyte - banyak memori! Ini jelas layak dilakukan dalam penyaji produksi.) <br><br><h2>  Optimasi kinerja kecil untuk menyelesaikan </h2><br>  Struktur <code>TransformedPrimitive</code> terlalu digeneralisasi menghabiskan banyak memori dan waktu: profiler mengatakan bahwa sebagian besar waktu saat startup dihabiskan dalam fungsi <code>AnimatedTransform::Decompose()</code> , yang menguraikan transformasi matriks menjadi rotasi, transfer, dan skala skala empat.  Karena tidak ada yang bergerak dalam adegan ini, pekerjaan ini tidak perlu, dan pemeriksaan menyeluruh dari implementasi <code>AnimatedTransform</code> telah menunjukkan bahwa tidak ada nilai-nilai ini diakses jika dua matriks transformasi sebenarnya identik. <br><br>  Menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua baris</a> ke konstruktor sehingga dekomposisi dari transformasi tidak dilakukan ketika mereka tidak diperlukan, kami menyimpan 1 menit 31 dari waktu mulai: sebagai hasilnya, kami sampai 20 menit 9 detik, yaitu, secara umum, mereka melaju 1,73 kali. <br><br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel selanjutnya,</a> kita akan serius mengambil parser dan menganalisis apa yang menjadi penting ketika kita mempercepat pekerjaan bagian lain. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417445/">https://habr.com/ru/post/id417445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417431/index.html">Anti-wawancara</a></li>
<li><a href="../id417435/index.html">Kesalahan ketik ditemukan pada konfigurasi Aliens: Colonial Marines, yang menyebabkan game AI buggy selama empat tahun</a></li>
<li><a href="../id417437/index.html">Proyektor vs panel datar. Kami mencoba jubah dokter mata dan mencari tahu mengapa ukuran itu penting</a></li>
<li><a href="../id417441/index.html">Bagaimana kami merusak pemain biasa dan untuk DDoS atau server kami: panduan praktis</a></li>
<li><a href="../id417443/index.html">Organik di Mars dapat ditemukan 40 tahun lalu jika metode analisis yang berbeda digunakan</a></li>
<li><a href="../id417447/index.html">Ekspedisi ke lingkaran peri misterius di gurun Namib</a></li>
<li><a href="../id417449/index.html">Dunia Jurassic: Bisakah Kita Benar-Benar Membangkitkan Dinosaurus?</a></li>
<li><a href="../id417451/index.html">Lima Kesalahan Umum untuk Pemula</a></li>
<li><a href="../id417453/index.html">Organisasi magang untuk siswa: menyapu dan trik</a></li>
<li><a href="../id417457/index.html">Frontend Conf Moscow - sisi klien masuk dan keluar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>