<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèº üè• üçÆ Leyes de reflexi√≥n en Go üë®üèª‚Äç‚úàÔ∏è üó®Ô∏è üë≤üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento la traducci√≥n del art√≠culo "Las leyes de la reflexi√≥n" del creador del lenguaje. 

 La reflexi√≥n es la capacidad de un program...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Leyes de reflexi√≥n en Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415171/">  Hola Habr!  Les presento la traducci√≥n del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Las leyes de la reflexi√≥n"</a> del creador del lenguaje. <br><br>  La reflexi√≥n es la capacidad de un programa para explorar su propia estructura, especialmente a trav√©s de los tipos.  Esta es una forma de metaprogramaci√≥n y una gran fuente de confusi√≥n. <br>  En Go, la reflexi√≥n se usa ampliamente, por ejemplo, en los paquetes test y fmt.  En este art√≠culo, intentaremos deshacernos de la "magia" explicando c√≥mo funciona la reflexi√≥n en Go. <br><a name="habracut"></a><br><h3>  Tipos e interfaces </h3><br>  Dado que la reflexi√≥n se basa en un sistema de tipos, vamos a actualizar nuestro conocimiento de los tipos en Go. <br>  Go est√° est√°ticamente escrito.  Cada variable tiene un √∫nico tipo est√°tico fijo en tiempo de compilaci√≥n: <code>int, float32, *MyType, []byte</code> ... Si declaramos: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j MyInt</code> </pre> <br>  entonces <code>i</code> es de tipo <code>int</code> y <code>j</code> es de tipo <code>MyInt</code> .  Las variables <code>i</code> y <code>j</code> tienen diferentes tipos est√°ticos y, aunque tienen el mismo tipo b√°sico, no pueden asignarse entre s√≠ sin conversi√≥n. <br><br>  Una de las categor√≠as de tipo importantes son las interfaces, que son conjuntos fijos de m√©todos.  Una interfaz puede almacenar cualquier valor espec√≠fico (no interfaz) siempre que este valor implemente los m√©todos de la interfaz.  Un par de ejemplos bien conocidos son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">io.Reader y io.Writer</a> , los tipos Reader y Writer del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete io</a> : <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Reader -  ,    Read(). type Reader interface { Read(p []byte) (n int, err error) } // Writer -  ,    Write(). type Writer interface { Write(p []byte) (n int, err error) }</span></span></code> </pre> <br>  Se dice que cualquier tipo que implemente el m√©todo <code>Read()</code> o <code>Write()</code> con esta firma implementa <code>io.Reader</code> o <code>io.Writer</code> respectivamente.  Esto significa que una variable de tipo <code>io.Reader</code> puede contener cualquier valor de tipo Read (): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader r = os.Stdin r = bufio.NewReader(r) r = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(bytes.Buffer)</code> </pre> <br>  Es importante comprender que a <code>r</code> se le puede asignar cualquier valor que implemente <code>io.Reader</code> .  Go se escribe est√°ticamente, y el tipo est√°tico <code>r</code> es <code>io.Reader</code> . <br><br>  Un ejemplo extremadamente importante de un tipo de interfaz es la interfaz vac√≠a: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}</code> </pre> <br>  Es un conjunto vac√≠o de m√©todos ‚àÖ y se implementa con cualquier valor. <br>  Algunos dicen que las interfaces Go son variables de tipo din√°mico, pero esto es una falacia.  Est√°n tipificados est√°ticamente: una variable con un tipo de interfaz siempre tiene el mismo tipo est√°tico, y aunque en el tiempo de ejecuci√≥n el valor almacenado en la variable de interfaz puede cambiar el tipo, este valor siempre satisfar√° la interfaz.  (No hay elementos <code>undefined</code> , <code>NaN</code> u otras cosas que rompan la l√≥gica del programa). <br><br>  Esto debe entenderse: la reflexi√≥n y las interfaces est√°n estrechamente relacionadas. <br><br><h3>  Representaci√≥n interna de la interfaz. </h3><br>  Russ Cox escribi√≥ una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n de blog</a> detallada sobre la configuraci√≥n de una interfaz en Go.  No menos buen art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">es sobre Habr'e</a> .  No es necesario repetir toda la historia, se mencionan los puntos principales. <br><br>  Una variable de tipo de interfaz contiene un par: el valor espec√≠fico asignado a la variable y un descriptor de tipo para ese valor.  M√°s precisamente, el valor es el elemento de datos b√°sico que implementa la interfaz, y el tipo describe el tipo completo de este elemento.  Por ejemplo, despu√©s <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader tty, err := os.OpenFile(<span class="hljs-string"><span class="hljs-string">"/dev/tty"</span></span>, os.O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } r = tty</code> </pre> <br>  <code>r</code> contiene, esquem√°ticamente, un par <code>(, ) --&gt; (tty, *os.File)</code> .  Tenga en cuenta que el tipo <code>*os.File</code> implementa m√©todos distintos de <code>Read()</code> ;  incluso si el valor de la interfaz proporciona acceso solo al m√©todo Read (), el valor dentro contiene toda la informaci√≥n sobre el tipo de este valor.  Es por eso que podemos hacer tales cosas: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w io.Writer w = r.(io.Writer)</code> </pre> <br>  La expresi√≥n en esta asignaci√≥n es una declaraci√≥n de tipo;  afirma que el elemento dentro de <code>r</code> tambi√©n implementa <code>io.Writer</code> , y por lo tanto podemos asignarlo a <code>w</code> .  Una vez asignado, <code>w</code> contendr√° un par <code>(tty, *os.File)</code> .  Este es el mismo par que en <code>r</code> .  El tipo est√°tico de la interfaz determina qu√© m√©todos se pueden invocar en la variable de la interfaz, aunque un conjunto m√°s amplio de m√©todos puede tener un valor espec√≠fico en su interior. <br><br>  Continuando, podemos hacer lo siguiente: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> empty <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} empty = w</code> </pre> <br>  y el valor vac√≠o del campo vac√≠o nuevamente contendr√° el mismo par <code>(tty, *os.File)</code> .  Esto es conveniente: una interfaz vac√≠a puede contener cualquier valor y toda la informaci√≥n que necesitemos de ella. <br><br>  No necesitamos una aserci√≥n de tipo aqu√≠ porque se sabe que <code>w</code> satisface una interfaz vac√≠a.  En el ejemplo donde transferimos el valor de <code>Reader</code> a <code>Writer</code> , necesit√°bamos usar expl√≠citamente una aserci√≥n de tipo, porque <code>Writer</code> m√©todos <code>Writer</code> no son un subconjunto de <code>Reader</code> 's.  Intentar convertir un valor que no coincida con la interfaz provocar√° p√°nico. <br><br>  Un detalle importante es que un par dentro de una interfaz siempre tiene un formulario (valor, tipo espec√≠fico) y no puede tener un formulario (valor, interfaz).  Las interfaces no admiten interfaces como valores. <br><br>  Ahora estamos listos para estudiar reflexionar. <br><br><h3>  La primera ley de <s>reflexi√≥n</s> refleja </h3><br><ul><li>  La reflexi√≥n se extiende desde la interfaz hasta la reflexi√≥n del objeto. </li></ul><br>  En un nivel b√°sico, reflexionar es solo un mecanismo para examinar un par de tipos y valores almacenados dentro de una variable de interfaz.  Para comenzar, hay dos tipos que debemos conocer: <code>reflect.Type</code> y <code>reflect.Value</code> .  Estos dos tipos proporcionan acceso a los contenidos de la variable de interfaz y son devueltos por funciones simples, reflect.TypeOf () y reflect.ValueOf (), respectivamente.  Extraen partes del significado de la interfaz.  (Adem√°s, <code>reflect.Value</code> f√°cil de obtener <code>reflect.Type</code> , pero no <code>reflect.Type</code> los conceptos de <code>Value</code> y <code>Type</code> en este momento). <br><br>  Comencemos con <code>TypeOf()</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"reflect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, reflect.TypeOf(x)) }</code> </pre> <br>  El programa saldr√° <br> <code>type: float64</code> <br> <br>  El programa es similar a pasar una variable simple <code>float64 x</code> para <code>reflect.TypeOf()</code> . <code>reflect.TypeOf()</code> .  ¬øVes la interfaz?  Y lo es: <code>reflect.TypeOf()</code> acepta una interfaz vac√≠a, de acuerdo con la declaraci√≥n de funci√≥n: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TypeOf()  reflect.Type    . func TypeOf(i interface{}) Type</span></span></code> </pre> <br>  Cuando llamamos a <code>reflect.TypeOf(x)</code> , <code>x</code> almacena primero en una interfaz vac√≠a, que luego se pasa como argumento;  <code>reflect.TypeOf()</code> desempaqueta esta interfaz vac√≠a para restaurar la informaci√≥n de tipo. <br><br>  La funci√≥n <code>reflect.ValueOf()</code> , por supuesto, restaura el valor (en adelante ignoraremos la plantilla y nos centraremos en el c√≥digo): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, reflect.ValueOf(x).String())</code> </pre> <br>  imprimir√° <br> <code>value: &lt;float64 Value&gt;</code> <br>  (Llamamos al m√©todo <code>String()</code> expl√≠citamente porque, por defecto, el paquete fmt se desempaqueta para <code>reflect.Value</code> e imprime un valor espec√≠fico). <br>  Tanto <code>reflect.Type</code> como <code>reflect.Value</code> tienen muchos m√©todos, que le permiten explorarlos y modificarlos.  Un ejemplo importante es que <code>reflect.Value</code> tiene un m√©todo <code>Type()</code> que devuelve el tipo de valor.  <code>reflect.Type</code> y <code>reflect.Value</code> tienen un m√©todo <code>Kind()</code> que devuelve una constante que indica qu√© elemento primitivo est√° almacenado: <code>Uint, Float64, Slice</code> ... Estas constantes se declaran en la enumeraci√≥n en el paquete <code>Uint, Float64, Slice</code> .  <code>Value</code> m√©todos de <code>Value</code> con nombres como <code>Int()</code> y <code>Float()</code> nos permiten extraer valores (como int64 y float64) encerrados dentro: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is float64:"</span></span>, v.Kind() == reflect.Float64) fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, v.Float())</code> </pre> <br>  imprimir√° <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: float64 kind <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> float64: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-number"><span class="hljs-number">3.4</span></span></code> </pre> <br>  Tambi√©n hay m√©todos como <code>SetInt()</code> y <code>SetFloat()</code> , pero para usarlos necesitamos comprender la capacidad de configuraci√≥n, el tema de la tercera ley de reflexi√≥n. <br><br>  La biblioteca de reflejos tiene un par de propiedades que debe resaltar.  Primero, para mantener la API simple, los m√©todos de <code>Value</code> "getter" y "setter" act√∫an sobre el tipo m√°s grande que puede contener un valor: <code>int64</code> para todos los enteros con <code>int64</code> .  Es decir, el m√©todo <code>Int()</code> del valor <code>Value</code> devuelve <code>int64</code> y el valor <code>SetInt()</code> toma <code>int64</code> ;  La conversi√≥n al tipo real puede ser necesaria: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> = <span class="hljs-string"><span class="hljs-string">'x'</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is uint8: "</span></span>, v.Kind() == reflect.Uint8) x = <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>(v.Uint()) <span class="hljs-comment"><span class="hljs-comment">// v.Uint  uint64.</span></span></code> </pre> <br>  ser√° <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> kind is <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Aqu√≠ <code>v.Uint()</code> devolver√° <code>uint64</code> , se necesita una declaraci√≥n de tipo expl√≠cito. <br><br>  La segunda propiedad es que el reflejo <code>Kind()</code> del objeto describe el tipo base, no el tipo est√°tico.  Si el objeto de reflexi√≥n contiene un valor de un tipo entero definido por el usuario, como en <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x MyInt = <span class="hljs-number"><span class="hljs-number">7</span></span> v := reflect.ValueOf(x) <span class="hljs-comment"><span class="hljs-comment">// v   Value.</span></span></code> </pre> <br>  <code>v.Kind() == reflect.Int</code> , aunque el tipo est√°tico de <code>x</code> es <code>MyInt</code> , no <code>int</code> .  En otras palabras, <code>Kind()</code> no puede distinguir <code>int</code> de <code>MyInt</code> , a <code>MyInt</code> <code>Type()</code> .  <code>Kind</code> solo puede aceptar valores de tipos incorporados. <br><br><h3>  La segunda ley de <s>reflexi√≥n</s> refleja </h3><br><ul><li>  La reflexi√≥n se extiende desde el objeto reflejado hasta la interfaz. </li></ul><br>  Al igual que la reflexi√≥n f√≠sica, reflexionar en Go crea su opuesto. <br><br>  Habiendo <code>reflect.Value</code> , podemos restaurar el valor de la interfaz usando el m√©todo <code>Interface()</code> ;  El m√©todo empaqueta la informaci√≥n de tipo y valor en la interfaz y devuelve el resultado: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Interface   v  interface{}. func (v Value) Interface() interface{}</span></span></code> </pre>  bvt <br>  Como un ejemplo: <br><br><pre> <code class="go hljs">y := v.Interface().(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>) <span class="hljs-comment"><span class="hljs-comment">// y   float64. fmt.Println(y)</span></span></code> </pre> <br>  imprime el valor de <code>float64</code> representado por el objeto reflejado <code>v</code> . <br>  Sin embargo, podemos hacerlo a√∫n mejor.  Los argumentos en <code>fmt.Println()</code> y <code>fmt.Printf()</code> se pasan como interfaces vac√≠as, que luego el paquete fmt desempaqueta internamente, como en los ejemplos anteriores.  Por lo tanto, todo lo que se requiere para imprimir el contenido de <code>reflect.Value</code> correctamente es pasar el resultado del m√©todo <code>Interface()</code> a la funci√≥n de salida formateada: <br><br><pre> <code class="go hljs">fmt.Println(v.Interface())</code> </pre> <br>  (¬øPor qu√© no <code>fmt.Println(v)</code> ? Debido a que <code>v</code> es de tipo <code>reflect.Value</code> ; queremos obtener el valor que contiene). Dado que nuestro valor es <code>float64</code> , incluso podemos usar el formato de coma flotante si queremos: <br><br><pre> <code class="go hljs">fmt.Printf(<span class="hljs-string"><span class="hljs-string">"value is %7.1e\n"</span></span>, v.Interface())</code> </pre> <br>  saldr√° en un caso espec√≠fico <br> <code>3.4e+00</code> <br> <br>  Nuevamente, no es necesario <code>v.Interface()</code> tipo de resultado <code>v.Interface()</code> en <code>float64</code> ;  un valor de interfaz vac√≠o contiene informaci√≥n sobre un valor espec√≠fico en su interior, y <code>fmt.Printf()</code> restaurar√°. <br>  En resumen, el m√©todo <code>Interface()</code> es el inverso de la funci√≥n <code>ValueOf()</code> , excepto que su resultado es siempre de la <code>interface{}</code> tipo est√°tico <code>interface{}</code> . <br><br>  Repita: la reflexi√≥n se extiende desde los valores de la interfaz hasta los objetos de reflexi√≥n y viceversa. <br><br><h3>  Tercera ley de <s>reflexi√≥n</s> reflexi√≥n </h3><br><ul><li>  Para cambiar el objeto de reflexi√≥n, el valor debe ser configurable. </li></ul><br>  La tercera ley es la m√°s sutil y confusa.  Comenzamos con los primeros principios. <br>  Este c√≥digo no funciona, pero merece atenci√≥n. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Si ejecuta este c√≥digo, se bloquear√° del p√°nico con un mensaje cr√≠tico: <br> <code>panic: reflect.Value.SetFloat   </code> <br>  El problema no es que no se aborde el literal <code>7.1</code> ;  Esto es lo que <code>v</code> no <code>v</code> instalable.  <code>reflect.Value</code> es una propiedad de <code>reflect.Value</code> , y no todo <code>reflect.Value</code> tiene. <br>  El m√©todo <code>reflect.Value.CanSet()</code> se establece;  en nuestro caso: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  imprimir√°: <br> <code>settability of v: false</code> <br> <br>  Se produjo un error al llamar al m√©todo <code>Set()</code> en un valor no administrado.  Pero, ¬øqu√© es la instalabilidad? <br><br>  La sostenibilidad es un poco como la direccionabilidad, pero m√°s estricta.  Esta es una propiedad donde el objeto de reflexi√≥n puede cambiar el valor almacenado que se us√≥ para crear el objeto de reflexi√≥n.  La sostenibilidad est√° determinada por si el objeto de reflexi√≥n contiene el elemento fuente o solo una copia del mismo.  Cuando escribimos: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x)</code> </pre> <br>  le pasamos una copia de <code>x</code> a <code>reflect.ValueOf()</code> , por lo que la interfaz se crea como un argumento para <code>reflect.ValueOf()</code> : esta es una copia de <code>x</code> , no <code>x</code> s√≠ misma.  Por lo tanto, si la declaraci√≥n: <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>)</code> </pre> <br>  si se ejecutara, no actualizar√≠a <code>x</code> , aunque <code>v</code> parece que se cre√≥ a partir de <code>x</code> .  En cambio, actualizar√≠a la copia de <code>x</code> almacenada dentro del valor de <code>v</code> , y la <code>x</code> misma no se ver√≠a afectada.  Esto est√° prohibido para no causar problemas, y la instalabilidad es una propiedad utilizada para evitar un problema. <br><br>  Esto no deber√≠a parecer extra√±o.  Esta es una situaci√≥n com√∫n en ropa inusual.  Considere pasar <code>x</code> a una funci√≥n: <br> <code>f(x)</code> <br> <br>  No esperamos que <code>f()</code> pueda cambiar <code>x</code> , porque pasamos una copia del valor de <code>x</code> , no <code>x</code> s√≠.  Si queremos que <code>f()</code> cambie directamente <code>x</code> , debemos pasar un puntero a <code>x</code> a nuestra funci√≥n: <br> <code>f(&amp;x)</code> <br> <br>  Esto es sencillo y familiar, y la reflexi√≥n funciona de manera similar.  Si queremos cambiar <code>x</code> usando la reflexi√≥n, debemos proporcionar a la biblioteca de reflexi√≥n un puntero al valor que queremos cambiar. <br><br>  Hag√°moslo  Primero, inicializamos <code>x</code> como de costumbre, y luego creamos un <code>reflect.Value p</code> que apunta a √©l. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> p := reflect.ValueOf(&amp;x) <span class="hljs-comment"><span class="hljs-comment">//   x. fmt.Println("type of p:", p.Type()) fmt.Println("settability of p:", p.CanSet())</span></span></code> </pre> <br>  saldr√° <br> <code>type of p: *float64 <br> settability of p: false</code> <br> <br>  El objeto Reflection <code>p</code> no se puede establecer, pero no es la <code>p</code> que queremos establecer, es el puntero <code>*p</code> .  Para obtener lo que se√±ala <code>p</code> , llamamos al m√©todo <code>Value.Elem()</code> , que toma el valor indirectamente a trav√©s del puntero y almacena el resultado en <code>reflect.Value v</code> : <br><br><pre> <code class="go hljs">v := p.Elem() fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  Ahora <code>v</code> es un objeto instalable; <br> <code>settability of v: true</code> <br>  y dado que representa <code>x</code> , finalmente podemos usar <code>v.SetFloat()</code> para cambiar el valor de <code>x</code> : <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) fmt.Println(v.Interface()) fmt.Println(x)</code> </pre> <br>  conclusi√≥n como se esperaba <br> <code>7.1 <br> 7.1</code> <br>  Reflexionar puede ser dif√≠cil de entender, pero hace exactamente lo que hace el lenguaje, aunque con la ayuda de <code>reflection.Value</code> <code>reflect.Type</code> y <code>reflection.Value</code> <code>reflect.Type</code> , que puede ocultar lo que est√° sucediendo.  Solo tenga en cuenta esa <code>reflection.Value</code> necesita la direcci√≥n de una variable para cambiarlo. <br><br><h3>  Estructuras </h3><br>  En nuestro ejemplo anterior, <code>v</code> no <code>v</code> un puntero, solo se derivaba de √©l.  Una forma com√∫n de crear esta situaci√≥n es usar la reflexi√≥n para cambiar los campos de la estructura.  Mientras tengamos la direcci√≥n de la estructura, podemos cambiar sus campos. <br><br>  Aqu√≠ hay un ejemplo simple que analiza el valor de la estructura <code>t</code> .  Creamos un objeto de reflexi√≥n con la direcci√≥n de la estructura para modificarlo m√°s tarde.  Luego establezca typeOfT en su tipo e itere sobre los campos utilizando llamadas a m√©todos simples (consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete para obtener una descripci√≥n detallada</a> ).  Tenga en cuenta que estamos extrayendo nombres de campo del tipo de estructura, pero los campos en s√≠ mismos son <code>reflect.Value</code> regulares. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } t := T{<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-string"><span class="hljs-string">"skidoo"</span></span>} s := reflect.ValueOf(&amp;t).Elem() typeOfT := s.Type() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; s.NumField(); i++ { f := s.Field(i) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%d: %s %s = %v\n"</span></span>, i, typeOfT.Field(i).Name, f.Type(), f.Interface()) }</code> </pre> <br>  El programa saldr√° <br> <code>0: A int = 23 <br> 1: B string = skidoo</code> <br>  Aqu√≠ se muestra un punto m√°s sobre la instalabilidad: los nombres de los campos <code>T</code> en may√∫sculas (exportados), porque solo los campos exportados son configurables. <br>  Como <code>s</code> contiene un objeto de reflexi√≥n instalable, podemos cambiar el campo de estructura. <br><br><pre> <code class="go hljs">s.Field(<span class="hljs-number"><span class="hljs-number">0</span></span>).SetInt(<span class="hljs-number"><span class="hljs-number">77</span></span>) s.Field(<span class="hljs-number"><span class="hljs-number">1</span></span>).SetString(<span class="hljs-string"><span class="hljs-string">"Sunset Strip"</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"t is now"</span></span>, t)</code> </pre> <br>  Resultado: <br> <code>t is now {77 Sunset Strip}</code> <br>  Si cambiamos el programa para que <code>s</code> cree desde <code>t</code> lugar de <code>&amp;t</code> , las llamadas a <code>SetInt()</code> y <code>SetString()</code> terminar√≠an en p√°nico, ya que los campos <code>t</code> no ser√≠an configurables. <br><br><h3>  Conclusi√≥n </h3><br>  Recordemos las leyes de la reflexi√≥n: <br><br><ul><li>  La reflexi√≥n se extiende desde la interfaz hasta la reflexi√≥n del objeto. </li><li>  La reflexi√≥n se extiende desde la reflexi√≥n de un objeto hasta la interfaz. </li><li>  Para cambiar el objeto de reflexi√≥n, se debe establecer el valor. </li></ul><br>  Publicado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rob Pike</a> . <br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/2q/04/ha/2q04hardrnhhnrnuyb6dk0quvue.png" width="350"></a> </div> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415171/">https://habr.com/ru/post/es415171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415159/index.html">Anuncio de la conferencia DevOps DevOops 2018</a></li>
<li><a href="../es415163/index.html">Red inal√°mbrica en una f√°brica farmac√©utica especialmente protegida y especialmente protegida en algunos lugares de Rusia</a></li>
<li><a href="../es415165/index.html">Lanzamiento de Node.js 10.5: multihilo fuera de la caja</a></li>
<li><a href="../es415167/index.html">Lecci√≥n abierta "Multithreading en Java. Primitivas b√°sicas de sincronizaci√≥n ¬ª</a></li>
<li><a href="../es415169/index.html">Compresi√≥n y deduplicaci√≥n: reduzca el tama√±o del archivo de correo y la copia de seguridad utilizando el invierno ZxPowerstore</a></li>
<li><a href="../es415175/index.html">Entrevista con miembro de la Expo Mundial Aumentada</a></li>
<li><a href="../es415177/index.html">Bienvenido</a></li>
<li><a href="../es415181/index.html">[Ekaterimburgo, anuncio] Mitap de analistas: sobre los primeros analistas y CBAP, sobre m√©tricas, sobre el sector p√∫blico y los tipos de analistas</a></li>
<li><a href="../es415183/index.html">Extensi√≥n web entre navegadores para scripts personalizados Parte 1</a></li>
<li><a href="../es415185/index.html">Videoconferencia gratuita de 3CX WebMeeting: descripci√≥n general de la funci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>