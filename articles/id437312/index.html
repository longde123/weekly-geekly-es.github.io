<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚻 🧒🏾 ↔️ Mengimplementasikan hot reload kode C ++ di Linux dan macOS: menggali lebih dalam 🔌 👨‍👨‍👧‍👦 🚳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Tautan ke perpustakaan dan demo video di akhir artikel. Untuk memahami apa yang terjadi dan siapa orang-orang ini, saya sarankan membaca artikel seb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengimplementasikan hot reload kode C ++ di Linux dan macOS: menggali lebih dalam</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437312/"><p><img src="https://habrastorage.org/webt/cz/hn/wz/czhnwzufandjpr6jf5cwj1j3p48.png"></p><br><p>  * Tautan ke perpustakaan dan demo video di akhir artikel.  Untuk memahami apa yang terjadi dan siapa orang-orang ini, saya sarankan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> . </p><br><p>  Pada artikel terakhir, kami membiasakan diri dengan pendekatan yang memungkinkan untuk memuat ulang kode c ++.  "Kode" dalam hal ini adalah fungsi, data, dan pekerjaan mereka yang terkoordinasi satu sama lain.  Tidak ada masalah khusus dengan fungsi, kami mengarahkan aliran eksekusi dari fungsi lama ke yang baru, dan semuanya berfungsi.  Masalah muncul dengan data (variabel statis dan global), yaitu dengan strategi sinkronisasi mereka dalam kode lama dan baru.  Dalam implementasi pertama, strategi ini sangat canggung: kita cukup menyalin nilai-nilai semua variabel statis dari kode lama ke yang baru, sehingga kode baru, mengacu pada variabel baru, bekerja dengan nilai-nilai dari kode lama.  Tentu saja, ini tidak benar, dan hari ini kami akan mencoba untuk memperbaiki kekurangan ini dengan secara simultan memecahkan sejumlah masalah kecil namun menarik. </p><br><p>  Artikel ini menghilangkan detail tentang pekerjaan mekanis, seperti membaca karakter dan memindahkan file elf dan mach-o.  Penekanannya adalah pada poin-poin halus yang saya temui dalam proses implementasi, dan yang mungkin berguna bagi seseorang yang, seperti saya baru-baru ini, sedang mencari jawaban. </p><a name="habracut"></a><br><h3 id="sut">  Esensi </h3><br><p>  Mari kita bayangkan bahwa kita memiliki kelas (contoh sintetis, tolong jangan mencari makna di dalamnya, hanya kode yang penting): </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Entity.hpp class Entity { public: Entity(const std::string&amp; description); ~Entity(); void printDescription(); static int getLivingEntitiesCount(); private: static int m_livingEntitiesCount; std::string m_description; }; // Entity.cpp int Entity::m_livingEntitiesCount = 0; Entity::Entity(const std::string&amp; description) : m_description(description) { m_livingEntitiesCount++; } Entity::~Entity() { m_livingEntitiesCount--; } int Entity::getLivingEntitiesCount() { return m_livingEntitiesCount; } void Entity::printDesctiption() { std::cout &lt;&lt; m_description &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Tidak ada yang istimewa selain variabel statis.  Sekarang bayangkan kita ingin mengubah metode <code>printDescription()</code> menjadi: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Entity::printDescription() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DESCRIPTION: "</span></span> &lt;&lt; m_description &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Apa yang terjadi setelah kode dimuat ulang?  Selain metode kelas <code>Entity</code> , variabel statis <code>m_livingEntitiesCount</code> juga masuk ke pustaka dengan kode baru.  Tidak ada hal buruk yang akan terjadi jika kita cukup menyalin nilai variabel ini dari kode lama ke yang baru dan terus menggunakan variabel baru, melupakan yang lama, karena semua metode yang menggunakan variabel ini secara langsung ada di perpustakaan dengan kode baru. </p><br><p>  C ++ sangat fleksibel dan kaya.  Dan sementara keanggunan memecahkan beberapa masalah di c ++ berbatasan dengan kode berbau busuk, saya suka bahasa ini.  Misalnya, bayangkan proyek Anda tidak menggunakan rtti.  Pada saat yang sama, Anda harus memiliki implementasi kelas <code>Any</code> dengan antarmuka yang agak aman: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } };</code> </pre> <br><p>  Kami tidak akan membahas detail implementasi kelas ini.  Yang penting bagi kita adalah bahwa untuk implementasi kita memerlukan semacam mekanisme untuk pemetaan yang tidak ambigu dari tipe (compile-time entity) ke dalam nilai variabel, misalnya, <code>uint64_t</code> (entitas runtime), yaitu tipe "enumerate".  Saat menggunakan rtti, hal-hal seperti <code>type_info</code> dan, lebih cocok untuk kita, <code>type_index</code> tersedia untuk kita.  Tetapi kami tidak memiliki rtti.  Dalam hal ini, peretasan yang cukup umum (atau solusi elegan?) Apakah fungsi ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> typeId() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> someVar; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(&amp;someVar); }</code> </pre> <br><p>  Maka implementasi dari kelas <code>Any</code> akan terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_typeId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(typeId&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::decay&lt;T&gt;::type&gt;())</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// copy or move value somewhere {} template &lt;typename T&gt; bool is() const { return m_typeId == typeId&lt;std::decay&lt;T&gt;::type&gt;(); } template &lt;typename T&gt; T&amp; as() { ... } private: uint64_t m_typeId = 0; };</span></span></span></span></code> </pre> <br><p>  Untuk setiap jenis, fungsi akan dipakai tepat 1 kali, masing-masing, setiap versi fungsi akan memiliki variabel statis sendiri, jelas dengan alamat uniknya sendiri.  Apa yang terjadi ketika kami memuat ulang kode menggunakan fungsi ini?  Panggilan ke versi fungsi yang lama akan dialihkan ke yang baru.  Yang baru akan memiliki variabel statisnya sendiri yang sudah diinisialisasi (kami menyalin nilai dan variabel penjaganya).  Tapi kami tidak tertarik dengan artinya, kami hanya menggunakan alamatnya.  Dan alamat variabel baru akan berbeda.  Dengan demikian, data menjadi tidak konsisten: dalam contoh kelas <code>Any</code> sudah dibuat, alamat variabel statis lama akan disimpan, dan metode <code>is()</code> akan membandingkannya dengan alamat yang baru, dan "Ini tidak <code>Any</code> lagi sama dengan <code>Any</code> " ©. </p><br><h3 id="plan">  Rencanakan </h3><br><p>  Untuk mengatasi masalah ini, Anda memerlukan sesuatu yang lebih pintar dari sekadar menyalin.  Setelah menghabiskan beberapa malam di Google, membaca dokumentasi, kode sumber, dan sistem api, rencana berikut ini dibuat di kepala saya: </p><br><ol><li>  Setelah membangun kode baru, kami pergi melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">relokasi</a> . </li><li>  Dari relokasi ini kita mendapatkan semua tempat dalam kode yang menggunakan variabel statis (dan terkadang global). </li><li>  Alih-alih alamat ke versi variabel baru, kami mengganti alamat versi lama ke tempat relokasi. </li></ol><br><p>  Dalam hal ini, tidak akan ada tautan ke data baru, seluruh aplikasi akan terus bekerja dengan versi variabel lama hingga alamat.  Itu seharusnya bekerja.  Ini tidak bisa gagal berfungsi. </p><br><h3 id="relokacii">  Relokasi </h3><br><p>  Ketika kompiler menghasilkan kode mesin, ia memasukkan beberapa byte yang cukup untuk menulis alamat sebenarnya dari variabel atau fungsi ke tempat ini di setiap tempat di mana salah satu fungsi dipanggil atau alamat variabel dimuat, dan juga menghasilkan relokasi.  Dia tidak bisa segera mencatat alamat aslinya, karena pada tahap ini dia tidak tahu alamat ini.  Fungsi dan variabel setelah penautan dapat di bagian yang berbeda, di tempat bagian yang berbeda, di bagian akhir dapat dimuat ke alamat yang berbeda saat runtime. </p><br><p>  Relokasi berisi informasi: </p><br><ul><li>  Alamat apa yang Anda perlukan untuk menuliskan alamat fungsi atau variabel </li><li>  Alamat fungsi atau variabel mana yang akan ditulis </li><li>  Formula tempat alamat ini harus dihitung </li><li>  Berapa byte yang dicadangkan untuk alamat ini </li></ul><br><p>  Dalam OS yang berbeda, relokasi direpresentasikan secara berbeda, tetapi pada akhirnya mereka semua bekerja dengan prinsip yang sama.  Misalnya, di elf (Linux), relokasi terletak di bagian <code>.rela</code> khusus (dalam versi 32-bit ini <code>.rel</code> ), yang merujuk ke bagian dengan alamat yang perlu diperbaiki (misalnya, <code>.rela.text</code> - bagian di mana relokasi berada, diterapkan pada bagian <code>.text</code> ), dan setiap entri menyimpan informasi tentang simbol yang alamatnya ingin Anda masukkan di situs relokasi.  Dalam mach-o (macOS), yang terjadi adalah kebalikannya, tidak ada bagian terpisah untuk relokasi, sebaliknya, setiap bagian berisi pointer ke tabel relokasi yang harus diterapkan ke bagian ini, dan setiap catatan dalam tabel ini memiliki referensi ke simbol relasional. <br>  Misalnya, untuk kode seperti itu (dengan opsi <code>-fPIC</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> globalVariable = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> functionLocalVariable = <span class="hljs-number"><span class="hljs-number">0</span></span>; functionLocalVariable++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> globalVariable + functionLocalVariable; }</code> </pre> <br><p>  kompiler akan membuat bagian seperti itu dengan relokasi di Linux: </p><br><pre> <code class="plaintext hljs">Relocation section '.rela.text' at offset 0x1a0 contains 4 entries: Offset Info Type Symbol's Value Symbol's Name + Addend 0000000000000007 0000000600000009 R_X86_64_GOTPCREL 0000000000000000 globalVariable - 4 000000000000000d 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 0000000000000016 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 000000000000001e 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4</code> </pre> <br><p>  dan tabel relokasi seperti itu di macOS: </p><br><pre> <code class="plaintext hljs">RELOCATION RECORDS FOR [__text]: 000000000000001b X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000015 X86_64_RELOC_SIGNED _globalVariable 000000000000000f X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000006 X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable</code> </pre> <br><p>  Dan inilah fungsi <code>veryUsefulFunction()</code> (di Linux): </p><br><pre> <code class="plaintext hljs">0000000000000000 &lt;_Z18veryUsefulFunctionv&gt;: 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp 4: 48 8b 05 00 00 00 00 mov rax,QWORD PTR [rip+0x0] b: 8b 0d 00 00 00 00 mov ecx,DWORD PTR [rip+0x0] 11: 83 c1 01 add ecx,0x1 14: 89 0d 00 00 00 00 mov DWORD PTR [rip+0x0],ecx 1a: 8b 08 mov ecx,DWORD PTR [rax] 1c: 03 0d 00 00 00 00 add ecx,DWORD PTR [rip+0x0] 22: 89 c8 mov eax,ecx 24: 5d pop rbp 25: c3 ret</code> </pre> <br><p>  jadi setelah menautkan objek ke pustaka dinamis: </p><br><pre> <code class="plaintext hljs">00000000000010e0 &lt;_Z18veryUsefulFunctionv&gt;: 10e0: 55 push rbp 10e1: 48 89 e5 mov rbp,rsp 10e4: 48 8b 05 05 21 00 00 mov rax,QWORD PTR [rip+0x2105] 10eb: 8b 0d 13 2f 00 00 mov ecx,DWORD PTR [rip+0x2f13] 10f1: 83 c1 01 add ecx,0x1 10f4: 89 0d 0a 2f 00 00 mov DWORD PTR [rip+0x2f0a],ecx 10fa: 8b 08 mov ecx,DWORD PTR [rax] 10fc: 03 0d 02 2f 00 00 add ecx,DWORD PTR [rip+0x2f02] 1102: 89 c8 mov eax,ecx 1104: 5d pop rbp 1105: c3 ret</code> </pre> <br><p>  Ada 4 tempat di mana 4 byte dicadangkan untuk alamat variabel nyata. </p><br><p>  Pada sistem yang berbeda, set kemungkinan relokasi adalah milik Anda.  Di Linux pada x86-64, sebanyak <a href="">40 jenis relokasi</a> .  Hanya ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9</a> di MacOS di x86-64.  Semua jenis relokasi dapat dibagi secara kondisional menjadi 2 kelompok: </p><br><ol><li>  Relokasi waktu tautan - relokasi yang digunakan dalam proses menautkan file objek ke file yang dapat dieksekusi atau perpustakaan dinamis </li><li>  Relokasi waktu pemuatan - relokasi diterapkan pada saat perpustakaan dinamis dimuat ke dalam memori proses </li></ol><br><p>  Kelompok kedua termasuk relokasi fungsi dan variabel yang diekspor.  Ketika perpustakaan dinamis dimuat ke dalam memori proses, untuk semua relokasi dinamis (termasuk relokasi variabel global), linker mencari definisi simbol di semua perpustakaan yang sudah dimuat, termasuk dalam program itu sendiri, dan alamat simbol yang cocok pertama digunakan untuk relokasi.  Jadi, tidak ada yang perlu dilakukan dengan relokasi ini, penghubung akan menemukan variabel dari aplikasi kita sendiri, karena akan masuk ke dalam daftar pustaka dan program yang dimuat sebelumnya, dan mengganti alamatnya dalam kode baru, mengabaikan versi baru dari variabel ini. </p><br><p>  Ada titik halus yang terkait dengan macOS dan penghubung dinamisnya.  MacOS mengimplementasikan apa yang disebut mekanisme namespace dua tingkat.  Jika tidak sopan, maka saat memuat pustaka dinamis, penghubung pertama-tama akan mencari karakter di pustaka ini, dan jika tidak menemukannya, ia akan mencari orang lain.  Ini dilakukan untuk tujuan kinerja, sehingga relokasi diselesaikan dengan cepat, yang pada umumnya logis.  Tapi ini memutus aliran kami terkait variabel global.  Untungnya, ld di macOS memiliki flag khusus - <code>-flat_namespace</code> , dan jika Anda membangun perpustakaan dengan flag ini, maka algoritma pencarian karakter akan identik dengan yang ada di Linux. </p><br><p>  Kelompok pertama termasuk relokasi variabel statis - persis apa yang kita butuhkan.  Satu-satunya masalah adalah bahwa relokasi ini tidak ada di perpustakaan yang dikompilasi, karena mereka sudah diselesaikan oleh linker.  Oleh karena itu, kita akan membacanya dari file objek tempat perpustakaan dikumpulkan. <br>  Kemungkinan jenis relokasi juga dibatasi oleh apakah kode yang dirakit tergantung pada posisi atau tidak.  Karena kami mengumpulkan kode kami dalam mode PIC (kode posisi-independen), relokasi hanya digunakan relatif.  Total relokasi yang menarik bagi kami adalah: </p><br><ul><li>  Relokasi dari bagian <code>.rela.text</code> di Linux dan relokasi yang dirujuk oleh bagian <code>__text</code> di macOS, dan </li><li>  Yang menggunakan karakter dari <code>.bss</code> dan <code>.bss</code> bagian di Linux dan <code>__data</code> , <code>__bss</code> dan <code>__common</code> di macOS, dan </li><li>  Relokasi bertipe <code>R_X86_64_PC32</code> dan <code>R_X86_64_PC64</code> di Linux dan <code>X86_64_RELOC_SIGNED</code> , <code>X86_64_RELOC_SIGNED_1</code> , <code>X86_64_RELOC_SIGNED_2</code> dan <code>X86_64_RELOC_SIGNED_4</code> di macOS </li></ul><br><p>  Titik halus yang terkait dengan bagian <code>__common</code> .  Linux juga memiliki bagian <code>*COM*</code> serupa.  Variabel global dapat jatuh ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian ini</a> .  Tetapi, ketika saya menguji dan menyusun sekelompok potongan kode, di Linux, relokasi karakter dari bagian <code>*COM*</code> selalu dinamis, seperti variabel global reguler.  Pada saat yang sama, pada macOS karakter seperti itu kadang-kadang dipindahkan selama menghubungkan jika fungsi dan karakter berada di file yang sama.  Oleh karena itu, pada MacOS masuk akal untuk mempertimbangkan bagian ini ketika membaca karakter dan relokasi. </p><br><p>  Nah, sekarang kami memiliki satu set semua relokasi yang kami butuhkan, apa yang harus dilakukan dengan mereka?  Logikanya di sini sederhana.  Ketika tautan menghubungkan perpustakaan, itu menulis alamat simbol yang dihitung dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rumus tertentu</a> di alamat relokasi.  Untuk relokasi kami di kedua platform, rumus ini berisi alamat simbol sebagai istilah.  Dengan demikian, alamat terhitung yang sudah direkam dalam tubuh fungsi memiliki bentuk: </p><br><pre> <code class="plaintext hljs">resultAddr = newVarAddr + addend - relocAddr</code> </pre> <br><p>  Pada saat yang sama, kita tahu alamat kedua versi variabel - lama, sudah ada dalam aplikasi, dan baru.  Tetap bagi kami untuk mengubahnya dengan rumus: </p><br><pre> <code class="plaintext hljs">resultAddr = resultAddr - newVarAddr + oldVarAddr</code> </pre> <br><p>  dan menulisnya ke alamat relokasi.  Setelah itu, semua fungsi dalam kode baru akan menggunakan versi variabel yang ada, dan variabel baru hanya akan berbohong dan tidak melakukan apa pun.  Apa yang kamu butuhkan!  Tetapi ada satu titik halus. </p><br><h3 id="zagruzka-biblioteki-s-novym-kodom">  Memuat perpustakaan dengan kode baru </h3><br><p>  Ketika sistem memuat perpustakaan dinamis ke dalam memori proses, itu bebas untuk menempatkannya di mana saja di ruang alamat virtual.  Di Ubuntu 18.04 saya, aplikasi dimuat pada <code>0x00400000</code> , dan perpustakaan dinamis kami tepat setelah <code>ld-2.27.so</code> di alamat di area <code>0x7fd3829bd000</code> .  Jarak antara alamat unduhan program dan pustaka jauh lebih besar daripada jumlah yang akan masuk ke dalam bilangan bulat 32-bit yang ditandatangani.  Dan dalam relokasi tautan waktu, hanya 4 byte yang dicadangkan untuk alamat karakter target. </p><br><p>  Setelah merokok dokumentasi untuk kompiler dan tautan, saya memutuskan untuk mencoba opsi <code>-mcmodel=large</code> .  Itu memaksa kompiler untuk menghasilkan kode tanpa asumsi tentang jarak antara karakter, sehingga semua alamat diasumsikan 64-bit.  Tetapi opsi ini tidak ramah PIC, karena jika <code>-mcmodel=large</code> tidak dapat digunakan dengan <code>-fPIC</code> , setidaknya pada macOS.  Saya masih tidak mengerti apa masalahnya, mungkin di macOS tidak ada relokasi yang cocok untuk situasi ini. </p><br><p>  Di perpustakaan di bawah windows, masalah ini diselesaikan sebagai berikut.  Tangan mengalokasikan sepotong memori virtual di dekat lokasi unduhan aplikasi, cukup untuk mengakomodasi bagian perpustakaan yang diperlukan.  Kemudian bagian dimuat ke dalamnya dengan tangan, hak yang diperlukan diatur ke halaman memori dengan bagian yang sesuai, semua relokasi dibuka ritsleting dengan tangan, dan segala sesuatu yang lain ditambal.  Saya malas  Saya benar-benar tidak ingin melakukan semua pekerjaan ini dengan relokasi waktu buka, terutama di Linux.  Dan mengapa apa yang sudah diketahui oleh seorang penghubung dinamis?  Lagipula, orang-orang yang menulisnya tahu lebih banyak daripada saya. </p><br><p>  Untungnya, dokumentasi tersebut menemukan opsi yang diperlukan untuk menunjukkan tempat mengunduh pustaka dinamis kami: </p><br><ul><li>  Apple ld: <code>-image_base 0xADDRESS</code> </li><li>  LLVM lld: <code>--image-base=0xADDRESS</code> </li><li>  GNU ld: <code>-Ttext-segment=0xADDRESS</code> </li></ul><br><p>  Opsi-opsi ini harus diteruskan ke tautan pada saat menghubungkan perpustakaan dinamis.  Ada 2 kesulitan. <br>  Yang pertama terkait dengan GNU ld.  Agar opsi ini berfungsi, Anda harus: </p><br><ul><li>  Pada saat memuat perpustakaan, area tempat kami ingin memuatnya gratis </li><li>  Alamat yang ditentukan dalam opsi harus kelipatan dari ukuran halaman (pada x86-64 Linux dan macOS adalah <code>0x1000</code> ) </li><li>  Paling tidak di Linux, alamat yang ditentukan dalam opsi harus kelipatan dari penyelarasan segmen <code>PT_LOAD</code> </li></ul><br><p>  Yaitu, jika tautan mengatur perataan ke <code>0x10000000</code> , maka pustaka ini tidak dapat dimuat di alamat <code>0x10001000</code> , bahkan dengan mempertimbangkan bahwa alamat tersebut disejajarkan dengan ukuran halaman.  Jika salah satu dari kondisi ini tidak terpenuhi, perpustakaan akan memuat "seperti biasa".  Saya memiliki GNU ld 2,30 pada sistem saya, dan, tidak seperti LLVM lld, secara default ia menetapkan keselarasan segmen <code>PT_LOAD</code> ke <code>0x20000</code> , yang sangat tidak terlihat.  Untuk menyiasatinya, di samping opsi <code>-Ttext-segment=...</code> , tentukan <code>-z max-page-size=0x1000</code> .  Saya menghabiskan satu hari sampai saya menyadari mengapa perpustakaan tidak memuat di mana saya perlu. </p><br><p>  Kesulitan kedua - alamat unduhan harus diketahui pada tahap menghubungkan perpustakaan.  Tidak terlalu sulit untuk diatur.  Di Linux, cukup mem-parsing pseudo-file <code>/proc/&lt;pid&gt;/maps</code> , menemukan bagian yang tidak dihuni yang paling dekat dengan program, di mana perpustakaan akan cocok, dan menggunakan alamat awal bagian ini ketika menghubungkan.  Ukuran perpustakaan masa depan dapat diperkirakan secara kasar dengan melihat ukuran file objek, atau dengan menguraikannya dan menghitung ukuran semua bagian.  Pada akhirnya, kita tidak perlu angka pastinya, tetapi perkiraan ukuran dengan margin. </p><br><p>  MacOS tidak memiliki <code>/proc/*</code> ; sebagai gantinya, disarankan untuk menggunakan utilitas <code>vmmap</code> .  Output dari perintah <code>vmmap -interleaved &lt;pid&gt;</code> berisi informasi yang sama dengan <code>proc/&lt;pid&gt;/maps</code> .  Tetapi di sini kesulitan lain muncul.  Jika aplikasi membuat proses turunan yang mengeksekusi perintah ini, dan pengidentifikasi proses saat ini ditetapkan sebagai <code>&lt;pid&gt;</code> , program akan hang ketat.  Seperti yang saya pahami, <code>vmmap</code> menghentikan proses untuk membaca pemetaan memorinya, dan tampaknya, jika ini adalah proses pemanggilan, maka ada yang salah.  Dalam hal ini, Anda perlu menentukan flag tambahan <code>-forkCorpse</code> sehingga <code>vmmap</code> membuat proses anak kosong dari proses kami, menghapus pemetaan dari itu dan membunuhnya, sehingga tidak mengganggu program. </p><br><p>  Pada dasarnya itu yang perlu kita ketahui. </p><br><h3 id="sobiraem-vse-vmeste">  Menyatukan semuanya </h3><br><p>  Dengan modifikasi ini, algoritma pemuatan kode akhir terlihat seperti ini: </p><br><ol><li>  Kompilasi kode baru ke file objek </li><li>  Untuk file objek, kami memperkirakan ukuran perpustakaan masa depan </li><li>  Membaca File Objek Relokasi </li><li>  Kami mencari sepotong memori virtual gratis di sebelah aplikasi </li><li>  Kami membangun perpustakaan dinamis dengan opsi yang diperlukan, <code>dlopen</code> melalui <code>dlopen</code> </li><li>  Kode tambalan sesuai dengan relokasi tautan-waktu </li><li>  Fungsi tambalan </li><li>  Salin variabel statis yang tidak berpartisipasi dalam langkah 6 </li></ol><br><p>  Hanya variabel penjaga dari variabel statis yang termasuk dalam langkah 8, sehingga mereka dapat disalin dengan aman (dengan demikian mempertahankan "inisialisasi" dari variabel statis itu sendiri). </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Karena ini hanyalah alat pengembangan, tidak dimaksudkan untuk produksi apa pun, hal terburuk yang dapat terjadi jika pustaka berikutnya dengan kode baru tidak muat ke dalam memori atau secara tidak sengaja memuat di alamat berbeda adalah memulai kembali aplikasi yang di-debug.  Saat menjalankan tes, 31 pustaka dengan kode yang diperbarui dimuat ke dalam memori pada gilirannya. </p><br><p>  Untuk kelengkapan, 3 bagian yang lebih berat tidak ada dalam implementasi: </p><br><ol><li>  Sekarang perpustakaan dengan kode baru dimuat ke dalam memori di sebelah program, meskipun kode dari perpustakaan dinamis lain yang telah dimuat jauh dapat masuk ke dalamnya.  Untuk memperbaikinya, Anda perlu melacak kepemilikan unit terjemahan ke satu atau lain perpustakaan dan program, dan membagi perpustakaan dengan kode baru jika perlu. </li><li>  Memuat ulang kode dalam aplikasi multi-utas masih tidak dapat diandalkan (dengan pasti Anda hanya dapat memuat ulang kode yang berjalan di utas yang sama dengan pustaka runloop).  Untuk perbaikan, perlu untuk memindahkan bagian dari implementasi ke program yang terpisah, dan program ini, sebelum menambal, harus menghentikan proses dengan semua utas, menambal, dan mengembalikannya untuk bekerja.  Saya tidak tahu bagaimana melakukan ini tanpa program eksternal. </li><li>  Pencegahan crash aplikasi yang tidak disengaja setelah kode dimuat ulang.  Setelah memperbaiki kode, Anda dapat secara tidak sengaja mengubah pointer yang tidak valid dalam kode baru, setelah itu Anda harus me-restart aplikasi.  Tidak ada yang salah, tapi tetap saja.  Kedengarannya seperti ilmu hitam, aku masih berpikir. </li></ol><br><p>  Tetapi implementasi saat ini mulai menguntungkan saya secara pribadi, itu sudah cukup untuk digunakan dalam pekerjaan utama saya.  Butuh sedikit membiasakan diri, tetapi penerbangannya normal. <br>  Jika saya sampai pada ketiga poin ini dan menemukan dalam implementasi mereka cukup banyak hal yang menarik, saya pasti akan membagikannya. </p><br><h3 id="demo">  Demo </h3><br><p>  Karena implementasinya memungkinkan penambahan unit siaran baru dengan cepat, saya memutuskan untuk merekam video pendek di mana saya menulis permainan sederhana yang cabul dari awal tentang pesawat ruang angkasa membajak bentangan alam semesta dan menembak asteroid persegi.  Saya mencoba untuk tidak menulis dengan gaya "semua dalam satu file", tetapi, jika mungkin, mengatur semuanya di rak, sehingga menghasilkan banyak file kecil (jadi ada begitu banyak tulisan).  Tentu saja, kerangka ini digunakan untuk menggambar, input, jendela, dan hal-hal lain, tetapi kode permainan itu sendiri ditulis dari awal. <br>  Fitur utama - Saya hanya menjalankan aplikasi 3 kali: pada awalnya, ketika itu hanya memiliki adegan kosong, dan 2 kali setelah jatuh karena kelalaian saya.  Seluruh permainan secara bertahap dituangkan dalam proses penulisan kode.  Waktu nyata - sekitar 40 menit.  Secara umum, Anda dipersilakan. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5xfgViYchqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Seperti biasa, saya akan senang dengan kritik apa pun, terima kasih! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan ke implementasi</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437312/">https://habr.com/ru/post/id437312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437300/index.html">10 keterampilan dan pengetahuan yang diperlukan untuk pengembang iOS pemula</a></li>
<li><a href="../id437304/index.html">Cara membeli kentang jika Anda buta warna</a></li>
<li><a href="../id437306/index.html">Keterampilan yang tidak jelas dibutuhkan oleh manajer produk</a></li>
<li><a href="../id437308/index.html">SDL 2.0 Siklus Pelajaran: Pelajaran 4 - Menangani Acara</a></li>
<li><a href="../id437310/index.html">Batas Gradien CSS</a></li>
<li><a href="../id437314/index.html">Enigma Italia: mesin kriptografi OMI</a></li>
<li><a href="../id437316/index.html">Institut Pengembangan Internet telah menyebutkan situs-situs yang mungkin terputus di RuNet sejak 1 Februari</a></li>
<li><a href="../id437318/index.html">Migrasi yang mulus (hampir) antara rilis PostgreSQL besar menggunakan replikasi logis</a></li>
<li><a href="../id437320/index.html">Indeks Pengembangan Sphere Media 2018: stagnasi televisi, peningkatan kepercayaan terhadap media informal</a></li>
<li><a href="../id437322/index.html">Negara terlibat dalam BigDate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>