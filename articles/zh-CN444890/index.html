<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😅 🤶 👩🏾‍🚀 Linux shell的许多技巧可以节省您的时间 📠 💅🏿 🚠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- 首先，您可以在这里阅读俄语的这篇文章。 
 一天晚上，我正在阅读Jeffrey Friedl的Mastering正则表达式 ，我意识到即使您拥有所有文档和丰富的经验，也可能会有很多由不同的人开发并被囚禁的技巧。 所有人都不一样。 对某些人来说显而易见的技术对其他人可能并不明显，而对于第三人称来说...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux shell的许多技巧可以节省您的时间</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444890/"><div style="text-align:center;"><img width="90%" src="https://habrastorage.org/webt/fs/43/05/fs4305wjukd5umg71ochqeqxxek.png"></div><br><br><ul><li>  <i>首先，您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>阅读俄语的这篇文章。</i> </li></ul><br> 一天晚上，我正在阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jeffrey Friedl的Mastering正则表达式</a> ，我意识到即使您拥有所有文档和丰富的经验，也可能会有很多由不同的人开发并被囚禁的技巧。 所有人都不一样。 对某些人来说显而易见的技术对其他人可能并不明显，而对于第三人称来说却像是某种怪异的魔术。 顺便说一句，我已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里用俄语</a>描述了一些这样的时刻。 <br><br> 对于管理员或用户而言，命令行不仅是可以完成所有任务的工具，而且还是可以永远开发的高度定制的工具。 最近，有一篇有关CLI中一些有用技巧的翻译文章。 但是我觉得翻译人员没有足够的CLI经验，也没有遵循所描述的技巧，因此许多重要的事情可能会被遗漏或误解。 <br><br> 根据我的个人经验，在Linux Shell中有12种技巧。 <br><a name="habracut"></a><br> 注意：本文中的所有脚本和示例都经过了尽可能的简化-也许您会发现一些看起来完全没用的技巧-也许是原因。 但无论如何，请在评论中分享您的想法！ <br><br><h4>  1.使用可变扩展名分割字符串 </h4><br> 人们经常使用<b>cut</b>甚至<b>awk</b>只是通过模式或使用分隔符减去字符串的一部分。 <br> 另外，许多人使用$ {VARIABLE：start_position：length}的子字符串bash操作，其运行速度非常快。 <br><br> 但是bash提供了一种使用＃，##，％和%%处理文本字符串的有效方法-这称为<i>bash变量扩展</i> 。 <br> 使用此语法，您可以在无需执行外部命令的情况下减少模式的需要，因此它将非常快速地工作。 <br><br> 下面的示例显示如何从字符串中获取第三列（shell），其中使用<b>cut</b>或使用变量扩展名（用<u>*：</u> mask和##命令，这意味着：直到找到最后一个冒号为止的所有字符）： <br><br><pre><code class="bash hljs">$ STRING=<span class="hljs-string"><span class="hljs-string">"username:homedir:shell"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 3 shell $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${STRING##*:}</span></span></span><span class="hljs-string">"</span></span> shell</code> </pre> <br> 第二个选项不启动子进程（ <b>cut</b> ），并且根本不使用管道，这样可以更快地工作。 而且，如果您在管道几乎不移动的Windows上使用bash子系统，则速度差异会<u>很大</u> 。 <br><br> 让我们看一下Ubuntu上的示例-循环执行我们的命令1000次 <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash STRING="Name:Date:Shell" echo "using cut" time for A in {1..1000} do cut -d ":" -f 3 &gt; /dev/null &lt;&lt;&lt;"$STRING" done echo "using ##" time for A in {1..1000} do echo "${STRING##*:}" &gt; /dev/null done</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">结果</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh using cut real 0m0.950s user 0m0.012s sys 0m0.232s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.011s user 0m0.008s sys 0m0.004s</span></span></code> </pre></div></div><br> 差别是几十倍！ <br><br> 当然，上面的例子太人为了。 在实际示例中，我们将不使用静态字符串，而是要读取真实文件。 对于' <b>cut</b> '命令，我们只将/ etc / passwd重定向到它。 在##的情况下，我们必须创建一个循环并使用内部的' <b>read</b> '命令读取文件。 那么谁会赢得这场案子呢？ <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash echo "using cut" time for count in {1..1000} do cut -d ":" -f 7 &lt;/etc/passwd &gt; /dev/null done echo "using ##" time for count in {1..1000} do while read do echo "${REPLY##*:}" &gt; /dev/null done &lt;/etc/passwd done</span></span></code> </pre><div class="spoiler">  <b class="spoiler_title">结果</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh $ ./test.sh using cut real 0m0.827s user 0m0.004s sys 0m0.208s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.613s user 0m0.436s sys 0m0.172s</span></span></code> </pre> 没有评论=） </div></div><br> 还有更多示例： <br><br> 提取等号后的值： <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"myClassName = helloClass"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">${VAR##*= }</span></span> helloClass</code> </pre><br> 提取括号中的文本： <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"Hello my friend (enemy)"</span></span> $ TEMP=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${VAR##*\(}</span></span></span><span class="hljs-string">"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${TEMP%\)}</span></span></span><span class="hljs-string">"</span></span> enemy</code> </pre><br><h4>  2. Bash自动补全 </h4><br>  bash-completion软件包几乎是每个Linux发行版的一部分。 您可以在/etc/bash.bashrc或/etc/profile.d/bash_completion.sh中启用它，但通常默认情况下已启用它。 通常，自动完成是新手首先遇到的Linux Shell上的第一个便捷时刻。 <br><br> 但是并非所有人都使用所有bash补全功能这一事实，我认为这完全是徒劳的。 例如，并非所有人都知道，自动完成功能不仅适用于文件名，而且适用于别名，变量名，函数名，甚至适用于某些带有参数的命令。 如果您深入研究自动完成脚本（实际上是shell脚本），甚至<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以</a>为自己的应用程序或脚本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">添加自动完成</a> 。 <br> 但是，让我们回到别名。 <br><br> 您无需编辑PATH变量或在指定目录中创建文件即可运行别名。 您只需要将它们添加到配置文件或启动脚本中，然后在任何位置执行它们即可。 <br><br> 通常，我们在* nix中使用小写字母表示文件和目录，因此创建大写别名非常方便-在这种情况下，bash-completion几乎会用单个字母来<s>猜测</s>您的命令： <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TAsteriskLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/asteriks.log"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TMailLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/mail.log"</span></span> $ TA[tab]steriksLog $ TM[tab]ailLog</code> </pre> <br><h4>  3.使用选项卡进行Bash自动补全-第2部分 </h4><br> 对于更复杂的情况，可能您想将个人脚本放入$ HOME / bin中。 <br> 但是我们在bash中有函数。 <br><br> 函数不需要路径或单独的文件。  （注意）bash补全功能也可以使用。 <br><br> 让我们在<b>.profile中</b>创建函数LastLogin（不要忘记重新加载.profile）： <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> LastLogin { STRING=$(last | head -n 1 | tr -s <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>) USER=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 1) IP=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 3) SHELL=$( grep <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">"</span></span> /etc/passwd | cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"User: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">, IP: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$IP</span></span></span><span class="hljs-string">, SHELL=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SHELL</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br>  <i>（实际上，此函数在做什么并不重要，它只是一个示例脚本，我们可以将其放到单独的脚本中，甚至放到别名中，但功能可能会更好）</i> 。 <br><br> 在控制台中（请注意，函数名的首字母大写以加快bash的完成速度）： <br><br><pre> <code class="bash hljs">$ L[tab]astLogin User: saboteur, IP: 10.0.2.2, SHELL=/bin/bash</code> </pre> <br><h4>  4.1。 敏感数据 </h4><br> 如果您在控制台中的任何命令前放置空格，它将不会出现在命令历史记录中，因此，如果您需要在命令中放置纯文本密码，这是使用此功能的好方法-查看下面的示例， <i>回显“ hello 2”</i>将不会出现在历史记录中： <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> hello $ <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 2011 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> 2012 <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"my password secretmegakey"</span></span> <span class="hljs-comment"><span class="hljs-comment"># there are two spaces before 'echo' my password secretmegakey $ history 2 2011 echo "hello" 2012 history 2</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">它是可选的</b> <div class="spoiler_text"> 通常默认情况下启用它，但是您可以在以下变量中配置此行为： <br><br> 导出HISTCONTROL =忽略两者 </div></div><br><br><h4>  4.2。 命令行参数中的敏感数据 </h4><br> 您想在git中存储一些shell脚本以在服务器之间共享它们，或者可能是应用程序启动脚本的一部分。 并且您希望此脚本将连接到数据库或执行其他需要凭据的操作。 <br><br> 当然，将凭据存储在脚本本身中是个坏主意，因为git是不安全的。 <br><br> 通常，您可以使用已经在目标环境上定义的变量，并且脚本本身不会包含密码。 <br><br> 例如，您可以在具有700个权限的每个环境上创建小脚本，并使用主脚本中的<b>source</b>命令调用它： <br><br><pre> <code class="bash hljs">secret.sh PASSWORD=LOVESEXGOD</code> </pre><br><pre> <code class="bash hljs">myapp.sh <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ~/secret.sh sqlplus -l user/<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PASSWORD</span></span></span><span class="hljs-string">"</span></span>@database:port/sid @mysqfile.sql</code> </pre> <br> 但这并不安全。 <br><br> 如果其他人可以登录到您的主机，则他只需执行<b>ps</b>命令并查看带有整个命令行参数（包括密码）的sqlplus进程。 因此，安全工具通常应该能够直接从文件中读取密码/密钥/敏感数据。 <br><br> 例如-安全<b>ssh</b>甚至没有任何选项可以在命令行中提供密码。 但是他可以从文件读取ssh密钥（并且可以在ssh密钥文件上设置安全权限）。 <br><br> 非安全wget具有选项“ --password”，该选项可让您在命令行中提供密码。  wget一直在运行，每个人都可以执行ps命令并查看您提供的密码。 <br><br> 另外，如果您有很多敏感数据，并且想通过git控制它，那么唯一的方法就是加密。 因此，您只需将每个主密码以及所有其他可以加密并放入git的数据输入到每个目标环境。 而且，您可以使用openssl CLI界面从命令行使用加密的数据。 这是从命令行加密和解密的示例： <br><br> 文件secret.key包含主密钥-单行： <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"secretpassword"</span></span> &gt; secret.key; chmod 600 secret.key</code> </pre> <br> 让我们使用aes-256-cbc加密字符串： <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"string_to_encrypt"</span></span> | openssl enc -pass file:secret.key -e -aes-256-cbc -a U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML</code> </pre> <br> 您可以将此加密的字符串放入git或任何其他位置存储的任何配置文件中-没有secret.key几乎不可能对其进行解密。 <br> 要解密执行相同的命令，只需将-e替换为-d即可： <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML'</span></span> | openssl enc -pass file:secret.key -d -aes-256-cbc -a string_to_encrypt</code> </pre> <br><h4>  5. grep命令 </h4><br> 所有人都应该知道grep命令。 并且对正则表达式要友好。 通常，您可以编写如下内容： <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i error</code> </pre> <br> 甚至像这样： <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i -P <span class="hljs-string"><span class="hljs-string">"(error|warning|failure)"</span></span></code> </pre> <br> 但是不要忘记grep有很多不错的选择。 例如，-v会还原您的搜索并显示除“ info”消息以外的所有消息： <br><br><pre> <code class="bash hljs">tail -f application.log | grep -v -i <span class="hljs-string"><span class="hljs-string">"info"</span></span></code> </pre> <br> 其他内容： <br><br> 选项-P非常有用，因为默认情况下grep使用相当过时的“基本正则表达式：”，并且-P启用PCRE，PCRE甚至不知道分组。 <br>  -i忽略大小写。 <br>  --line-buffered立即解析行，而不是等待到达标准的4k缓冲区（对于tail -f | grep非常有用）。 <br><br> 如果您对正则表达式非常了解，则使用--only-matching / -o可以真正实现剪切文本的出色功能。 只需比较以下两个命令以提取myuser的外壳程序即可： <br><br><pre> <code class="bash hljs">$ grep myuser /etc/passwd| cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7 $ grep -Po <span class="hljs-string"><span class="hljs-string">"^myuser(:.*){5}:\K.*"</span></span> /etc/passwd</code> </pre> <br> 第二个命令看起来更编译，但是它只运行<b>grep</b>而不是<b>grep</b>和<b>cut</b> ，因此执行时间会更少。 <br><br><h4>  6.如何减少日志文件的大小 </h4><br> 在* nix中，如果删除应用程序当前正在使用的日志文件，则不能仅删除所有日志，还可以阻止应用程序在重新启动之前编写新日志。 <br><br> 由于文件描述符不是打开文件名而是打开iNode结构，因此应用程序将继续向没有目录条目的文件写入文件描述符，并且该文件在应用程序停止后由文件系统自动删除（ <i>您的应用程序可以每次想写一些东西来避免这种问题时都要打开和关闭日志文件，但这会影响性能</i> ）。 <br><br> 因此，如何清除日志文件而不删除它： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> &gt; application.log</code> </pre> <br> 或者我们可以使用truncate命令： <br><br><pre> <code class="bash hljs">truncate --size=1M application.log</code> </pre> <br> 提及，该<b>truncate</b>命令将删除文件的其余部分，因此您将丢失最新的日志事件。 另一个示例如何存储最后1000行： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(tail -n 1000 application.log)</span></span></span><span class="hljs-string">"</span></span> &gt; application.log</code> </pre> <br>  <i>PS在Linux中，我们有标准的服务rotatelog。</i>  <i>您可以将日志添加到自动截断/旋转日志中，也可以使用可以满足您要求的现有日志库（例如Java中的log4j）。</i> <br><br><h4>  7. <b>手表</b>在看着你！ </h4><br> 在某些情况下，您正在等待事件结束。 例如，当另一个用户登录到shell（您连续执行<b>who</b>命令）时，或者某人应该使用scp或ftp将文件复制到您的计算机上时，您正在等待完成（重复ls数十次）。 <br><br> 在这种情况下，您可以使用 <br><br><pre> <code class="bash hljs">watch &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt;</code> </pre> <br> 默认情况下，将每隔2秒钟执行一次，且屏幕会预先清除，直到按Ctrl + C为止。 您可以配置执行频率。 <br><br> 当您要观看实时日志时，此功能非常有用。 <br><br><h4>  8.打击顺序 </h4><br> 创建范围非常有用。 例如，而不是像这样： <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 1 2 3 4 5; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br> 您可以编写以下内容： <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> server{1..5}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$srv</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br> 您也可以使用<b>seq</b>命令生成格式化范围。 例如，我们可以使用<b>seq</b>创建值，将根据宽度（00、01而不是0、1）自动调整抽动： <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $(seq -w 5 10); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server05 server06 server07 server08 server09 server10</code> </pre> <br> 使用命令替换的另一个示例-重命名文件。 为了获得不带扩展名的文件名，我们使用“ <b>basename</b> ”命令： <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> name=$(basename <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$file</span></span></span><span class="hljs-string">"</span></span> .txt);mv <span class="hljs-variable"><span class="hljs-variable">$name</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br> 甚至还比'％'更短： <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mv <span class="hljs-variable"><span class="hljs-variable">${file%.txt}</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  PS实际上，对于重命名文件，您可以尝试使用具有很多选项的“ <b>重命名</b> ”工具。 <br><br> 另一个示例-让我们为新的Java项目创建结构： <br><br><pre> <code class="bash hljs">mkdir -p project/src/{main,<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>}/{java,resources}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">结果</b> <div class="spoiler_text"><pre> <code class="python hljs">project/ !--- src/ |--- main/ | |-- java/ | !-- resources/ !--- test/ |-- java/ !-- resources/</code> </pre> </div></div><br><h4>  9.尾巴，多个文件，多个用户... </h4><br> 我已经提到了<b>multitail</b>来读取文件并观看多个实时日志。 但默认情况下未提供该功能，因此安装权限并非总是可用。 <br><br> 但是标准尾巴也可以做到： <br><br><pre> <code class="bash hljs">tail -f /var/logs/*.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span></code> </pre> <br> 还让您记住有关用户的信息，这些用户使用'tail -f'别名查看应用程序日志。 <br> 多个用户可以使用“ tail -f”同时观看日志文件。 他们中有些人的会话不太准确。 由于某种原因，他们可能会将'tail -f'留在后台，而忽略了它。 <br><br> 如果重新启动该应用程序，则有一些正在运行的“ tail -f”进程正在监视不存在的日志文件，该进程可能会挂起几天甚至几个月。 <br><br> 通常这不是一个大问题，但不是整齐的。 <br><br> 如果使用别名查看日志，可以使用--pid选项修改该别名： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TFapplog=<span class="hljs-string"><span class="hljs-string">'tail -f --pid=$(cat /opt/app/tmp/app.pid) /opt/app/logs/app.log'</span></span></code> </pre> <br> 在这种情况下，重新启动目标应用程序时，所有<b>尾部</b>将自动终止。 <br><br><h4>  10.创建具有指定大小的文件 </h4><br>  <b>dd</b>是使用块和二进制数据的最受欢迎的工具之一。 例如，创建1 MB文件并填充零将是： <br><br><pre> <code class="bash hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=out.txt bs=1M count=10</code> </pre> <br> 但我建议使用<b>fallocate</b> ： <br><br><pre> <code class="bash hljs">fallocate -l 10M file.txt</code> </pre> <br> 在支持分配功能（xfs，ext4，Btrfs ...）的文件系统上， <b>fallocate</b>将立即执行，这与dd工具不同。 另外，分配是指实际分配块，而不是创建备用文件。 <br><br><h4>  11. xargs </h4><br> 很多人都知道流行的<b>xargs</b>命令。 但是，并非所有人都使用以下两个选项，因此可以极大地改善脚本。 <br><br> 首先-您可以获得很长的参数列表，可能超过命令行长度（默认情况下〜4 kb）。 <br><br> 但是您可以使用-n选项限制执行，因此<b>xargs</b>将多次运行命令，一次发送指定数量的参数： <br><br><pre> <code class="bash hljs">$ <span class="hljs-comment"><span class="hljs-comment"># lets print 5 arguments and send them to echo with xargs: $ echo 1 2 3 4 5 | xargs echo 1 2 3 4 5 $ # now let's repeat, but limit argument processing by 3 per execution $ echo 1 2 3 4 5 | xargs -n 3 echo 1 2 3 4 5</span></span></code> </pre> <br> 来吧 处理长列表可能需要很多时间，因为它在单个线程中运行。 但是，如果我们有几个核心，我们可以告诉<b>xargs</b>并行运行： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10| xargs -n 2 -P 3 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br> 在上面的示例中，我们告诉<b>xargs</b>处理3个线程中的list； 每个线程每次执行将接受并处理2个参数。 如果您不知道自己有多少个内核，请使用“ <b>nproc</b> ”进行优化： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10 | xargs -n 2 -P $(nproc) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br><h4>  12.睡觉吗？ 一会儿 阅读！ </h4><br> 有时您需要等待几秒钟。 或等待用户输入以下内容： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue "</span></span> -n 1</code> </pre> <br> 但是您只需添加超时选项以<b>读取</b>命令，脚本就会暂停指定的秒数，但是在交互执行的情况下，用户可以轻松跳过等待。 <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue (auto continue in 30 seconds) "</span></span> -t 30 -n 1</code> </pre> <br> 因此，您只需忘记睡眠命令即可。 <br><br> 我怀疑并不是所有的技巧看起来都很有趣，但是在我看来，有十二个数字是可以填写的好数字。 <br><br> 在此，我说再见，感谢您参加调查。 <br><br> 当然可以随意讨论以上内容，并在评论中分享您的绝妙招！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444890/">https://habr.com/ru/post/zh-CN444890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444880/index.html">量子力学的多世界解释</a></li>
<li><a href="../zh-CN444882/index.html">银行开始封锁自由账户</a></li>
<li><a href="../zh-CN444884/index.html">Groovy离开CédricChampeau</a></li>
<li><a href="../zh-CN444886/index.html">混淆后的逆向工程应用</a></li>
<li><a href="../zh-CN444888/index.html">英语和IT：俄罗斯地球上的英语猫头鹰？</a></li>
<li><a href="../zh-CN444892/index.html">美国欺诈者获得数百万美元的假冒微软技术支持</a></li>
<li><a href="../zh-CN444894/index.html">Zabbix 4.2发布</a></li>
<li><a href="../zh-CN444896/index.html">将硬盘驱动器回收为电子垃圾-iNEMI的部分解决方案</a></li>
<li><a href="../zh-CN444898/index.html">如何为无人飞行器（UAV）或机器人选择宽带调制解调器</a></li>
<li><a href="../zh-CN444900/index.html">Vue.js中的表单验证</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>