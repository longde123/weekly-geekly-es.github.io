<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéæ üôâ ü§∑ Experi√™ncia pessoal: passando do desenvolvimento C de baixo n√≠vel para a programa√ß√£o Java üß† ü§î ‚õÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O artigo reflete a experi√™ncia pessoal do autor - um programador √°vido de microcontroladores que, ap√≥s muitos anos de experi√™ncia no desenvolvimento d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Experi√™ncia pessoal: passando do desenvolvimento C de baixo n√≠vel para a programa√ß√£o Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412775/"><img src="https://habrastorage.org/webt/vn/27/lu/vn27lubocfjfz-oiaqgsy7eig5o.jpeg"><br><br>  O artigo reflete a experi√™ncia pessoal do autor - um programador √°vido de microcontroladores que, ap√≥s muitos anos de experi√™ncia no desenvolvimento de microcontroladores em C (e um pouco em C ++), teve a oportunidade de participar de um grande projeto Java para desenvolver software para decodificadores de TV com Android.  Durante esse projeto, pude coletar notas sobre diferen√ßas interessantes entre as linguagens Java e C / C ++, avaliar diferentes abordagens para escrever programas.  O artigo n√£o pretende ser uma refer√™ncia, mas n√£o examina a efici√™ncia e a produtividade dos programas Java.  √â antes uma cole√ß√£o de observa√ß√µes pessoais.  Salvo indica√ß√£o em contr√°rio, esta √© uma vers√£o do Java SE 7. <br><a name="habracut"></a><br><h2>  Diferen√ßas de sintaxe e constru√ß√µes de controle </h2><br>  Em resumo - as diferen√ßas s√£o m√≠nimas, a sintaxe √© muito semelhante.  Os blocos de c√≥digo tamb√©m s√£o formados por um par de chaves {}.  As regras para compilar identificadores s√£o as mesmas que para C / C ++.  A lista de palavras-chave √© quase a mesma que em C / C ++.  Tipos de dados internos - semelhantes aos do C / C ++.  Matrizes - todas tamb√©m s√£o declaradas usando colchetes. <br><br>  O controle constr√≥i a op√ß√£o if-else, while, do-while, for, tamb√©m s√£o quase completamente id√™nticas.  Vale ressaltar que em Java havia r√≥tulos familiares aos programadores C (aqueles que s√£o usados ‚Äã‚Äãcom a palavra-chave goto e cujo uso √© fortemente desencorajado).  No entanto, Java excluiu a possibilidade de alternar para um r√≥tulo usando goto.  Os r√≥tulos devem ser usados ‚Äã‚Äãapenas para sair de loops aninhados: <br><br><pre><code class="java hljs">outer: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { inner: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> inner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> outer; } }</code> </pre> <br>  Para melhorar a legibilidade dos programas em Java, foi adicionada uma oportunidade interessante para separar os d√≠gitos de n√∫meros longos com um sublinhado: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value1 = <span class="hljs-number"><span class="hljs-number">1_500_000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value2 = <span class="hljs-number"><span class="hljs-number">0xAA_BB_CC_DD</span></span>;</code> </pre> <br>  Externamente, um programa Java n√£o √© muito diferente de um programa familiar C. A principal diferen√ßa visual √© que o Java n√£o permite fun√ß√µes, vari√°veis, defini√ß√µes de novos tipos (estruturas), constantes e assim por diante, localizadas "livremente" no arquivo de origem.  Java √© uma linguagem orientada a objetos, portanto, todas as entidades do programa devem pertencer a alguma classe.  Outra diferen√ßa significativa √© a falta de um pr√©-processador.  Essas duas diferen√ßas s√£o descritas em mais detalhes abaixo. <br><br><h2>  Abordagem de objetos na linguagem C </h2><br>  Quando escrevemos grandes programas em C, basicamente temos que trabalhar com objetos.  O papel do objeto aqui √© desempenhado por uma estrutura que descreve uma certa ess√™ncia do "mundo real": <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   ‚Äì ¬´¬ª struct Data { int field; char *str; /* ... */ };</span></span></code> </pre> <br>  Tamb√©m em C existem m√©todos para processar "objetos" - estruturas - fun√ß√µes.  No entanto, fun√ß√µes n√£o s√£o essencialmente mescladas com dados.  Sim, eles geralmente s√£o colocados em um arquivo, mas cada vez √© necess√°rio passar um ponteiro para o objeto a ser processado na fun√ß√£o "t√≠pica": <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result_code; }</code> </pre> <br>  Voc√™ pode usar o "objeto" somente ap√≥s alocar mem√≥ria para armazen√°-lo: <br><br><pre> <code class="java hljs">Data *data = malloc(sizeof(Data));</code> </pre> <br>  Em um programa C, geralmente √© definida uma fun√ß√£o respons√°vel pela inicializa√ß√£o do "objeto" antes de seu primeiro uso: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;field = <span class="hljs-number"><span class="hljs-number">1541</span></span>; data-&gt;str = NULL; }</code> </pre> <br>  Ent√£o o ciclo de vida de um "objeto" em C √© geralmente assim: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*    "" */</span></span> struct Data *data = malloc(sizeof(Data)); <span class="hljs-comment"><span class="hljs-comment">/*  "" */</span></span> init(data); <span class="hljs-comment"><span class="hljs-comment">/*   "" */</span></span> process(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"string"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*  ,  ""     . */</span></span> free(data);</code> </pre> <br>  Agora, listamos os poss√≠veis erros de tempo de execu√ß√£o que podem ser cometidos pelo programador no ciclo de vida do "objeto": <br><br><ol><li>  Esque√ßa de alocar mem√≥ria para o "objeto" </li><li>  Especifique a quantidade incorreta de mem√≥ria alocada </li><li>  Esque√ßa de inicializar o "objeto" </li><li>  Esque√ßa de liberar mem√≥ria depois de usar o objeto </li></ol><br>  Pode ser extremamente dif√≠cil detectar esses erros, pois eles n√£o s√£o detectados pelo compilador e aparecem durante a opera√ß√£o do programa.  Al√©m disso, seu efeito pode ser muito diversificado e afetar outras vari√°veis ‚Äã‚Äãe "objetos" do programa. <br><br><h2>  Abordagem de objeto Java </h2><br>  Diante da OOP - programa√ß√£o orientada a objetos, voc√™ provavelmente j√° ouviu falar de uma das baleias OOP - encapsulamento.  Em Java, diferentemente de C, dados e m√©todos para process√°-los s√£o combinados e s√£o objetos "verdadeiros".  Em termos de POO, isso √© chamado de encapsulamento.  Uma classe √© uma descri√ß√£o de um objeto, o an√°logo mais pr√≥ximo de uma classe em C √© definir um novo tipo usando typedef struct.  Em termos de Java, as fun√ß√µes que pertencem a uma classe s√£o chamadas m√©todos. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Entity { public int field; //   public String str; //   //  public int process(int arg1, String arg2) { /* ... */ return resultCode; } //  public Entity() { field = 1541; str = "value"; } }</span></span></code> </pre> <br>  A ideologia da linguagem Java √© baseada na afirma√ß√£o "tudo √© um objeto".  Portanto, n√£o √© de surpreender que o Java pro√≠ba a cria√ß√£o de m√©todos (fun√ß√µes) e campos de dados (vari√°veis) separadamente da classe.  Mesmo o m√©todo main () familiar, a partir do qual o programa √© iniciado, deve pertencer a uma das classes. <br><br>  Uma defini√ß√£o de classe em Java √© an√°loga a uma declara√ß√£o de estrutura em C. Ao descrever uma classe, voc√™ n√£o cria nada na mem√≥ria.  Um objeto desta classe aparece no momento de sua cria√ß√£o pelo novo operador.  Criar um objeto em Java √© um an√°logo da aloca√ß√£o de mem√≥ria na linguagem C, mas, diferentemente do √∫ltimo, um m√©todo especial √© chamado automaticamente durante a cria√ß√£o do objeto - o construtor do objeto.  O construtor assume o papel da inicializa√ß√£o inicial do objeto - um an√°logo da fun√ß√£o init () discutida anteriormente.  O nome do construtor deve corresponder ao nome da classe.  O construtor n√£o pode retornar um valor. <br><br>  O ciclo de vida de um objeto em um programa Java √© o seguinte: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   (   ,  ) Entity entity = new Entity(); //    entity.process(123, "argument");</span></span></code> </pre> <br>  Observe que o n√∫mero de poss√≠veis erros no programa Java √© muito menor que no programa C. Sim, voc√™ ainda pode esquecer de criar o objeto antes do primeiro uso (o que, no entanto, levar√° a uma NullPointerException facilmente depurada), mas como nos outros erros inerentes Programas C, a situa√ß√£o est√° mudando fundamentalmente: <br><br><ol><li>  N√£o h√° operador sizeof () em Java.  O pr√≥prio compilador Java calcula a quantidade de mem√≥ria para armazenar o objeto.  Portanto, n√£o √© poss√≠vel especificar o tamanho errado da sele√ß√£o. </li><li>  A inicializa√ß√£o do objeto ocorre no momento da cria√ß√£o.  √â imposs√≠vel esquecer a inicializa√ß√£o. </li><li>  A mem√≥ria ocupada pelo objeto n√£o precisa ser liberada; o coletor de lixo faz esse trabalho.  √â imposs√≠vel esquecer de excluir um objeto ap√≥s o uso - h√° menos probabilidade de um efeito de "vazamento de mem√≥ria". </li></ol><br>  Portanto, tudo em Java √© um objeto de uma classe ou de outra.  As exce√ß√µes s√£o primitivas que foram adicionadas ao idioma para melhorar o desempenho e o consumo de mem√≥ria.  Mais sobre os primitivos est√° abaixo. <br><br><h2>  Coletor de mem√≥ria e lixo </h2><br>  Java mant√©m os conceitos familiares de heap and stack para C / C ++, um programador.  Ao criar um objeto com o novo operador, a mem√≥ria para armazenar o objeto √© emprestada da pilha.  No entanto, um link para um objeto (um link √© um an√°logo de um ponteiro), se o objeto criado n√£o fizer parte de outro objeto, √© colocado na pilha.  Na pilha est√£o armazenados os "corpos" dos objetos e na pilha existem vari√°veis ‚Äã‚Äãlocais: refer√™ncias a objetos e tipos primitivos.  Se o heap existir durante a execu√ß√£o do programa e estiver dispon√≠vel para todos os encadeamentos do programa, a pilha pertencer√° ao m√©todo e s√≥ existir√° durante sua execu√ß√£o e tamb√©m n√£o estar√° dispon√≠vel para outros encadeamentos do programa. <br><br>  Java √© desnecess√°rio e mais ainda - voc√™ n√£o pode liberar manualmente a mem√≥ria ocupada por um objeto.  Este trabalho √© realizado pelo coletor de lixo no modo autom√°tico.  O tempo de execu√ß√£o monitora se √© poss√≠vel alcan√ßar cada objeto no heap a partir do local atual do programa, seguindo os links de objeto para objeto.  Caso contr√°rio, esse objeto √© reconhecido como "lixo" e se torna um candidato √† exclus√£o. <br><br>  √â importante observar que a exclus√£o em si n√£o ocorre no momento em que o objeto ‚Äún√£o √© mais necess√°rio‚Äù - o coletor de lixo decide sobre a exclus√£o e a exclus√£o pode ser adiada o quanto for necess√°rio at√© o t√©rmino do programa. <br><br>  Obviamente, o trabalho do coletor de lixo exige sobrecarga do processador.  Mas, em troca, ele alivia o programador de uma grande dor de cabe√ßa associada √† necessidade de liberar mem√≥ria ap√≥s o t√©rmino do uso de "objetos".  De fato, ‚Äúpegamos‚Äù a mem√≥ria quando precisamos dela e a usamos, sem pensar que precisamos liber√°-la depois de n√≥s mesmos. <br><br>  Falando sobre vari√°veis ‚Äã‚Äãlocais, devemos lembrar a abordagem de Java para sua inicializa√ß√£o.  Se em C / C ++ uma vari√°vel local n√£o inicializada contiver um valor aleat√≥rio, o compilador Java simplesmente n√£o permitir√° que ela seja deixada n√£o inicializada: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">//  . System.out.println("" + i); //  !</span></span></code> </pre><br><h2>  Links - Ponteiros de substitui√ß√£o </h2><br>  Java n√£o possui ponteiros; portanto, um programador Java n√£o pode cometer um dos muitos erros que ocorrem ao trabalhar com ponteiros.  Ao criar um objeto, voc√™ obt√©m um link para este objeto: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  entity ‚Äì  . Entity entity = new Entity();</span></span></code> </pre><br>  Em C, o programador teve uma escolha: como passar, digamos, uma estrutura para uma fun√ß√£o.  Voc√™ pode passar por valor: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    . int func(Data data);    ‚Äì   : //    . void process(Data *data);</span></span></code> </pre> <br>  A passagem por valor garantia que a fun√ß√£o n√£o alteraria os dados na estrutura, mas era ineficaz em termos de desempenho - no momento em que a fun√ß√£o foi chamada, uma c√≥pia da estrutura foi criada.  Passar por um ponteiro √© muito mais eficiente: de fato, o endere√ßo na mem√≥ria onde a estrutura est√° localizada foi passado para a fun√ß√£o. <br><br>  Em Java, havia apenas uma maneira de passar um objeto para um m√©todo - por refer√™ncia.  Passar por refer√™ncia em Java √© an√°logo a passar por um ponteiro em C: <br><ul><li>  a c√≥pia (clonagem) de mem√≥ria n√£o ocorre, </li><li>  de fato, o endere√ßo da localiza√ß√£o desse objeto √© transmitido. </li></ul><br>  No entanto, diferentemente do ponteiro da linguagem C, um link Java n√£o pode ser incrementado / decrementado.  ‚ÄúExecutar‚Äù os elementos de uma matriz usando um link para ela em Java n√£o funcionar√°.  Tudo o que pode ser feito com um link √© atribuir um valor diferente. <br><br>  Obviamente, a aus√™ncia de ponteiros, como tal, reduz o n√∫mero de poss√≠veis erros; no entanto, o an√°logo do ponteiro nulo permanece no idioma - uma refer√™ncia nula indicada pela palavra-chave nula. <br><br>  Uma refer√™ncia nula √© uma dor de cabe√ßa para um programador Java, pois  for√ßa a refer√™ncia do objeto a ser verificada como nula antes de us√°-la ou a manipular exce√ß√µes NullPointerException.  Se isso n√£o for feito, o programa falhar√°. <br><br>  Portanto, todos os objetos em Java s√£o transmitidos por links.  Tipos de dados primitivos (int, long, char ...) s√£o passados ‚Äã‚Äãpor valor (mais sobre primitivos s√£o fornecidos abaixo). <br><br><h2>  Recursos do Java Link </h2><br>  O acesso a qualquer objeto no programa √© feito atrav√©s de um link - isso claramente tem um efeito positivo no desempenho, mas pode surpreender um novato: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   entity1   . Entity entity1 = new Entity(); entity1.field = 123; //   entity2,     entity1. //    !   ! Entity entity2 = entity1; //   entity1  entity2         . entity2.field = 777; //  entity1.field  777. System.out.println(entity1.field);</span></span></code> </pre> <br>  Argumentos de m√©todo e valores de retorno - tudo √© passado atrav√©s do link.  Al√©m das vantagens, h√° uma desvantagem em compara√ß√£o com as linguagens C / C ++, onde podemos explicitamente proibir fun√ß√µes de alterar o valor passado por um ponteiro usando um qualificador const: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct Data* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! //    ,    ! data-&gt;field = 0; }</span></span></code> </pre> <br>  Ou seja, a linguagem C permite rastrear esse erro no est√°gio de compila√ß√£o.  Java tamb√©m possui a palavra-chave const, mas √© reservada para vers√µes futuras e atualmente n√£o √© usada.  At√© certo ponto, a palavra-chave final √© chamada para cumprir seu papel.  No entanto, ele n√£o protege o objeto passado para o m√©todo contra altera√ß√µes: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Entity data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . //    final,    . data.field = 0; } }</span></span></code> </pre> <br>  A quest√£o √© que a palavra-chave final, neste caso, √© aplicada ao link, e n√£o ao objeto para o qual o link aponta.  Se final for aplicado √† primitiva, o compilador se comportar√° conforme o esperado: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . value = 0; }</span></span></code> </pre> <br>  Os links Java s√£o muito semelhantes aos links da linguagem C ++. <br><br><h2>  Primitivas Java </h2><br>  Cada objeto Java, al√©m dos campos de dados, cont√©m informa√ß√µes de suporte.  Se queremos operar, por exemplo, em bytes separados e cada byte √© representado por um objeto, no caso de uma matriz de bytes, a sobrecarga de mem√≥ria pode muitas vezes exceder o tamanho utiliz√°vel. <br>  Para que o Java permane√ßa eficiente o suficiente nos casos descritos acima, o suporte para tipos primitivos - primitivos - foi adicionado √† linguagem. <br><table><tbody><tr><th>  Primitivo </th><th>  Ver </th><th>  Profundidade de bits </th><th>  Poss√≠vel anal√≥gico em C </th></tr><tr><td>  byte </td><td rowspan="5">  Inteiro </td><td>  8 </td><td>  char </td></tr><tr><td>  curto </td><td>  16 </td><td>  curto </td></tr><tr><td>  char </td><td>  16 </td><td>  wchar_t </td></tr><tr><td>  int </td><td>  32. </td><td>  int (longo) </td></tr><tr><td>  longo </td><td>  64 </td><td>  longo </td></tr><tr><td>  flutuar </td><td>  N√∫meros de ponto flutuante </td><td>  32. </td><td>  flutuar </td></tr><tr><td>  dobrar </td><td></td><td>  64 </td><td>  dobrar </td></tr><tr><td>  booleano </td><td>  Logical </td><td>  - </td><td>  int (C89) / bool (C99) </td></tr></tbody></table><br>  Todas as primitivas t√™m seus an√°logos na linguagem C. No entanto, o padr√£o C n√£o determina o tamanho exato dos tipos inteiros; em vez disso, o intervalo de valores que esse tipo pode armazenar √© fixo.  Freq√ºentemente, o programador deseja garantir a mesma profundidade de bits para m√°quinas diferentes, o que leva ao aparecimento de tipos como uint32_t no programa, embora todas as fun√ß√µes da biblioteca exijam argumentos do tipo int. <br>  Este fato n√£o pode ser atribu√≠do √†s vantagens da linguagem. <br><br>  Primitivas inteiras Java, ao contr√°rio de C, t√™m profundidades de bits fixas.  Portanto, voc√™ n√£o precisa se preocupar com a profundidade de bits real da m√°quina na qual o programa Java est√° sendo executado, nem com a ordem dos bytes ("rede" ou "Intel").  Esse fato ajuda a compreender o princ√≠pio "ele √© escrito uma vez - √© cumprido em toda parte". <br><br>  Al√©m disso, em Java, todas as primitivas inteiras s√£o assinadas (o idioma n√£o possui a palavra-chave n√£o assinada).  Isso elimina a dificuldade de usar vari√°veis ‚Äã‚Äãassinadas e n√£o assinadas em uma √∫nica express√£o inerente a C. <br><br>  Em conclus√£o, a ordem dos bytes nas primitivas de v√°rios bytes em Java √© fixa (byte baixo no endere√ßo baixo, Little-endian, ordem reversa). <br><br>  As desvantagens da implementa√ß√£o de opera√ß√µes com primitivas em Java incluem o fato de que aqui, como no programa C / C ++, o estouro da grade de bits pode ocorrer, sem exce√ß√µes: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = (i1 + i2); <span class="hljs-comment"><span class="hljs-comment">// r = -16</span></span></code> </pre> <br>  Portanto, os dados em Java s√£o representados por dois tipos de entidades: objetos e primitivas.  As primitivas violam o conceito de "tudo √© um objeto", mas em algumas situa√ß√µes elas s√£o eficazes demais para n√£o us√°-las. <br><br><h2>  Heran√ßa </h2><br>  A heran√ßa √© outra baleia OOP da qual voc√™ provavelmente j√° ouviu falar.  Se voc√™ responder brevemente √† pergunta "por que a heran√ßa √© necess√°ria", a resposta ser√° "reutiliza√ß√£o de c√≥digo". <br><br>  Suponha que voc√™ programe em C e tenha uma "classe" bem escrita e depurada - uma estrutura e fun√ß√µes para process√°-la.  Em seguida, surge a necessidade de criar uma "classe" semelhante, mas com funcionalidade aprimorada, e a "classe" b√°sica ainda √© necess√°ria.  No caso da linguagem C, voc√™ tem apenas uma maneira de resolver esse problema - composi√ß√£o.  Trata-se de criar uma nova estrutura estendida - "classe", que deve conter um ponteiro para a estrutura "classe" base: <br><br><pre> <code class="java hljs">struct Base { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field1; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *field2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baseMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Base *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; struct Extended { struct Base *base; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> auxField; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extendedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Extended *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ baseMethod(obj-&gt;base, <span class="hljs-number"><span class="hljs-number">123</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Java como uma linguagem orientada a objetos permite estender a funcionalidade de classes existentes usando o mecanismo de heran√ßa: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Base { protected int baseField; private int hidden; public void baseMethod() { } } //   -   . class Extended extends Base { public void extendedMethod() { //    public  protected     . baseField = 123; baseMethod(); // !   private  ! hidden = 123; } }</span></span></code> </pre> <br>  Deve-se notar que o Java de forma alguma pro√≠be o uso da composi√ß√£o como uma maneira de estender a funcionalidade de classes j√° escritas.  Al√©m disso, em muitas situa√ß√µes, a composi√ß√£o √© prefer√≠vel √† heran√ßa. <br><br>  Gra√ßas √† heran√ßa, as classes em Java s√£o organizadas em uma estrutura hier√°rquica, cada classe necessariamente tem um e apenas um "pai" e pode ter qualquer n√∫mero de "filhos".  Ao contr√°rio do C ++, uma classe em Java n√£o pode herdar de mais de um pai (isso resolve o problema da "heran√ßa de diamante"). <br><br>  Durante a heran√ßa, a classe derivada obt√©m em seu local todos os campos e m√©todos p√∫blicos e protegidos de sua classe base, bem como a classe base de sua classe base e assim por diante na hierarquia de heran√ßa. <br><br>  No topo da hierarquia de heran√ßa est√° o progenitor comum de todas as classes Java - a classe Object, a √∫nica que n√£o possui um pai. <br><br><h2>  Identifica√ß√£o din√¢mica do tipo </h2><br>  Um dos pontos principais da linguagem Java √© o suporte √† identifica√ß√£o din√¢mica de tipo (RTTI).  Em palavras simples, o RTTI permite substituir um objeto de uma classe derivada em que √© necess√°ria uma refer√™ncia √† base: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     Base link; //         link = new Extended();</span></span></code> </pre><br>  Tendo um link em tempo de execu√ß√£o, √© poss√≠vel determinar o tipo verdadeiro do objeto ao qual o link se refere - usando o operador instanceof: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Base) { <span class="hljs-comment"><span class="hljs-comment">// false } else if (link instanceof Extended) { // true }</span></span></code> </pre> <br><h2>  Substitui√ß√µes de m√©todo </h2><br>  Redefinir um m√©todo ou fun√ß√£o significa substituir seu corpo no est√°gio de execu√ß√£o do programa.  Os programadores C est√£o cientes da capacidade de uma linguagem de alterar o comportamento de uma fun√ß√£o durante a execu√ß√£o do programa.  √â sobre o uso de ponteiros de fun√ß√£o.  Por exemplo, voc√™ pode incluir um ponteiro para uma fun√ß√£o na estrutura da estrutura e atribuir v√°rias fun√ß√µes ao ponteiro para alterar o algoritmo de processamento de dados dessa estrutura: <br><br><pre> <code class="java hljs">struct Object { <span class="hljs-comment"><span class="hljs-comment">//   . void (*process)(struct Object *); int data; }; void divideByTwo(struct Object *obj) { obj-&gt;data = obj-&gt;data / 2; } void square(struct Object *obj) { obj-&gt;data = obj-&gt;data * obj-&gt;data; } struct Object obj; obj.data = 123; obj.process = divideByTwo; obj.process(&amp;obj); // 123 / 2 = 61 obj.process = square; obj.process(&amp;obj); // 61 * 61 = 3721</span></span></code> </pre> <br>  Em Java, como em outras linguagens OOP, a substitui√ß√£o de m√©todos est√° inextricavelmente vinculada √† heran√ßa.  Uma classe derivada obt√©m acesso aos m√©todos p√∫blicos e protegidos da classe base.  Al√©m do fato de ele poder cham√°-los, voc√™ pode alterar o comportamento de um dos m√©todos da classe base sem alterar sua assinatura.  Para fazer isso, basta definir um m√©todo com exatamente a mesma assinatura na classe derivada: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   . class Extended extends Base { //  . public void method() { /* ... */ } //     ! // E      . //     . public void method(int i) { /* ... */ } }</span></span></code> </pre> <br>  √â muito importante que a assinatura (nome do m√©todo, valor de retorno, argumentos) corresponda exatamente.  Se o nome do m√©todo corresponder e os argumentos diferirem, o m√©todo ser√° sobrecarregado, mais sobre o que est√° abaixo. <br><br><h2>  Polimorfismo </h2><br>  Como o encapsulamento e a heran√ßa, a terceira baleia POO - polimorfismo - tamb√©m possui algum tipo de an√°logo na linguagem C orientada a procedimentos. <br><br>  Suponha que tenhamos v√°rias "classes" de estruturas com as quais voc√™ deseja executar o mesmo tipo de a√ß√£o, e a fun√ß√£o que executa essa a√ß√£o deve ser universal - deve "ser capaz" de trabalhar com qualquer "classe" como argumento.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma solu√ß√£o poss√≠vel √© a seguinte: </font></font><br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Ids { ID_A, ID_B }; struct ClassA { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassA obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_A; } struct ClassB { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassB obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_B; } <span class="hljs-comment"><span class="hljs-comment">/* klass -   ClassA, ClassB, ... */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commonFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *klass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)klass; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_A: ClassA *obj = (ClassA *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_B: ClassB *obj = (ClassB *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A solu√ß√£o parece complicada, mas o objetivo √© alcan√ßado - a fun√ß√£o universal commonFunc () aceita o "objeto" de qualquer "classe" como argumento. </font><font style="vertical-align: inherit;">Um pr√©-requisito √© uma estrutura de "classe" no primeiro campo deve conter um identificador pelo qual a "classe" real do objeto √© determinada. </font><font style="vertical-align: inherit;">Essa solu√ß√£o √© poss√≠vel devido ao uso do argumento com o tipo "void *". </font><font style="vertical-align: inherit;">No entanto, um ponteiro de qualquer tipo pode ser passado para essa fun√ß√£o, por exemplo, "int *". </font><font style="vertical-align: inherit;">Isso n√£o causar√° erros de compila√ß√£o, mas em tempo de execu√ß√£o, o programa se comportar√° de forma imprevis√≠vel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos ver como o polimorfismo se parece em Java (no entanto, como em qualquer outra linguagem OOP). </font><font style="vertical-align: inherit;">Suponha que temos muitas classes que devem ser processadas da mesma maneira por algum m√©todo. </font><font style="vertical-align: inherit;">Ao contr√°rio da solu√ß√£o para a linguagem C apresentada acima, esse m√©todo polim√≥rfico DEVE ser inclu√≠do em todas as classes do conjunto fornecido e todas as suas vers√µes DEVEM ter a mesma assinatura.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, voc√™ precisa for√ßar o compilador a chamar exatamente a vers√£o do m√©todo que pertence √† classe correspondente. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_set_of_class_ klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou seja, o m√©todo executor (), que pode estar em qualquer parte do programa, deve poder trabalhar com qualquer classe do conjunto (A, B ou C). </font><font style="vertical-align: inherit;">De alguma forma, devemos "dizer" ao compilador que _set_of_class_ indica nossas muitas classes. </font><font style="vertical-align: inherit;">Aqui a heran√ßa √© √∫til - √© necess√°rio criar todas as classes a partir das derivadas definidas de alguma classe base, que conter√£o um m√©todo polim√≥rfico:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }   executor()   : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Base klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E agora qualquer classe que √© herdeira de Base (gra√ßas √† identifica√ß√£o din√¢mica de tipo) pode ser passada a ela como argumento: </font></font><br><br><pre> <code class="java hljs">executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependendo de qual objeto de classe √© passado como argumento, um m√©todo pertencente a essa classe ser√° chamado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A palavra-chave abstract permite excluir o corpo do m√©todo (torn√°-lo abstrato, em termos de POO). </font><font style="vertical-align: inherit;">De fato, estamos dizendo ao compilador que esse m√©todo deve ser substitu√≠do nas classes derivadas dele. </font><font style="vertical-align: inherit;">Se n√£o for esse o caso, ocorre um erro de compila√ß√£o. </font><font style="vertical-align: inherit;">Uma classe que cont√©m pelo menos um m√©todo abstrato tamb√©m √© chamada de abstrata. </font><font style="vertical-align: inherit;">O compilador exige marcar essas classes tamb√©m com o resumo da palavra-chave.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estrutura de projeto Java </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em Java, todos os arquivos de origem t√™m a extens√£o * .java. </font><font style="vertical-align: inherit;">Os arquivos de cabe√ßalho * .h e os prot√≥tipos de fun√ß√µes ou classes est√£o ausentes. </font><font style="vertical-align: inherit;">Cada arquivo de origem Java deve conter pelo menos uma classe. </font><font style="vertical-align: inherit;">O nome da classe √© habitual para escrever, come√ßando com uma letra mai√∫scula. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√°rios arquivos com c√≥digo fonte podem ser combinados em um pacote. </font><font style="vertical-align: inherit;">Para fazer isso, as seguintes condi√ß√µes devem ser atendidas:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arquivos com c√≥digo-fonte devem estar no mesmo diret√≥rio no sistema de arquivos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O nome deste diret√≥rio deve corresponder ao nome do pacote. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No in√≠cio de cada arquivo de origem, o pacote ao qual esse arquivo pertence deve ser indicado, por exemplo: </font></font></li></ol><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.company.pkg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para garantir a exclusividade dos nomes de pacotes no mundo, √© proposto o uso do nome de dom√≠nio "invertido" da empresa. </font><font style="vertical-align: inherit;">No entanto, isso n√£o √© um requisito e qualquer nome pode ser usado no projeto local. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m √© recomend√°vel que voc√™ especifique nomes de pacotes em min√∫sculas. </font><font style="vertical-align: inherit;">Portanto, eles podem ser facilmente distinguidos dos nomes das classes.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oculta√ß√£o da implementa√ß√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro aspecto do encapsulamento √© a separa√ß√£o da interface e implementa√ß√£o. Se a interface estiver acess√≠vel para as partes externas do programa (externas ao m√≥dulo ou classe), a implementa√ß√£o estar√° oculta. Na literatura, uma analogia da caixa preta √© frequentemente desenhada quando a implementa√ß√£o interna ‚Äún√£o √© vis√≠vel‚Äù do lado de fora, mas o que √© inserido na entrada da caixa e o que ele fornece √© ‚Äúvis√≠vel‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em C, ocultar implementa√ß√µes √© realizada dentro de um m√≥dulo, marcando fun√ß√µes que n√£o devem ser vis√≠veis do lado de fora com a palavra-chave est√°tica. Os prot√≥tipos das fun√ß√µes que comp√µem a interface do m√≥dulo s√£o colocados no arquivo de cabe√ßalho. Um m√≥dulo em C significa um par: um arquivo de origem com a extens√£o *. Ce um cabe√ßalho com a extens√£o *. H.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java tamb√©m possui a palavra-chave est√°tica, mas n√£o afeta a "visibilidade" do m√©todo ou campo de fora. </font><font style="vertical-align: inherit;">Para controlar a ‚Äúvisibilidade‚Äù, existem 3 modificadores de acesso: privado, protegido e p√∫blico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os campos e m√©todos de uma classe marcada como privada est√£o dispon√≠veis apenas dentro dela. </font><font style="vertical-align: inherit;">Os campos e m√©todos protegidos tamb√©m s√£o acess√≠veis aos descendentes de classe. </font><font style="vertical-align: inherit;">O modificador p√∫blico significa que o elemento marcado √© acess√≠vel de fora da classe, ou seja, faz parte da interface. </font><font style="vertical-align: inherit;">Tamb√©m √© poss√≠vel que n√£o haja modificador; nesse caso, o acesso ao elemento de classe √© limitado pelo pacote em que a classe est√° localizada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â recomend√°vel que, ao escrever uma classe, marque inicialmente todos os campos da classe como privado e estenda os direitos de acesso conforme necess√°rio.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobrecarga de m√©todo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dos recursos irritantes da biblioteca padr√£o C √© a presen√ßa de um zool√≥gico inteiro de fun√ß√µes que executam essencialmente a mesma coisa, mas diferem no tipo de argumento, por exemplo: fabs (), fabsf (), fabsl () - fun√ß√µes para obter o valor absoluto de double, float e long tipos duplos, respectivamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java (assim como C ++) suporta um mecanismo de sobrecarga de m√©todo - pode haver v√°rios m√©todos em uma classe com um nome completamente id√™ntico, mas diferentes no tipo e no n√∫mero de argumentos. </font><font style="vertical-align: inherit;">Pelo n√∫mero de argumentos e seu tipo, o compilador escolher√° a vers√£o necess√°ria do pr√≥prio m√©todo - √© muito conveniente e melhora a legibilidade do programa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em Java, diferentemente do C ++, os operadores n√£o podem ser sobrecarregados. </font><font style="vertical-align: inherit;">A exce√ß√£o s√£o os operadores "+" e "+ =", que s√£o inicialmente sobrecarregados para as seq√º√™ncias de caracteres String.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caracteres e seq√º√™ncias de caracteres em Java </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em C, voc√™ precisa trabalhar com cadeias de terminal nulo representadas por ponteiros para o primeiro caractere: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str; <span class="hljs-comment"><span class="hljs-comment">//  ASCII  wchar_t *strw; //   "" </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essas linhas devem terminar com um caractere nulo. </font><font style="vertical-align: inherit;">Se for acidentalmente "apagado", uma sequ√™ncia ser√° considerada uma sequ√™ncia de bytes na mem√≥ria at√© o primeiro caractere nulo. </font><font style="vertical-align: inherit;">Ou seja, se outras vari√°veis ‚Äã‚Äãde programa forem colocadas na mem√≥ria ap√≥s a linha, depois de modificar uma linha danificada, seus valores poder√£o (e provavelmente ser√£o) distorcidos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, um programador C n√£o √© obrigado a usar seq√º√™ncias de terminais nulos cl√°ssicas, mas aplica uma implementa√ß√£o de terceiros, mas aqui deve-se ter em mente que todas as fun√ß√µes da biblioteca padr√£o requerem sequ√™ncias de terminais nulos como argumentos. </font><font style="vertical-align: inherit;">Al√©m disso, o padr√£o C n√£o define a codifica√ß√£o usada, este ponto tamb√©m deve ser controlado pelo programador.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em Java, o tipo de caractere primitivo (assim como o wrapper Character, sobre os wrappers abaixo) representa um √∫nico caractere de acordo com o padr√£o Unicode. A codifica√ß√£o UTF-16 √© usada, respectivamente, um caractere ocupa 2 bytes na mem√≥ria, o que permite codificar quase todos os caracteres dos idiomas usados ‚Äã‚Äãatualmente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os caracteres podem ser especificados por seu Unicode:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch1 = <span class="hljs-string"><span class="hljs-string">'\u20BD'</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o Unicode de um caractere exceder o m√°ximo de 216 para char, esse caractere dever√° ser representado por int. Na sequ√™ncia, ele ocupar√° 2 caracteres de 16 bits, mas, novamente, caracteres com um c√≥digo superior a 216 s√£o usados ‚Äã‚Äãraramente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As seq√º√™ncias Java s√£o implementadas pela classe String incorporada e armazenam caracteres char de 16 bits. A classe String cont√©m tudo ou quase tudo o que pode ser necess√°rio para trabalhar com seq√º√™ncias de caracteres. N√£o h√° necessidade de pensar no fato de que a linha deve necessariamente terminar com zero; aqui √© imposs√≠vel imperceptivelmente "limpar" esse caractere de termina√ß√£o zero ou acessar a mem√≥ria al√©m da linha. Em geral, ao trabalhar com seq√º√™ncias de caracteres em Java, o programador n√£o pensa em como a sequ√™ncia √© armazenada na mem√≥ria.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como mencionado acima, Java n√£o permite sobrecarga de operador (como em C ++), no entanto, a classe String √© uma exce√ß√£o - somente para ela os operadores de mesclagem de linha "+" e "+ =" s√£o inicialmente sobrecarregados. </font></font><br><br><pre> <code class="java hljs">String str1 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + <span class="hljs-string"><span class="hljs-string">"World!"</span></span>; String str2 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span>; str2 += <span class="hljs-string"><span class="hljs-string">"World!"</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale ressaltar que as strings em Java s√£o imut√°veis ‚Äã‚Äã- uma vez criadas, elas n√£o permitem sua altera√ß√£o. </font><font style="vertical-align: inherit;">Quando tentamos alterar a linha, por exemplo, assim:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; str.toUpperCase(); System.out.println(str); <span class="hljs-comment"><span class="hljs-comment">//   "Hello, World!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, a string original n√£o muda realmente. </font><font style="vertical-align: inherit;">Em vez disso, √© criada uma c√≥pia modificada da sequ√™ncia original, que por sua vez tamb√©m √© imut√°vel:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; String str2 = str.toUpperCase(); System.out.println(str2); <span class="hljs-comment"><span class="hljs-comment">//   "HELLO, WORLD!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, cada altera√ß√£o de uma string na realidade resulta na cria√ß√£o de um novo objeto (de fato, nos casos de mesclagem de strings, o compilador pode otimizar o c√≥digo e usar a classe StringBuilder, que ser√° discutida mais adiante). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acontece que o programa geralmente precisa mudar a mesma linha. </font><font style="vertical-align: inherit;">Nesses casos, para otimizar a velocidade do programa e o consumo de mem√≥ria, voc√™ pode impedir a cria√ß√£o de novos objetos de linha. </font><font style="vertical-align: inherit;">Para esses prop√≥sitos, a classe StringBuilder deve ser usada:</font></font><br><br><pre> <code class="java hljs">String sourceString = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(sourceString); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.append(<span class="hljs-string"><span class="hljs-string">"!!"</span></span>); String changedString = builder.toString(); System.out.println(changedString); <span class="hljs-comment"><span class="hljs-comment">//   "Hell0, W0rld!!!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separadamente, vale a pena mencionar a compara√ß√£o de strings. </font><font style="vertical-align: inherit;">Um erro t√≠pico de um programador iniciante em Java √© comparar cadeias usando o operador "==":</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    "Yes" // ! if (usersInput == "Yes") { //    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse c√≥digo n√£o cont√©m formalmente erros no est√°gio de compila√ß√£o ou erros de tempo de execu√ß√£o, mas funciona de maneira diferente do esperado. </font><font style="vertical-align: inherit;">Como todos os objetos e cadeias, inclusive em Java, s√£o representados por links, a compara√ß√£o com o operador ‚Äú==‚Äù fornece uma compara√ß√£o de links, n√£o valores de objetos. </font><font style="vertical-align: inherit;">Ou seja, o resultado ser√° verdadeiro apenas se 2 links realmente se referirem √† mesma linha. </font><font style="vertical-align: inherit;">Se as strings s√£o objetos diferentes na mem√≥ria e voc√™ precisa comparar seus conte√∫dos, use o m√©todo equals ():</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (usersInput.equals(<span class="hljs-string"><span class="hljs-string">"Yes"</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O mais surpreendente √© que, em alguns casos, a compara√ß√£o usando o operador "==" funciona corretamente: </font></font><br><br><pre> <code class="java hljs">String someString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, anotherString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   "true": System.out.println(someString == anotherString);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso ocorre porque, na realidade, someString e anotherString se referem ao mesmo objeto na mem√≥ria. </font><font style="vertical-align: inherit;">O compilador coloca os mesmos literais de string no pool de strings - ocorre o chamado internamento. </font><font style="vertical-align: inherit;">Ent√£o, toda vez que a mesma string literal aparece no programa, um link para a string do pool √© usado. </font><font style="vertical-align: inherit;">O internamento de strings √© precisamente poss√≠vel devido √† propriedade de imutabilidade de strings. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora a compara√ß√£o do conte√∫do de cadeias de caracteres seja permitida apenas pelo m√©todo equals (), em Java, √© poss√≠vel usar corretamente cadeias de caracteres em constru√ß√µes de casos de comuta√ß√£o (come√ßando com Java 7):</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(); <span class="hljs-comment"><span class="hljs-comment">// ... switch (str) { case "string_value_1": // ... break; case "string_value_2": // ... break; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curiosamente, qualquer objeto Java pode ser convertido em uma string. </font><font style="vertical-align: inherit;">O m√©todo toString () correspondente √© definido na classe base para todas as classes da classe Object.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abordagem de tratamento de erros </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao programar em C, voc√™ pode criar a seguinte abordagem de tratamento de erros. Cada fun√ß√£o de uma biblioteca retorna um tipo int. Se a fun√ß√£o for bem-sucedida, esse resultado ser√° 0. Se o resultado for diferente de zero, isso indica um erro. Na maioria das vezes, o c√≥digo de erro √© passado pelo valor retornado pela fun√ß√£o. Como a fun√ß√£o pode retornar apenas um valor e j√° est√° ocupada pelo c√≥digo de erro, o resultado real da fun√ß√£o deve ser retornado atrav√©s do argumento como um ponteiro, por exemplo, assim:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data **result, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> errorCode; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A prop√≥sito, este √© um dos casos em que, em um programa C, torna-se necess√°rio usar um ponteiro para um ponteiro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Äs vezes, eles usam uma abordagem diferente. A fun√ß√£o n√£o retorna um c√≥digo de erro, mas diretamente o resultado de sua execu√ß√£o, geralmente na forma de um ponteiro. Uma situa√ß√£o de erro √© indicada com um ponteiro nulo. Em seguida, a biblioteca geralmente cont√©m uma fun√ß√£o separada que retorna o c√≥digo do √∫ltimo erro:</font></font><br><br><pre> <code class="java hljs">struct Data* function(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *arg); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLastError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De uma maneira ou de outra, ao programar em C, o c√≥digo que funciona ‚Äú√∫til‚Äù e o c√≥digo respons√°vel pelo tratamento de erros se entrela√ßam, o que obviamente n√£o facilita a leitura do programa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em Java, se desejar, voc√™ pode usar as abordagens descritas acima, mas aqui voc√™ pode aplicar uma maneira completamente diferente de lidar com erros - tratamento de exce√ß√µes (no entanto, como em C ++). A vantagem do tratamento de exce√ß√µes √© que, nesse caso, o c√≥digo ‚Äú√∫til‚Äù e o c√≥digo respons√°vel pelo tratamento de erros e conting√™ncias s√£o separados logicamente um do outro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso √© conseguido usando constru√ß√µes try-catch: o c√≥digo ‚Äú√∫til‚Äù √© colocado na se√ß√£o try e o c√≥digo de tratamento de erros √© colocado na se√ß√£o catch.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//       try (FileReader reader = new FileReader("path\\to\\file.txt")) { //    -   . while (reader.read() != -1){ // ... } } catch (IOException ex) { //     }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√° situa√ß√µes em que n√£o √© poss√≠vel processar corretamente o erro no local de sua ocorr√™ncia. </font><font style="vertical-align: inherit;">Nesses casos, uma indica√ß√£o √© colocada na assinatura do m√©todo de que o m√©todo pode causar esse tipo de exce√ß√£o:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, a chamada para esse m√©todo deve necessariamente ser enquadrada em um bloco try-catch, ou o m√©todo de chamada tamb√©m deve ser marcado para que possa gerar essa exce√ß√£o. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Falta de pr√©-processador </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por mais conveniente que seja o pr√©-processador familiar aos programadores de C / C ++, ele est√° ausente na linguagem Java. </font><font style="vertical-align: inherit;">Os desenvolvedores de Java provavelmente decidiram que ele √© usado apenas para garantir a portabilidade dos programas e, como o Java roda em quase todos os lugares, um pr√©-processador n√£o √© necess√°rio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode compensar a falta de um pr√©-processador usando um campo de sinalizador est√°tico e verificar seu valor no programa, quando necess√°rio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se estamos falando sobre a organiza√ß√£o dos testes, √© poss√≠vel usar anota√ß√µes em conjunto com reflex√£o (reflex√£o).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma matriz tamb√©m √© um objeto. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao trabalhar com matrizes em C, a sa√≠da do √≠ndice al√©m dos limites da matriz √© um erro muito insidioso. </font><font style="vertical-align: inherit;">O compilador n√£o o reportar√° de forma alguma e, durante a execu√ß√£o, o programa n√£o ser√° parado com a mensagem correspondente:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> array[<span class="hljs-number"><span class="hljs-number">5</span></span>]; array[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">666</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provavelmente, o programa continuar√° a execu√ß√£o, mas o valor da vari√°vel localizada ap√≥s a matriz do exemplo acima ser√° distorcida. Depurar esse tipo de erro pode n√£o ser f√°cil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em Java, o programador est√° protegido contra esse tipo de erros dif√≠ceis de diagnosticar. Quando voc√™ tenta ir al√©m dos limites da matriz, uma ArrayIndexOutOfBoundsException √© lan√ßada. Se a captura de exce√ß√£o n√£o foi programada usando a constru√ß√£o try-catch, o programa trava e uma mensagem correspondente √© enviada ao fluxo de erros padr√£o indicando o arquivo com o c√≥digo-fonte e o n√∫mero da linha em que a matriz foi excedida. Ou seja, o diagn√≥stico de tais erros se torna uma quest√£o trivial.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse comportamento do programa Java √© poss√≠vel porque a matriz em Java √© representada por um objeto. </font><font style="vertical-align: inherit;">A matriz Java n√£o pode ser redimensionada; seu tamanho √© codificado no momento em que a mem√≥ria √© alocada. </font><font style="vertical-align: inherit;">Em tempo de execu√ß√£o, obter o tamanho da matriz √© t√£o simples quanto isso:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arraySize = array.length; <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se falamos de matrizes multidimensionais, comparado com a linguagem C, o Java oferece uma oportunidade interessante para organizar matrizes "ladder". </font><font style="vertical-align: inherit;">Para o caso de uma matriz bidimensional, o tamanho de cada linha individual pode ser diferente do restante:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) { array[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como em C, os elementos da matriz est√£o localizados na mem√≥ria, um por um, portanto, o acesso √† matriz √© considerado o mais eficiente. </font><font style="vertical-align: inherit;">Se voc√™ precisar executar opera√ß√µes de inser√ß√£o / exclus√£o de elementos ou criar estruturas de dados mais complexas, precisar√° usar cole√ß√µes, como um conjunto (Conjunto), uma lista (Lista), um mapa (Mapa). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devido √† falta de ponteiros e √† incapacidade de incrementar links, o acesso aos elementos da matriz √© poss√≠vel usando √≠ndices.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colec√ß√µes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muitas vezes, a funcionalidade de matrizes n√£o √© suficiente - √© necess√°rio usar estruturas de dados din√¢micas. Como a biblioteca C padr√£o n√£o cont√©m uma implementa√ß√£o pronta de estruturas de dados din√¢micas, voc√™ deve usar a implementa√ß√£o em c√≥digos-fonte ou na forma de bibliotecas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferentemente de C, a biblioteca Java padr√£o cont√©m um rico conjunto de implementa√ß√µes de estruturas ou cole√ß√µes din√¢micas de dados, expressas em termos de Java. Todas as cole√ß√µes s√£o divididas em tr√™s grandes classes: listas, conjuntos e mapas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listas - matrizes din√¢micas - permitem adicionar / remover itens. Muitos n√£o garantem a ordem dos elementos adicionados, mas garantem que n√£o h√° elementos duplicados. Os cart√µes ou matrizes associativas operam com pares de valores-chave e o valor da chave √© √∫nico - n√£o pode haver 2 pares com as mesmas chaves no cart√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para listas, conjuntos e mapas, h√° muitas implementa√ß√µes, cada uma delas otimizada para uma opera√ß√£o espec√≠fica. Por exemplo, as listas s√£o implementadas pelas classes ArrayList e LinkedList, com ArrayList fornecendo melhor desempenho ao acessar um elemento arbitr√°rio, e o LinkedList √© mais eficiente ao inserir / excluir elementos no meio da lista.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somente objetos Java completos podem ser armazenados em cole√ß√µes (de fato, refer√™ncias a objetos); portanto, √© imposs√≠vel criar uma cole√ß√£o de primitivas diretamente (int, char, byte etc.). </font><font style="vertical-align: inherit;">Nesse caso, as classes de wrapper apropriadas devem ser usadas:</font></font><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primitivo </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classe de embalagem </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> byte </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Byte </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> curto </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Curto </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> char </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Car√°ter </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> int </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inteiro </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> longo </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Longo </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flutuar </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flutuar </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dobrar </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duplo </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> booleano </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Booleano </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Felizmente, ao programar em Java, n√£o h√° necessidade de seguir a coincid√™ncia exata do tipo primitivo e seu "wrapper". </font><font style="vertical-align: inherit;">Se o m√©todo receber um argumento, por exemplo, do tipo Inteiro, poder√° ser passado o tipo int. </font><font style="vertical-align: inherit;">E vice-versa, onde o tipo int √© necess√°rio, voc√™ pode usar com seguran√ßa o n√∫mero inteiro. </font><font style="vertical-align: inherit;">Isso foi poss√≠vel gra√ßas ao mecanismo interno do Java para empacotar / descompactar primitivas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dos momentos desagrad√°veis, deve-se mencionar que a biblioteca Java padr√£o cont√©m classes de cole√ß√£o antigas que foram implementadas sem √™xito nas primeiras vers√µes do Java e que n√£o devem ser usadas em novos programas. </font><font style="vertical-align: inherit;">Essas s√£o as classes Enumera√ß√£o, Vetor, Pilha, Dicion√°rio, Hashtable, Propriedades.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generaliza√ß√µes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As cole√ß√µes s√£o comumente usadas como tipos de dados gen√©ricos. </font><font style="vertical-align: inherit;">A ess√™ncia das generaliza√ß√µes nesse caso √© que especificamos o tipo principal da cole√ß√£o, por exemplo, ArrayList, e entre colchetes angulares especificamos o tipo de par√¢metro, que neste caso determina o tipo de elementos armazenados na lista:</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso permite que o compilador rastreie a tentativa de adicionar um objeto de um tipo diferente do par√¢metro de tipo especificado: </font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  ! list.add("First");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √â muito importante que o par√¢metro type seja apagado durante a execu√ß√£o do programa, e n√£o h√° diferen√ßa entre, por exemplo, um objeto da classe </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;Integer&gt; </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e objeto de classe </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;&gt;. </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, n√£o h√° como descobrir o tipo de elementos de cole√ß√£o durante a execu√ß√£o do programa: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! if (list instanceof List&lt;Integer&gt;) { return true; } return false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma solu√ß√£o parcial pode ser a seguinte abordagem: pegue o primeiro elemento da cole√ß√£o e determine seu tipo: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!list.isEmpty() &amp;&amp; list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Integer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas essa abordagem n√£o funcionar√° se a lista estiver vazia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse sentido, as generaliza√ß√µes de Java s√£o significativamente inferiores √†s generaliza√ß√µes de C ++. </font><font style="vertical-align: inherit;">As generaliza√ß√µes Java realmente servem para "eliminar" alguns dos erros em potencial no est√°gio de compila√ß√£o.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iterar sobre todos os elementos de uma matriz ou cole√ß√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ao programar em C, voc√™ geralmente precisa iterar sobre todos os elementos da matriz: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SIZE; i++) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cometer um erro aqui √© mais simples, basta especificar o tamanho errado da matriz SIZE ou colocar "&lt;=" em vez de "&lt;". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em Java, al√©m da forma ‚Äúusual‚Äù da instru√ß√£o for, existe uma forma de iterar sobre todos os elementos de uma matriz ou cole√ß√£o (geralmente chamada foreach em outras linguagens):</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ... for (Integer i : list) { // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui temos a garantia de iterar sobre todos os elementos da lista, os erros inerentes √† forma "usual" da instru√ß√£o for s√£o eliminados. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cole√ß√µes diversas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como todos os objetos s√£o herdados do objeto raiz, o Java tem uma oportunidade interessante de criar listas com v√°rios tipos reais de elementos: </font></font><br><br><pre> <code class="java hljs">List list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"First"</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">2</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Double(<span class="hljs-number"><span class="hljs-number">3.0</span></span>));         <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object o : list) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { <span class="hljs-comment"><span class="hljs-comment">// ... } else if (o instanceof Integer) { // ... } else if (o instanceof Double) { // ... } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transfer√™ncias </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparando C / C ++ e Java, √© imposs√≠vel n√£o notar quanto mais enumera√ß√µes funcionais s√£o implementadas em Java. </font><font style="vertical-align: inherit;">Aqui a enumera√ß√£o √© uma classe completa e os elementos de enumera√ß√£o s√£o objetos dessa classe. </font><font style="vertical-align: inherit;">Isso permite que um elemento de enumera√ß√£o defina v√°rios campos de qualquer tipo em correspond√™ncia:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Colors { <span class="hljs-comment"><span class="hljs-comment">//     -   . RED ((byte)0xFF, (byte)0x00, (byte)0x00), GREEN ((byte)0x00, (byte)0xFF, (byte)0x00), BLUE ((byte)0x00, (byte)0x00, (byte)0xFF), WHITE ((byte)0xFF, (byte)0xFF, (byte)0xFF), BLACK ((byte)0x00, (byte)0x00, (byte)0x00); //  . private byte r, g, b; //  . private Colors(byte r, byte g, byte b) { this.r = r; this.g = g; this.b = b; } //  . public double getLuma() { return 0.2126 * r + 0.7152 * g + 0.0722 * b; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como uma classe completa, uma enumera√ß√£o pode ter m√©todos e, usando um construtor privado, voc√™ pode definir os valores do campo de elementos de enumera√ß√£o individuais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√° uma oportunidade regular de obter uma representa√ß√£o em seq√º√™ncia de caracteres de um elemento de enumera√ß√£o, um n√∫mero de s√©rie e uma matriz de todos os elementos:</font></font><br><br><pre> <code class="java hljs">Colors color = Colors.BLACK; String str = color.toString(); <span class="hljs-comment"><span class="hljs-comment">// "BLACK" int i = color.ordinal(); // 4 Colors[] array = Colors.values(); // [RED, GREEN, BLUE, WHITE, BLACK]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E vice-versa - pela representa√ß√£o em cadeia, voc√™ pode obter um elemento de enumera√ß√£o e tamb√©m chamar seus m√©todos: </font></font><br><br><pre> <code class="java hljs">Colors red = Colors.valueOf(<span class="hljs-string"><span class="hljs-string">"RED"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Colors.RED Double redLuma = red.getLuma(); // 0.2126 * 255</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Naturalmente, enumera√ß√µes podem ser usadas em constru√ß√µes de casos de comuta√ß√£o. </font></font><br><br><h2>  Conclus√µes </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, as linguagens C e Java s√£o projetadas para resolver problemas completamente diferentes. Por√©m, se compararmos o processo de desenvolvimento de software nessas duas linguagens, de acordo com as impress√µes subjetivas do autor, a linguagem Java supera significativamente o C na conveni√™ncia e velocidade dos programas de grava√ß√£o. O ambiente de desenvolvimento (IDE) desempenha um papel significativo no fornecimento de conveni√™ncia. O autor trabalhou com o IntelliJ IDEA IDE. Ao programar em Java, voc√™ n√£o precisa "constantemente ter medo" de cometer um erro - geralmente o ambiente de desenvolvimento diz o que precisa ser corrigido e, √†s vezes, faz isso por voc√™. Se um erro de tempo de execu√ß√£o ocorreu, o tipo de erro e o local de sua ocorr√™ncia no c√≥digo-fonte s√£o sempre indicados no log - a luta contra esses erros se torna uma quest√£o trivial. Um programador C n√£o precisa fazer esfor√ßos desumanos para mudar para Java, e tudo porque a sintaxe da linguagem mudou um pouco.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se essa experi√™ncia for interessante para os leitores, no pr√≥ximo artigo, falaremos sobre a experi√™ncia do uso do mecanismo JNI (executando o c√≥digo C / C ++ nativo de um aplicativo Java). </font><font style="vertical-align: inherit;">O mecanismo JNI √© indispens√°vel quando voc√™ deseja controlar a resolu√ß√£o da tela, o m√≥dulo Bluetooth e, em outros casos, quando os recursos dos servi√ßos e gerentes do Android n√£o s√£o suficientes.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt412775/">https://habr.com/ru/post/pt412775/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt412763/index.html">Usando a placa de recarga Firefly-RK3288 com o SoC RockChip RK3288 Sensor t√©rmico digital Microchip I2C - MCP9808</a></li>
<li><a href="../pt412765/index.html">Introdu√ß√£o ao novo sistema de cart√µes lado a lado da Unity</a></li>
<li><a href="../pt412767/index.html">Revis√£o da confer√™ncia de impacto CMG 2016</a></li>
<li><a href="../pt412769/index.html">Eu fiz o PWA e o coloquei em tr√™s lojas de aplicativos. E aqui est√° o que eu descobri</a></li>
<li><a href="../pt412773/index.html">Astro-aeroespacial de Minsk</a></li>
<li><a href="../pt412777/index.html">Obras-primas da constru√ß√£o da coluna mundial: QUAD 11L - as melhores ‚Äúprateleiras‚Äù dos dois mil√©simos</a></li>
<li><a href="../pt412779/index.html">SSLH: oculte SSH / HTTPS / OpenVPN / Telegram atr√°s de uma √∫nica porta 443</a></li>
<li><a href="../pt412781/index.html">F√£ do NES tornou poss√≠vel o lan√ßamento de jogos SNES no console</a></li>
<li><a href="../pt412783/index.html">Instalando o proxy MTProto Telegram da origem no Centos 7</a></li>
<li><a href="../pt412785/index.html">Mestre em Gest√£o e Freelancer. A hist√≥ria em tr√™s partes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>