<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏿 👩‍🍳 💆🏻 Huawei Cloud: Heute ist es in PVS-Studio bewölkt 🅱️ 👩🏼‍⚖️ 🧑🏿‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Jahrhundert hat jeder von Cloud-Diensten gehört. Viele Unternehmen haben dieses Marktsegment gemeistert und ihre Cloud-Services in verschied...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Huawei Cloud: Heute ist es in PVS-Studio bewölkt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/477566/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ac/bd2/47b/2acbd247b999e7f8e9e45f77181e2f06.png" alt="Bild 2"></div><br>  In diesem Jahrhundert hat jeder von Cloud-Diensten gehört.  Viele Unternehmen haben dieses Marktsegment gemeistert und ihre Cloud-Services in verschiedene Richtungen entwickelt.  Unser Team hat sich kürzlich auch für diese Dienste interessiert, um den PVS-Studio Code Analyzer in diese zu integrieren.  Wir glauben, dass unsere regelmäßigen Leser bereits erraten, welche Art von Projekt wir diesmal prüfen werden.  Die Wahl fiel auf den Code der Cloud-Dienste von Huawei. <br><a name="habracut"></a><br><h2>  Einleitung </h2><br>  Wenn Sie dem PVS-Studio-Team folgen, haben Sie wahrscheinlich bemerkt, dass wir uns in letzter Zeit sehr für Cloud-Technologien interessiert haben.  Wir haben bereits mehrere Artikel zu diesem Thema veröffentlicht: <br><br><ul><li>  <a href="https://www.viva64.com/ru/b/0670/">PVS-Studio geht in die Cloud: Azure DevOps</a> </li><li>  <a href="https://www.viva64.com/ru/b/0636/">PVS-Studio geht in die Cloud: Travis CI</a> </li><li>  <a href="https://www.viva64.com/ru/b/0676/">PVS-Studio geht in die Cloud: CircleCI</a> </li><li>  <a href="https://www.viva64.com/ru/b/0686/">PVS-Studio geht in die Cloud: GitLab CI / CD</a> </li></ul><br>  Als ich gerade ein weiteres interessantes Projekt für den kommenden Artikel aufnahm, erhielt ich per E-Mail ein Stellenangebot von <a href="https://www.huawei.com/en/">Huawei</a> .  Beim Sammeln von Informationen über dieses Unternehmen stellte sich heraus, dass es über eigene Cloud-Dienste verfügt. Hauptsache, der Quellcode dieser Dienste ist auf GitHub frei verfügbar.  Dies war der Hauptgrund für die Wahl dieses Unternehmens für diesen Artikel.  Wie ein chinesischer Weiser sagte: "Unfälle sind nicht zufällig." <br><br>  Nun ein wenig über unseren Analysator.  PVS-Studio ist ein statischer Code-Analysator, der Fehler und Schwachstellen im Quellcode von Programmen identifiziert, die in C, C ++, C # und Java geschrieben wurden.  Der Analyzer läuft auf den Plattformen Windows, Linux und macOS.  Neben Plugins für klassische Entwicklungsumgebungen wie Visual Studio oder IntelliJ IDEA kann der Analyzer auch in SonarQube und Jenkins integriert werden: <br><br><ul><li>  <a href="https://www.viva64.com/ru/m/0037/">Integration der PVS-Studio-Analyseergebnisse in SonarQube</a> </li><li>  <a href="https://www.viva64.com/ru/m/0048/">Starten Sie PVS-Studio in Jenkins</a> </li></ul><br><h2>  Projektanalyse </h2><br>  Bei der Suche nach Informationen für den Artikel habe ich festgestellt, dass Huawei über ein <a href="https://developer.huaweicloud.com/en-us">Entwicklercenter verfügt,</a> in dem Sie Informationen, Handbücher und den Quellcode für die Cloud-Dienste abrufen können.  Eine Vielzahl von Programmiersprachen wurden verwendet, um diese Dienste zu erstellen, jedoch erwiesen sich Sprachen wie Go, Java und Python als die beliebtesten. <br><br>  Da ich mich auf Java spezialisiere, wurden die Projekte entsprechend ausgewählt.  Quellen der im Artikel analysierten Projekte finden Sie im GitHub-Repository <a href="https://github.com/huaweicloud/">huaweicloud</a> . <br><br>  Um die Projekte zu analysieren, musste ich nur ein paar Aktionen ausführen: <br><br><ul><li>  Holen Sie sich Projekte aus dem Repository; </li><li>  Befolgen Sie die <a href="https://www.viva64.com/ru/m/0044/">Anweisungen</a> zum Starten des Java Analyzers und starten Sie die Analyse für jedes Projekt. </li></ul><br>  Nach der Analyse der Projekte haben wir nur drei herausgegriffen, auf die ich gerne eingehen möchte.  Dies ist darauf zurückzuführen, dass die verbleibenden Java-Projekte zu klein waren. <br><br>  Projektanalyseergebnisse (Anzahl der Warnungen und Anzahl der Dateien): <br><br><ul><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java">huaweicloud-sdk-java</a> : 31 - Hoch, 2 - Mittel und 16 - Niedrig, 2700+ Dateien. </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-dis-agent">huaweicloud-dis-agent</a> : 7 - Hoch, 6 - Mittel und 6 - Niedrig, über 100 Dateien. </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java-dis">huaweicloud-sdk-java-dis</a> : 15 - Hoch, 6 - Mittel und 16 - Niedrig, 270+ Dateien. </li></ul><br>  Da es nur wenige Warnungen gibt, können wir im Allgemeinen über die gute Qualität des Codes sprechen.  Darüber hinaus sind nicht alle Operationen gültige Fehler.  Dies liegt an der Tatsache, dass der Analysator manchmal nicht über genügend Informationen verfügt, um den richtigen Code vom falschen zu unterscheiden.  Aus diesem Grund wird die Analysatordiagnose täglich mithilfe der vom Benutzer erhaltenen Informationen verbessert.  Siehe auch den Artikel " <a href="https://www.viva64.com/ru/b/0488/">Wie und warum statische Analysegeräte gegen falsch positive Ergebnisse vorgehen</a> ". <br><br>  Bei der Analyse von Projekten habe ich die interessantesten Warnungen ausgewählt, auf die ich in diesem Artikel eingehen werde. <br><br><h2>  Reihenfolge der Feldinitialisierung </h2><br>  <a href="https://www.viva64.com/ru/w/v6050/">V6050 Klasseninitialisierungszyklus</a> ist vorhanden.  Die Initialisierung von 'INSTANCE' erscheint vor der Initialisierung von 'LOG'.  UntrustedSSL.java (32), UntrustedSSL.java (59), UntrustedSSL.java (33) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UntrustedSSL INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UntrustedSSL(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(UntrustedSSL.class); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { LOG.error(t.getMessage(), t); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Wenn im Konstruktor der <i>UntrustedSSL-</i> Klasse eine Ausnahme auftritt, werden Informationen zu dieser Ausnahme im <i>catch-Block</i> mithilfe des <i>LOG-</i> Protokolls protokolliert.  Aufgrund der Initialisierungsreihenfolge statischer Felder ist das <i>LOG</i> zum Zeitpunkt der Initialisierung des <i>INSTANCE-</i> Felds jedoch noch nicht initialisiert.  Daher wird beim Protokollieren von Ausnahmeinformationen im Konstruktor eine <i>NullPointerException</i> ausgelöst.  Diese Ausnahme ist die Ursache für eine andere <i>ExceptionInInitializerError-Ausnahme</i> , die ausgelöst wird, wenn beim Initialisieren des statischen Felds eine Ausnahme aufgetreten ist.  <i>Um</i> das beschriebene Problem zu lösen, muss <i>lediglich</i> die <i>LOG-</i> Initialisierung vor der <i>INSTANCE-</i> Initialisierung platziert werden. <br><br><h2>  Unsichtbarer Tippfehler </h2><br>  <a href="https://www.viva64.com/ru/w/v6005/">V6005</a> Die Variable 'this.metricSchema' ist sich selbst zugeordnet.  OpenTSDBSchema.java (72) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenTSDBSchema</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JsonProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"metric"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SchemaField&gt; metricSchema; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMetricsSchema</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;SchemaField&gt; metricsSchema)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.metricSchema = metricSchema; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } public void setMetricSchema(List&lt;SchemaField&gt; metricSchema) { this.metricSchema = metricSchema; } .... }</span></span></code> </pre> <br>  Beide Methoden legen das <i>metricSchema-</i> Feld fest, aber die Methodennamen unterscheiden sich durch das eigene Zeichen.  Der Programmierer benannte die Argumente dieser Methoden gemäß dem Namen der Methode.  In der Zeile, auf die der Analysator zeigt, wird das <i>metricSchema-</i> Feld <i>sich selbst</i> zugewiesen, und das Argument der <i>metricsSchema-</i> Methode <i>wird</i> nicht verwendet. <br><br>  <a href="https://www.viva64.com/ru/w/v6005/">V6005</a> Die Variable 'suspend' ist sich selbst zugeordnet.  SuspendTransferTaskRequest.java (77) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuspendTransferTaskRequest</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> suspend; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ suspend = suspend; } .... }</code> </pre> <br>  Hierbei handelt es sich um einen banalen Fehler im Zusammenhang mit Nachlässigkeit, aufgrund dessen die Zuordnung des Arguments zu sich selbst erfolgt.  Infolgedessen wird der Wert des angekommenen Arguments nicht wie impliziert dem <i>Suspend-</i> Feld zugewiesen.  Richtig: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspend = suspend; }</code> </pre> <br><h2>  Vorausbestimmte Bedingungen </h2><br>  Wie so oft bricht die <a href="https://www.viva64.com/ru/w/v6007/">V6007-</a> Regel in Bezug auf die Anzahl der Warnungen vor. <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007 Der</a> Ausdruck 'firewallPolicyId == null' ist immer falsch.  FirewallPolicyServiceImpl.java (125) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FirewallPolicy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFirewallRuleFromPolicy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String firewallPolicyId, String firewallRuleId)</span></span></span><span class="hljs-function"> </span></span>{ checkNotNull(firewallPolicyId); checkNotNull(firewallRuleId); checkState(!(firewallPolicyId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; firewallRuleId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>), <span class="hljs-string"><span class="hljs-string">"Either a Firewall Policy or Firewall Rule identifier must be set"</span></span>); .... }</code> </pre> <br>  In dieser Methode werden die Argumente von der <i>checkNotNull-</i> Methode auf <i>null</i> überprüft: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CanIgnoreReturnValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkNotNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T reference)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reference == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NullPointerException(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference; } }</code> </pre> <br>  Nachdem Sie das Argument mit der <i>checkNotNull-</i> Methode <i>überprüft haben</i> , können Sie zu 100% sicher sein, dass das an diese Methode übergebene Argument nicht <i>null ist</i> .  Da beide Argumente für die <i>removeFirewallRuleFromPolicy-</i> Methode von der <i>checkNotNull-</i> Methode überprüft werden, ist es nicht sinnvoll, die Argumente erneut auf <i>Nullwerte</i> zu überprüfen.  Als erstes Argument wird jedoch ein Ausdruck an die <i>checkState-</i> Methode übergeben, wobei die Argumente <i>firewallPolicyId</i> und <i>firewallRuleId</i> erneut auf <i>null</i> überprüft werden. <br><br>  Eine ähnliche Warnung wird für <i>firewallRuleId</i> ausgegeben: <br><br><ul><li>  V6007 Der Ausdruck 'firewallRuleId == null' ist immer falsch.  FirewallPolicyServiceImpl.java (125) </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007 Der</a> Ausdruck ' <a href="https://www.viva64.com/ru/w/v6007/">filtersParams</a> ! = Null' ist immer wahr.  NetworkPolicyServiceImpl.java (60) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Invocation&lt;NetworkServicePolicies&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildInvocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; filteringParams)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> servicePoliciesInvocation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return servicePoliciesInvocation; }</span></span></code> </pre> <br>  Wenn in dieser Methode das Argument <i>filtersParams</i> <i>null ist</i> , wird die Methode beendet und gibt einen Wert zurück.  Daher ist der Test, auf den der Analysator zeigt, immer wahr, was bedeutet, dass dieser Test keinen Sinn ergibt. <br><br>  Ähnliches tritt in 13 Klassen auf: <br><br><ul><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  PolicyRuleServiceImpl.java (58) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  GroupServiceImpl.java (58) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  ExternalSegmentServiceImpl.java (57) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  L3policyServiceImpl.java (57) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  PolicyRuleSetServiceImpl.java (58) </li><li>  usw... </li></ul><br><h2>  Nullreferenz </h2><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a> Potentielle Null-Dereferenzierung von 'm.blockDeviceMapping'.  NovaServerCreate.java (390) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ServerCreateBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BlockDeviceMappingCreate blockDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blockDevice != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; m.blockDeviceMapping == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { m.blockDeviceMapping = Lists.newArrayList(); } m.blockDeviceMapping.add(blockDevice); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return this; }</span></span></code> </pre> <br>  Bei dieser Methode wird die Initialisierung des Referenzfelds <i>m.blockDeviceMapping</i> nicht durchgeführt, wenn das Argument <i>blockDevice</i> den <i>Wert</i> <i>null hat</i> .  Dieses Feld wird nur in dieser Methode initialisiert. Wenn also die Methode <i>add</i> aufgerufen wird, <i>löst das</i> Feld <i>m.blockDeviceMapping</i> eine <i>NullPointerException aus</i> . <br><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a> Potentielle Null-Dereferenzierung von 'FileId.get (path)' in Funktion '&lt;init&gt;'.  TrackedFile.java (140), TrackedFile.java (115) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileFlow&lt;?&gt; flow, Path path)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(flow, path, FileId.get(path), ....); }</code> </pre> <br>  Das Ergebnis der statischen Methode <i>FileId.get (path)</i> wird als drittes Argument an den Konstruktor der <i>TrackedFile-</i> Klasse übergeben.  Diese Methode kann jedoch <i>null zurückgeben</i> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FileId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Files.exists(file)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } .... }</code> </pre> <br>  In dem <i>hierdurch</i> aufgerufenen Konstruktor ändert sich das Argument <i>id</i> erst, wenn es zum ersten Mal verwendet wird: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., ...., FileId id, ....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... FileId newId = FileId.get(path); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!id.equals(newId)) { .... } }</code> </pre> <br>  Wenn daher <i>null</i> als drittes Argument an die Methode übergeben wird, tritt eine Ausnahme auf. <br><br>  Eine ähnliche Situation tritt in einem anderen Fall auf: <br><br><ul><li>  V6008 Potentielle Null-Dereferenzierung von 'Buffer'.  PublishingQueue.java (518) </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a> Mögliche Null-Dereferenzierung von 'dataTmpFile'.  CacheManager.java (91) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putToCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PutRecordsRequest putRecordsRequest)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dataTmpFile.createNewFile(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } catch (IOException e) { LOGGER.error("Failed to create cache tmp file, return.", e); return ; } } .... }</span></span></code> </pre> <br>  Und wieder NPE.  Durch eine Reihe von Überprüfungen in der bedingten Anweisung kann das <i>dataTmpFile-</i> Objekt für die weitere Dereferenzierung auf Null gesetzt werden.  Ich denke, hier gibt es zwei Tippfehler, und der Check sollte tatsächlich so aussehen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !dataTmpFile.exists())</code> </pre> <br><h2>  Teilstrings und negative Zahlen </h2><br>  <a href="https://www.viva64.com/ru/w/v6009/">V6009</a> Die Funktion 'substring' kann den Wert '-1' empfangen, wenn ein nicht negativer Wert erwartet wird.  Überprüfen Sie das Argument: 2. RemoveVersionProjectIdFromURL.java (37) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String url)</span></span></span><span class="hljs-function"> </span></span>{ String urlRmovePojectId = url.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, url.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urlRmovePojectId.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, urlRmovePojectId.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); }</code> </pre> <br>  Es versteht sich, dass die URL als Zeichenfolge an diese Methode übergeben wird, die in keiner Weise validiert wird.  Nachdem dieser String mit der <i>lastIndexOf-</i> Methode mehrmals <i>gekürzt wurde</i> .  Wenn <i>lastIndexOf</i> keine Übereinstimmung in der Zeichenfolge findet, wird -1 zurückgegeben.  Dadurch wird eine <i>StringIndexOutOfBoundsException ausgelöst</i> , da die Argumente für die <i>Teilzeichenfolgemethode</i> nicht negative Zahlen sein müssen.  Damit die Methode ordnungsgemäß funktioniert, müssen Sie das Eingabeargument validieren oder <i>sicherstellen</i> , dass die Ergebnisse der <i>lastIndexOf-</i> Methoden keine negativen Zahlen sind. <br><br>  Hier sind einige andere Orte, an denen dies passiert: <br><br><ul><li>  V6009 Die Funktion 'substring' kann den Wert '-1' empfangen, wenn ein nicht negativer Wert erwartet wird.  Überprüfen Sie das Argument: 2. RemoveProjectIdFromURL.java (37) </li><li>  V6009 Die Funktion 'substring' kann den Wert '-1' empfangen, wenn ein nicht negativer Wert erwartet wird.  Überprüfen Sie das Argument: 2. RemoveVersionProjectIdFromURL.java (38) </li></ul><br><h2>  Vergessenes Ergebnis </h2><br>  <a href="https://www.viva64.com/ru/w/v6010/">V6010</a> Der Rückgabewert der Funktion 'concat' muss verwendet werden.  AKSK.java (278) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildCanonicalHost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(URL url)</span></span></span><span class="hljs-function"> </span></span>{ String host = url.getHost(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port = url.getPort(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host; }</code> </pre> <br>  Beim Schreiben dieses Codes wurde nicht berücksichtigt, dass der Aufruf der <i>concat-</i> Methode die <i>Hostzeichenfolge</i> aufgrund der Unveränderlichkeit von Objekten des Typs <i>String</i> nicht ändert.  Damit die Methode ordnungsgemäß funktioniert, müssen Sie das Ergebnis der <i>concat-</i> Methode der <i>Hostvariablen</i> im <i>if-</i> Block zuweisen.  Richtig: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host = host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); }</code> </pre> <br><h2>  Nicht verwendete Variablen </h2><br>  <a href="https://www.viva64.com/ru/w/v6021/">V6021</a> Variable 'url' wird nicht verwendet.  TriggerV2Service.java (95) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteAllTriggersForFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String functionUrn)</span></span></span><span class="hljs-function"> </span></span>{ checkArgument(!Strings.isNullOrEmpty(functionUrn), ....); String url = ClientConstants.FGS_TRIGGERS_V2 + ClientConstants.URI_SEP + functionUrn; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deleteWithResponse(uri(triggersUrlFmt, functionUrn)).execute(); }</code> </pre> <br>  Bei dieser Methode wird die <i>URL-</i> Variable nach der Initialisierung nicht verwendet.  Höchstwahrscheinlich sollte die <i>URL-</i> Variable als zweites Argument anstelle von <i>functionUrn an</i> die <i>URL-</i> Methode übergeben <i>werden</i> , da die Variable <i>functionUrn</i> an der Initialisierung der <i>URL-</i> Variable beteiligt ist. <br><br><h2>  Argument wird im Konstruktor nicht verwendet </h2><br>  <a href="https://www.viva64.com/ru/w/v6022/">V6022 Der</a> Parameter 'returnType' wird im Konstruktorkörper nicht verwendet.  HttpRequest.java (68) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpReQuest</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ .... Class&lt;R&gt; returnType; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., Class&lt;R&gt; returnType)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// &lt;= { this.endpoint = endpoint; this.path = path; this.method = method; this.entity = entity; } .... public Class&lt;R&gt; getReturnType() { return returnType; } .... }</span></span></span></span></code> </pre> <br>  In diesem Konstruktor haben sie vergessen, das <i>returnType-</i> Argument zu verwenden und dessen Wert dem <i>returnType-</i> Feld <i>zuzuweisen</i> .  Wenn die Methode <i>getReturnType aufgerufen wird</i> , gibt das von diesem Konstruktor erstellte Objekt daher den Standardwert <i>null zurück</i> , obwohl höchstwahrscheinlich beabsichtigt war, das Objekt <i>abzurufen</i> , das zuvor an den Konstruktor übergeben wurde. <br><br><h2>  Gleiche Funktionalität </h2><br>  <a href="https://www.viva64.com/ru/w/v6032/">V6032</a> Es ist merkwürdig, dass der Hauptteil der Methode 'enable' dem Hauptteil einer anderen Methode ' <a href="https://www.viva64.com/ru/w/v6032/">disable</a> ' vollständig entspricht.  ServiceAction.java (32), ServiceAction.java (36) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String binary; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String host; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.binary = binary; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.host = host; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ServiceAction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// &lt;= return new ServiceAction(binary, host); } public static ServiceAction disable(String binary, String host) { // &lt;= return new ServiceAction(binary, host); } .... }</span></span></code> </pre> <br>  Das Vorhandensein von zwei identischen Methoden ist kein Fehler, aber die Tatsache, dass zwei Methoden dieselbe Aktion ausführen, ist zumindest seltsam.  Wenn wir uns die Namen der oben genannten Methoden ansehen, können wir annehmen, dass sie die entgegengesetzten Aktionen ausführen.  Tatsächlich tun beide Methoden dasselbe: Sie erstellen ein <i>ServiceAction-</i> Objekt und geben es zurück.  Die Methode <i>disable</i> wurde höchstwahrscheinlich durch Kopieren des Codes der Methode <i>enable erstellt</i> , hat jedoch vergessen, den Methodentext zu ändern. <br><br><h2>  Ich habe vergessen, die Hauptsache zu überprüfen </h2><br>  <a href="https://www.viva64.com/ru/w/v6060/">V6060</a> Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (49), DomainService.java (46) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Domains </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_size"</span></span>), ....); Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_number"</span></span>), ....); Invocation&lt;Domains&gt; domainInvocation = get(Domains.class, uri(<span class="hljs-string"><span class="hljs-string">"/domains"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (params != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return domainInvocation.execute(this.buildExecutionOptions(Domains.class)); }</span></span></code> </pre> <br>  Bei dieser Methode haben wir beschlossen, den Inhalt einer Struktur vom Typ <i>Map</i> auf <i>Nullungleichheit</i> zu prüfen.  Dazu ruft das Argument <i>params</i> die Methode <i>get</i> zweimal auf, deren Ergebnis an die Methode <i>checkNotNull übergeben</i> wird.  Alles scheint logisch, aber egal wie!  In <i>if</i> wird das Argument <i>params</i> auf <i>null</i> geprüft.  Danach kann angenommen werden, dass das Eingabeargument <i>null ist</i> , aber vor dieser Überprüfung wurde die Methode <i>get</i> bereits zweimal für <i>params</i> aufgerufen.  Wenn <i>null</i> als Argument an diese Methode übergeben wird, wird beim ersten Aufruf der <i>get-</i> Methode eine Ausnahme ausgelöst. <br><br>  Eine ähnliche Situation tritt an drei weiteren Stellen auf: <br><br><ul><li>  V6060 Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (389), DomainService.java (387) </li><li>  V6060 Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (372), DomainService.java (369) </li><li>  V6060 Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (353), DomainService.java (350) </li></ul><br><h2>  Fazit </h2><br>  Moderne Großunternehmen können heutzutage einfach nicht auf die Nutzung von Cloud-Diensten verzichten.  Eine große Anzahl von Menschen nutzt diese Dienste, so dass selbst der kleinste Fehler in dem Dienst für viele Menschen zu Problemen sowie zu zusätzlichen Kosten für das Unternehmen führen kann, um die Folgen dieses Fehlers zu beheben.  Bei der Entwicklung muss immer der Faktor Mensch berücksichtigt werden, da jeder früher oder später Fehler macht und dieser Artikel ein Beispiel dafür ist.  Aus diesem Grund sollten Sie alle möglichen Tools verwenden, um die Qualität des Codes zu verbessern. <br><br>  PVS-Studio wird Huawei mit Sicherheit über die Ergebnisse der Überprüfung seiner Cloud-Dienste informieren, damit die Entwickler dieses Unternehmens diese genauer untersuchen können. <br><br>  Die im Artikel gezeigte einmalige Verwendung der statischen Code-Analyse kann nicht alle Vorteile zeigen.  Nähere Informationen zur korrekten Verwendung der statischen Analyse finden Sie <a href="https://www.viva64.com/ru/b/0594/">hier</a> und <a href="https://www.viva64.com/ru/b/0639/">hier</a> .  Sie können den PVS-Studio Analyzer <a href="https://www.viva64.com/ru/pvs-studio-download/">hier</a> herunterladen. <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/477558/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel mit einem englischsprachigen Publikum teilen möchten, verwenden Sie bitte den Link zur Übersetzung: Valery Komarov.  <a href="https://habr.com/en/company/pvs-studio/blog/477558/">Huawei Cloud: Heute ist es im PVS-Studio bewölkt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477566/">https://habr.com/ru/post/de477566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477554/index.html">Die .ORG Domain Zone wird an eine private Firma verkauft. Die Öffentlichkeit fordert die ICANN auf, den Vertrag zu kündigen</a></li>
<li><a href="../de477558/index.html">Huawei Cloud: Heute ist es im PVS-Studio bewölkt</a></li>
<li><a href="../de477560/index.html">Ändern Sie Ihre Einstellung mit SwiftUI</a></li>
<li><a href="../de477562/index.html">Interface-Design für das Spiel, zeichnen Sie eine Reihe von Symbolen</a></li>
<li><a href="../de477564/index.html">Komplexe Kunden: So schützen Sie Ihr Team vor ihnen</a></li>
<li><a href="../de477568/index.html">Der Service ist einfach bedingungslose Rückgabe. Russische Post</a></li>
<li><a href="../de477578/index.html">So wählen Sie eine Programmiersprache zum Erstellen einer Android-Anwendung</a></li>
<li><a href="../de477580/index.html">Beste PHP Frameworks für die Webentwicklung</a></li>
<li><a href="../de477584/index.html">Zeitloser Klassiker: Was moderne Actionspiele von DOOM lernen sollten</a></li>
<li><a href="../de477590/index.html">Embedding Code und die Gefahr von Raubkopien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>