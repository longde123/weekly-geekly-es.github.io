<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§æüèø üë©‚Äçüç≥ üíÜüèª Huawei Cloud: Heute ist es in PVS-Studio bew√∂lkt üÖ±Ô∏è üë©üèº‚Äç‚öñÔ∏è üßëüèø‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Jahrhundert hat jeder von Cloud-Diensten geh√∂rt. Viele Unternehmen haben dieses Marktsegment gemeistert und ihre Cloud-Services in verschied...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Huawei Cloud: Heute ist es in PVS-Studio bew√∂lkt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/477566/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ac/bd2/47b/2acbd247b999e7f8e9e45f77181e2f06.png" alt="Bild 2"></div><br>  In diesem Jahrhundert hat jeder von Cloud-Diensten geh√∂rt.  Viele Unternehmen haben dieses Marktsegment gemeistert und ihre Cloud-Services in verschiedene Richtungen entwickelt.  Unser Team hat sich k√ºrzlich auch f√ºr diese Dienste interessiert, um den PVS-Studio Code Analyzer in diese zu integrieren.  Wir glauben, dass unsere regelm√§√üigen Leser bereits erraten, welche Art von Projekt wir diesmal pr√ºfen werden.  Die Wahl fiel auf den Code der Cloud-Dienste von Huawei. <br><a name="habracut"></a><br><h2>  Einleitung </h2><br>  Wenn Sie dem PVS-Studio-Team folgen, haben Sie wahrscheinlich bemerkt, dass wir uns in letzter Zeit sehr f√ºr Cloud-Technologien interessiert haben.  Wir haben bereits mehrere Artikel zu diesem Thema ver√∂ffentlicht: <br><br><ul><li>  <a href="https://www.viva64.com/ru/b/0670/">PVS-Studio geht in die Cloud: Azure DevOps</a> </li><li>  <a href="https://www.viva64.com/ru/b/0636/">PVS-Studio geht in die Cloud: Travis CI</a> </li><li>  <a href="https://www.viva64.com/ru/b/0676/">PVS-Studio geht in die Cloud: CircleCI</a> </li><li>  <a href="https://www.viva64.com/ru/b/0686/">PVS-Studio geht in die Cloud: GitLab CI / CD</a> </li></ul><br>  Als ich gerade ein weiteres interessantes Projekt f√ºr den kommenden Artikel aufnahm, erhielt ich per E-Mail ein Stellenangebot von <a href="https://www.huawei.com/en/">Huawei</a> .  Beim Sammeln von Informationen √ºber dieses Unternehmen stellte sich heraus, dass es √ºber eigene Cloud-Dienste verf√ºgt. Hauptsache, der Quellcode dieser Dienste ist auf GitHub frei verf√ºgbar.  Dies war der Hauptgrund f√ºr die Wahl dieses Unternehmens f√ºr diesen Artikel.  Wie ein chinesischer Weiser sagte: "Unf√§lle sind nicht zuf√§llig." <br><br>  Nun ein wenig √ºber unseren Analysator.  PVS-Studio ist ein statischer Code-Analysator, der Fehler und Schwachstellen im Quellcode von Programmen identifiziert, die in C, C ++, C # und Java geschrieben wurden.  Der Analyzer l√§uft auf den Plattformen Windows, Linux und macOS.  Neben Plugins f√ºr klassische Entwicklungsumgebungen wie Visual Studio oder IntelliJ IDEA kann der Analyzer auch in SonarQube und Jenkins integriert werden: <br><br><ul><li>  <a href="https://www.viva64.com/ru/m/0037/">Integration der PVS-Studio-Analyseergebnisse in SonarQube</a> </li><li>  <a href="https://www.viva64.com/ru/m/0048/">Starten Sie PVS-Studio in Jenkins</a> </li></ul><br><h2>  Projektanalyse </h2><br>  Bei der Suche nach Informationen f√ºr den Artikel habe ich festgestellt, dass Huawei √ºber ein <a href="https://developer.huaweicloud.com/en-us">Entwicklercenter verf√ºgt,</a> in dem Sie Informationen, Handb√ºcher und den Quellcode f√ºr die Cloud-Dienste abrufen k√∂nnen.  Eine Vielzahl von Programmiersprachen wurden verwendet, um diese Dienste zu erstellen, jedoch erwiesen sich Sprachen wie Go, Java und Python als die beliebtesten. <br><br>  Da ich mich auf Java spezialisiere, wurden die Projekte entsprechend ausgew√§hlt.  Quellen der im Artikel analysierten Projekte finden Sie im GitHub-Repository <a href="https://github.com/huaweicloud/">huaweicloud</a> . <br><br>  Um die Projekte zu analysieren, musste ich nur ein paar Aktionen ausf√ºhren: <br><br><ul><li>  Holen Sie sich Projekte aus dem Repository; </li><li>  Befolgen Sie die <a href="https://www.viva64.com/ru/m/0044/">Anweisungen</a> zum Starten des Java Analyzers und starten Sie die Analyse f√ºr jedes Projekt. </li></ul><br>  Nach der Analyse der Projekte haben wir nur drei herausgegriffen, auf die ich gerne eingehen m√∂chte.  Dies ist darauf zur√ºckzuf√ºhren, dass die verbleibenden Java-Projekte zu klein waren. <br><br>  Projektanalyseergebnisse (Anzahl der Warnungen und Anzahl der Dateien): <br><br><ul><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java">huaweicloud-sdk-java</a> : 31 - Hoch, 2 - Mittel und 16 - Niedrig, 2700+ Dateien. </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-dis-agent">huaweicloud-dis-agent</a> : 7 - Hoch, 6 - Mittel und 6 - Niedrig, √ºber 100 Dateien. </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java-dis">huaweicloud-sdk-java-dis</a> : 15 - Hoch, 6 - Mittel und 16 - Niedrig, 270+ Dateien. </li></ul><br>  Da es nur wenige Warnungen gibt, k√∂nnen wir im Allgemeinen √ºber die gute Qualit√§t des Codes sprechen.  Dar√ºber hinaus sind nicht alle Operationen g√ºltige Fehler.  Dies liegt an der Tatsache, dass der Analysator manchmal nicht √ºber gen√ºgend Informationen verf√ºgt, um den richtigen Code vom falschen zu unterscheiden.  Aus diesem Grund wird die Analysatordiagnose t√§glich mithilfe der vom Benutzer erhaltenen Informationen verbessert.  Siehe auch den Artikel " <a href="https://www.viva64.com/ru/b/0488/">Wie und warum statische Analyseger√§te gegen falsch positive Ergebnisse vorgehen</a> ". <br><br>  Bei der Analyse von Projekten habe ich die interessantesten Warnungen ausgew√§hlt, auf die ich in diesem Artikel eingehen werde. <br><br><h2>  Reihenfolge der Feldinitialisierung </h2><br>  <a href="https://www.viva64.com/ru/w/v6050/">V6050 Klasseninitialisierungszyklus</a> ist vorhanden.  Die Initialisierung von 'INSTANCE' erscheint vor der Initialisierung von 'LOG'.  UntrustedSSL.java (32), UntrustedSSL.java (59), UntrustedSSL.java (33) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UntrustedSSL INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UntrustedSSL(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(UntrustedSSL.class); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { LOG.error(t.getMessage(), t); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Wenn im Konstruktor der <i>UntrustedSSL-</i> Klasse eine Ausnahme auftritt, werden Informationen zu dieser Ausnahme im <i>catch-Block</i> mithilfe des <i>LOG-</i> Protokolls protokolliert.  Aufgrund der Initialisierungsreihenfolge statischer Felder ist das <i>LOG</i> zum Zeitpunkt der Initialisierung des <i>INSTANCE-</i> Felds jedoch noch nicht initialisiert.  Daher wird beim Protokollieren von Ausnahmeinformationen im Konstruktor eine <i>NullPointerException</i> ausgel√∂st.  Diese Ausnahme ist die Ursache f√ºr eine andere <i>ExceptionInInitializerError-Ausnahme</i> , die ausgel√∂st wird, wenn beim Initialisieren des statischen Felds eine Ausnahme aufgetreten ist.  <i>Um</i> das beschriebene Problem zu l√∂sen, muss <i>lediglich</i> die <i>LOG-</i> Initialisierung vor der <i>INSTANCE-</i> Initialisierung platziert werden. <br><br><h2>  Unsichtbarer Tippfehler </h2><br>  <a href="https://www.viva64.com/ru/w/v6005/">V6005</a> Die Variable 'this.metricSchema' ist sich selbst zugeordnet.  OpenTSDBSchema.java (72) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenTSDBSchema</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JsonProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"metric"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SchemaField&gt; metricSchema; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMetricsSchema</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;SchemaField&gt; metricsSchema)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.metricSchema = metricSchema; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } public void setMetricSchema(List&lt;SchemaField&gt; metricSchema) { this.metricSchema = metricSchema; } .... }</span></span></code> </pre> <br>  Beide Methoden legen das <i>metricSchema-</i> Feld fest, aber die Methodennamen unterscheiden sich durch das eigene Zeichen.  Der Programmierer benannte die Argumente dieser Methoden gem√§√ü dem Namen der Methode.  In der Zeile, auf die der Analysator zeigt, wird das <i>metricSchema-</i> Feld <i>sich selbst</i> zugewiesen, und das Argument der <i>metricsSchema-</i> Methode <i>wird</i> nicht verwendet. <br><br>  <a href="https://www.viva64.com/ru/w/v6005/">V6005</a> Die Variable 'suspend' ist sich selbst zugeordnet.  SuspendTransferTaskRequest.java (77) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuspendTransferTaskRequest</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> suspend; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ suspend = suspend; } .... }</code> </pre> <br>  Hierbei handelt es sich um einen banalen Fehler im Zusammenhang mit Nachl√§ssigkeit, aufgrund dessen die Zuordnung des Arguments zu sich selbst erfolgt.  Infolgedessen wird der Wert des angekommenen Arguments nicht wie impliziert dem <i>Suspend-</i> Feld zugewiesen.  Richtig: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspend = suspend; }</code> </pre> <br><h2>  Vorausbestimmte Bedingungen </h2><br>  Wie so oft bricht die <a href="https://www.viva64.com/ru/w/v6007/">V6007-</a> Regel in Bezug auf die Anzahl der Warnungen vor. <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007 Der</a> Ausdruck 'firewallPolicyId == null' ist immer falsch.  FirewallPolicyServiceImpl.java (125) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FirewallPolicy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFirewallRuleFromPolicy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String firewallPolicyId, String firewallRuleId)</span></span></span><span class="hljs-function"> </span></span>{ checkNotNull(firewallPolicyId); checkNotNull(firewallRuleId); checkState(!(firewallPolicyId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; firewallRuleId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>), <span class="hljs-string"><span class="hljs-string">"Either a Firewall Policy or Firewall Rule identifier must be set"</span></span>); .... }</code> </pre> <br>  In dieser Methode werden die Argumente von der <i>checkNotNull-</i> Methode auf <i>null</i> √ºberpr√ºft: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CanIgnoreReturnValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkNotNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T reference)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reference == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NullPointerException(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference; } }</code> </pre> <br>  Nachdem Sie das Argument mit der <i>checkNotNull-</i> Methode <i>√ºberpr√ºft haben</i> , k√∂nnen Sie zu 100% sicher sein, dass das an diese Methode √ºbergebene Argument nicht <i>null ist</i> .  Da beide Argumente f√ºr die <i>removeFirewallRuleFromPolicy-</i> Methode von der <i>checkNotNull-</i> Methode √ºberpr√ºft werden, ist es nicht sinnvoll, die Argumente erneut auf <i>Nullwerte</i> zu √ºberpr√ºfen.  Als erstes Argument wird jedoch ein Ausdruck an die <i>checkState-</i> Methode √ºbergeben, wobei die Argumente <i>firewallPolicyId</i> und <i>firewallRuleId</i> erneut auf <i>null</i> √ºberpr√ºft werden. <br><br>  Eine √§hnliche Warnung wird f√ºr <i>firewallRuleId</i> ausgegeben: <br><br><ul><li>  V6007 Der Ausdruck 'firewallRuleId == null' ist immer falsch.  FirewallPolicyServiceImpl.java (125) </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007 Der</a> Ausdruck ' <a href="https://www.viva64.com/ru/w/v6007/">filtersParams</a> ! = Null' ist immer wahr.  NetworkPolicyServiceImpl.java (60) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Invocation&lt;NetworkServicePolicies&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildInvocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; filteringParams)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> servicePoliciesInvocation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return servicePoliciesInvocation; }</span></span></code> </pre> <br>  Wenn in dieser Methode das Argument <i>filtersParams</i> <i>null ist</i> , wird die Methode beendet und gibt einen Wert zur√ºck.  Daher ist der Test, auf den der Analysator zeigt, immer wahr, was bedeutet, dass dieser Test keinen Sinn ergibt. <br><br>  √Ñhnliches tritt in 13 Klassen auf: <br><br><ul><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  PolicyRuleServiceImpl.java (58) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  GroupServiceImpl.java (58) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  ExternalSegmentServiceImpl.java (57) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  L3policyServiceImpl.java (57) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  PolicyRuleSetServiceImpl.java (58) </li><li>  usw... </li></ul><br><h2>  Nullreferenz </h2><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a> Potentielle Null-Dereferenzierung von 'm.blockDeviceMapping'.  NovaServerCreate.java (390) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ServerCreateBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BlockDeviceMappingCreate blockDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blockDevice != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; m.blockDeviceMapping == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { m.blockDeviceMapping = Lists.newArrayList(); } m.blockDeviceMapping.add(blockDevice); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return this; }</span></span></code> </pre> <br>  Bei dieser Methode wird die Initialisierung des Referenzfelds <i>m.blockDeviceMapping</i> nicht durchgef√ºhrt, wenn das Argument <i>blockDevice</i> den <i>Wert</i> <i>null hat</i> .  Dieses Feld wird nur in dieser Methode initialisiert. Wenn also die Methode <i>add</i> aufgerufen wird, <i>l√∂st das</i> Feld <i>m.blockDeviceMapping</i> eine <i>NullPointerException aus</i> . <br><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a> Potentielle Null-Dereferenzierung von 'FileId.get (path)' in Funktion '&lt;init&gt;'.  TrackedFile.java (140), TrackedFile.java (115) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileFlow&lt;?&gt; flow, Path path)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(flow, path, FileId.get(path), ....); }</code> </pre> <br>  Das Ergebnis der statischen Methode <i>FileId.get (path)</i> wird als drittes Argument an den Konstruktor der <i>TrackedFile-</i> Klasse √ºbergeben.  Diese Methode kann jedoch <i>null zur√ºckgeben</i> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FileId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Files.exists(file)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } .... }</code> </pre> <br>  In dem <i>hierdurch</i> aufgerufenen Konstruktor √§ndert sich das Argument <i>id</i> erst, wenn es zum ersten Mal verwendet wird: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., ...., FileId id, ....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... FileId newId = FileId.get(path); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!id.equals(newId)) { .... } }</code> </pre> <br>  Wenn daher <i>null</i> als drittes Argument an die Methode √ºbergeben wird, tritt eine Ausnahme auf. <br><br>  Eine √§hnliche Situation tritt in einem anderen Fall auf: <br><br><ul><li>  V6008 Potentielle Null-Dereferenzierung von 'Buffer'.  PublishingQueue.java (518) </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a> M√∂gliche Null-Dereferenzierung von 'dataTmpFile'.  CacheManager.java (91) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putToCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PutRecordsRequest putRecordsRequest)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dataTmpFile.createNewFile(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } catch (IOException e) { LOGGER.error("Failed to create cache tmp file, return.", e); return ; } } .... }</span></span></code> </pre> <br>  Und wieder NPE.  Durch eine Reihe von √úberpr√ºfungen in der bedingten Anweisung kann das <i>dataTmpFile-</i> Objekt f√ºr die weitere Dereferenzierung auf Null gesetzt werden.  Ich denke, hier gibt es zwei Tippfehler, und der Check sollte tats√§chlich so aussehen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !dataTmpFile.exists())</code> </pre> <br><h2>  Teilstrings und negative Zahlen </h2><br>  <a href="https://www.viva64.com/ru/w/v6009/">V6009</a> Die Funktion 'substring' kann den Wert '-1' empfangen, wenn ein nicht negativer Wert erwartet wird.  √úberpr√ºfen Sie das Argument: 2. RemoveVersionProjectIdFromURL.java (37) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String url)</span></span></span><span class="hljs-function"> </span></span>{ String urlRmovePojectId = url.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, url.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urlRmovePojectId.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, urlRmovePojectId.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); }</code> </pre> <br>  Es versteht sich, dass die URL als Zeichenfolge an diese Methode √ºbergeben wird, die in keiner Weise validiert wird.  Nachdem dieser String mit der <i>lastIndexOf-</i> Methode mehrmals <i>gek√ºrzt wurde</i> .  Wenn <i>lastIndexOf</i> keine √úbereinstimmung in der Zeichenfolge findet, wird -1 zur√ºckgegeben.  Dadurch wird eine <i>StringIndexOutOfBoundsException ausgel√∂st</i> , da die Argumente f√ºr die <i>Teilzeichenfolgemethode</i> nicht negative Zahlen sein m√ºssen.  Damit die Methode ordnungsgem√§√ü funktioniert, m√ºssen Sie das Eingabeargument validieren oder <i>sicherstellen</i> , dass die Ergebnisse der <i>lastIndexOf-</i> Methoden keine negativen Zahlen sind. <br><br>  Hier sind einige andere Orte, an denen dies passiert: <br><br><ul><li>  V6009 Die Funktion 'substring' kann den Wert '-1' empfangen, wenn ein nicht negativer Wert erwartet wird.  √úberpr√ºfen Sie das Argument: 2. RemoveProjectIdFromURL.java (37) </li><li>  V6009 Die Funktion 'substring' kann den Wert '-1' empfangen, wenn ein nicht negativer Wert erwartet wird.  √úberpr√ºfen Sie das Argument: 2. RemoveVersionProjectIdFromURL.java (38) </li></ul><br><h2>  Vergessenes Ergebnis </h2><br>  <a href="https://www.viva64.com/ru/w/v6010/">V6010</a> Der R√ºckgabewert der Funktion 'concat' muss verwendet werden.  AKSK.java (278) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildCanonicalHost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(URL url)</span></span></span><span class="hljs-function"> </span></span>{ String host = url.getHost(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port = url.getPort(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host; }</code> </pre> <br>  Beim Schreiben dieses Codes wurde nicht ber√ºcksichtigt, dass der Aufruf der <i>concat-</i> Methode die <i>Hostzeichenfolge</i> aufgrund der Unver√§nderlichkeit von Objekten des Typs <i>String</i> nicht √§ndert.  Damit die Methode ordnungsgem√§√ü funktioniert, m√ºssen Sie das Ergebnis der <i>concat-</i> Methode der <i>Hostvariablen</i> im <i>if-</i> Block zuweisen.  Richtig: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host = host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); }</code> </pre> <br><h2>  Nicht verwendete Variablen </h2><br>  <a href="https://www.viva64.com/ru/w/v6021/">V6021</a> Variable 'url' wird nicht verwendet.  TriggerV2Service.java (95) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteAllTriggersForFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String functionUrn)</span></span></span><span class="hljs-function"> </span></span>{ checkArgument(!Strings.isNullOrEmpty(functionUrn), ....); String url = ClientConstants.FGS_TRIGGERS_V2 + ClientConstants.URI_SEP + functionUrn; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deleteWithResponse(uri(triggersUrlFmt, functionUrn)).execute(); }</code> </pre> <br>  Bei dieser Methode wird die <i>URL-</i> Variable nach der Initialisierung nicht verwendet.  H√∂chstwahrscheinlich sollte die <i>URL-</i> Variable als zweites Argument anstelle von <i>functionUrn an</i> die <i>URL-</i> Methode √ºbergeben <i>werden</i> , da die Variable <i>functionUrn</i> an der Initialisierung der <i>URL-</i> Variable beteiligt ist. <br><br><h2>  Argument wird im Konstruktor nicht verwendet </h2><br>  <a href="https://www.viva64.com/ru/w/v6022/">V6022 Der</a> Parameter 'returnType' wird im Konstruktork√∂rper nicht verwendet.  HttpRequest.java (68) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpReQuest</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ .... Class&lt;R&gt; returnType; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., Class&lt;R&gt; returnType)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// &lt;= { this.endpoint = endpoint; this.path = path; this.method = method; this.entity = entity; } .... public Class&lt;R&gt; getReturnType() { return returnType; } .... }</span></span></span></span></code> </pre> <br>  In diesem Konstruktor haben sie vergessen, das <i>returnType-</i> Argument zu verwenden und dessen Wert dem <i>returnType-</i> Feld <i>zuzuweisen</i> .  Wenn die Methode <i>getReturnType aufgerufen wird</i> , gibt das von diesem Konstruktor erstellte Objekt daher den Standardwert <i>null zur√ºck</i> , obwohl h√∂chstwahrscheinlich beabsichtigt war, das Objekt <i>abzurufen</i> , das zuvor an den Konstruktor √ºbergeben wurde. <br><br><h2>  Gleiche Funktionalit√§t </h2><br>  <a href="https://www.viva64.com/ru/w/v6032/">V6032</a> Es ist merkw√ºrdig, dass der Hauptteil der Methode 'enable' dem Hauptteil einer anderen Methode ' <a href="https://www.viva64.com/ru/w/v6032/">disable</a> ' vollst√§ndig entspricht.  ServiceAction.java (32), ServiceAction.java (36) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String binary; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String host; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.binary = binary; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.host = host; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ServiceAction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// &lt;= return new ServiceAction(binary, host); } public static ServiceAction disable(String binary, String host) { // &lt;= return new ServiceAction(binary, host); } .... }</span></span></code> </pre> <br>  Das Vorhandensein von zwei identischen Methoden ist kein Fehler, aber die Tatsache, dass zwei Methoden dieselbe Aktion ausf√ºhren, ist zumindest seltsam.  Wenn wir uns die Namen der oben genannten Methoden ansehen, k√∂nnen wir annehmen, dass sie die entgegengesetzten Aktionen ausf√ºhren.  Tats√§chlich tun beide Methoden dasselbe: Sie erstellen ein <i>ServiceAction-</i> Objekt und geben es zur√ºck.  Die Methode <i>disable</i> wurde h√∂chstwahrscheinlich durch Kopieren des Codes der Methode <i>enable erstellt</i> , hat jedoch vergessen, den Methodentext zu √§ndern. <br><br><h2>  Ich habe vergessen, die Hauptsache zu √ºberpr√ºfen </h2><br>  <a href="https://www.viva64.com/ru/w/v6060/">V6060</a> Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (49), DomainService.java (46) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Domains </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_size"</span></span>), ....); Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_number"</span></span>), ....); Invocation&lt;Domains&gt; domainInvocation = get(Domains.class, uri(<span class="hljs-string"><span class="hljs-string">"/domains"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (params != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return domainInvocation.execute(this.buildExecutionOptions(Domains.class)); }</span></span></code> </pre> <br>  Bei dieser Methode haben wir beschlossen, den Inhalt einer Struktur vom Typ <i>Map</i> auf <i>Nullungleichheit</i> zu pr√ºfen.  Dazu ruft das Argument <i>params</i> die Methode <i>get</i> zweimal auf, deren Ergebnis an die Methode <i>checkNotNull √ºbergeben</i> wird.  Alles scheint logisch, aber egal wie!  In <i>if</i> wird das Argument <i>params</i> auf <i>null</i> gepr√ºft.  Danach kann angenommen werden, dass das Eingabeargument <i>null ist</i> , aber vor dieser √úberpr√ºfung wurde die Methode <i>get</i> bereits zweimal f√ºr <i>params</i> aufgerufen.  Wenn <i>null</i> als Argument an diese Methode √ºbergeben wird, wird beim ersten Aufruf der <i>get-</i> Methode eine Ausnahme ausgel√∂st. <br><br>  Eine √§hnliche Situation tritt an drei weiteren Stellen auf: <br><br><ul><li>  V6060 Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (389), DomainService.java (387) </li><li>  V6060 Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (372), DomainService.java (369) </li><li>  V6060 Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (353), DomainService.java (350) </li></ul><br><h2>  Fazit </h2><br>  Moderne Gro√üunternehmen k√∂nnen heutzutage einfach nicht auf die Nutzung von Cloud-Diensten verzichten.  Eine gro√üe Anzahl von Menschen nutzt diese Dienste, so dass selbst der kleinste Fehler in dem Dienst f√ºr viele Menschen zu Problemen sowie zu zus√§tzlichen Kosten f√ºr das Unternehmen f√ºhren kann, um die Folgen dieses Fehlers zu beheben.  Bei der Entwicklung muss immer der Faktor Mensch ber√ºcksichtigt werden, da jeder fr√ºher oder sp√§ter Fehler macht und dieser Artikel ein Beispiel daf√ºr ist.  Aus diesem Grund sollten Sie alle m√∂glichen Tools verwenden, um die Qualit√§t des Codes zu verbessern. <br><br>  PVS-Studio wird Huawei mit Sicherheit √ºber die Ergebnisse der √úberpr√ºfung seiner Cloud-Dienste informieren, damit die Entwickler dieses Unternehmens diese genauer untersuchen k√∂nnen. <br><br>  Die im Artikel gezeigte einmalige Verwendung der statischen Code-Analyse kann nicht alle Vorteile zeigen.  N√§here Informationen zur korrekten Verwendung der statischen Analyse finden Sie <a href="https://www.viva64.com/ru/b/0594/">hier</a> und <a href="https://www.viva64.com/ru/b/0639/">hier</a> .  Sie k√∂nnen den PVS-Studio Analyzer <a href="https://www.viva64.com/ru/pvs-studio-download/">hier</a> herunterladen. <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/477558/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel mit einem englischsprachigen Publikum teilen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Valery Komarov.  <a href="https://habr.com/en/company/pvs-studio/blog/477558/">Huawei Cloud: Heute ist es im PVS-Studio bew√∂lkt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477566/">https://habr.com/ru/post/de477566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477554/index.html">Die .ORG Domain Zone wird an eine private Firma verkauft. Die √ñffentlichkeit fordert die ICANN auf, den Vertrag zu k√ºndigen</a></li>
<li><a href="../de477558/index.html">Huawei Cloud: Heute ist es im PVS-Studio bew√∂lkt</a></li>
<li><a href="../de477560/index.html">√Ñndern Sie Ihre Einstellung mit SwiftUI</a></li>
<li><a href="../de477562/index.html">Interface-Design f√ºr das Spiel, zeichnen Sie eine Reihe von Symbolen</a></li>
<li><a href="../de477564/index.html">Komplexe Kunden: So sch√ºtzen Sie Ihr Team vor ihnen</a></li>
<li><a href="../de477568/index.html">Der Service ist einfach bedingungslose R√ºckgabe. Russische Post</a></li>
<li><a href="../de477578/index.html">So w√§hlen Sie eine Programmiersprache zum Erstellen einer Android-Anwendung</a></li>
<li><a href="../de477580/index.html">Beste PHP Frameworks f√ºr die Webentwicklung</a></li>
<li><a href="../de477584/index.html">Zeitloser Klassiker: Was moderne Actionspiele von DOOM lernen sollten</a></li>
<li><a href="../de477590/index.html">Embedding Code und die Gefahr von Raubkopien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>