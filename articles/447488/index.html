<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîï üöã ü•´ Romper una grieta simple con Ghidra - Parte 2 ü¶ã ü¶Ü üïó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la primera parte del art√≠culo, usando Ghidra, analizamos autom√°ticamente un simple programa de crack (que descargamos de crackmes.one). Descubrimos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Romper una grieta simple con Ghidra - Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447488/">  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte del</a> art√≠culo, usando Ghidra, analizamos autom√°ticamente un simple programa de crack (que descargamos de crackmes.one).  Descubrimos c√≥mo cambiar el nombre de las funciones "incomprensibles" directamente en la lista del descompilador, y tambi√©n entendimos el algoritmo del programa de "nivel superior", es decir.  que se realiza por <b>main ()</b> . <br><br>  En esta parte, como promet√≠, tomaremos el an√°lisis de la funci√≥n <strong>_construct_key ()</strong> , que, como descubrimos, es responsable de leer el archivo binario transferido al programa y verificar la lectura de datos. <br><a name="habracut"></a><br><h2>  Paso 5 - Descripci√≥n general de la funci√≥n _construct_key () </h2><br>  Veamos la lista completa de esta funci√≥n de inmediato: <br><br><div class="spoiler">  <b class="spoiler_title">Listado _construct_key ()</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ** __cdecl _construct_key(FILE *param_1) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVar1; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sVar2; uint uVar3; uint local_3c; byte local_36; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> local_35; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_34; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *local_30 [<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *local_20; undefined4 local_19; undefined local_15; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **local_14; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_10; local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)__prepare_key(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_14 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { local_19 = <span class="hljs-number"><span class="hljs-number">0</span></span>; local_15 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_19,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,param_1); iVar1 = _text((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;local_19,*(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iVar1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _text(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); _text(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) == <span class="hljs-number"><span class="hljs-number">5</span></span>)) { local_30[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *local_14; local_30[<span class="hljs-number"><span class="hljs-number">1</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>; local_30[<span class="hljs-number"><span class="hljs-number">2</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x218</span></span>; local_30[<span class="hljs-number"><span class="hljs-number">3</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x324</span></span>; local_20 = *local_14 + <span class="hljs-number"><span class="hljs-number">0x430</span></span>; local_10 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (local_10 &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { local_35 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_35,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*local_30[local_10] != local_35) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } local_36 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_36,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_36 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } *(uint *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = (uint)local_36; _text(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,*(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>),param_1); sVar2 = _text(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sVar2 != *(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>)) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } local_3c = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_3c,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); local_3c = local_3c + <span class="hljs-number"><span class="hljs-number">7</span></span>; uVar3 = _text(param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_3c &lt; uVar3) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } *(uint *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x108</span></span>) = local_3c; _text(param_1,local_3c,<span class="hljs-number"><span class="hljs-number">0</span></span>); local_10 = local_10 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } local_34 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_34,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)(*local_14 + <span class="hljs-number"><span class="hljs-number">0x53c</span></span>) == local_34) { _text(<span class="hljs-string"><span class="hljs-string">"Markers seem to still exist"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_14; }</code> </pre> <br></div></div><br>  Con esta funci√≥n haremos lo mismo que antes con <strong>main ()</strong> : para empezar, repasaremos las llamadas a funciones "veladas".  Como era de esperar, todas estas funciones provienen de las bibliotecas est√°ndar de C. No describir√© el procedimiento para cambiar el nombre de las funciones nuevamente; si es necesario, regrese a la primera parte del art√≠culo.  Como resultado del cambio de nombre, se "encontraron" las siguientes funciones est√°ndar: <br><br><ul><li>  fread () </li><li>  strncmp () </li><li>  strlen () </li><li>  ftell () </li><li>  fseek () </li><li>  pone () </li></ul><br>  Cambiamos el nombre de las funciones de contenedor correspondientes en nuestro c√≥digo (las que el descompilador oculta descaradamente detr√°s de la palabra <strong>_text</strong> ) agregando el √≠ndice 2 (para que no haya confusi√≥n con las funciones C originales).  Casi todas estas funciones son para trabajar con secuencias de archivos.  No es sorprendente: un vistazo r√°pido al c√≥digo es suficiente para comprender que lee datos secuencialmente de un archivo (cuyo descriptor se pasa a la funci√≥n como el √∫nico par√°metro) y compara los datos le√≠dos con una determinada matriz bidimensional de bytes <strong>locales_14</strong> . <br><br>  Supongamos que esta matriz contiene datos para la verificaci√≥n de claves.  Ll√°malo, di <strong>key_array</strong> .  Como Hydra le permite cambiar el nombre no solo de las funciones, sino tambi√©n de las variables, usaremos esto y <strong>cambiaremos</strong> el nombre del incomprensible <strong>local_14</strong> a un <strong>key_array</strong> m√°s comprensible.  Esto se hace de la misma manera que para las funciones: a trav√©s del men√∫ del bot√≥n derecho del mouse ( <strong>Cambiar nombre local</strong> ) o con la tecla <strong>L</strong> del teclado. <br><br>  Entonces, inmediatamente despu√©s de la declaraci√≥n de variables locales, se <strong>llama a</strong> una determinada funci√≥n <strong>_prepare_key ()</strong> : <br><br><pre> <code class="cpp hljs">key_array = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)__prepare_key(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key_array == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { key_array = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; }</code> </pre><br>  Volveremos a <strong>_prepare_key ()</strong> , este es el tercer nivel de anidamiento en nuestra jerarqu√≠a de llamadas: <strong>main () -&gt; _construct_key () -&gt; _prepare_key ()</strong> .  Mientras tanto, aceptamos que crea y de alguna manera inicializa esta matriz bidimensional de "prueba".  Y solo si esta matriz no est√° vac√≠a, la funci√≥n contin√∫a su trabajo, como lo demuestra el bloque <b>else</b> inmediatamente despu√©s de la condici√≥n anterior. <br><br>  Luego, el programa lee los primeros 4 bytes del archivo y lo compara con la secci√≥n correspondiente de la matriz <b>key_array</b> .  (El siguiente c√≥digo es despu√©s de cambiar el nombre, incluida la variable <b>local_19,</b> <b>renombr√© first_4bytes</b> ). <br><br><pre> <code class="cpp hljs">first_4bytes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   4    */</span></span> fread2(&amp;first_4bytes,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,param_1); <span class="hljs-comment"><span class="hljs-comment">/*   key_array[1][0...3] */</span></span> iVar1 = strncmp2((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;first_4bytes,*(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iVar1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... }</code> </pre><br>  Por lo tanto, la ejecuci√≥n adicional se produce solo si los primeros 4 bytes coinciden (recuerde esto).  Luego leemos 2 bloques de 2 bytes del archivo (y el mismo <b>key_array</b> se usa como b√∫fer para escribir datos): <br><br><pre> <code class="cpp hljs">fread2(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); fread2(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1);</code> </pre><br>  Y de nuevo, adem√°s, la funci√≥n solo funciona si la siguiente condici√≥n es verdadera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) == <span class="hljs-number"><span class="hljs-number">5</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//   ... }</span></span></code> </pre><br>  Es f√°cil ver que el primero de los bloques de 2 bytes le√≠dos anteriormente debe ser el n√∫mero 5, y el segundo debe ser el n√∫mero 4 (el tipo de datos <b>corto</b> solo ocupa 2 bytes en plataformas de 32 bits). <br><br>  Lo siguiente es esto: <br><br><pre> <code class="cpp hljs">local_30[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *key_array; <span class="hljs-comment"><span class="hljs-comment">// .. key_array[0] local_30[1] = *key_array + 0x10c; local_30[2] = *key_array + 0x218; local_30[3] = *key_array + 0x324; local_20 = *key_array + 0x430;</span></span></code> </pre><br>  Aqu√≠ vemos que la matriz <b>local_30</b> (declarada como char * local_30 [4]) contiene los desplazamientos del puntero <b>key_array</b> .  Es decir, <b>local_30</b> es una matriz de l√≠neas de marcador en la que probablemente se leer√°n los datos del archivo.  Bajo esta suposici√≥n, <b>cambi√© el</b> nombre de <b>local_30</b> a <b>marcadores</b> .  En esta secci√≥n de c√≥digo, solo la √∫ltima l√≠nea parece un poco sospechosa, donde la asignaci√≥n del √∫ltimo desplazamiento (en el √≠ndice 0x430, es decir, 1072) no se realiza por el siguiente elemento de <b>marcadores</b> , sino por una variable <b>local_20</b> separada ( <b>char *</b> ).  Pero a√∫n lo resolveremos, pero por ahora, ¬°sigamos adelante! <br><br>  A continuaci√≥n estamos esperando un ciclo: <br><br><pre> <code class="cpp hljs"> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// local_10   i while (i &lt; 5) { // ... i = i + 1; }</span></span></code> </pre><br>  Es decir  Solo 5 iteraciones de 0 a 4 inclusive.  En el bucle, la lectura del archivo y la verificaci√≥n del cumplimiento de nuestra matriz de <b>marcadores</b> comienza de inmediato: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c_marker = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_35 /*  .    */ fread2(&amp;c_marker, 1, 1, param_1); if (*markers[i] != c_marker) { /*    -      */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  Es decir, el siguiente byte del archivo se lee en la variable <b>c_marker</b> (en el c√≥digo descompilado original - <b>local_35</b> ) y se verifica el cumplimiento del primer car√°cter del elemento de <b>marcadores</b> i-th.  En caso de una falta de coincidencia, la matriz <b>key_array</b> se pone a cero y se devuelve un puntero doble vac√≠o.  M√°s adelante en el c√≥digo, vemos que esto se hace cuando los datos le√≠dos no coinciden con los datos de verificaci√≥n. <br><br>  Pero aqu√≠, como dicen, "el perro est√° enterrado".  Echemos un vistazo m√°s de cerca a este ciclo.  Tiene 5 iteraciones, como descubrimos.  Puede verificar esto si lo desea mirando el c√≥digo del ensamblador: <br><br><img src="https://habrastorage.org/webt/si/b4/q8/sib4q8jsxe2zyxpxi2gcwy0vfba.png"><br><br><img src="https://habrastorage.org/webt/tr/8q/oh/tr8qoh9ayg-7v9t6rv1vwtsuy_c.png"><br><br>  De hecho, el comando CMP compara el valor de la variable <b>local_10</b> (ya tenemos <b>i</b> ) con el n√∫mero 4 y si el valor es <i>menor o igual a</i> 4 (el comando JLE), se realiza la transici√≥n a la etiqueta <b>LAB_004017eb</b> , es decir.  comienzo del cuerpo del ciclo.  Es decir  la condici√≥n se cumplir√° para <b>i</b> = 0, 1, 2, 3 y 4, ¬°solo 5 iteraciones!  Todo estar√≠a bien, pero los <b>marcadores</b> tambi√©n <b>est√°n</b> indexados por esta variable en un bucle, y despu√©s de todo, esta matriz se declara con solo 4 elementos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *markers [<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre><br>  Entonces, alguien claramente est√° tratando de enga√±ar a alguien :) ¬øRecuerdas que dije que esta l√≠nea es dudosa? <br><br><pre> <code class="cpp hljs">local_20 = *key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>;</code> </pre><br>  Solo asi!  Simplemente mire la lista completa de la funci√≥n e intente encontrar al menos una referencia m√°s a la variable <b>local_20</b> .  Ella no esta ahi!  Concluimos de esto: este desplazamiento tambi√©n debe almacenarse en la matriz de <b>marcadores</b> , y la matriz en s√≠ misma debe contener 5 elementos.  Vamos a arreglarlo  Vaya a la declaraci√≥n de variable, <b>presione Ctrl + L</b> (Reescribir variable) y cambie audazmente el tama√±o de la matriz a 5: <br><br><img src="https://habrastorage.org/webt/t0/sq/xw/t0sqxw-hbw5dqo9mca3m43r5cei.png"><br><br>  Listo  Despl√°cese hacia abajo hasta el c√≥digo para asignar desplazamientos de puntero a los <b>marcadores</b> , y ¬°he aqu√≠!  - una variable extra incomprensible desaparece y todo encaja: <br><br><pre> <code class="cpp hljs">markers[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *key_array; markers[<span class="hljs-number"><span class="hljs-number">1</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>; markers[<span class="hljs-number"><span class="hljs-number">2</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x218</span></span>; markers[<span class="hljs-number"><span class="hljs-number">3</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x324</span></span>; markers[<span class="hljs-number"><span class="hljs-number">4</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ...   !</span></span></code> </pre><br>  Volvemos a nuestro <b>ciclo while</b> (en el c√≥digo fuente, esto probablemente sea <b>para</b> , pero no nos importa).  A continuaci√≥n, el byte del archivo se lee nuevamente y se verifica su valor: <br><br><pre> <code class="cpp hljs">byte n_strlen1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_36 /*  .    */ fread2(&amp;n_strlen1,1,1,param_1); if (n_strlen1 == 0) { /*      */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  OK, este <b>n_strlen1</b> debe ser distinto de cero.  Por qu√©  Ver√° ahora, pero al mismo tiempo comprender√° por qu√© le di a esta variable el siguiente nombre: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   n_strlen1)  (markers[i] + 0x104) */</span></span> *(uint *)(markers[i] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = (uint)n_strlen1; <span class="hljs-comment"><span class="hljs-comment">/*    (n_strlen1)  (--&gt;  ?) */</span></span> fread2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,*(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(markers[i] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>),param_1); n_strlen2 = strlen2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   sVar2 if (n_strlen2 != *(size_t *)(markers[i] + 0x104)) { /*    (n_strlen2)  == n_strlen1 */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  Agregu√© comentarios en los que todo deber√≠a estar claro.  <b>N_strlen1</b> bytes se leen del archivo y se guardan como una secuencia de caracteres (es decir, una cadena) en la matriz de <b>marcadores [i]</b> , es decir, despu√©s del "s√≠mbolo de detenci√≥n" correspondiente, que ya est√° escrito all√≠ desde <b>key_array</b> .  Guardar el valor <b>n_strlen1</b> en los <b>marcadores [i]</b> en el desplazamiento 0x104 (260) no juega ning√∫n papel aqu√≠ (vea la primera l√≠nea en el c√≥digo anterior).  De hecho, este c√≥digo se puede optimizar de la siguiente manera (y ciertamente este es el caso en el c√≥digo fuente): <br><br><pre> <code class="cpp hljs">fread2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) n_strlen1, param_1); n_strlen2 = strlen2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n_strlen2 != (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) n_strlen1) { ... }</code> </pre><br>  Tambi√©n verifica que la longitud de la l√≠nea de lectura sea <b>n_strlen1</b> .  Esto puede parecer innecesario, dado que este par√°metro se pas√≥ a la funci√≥n <b>fread</b> , pero <b>fread</b> <i>no</i> lee <i>m√°s que</i> tantos bytes especificados y puede leer menos de lo indicado, por ejemplo, en el caso de cumplir con el marcador de fin de archivo (EOF).  Es decir, todo es estricto: la longitud de la l√≠nea (en bytes) se indica en el archivo, luego la l√≠nea en s√≠ va, y exactamente 5 veces.  Pero nos estamos adelantando a nosotros mismos. <br><br>  Adem√°s riega este c√≥digo (que tambi√©n coment√© de inmediato): <br><br><pre> <code class="cpp hljs">uint n_pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_3c /*  .    */ fread2(&amp;n_pos,1,1,param_1); /*   7 */ n_pos = n_pos + 7; /*     */ uint n_filepos = ftell2(param_1); //   uVar3 if (n_pos &lt; n_filepos) { /* n_pos   &gt;= n_filepos */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  Todav√≠a es m√°s simple aqu√≠: tomamos el siguiente byte del archivo, agregamos 7 y comparamos el valor resultante con la posici√≥n actual del cursor en la secuencia del archivo obtenida por la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funci√≥n ftell ()</a> .  El valor de <b>n_pos no</b> debe ser menor que la posici√≥n del cursor (es decir, desplazamiento en bytes desde el comienzo del archivo). <br><br>  La l√≠nea final en el bucle: <br><br><pre> <code class="cpp hljs">fseek2(param_1,n_pos,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Es decir  reorganice el cursor del archivo (desde el principio) a la posici√≥n indicada por <b>n_pos</b> por la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fseek ()</a> .  Bien, hacemos todas estas operaciones en el ciclo 5 veces.  La funci√≥n <b>_construct_key () termina con el</b> siguiente c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_lastmarker = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_34 /*   4    (int32) */ fread2(&amp;i_lastmarker,4,1,param_1); if (*(int *)(*key_array + 0x53c) == i_lastmarker) { /*    == key_array[0][1340] ...   :) */ puts2("Markers seem to still exist"); } else { _free_key(key_array); key_array = (char **)0x0; }</span></span></code> </pre><br>  Por lo tanto, el √∫ltimo bloque de datos en el archivo debe ser un valor entero de 4 bytes y debe ser igual al valor en <b>key_array [0] [1340]</b> .  En este caso, recibiremos un mensaje de felicitaci√≥n en la consola.  De lo contrario, la matriz vac√≠a a√∫n regresa sin ning√∫n elogio :) <br><br><h2>  Paso 6 - Descripci√≥n general de la funci√≥n __prepare_key () </h2><br>  Solo nos queda una funci√≥n sin ensamblar: <b>__prepare_key ()</b> .  Ya hemos adivinado que es all√≠ donde se generan los datos de verificaci√≥n en forma de la matriz <b>key_array</b> , que luego se utiliza en la funci√≥n <b>_construct_key ()</b> para verificar los datos del archivo.  ¬°Queda por descubrir qu√© tipo de datos hay! <br><br>  No analizar√© esta funci√≥n en detalle e inmediatamente dar√© una lista completa con comentarios despu√©s de todo el cambio de nombre necesario de las variables: <br><br><div class="spoiler">  <b class="spoiler_title">__Prepare_key () listado de funciones</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ** __prepare_key(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **key_array; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *pvVar1; <span class="hljs-comment"><span class="hljs-comment">/* key_array = new char*[2]; // 2 4-  (char*) */</span></span> key_array = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key_array == (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { key_array = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pvVar1 = calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0x540</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* key_array[0] = new char[1340] */</span></span> *key_array = pvVar1; pvVar1 = calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* key_array[1] = new char[8] */</span></span> key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = pvVar1; <span class="hljs-comment"><span class="hljs-comment">/* "VOID" */</span></span> *(undefined4 *)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0x404024</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 5  4 (2- ) */</span></span> *(undefined2 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) = <span class="hljs-number"><span class="hljs-number">5</span></span>; *(undefined2 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* key_array[0][0] = 'b' */</span></span> *(undefined *)*key_array = <span class="hljs-number"><span class="hljs-number">0x62</span></span>; *(undefined4 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'W' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x218</span></span>) = <span class="hljs-number"><span class="hljs-number">0x57</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'p' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x324</span></span>) = <span class="hljs-number"><span class="hljs-number">0x70</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'l' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>) = <span class="hljs-number"><span class="hljs-number">0x6c</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 152 ( ASCII) */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>) = <span class="hljs-number"><span class="hljs-number">0x98</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   = 1122 (int32) */</span></span> *(undefined4 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x53c</span></span>) = <span class="hljs-number"><span class="hljs-number">0x462</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key_array; }</code> </pre><br></div></div><br>  El √∫nico lugar que vale la pena considerar es esta l√≠nea: <br><br><pre> <code class="cpp hljs">*(undefined4 *)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0x404024</span></span>;</code> </pre><br>  ¬øC√≥mo entiendo que aqu√≠ se encuentra la l√≠nea "ANULAR"?  El hecho es que 0x404024 es la direcci√≥n en el espacio de direcciones del programa que conduce a la secci√≥n <b>.rdata</b> .  Hacer doble clic en este valor nos permite ver claramente qu√© hay all√≠: <br><br><img src="https://habrastorage.org/webt/8a/eu/0j/8aeu0jkpr-ea7euhrlcgvm0rxq8.png"><br><br>  Por cierto, lo mismo se puede entender del c√≥digo del ensamblador para esta l√≠nea: <br><br> <code>004015da c7 00 24 MOV dword ptr [EAX], .rdata = 56h V <br> 40 40 00 <br></code> <br>  Los datos correspondientes a la l√≠nea VOID se encuentran al comienzo de la secci√≥n <b>.rdata</b> (con un desplazamiento cero de la direcci√≥n correspondiente). <br><br>  Entonces, a la salida de esta funci√≥n, se debe formar una matriz bidimensional con los siguientes datos: <br><br> <code>[0] [0]:'b' [268]:'l' [536]:'W' [804]:'p' [1072]:152 [1340]:1122 <br> [1] [0-3]:"VOID" [4-5]:5 [6-7]:4 <br></code> <br><h2>  Paso 7 - Prepara el binario para el crack </h2><br>  Ahora podemos comenzar la s√≠ntesis del archivo binario.  Todos los datos iniciales en nuestras manos: <br>  1) datos de verificaci√≥n ("s√≠mbolos de parada") y sus posiciones en la matriz de verificaci√≥n; <br>  2) la secuencia de datos en el archivo <br><br>  Vamos a restaurar la estructura del archivo deseado de acuerdo con el algoritmo de la funci√≥n <b>_construct_key ()</b> .  Entonces, la secuencia de datos en el archivo ser√° la siguiente: <br><br><div class="spoiler">  <b class="spoiler_title">Estructura de archivo</b> <div class="spoiler_text"><ol><li>  4 bytes == key_array [1] [0 ... 3] == "ANULADO" </li><li>  2 bytes == key_array [1] [4] == 5 </li><li>  2 bytes == key_array [1] [6] == 4 </li><li>  1 byte == key_array [0] [0] == 'b' (token) </li><li>  1 byte == (longitud de la l√≠nea siguiente) == n_strlen1 </li><li>  n_strlen1 bytes == (cualquier cadena) == n_strlen1 </li><li>  1 byte == (+7 == siguiente token) == n_pos </li><li>  1 byte == key_array [0] [0] == 'l' (token) </li><li>  1 byte == (longitud de la l√≠nea siguiente) == n_strlen1 </li><li>  n_strlen1 bytes == (cualquier cadena) == n_strlen1 </li><li>  1 byte == (+7 == siguiente token) == n_pos </li><li>  1 byte == key_array [0] [0] == 'W' (token) </li><li>  1 byte == (longitud de la l√≠nea siguiente) == n_strlen1 </li><li>  n_strlen1 bytes == (cualquier cadena) == n_strlen1 </li><li>  1 byte == (+7 == siguiente token) == n_pos </li><li>  1 byte == key_array [0] [0] == 'p' (token) </li><li>  1 byte == (longitud de la l√≠nea siguiente) == n_strlen1 </li><li>  n_strlen1 bytes == (cualquier cadena) == n_strlen1 </li><li>  1 byte == (+7 == siguiente token) == n_pos </li><li>  1 byte == key_array [0] [0] == 152 (token) </li><li>  1 byte == (longitud de la l√≠nea siguiente) == n_strlen1 </li><li>  n_strlen1 bytes == (cualquier cadena) == n_strlen1 </li><li>  1 byte == (+7 == siguiente token) == n_pos </li><li>  4 bytes == (key_array [1340]) == 1122 </li></ol><br></div></div><br>  Para mayor claridad, hice en Excel una tableta con los datos del archivo deseado: <br><br><img src="https://habrastorage.org/webt/kr/i-/7a/kri-7arjlro0ye_los64uhakbfq.png"><br><br>  Aqu√≠ en la s√©ptima l√≠nea, los datos en forma de caracteres y n√∫meros, en la sexta l√≠nea, sus representaciones hexadecimales, en la octava l√≠nea, el tama√±o de cada elemento (en bytes), en la novena l√≠nea, el desplazamiento relativo al comienzo del archivo.  Esta vista es muy conveniente porque  le permite ingresar cualquier l√≠nea en el archivo futuro (marcado con un relleno amarillo), mientras que los valores de las longitudes de estas l√≠neas, as√≠ como los desplazamientos de posici√≥n del siguiente s√≠mbolo de parada, se calculan mediante f√≥rmulas autom√°ticamente, seg√∫n lo requiera el algoritmo del programa.  Arriba (en las l√≠neas 1-4), se <b>muestra</b> la estructura de la <b>matriz de</b> verificaci√≥n <b>key_array</b> . <br><br>  El Excel en s√≠ y otros materiales de origen para el art√≠culo se pueden descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h3>  Generaci√≥n y validaci√≥n de archivos binarios. </h3><br>  Lo √∫nico que queda es generar el archivo deseado en formato binario y alimentarlo con nuestro crack.  Para generar el archivo, escrib√≠ un script simple de Python: <br><br><div class="spoiler">  <b class="spoiler_title">Script para generar el archivo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys, os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess out_str = [<span class="hljs-string"><span class="hljs-string">'!'</span></span>, <span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">' solved'</span></span>, <span class="hljs-string"><span class="hljs-string">' this'</span></span>, <span class="hljs-string"><span class="hljs-string">' crackme!'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(file_path, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> outfile: outfile.write(<span class="hljs-string"><span class="hljs-string">'VOID'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'2h'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'b'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos = <span class="hljs-number"><span class="hljs-number">10</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'l'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'W'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'p'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-number"><span class="hljs-number">152</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'i'</span></span>, <span class="hljs-number"><span class="hljs-number">1122</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> err: print(err) <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(sys.argv) != <span class="hljs-number"><span class="hljs-number">2</span></span>: print(<span class="hljs-string"><span class="hljs-string">'USAGE: {this_script.py} path_to_crackme[.exe]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.isfile(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]): print(<span class="hljs-string"><span class="hljs-string">'File "{}" unavailable!'</span></span>.format(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> file_path = os.path.splitext(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">'.dat'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: write_file(file_path) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: outputstr = subprocess.check_output(<span class="hljs-string"><span class="hljs-string">'"{}" -f "{}"'</span></span>.format(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], file_path), stderr=subprocess.STDOUT) print(outputstr.decode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> err: print(err) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: main()</code> </pre><br></div></div><br>  El script toma la ruta a las grietas como un par√°metro √∫nico, luego genera un archivo binario con la clave en el mismo directorio y llama a las grietas con el par√°metro correspondiente, traduciendo la salida del programa a la consola. <br><br>  Para convertir datos de texto a binario, use el paquete de <b>estructura</b> .  El m√©todo <b>pack () le</b> permite escribir datos binarios en un formato en el que se indica el tipo de datos ("B" = "byte", "i" = int, etc.), y tambi√©n puede especificar la secuencia ("&gt;" = "Big -endian "," &lt;"=" Little-endian ").  El orden predeterminado es Little-endian.  Porque  Ya determinamos en el primer art√≠culo que este es exactamente nuestro caso, luego indicamos solo el tipo. <br><br>  Todo el c√≥digo en su conjunto reproduce el algoritmo de programa que encontramos.  Como la l√≠nea a imprimir si tiene √©xito, especifiqu√© "¬°Resolv√≠ este crackme!"  (puede modificar este script para que sea posible especificar cualquier l√≠nea). <br><br>  Verifique la salida: <br><br><img src="https://habrastorage.org/webt/th/mx/pz/thmxpzy22t8leydwou56w3emrze.png"><br><br>  ¬°Hurra, todo funciona!  Entonces, despu√©s de sudar un poco y haber resuelto un par de funciones, pudimos restaurar completamente el algoritmo del programa y "descifrarlo".  Por supuesto, esto es solo un simple crack, un programa de prueba e incluso el del segundo nivel de dificultad (de los 5 ofrecidos en ese sitio).  En realidad, trataremos con una compleja jerarqu√≠a de llamadas y docenas, cientos de funciones y, en algunos casos, secciones cifradas de datos, c√≥digo basura y otras t√©cnicas de ofuscaci√≥n, hasta el uso de m√°quinas virtuales internas y c√≥digo P ... Pero esto, como dicen, ya es Una historia completamente diferente. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Materiales para el art√≠culo.</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447488/">https://habr.com/ru/post/447488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447474/index.html">Un an√°logo de decatr√≥n funcional en miniatura para la r√©plica Harwell Dekatron Computer y no solo</a></li>
<li><a href="../447476/index.html">Configuraci√≥n de LaTeX en texto sublime</a></li>
<li><a href="../447478/index.html">La ilusi√≥n de inmutabilidad y confianza como base del desarrollo del equipo.</a></li>
<li><a href="../447480/index.html">D√≠a de la Cosmon√°utica 2019: eventos por ciudad</a></li>
<li><a href="../447482/index.html">Escuela de derecho cibern√©tico. Ley digital intensiva de 5 d√≠as</a></li>
<li><a href="../447490/index.html">C√≥mo mejorar tu estilo de escritura en ingl√©s: 5 consejos</a></li>
<li><a href="../447494/index.html">Sostenibilidad GAN Learning (Profundizando m√°s)</a></li>
<li><a href="../447496/index.html">Gesti√≥n de frambuesa a trav√©s de websockets</a></li>
<li><a href="../447498/index.html">Reportaje fotogr√°fico de JPoint 2019 + anuncio de Joker 2019 en San Petersburgo</a></li>
<li><a href="../447500/index.html">Por qu√© los operadores se asustaron con eSIM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>