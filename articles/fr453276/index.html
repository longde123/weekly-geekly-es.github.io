<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòà ü§∏ üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø Arduino et temporisation interrompt üà∏ üë£ ‚úåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article "Timer interrupts" de E. 
 Pr√©face 


 La carte Arduino vous permet de r√©soudre rapidement ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduino et temporisation interrompt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453276/"><p>  Bonjour, Habr!  Je vous pr√©sente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Timer interrupts"</a> de E. </p><br><h3 id="predislovie">  Pr√©face </h3><br><p>  La carte Arduino vous permet de r√©soudre rapidement et de mani√®re minimale une vari√©t√© de probl√®mes.  Mais l√† o√π des intervalles de temps arbitraires sont n√©cessaires (interrogation p√©riodique des capteurs, signaux PWM de haute pr√©cision, impulsions de longue dur√©e), les fonctions de d√©lai de biblioth√®que standard ne sont pas pratiques.  Pendant la dur√©e de leur action, l'esquisse est suspendue et il devient impossible de la g√©rer. </p><br><p>  Dans une situation similaire, il est pr√©f√©rable d'utiliser les minuteries AVR int√©gr√©es.  Un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article r√©ussi</a> explique comment faire cela et ne pas se perdre dans la jungle technique des fiches techniques, dont une traduction est port√©e √† votre attention. </p><br><p><img src="https://habrastorage.org/webt/3g/n_/iw/3gn_iwqe-tubwgqslsclzuaznki.png"></p><a name="habracut"></a><br><p>  Cet article d√©crit les temporisateurs AVR et Arduino et comment les utiliser dans des projets Arduino et des circuits utilisateur. </p><br><h3 id="chto-takoe-taymer">  Qu'est-ce qu'une minuterie? </h3><br><p> Comme dans la vie quotidienne des microcontr√¥leurs, une minuterie est une chose qui peut signaler √† l'avenir, au moment o√π vous la d√©finissez.  Lorsque ce moment arrive, le microcontr√¥leur est interrompu, lui rappelant de faire quelque chose, par exemple, pour ex√©cuter un certain morceau de code. </p><br><p>  Les minuteries, comme les interruptions externes, fonctionnent ind√©pendamment du programme principal.  Au lieu de boucler ou de r√©p√©ter l'appel de retard <em>millis ()</em> , vous pouvez assigner une minuterie pour faire son travail pendant que votre code fait d'autres choses. </p><br><p>  Supposons donc qu'un appareil doive faire quelque chose, par exemple, faire clignoter une LED toutes les 5 secondes.  Si vous n'utilisez pas de minuteries, mais √©crivez du code normal, vous devez d√©finir une variable au moment o√π la LED est allum√©e et v√©rifier constamment si le moment de sa commutation est arriv√©.  Avec une interruption de minuterie, il vous suffit de configurer l'interruption, puis de d√©marrer la minuterie.  La LED clignotera exactement √† l'heure, quelles que soient les actions du programme principal. </p><br><h3 id="kak-rabotaet-taymer">  Comment fonctionne la minuterie? </h3><br><p>  Il agit en incr√©mentant une variable appel√©e <em>registre de comptage</em> .  Le registre de comptage peut compter jusqu'√† une certaine valeur, en fonction de sa taille.  La minuterie incr√©mente son compteur encore et encore jusqu'√† ce qu'il atteigne sa valeur maximale, √† ce stade, le compteur d√©bordera et se remettra √† z√©ro.  Une minuterie d√©finit g√©n√©ralement un bit indicateur pour vous informer qu'un d√©passement s'est produit. </p><br><p>  Vous pouvez v√©rifier cet indicateur manuellement ou effectuer un changement de minuterie - provoquer une interruption automatiquement lorsque l'indicateur est d√©fini.  Comme toute autre interruption, vous pouvez affecter une <em>routine de service d'interruption</em> ( <em>ISR</em> ) pour ex√©cuter le code sp√©cifi√© lorsque le temporisateur d√©borde.  L'ISR lui-m√™me effacera l'indicateur de d√©bordement, donc l'utilisation d'interruptions est g√©n√©ralement le meilleur choix en raison de sa simplicit√© et de sa vitesse. </p><br><p>  Pour augmenter les valeurs du compteur √† des intervalles de temps exacts, la minuterie doit √™tre connect√©e √† la source d'horloge.  La source d'horloge g√©n√®re un signal √† r√©p√©tition constante.  Chaque fois que le temporisateur d√©tecte ce signal, il augmente la valeur du compteur d'une unit√©.  √âtant donn√© que la minuterie fonctionne sur une source d'horloge, la plus petite unit√© de temps mesurable est la p√©riode de cycle.  Si vous connectez un signal d'horloge de 1 MHz, la r√©solution du minuteur (ou la p√©riode du minuteur) sera: </p><br><p>  T = 1 / f (f est la fr√©quence d'horloge) <br>  T = 1/1 MHz = 1/10 ^ 6 Hz <br>  T = (1 ‚àó 10 ^ -6) s </p><br><p>  Ainsi, la r√©solution de la minuterie est d'un millioni√®me de seconde.  Bien que vous puissiez utiliser une source d'horloge externe pour les minuteries, dans la plupart des cas, la source interne de la puce elle-m√™me est utilis√©e. </p><br><h3 id="tipy-taymerov">  Types de minuterie </h3><br><p>  Dans les cartes Arduino standard sur une puce AVR 8 bits, il y a plusieurs temporisateurs √† la fois.  Les puces Atmega168 et Atmega328 ont trois temporisateurs Timer0, Timer1 et Timer2.  Ils ont √©galement une horloge de surveillance qui peut √™tre utilis√©e pour se prot√©ger contre les pannes ou comme m√©canisme de r√©initialisation logicielle.  Voici quelques fonctionnalit√©s de chaque minuterie. </p><br><p>  Timer0: <br>  Timer0 est un temporisateur 8 bits, ce qui signifie que son registre de comptage peut stocker des nombres jusqu'√† 255 (c'est-√†-dire un octet non sign√©).  Timer0 est utilis√© par les fonctions temporaires Arduino standard telles que <em>delay ()</em> et <em>millis ()</em> , il est donc pr√©f√©rable de ne pas le confondre si vous vous souciez des cons√©quences. </p><br><p>  Timer1: <br>  Timer1 est un temporisateur de 16 bits avec une valeur de comptage maximale de 65535 (entier non sign√©).  Ce minuteur utilise la biblioth√®que Arduino Servo, gardez cela √† l'esprit si vous l'utilisez dans vos projets. </p><br><p>  Timer2: <br>  Timer2 est 8 bits et est tr√®s similaire √† Timer0.  Il est utilis√© dans la fonction Arduino <em>tone ()</em> . </p><br><p>  Timer3, Timer4, Timer5: <br>  Les puces ATmega1280 et ATmega2560 (install√©es dans les variantes Arduino Mega) ont trois temporisateurs suppl√©mentaires.  Tous sont en 16 bits et fonctionnent de mani√®re similaire √† Timer1. </p><br><h3 id="konfiguraciya-registrov">  Enregistrer la configuration </h3><br><p>  Afin d'utiliser ces minuteries, l'AVR dispose de registres de param√®tres.  Les temporisateurs contiennent de nombreux registres de ce type.  Deux d'entre eux - les registres de contr√¥le du temporisateur / compteur contiennent des variables de r√©glage et sont appel√©s TCCRxA et TCCRxB, o√π x est le num√©ro du temporisateur (TCCR1A et TCCR1B, etc.).  Chaque registre contient 8 bits et chaque bit stocke une variable de configuration.  Voici les d√©tails de la fiche technique Atmega328: </p><br><div class="scrollable-table"><table><thead><tr><th>  TCCR1A </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>  Bit </td><td>  7 </td><td>  6 </td><td>  5 </td><td>  4 </td><td>  3 </td><td>  2 </td><td>  1 </td><td>  0 </td></tr><tr><td>  0x80 </td><td>  COM1A1 </td><td>  COM1A0 </td><td>  COM1B1 </td><td>  COM1B0 </td><td>  - </td><td>  - </td><td>  Wgm11 </td><td>  Wgm10 </td></tr><tr><td>  R√©√©criture </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  R </td><td>  R </td><td>  Rw </td><td>  Rw </td></tr><tr><td>  Valeur initiale </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  TCCR1B </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>  Bit </td><td>  7 </td><td>  6 </td><td>  5 </td><td>  4 </td><td>  3 </td><td>  2 </td><td>  1 </td><td>  0 </td></tr><tr><td>  0x81 </td><td>  ICNC1 </td><td>  ICES1 </td><td>  - </td><td>  Wgm13 </td><td>  Wgm12 </td><td>  CS12 </td><td>  CS11 </td><td>  CS10 </td></tr><tr><td>  R√©√©criture </td><td>  Rw </td><td>  Rw </td><td>  R </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td></tr><tr><td>  Valeur initiale </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr></tbody></table></div><br><p>  Les plus importants sont les trois derniers bits de TCCR1B: CS12, CS11 et CS10.  Ils d√©terminent la fr√©quence d'horloge du temporisateur.  En les choisissant dans diff√©rentes combinaisons, vous pouvez commander la minuterie pour agir √† diff√©rentes vitesses.  Voici un tableau de donn√©es techniques d√©crivant l'effet des bits s√©lectionn√©s: </p><br><div class="scrollable-table"><table><thead><tr><th>  CS12 </th><th>  CS11 </th><th>  CS10 </th><th>  Action </th></tr></thead><tbody><tr><td>  0 </td><td>  0 </td><td>  0 </td><td>  Pas de source d'horloge (minuterie / compteur arr√™t√©) </td></tr><tr><td>  0 </td><td>  0 </td><td>  1 </td><td>  clk_io / 1 (pas de division) </td></tr><tr><td>  0 </td><td>  1 </td><td>  0 </td><td>  clk_io / 8 (diviseur de fr√©quence) </td></tr><tr><td>  0 </td><td>  1 </td><td>  1 </td><td>  clk_io / 64 (diviseur de fr√©quence) </td></tr><tr><td>  1 </td><td>  0 </td><td>  0 </td><td>  clk_io / 256 (diviseur de fr√©quence) </td></tr><tr><td>  1 </td><td>  0 </td><td>  1 </td><td>  clk_io / 1024 (diviseur de fr√©quence) </td></tr><tr><td>  1 </td><td>  1 </td><td>  0 </td><td>  Source d'horloge externe sur la broche T1.  Horloge de r√©cession </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td><td>  Source d'horloge externe sur la broche T1.  Horloge avant </td></tr></tbody></table></div><br><p>  Par d√©faut, tous ces bits sont mis √† z√©ro. </p><br><p>  Supposons que vous vouliez que Timer1 s'ex√©cute √† une fr√©quence d'horloge avec un √©chantillon par p√©riode.  Quand il d√©borde, vous voulez appeler la routine d'interruption, qui fait passer la LED connect√©e √† la jambe 13 √† l'√©tat allum√© ou √©teint.  Pour cet exemple, nous √©crirons le code Arduino, mais nous utiliserons les proc√©dures et les fonctions de la biblioth√®que avr-libc chaque fois que cela ne rend pas les choses trop compliqu√©es.  Les partisans de l'AVR pur peuvent adapter le code √† leur guise. </p><br><p>  Tout d'abord, initialisez le minuteur: </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// avr-libc library includes #include &lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #define LEDPIN 13 void setup() { pinMode(LEDPIN, OUTPUT); //  Timer1 cli(); //    TCCR1A = 0; //  TCCR1A   0 TCCR1B = 0; //   Timer1 overflow: TIMSK1 = (1 &lt;&lt; TOIE1); //  CS10  ,      : TCCR1B |= (1 &lt;&lt; CS10); sei(); //    }</span></span></code> </pre> <br><p>  Le registre TIMSK1 est un registre de masque d'interruption temporisateur / compteur1.  Il contr√¥le l'interruption que la minuterie peut provoquer.  La d√©finition du bit TOIE1 indique au temporisateur d'interrompre lorsque le temporisateur d√©borde.  Plus d'informations √† ce sujet plus tard. </p><br><p>  Lorsque vous d√©finissez le bit CS10, la minuterie commence √† compter et d√®s qu'une interruption de d√©passement se produit, l'ISR (TIMER1_OVF_vect) est appel√©.  Cela se produit toujours lorsque la minuterie d√©borde. </p><br><p>  Nous d√©finissons ensuite la fonction d'interruption ISR: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_OVF_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</code> </pre> <br><p>  Nous pouvons maintenant d√©finir le cycle loop () et changer la LED ind√©pendamment de ce qui se passe dans le programme principal.  Pour d√©sactiver la minuterie, r√©glez TCCR1B = 0 √† tout moment. </p><br><h3 id="kak-chasto-budet-migat-svetodiod">  √Ä quelle fr√©quence la LED clignotera-t-elle? </h3><br><p>  Timer1 est r√©gl√© pour d√©border l'interruption et supposons que vous utilisez un Atmega328 avec une fr√©quence d'horloge de 16 MHz.  √âtant donn√© que la minuterie est de 16 bits, elle peut compter jusqu'√† la valeur maximale (2 ^ 16 - 1), ou 65535. √Ä 16 MHz, le cycle s'ex√©cute 1 / (16 ‚àó 10 ^ 6) secondes ou 6,25e-8 s.  Cela signifie que 65535 √©chantillons se produiront en (65535 ‚àó 6,25e-8 s) et que l'ISR sera appel√© apr√®s environ 0,0041 s.  Et donc √† chaque fois, tous les quatre milli√®mes de seconde.  Il est trop rapide de voir le scintillement. </p><br><p>  Si nous appliquons un signal PWM tr√®s rapide avec une couverture de 50% √† la LED, alors la lueur appara√Ætra continue, mais moins lumineuse que d'habitude.  Une telle exp√©rience montre la puissance incroyable des microcontr√¥leurs - m√™me une puce 8 bits peu co√ªteuse peut traiter les informations beaucoup plus rapidement que nous ne pouvons le d√©tecter. </p><br><h3 id="delitel-taymera-i-rezhim-ctc">  Diviseur de minuterie et mode CTC </h3><br><p>  Pour contr√¥ler la p√©riode, vous pouvez utiliser un diviseur qui vous permet de diviser le signal d'horloge en diff√©rents degr√©s de deux et d'augmenter la p√©riode de la minuterie.  Par exemple, vous souhaitez que la LED clignote √† des intervalles d'une seconde.  Il y a trois bits CS dans le registre TCCR1B d√©finissant la r√©solution la plus appropri√©e.  Si vous d√©finissez les bits CS10 et CS12 en utilisant: </p><br><pre> <code class="cpp hljs">TCCR1B |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; CS10); TCCR1B |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; CS12);</code> </pre> <br><p>  alors la fr√©quence de la source d'horloge sera divis√©e par 1024. Cela donne une r√©solution de temporisation de 1 / (16 ‚àó 10 ^ 6/1024) ou 6,4e-5 s.  Maintenant, la minuterie d√©bordera tous les (65535 ‚àó 6,4e-5s) ou pour 4,194 s.  C'est trop long. </p><br><p>  Mais il existe un autre mode de minuterie AVR.  C'est ce qu'on appelle une r√©initialisation du temporisateur co√Øncident ou CTC.  Au lieu de compter pour d√©border, le temporisateur compare son compteur avec la variable qui √©tait pr√©c√©demment stock√©e dans le registre.  Lorsque le nombre correspond √† cette variable, le temporisateur peut soit d√©finir un indicateur, soit provoquer une interruption, tout comme dans le cas d'un d√©bordement. </p><br><p>  Pour utiliser le mode CTC, vous devez comprendre le nombre de cycles dont vous avez besoin pour obtenir un intervalle d'une seconde.  Supposons que le rapport de division soit toujours de 1024. </p><br><p>  Le calcul sera le suivant: </p><br><pre> <code class="plaintext hljs">(target time) = (timer resolution) * (# timer counts + 1) (# timer counts + 1) = (target time) / (timer resolution) (# timer counts + 1) = (1 s) / (6.4e-5 s) (# timer counts + 1) = 15625 (# timer counts) = 15625 - 1 = 15624</code> </pre> <br><p>  Vous devez ajouter une unit√© suppl√©mentaire au nombre d'√©chantillons car en mode CTC, lorsque le compteur correspond √† la valeur d√©finie, il se remet √† z√©ro.  La r√©initialisation prend une p√©riode d'horloge, qui doit √™tre prise en compte dans les calculs.  Dans de nombreux cas, une erreur sur une p√©riode n'est pas tr√®s importante, mais dans les t√¢ches de haute pr√©cision, elle peut √™tre critique. </p><br><p>  La fonction setup () sera comme ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(LEDPIN, OUTPUT); <span class="hljs-comment"><span class="hljs-comment">//  Timer1 cli(); //    TCCR1A = 0; //    0 TCCR1B = 0; OCR1A = 15624; //    TCCR1B |= (1 &lt;&lt; WGM12); //   CTC  //   CS10  CS12    1024 TCCR1B |= (1 &lt;&lt; CS10); TCCR1B |= (1 &lt;&lt; CS12); TIMSK1 |= (1 &lt;&lt; OCIE1A); //     sei(); //    }</span></span></code> </pre> <br><p>  Vous devez √©galement remplacer l'interruption de d√©bordement par une interruption co√Øncidente: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_COMPA_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</code> </pre> <br><p>  Maintenant, la LED s'allume et s'√©teint pendant exactement une seconde.  Et vous pouvez tout faire dans une boucle loop ().  Tant que vous ne modifiez pas les param√®tres de la minuterie, le programme n'a rien √† voir avec les interruptions.  Vous n'avez aucune restriction sur l'utilisation d'une minuterie avec diff√©rents modes et param√®tres du diviseur. </p><br><p>  Voici un exemple de d√©part complet que vous pouvez utiliser comme base pour vos propres projets: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Arduino  CTC  // avr-libc library includes #include &lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #define LEDPIN 13 void setup() { pinMode(LEDPIN, OUTPUT); //  Timer1 cli(); //    TCCR1A = 0; //    0 TCCR1B = 0; OCR1A = 15624; //    TCCR1B |= (1 &lt;&lt; WGM12); //  CTC  TCCR1B |= (1 &lt;&lt; CS10); //      1024 TCCR1B |= (1 &lt;&lt; CS12); TIMSK1 |= (1 &lt;&lt; OCIE1A); //      sei(); //    } void loop() { //   } ISR(TIMER1_COMPA_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</span></span></code> </pre> <br><p>  N'oubliez pas que vous pouvez utiliser les fonctions ISR int√©gr√©es pour √©tendre les fonctions du minuteur.  Par exemple, vous devez interroger le capteur toutes les 10 secondes.  Mais il n'y a pas de param√®tres de minuterie fournissant un compte aussi long sans d√©bordement.  Cependant, vous pouvez utiliser ISR pour incr√©menter la variable de comptage une fois par seconde, puis interroger le capteur lorsque la variable atteint 10. En utilisant le mode STS de l'exemple pr√©c√©dent, l'interruption pourrait ressembler √† ceci: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_COMPA_vect) { seconds++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(seconds == <span class="hljs-number"><span class="hljs-number">10</span></span>) { seconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; readSensor(); } }</code> </pre> <br><p>  Comme la variable sera modifi√©e √† l'int√©rieur de l'ISR, elle doit √™tre d√©clar√©e <em>volatile</em> .  Par cons√©quent, lors de la description des variables au d√©but du programme, vous devez √©crire: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> byte seconds;</code> </pre> <br><h3 id="posleslovie-perevodchika">  Postface du traducteur </h3><br><p>  √Ä un moment donn√©, cet article m'a fait gagner beaucoup de temps lors du d√©veloppement d'un prototype de g√©n√©rateur de mesure.  J'esp√®re que cela sera utile √† d'autres lecteurs. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453276/">https://habr.com/ru/post/fr453276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453260/index.html">Fonctions de param√©trage DPI</a></li>
<li><a href="../fr453262/index.html">O√π sont stock√©es vos constantes sur le microcontr√¥leur CortexM (en utilisant le compilateur IAR C ++ comme exemple)</a></li>
<li><a href="../fr453264/index.html">Virtuali-tee: un ¬´T-shirt m√©dical¬ª qui ne couvre pas mais expose</a></li>
<li><a href="../fr453272/index.html">Sponsors GitHub: une nouvelle fa√ßon de contribuer √† l'open source</a></li>
<li><a href="../fr453274/index.html">Commission cach√©e Yandex.Money dans Samsung Pay</a></li>
<li><a href="../fr453278/index.html">Pourquoi les ing√©nieurs ne se soucient-ils pas de la surveillance des applications?</a></li>
<li><a href="../fr453280/index.html">Dette technique</a></li>
<li><a href="../fr453286/index.html">L'erreur la plus ch√®re de ma vie: les d√©tails de l'attaque du port de la carte SIM</a></li>
<li><a href="../fr453290/index.html">Data Science Digest (mai 2019)</a></li>
<li><a href="../fr453292/index.html">"Un petit livre sur les trous noirs"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>