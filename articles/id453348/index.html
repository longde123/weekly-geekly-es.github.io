<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö± üë©üèº ü§∂üèæ Apa yang ada di dalam asyncio üë©üèø‚Äçü§ù‚Äçüë®üèª üîª üé¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, saya mengundang pembaca untuk melakukan perjalanan yang cukup menarik ke dalam asyncio dengan saya untuk memahami bagaimana ia mengi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang ada di dalam asyncio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453348/"><p>  Pada artikel ini, saya mengundang pembaca untuk melakukan perjalanan yang cukup menarik ke dalam <em><strong>asyncio</strong></em> dengan saya untuk memahami bagaimana ia mengimplementasikan eksekusi kode asinkron.  Kami membebani panggilan balik dan bergegas melalui serangkaian peristiwa melalui beberapa abstraksi kunci langsung ke coroutine.  Jika peta python Anda belum memiliki objek wisata ini, selamat datang di kucing. </p><a name="habracut"></a><br><h2 id="dlya-zatravki--kratkaya-spravka-o-raskinuvsheysya-pered-nami-mestnosti">  Sebagai permulaan - referensi singkat tentang area yang tersebar di hadapan kami </h2><br><p> <em><strong>asyncio</strong></em> adalah <em><strong>pustaka</strong></em> I / O asinkron yang, menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pep3153</a> , dibuat untuk menyediakan kerangka kerja standar untuk membuat kerangka kerja asinkron.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pep3156</a> juga mengatribusikan kepadanya kebutuhan untuk menyediakan integrasi yang sangat sederhana ke dalam kerangka asinkron yang sudah ada (Twisted, Tornado, Gevent).  Seperti yang dapat kita amati sekarang, tujuan-tujuan ini berhasil dicapai - kerangka kerja berbasis asyncio baru muncul: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/aio-libs/aio">aiohttp</a> , di Tornado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AsyncioMainLoop</a> adalah loop peristiwa default dari versi 5.0, di Twisted <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asyncioreactor</a> tersedia dari versi 16.5.0, dan ada perpustakaan pihak ketiga untuk Gevent . </p><br><p>  <em><strong>asyncio</strong></em> adalah pustaka hybrid yang secara bersamaan menggunakan dua pendekatan untuk mengimplementasikan eksekusi kode asinkron: klasik pada panggilan balik dan, relatif baru, (setidaknya untuk python) pada coroutine.  Ini didasarkan pada tiga abstraksi utama, yang merupakan analog dari abstraksi yang ada dalam kerangka kerja pihak ketiga: </p><br><ul><li>  <strong>Loop Acara Pluggable</strong> <br>  Peristiwa acara pluggable.  Pluggable berarti dapat diganti dalam dua baris kode dengan yang lain yang mengimplementasikan antarmuka yang sama.  Sekarang ada implementasi cython di atas libuv ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uvloop</a> ) <del>  dan di Rust ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asyncio-tokio</a> ) </del>  . </li><li>  <strong>Masa depan</strong> <br>  Hasil operasi, yang akan tersedia di masa depan.  Hal ini diperlukan untuk mendapatkan hasil eksekusi callback di coroutine. </li><li>  <strong>Tugas</strong> <br>  Subclass khusus Future untuk menjalankan coroutine pada suatu event loop. </li></ul><br><h2 id="poehali">  Ayo pergi! </h2><br><p>  Siklus peristiwa adalah komponen utama perpustakaan, di sepanjang jalan yang melewatinya, data dikirimkan ke salah satu komponennya.  Ini besar dan kompleks, jadi pertama-tama pertimbangkan versi stripped-down-nya. </p><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py import collections import random class Loop: def __init__(self): #     self.ready = collections.deque() def call_soon(self, callback, *args): #          self.ready.append((callback, args)) def run_until_complete(self, callback, *args): #         self.call_soon(callback, *args) #    -   #       while self.ready: ntodo = len(self.ready) #      #          for _ in range(ntodo): #       #        callback, args = self.ready.popleft() callback(*args) def callback(loop): print('') loop.call_soon(print, '') loop = Loop() loop.run_until_complete(callback, loop)</span></span></code> </pre> <br><p>  Mengendarai callback kecil kami, kami menuju jalan melalui <strong>call_soon</strong> , masuk ke antrian dan setelah menunggu sebentar kami akan ditampilkan. </p><br><h4 id="epizod-pro-plohie-kollbeki">  Episode Callback Buruk </h4><br><p>  Perlu disebutkan bahwa panggilan balik adalah kuda berbahaya - jika mereka melempar Anda di tengah jalan, juru bahasa python tidak akan bisa membantu memahami di mana ini terjadi.  Jika Anda tidak mempercayai <strong>saya</strong> , gunakan cara yang sama pada maybe_print <strong>callback</strong> , yang selesai hampir separuh waktu. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py def maybe_print(msg): if random.randint(0, 1): raise Exception(msg) else: print(msg) def starting_point(loop): #   print('') loop.call_soon(maybe_print, '') def main(loop): loop.call_soon(starting_point, loop) loop.call_soon(starting_point, loop) loop = Loop() loop.run_until_complete(main, loop)</span></span></code> </pre><br><p>  Di bawah ini adalah traceback penuh dari contoh sebelumnya.  Karena fakta bahwa fungsi <strong>maybe_print</strong> dimulai oleh loop acara, dan tidak langsung dari <strong>starting_point</strong> , traceback berakhir di situ, dalam metode <strong>run_until_complete</strong> .  Tidak mungkin untuk menentukan di mana <strong>starting_point</strong> berada dalam kode menggunakan traceback seperti itu, yang akan sangat menyulitkan debugging jika <strong>starting_point</strong> terletak di beberapa tempat dalam basis kode. </p><br><pre> <code class="bash hljs">$: python3 base_loop.py &gt;&gt;  <span class="hljs-comment"><span class="hljs-comment">#    &gt;&gt;  #    &gt;&gt;  #    &gt;&gt; Traceback (most recent call last): &gt;&gt; File "base_loop.py", line 42, in &lt;module&gt; &gt;&gt; loop.run_until_complete(main, loop) &gt;&gt; File "base_loop.py", line 17, in run_until_complete &gt;&gt; callback(*args) &gt;&gt; File "base_loop.py", line 29, in maybe_print &gt;&gt; raise Exception(msg) &gt;&gt; Exception:  #    </span></span></code> </pre> <br><p>  Tumpukan panggilan kontinu diperlukan tidak hanya untuk menampilkan traceback penuh, tetapi juga untuk mengimplementasikan fitur bahasa lainnya.  Misalnya, penanganan pengecualian didasarkan padanya.  Contoh di bawah ini tidak akan berfungsi, karena pada saat starting_point dimulai, fungsi <strong>utama</strong> sudah dijalankan: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py def main(loop): try: loop.call_soon(starting_point, loop) loop.call_soon(starting_point, loop) except: pass Loop().run_until_complete(main, loop)</span></span></code> </pre> <br><p>  Contoh berikut juga tidak akan berfungsi.  Manajer konteks dalam fungsi <strong>utama</strong> akan membuka dan menutup file sebelum pemrosesan dimulai. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py def main(loop): with open('file.txt', 'rb') as f: loop.call_soon(process_file, f) Loop().run_until_complete(main, loop) #       ,    =(</span></span></code> </pre> <br><p>  Kurangnya tumpukan panggilan terus menerus membatasi penggunaan fitur bahasa yang dikenal.  Untuk menghindari sebagian kelemahan ini, asyncio harus menambahkan banyak kode tambahan yang tidak terkait langsung dengan tugas yang diselesaikannya.  Kode ini, sebagian besar, tidak ada dalam contoh - mereka cukup rumit tanpanya. </p><br><h4 id="iz-cikla-sobytiy-vo-vneshniy-mir-i-obratno">  Dari siklus peristiwa ke dunia luar dan kembali </h4><br><p>  Lingkaran peristiwa berkomunikasi dengan dunia luar melalui sistem operasi melalui peristiwa.  Kode yang tahu cara bekerja dengannya disediakan oleh modul perpustakaan standar yang disebut <strong>penyeleksi</strong> .  Ini memungkinkan Anda untuk memberi tahu sistem operasi bahwa kami sedang menunggu semacam acara, dan kemudian bertanya apakah itu terjadi.  Pada contoh di bawah ini, acara yang diharapkan akan membaca ketersediaan soket. </p><br><div class="spoiler">  <b class="spoiler_title">Perulangan acara</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/event_loop.py import selectors import socket import collections from future import Future from handle import Handle from task import Task class EventLoop: def __init__(self): self.ready = collections.deque() #   self.selector = selectors.DefaultSelector() def add_reader(self, sock, callback): #       # : # , #         #           self.selector.register( sock, socket.EVENT_READ, (self._accept_conn, sock, callback) ) def _accept_conn(self, sock, callback): #    conn, addr = sock.accept() conn.setblocking(False) #      self.selector.register( conn, socket.EVENT_READ, (callback, conn) ) def run_until_complete(self, callback, *args): self.call_soon(callback, *args) #           -  while self.ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self.ready.popleft() callback(*args) #       for key, events in self.selector.select(timeout=0): #          callback, *args = key.data #       self.call_soon(callback, *args) def call_soon(self, callback, *args): self.ready.append((callback, args)) def print_data(conn): print(conn.recv(1000)) def main(loop): #   sock = socket.socket() #     8086  sock.bind(('localhost', 8086)) sock.listen(100) sock.setblocking(False) #      loop.add_reader(sock, print_data) loop = EventLoop() #    loop.run_until_complete(main, loop)</span></span></code> </pre> </div></div><br><p>  Seorang kurir dari dunia luar meninggalkan pesan atau bingkisannya di pemilih, dan pemilih menyerahkannya ke penerima.  Sekarang dimungkinkan untuk membaca dari soket menggunakan loop acara.  Jika Anda menjalankan kode ini dan terhubung menggunakan netcat, ia akan dengan setia menampilkan semua yang akan dikirim kepadanya. </p><br><pre> <code class="bash hljs">$: nc localhost 8086 $: python3 event_loop.py <span class="hljs-string"><span class="hljs-string">"Hi there!"</span></span> b<span class="hljs-string"><span class="hljs-string">'"Hi there!"\n'</span></span> <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> b<span class="hljs-string"><span class="hljs-string">'"Hello!"\n'</span></span> <span class="hljs-string"><span class="hljs-string">"Answer me, please!"</span></span> b<span class="hljs-string"><span class="hljs-string">'"Answer me, please!"\n'</span></span></code> </pre> <br><p>  Di awal artikel, dikatakan bahwa asyncio adalah perpustakaan hybrid di mana coroutine bekerja di atas callback.  Untuk mengimplementasikan fungsi ini, dua abstraksi utama yang tersisa digunakan: <strong>Tugas</strong> dan <strong>Masa Depan</strong> .  Selanjutnya, kode abstraksi ini akan ditampilkan, dan kemudian, dengan menggunakan siklus kejadiannya, coroutine dieksekusi. </p><br><h4 id="future">  Masa depan </h4><br><p>  Di bawah ini adalah kode untuk kelas Future.  Diperlukan agar di corutin Anda bisa menunggu hingga callback selesai dan mendapatkan hasilnya. </p><br><div class="spoiler">  <b class="spoiler_title">Masa depan</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/future.py import sys from asyncio import events, CancelledError class Future: #        _state = 'PENDING' # FINISHED, CANCELLED #          Future #          _source_traceback = None #            _callbacks = [] #           _exception = None #           _loop = None #     _result = None def __init__(self, loop): self._loop = loop self._source_traceback = events.extract_stack(sys._getframe(1)) def add_done_callback(self, callback): #        self._callbacks.append(callback) def _schedule_callbacks(self): #         for callback in self._callbacks: self._loop.call_soon(callback, self) self._callbacks[:] = [] #            Future #    -     def set_exception(self, exception): #       self._exception = exception #   self._state = 'FINISHED' #      self._schedule_callbacks() def set_result(self, result): #         self._result = result self._state = 'FINISHED' self._schedule_callbacks() def cancel(self): #       self._state = 'CANCELLED' self._schedule_callbacks() def result(self): #     #         if self._state == 'CANCELLED': raise CancelledError #         if self._exception is not None: raise self._exception #    return self._result def __await__(self): #  ,    await #        if self._state == 'PENDING': yield self #     return self.result()</span></span></code> </pre></div></div><br><h4 id="task">  Tugas </h4><br><p>  Ini adalah subkelas khusus <strong>Masa Depan</strong> .  Diperlukan untuk menjalankan coroutine pada loop event callback. </p><br><div class="spoiler">  <b class="spoiler_title">Tugas</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/task.py from asyncio import futures from future import Future class Task(Future): def __init__(self, coro, *, loop=None): super().__init__(loop=loop) #    self._coro = coro def _step(self, exc=None): #    ,     try: if exc is None: #        None #        result = self._coro.send(None) else: #        self._coro.throw(exc) except StopIteration: result = None except Exception as exc: self.set_exception(exc) else: #   Future      # wakeup      if isinstance(result, Future): result.add_done_callback(self._wakeup) #     step     elif result is None: self._loop.call_soon(self._step) def _wakeup(self, future): #     Future       Task #   try: future.result() except Exception as exc: self._step(exc) #        Future else: self._step()</span></span></code> </pre> </div></div><br><h4 id="cikl-sobytiy-umeyuschiy-rabotat-s-future">  Siklus acara yang dapat bekerja dengan Future </h4><br><div class="spoiler">  <b class="spoiler_title">EventLoop dengan Futures</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/future_event_loop.py import selectors from selectors import EVENT_READ, EVENT_WRITE import socket import collections from future import Future from task import Task class EventLoop: def __init__(self): self._ready = collections.deque() self.selector = selectors.DefaultSelector() def run_until_complete(self, callback, *args): self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() callback(*args) for key, events in self.selector.select(timeout=0): callback, *args = key.data self.call_soon(callback, *args) def call_soon(self, callback, *args): self._ready.append((callback, args)) #      Future def sock_accept(self, sock, fut=None): #       #  Future     fut = fut if fut else Future(loop=self) try: #     conn, address = sock.accept() conn.setblocking(False) except (BlockingIOError, InterruptedError): #     #      #   Future    self.selector.register( sock, EVENT_READ, (self.sock_accept, sock, fut) ) except Exception as exc: fut.set_exception(exc) self.selector.unregister(sock) else: #    #   Future    fut.set_result((conn, address)) self.selector.unregister(sock) return fut def sock_recv(self, sock, n, fut=None): #       #      , #     ,      fut = fut if fut else Future(loop=self) try: data = sock.recv(n) except (BlockingIOError, InterruptedError): self.selector.register( sock, EVENT_READ, (self.sock_recv, sock, n, fut) ) except Exception as exc: fut.set_exception(exc) self.selector.unregister(sock) else: fut.set_result(data) self.selector.unregister(sock) return fut async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #    conn, addr = await loop.sock_accept(sock) #     result = await loop.sock_recv(conn, 1000) print(result) loop = EventLoop() #    Task task = Task(coro=main(loop), loop=loop) #         loop.run_until_complete(task._step)</span></span></code> </pre> </div></div><br><h4 id="dvinemsya-dalshe">  Mari kita lanjutkan </h4><br><p>  Sekarang mari kita lihat bagaimana coroutine <strong>main</strong> akan dieksekusi: </p><br><div class="spoiler">  <b class="spoiler_title">Pemenuhan</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">__________________________________________________________________ class EventLoop: def run_until_complete(self, callback, *args): # task._step    self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() #     callback(*args) # task._step() ___________________________________________________________________ clsss Task: def _step(self, exc=None): try: if exc is None: #  None   result = self._coro.send(None) else: ___________________________________________________________________ async def main(loop): #      #   sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #         conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result) ___________________________________________________________________ class EventLoop: def sock_accept(self, sock, fut=None): #   Future fut = fut if fut else Future(loop=self) try: #     conn, address = sock.accept() conn.setblocking(False) except (BlockingIOError, InterruptedError): #     #      #   Future    self.selector.register( sock, EVENT_READ, (self.sock_accept, sock, fut) ) except Exception as exc: -------------------------------------------- self.selector.unregister(sock) #  Future   return fut ___________________________________________________________________ async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #   await   __await__  Future conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result) ___________________________________________________________________ class Future: def __await__(self): #   Future         if self._state == 'PENDING': yield self return self.result() ___________________________________________________________________ class Task(Future): def _step(self, exc=None): try: if exc is None: #           None result = self._coro.send(None) # result = fut -------------------------------- else: #  Future      # wakeup      if isinstance(result, Future): result.add_done_callback(self._wakeup) elif result is None: self._loop.call_soon(self._step) #      -    Task  Future #    #               ___________________________________________________________________ class EventLoop: def run_until_complete(self, callback, *args): self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() callback(*args) for key, events in self.selector.select(timeout=0): #    callback, *args = key.data self.call_soon(callback, *args) # loop.sock_accept(sock, fut) ___________________________________________________________________ class EventLoop: def sock_accept(self, sock, fut=None): fut = fut if fut else Future(loop=self) try: #    conn, address = sock.accept() conn.setblocking(False) except (BlockingIOError, InterruptedError): -------------------------------- else: #   Future fut.set_result((conn, address)) self.selector.unregister(sock) return fut ___________________________________________________________________ class Future: def set_result(self, result): #   self._result = result #   self._state = 'FINISHED' #      self._schedule_callbacks() def _schedule_callbacks(self): for callback in self._callbacks: #         task.wakeup self._loop.call_soon(callback, self) # (task.wakeup, fut) self._callbacks[:] = [] ___________________________________________________________________ class EventLoop: def run_until_complete(self, callback, *args): self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() #      #    task.wakeup callback(*args) # task.wakeup(fut) ___________________________________________________________________ class Task(Future): def _wakeup(self, future): try: future.result() except Exception as exc: self._step(exc) else: #   Future      task._step self._step() def _step(self, exc=None): try: if exc is None: #       None result = self._coro.send(None) else: ___________________________________________________________________ async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #   await   __awai__   conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result) ___________________________________________________________________ class Future: def __await__(self): if self._state == 'PENDING': yield self #   Future    return self.result() ___________________________________________________________________ async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #    Future    conn  addr conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result)</code> </pre> </div></div><br><p>  Dengan cara sederhana ini, asyncio melakukan coroutine. </p><br><h4 id="itogi">  Ringkasan </h4><br><p>  Tujuan menciptakan asyncio telah berhasil dicapai.  Itu tidak hanya memecahkan masalah kompatibilitas, tetapi juga menyebabkan peningkatan besar minat dalam pemrograman kompetitif di masyarakat.  Artikel dan perpustakaan baru mulai muncul, seperti jamur setelah hujan.  Selain itu, asyncio memengaruhi bahasa itu sendiri: coroutine asli dan kata kunci <strong>async</strong> / <strong>menunggu</strong> baru ditambahkan ke dalamnya.  Terakhir kali kata kunci baru ditambahkan kembali pada tahun 2003, itu adalah kata kunci <strong>hasil</strong> . </p><br><p>  Salah satu tujuan menciptakan asyncio adalah untuk menyediakan integrasi yang sangat sederhana ke dalam kerangka asinkron yang sudah ada (Twisted, Tornado, Gevent).  Pilihan alat secara logis mengikuti dari tujuan ini: jika tidak ada persyaratan kompatibilitas, coroutine mungkin akan diberi peran utama.  Karena kenyataan bahwa ketika pemrograman pada panggilan balik tidak mungkin untuk mempertahankan tumpukan panggilan yang berkelanjutan, sistem tambahan harus dibuat di perbatasan antara mereka dan coroutine untuk mendukung fitur bahasa berdasarkan itu. </p><br><p>  Sekarang pertanyaan utamanya.  Mengapa pengguna perpustakaan yang sederhana mengetahui semua ini, yang mengikuti rekomendasi dari dokumentasi dan hanya menggunakan coroutine dan API tingkat tinggi? <br>  Berikut adalah dokumentasi kelas StreamWriter </p><br><p><img src="https://habrastorage.org/webt/td/ou/jb/tdoujbeh0soadfwdveuowwbvvny.png"></p><br><p>  Contohnya dikembalikan oleh fungsi <strong>asyncio.open_connection</strong> dan merupakan <strong>async</strong> / <strong>menunggu</strong> API di atas API panggilan balik.  Dan panggilan balik ini keluar darinya.  Fungsi <strong>tulis</strong> dan <strong>tulis</strong> <strong>adalah</strong> sinkron, mereka mencoba menulis ke soket, dan jika gagal, mereka membuang data ke buffer yang mendasarinya dan menambahkan panggilan balik ke catatan.  <strong>Tiriskan</strong> corutin diperlukan untuk memberikan kesempatan untuk menunggu sampai jumlah data dalam buffer turun ke nilai yang ditentukan. </p><br><p>  Jika Anda lupa memanggil <strong>saluran</strong> antara panggilan <strong>tulis</strong> , maka buffer internal dapat tumbuh menjadi ukuran tidak senonoh.  Namun, jika Anda mengingat hal ini, beberapa momen tidak menyenangkan tetap ada.  Pertama: jika panggilan balik pada catatan "rusak", maka coroutine yang menggunakan API ini tidak akan mengetahuinya dengan cara apa pun, dan karenanya, tidak akan dapat memprosesnya.  Kedua: jika coroutine "pecah", maka panggilan balik ke catatan tidak akan mengetahuinya dengan cara apa pun dan akan terus menulis data dari buffer. </p><br><p>  Jadi, bahkan hanya menggunakan coroutine, bersiaplah untuk kenyataan bahwa callback akan mengingatkan diri mereka sendiri. </p><br><p>  Anda dapat membaca tentang cara bekerja dengan database dari kode asinkron dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini dari</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perangkat lunak blog perusahaan Antida kami</a> . </p><br><p>  PS Terima kasih atas informasi tentang kesalahan ketik dan ketidakakuratan kepada pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">eirnym</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">kurb</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">rasswet</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453348/">https://habr.com/ru/post/id453348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453336/index.html">Panduan Pemilihan Mesin Pembakaran CNC</a></li>
<li><a href="../id453338/index.html">Rust 1.35.0 Rilis: Implementasi Karakter Fungsional dan Inovasi Lainnya</a></li>
<li><a href="../id453340/index.html">Perl 5.30 dirilis</a></li>
<li><a href="../id453342/index.html">Mitos tentang karyawan jarak jauh yang kami hancurkan sendiri</a></li>
<li><a href="../id453346/index.html">Teknologi penyimpanan dan perlindungan data - hari ketiga di VMware EMPOWER 2019</a></li>
<li><a href="../id453350/index.html">Buka siaran aula utama RIT ++ 2019</a></li>
<li><a href="../id453352/index.html">Bagaimana drone mengirimkan obat-obatan penting di Ghana</a></li>
<li><a href="../id453354/index.html">Klasifikasi tutupan lahan menggunakan eo-learning. Bagian 3</a></li>
<li><a href="../id453356/index.html">Tren dan rekomendasi terkini tentang aglomerasi lembaga keuangan besar</a></li>
<li><a href="../id453360/index.html">Kota tanpa kemacetan lalu lintas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>