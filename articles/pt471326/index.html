<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úàÔ∏è üÜé üç§ O conto dos perigosos std :: enable_shared_from_this, ou o antipattern Zombie ü•Ñ üë®‚Äçüë®‚Äçüëß ü§ö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O artigo fornece um perigoso ‚ÄúZombie‚Äù antipadr√£o, que em algumas situa√ß√µes surge naturalmente ao usar std :: enable_shared_from_this. O material est√° ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O conto dos perigosos std :: enable_shared_from_this, ou o antipattern Zombie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471326/">  O artigo fornece um perigoso ‚ÄúZombie‚Äù antipadr√£o, que em algumas situa√ß√µes surge naturalmente ao usar std :: enable_shared_from_this.  O material est√° em algum lugar na jun√ß√£o da moderna tecnologia e arquitetura C ++. <br><a name="habracut"></a><br><h3>  1. Introdu√ß√£o </h3><br>  O C ++ 11 forneceu ao desenvolvedor ferramentas maravilhosas para trabalhar com a mem√≥ria - ponteiros inteligentes std :: unique_ptr e v√°rios std :: shared_ptr + std :: weak_ptr.  O uso de ponteiros inteligentes por conveni√™ncia e seguran√ßa supera em muito o uso de ponteiros brutos.  Ponteiros inteligentes s√£o amplamente utilizados na pr√°tica, como  permita que o desenvolvedor se concentre em quest√µes de n√≠vel superior do que controlar a corre√ß√£o da cria√ß√£o / exclus√£o de entidades criadas dinamicamente. <br>  O modelo de classe std :: enable_shared_from_this tamb√©m faz parte do padr√£o e parece bastante estranho quando voc√™ o encontra pela primeira vez. <br>  O artigo discutir√° como voc√™ pode ficar preso ao seu uso. <br><br><h2>  Programa educacional </h2><br><div class="spoiler">  <b class="spoiler_title">RAII e ponteiros inteligentes</b> <div class="spoiler_text"> O objetivo direto dos ponteiros inteligentes √© cuidar de um <b>peda√ßo de RAM</b> alocado no heap.  Ponteiros inteligentes implementam o idioma RAII (aquisi√ß√£o de recursos √© inicializa√ß√£o) e podem ser facilmente adaptados para cuidar de outros tipos de recursos que requerem inicializa√ß√£o e desinicializa√ß√£o n√£o trivial, como: <br>  - arquivos; <br>  - pastas tempor√°rias no disco; <br>  - conex√µes de rede (http, websockets); <br>  - threads de execu√ß√£o (threads); <br>  - mutexes; <br>  - outro (o que √© suficiente para fantasia). <br>  Para tal generaliza√ß√£o, basta escrever uma classe (de fato, √†s vezes voc√™ nem consegue escrever uma classe, mas apenas usa deleter - mas hoje a hist√≥ria n√£o √© sobre isso), implementando: <br>  - inicializa√ß√£o no construtor ou em um m√©todo separado; <br>  - desinicializa√ß√£o no destruidor, <br>  em seguida, "envolva" o ponteiro inteligente correspondente, dependendo do modelo de propriedade necess√°rio - joint (std :: shared_ptr) ou sole (std :: unique_ptr).  Isso resulta em um "RAII de duas camadas": um ponteiro inteligente permite transferir / compartilhar a propriedade do recurso, e a classe de usu√°rio inicializa / dessinicializa um recurso n√£o padr√£o. <br>  std :: shared_ptr usa um mecanismo de contagem de links.  O padr√£o define o contador de links fortes (conta o n√∫mero de c√≥pias existentes de std :: shared_ptr) e o contador de links fracos (conta o n√∫mero de c√≥pias existentes de std :: weak_ptr criado para esta inst√¢ncia de std :: shared_ptr).  A presen√ßa de pelo menos um elo forte garante que a destrui√ß√£o ainda n√£o foi feita.  Essa propriedade std :: shared_ptr √© amplamente usada para garantir a validade de um objeto at√© que o trabalho seja conclu√≠do em todas as partes do programa.  A presen√ßa de um link fraco n√£o impede a destrui√ß√£o do objeto e permite que voc√™ obtenha um link forte apenas at√© que seja destru√≠do. <br>  O RAII garante que a libera√ß√£o de um recurso √© muito mais confi√°vel do que uma chamada expl√≠cita para excluir / excluir [] / liberar / fechar / redefinir / desbloquear, porque: <br>  - voc√™ pode simplesmente esquecer a chamada expl√≠cita; <br>  - uma chamada expl√≠cita pode ser feita erroneamente mais de uma vez; <br>  - um desafio expl√≠cito √© dif√≠cil ao implementar a propriedade compartilhada de um recurso; <br>  - o mecanismo de promo√ß√£o de pilha no c ++ garante a chamada de destruidores para todos os objetos que ficam fora do escopo em caso de exce√ß√£o. <br>  A garantia de desinstala√ß√£o no idioma √© t√£o importante que merece um bom lugar no nome do idioma junto com a inicializa√ß√£o. <br>  Ponteiros inteligentes tamb√©m t√™m desvantagens: <br>  - a presen√ßa de sobrecarga em termos de desempenho e mem√≥ria (para a maioria dos aplicativos n√£o √© significativa); <br>  - a possibilidade de links c√≠clicos bloqueando a libera√ß√£o do recurso e levando ao seu vazamento. <br>  Certamente, todo desenvolvedor mais de uma vez leu sobre links circulares e viu exemplos sint√©ticos de c√≥digo problem√°tico. <br>  O perigo pode parecer insignificante pelos seguintes motivos: <br>  - se a mem√≥ria vazar com frequ√™ncia e muito - isso √© percept√≠vel em seu consumo, e se raramente e pouco -, √© improv√°vel que o problema apare√ßa no n√≠vel do usu√°rio final; <br>  - usa an√°lise din√¢mica de c√≥digo para vazamentos (Valgrind, Clang LeakSanitizer, etc.); <br>  - "Eu n√£o escrevo assim"; <br>  - "minha arquitetura est√° correta"; <br>  "Nosso c√≥digo est√° sendo revisado." <br></div></div><br><div class="spoiler">  <b class="spoiler_title">std :: enable_shared_from_this</b> <div class="spoiler_text">  No C ++ 11, a classe auxiliar std :: enable_shared_from_this √© introduzida.  Para um desenvolvedor que cria c√≥digo com √™xito sem std :: enable_shared_from_this, os usos potenciais dessa classe podem n√£o ser √≥bvios. <br>  O que std :: enable_shared_from_this faz? <br>  Permite que as fun√ß√µes-membro da classe instanciada em std :: shared_ptr recebam c√≥pias adicionais fortes (shared_from_this ()) ou fracas (fraca_from_this (), a partir do C ++ 17) das c√≥pias std :: shared_ptr nas quais foi criada .  Voc√™ n√£o pode chamar shared_from_this () e weak_from_this () do construtor e destruidor. <br><br>  <b>Por que √© t√£o dif√≠cil?</b>  <b>Voc√™ pode simplesmente construir std :: shared_ptr &lt;T&gt; (this)</b> <br>  N√£o, voc√™ n√£o pode.  Todos os std :: shared_ptrs que se preocupam com a mesma inst√¢ncia da classe devem usar uma unidade de contagem de links.  N√£o h√° como ficar sem magia especial. <br><br>  Um pr√©-requisito para usar std :: enable_shared_from_this √© criar inicialmente um objeto de classe em std :: shared_ptr.  Criando na pilha, alocando dinamicamente na pilha, criando em std :: unique_ptr - tudo isso n√£o √© adequado.  Apenas estritamente em std :: shared_ptr. <br><br>  <b>√â poss√≠vel limitar o usu√°rio na maneira de criar inst√¢ncias da classe?</b> <br>  Sim voc√™ pode.  Para fazer isso, apenas: <br>  - forne√ßa um m√©todo est√°tico para criar inst√¢ncias originalmente colocadas em std :: shared_ptr; <br>  - colocar o construtor em privado ou protegido; <br>  - proibir c√≥pia e movimento - sem√¢ntica. <br>  A classe entrou na gaiola, trancou-a e engoliu a chave - a partir de agora todas as suas inst√¢ncias viver√£o apenas em std :: shared_ptr, e n√£o h√° maneiras legais de tir√°-las de l√°. <br>  Essa restri√ß√£o n√£o pode ser chamada de uma boa solu√ß√£o arquitetural, mas esse m√©todo est√° em total conformidade com o padr√£o. <br>  Al√©m disso, voc√™ pode usar o idioma PIMPL: o √∫nico usu√°rio da classe caprichosa - a fachada - criar√° a implementa√ß√£o estritamente em std :: shared_ptr, e a pr√≥pria fachada j√° estar√° privada de restri√ß√µes desse tipo. <br><br>  std :: enable_shared_from_this possui nuances significativas na heran√ßa, mas discuti-las est√° al√©m do escopo deste artigo. <br></div></div><br><h2>  V√° direto ao ponto </h2><br>  Todos os exemplos de c√≥digo fornecidos no artigo s√£o publicados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> . <br>  O c√≥digo demonstra m√°s t√©cnicas disfar√ßadas como o uso seguro usual do C ++ moderno <br><br><h3>  Simplecyclic </h3><br>  Parece que nada pressagia problemas.  Uma declara√ß√£o de classe parece simples e direta.  Exceto por um detalhe ‚Äúpequeno‚Äù - por algum motivo, a heran√ßa de std :: enable_shared_from_this √© aplicada. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;functional&gt; namespace SimpleCyclic { class Cyclic final : public std::enable_shared_from_this&lt;Cyclic&gt; { public: static std::shared_ptr&lt;Cyclic&gt; create(); Cyclic(const Cyclic&amp;) = delete; Cyclic(Cyclic&amp;&amp;) = delete; Cyclic&amp; operator=(const Cyclic&amp;) = delete; Cyclic&amp; operator=(Cyclic&amp;&amp;) = delete; ~Cyclic(); void doSomething(); private: Cyclic(); std::function&lt;void(void)&gt; _fn; }; } // namespace SimpleCyclic</span></span></span></span></code> </pre> <br></div></div><br>  E na implementa√ß√£o: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "SimpleCyclic.h" namespace SimpleCyclic { Cyclic::Cyclic() = default; Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;Cyclic&gt; Cyclic::create() { return std::shared_ptr&lt;Cyclic&gt;(new Cyclic); } void Cyclic::doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace SimpleCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SimpleCyclic/SimpleCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto simpleCyclic = SimpleCyclic::Cyclic::create(); simpleCyclic-&gt;doSomething(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text"><blockquote>  N12SimpleCyclic6CyclicE :: doSomething <br></blockquote><br></div></div><br>  No corpo da fun√ß√£o doSomething (), a <b>pr√≥pria</b> inst√¢ncia da classe criar√° uma c√≥pia forte adicional do std :: shared_ptr no qual foi colocada.  Em seguida, usando uma captura generalizada, essa c√≥pia √© colocada em uma fun√ß√£o lambda atribu√≠da ao campo de dados da classe sob o disfarce de uma fun√ß√£o std :: inofensiva.  Uma chamada para doSomething () resulta em uma refer√™ncia circular e a inst√¢ncia da classe n√£o ser√° mais destru√≠da, mesmo ap√≥s a destrui√ß√£o de todos os links fortes externos. <br>  H√° um vazamento de mem√≥ria.  O destruidor SimpleCyclic :: Cyclic :: ~ Cyclic n√£o √© chamado. <br><br>  <b>A inst√¢ncia da classe "mant√©m" a si mesma.</b> <b><br></b>  <b>O c√≥digo ficou preso em um n√≥.</b> <br><br><img src="https://habrastorage.org/webt/xp/jj/_a/xpjj_atj4bf0av8kar46ebxqqew.jpeg"><br>  (imagem tirada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daqui</a> ) <br><br>  <b>E o que, este √© o antipadr√£o "Zombie"?</b> <br>  N√£o, isso √© apenas um treino.  Tudo o mais interessante ainda est√° por vir. <br><br>  <b>Por que o desenvolvedor escreveu isso?</b> <br>  Exemplo sint√©tico.  N√£o conhe√ßo nenhuma situa√ß√£o em que esse c√≥digo seja obtido harmoniosamente. <br><br>  <b>Ent√£o, a an√°lise din√¢mica de c√≥digo permaneceu silenciosa?</b> <br>  N√£o, Valgrind relatou honestamente um vazamento de mem√≥ria: <br><br><div class="spoiler">  <b class="spoiler_title">Post Valgrind</b> <div class="spoiler_text"><blockquote>  96 (64 diretos, 32 indiretos) bytes em 1 bloco s√£o <b>definitivamente perdidos</b> no registro de perdas 29 de 46 <br>  em SimpleCyclic :: Cyclic :: create () em /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  1: malloc em /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: operador new (long sem assinatura) em /usr/lib/libc++abi.dylib <br>  3: SimpleCyclic :: Cyclic :: create () em /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  4: principal em /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/main.cpphaps <br></blockquote><br></div></div><br><h3>  Pimplcyclic </h3><br>  Nesse caso, o arquivo de cabe√ßalho parece completamente correto e conciso.  Ele declarou uma fachada que armazena uma certa implementa√ß√£o em std :: shared_ptr.  A heran√ßa - incluindo std :: enable_shared_from_this - est√° ausente, diferente do exemplo anterior. <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace PimplCyclic { class Cyclic { public: Cyclic(); ~Cyclic(); private: class Impl; std::shared_ptr&lt;Impl&gt; _impl; }; } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br>  E na implementa√ß√£o: <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "PimplCyclic.h" namespace PimplCyclic { class Cyclic::Impl : public std::enable_shared_from_this&lt;Cyclic::Impl&gt; { public: ~Impl() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } private: std::function&lt;void(void)&gt; _fn; }; Cyclic::Cyclic() : _impl(std::make_shared&lt;Impl&gt;()) { if (_impl) { _impl-&gt;doSomething(); } } Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PimplCyclic/PimplCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto pimplCyclic = PimplCyclic::Cyclic(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text"><blockquote>  N11PimplCyclic6Cyclic4ImplE :: doSomething <br>  N11PimplCyclic6CyclicE :: ~ Cyclic <br></blockquote><br></div></div><br>  Chamar Impl :: doSomething () cria uma refer√™ncia circular em uma inst√¢ncia da classe Impl.  A fachada foi destru√≠da corretamente, mas a implementa√ß√£o est√° vazando.  O destruidor PimplCyclic :: Cyclic :: Impl :: ~ Impl n√£o √© chamado. <br>  O exemplo √© novamente sint√©tico, mas desta vez mais perigoso - todo o equipamento defeituoso est√° localizado na implementa√ß√£o e n√£o aparece no an√∫ncio. <br>  Al√©m disso, para criar um link circular, o c√≥digo do usu√°rio n√£o exigiu nenhuma a√ß√£o al√©m da constru√ß√£o. <br>  Uma an√°lise din√¢mica em face de Valgrind, e desta vez revelou um vazamento: <br><br><div class="spoiler">  <b class="spoiler_title">Post Valgrind</b> <div class="spoiler_text"><blockquote>  96 bytes em 1 bloco s√£o <b>definitivamente perdidos</b> no registro de perdas 29 de 46 <br>  em PimplCyclic :: Cyclic :: Cyclic () em /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  1: malloc em /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: operador new (long sem assinatura) em /usr/lib/libc++abi.dylib <br>  3: std :: __ 1 :: __ libcpp_allocate (sem assinatura, sem assinatura) em /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/new:252 <br>  4: std :: __ 1 :: alocador &lt;std :: __ 1 :: __ shared_ptr_emplace &lt;PimplCyclic :: Cyclic :: Impl, std :: __ 1 :: alocador &lt;PimplCyclic :: Cyclic :: Impl &gt;&gt;&gt; alocar (sem assinatura por muito tempo , void const *) em /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:1813 <br>  5: std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; :: make_shared &lt;&gt; () em /Applications/Xcode.app/Contents /Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4326 <br>  6: _ZNSt3__1L11make_sharedIN11PimplCyclic6Cyclic4ImplEJEEENS_9enable_ifIXntsr8is_arrayIT_EE5valueENS_10shared_ptrIS5_EEE4typeEDpOT0_ em /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4706 <br>  7: PimplCyclic :: Cyclic :: Cyclic () em /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  8: PimplCyclic :: Cyclic :: Cyclic () em /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:29 <br>  9: main em /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/main.cpphaps <br></blockquote><br></div></div><br>  <b>√â um pouco suspeito ver o Pimpl, no qual a implementa√ß√£o √© armazenada em std :: shared_ptr.</b> <br>  O Pimpl cl√°ssico baseado em um ponteiro bruto √© muito arcaico, e std :: unique_ptr tem um efeito colateral de espalhar a proibi√ß√£o de copiar sem√¢ntica na fachada.  Essa fachada implementar√° o idioma da propriedade exclusiva, que pode n√£o corresponder √† id√©ia arquitet√¥nica.  Do uso de std :: shared_ptr para armazenar a implementa√ß√£o, conclu√≠mos que a classe foi projetada para fornecer propriedade compartilhada. <br><br>  <b>Como isso difere do cl√°ssico vazamento - alocando mem√≥ria explicitamente chamando new sem exclus√£o subseq√ºente?</b>  <b>Da mesma forma, tudo ficaria bonito na interface e na implementa√ß√£o - um bug.</b> <br>  Estamos discutindo maneiras <b>modernas de</b> dar um tiro no pr√≥prio p√©. <br><br><h2>  Antipadr√£o "Zumbis" </h2><br>  Portanto, a partir do material acima, fica claro: <br>  - ponteiros inteligentes podem ser ligados a n√≥s; <br>  - o uso de std :: enable_shared_from_this pode contribuir para isso, porque  permite que uma inst√¢ncia de uma classe se vincule a um n√≥ quase sem ajuda externa. <br><br>  <b>E agora - aten√ß√£o - a quest√£o-chave do artigo: o tipo de recurso envolvido em um ponteiro inteligente √© importante?</b>  <b>Existe uma diferen√ßa entre um tratamento de arquivo RAII e uma conex√£o HTTPS ass√≠ncrona?</b> <br><br><h3>  Simplezomby </h3><br>  O c√≥digo comum a todos os exemplos subseq√ºentes de zumbis foi movido para a biblioteca Common. <br><br>  Interface abstrata de zumbi com o modesto nome Manager: <br><br><div class="spoiler">  <b class="spoiler_title">Common / Manager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace Common { class Listener; class Manager { public: Manager() = default; Manager(const Manager&amp;) = delete; Manager(Manager&amp;&amp;) = delete; Manager&amp; operator=(const Manager&amp;) = delete; Manager&amp; operator=(Manager&amp;&amp;) = delete; virtual ~Manager() = default; virtual void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Interface abstrata do ouvinte, pronta para aceitar texto seguro para threads: <br><br><div class="spoiler">  <b class="spoiler_title">Common / Listener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;memory&gt; namespace Common { class Listener { public: virtual ~Listener() = default; using Data = std::string; // thread-safe virtual void processData(const std::shared_ptr&lt;const Data&gt; data) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Ouvinte que exibe texto no console.  Implementa o conceito SingletonShared do meu artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">T√©cnica para evitar comportamentos indefinidos ao chamar um Singleton</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; #include "Common/Listener.h" namespace Common { class WriteToConsoleListener final : public Listener { public: WriteToConsoleListener(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener(WriteToConsoleListener&amp;&amp;) = delete; WriteToConsoleListener&amp; operator=(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener&amp; operator=(WriteToConsoleListener&amp;&amp;) = delete; ~WriteToConsoleListener() override; static std::shared_ptr&lt;WriteToConsoleListener&gt; instance(); // blocking void processData(const std::shared_ptr&lt;const Data&gt; data) override; private: WriteToConsoleListener(); std::mutex _mutex; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "WriteToConsoleListener.h" namespace Common { WriteToConsoleListener::WriteToConsoleListener() = default; WriteToConsoleListener::~WriteToConsoleListener() { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;WriteToConsoleListener&gt; WriteToConsoleListener::instance() { static auto inst = std::shared_ptr&lt;WriteToConsoleListener&gt;(new WriteToConsoleListener); return inst; } void WriteToConsoleListener::processData(const std::shared_ptr&lt;const Data&gt; data) { if (data) { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; *data &lt;&lt; std::flush; } } } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  E, finalmente, o primeiro zumbi, o mais simples e o mais ing√™nuo. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SimpleZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; }; } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include "SimpleZomby.h" #include "Common/Listener.h" namespace SimpleZomby { std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::Zomby() = default; Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SimpleZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ while (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;("SimpleZomby is alive!\n")); std::this_thread::sleep_for(std::chrono::seconds(1)); } }); } } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br>  Um zumbi executa uma fun√ß√£o lambda em um thread separado, enviando periodicamente uma string para o ouvinte.  As fun√ß√µes do Lambda para trabalho precisam de um sem√°foro e um ouvinte, que s√£o campos da classe zumbi.  A fun√ß√£o lambda n√£o os captura como campos separados, mas usa o objeto como um agregador.  Destruir uma inst√¢ncia da classe zombie antes que a fun√ß√£o lambda seja conclu√≠da resultar√° em um comportamento indefinido.  Para evitar isso, a fun√ß√£o lambda captura uma c√≥pia forte de shared_from_this (). <br>  No destruidor de zumbis, o sem√°foro √© definido como falso, ap√≥s o qual detach () √© chamado para o fluxo.  A configura√ß√£o do sem√°foro diz ao thread para desligar. <br><br>  <b>No destruidor, era necess√°rio chamar n√£o detach (), mas join ()!</b> <br>  ... e obtenha um destruidor que bloqueie a execu√ß√£o por tempo indeterminado, o que pode ser inaceit√°vel. <br><br>  <b>Portanto, isso √© uma viola√ß√£o da RAII!</b>  <b>O RAII deveria sair do destruidor somente depois de liberar o recurso!</b> <br>  Se estritamente - ent√£o sim, o destruidor de zumbis n√£o libera o recurso, mas apenas <b>garante que o lan√ßamento ser√° realizado</b> .  Algum tempo produzido - talvez em breve, ou talvez n√£o realmente.  E √© at√© poss√≠vel que o main termine o trabalho mais cedo - ent√£o o thread ser√° apagado √† for√ßa pelo sistema operacional.  Mas, na verdade, a linha entre RAII ‚Äúcerto‚Äù e ‚Äúerrado‚Äù pode ser muito pequena: por exemplo, RAII ‚Äúcorreto‚Äù, que chama std :: filesystem :: remove () em um destruidor de um arquivo tempor√°rio, pode retornar o controle a esse o momento em que o comando write ainda estar√° em qualquer um dos caches vol√°teis e n√£o ser√° gravado honestamente na placa magn√©tica do disco r√≠gido. <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "Common/Impl/WriteToConsoleListener.h" #include "SimpleZomby/SimpleZomby.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto simpleZomby = SimpleZomby::Zomby::create(); simpleZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zomby should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text"><blockquote>  SimpleZomby est√° vivo! <br>  SimpleZomby est√° vivo! <br>  SimpleZomby est√° vivo! <br>  SimpleZomby est√° vivo! <br>  SimpleZomby est√° vivo! <br>  ===================================================== =========== <br>  |  Zomby foi morto | <br>  ===================================================== =========== <br>  SimpleZomby est√° vivo! <br>  SimpleZomby est√° vivo! <br>  SimpleZomby est√° vivo! <br>  SimpleZomby est√° vivo! <br>  SimpleZomby est√° vivo! <br></blockquote><br></div></div><br>  O que pode ser visto na sa√≠da do programa: <br>  - o zumbi continuou a trabalhar mesmo depois de sair do campo de visibilidade; <br>  - nenhum destruidor foi chamado para zumbis ou WriteToConsoleListener. <br>  Ocorreu um vazamento de mem√≥ria. <br>  Houve um vazamento de recursos.  E o recurso, neste caso, √© o segmento de execu√ß√£o. <br>  O c√≥digo que deveria parar continuou a funcionar em um encadeamento separado. <br>  Um vazamento WriteToConsoleListener poderia ter sido evitado usando a t√©cnica SingletonWeak do meu artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Evitando o comportamento indeterminado ao chamar um Singleton</a> , mas intencionalmente n√£o o fiz. <br><br><img src="https://habrastorage.org/webt/mg/qu/e3/mgque3fstboi4ot2hvdwniafixe.jpeg"><br>  (imagem tirada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daqui</a> ) <br><br>  <b>Por que zumbis?</b> <br>  Porque ele foi morto, e ele ainda est√° vivo. <br><br>  <b>Como isso √© diferente das refer√™ncias circulares nos exemplos anteriores?</b> <br>  O fato de um recurso perdido n√£o ser apenas um peda√ßo de mem√≥ria, mas algo que executa independentemente o c√≥digo independentemente do encadeamento que o iniciou. <br><br>  <b>√â poss√≠vel destruir os "zumbis"?</b> <br>  Depois de sair do escopo (ou seja, depois de destruir todas as refer√™ncias fortes e fracas externas a zumbis) - √© imposs√≠vel.  Um zumbi ser√° destru√≠do quando ele decidir se destruir (sim, √© algo com comportamento ativo), talvez nunca, ou seja,  sobreviver√° at√© que o sistema operacional seja limpo quando o aplicativo terminar.  Obviamente, o c√≥digo do usu√°rio pode ter algum efeito sobre a condi√ß√£o de sa√≠da do c√≥digo zumbi, mas esse efeito ser√° indireto e depende da implementa√ß√£o. <br><br>  <b>E antes de sair do escopo?</b> <br>  Voc√™ pode chamar explicitamente o destruidor de zumbis, mas √© improv√°vel que voc√™ evite comportamentos indefinidos devido √† destrui√ß√£o repetida do objeto pelo destruidor de ponteiro inteligente tamb√©m - esta √© uma luta contra o RAII.  Ou voc√™ pode adicionar a fun√ß√£o de desinicializa√ß√£o expl√≠cita - e isso √© uma rejei√ß√£o do RAII. <br><br>  <b>Como isso √© diferente de apenas iniciar um thread seguido de detach ()?</b> <br>  No caso de zumbis, ao contr√°rio de uma simples chamada para desanexar (), existe uma id√©ia para interromper o fluxo.  S√≥ que n√£o funciona.  Ter a id√©ia certa ajuda a mascarar o problema. <br><br>  <b>O exemplo ainda √© sint√©tico?</b> <br>  Em parte.  Neste exemplo simples, n√£o havia motivos suficientes para usar shared_from_this () - por exemplo, voc√™ poderia capturar o fraco_from_this () ou capturar todos os campos obrigat√≥rios da classe.  Mas com a complexidade da tarefa, o equil√≠brio pode mudar para o lado <br>  shared_from_this (). <br><br>  <b>Valgrind, Valgrind!</b>  <b>Temos uma linha de defesa adicional contra zumbis!</b> <br>  Ai e ah - mas Valgrind n√£o revelou um vazamento de mem√≥ria.  Por que - eu n√£o sei.  Nos diagn√≥sticos, existem apenas entradas <b>"possivelmente perdidas"</b> que indicam as fun√ß√µes do sistema - aproximadamente a mesma e aproximadamente a mesma quantidade que quando se trabalha com uma rede principal vazia.  N√£o h√° refer√™ncias de c√≥digo do usu√°rio.  Outras ferramentas de an√°lise din√¢mica podem se sair melhor, mas se voc√™ ainda confiar nelas, continue lendo. <br><br><h3>  Steppingzomby </h3><br>  O c√≥digo neste exemplo segue as etapas resolveDnsName ---&gt; connectTcp ---&gt; estabeleSsl ---&gt; sendHttpRequest ---&gt; readHttpReply, simulando a opera√ß√£o da conex√£o HTTPS do cliente em execu√ß√£o ass√≠ncrona.  Cada passo leva cerca de um segundo. <br><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SteppingZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; void resolveDnsName(); void connectTcp(); void establishSsl(); void sendHttpRequest(); void readHttpReply(); }; } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include &lt;string&gt; #include "SteppingZomby.h" #include "Common/Listener.h" namespace { void doSomething(Common::Listener&amp; listener, std::string&amp;&amp; callingFunctionName) { listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " started\n")); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " finished\n")); } } // namespace namespace SteppingZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SteppingZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;resolveDnsName(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;connectTcp(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;establishSsl(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;sendHttpRequest(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;readHttpReply(); } }); } void Zomby::resolveDnsName() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::connectTcp() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::establishSsl() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::sendHttpRequest() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::readHttpReply() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "SteppingZomby/SteppingZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto steppingZomby = SteppingZomby::Zomby::create(); steppingZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(1500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text"><blockquote>  N13SteppingZomby5ZombyE :: resolveDnsName iniciado <br>  N13SteppingZomby5ZombyE :: resolveDnsName conclu√≠do <br>  N13SteppingZomby5ZombyE :: connectTcp iniciado <br>  ===================================================== =========== <br>  |  Zomby foi morto | <br>  ===================================================== =========== <br>  N13SteppingZomby5ZombyE :: connectTcp finalizado <br>  N13SteppingZomby5ZombyE :: EstablSsl iniciado <br>  N13SteppingZomby5ZombyE :: EstablSsl conclu√≠do <br>  N13SteppingZomby5ZombyE :: sendHttpRequest iniciado <br>  N13SteppingZomby5ZombyE :: sendHttpRequest finalizado <br>  N13SteppingZomby5ZombyE :: readHttpReply iniciado <br>  N13SteppingZomby5ZombyE :: readHttpReply conclu√≠do <br>  N13SteppingZomby5ZombyE :: ~ Zomby <br>  N6Common22WriteToConsoleListenerE :: ~ WriteToConsoleListener <br></blockquote><br></div></div><br>  Como no exemplo anterior, uma chamada para runOnce () levou a uma refer√™ncia circular. <br>  Mas desta vez, os destruidores de Zomby e WriteToConsoleListener <b>foram</b> chamados.  Todos os recursos foram liberados corretamente at√© o t√©rmino do aplicativo.  Um vazamento de mem√≥ria n√£o ocorreu. <br><br>  <b>Qual √© o problema ent√£o?</b> <br>  O problema √© que o zumbi viveu muito tempo - cerca de tr√™s segundos e meio ap√≥s a destrui√ß√£o de todos os elos fortes e fracos externos a ele.  Cerca de tr√™s segundos a mais do que ele deveria ter vivido.  E, durante todo esse tempo, ele se dedicou a promover a implementa√ß√£o da conex√£o HTTPS - at√© que ele chegou ao fim.  Apesar do fato de o resultado n√£o ser mais necess√°rio.  Apesar do fato de que a l√≥gica de neg√≥cios superior tentou impedir os zumbis. <br><br>  <b>Bem, pense bem, voc√™ tem a resposta que n√£o precisa ...</b> <br>  No caso de uma conex√£o HTTPS do cliente, as consequ√™ncias <b>do nosso lado</b> podem ser as seguintes: <br>  - consumo de mem√≥ria; <br>  - consumo de CPU; <br>  - consumo de porta TCP; <br> ‚Äî      ( ,        ); <br> ‚Äî       - ‚Äî           , ..       . <br>  <b>  </b> (  ‚Äî HTTPS- - ) ‚Äî     ,  : <br> ‚Äî      ; <br> ‚Äî       ; <br> ‚Äî     ; <br> ‚Äî     ; <br> ‚Äî    . <br> -   ,        .   HTTPS- <b>  </b> ‚Äî     ,       . <br>    -. <br><br> -            ,    . <br>      (, Websocket-)     ,       -    ‚Äî    . <br><br> <b>Valgrind?</b> <br>  .     .      ,   . <br><br><h3> BoozdedZomby </h3><br>      boozd::azzio,   boost::asio.   ,    ,     .     io_context::async_read (   ,     ), : <br> ‚Äî stream,     ; <br> ‚Äî ,    ; <br> ‚Äî callback-,       . <br>  io_context::async_read       callback,       (, ).        io_context::run() (     ,        ). <br><br><div class="spoiler"> <b class="spoiler_title">buffer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; namespace boozd::azzio { using buffer = std::vector&lt;int&gt;; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">stream.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;optional&gt; namespace boozd::azzio { class stream { public: virtual ~stream() = default; virtual std::optional&lt;int&gt; read() = 0; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">io_context.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; #include &lt;optional&gt; #include "buffer.h" namespace boozd::azzio { class stream; class io_context { public: ~io_context(); enum class error_code {no_error, good_error, bad_error, unknown_error, known_error, well_known_error}; using handler = std::function&lt;void(error_code)&gt;; // Start an asynchronous operation to read a certain amount of data from a stream. // This function is used to asynchronously read a certain number of bytes of data from a stream. // The function call always returns immediately. void async_read(stream&amp; s, buffer&amp; b, handler&amp;&amp; handler); // Run the io_context object's event processing loop. void run(); private: using pack = std::tuple&lt;stream&amp;, buffer&amp;&gt;; using pack_optional = std::optional&lt;pack&gt;; using handler_optional = std::optional&lt;handler&gt;; pack_optional _pack_optional; handler_optional _handler_optional; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">io_context.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;thread&gt; #include &lt;chrono&gt; #include "io_context.h" #include "stream.h" namespace boozd::azzio { io_context::~io_context() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void io_context::async_read(stream&amp; s, buffer&amp; b, io_context::handler&amp;&amp; handler) { _pack_optional.emplace(s, b); _handler_optional.emplace(std::move(handler)); } void io_context::run() { if (_pack_optional &amp;&amp; _handler_optional) { auto&amp; [s, b] = *_pack_optional; using namespace std::chrono; auto start = steady_clock::now(); while (duration_cast&lt;milliseconds&gt;(steady_clock::now() - start).count() &lt; 1000) { if (auto read = s.read()) b.emplace_back(*read); std::this_thread::sleep_for(milliseconds(100)); } (*_handler_optional)(error_code::no_error); } } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br>    boozd::azzio::stream,   : <br><br><div class="spoiler"> <b class="spoiler_title">impl/random_stream.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"boozd/azzio/stream.h"</span></span></span><span class="hljs-meta"> namespace boozd::azzio { class random_stream final : public stream { public: ~random_stream() override; std::optional</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int&gt; read() override; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">impl/random_stream.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "random_stream.h" namespace boozd::azzio { boozd::azzio::random_stream::~random_stream() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::optional&lt;int&gt; random_stream::read() { if (!(rand() &amp; 0x1)) return rand(); return std::nullopt; } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br> BoozdedZomby     -. -      async_read(),       boozd::azzio   run().     boozd::azzio        ( )      callback-.      ,    , -  shared_from_this. <br><br><div class="spoiler"> <b class="spoiler_title">BoozdedZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" #include "boozd/azzio/buffer.h" #include "boozd/azzio/io_context.h" #include "boozd/azzio/impl/random_stream.h" namespace Common { class Listener; } // namespace Common namespace BoozdedZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; Semaphore _semaphore = false; std::shared_ptr&lt;Common::Listener&gt; _listener; boozd::azzio::random_stream _stream; boozd::azzio::buffer _buffer; boozd::azzio::io_context _context; std::thread _thread; }; } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">BoozdedZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;sstream&gt; #include "boozd/azzio/impl/random_stream.h" #include "BoozdedZomby.h" #include "Common/Listener.h" namespace BoozdedZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("BoozdedZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()]() { while (shis &amp;&amp; shis-&gt;_semaphore &amp;&amp; shis-&gt;_listener) { auto handler = [shis](auto errorCode) { if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; errorCode == boozd::azzio::io_context::error_code::no_error) { std::ostringstream buf; buf &lt;&lt; "BoozdedZomby has got a fresh data: "; for (auto const &amp;elem : shis-&gt;_buffer) buf &lt;&lt; elem &lt;&lt; ' '; buf &lt;&lt; std::endl; shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } }; shis-&gt;_buffer.clear(); shis-&gt;_context.async_read(shis-&gt;_stream, shis-&gt;_buffer, handler); shis-&gt;_context.run(); } }); } } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "BoozdedZomby/BoozdedZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto boozdedZomby = BoozdedZomby::Zomby::create(); boozdedZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><blockquote> BoozdedZomby has got a fresh data: 1144108930 101027544 1458777923 1115438165 74243042 <br> BoozdedZomby has got a fresh data: 143542612 1131570933 <br> BoozdedZomby has got a fresh data: 893351816 563613512 704877633 <br> BoozdedZomby has got a fresh data: 1551901393 1399125485 1899894091 937186357 590357944 357571490 <br> ============================================================ <br>  | Zomby was killed | <br> ============================================================ <br> BoozdedZomby has got a fresh data: 1927702196 130060903 1083454666 2118797801 2035308228 824938981 <br> BoozdedZomby has got a fresh data: 2020739063 1635339425 34075629 <br> BoozdedZomby has got a fresh data: 2146319451 500782188 1269406752 884936716 892053144 <br> BoozdedZomby has got a fresh data: 330111137 1723153177 1070477904 <br> BoozdedZomby has got a fresh data: 343098142 280090412 589673557 889688008 2014119113 388471006 <br></blockquote><br></div></div><br>    run_once()   .         .       ,     : <br> ‚Äî boozdedZomby; <br> ‚Äî writeToConsoleListener; <br> ‚Äî   . <br>   . <br>   . <br><br> <b>     ?</b> <br>      .      .          boost::asio.  ,              ‚Äî        ( ). <br><br> <b>Valgrind?</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passado. </font><font style="vertical-align: inherit;">Embora pare√ßa ter sido detectar vazamentos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zumbis em estado selvagem </font></font></h2><br> <b> !    !</b> <br>   . <br> <a href="https://www.boost.org/doc/libs/master/libs/beast/example/http/client/async/"> HTTP-</a> <br> <a href=""> Websocket-</a> <br>    boost ,    BoozdedZomby + SteppingZomby.   ,     .         ,      production ‚Äî       ,      . <br><br> <b>  ,   boost::asio::io_context!</b> <br> ‚Ä¶    n  (, -),    . <br><br>  : <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    stackoverflow ,        </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   ,      </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">         </a> <br><br><h2>  Conclus√£o </h2><br> ,        ¬´¬ª. <br><br>         ,       . <br><br>        std::thread    ‚Äî          . <br><br>      ,   . <br><br>     event-driven,        (polling-based). <br><br>     . <br><br> ,  <b></b>           .       std::enable_shared_from_this,       (       ‚Äî       ). ,        :            -    . <br><br>           ,    SteppingZomby.       ‚Äî          shared_from_this (  ,   ,       ‚Äî   1  6  ). <br><br>           ‚Äî     ,  .   . <br><br>  ,   ,  .        std::enable_shared_from_this ‚Äî  <b></b> . <br><br> PS:    ‚Äî        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471326/">https://habr.com/ru/post/pt471326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471310/index.html">Minha opini√£o muito subjetiva sobre o profissional e n√£o apenas a educa√ß√£o em TI</a></li>
<li><a href="../pt471312/index.html">Preparando-se para a certifica√ß√£o profissional da Spring. Bota de mola</a></li>
<li><a href="../pt471318/index.html">Resumo de aprendizado de m√°quina e intelig√™ncia artificial de setembro</a></li>
<li><a href="../pt471320/index.html">Ferramentas para desenvolvedores de software: Framework aberto e bibliotecas de aprendizado de m√°quina</a></li>
<li><a href="../pt471324/index.html">As redes neurais sonham com a Mona Lisa?</a></li>
<li><a href="../pt471330/index.html">Hist√≥rias do computador lunar. Parte 2</a></li>
<li><a href="../pt471332/index.html">Hist√≥rias do computador lunar. Parte 3</a></li>
<li><a href="../pt471334/index.html">Para memorizar, mas n√£o para empinar - aprendendo ‚Äúpor cart√µes‚Äù</a></li>
<li><a href="../pt471336/index.html">Holivar. Hist√≥ria do Runet. Parte 6. Fechaduras: Lurk, Tape, 282nd e caminho chin√™s</a></li>
<li><a href="../pt471340/index.html">Drimsim vs Mate 20 Pro Round! Mas para quem?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>