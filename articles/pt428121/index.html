<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöó üßùüèº üë©‚Äçüë©‚Äçüëß‚Äçüëß Stan Drapkin. Armadilhas de criptografia de alto n√≠vel no .NET üëµ üë©üèΩ‚Äçüöí üéÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stan Drapkin √© um especialista em seguran√ßa e conformidade com mais de 16 anos de experi√™ncia com o .NET Framework (come√ßando com o .NET 1.0-beta em 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Stan Drapkin. Armadilhas de criptografia de alto n√≠vel no .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/428121/">  Stan Drapkin √© um especialista em seguran√ßa e conformidade com mais de 16 anos de experi√™ncia com o .NET Framework (come√ßando com o .NET 1.0-beta em 2001).  Infelizmente, ele pr√≥prio n√£o escreve artigos em russo, ent√£o concordamos com ele em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publicar</a> uma tradu√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seu relat√≥rio com o DotNext Piter</a> .  Este relat√≥rio <b>conquistou o primeiro lugar</b> na confer√™ncia! <br><br>  Criptografia sim√©trica, assim√©trica, h√≠brida, de alto n√≠vel, baixo n√≠vel, fluxo e criptografia el√≠ptica moderna.  Cinq√ºenta e seis minutos de v√≠deo sobre criptografia e muito mais r√°pido - na forma de texto. <br><br><img src="https://habrastorage.org/webt/ye/8s/g0/ye8sg0kuwhgvtitnjxvwpehfnwc.png"><br><br>  Sob o corte - v√≠deos, slides e tradu√ß√£o.  Boa leitura! <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZqGyV7Jshww" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Slides</a> <br><br>  Meu nome √© Stan Drapkin, sou o diretor t√©cnico de uma empresa especializada em seguran√ßa da informa√ß√£o e conformidade regulat√≥ria.  Al√©m disso, sou autor de v√°rias bibliotecas de c√≥digo aberto, que s√£o muito bem recebidas pela comunidade.  Quantos ouviram falar do <i>Inferno</i> ?  Esta biblioteca demonstra a abordagem correta da criptografia no .NET e o <i>TinyORM</i> implementa o micro-ORM para .NET.  Al√©m disso, escrevi v√°rios livros que podem ser relevantes para o t√≥pico do artigo de hoje.  Um deles, a edi√ß√£o de 2014, √© ‚ÄúSecurity Driven .NET‚Äù, o outro de 2017 √© ‚ÄúApplication Security in .NET, Succinctly‚Äù. <br><br>  Primeiro, falaremos sobre o que eu chamo de quatro est√°gios da ilumina√ß√£o criptogr√°fica.  Em seguida, dois t√≥picos principais se seguir√£o: no primeiro, falaremos sobre criptografia sim√©trica; no segundo, sobre assim√©trico e h√≠brido.  Na primeira parte, comparamos a criptografia de alto e baixo n√≠vel e analisamos um exemplo de criptografia de fluxo cont√≠nuo.  Na segunda parte, teremos muitas "aventuras" com a RSA, ap√≥s as quais nos familiarizaremos com a moderna criptografia el√≠ptica. <br><br>  Ent√£o, como s√£o esses est√°gios da cripto-ilumina√ß√£o?  A primeira etapa - "XOR √© t√£o legal, olha, m√£e, como posso!"  Certamente muitos de voc√™s est√£o familiarizados com este est√°gio e est√£o cientes das maravilhas da fun√ß√£o XOR.  Mas espero que a maior parte desse est√°gio tenha crescido e passado para a pr√≥xima, ou seja, aprendida a executar criptografia e descriptografia usando o AES (Advanced Encryption Standard), um algoritmo conhecido e altamente considerado.  A maioria dos desenvolvedores que n√£o visitam o DotNext est√° nesse est√°gio.  Por√©m, como voc√™ segue o DotNext e conhece os relat√≥rios sobre os perigos das APIs de baixo n√≠vel, voc√™ provavelmente est√° no pr√≥ximo est√°gio: "Fiz tudo (a) incorretamente, preciso mudar para as APIs de alto n√≠vel".  Bem, para completar, vou mencionar tamb√©m a √∫ltima etapa - o entendimento de que, com a melhor solu√ß√£o para o problema, a criptografia pode n√£o ser necess√°ria.  Esse est√°gio √© o mais dif√≠cil de alcan√ßar e h√° poucas pessoas nele.  Um exemplo √© Peter G. Neumann, que disse o seguinte: "Se voc√™ acha que a solu√ß√£o para o seu problema est√° na criptografia, n√£o entende exatamente qual √© o seu problema". <br><br>  O fato de que a criptografia de baixo n√≠vel √© perigosa foi discutido em muitos relat√≥rios sobre o .NET.  Voc√™ pode consultar o relat√≥rio de Vladimir Kochetkov em 2015, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Armadilhas do System.Security.Cryptography"</a> .  Sua id√©ia principal √© que, em cada est√°gio do trabalho com APIs criptogr√°ficas de baixo n√≠vel, sem conhec√™-lo, tomamos muitas decis√µes, para muitas das quais simplesmente n√£o temos o conhecimento apropriado.  A principal conclus√£o √© que, idealmente, a criptografia de alto n√≠vel deve ser usada em vez da criptografia de baixo n√≠vel.  Essa √© uma conclus√£o maravilhosa, mas nos leva a outro problema - sabemos exatamente como deve ser a criptografia de alto n√≠vel?  Vamos conversar um pouco sobre isso. <br><br>  Defina os atributos de uma API criptogr√°fica de n√≠vel <i>n√£o</i> alto.  Para come√ßar, essa API n√£o dar√° a impress√£o de ser nativa do .NET, mas parecer√° um shell de baixo n√≠vel.  Al√©m disso, essa API ser√° f√°cil de usar incorretamente, ou seja,  n√£o como deveria.  Al√©m disso, for√ßar√° voc√™ a gerar muitas coisas estranhas de baixo n√≠vel - nonce, vetores de inicializa√ß√£o e similares.  Essa API o for√ßar√° a tomar decis√µes desagrad√°veis ‚Äã‚Äãpara as quais voc√™ n√£o est√° preparado - escolha algoritmos, modos de preenchimento, tamanhos de chave, nonce etc.  Tamb√©m n√£o ter√° a API correta para streaming (API de streaming) - falaremos sobre como a √∫ltima deve ser. <br><br>  Por outro lado, como deve ser uma API criptogr√°fica de alto n√≠vel?  Acredito que, antes de tudo, deve ser intuitivo e conciso para o leitor do c√≥digo e o escritor.  Al√©m disso, essa API deve ser f√°cil de aprender e usar e deve ser extremamente dif√≠cil de aplicar da maneira errada.  Tamb√©m deve ser poderoso, isto √©, deve permitir-nos alcan√ßar nosso objetivo com um pouco de esfor√ßo, uma pequena quantidade de c√≥digo.  Por fim, essa API n√£o deve ter uma lista longa de restri√ß√µes, cuidados, casos especiais, em geral - deve haver um m√≠nimo de coisas que devem ser lembradas ao trabalhar com ela, em outras palavras - deve ser caracterizada por um baixo n√≠vel de interfer√™ncia (baixo atrito). apenas trabalhe sem reservas. <br><br>  Tendo lidado com os requisitos para uma API criptogr√°fica de alto n√≠vel para .NET, como podemos encontr√°-la agora?  Voc√™ pode tentar apenas o google, mas isso seria muito primitivo - somos desenvolvedores profissionais e esse n√£o √© o nosso m√©todo.  Portanto, estamos investigando esse problema e testando v√°rias alternativas.  Mas, para isso, precisamos primeiro criar para n√≥s mesmos a id√©ia correta do que √© a criptografia autenticada e, para isso, precisamos entender os conceitos b√°sicos.  Eles s√£o os seguintes: o texto sem formata√ß√£o P (texto sem formata√ß√£o), que convertemos em texto cifrado C (texto cifrado) do mesmo comprimento usando alguma chave secreta K (chave).  Como voc√™ pode ver, at√© agora estamos trabalhando com um esquema muito simples.  Al√©m disso, tamb√©m temos uma tag de autentica√ß√£o T e nonce N. Um par√¢metro importante √© NÃÖ, ou seja, reutilizar o nonce com uma chave.  Como muitos de voc√™s provavelmente sabem, isso leva a uma viola√ß√£o da confidencialidade do texto, o que √© obviamente indesej√°vel.  Outro conceito importante √© o AD (Associated Data), ou seja, dados associados.  S√£o dados opcionais que s√£o autenticados, mas n√£o participam da criptografia e descriptografia. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f9/41c/537/2f941c537ee2813920df009759b19e97.jpg"><br><br>  Tendo entendido os conceitos b√°sicos, vamos dar uma olhada nas v√°rias op√ß√µes de bibliotecas criptogr√°ficas para .NET.  Vamos come√ßar com a an√°lise do <i>Libsodium.NET.</i>  Quantos de voc√™s a conhecem?  A meu ver, alguns s√£o familiares. <br><br><pre><code class="cs hljs">nonce = SecretAeadAes.GenerateNonce(); c = SecretAeadAes.Encrypt(p, nonce, key, ad); d = SecretAeadAes.Decrypt(c, nonce, key, ad);</code> </pre> <br>  <i>Aqui est√° o</i> c√≥digo C # com o qual a criptografia √© realizada com o <i>Libsodium.NET</i> .  √Ä primeira vista, √© bastante simples e conciso: na primeira linha, gera-se nonce, que √© usado na segunda linha, onde a criptografia ocorre, e na terceira, onde o texto √© descriptografado.  Parecia - que dificuldades poderiam existir?  Para come√ßar, o Libsodium.NET oferece n√£o um, mas tr√™s m√©todos diferentes de criptografia sim√©trica: <br><br>  Vezes <br><br><pre> <code class="cs hljs">nonce = SecretAeadAes.GenerateNonce(); c = SecretAeadAes.Encrypt(p, nonce, key, ad); d = SecretAeadAes.Decrypt(c, nonce, key, ad);</code> </pre><br>  Dois <br><br><pre> <code class="cs hljs">nonce = SecretAead.GenerateNonce(); c = SecretAead.Encrypt(p, nonce, key, ad); d = SecretAead.Decrypt(c, nonce, key. ad);</code> </pre><br>  Tr√™s <br><br><pre> <code class="cs hljs">nonce = SecretBox.GenerateNonce(); c = SecretBox.Create(p, nonce, key); d = SecretBox.Open(c, nonce, key);</code> </pre><br>  Obviamente, surge a pergunta - qual deles √© melhor em sua situa√ß√£o espec√≠fica?  Para responder, √© necess√°rio entrar nesses m√©todos, o que faremos agora. <br><br>  O primeiro m√©todo, <code>SecretAeadAes</code> , usa o AES-GCM com um nonce de 96 bits.  √â importante que ele tenha uma lista bastante longa de restri√ß√µes.  Por exemplo, ao us√°-lo, voc√™ n√£o deve criptografar mais de 550 gigabytes com uma chave e n√£o deve haver mais de 64 gigabytes em uma mensagem com no m√°ximo 2 <sup>32</sup> mensagens.  Al√©m disso, a biblioteca n√£o avisa sobre essas restri√ß√µes; voc√™ mesmo deve rastre√°-las, o que cria uma carga adicional para voc√™ como desenvolvedor. <br><br>  O segundo m√©todo, o <code>SecretAead</code> , usa um conjunto de cifras diferente, <code>ChaCha20/Poly1305</code> com um nonce de 64 bits significativamente menor.  Um n√∫mero t√£o pequeno faz com que as colis√µes sejam extremamente prov√°veis ‚Äã‚Äãe, por esse motivo, voc√™ n√£o deve usar esse m√©todo - exceto em casos muito raros e desde que voc√™ seja muito versado no t√≥pico. <br><br>  Finalmente, o terceiro m√©todo, <code>SecretBox</code> .  Deve-se notar imediatamente que n√£o h√° dados associados nos argumentos para esta API.  Se voc√™ precisar de criptografia autenticada com o AD, esse m√©todo n√£o √© adequado para voc√™.  O algoritmo de criptografia usado aqui √© chamado <code>xSalsa20/Poly1305</code> , o nonce √© grande o suficiente - 192 bits.  No entanto, a falta de DA √© uma limita√ß√£o significativa. <br><br>  Ao usar o <i>Libsodium.NET</i> , surgem algumas perguntas.  Por exemplo, o que exatamente devemos fazer com o nonce gerado pela primeira linha de c√≥digo nos exemplos acima?  A biblioteca n√£o nos diz nada sobre isso, temos que descobrir por conta pr√≥pria.  Provavelmente, adicionaremos manualmente esse nonce ao in√≠cio ou ao final do texto cifrado.  Al√©m disso, podemos ter a impress√£o de que o AD nos dois primeiros m√©todos pode ter qualquer tamanho.  Mas, de fato, a biblioteca suporta o AD com no m√°ximo 16 bytes - afinal, 16 bytes ser√£o suficientes para todos, certo?  Vamos seguir em frente.  O que acontece com os erros de descriptografia?  Nesta biblioteca, foi decidido nesses casos lan√ßar exce√ß√µes.  Se em seu ambiente durante a descriptografia, a integridade dos dados puder ser violada, voc√™ ter√° muitas exce√ß√µes que precisar√£o ser tratadas.  E se o tamanho da sua chave n√£o tiver exatamente 32 bytes?  A biblioteca n√£o nos diz nada sobre isso, esses s√£o seus problemas que n√£o lhe interessam.  Outro t√≥pico importante √© a reutiliza√ß√£o de matrizes de bytes, a fim de reduzir a carga no coletor de lixo em cen√°rios intensivos.  Por exemplo, no c√≥digo, vimos uma matriz que o gerador de nonce retornou para n√≥s.  Gostaria de n√£o criar um novo buffer a cada vez, mas reutilizar o existente.  Isso n√£o √© poss√≠vel nesta biblioteca, uma matriz de bytes ser√° regenerada toda vez. <br><br>  Usando o esquema que j√° vimos, tentaremos comparar v√°rios algoritmos do <i>Libsodium.NET</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3c/6e3/d3c/b3c6e3d3ce4ef29723e2ac691c3fd4d4.jpg"><br><br>  O primeiro algoritmo, AES-GCM, usa nonce 96 bits de comprimento (coluna amarela na imagem).  Tem menos de 128 bits, o que cria algum desconforto, mas n√£o √© muito significativo.  A pr√≥xima coluna √© azul, este √© o local ocupado pela etiqueta de autentica√ß√£o; no AES-GCM, s√£o 16 bytes ou 128 bits.  O segundo d√≠gito azul, entre par√™nteses, significa a quantidade de entropia, ou aleatoriedade, contida nessa tag - menos de 128 bits.  Quanto menos - nesse algoritmo depende da quantidade de dados criptografados.  Quanto mais criptografada, mais fraca a tag.  Isso por si s√≥ deve gerar d√∫vidas sobre esse algoritmo, que s√≥ aumentar√° se olharmos para a coluna branca.  Diz que repeti√ß√µes (colis√µes) de nonce levar√£o √† falsifica√ß√£o de todos os textos cifrados criados pela mesma chave.  Se, dentre, digamos, 100 de seus textos cifrados criados por uma chave comum em dois, houver uma colis√£o n√£o-violenta, essa viol√™ncia levar√° a um vazamento interno da chave de autentica√ß√£o e permitir√° que um invasor falsifique qualquer outro texto cifrado criado por essa chave.  Essa √© uma limita√ß√£o muito significativa. <br><br>  Vamos para o segundo m√©todo <i>Libsodium.NET</i> .  Como eu disse, aqui para nonce, pouco espa√ßo √© usado, apenas 64 bits.  A tag ocupa 128 bits, mas cont√©m apenas 106 bits de entropia ou menos, em outras palavras, significativamente inferior ao n√≠vel de seguran√ßa de 128 bits, que na maioria dos casos eles tentam alcan√ßar.  Quanto √† falsifica√ß√£o, a situa√ß√£o aqui √© um pouco melhor do que no caso da AES-GCM.  A colis√£o de nonce leva √† falsifica√ß√£o de textos cifrados, mas apenas para os blocos em que ocorreram colis√µes.  No exemplo anterior, ter√≠amos forjado 2 textos cifrados, n√£o 100. <br><br>  Finalmente, no caso do algoritmo xSalsa / Poly, temos um nonce muito grande de 192 bits, o que torna as colis√µes extremamente improv√°veis.  O m√©todo de autentica√ß√£o √© o mesmo do m√©todo anterior; portanto, o tag novamente recebe 128 bits e possui 106 bits de entropia ou menos. <br><br>  Compare todos esses n√∫meros com os indicadores correspondentes da biblioteca <i>Inferno</i> .  Nele, o nonce ocupa um espa√ßo colossal de 320 bits, o que torna as colis√µes quase imposs√≠veis.  Quanto ao tag, tudo √© simples: ocupa exatamente 128 bits e possui exatamente 128 bits de entropia, nada menos.  Este √© um exemplo de uma abordagem confi√°vel e segura. <br><br>  Antes de conhecermos o <i>Libsodium.NET</i> com mais detalhes, precisamos entender seu objetivo - infelizmente, nem todo mundo que usa essa biblioteca est√° ciente disso.  Para fazer isso, consulte a documenta√ß√£o, que afirma que o <i>Libsodium.NET</i> √© um inv√≥lucro em C # para o <i>libsodium</i> .  Este √© outro projeto de c√≥digo aberto, cuja documenta√ß√£o diz que √© um fork do <i>NaCl</i> com uma API compat√≠vel.  Bem, consulte a documenta√ß√£o do <i>NaCl</i> , outro projeto de c√≥digo aberto.  Nele, como objetivo, postula- <i>se o NaCl</i> para fornecer todas as opera√ß√µes necess√°rias para a cria√ß√£o de ferramentas criptogr√°ficas de alto n√≠vel.  √â aqui que o c√£o est√° enterrado: a tarefa do <i>NaCl</i> e todas as suas conchas √© fornecer elementos de baixo n√≠vel, a partir dos quais algu√©m j√° pode montar APIs criptogr√°ficas de alto n√≠vel.  Esses shells como bibliotecas de alto n√≠vel n√£o foram concebidos.  Da√≠ a moral: se voc√™ precisa de uma API criptogr√°fica de alto n√≠vel, precisa encontrar uma biblioteca de alto n√≠vel e n√£o usar um wrapper de baixo n√≠vel e fingir que est√° trabalhando com um de alto n√≠vel. <br><br>  Vamos ver como a criptografia funciona no <i>Inferno</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/64f/367/fe7/64f367fe769bce5d8fa0482f8a301648.jpg"><br><br>  Aqui est√° um c√≥digo de exemplo no qual, como no caso do <i>Libsodium</i> , cada criptografia e descriptografia leva apenas uma linha.  Os argumentos s√£o chave, texto e dados associados opcionais.  Deve-se notar que n√£o h√° nenhuma exce√ß√£o, n√£o h√° necessidade de tomar decis√µes; no caso de um erro de descriptografia, ele simplesmente retorna nulo, sem gerar exce√ß√µes.  Como a cria√ß√£o de exce√ß√µes aumenta significativamente a carga no coletor de lixo, sua aus√™ncia √© muito importante para scripts que processam grandes fluxos de dados.  Espero ter conseguido convenc√™-lo de que essa abordagem √© √≥tima. <br><br>  Fora de interesse, vamos tentar criptografar alguma string.  Esse deve ser o cen√°rio mais simples que todos podem implementar.  Suponha que tenhamos apenas dois valores de string diferentes poss√≠veis: "ESQUERDA" e "DIREITA". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88b/522/92b/88b52292b7ce52dc2a90302cbbbe1f36.jpg"><br><br>  Na figura, voc√™ v√™ a criptografia dessas linhas usando o <i>Inferno</i> (embora, neste exemplo, n√£o importe qual biblioteca √© usada).  Criptografamos duas linhas com uma chave e obtemos dois textos cifrados, <code>c1</code> e <code>c2</code> .  Tudo neste c√≥digo est√° correto?  Ele est√° pronto para a produ√ß√£o?  Algu√©m pode dizer que o problema √© poss√≠vel em um curto espa√ßo de tempo, mas est√° longe do principal, portanto, assumiremos que a chave √© usada da mesma forma e que √© de comprimento suficiente.  Quero dizer outra coisa: com abordagens criptogr√°ficas convencionais, <code>c1</code> em nosso exemplo ser√° menor que <code>c2</code> .  Isso √© chamado de vazamento de comprimento - <code>c2</code> em muitos casos ter√° um byte a mais que <code>c1</code> .  Isso pode permitir que um invasor entenda qual sequ√™ncia √© representada por este texto cifrado, "ESQUERDA" ou "DIREITA".  A maneira mais f√°cil de resolver esse problema √© fazer com que as duas linhas tenham o mesmo comprimento - por exemplo, adicione um caractere ao final da linha "ESQUERDA". <br><br>  √Ä primeira vista, o vazamento de comprimento √© percebido como um problema absurdo que n√£o pode ser encontrado em aplicativos reais.  Mas em janeiro de 2018, um artigo foi publicado na revista Wired com um estudo realizado pela empresa israelense Checkmarx, sob o t√≠tulo "A falta de criptografia no Tinder permite que pessoas de fora rastreiem quando voc√™ desliza a tela".  Vou recontar brevemente o conte√∫do, mas primeiro uma descri√ß√£o aproximada da funcionalidade do Tinder.  O Tinder √© um aplicativo que recebe um fluxo com fotos e, em seguida, o usu√°rio desliza a tela para a direita ou esquerda, dependendo se ele gosta ou n√£o da foto.  Os pesquisadores descobriram que, embora os pr√≥prios comandos tenham sido criptografados corretamente usando TLS e HTTPS, os dados para o comando da direita ocupam um n√∫mero diferente de bytes que os da esquerda.  Isso, √© claro, √© uma vulnerabilidade, mas por si s√≥ n√£o √© muito significativo.  Mais significativo para o Tinder foi o fato de que eles enviaram os fluxos com fotos via HTTP normal, sem nenhuma criptografia.  Assim, o invasor pode obter acesso n√£o apenas √†s rea√ß√µes do usu√°rio √†s fotos, mas tamb√©m √†s pr√≥prias fotos.  Ent√£o, como voc√™ pode ver, o vazamento de comprimento √© um problema muito real. <br><br>  Agora vamos tentar criptografar o arquivo.  Imediatamente, devo dizer que na criptografia de arquivo <i>Libsodium.NET</i> ou, mais amplamente, a criptografia de fluxo n√£o √© implementada por padr√£o; ela deve ser feita manualmente - o que, acredite, √© muito dif√≠cil de executar corretamente.  No <i>Inferno</i> , as coisas s√£o muito melhores com isso. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f0/446/955/5f0446955f52e679e6dbeaacee2389b4.jpg"><br><br>  Acima, voc√™ v√™ um exemplo tirado praticamente sem altera√ß√µes do MSDN.  √â muito simples, aqui vemos um fluxo para o arquivo de origem e outro para o arquivo de destino, al√©m de um fluxo de criptografia que converte o primeiro no segundo.  Nesse c√≥digo, o <i>Inferno √©</i> usado apenas em uma linha - na onde a convers√£o ocorre.  Portanto, diante de n√≥s √© uma solu√ß√£o simples e ao mesmo tempo totalmente funcional e testada para criptografia de fluxo. <br><br>  Deve-se lembrar que ao criptografar com a mesma chave, temos um limite no n√∫mero de mensagens.  Eles existem no <i>Inferno</i> e nesta biblioteca est√£o claramente escritos na tela.  Mas, ao mesmo tempo, eles s√£o t√£o grandes no <i>Inferno</i> que, na pr√°tica, voc√™ nunca os alcan√ßar√°.  No <i>Libsodium.NET, as</i> restri√ß√µes s√£o diferentes para algoritmos diferentes, mas em todos os casos elas s√£o baixas o suficiente para serem excedidas.  Portanto, voc√™ precisa verificar se eles ser√£o alcan√ßados em cada cen√°rio individual. <br><br>  Tamb√©m devemos falar sobre autentica√ß√£o de dados associados, pois esse √© um t√≥pico que muitas vezes n√£o √© abordado.  Os an√∫ncios podem ser "fracos": isso significa que eles s√£o autenticados, mas n√£o est√£o envolvidos no processo de criptografia e descriptografia.  Por outro lado, os an√∫ncios "fortes" alteram esse processo.  A maioria das bibliotecas do AD que conhe√ßo s√£o fracas, enquanto o <i>Inferno</i> usa a segunda abordagem, na qual os ADs s√£o usados ‚Äã‚Äãno pr√≥prio processo de criptografia / descriptografia ... <br><br>  Ele tamb√©m deve se concentrar em qual n√≠vel de seguran√ßa deve se esfor√ßar para a criptografia de alto n√≠vel.  Em resumo, minha resposta √©: criptografia de 256 bits com uma marca de autentica√ß√£o de 128 bits.  Por que uma chave √© t√£o grande?  H√° muitas raz√µes para isso, cada uma das quais √© significativa por si s√≥, mas agora gostaria que voc√™ se lembrasse de uma coisa: precisamos nos proteger de poss√≠veis preconceitos ao gerar chaves criptogr√°ficas.  Deixe-me explicar o que se entende por vi√©s.  Para um gerador de bits aleat√≥rio sem vi√©s, para cada bit, as probabilidades de aceitar o valor 0 ou 1 s√£o iguais.  Mas suponha que em nosso gerador o bit aceite o valor 1 com uma probabilidade de 56%, n√£o 50%.  √Ä primeira vista, esse vi√©s √© pequeno, mas na verdade √© significativo: 25%.  Agora vamos tentar calcular a quantidade de entropia que obtemos ao gerar um certo n√∫mero de bits com nosso gerador. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3eb/f2e/df8/3ebf2edf8c049579b2e4218f9dff16b8.jpg"><br><br>  Na figura, voc√™ v√™ a f√≥rmula pela qual esse c√°lculo ser√° feito.  √â importante que existam apenas duas vari√°veis: o vi√©s sobre o qual j√° falamos (vi√©s) e o n√∫mero de bits criados pelo gerador.  Assumimos que o vi√©s √© de 25% - este √© um caso bastante extremo; na pr√°tica, voc√™ provavelmente n√£o funcionar√° em sistemas com um gerador de n√∫meros aleat√≥rios distorcido.  De qualquer forma, com vi√©s de 25% e uma chave de 128 bits, obtemos apenas 53 bits de entropia.  Primeiro, √© significativamente menor que 128 bits, o que geralmente √© esperado de um gerador de n√∫meros aleat√≥rios e, segundo, com as tecnologias modernas, essa chave pode ser simplesmente for√ßa bruta.  Mas se em vez da chave de 128 bits usarmos 256 bits, obteremos 106 bits de entropia.  Isso j√° √© muito bom, embora seja menor que o esperado 256. Com as tecnologias modernas, √© quase imposs√≠vel decifrar essa chave. <br><br>  No final da primeira parte do relat√≥rio, resumirei os resultados intermedi√°rios.  Eu recomendo a todos que usem APIs criptogr√°ficas bem escritas.  Encontre o que mais lhe conv√©m ou envie uma peti√ß√£o √† Microsoft para escrever para voc√™.  Al√©m disso, ao escolher uma API, voc√™ deve prestar aten√ß√£o √† disponibilidade de suporte para trabalhar com threads.  Pelas raz√µes j√° explicadas, o comprimento m√≠nimo da chave deve ser de 256 bits.  Por fim, deve-se ter em mente que a criptografia de alto n√≠vel, como qualquer outra, n√£o √© ideal.  Podem ocorrer vazamentos e, na maioria dos cen√°rios, seus recursos devem ser mantidos em mente. <br><br>  Vamos falar sobre criptografia assim√©trica ou h√≠brida.  Vou fazer uma pergunta complicada: voc√™ pode usar o RSA no .NET?  N√£o se apresse em responder afirmativamente, como muitos fazem - vamos primeiro testar seu conhecimento nessa √°rea.  Os slides a seguir ser√£o projetados especificamente para pessoas que j√° est√£o familiarizadas com este t√≥pico.  Mas primeiro, vejamos a Wikipedia e lembre-se do que √© exatamente o RSA, caso algu√©m se esque√ßa ou n√£o use esse algoritmo h√° muito tempo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fec/e71/6ba/fece716ba7a00668b4d955c37745e744.png"><br><br>  Suponha que haja Alice que, usando um gerador de n√∫meros aleat√≥rios, crie um par de chaves que inclua um privado e um p√∫blico.  Em seguida, h√° um Bob que deseja criptografar uma mensagem para Alice: "Ol√° Alice!"  Usando sua chave p√∫blica, ele gera um texto cifrado, que ele envia para ela.  Ela descriptografa esse texto cifrado usando a parte privada de sua chave. <br><br>  Vamos tentar reproduzir esse cen√°rio na pr√°tica. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/35d/021/627/35d021627d87f316a65b87bc4662aa05.jpg"><br><br>  Como voc√™ pode ver acima, criamos uma inst√¢ncia do RSA e criptografamos algum texto.  Preste imediatamente aten√ß√£o que o .NET nos obriga a escolher o modo de preenchimento.  Existem cinco deles, todos com nomes obscuros.  Se tentarmos todos por sua vez, descobriremos que os tr√™s √∫ltimos simplesmente lan√ßam uma exce√ß√£o e n√£o funcionam.  Usaremos um dos dois restantes - <code>OaepSHA1</code> .  Aqui, a chave ter√° 1 kilobit de tamanho, que √© muito pequena para o RSA, √© praticamente uma chave invadida.  Portanto, temos que definir o tamanho da chave manualmente.  A partir da documenta√ß√£o, descobrimos que existe uma propriedade especial <code>.KeySize</code> , que recebe ou define o tamanho da chave. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0e/e77/a12/e0ee77a12bcd866142463ee8440c9b28.jpg"><br><br>  √Ä primeira vista, √© exatamente isso que precisamos, ent√£o escrevemos: <code>rsa.KeySize = 3072</code> .  Mas se, guiados por suspeitas vagas, depois verificarmos qual √© o tamanho da chave agora, descobriremos que ele ainda precisa de 1 kilobit.  N√£o importa, verificaremos esse par√¢metro usando o m√©todo <code>WriteLine(rsa.KeySize)</code> ou <code>rsa.ExportParameters(false).Modulus.Length * 8</code> - neste √∫ltimo caso, o componente p√∫blico da chave RSA √© exportado, para isso precisamos do argumento "false".  O m√≥dulo dessa chave √© uma matriz, que multiplicamos por 8 e obtemos o tamanho em bits - que novamente ser√° de 1 kilobit.  Como voc√™ pode ver, esse algoritmo ainda √© muito cedo para enviar para produ√ß√£o. <br><br>  N√£o perderemos tempo tentando descobrir por que essa API n√£o funciona; tente outra implementa√ß√£o RSA fornecida pela Microsoft no .NET 4.6, ou seja, completamente nova.  √â chamado <i>RSACng</i> , e <i>Cng</i> significa Cryptography next generation.  √ìtimo, quem n√£o quer trabalhar com ferramentas da pr√≥xima gera√ß√£o?  Certamente aqui vamos encontrar uma solu√ß√£o m√°gica para todos os nossos problemas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/1af/3fb/7ed1af3fbcd93422ff6648e2af791264.jpg"><br><br>  Solicitamos uma inst√¢ncia do RSACng, definimos novamente o tamanho da chave como 3 kilobits, verificamos novamente o tamanho da chave via <code>WriteLine(rsa.KeySize)</code> - e descobrimos novamente que o tamanho da chave ainda √© igual a um kilobit.  Al√©m disso, se solicitarmos o tipo de objeto que gerou a chave - como lembramos, solicitamos uma inst√¢ncia do RSACng - descobrimos que √© RSACryptoServiceProvider.  Eu s√≥ quero compartilhar meu sentimento pessoal de desespero aqui e gritar: "Por que Microsoft?!" <br><br>  Ap√≥s tormento e tormento prolongados, descobrimos que, de fato, voc√™ precisa usar o designer, n√£o a f√°brica. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c20/5e7/be1/c205e7be1603914e310bfb703f25e157.jpg"><br><br>  Aqui, o valor padr√£o do tamanho da chave √© 2048 bits, o que j√° √© muito melhor.  O que √© ainda melhor - aqui finalmente conseguimos definir o tamanho da chave para 3 kilobits.  Como se costuma dizer, conquista desbloqueada. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deixe-me lembr√°-lo de que todos os nossos esfor√ßos at√© agora foram reduzidos apenas √† cria√ß√£o do RSA, ainda nem iniciamos a criptografia. Ainda h√° perguntas que precisamos primeiro responder. Para iniciantes, em que medida voc√™ pode confiar nos tamanhos de chave padr√£o? A implementa√ß√£o da f√°brica RSA pode ser substitu√≠da </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, pode mudar sem o seu conhecimento (por exemplo, um administrador do sistema pode alter√°-la). E isso significa que o tamanho da chave padr√£o tamb√©m pode mudar. Portanto, voc√™ nunca deve confiar nos valores fornecidos por padr√£o, o tamanho da chave sempre deve ser definido de forma independente. Em seguida, qu√£o bons s√£o os tamanhos de chave RSA padr√£o? Existem duas implementa√ß√µes de RSA no .NET, uma baseada </font></font><code>RSACryptoServiceProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e outra baseada</font></font><code>RSACng</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No primeiro, o tamanho padr√£o √© 1 kilobits, no segundo. Por divers√£o, vamos comparar esses valores com os da rede Bitcoin (BCN). Pe√ßo desculpas antecipadamente por levantar um t√≥pico delicado, mas n√£o discutiremos Bitcoin ou criptomoeda, apenas falaremos sobre a pr√≥pria rede. Ela tem um hashrate publicado, que cresce todos os meses e hoje √© igual a 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hashes por segundo. Isso equivale a 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hashes por ano. Para simplificar, suponha que um hash seja equivalente a uma opera√ß√£o b√°sica - embora isso n√£o seja totalmente verdade, √© mais complexo. Se voc√™ ler livros sobre criptografia escritos por profissionais reais, e n√£o pessoas como eu, saber√° que 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opera√ß√µes (ou seja, um minuto de BCN) s√£o suficientes para quebrar uma chave RSA de 1 kilobit e 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(um ano BCN) - para quebrar uma chave de 2 kilobit. Ambos os valores devem nos causar ansiedade - √© isso que pode ser alcan√ßado com as tecnologias existentes. √â por isso que eu recomendo fortemente que voc√™ sempre defina o tamanho da chave e aumente pelo menos 3 kilobits, e se o desempenho permitir, ent√£o 4. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No .NET, n√£o √© t√£o f√°cil descobrir como exportar chaves p√∫blicas e privadas. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/836/078/4ea8360788f3ffdbb6a07dfe9c0587e0.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na parte superior do slide, voc√™ v√™ duas inst√¢ncias da chave RSA, a primeira de </font></font><code>RSACryptoServiceProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a segunda de</font></font><code>RSACng</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada 4 kilobits. O c√≥digo abaixo √© usado para extrair as chaves p√∫blica e privada de ambas as inst√¢ncias. Deve-se notar que as duas APIs s√£o bem diferentes uma da outra - c√≥digo diferente, m√©todos diferentes, par√¢metros diferentes. Al√©m disso, se compararmos o tamanho das chaves p√∫blicas da primeira e da segunda c√≥pias, veremos que elas s√£o compar√°veis, aproximadamente meio kilobyte cada. Mas a chave privada para a nova implementa√ß√£o do RSA √© muito menor que a antiga. √â necess√°rio ter isso em mente e observar a uniformidade, para n√£o interferir nessas duas APIs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo o que fizemos com a RSA at√© agora se resumiu a tentar obter uma c√≥pia de trabalho; Agora tente criptografar alguma coisa. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/fb5/c3c/c88fb5c3ca4ee8a62b9b0bd2595291cf.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie uma matriz de bytes, que ser√° nosso texto sem formata√ß√£o (</font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e criptograf√°-lo usando um desses modos de adi√ß√£o que n√£o lan√ßaram uma exce√ß√£o. Mas desta vez temos uma exce√ß√£o. Esta √© uma exce√ß√£o a um par√¢metro inv√°lido; mas de que par√¢metro estamos falando? N√£o fa√ßo ideia - e provavelmente a Microsoft tamb√©m. Se tentarmos executar o mesmo m√©todo com outros modos de suplemento, em cada caso, obteremos a mesma exce√ß√£o. Portanto, o ponto n√£o est√° no modo de suplemento. Portanto, o problema est√° no pr√≥prio c√≥digo-fonte. √â dif√≠cil dizer o que h√° de errado com ele, ent√£o vamos tentar dividir pela metade apenas por precau√ß√£o. Desta vez, a criptografia √© bem-sucedida. Estamos perplexos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Talvez o ponto principal seja que usamos o suplemento SHA-1? O SHA-1, como sabemos, n√£o √© mais uma fun√ß√£o criptograficamente forte; portanto, nossos auditores e o departamento de conformidade insistem em nos livrar dele. Substitua </font></font><code>OaepSHA1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>OaepSHA256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pelo menos, tranquilizar√° os auditores. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/29e/7ed/275/29e7ed275ae1eb8deea59683289b5b6b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas quando tentamos criptografar, obtemos novamente a exce√ß√£o do par√¢metro errado. Toda essa situa√ß√£o √© causada pelo fato de que a restri√ß√£o no tamanho do texto que pode ser transferido para a fun√ß√£o criptogr√°fica depende n√£o apenas do modo de suplemento, mas tamb√©m do tamanho da chave. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos tentar descobrir exatamente como √© essa f√≥rmula m√°gica, que determina a quantidade m√°xima de dados criptografados. Deve estar no m√©todo</font></font><code>int GetMaxDataSizeForEnc(RSAEncryptionPadding pad)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que calcula este volume, tendo recebido o modo de suplemento na entrada. A principal desvantagem desse m√©todo √© que ele n√£o existe, eu o inventei. Estou tentando transmitir a ideia de que mesmo as informa√ß√µes mais b√°sicas que um desenvolvedor precisa para usar o RSA corretamente n√£o est√£o dispon√≠veis para n√≥s. Obrigado Microsoft.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√£o as raz√µes pelas quais o RSA deve ser evitado, mesmo para assinatura. Como espero ter conseguido mostrar, as APIs para RSA no .NET s√£o extremamente insatisfat√≥rias. Voc√™ √© for√ßado a tomar muitas decis√µes em rela√ß√£o ao modo de suplemento, tamanho dos dados e similares, o que √© indesej√°vel. Al√©m disso, para um n√≠vel de seguran√ßa de 128 bits, voc√™ precisar√° de pelo menos uma chave de 4 kilobytes muito volumosa. Ele fornecer√° uma chave privada de kilobyte, uma chave p√∫blica de meio kilobyte e uma assinatura de meio kilobyte. Para muitos cen√°rios, esses valores podem n√£o ser desej√°veis. E se voc√™ tentar alcan√ßar um n√≠vel de seguran√ßa de 256 bits, precisar√° de uma chave enorme - 15360 bits. No RSA, usar essa chave √© quase imposs√≠vel. No meu laptop, uma dessas chaves √© gerada em um minuto e meio.Al√©m disso, o RSA em um n√≠vel fundamental, como algoritmo, implementa muito lentamente uma assinatura, independentemente da implementa√ß√£o. Por que a velocidade da assinatura √© importante para n√≥s? Se voc√™ usar TLS com certificados RSA, a assinatura ser√° feita no servidor. E n√≥s, como desenvolvedores, somos mais afetados exatamente pelo que acontece no servidor, somos respons√°veis ‚Äã‚Äãpor isso, sua taxa de transfer√™ncia √© importante para n√≥s. Em resumo, quero recomendar mais uma vez n√£o usar o RSA.Quero recomendar novamente para n√£o usar o RSA.Quero recomendar novamente para n√£o usar o RSA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse caso, o que pode substituir o RSA? Gostaria de apresentar a voc√™ as primitivas criptogr√°ficas el√≠pticas modernas. Primeiro, lembre-se do ECDSA (Digital Signature Algorithm), que pode ser usado em vez do RSA para assinaturas. Nesta e nas seguintes abrevia√ß√µes, EC √© um prefixo gen√©rico que significa Elliptic-Curve ("el√≠ptico"). Em securitydriven.net/inferno/#DSA Assinaturas, voc√™ pode encontrar um exemplo de c√≥digo ECDSA, que, ali√°s, √© nativo do .NET. Outro algoritmo importante √© o ECIES (Esquema de Criptografia Integrado, ‚Äúesquema de criptografia integrado el√≠ptico‚Äù). Esse algoritmo pode executar criptografia h√≠brida em vez do RSA, ou seja, onde voc√™ gera uma chave sim√©trica, criptografa os dados com ela e, em seguida, criptografa a pr√≥pria chave.O c√≥digo de amostra est√° dispon√≠vel no exemplo securitydriven.net/inferno/#ECIES. Finalmente, outro algoritmo muito importante √© o ECDH (troca de chaves Diffie-Hellman, "troca de chaves Diffie-Hellman"). Permite criar chaves para criptografia sim√©trica entre duas partes com chaves p√∫blicas conhecidas. Em algumas situa√ß√µes e m√©todos de uso, ele permite sigilo direto (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sigilo para a frente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). O link </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">securitydriven.net/inferno/#DHM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chave do c√≥digo dispon√≠vel amostra Exchange.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resumir a conversa sobre criptografia assim√©trica. Voc√™ sempre deve usar APIs de alto n√≠vel que n√£o o for√ßam a tomar decis√µes para as quais voc√™ n√£o est√° pronto. Eu tamb√©m recomendaria parar de usar o RSA. Obviamente, √© mais f√°cil falar do que fazer, pois todos trabalhamos com aplicativos grandes e j√° criados, que podem n√£o ser totalmente reformulados. Nesse caso, pelo menos voc√™ precisa aprender a usar o RSA corretamente. Al√©m disso, aconselho que voc√™ se familiarize com os modernos algoritmos criptogr√°ficos el√≠pticos (ECDSA, ECDH, ECIES). Por fim, √© importante que a criptografia de alto n√≠vel n√£o resolva magicamente todos os problemas; portanto, √© preciso lembrar os objetivos que voc√™ busca. Vou citar StackOverflow, com o qual concordo completamente: ‚ÄúA criptografia sozinha n√£o resolve problemas.A criptografia sim√©trica apenas torna a privacidade de dados um problema de gerenciamento de chaves. ‚Äù</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vou dizer algumas palavras sobre recursos que podem ser √∫teis para voc√™. Existe uma biblioteca </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SecurityDriven.Inferno de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√≠vel superior relativamente aceit√°vel, </font><font style="vertical-align: inherit;">com boa documenta√ß√£o. H√° um livro maravilhoso, Serious Cryptography, de Jean-Philippe Aumasson, Serious Cryptography. Ele fornece uma vis√£o geral do estado atual da criptografia, levando em considera√ß√£o as √∫ltimas inova√ß√µes. Al√©m disso, escrevi o livro j√° mencionado Application Security in .NET, Succinctly, que √© de dom√≠nio p√∫blico. Possui ainda mais informa√ß√µes sobre as armadilhas de seguran√ßa do .NET. Finalmente, o Slideshare tem uma excelente apresenta√ß√£o de Vladimir Kochetkov, que descreve os conceitos b√°sicos da teoria de seguran√ßa de aplicativos de uma maneira um tanto simplista, mas muito s√≥lida, e explica v√°rias fontes de perigos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como conclus√£o, vamos ver alguns exemplos adicionais que eu preparei. No come√ßo, falei sobre o quarto est√°gio da ilumina√ß√£o criptogr√°fica, no qual chega √† conclus√£o de que a melhor solu√ß√£o pode n√£o precisar de criptografia. Vejamos um exemplo dessa solu√ß√£o. Vamos dar uma olhada no mecanismo cl√°ssico do .NET - CSRF (falsifica√ß√£o de solicita√ß√£o entre sites, "falsifica√ß√£o de solicita√ß√£o entre sites"), projetado para proteger contra uma classe de ataques, incluindo falsifica√ß√£o de solicita√ß√£o entre sites. Nesse modelo, temos um agente de usu√°rio - geralmente um navegador. Ele tenta estabelecer uma conex√£o com o servidor enviando uma solicita√ß√£o GET. Em resposta, o servidor envia um token CSRF, oculto no campo "oculto" do HTML. Al√©m disso, o mesmo token √© anexado √† resposta como um cookie, como um cabe√ßalho.O usu√°rio processa algum formul√°rio e executa um POST, que retorna ao servidor com os dois tokens. O servidor verifica, em primeiro lugar, se os dois tokens foram enviados e, em segundo lugar, se eles correspondem. √â essa compara√ß√£o de identidade que permite que o servidor se proteja de um invasor. Esse √© um mecanismo cl√°ssico incorporado ao ASP.NET e ao ASP.NET Core. Mikhail Shcherbakov fez um excelente relat√≥rio no qual o trabalho da CSRF foi investigado em detalhes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema com essa abordagem √© que a gera√ß√£o de token CSRF usa criptografia. A dificuldade √© que a criptografia em si √© uma opera√ß√£o complexa e que consome recursos, carrega o processador, requer mem√≥ria e aumenta o atraso. Tudo isso √© indesej√°vel. Al√©m disso, a inje√ß√£o de um token √© um processo complicado, confuso e inconveniente. Em muitos casos - por exemplo, ao usar chamadas ass√≠ncronas AJAX -, sua implementa√ß√£o √© sua como desenvolvedor. Quem fez isso sabe que essa atividade √© extremamente desagrad√°vel. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a22/806/cae/a22806caea546a62b7a14d2af7583d48.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A mesma prote√ß√£o criptogr√°fica ou compar√°vel pode ser criada sem o uso de criptografia, como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mostrado no slide. Entendo que o texto aqui √© bastante complicado, por isso estou pronto para discuti-lo com mais detalhes na √°rea de discuss√£o. Isso √© tudo para mim, muito obrigado.</font></font><br><br><blockquote>  .       DotNext.      DotNext 2018 Moscow ‚Äî   22-23  2018  - ¬´  ¬ª. <br><br> <b>  </b> .  ,  ,    .          !     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428121/">https://habr.com/ru/post/pt428121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428111/index.html">Aritm√©tica da precis√£o arbitr√°ria em Erlang</a></li>
<li><a href="../pt428113/index.html">Para a quest√£o das curvas de Bezier, velocidade do Arduino e um site interessante, ou como passei o fim de semana</a></li>
<li><a href="../pt428115/index.html">Desenvolvimento web para com√©rcio eletr√¥nico: 5 tend√™ncias tecnol√≥gicas para 2019</a></li>
<li><a href="../pt428117/index.html">Processadores tensores gratuitos do Google na Nuvem Colaborativa</a></li>
<li><a href="../pt428119/index.html">"Classe-campos-proposta" ou "O que deu errado no commit do tc39"</a></li>
<li><a href="../pt428123/index.html">Semana 41 da Seguran√ßa: Boas Novas</a></li>
<li><a href="../pt428125/index.html">Quem s√£o as an√°lises de produtos e por que elas s√£o necess√°rias em uma equipe?</a></li>
<li><a href="../pt428127/index.html">Nginx cache: tudo novo - bem esquecido</a></li>
<li><a href="../pt428129/index.html">L√≥gica fuzzy simples colada ‚Äúdo que era‚Äù para um motor de turbina a g√°s</a></li>
<li><a href="../pt428131/index.html">Toda a verdade sobre o RTOS. Artigo 17. Grupos de Sinalizadores de Eventos: Introdu√ß√£o e Servi√ßos B√°sicos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>