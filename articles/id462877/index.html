<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏻 🔗 🕺 Kunci di PostgreSQL: 1. Kunci Hubungan 💞 👨🏿‍🤝‍👨🏼 👨🏿‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dua seri artikel sebelumnya telah berfokus pada isolasi dan multiversionisme dan penjurnalan . 

 Dalam seri ini kita akan berbicara tentang kunci. Sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kunci di PostgreSQL: 1. Kunci Hubungan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/462877/">  Dua seri artikel sebelumnya telah berfokus pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">isolasi dan multiversionisme</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penjurnalan</a> . <br><br>  Dalam seri ini kita akan berbicara tentang kunci.  Saya akan mematuhi istilah ini, tetapi dalam literatur mungkin ada yang lain: <em>kastil</em> . <br><br>  Siklus akan terdiri dari empat bagian: <br><br><ol><li>  Kunci hubungan (artikel ini); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kunci baris</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kunci benda lain</a> dan kunci predikat; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kunci dalam RAM</a> . </li></ol><br>  Materi semua artikel didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kursus pelatihan</a> administratif yang dilakukan Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">pluzanov</a> dan saya, tetapi jangan mengulanginya kata demi kata dan dimaksudkan untuk membaca dengan penuh pertimbangan dan eksperimen independen. <br><br><img src="https://habrastorage.org/webt/rx/jt/bz/rxjtbz_s6otkhbwcm6agmmtldxe.png"><br><br><h1>  Informasi umum tentang kunci </h1><br>  PostgreSQL menggunakan banyak mekanisme berbeda yang digunakan untuk memblokir sesuatu (atau paling tidak disebut itu).  Oleh karena itu, saya akan mulai dengan kata-kata paling umum tentang mengapa kunci diperlukan sama sekali, apa itu kunci dan bagaimana mereka berbeda satu sama lain.  Kemudian kita akan melihat apa jenis ini ditemukan di PostgreSQL dan hanya setelah itu kita akan mulai menangani berbagai jenis kunci secara detail. <br><a name="habracut"></a><br>  Kunci digunakan untuk merampingkan akses bersamaan ke sumber daya bersama. <br><br>  Akses kompetitif mengacu pada akses simultan dari beberapa proses.  Proses itu sendiri dapat dilakukan secara paralel (jika peralatan memungkinkan) dan secara berurutan dalam mode pembagian waktu - ini tidak penting. <br><br>  Jika tidak ada persaingan, maka tidak perlu kunci (misalnya, cache buffer bersama membutuhkan kunci, tetapi yang lokal tidak). <br><br>  Sebelum mengakses sumber daya, suatu proses harus mendapatkan kunci yang terkait dengan sumber daya itu.  Artinya, kita berbicara tentang disiplin tertentu: semuanya bekerja selama semua proses mematuhi aturan yang ditetapkan untuk mengakses sumber daya bersama.  Jika DBMS mengelola kunci, maka itu sendiri akan memantau pesanan;  jika pemblokiran diatur oleh aplikasi, maka kewajiban ini menjadi tanggung jawabnya. <br><br>  Pada tingkat rendah, kunci diwakili oleh bagian dari memori bersama, di mana ia dicatat dalam beberapa cara apakah kunci bebas atau ditangkap (dan, mungkin, informasi tambahan dicatat: nomor proses, waktu pengambilan, dll). <br><br><blockquote>  Anda mungkin memperhatikan bahwa sepotong memori bersama itu sendiri merupakan sumber daya yang memungkinkan akses kompetitif.  Jika kita turun ke level yang lebih rendah, kita akan melihat bahwa primitif aksesori khusus (seperti semaphore atau mutex) yang disediakan oleh OS digunakan untuk mengatur akses.  Arti mereka adalah bahwa kode yang mengakses sumber daya bersama harus dieksekusi hanya dalam satu proses pada satu waktu.  Pada level terendah, primitif ini diimplementasikan berdasarkan instruksi prosesor atom (seperti test-and-set atau compare-and-swap). <br></blockquote><br>  Setelah sumber daya tidak lagi dibutuhkan oleh proses, ia <em>melepaskan</em> kunci sehingga orang lain dapat menggunakan sumber daya. <br><br>  Tentu saja, mengunci kunci tidak selalu memungkinkan: sumber daya mungkin sudah diambil oleh orang lain.  Kemudian proses masuk ke antrian tunggu (jika mekanisme penguncian memberikan kesempatan ini), atau coba lagi untuk mengambil kunci setelah waktu tertentu.  Dengan satu atau lain cara, ini mengarah pada fakta bahwa proses dipaksa untuk diam dalam mengantisipasi pelepasan sumber daya. <br><br><blockquote>  Terkadang dimungkinkan untuk menerapkan strategi non-blocking lainnya.  Sebagai contoh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mekanisme multi-</a> versi memungkinkan beberapa proses dalam beberapa kasus untuk bekerja secara bersamaan dengan versi data yang berbeda tanpa saling menghalangi. <br></blockquote><br>  Pada prinsipnya, sumber daya yang dilindungi dapat berupa apa saja, jika saja sumber daya ini dapat diidentifikasi dan dicocokkan secara jelas dengan alamat pemblokiran. <br><br>  Sebagai contoh, sumber daya dapat menjadi objek yang bekerja dengan DBMS, seperti halaman data (diidentifikasi oleh nama file dan posisi di dalam file), tabel (oid dalam direktori sistem), baris tabel (halaman dan offset di dalam halaman).  Sumber daya dapat berupa struktur dalam memori, seperti tabel hash, buffer, dll. (Diidentifikasi oleh nomor yang ditentukan sebelumnya).  Kadang-kadang bahkan lebih nyaman untuk menggunakan sumber daya abstrak yang tidak memiliki makna fisik (mereka diidentifikasi hanya dengan angka unik). <br><br>  Efektivitas kunci dipengaruhi oleh banyak faktor, yang mana kami bedakan dua. <br><br><ul><li>  <strong>Granularity</strong> (granularity) penting jika sumber daya membentuk hierarki. <br><br>  Misalnya, tabel terdiri dari halaman yang berisi baris tabel.  Semua objek ini dapat bertindak sebagai sumber daya.  Jika proses biasanya hanya tertarik pada beberapa baris, dan kunci diatur pada tingkat tabel, maka proses lain tidak akan dapat bekerja dengan baris yang berbeda pada saat yang sama.  Oleh karena itu, semakin tinggi granularity, semakin baik untuk kemungkinan paralelisasi. <br><br>  Tetapi ini mengarah pada peningkatan jumlah kunci (informasi tentang yang harus disimpan dalam memori).  Dalam hal ini, <em>peningkatan level</em> (eskalasi) dari kunci dapat diterapkan: ketika jumlah kunci granular tingkat rendah melebihi batas tertentu, mereka diganti dengan satu kunci dari level yang lebih tinggi. <br></li><li>  Kunci dapat ditangkap dalam <strong>mode yang</strong> berbeda. <br><br>  Nama-nama mode dapat benar-benar arbitrer, hanya matriks kompatibilitasnya satu sama lain yang penting.  Mode yang tidak kompatibel dengan mode apa pun (termasuk dengan mode itu sendiri) biasanya disebut <em>eksklusif</em> atau eksklusif.  Jika mode-mode tersebut kompatibel, maka kunci dapat ditangkap oleh beberapa proses secara bersamaan;  mode seperti itu disebut shared.  Secara umum, semakin banyak mode yang kompatibel satu sama lain dapat dibedakan, semakin banyak peluang diciptakan untuk paralelisme. <br></li></ul><br>  Menurut waktu penggunaan, kunci dapat dibagi menjadi panjang dan pendek. <br><br><ul><li>  Kunci <strong>jangka panjang</strong> ditangkap untuk waktu yang berpotensi lama (biasanya sampai akhir transaksi) dan paling sering terkait dengan sumber daya seperti tabel (hubungan) dan baris.  PostgreSQL biasanya mengelola kunci ini secara otomatis, tetapi pengguna tetap memiliki kontrol atas proses ini. <br><br>  Kunci panjang ditandai oleh sejumlah besar mode sehingga sebanyak mungkin tindakan simultan dapat dilakukan pada data.  Biasanya, untuk kunci seperti itu, ada infrastruktur yang dikembangkan (misalnya, dukungan antrian tunggu dan deteksi kebuntuan) dan alat pemantauan, karena biaya pemeliharaan semua fasilitas ini masih jauh lebih rendah dibandingkan dengan biaya operasi pada data yang dilindungi. <br></li><li>  Kunci <strong>jangka pendek</strong> ditangkap untuk waktu singkat (dari beberapa instruksi prosesor hingga sepersekian detik) dan biasanya merujuk pada struktur data dalam memori bersama.  PostgreSQL mengelola kunci semacam itu sepenuhnya secara otomatis - Anda hanya perlu tahu tentang keberadaannya. <br><br>  Kunci pendek ditandai oleh mode minimum (eksklusif dan bersama) dan infrastruktur sederhana.  Dalam beberapa kasus, bahkan alat pemantauan mungkin tidak tersedia. <br></li></ul><br>  PostgreSQL menggunakan berbagai jenis kunci. <br><br>  <strong>Kunci pada level objek</strong> adalah <strong>kunci</strong> "berat" jangka panjang.  Sumber daya di sini adalah hubungan dan objek lainnya.  Jika kata pemblokiran muncul dalam teks tanpa klarifikasi, maka itu menunjukkan pemblokiran "normal". <br><br>  Di antara kunci jangka panjang, kunci <strong>level baris</strong> menonjol secara terpisah.  Implementasinya berbeda dari kunci jangka panjang lainnya karena jumlahnya yang berpotensi besar (bayangkan memperbarui satu juta baris dalam satu transaksi).  Kunci tersebut akan dibahas pada artikel selanjutnya. <br><br>  Artikel ketiga dalam seri ini akan dikhususkan untuk kunci yang tersisa di tingkat objek, serta <strong>kunci predikat</strong> (karena informasi tentang semua kunci ini disimpan dalam RAM dengan cara yang sama). <br><br>  Kunci pendek mencakup berbagai <strong>kunci struktur RAM</strong> .  Kami akan mempertimbangkannya di artikel terakhir siklus ini. <br><br><h1>  Kunci objek </h1><br>  Jadi, kita mulai dengan kunci level objek.  Di sini, suatu objek dipahami pada awalnya sebagai <em>hubungan</em> , yaitu, tabel, indeks, sekuens, representasi terwujud, tetapi juga beberapa entitas lainnya.  Kunci ini biasanya melindungi objek dari perubahan pada saat yang sama atau dari digunakan saat objek berubah, tetapi juga untuk kebutuhan lainnya. <br><br>  Kata-kata buram?  Ya, karena kunci dari grup ini digunakan untuk berbagai keperluan.  Yang menyatukan mereka adalah bagaimana mereka diatur. <br><br><h2>  Perangkat </h2><br>  Kunci objek terletak di memori bersama server.  Jumlah mereka dibatasi oleh produk dari nilai dua parameter: <em>max_locks_per_transaction</em> × <em>max_connections</em> . <br><br>  <em>Kumpulan</em> kunci adalah umum untuk semua transaksi, yaitu, satu transaksi dapat menangkap lebih banyak kunci daripada <em>max_locks_per_transaction</em> : hanya penting bahwa jumlah total kunci dalam sistem tidak melebihi batas yang ditetapkan.  Kolam dibuat saat startup, jadi mengubah salah satu dari dua opsi yang ditunjukkan memerlukan server reboot. <br><br>  Semua kunci dapat dilihat dalam tampilan pg_locks. <br><br>  Jika sumber daya sudah terkunci dalam mode yang tidak kompatibel, transaksi yang mencoba untuk menangkap sumber daya ini antri dan menunggu kunci untuk dirilis.  Transaksi yang tertunda tidak menggunakan sumber daya prosesor: proses layanan yang sesuai “tertidur” dan terbangun oleh sistem operasi ketika sumber daya dirilis. <br><br>  <em>Kebuntuan</em> atau situasi <em>kebuntuan</em> dimungkinkan di mana satu transaksi membutuhkan sumber daya yang ditempati oleh transaksi kedua untuk melanjutkan, dan yang kedua membutuhkan sumber daya yang ditempati oleh yang pertama (dalam kasus umum, kebuntuan dan lebih dari dua transaksi dapat terjadi).  Dalam hal ini, penantian akan berlanjut tanpa batas waktu, sehingga PostgreSQL secara otomatis mendeteksi situasi seperti itu dan membatalkan salah satu transaksi sehingga orang lain dapat terus bekerja.  (Kita akan berbicara lebih banyak tentang kebuntuan di artikel selanjutnya.) <br><br><h2>  Jenis objek </h2><br>  Berikut adalah daftar jenis kunci (atau, jika Anda suka, jenis objek) yang akan kita bahas dalam artikel ini dan selanjutnya.  Nama-nama diberikan sesuai dengan kolom jenis kunci pada tampilan pg_locks. <br><br><ul><li>  <strong>hubungan</strong> <br><br>  Kunci hubungan. <br></li><li>  <strong>transactionid</strong> dan <strong>virtualxid</strong> <br><br>  Memblokir nomor transaksi (nyata atau virtual).  Setiap transaksi itu sendiri memegang kunci eksklusif dari nomornya sendiri, sehingga kunci tersebut nyaman digunakan ketika Anda harus menunggu sampai akhir transaksi lain. <br></li><li>  <strong>tuple</strong> <br><br>  Kunci versi string.  Dalam beberapa kasus digunakan untuk menetapkan prioritas di antara beberapa transaksi yang berharap untuk mengunci baris yang sama. <br></li></ul><br>  Kami akan menunda diskusi tentang jenis-jenis kunci yang tersisa sampai artikel ketiga dalam siklus.  Semuanya ditangkap hanya dalam mode luar biasa, atau eksklusif dan dibagikan. <br><br><ul><li>  <strong>memperpanjang</strong> <br><br>  Digunakan saat menambahkan halaman ke file hubungan apa pun. <br></li><li>  <strong>objek</strong> <br><br>  Mengunci objek yang bukan hubungan (database, skema, langganan, dll.). <br></li><li>  <strong>halaman</strong> <br><br>  Kunci halaman jarang digunakan dan hanya oleh beberapa jenis indeks. <br></li><li>  <strong>penasihat</strong> <br><br>  Pemblokiran yang disarankan, ditetapkan secara manual oleh pengguna. <br></li></ul><br><h1>  Kunci hubungan </h1><br>  Agar tidak kehilangan konteks, saya akan menandai pada gambar seperti itu jenis kunci, yang akan dibahas nanti. <br><br><img src="https://habrastorage.org/webt/od/wc/ne/odwcnenfvjv_ikwmqw8x-vaexqi.png"><br><br><h2>  Mode </h2><br>  Jika bukan yang paling penting, maka pasti yang paling "bercabang" memblokir - memblokir hubungan.  Baginya, sebanyak 8 mode yang berbeda didefinisikan.  Kuantitas seperti itu diperlukan agar jumlah instruksi terbesar yang dimiliki oleh satu tabel dapat dieksekusi secara bersamaan. <br><br>  Tidak masuk akal untuk mempelajari mode-mode ini dengan hati atau mencoba memahami arti nama-nama mereka;  yang terpenting adalah memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">matriks</a> di depan mata Anda pada waktu yang tepat, yang menunjukkan mana yang saling bertentangan.  Untuk kenyamanan, itu direproduksi di sini bersama dengan contoh-contoh perintah yang membutuhkan tingkat penguncian yang sesuai: <br><br><div class="scrollable-table"><table><tbody><tr><th>  mode kunci </th><th>  Sebagai </th><th>  RS </th><th>  RE </th><th>  SUE </th><th>  S </th><th>  SRE </th><th>  E </th><th>  Ae </th><th>  contoh <nobr>perintah SQL</nobr> </th></tr><tr><td>  Akses berbagi </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  PILIH </td></tr><tr><td>  Berbagi baris </td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  PILIH UNTUK PEMBARUAN / SAHAM </td></tr><tr><td>  Baris eksklusif </td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  INSERT, UPDATE, DELETE </td></tr><tr><td>  Bagikan Pembaruan Eksklusif </td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  VACUUM, ALTER TABLE <sup>*</sup> , BUAT INDEKS DENGAN KONCUR </td></tr><tr><td>  Bagikan </td><td></td><td></td><td>  X </td><td>  X </td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  BUAT INDEKS </td></tr><tr><td>  Bagikan Baris Eksklusif </td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  BUAT TRIGGER, ALTER TABEL <sup>*</sup> </td></tr><tr><td>  Eksklusif </td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  REFRESH MAT.  LIHAT SECARA KONSUR </td></tr><tr><td>  Akses eksklusif </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  DROP, TRUNCATE, VACUUM FULL, LOCK TABLE, ALTER TABLE <sup>*</sup> , REFRESH MAT.  LIHAT </td></tr></tbody></table></div><br>  Beberapa komentar: <br><br><ul><li>  4 mode pertama memungkinkan perubahan data secara bersamaan dalam tabel, dan 4 mode selanjutnya tidak. </li><li>  Mode pertama (Access Share) adalah yang terlemah, kompatibel dengan yang lain dari yang terakhir (Access Exclusive).  Mode terakhir ini eksklusif, tidak kompatibel dengan mode apa pun. </li><li>  Perintah ALTER TABLE memiliki banyak opsi, yang berbeda membutuhkan tingkat penguncian yang berbeda.  Oleh karena itu, dalam matriks, perintah ini muncul pada garis yang berbeda dan ditandai dengan tanda bintang. </li></ul><br><h2>  Misalnya, misalnya </h2><br>  berikan contoh.  Apa yang terjadi jika saya menjalankan perintah CREATE INDEX? <br><br>  Kami menemukan dalam dokumentasi bahwa perintah ini mengatur kunci dalam mode Berbagi.  Menurut matriks, kami menentukan bahwa perintah itu kompatibel dengan dirinya sendiri (yaitu, Anda dapat secara bersamaan membuat beberapa indeks) dan dengan membaca perintah.  Dengan demikian, perintah SELECT akan terus bekerja, tetapi perintah UPDATE, DELETE, INSERT akan diblokir. <br><br>  Dan sebaliknya - transaksi tidak lengkap yang mengubah data dalam tabel akan memblokir operasi perintah CREATE INDEX.  Oleh karena itu, ada varian dari perintah - CREATE INDEX CONCURRENTLY.  Ini bekerja lebih lama (dan bahkan mungkin jatuh dengan kesalahan), tetapi memungkinkan untuk perubahan data secara bersamaan. <br><br>  Ini bisa dilihat dalam praktik.  Untuk percobaan, kami akan menggunakan tabel akun "bank" yang familier dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">siklus pertama</a> , di mana kami akan menyimpan nomor dan jumlah akun. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3000.00</span></span>);</code> </pre> <br>  Di sesi kedua, mulai transaksi.  Kami membutuhkan nomor proses layanan. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 4746 | (1 row)</code> </pre><br>  Kunci apa yang dimiliki oleh transaksi yang baru dimulai?  Kami mencari di pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4746</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 5/15 | | ExclusiveLock | t (1 row)</code> </pre><br>  Seperti yang sudah saya katakan, transaksi selalu memegang kunci eksklusif (ExclusiveLock) dari nomornya sendiri, dalam hal ini, yang virtual.  Tidak ada kunci lain pada proses ini. <br><br>  Sekarang perbarui baris tabel.  Bagaimana situasinya akan berubah? <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ---------------+---------------+---------+--------+------------------+--------- relation | accounts_pkey | | | RowExclusiveLock | t relation | accounts | | | RowExclusiveLock | t virtualxid | | 5/15 | | ExclusiveLock | t transactionid | | | 529404 | ExclusiveLock | t (4 rows)</code> </pre><br>  Sekarang ada kunci pada tabel dan indeks yang dapat diubah (dibuat untuk kunci utama), yang digunakan oleh perintah UPDATE.  Kedua kunci diambil dalam mode RowExclusiveLock.  Selain itu, pemblokiran eksklusif nomor transaksi nyata telah ditambahkan (yang muncul segera setelah transaksi mulai mengubah data). <br><br>  Sekarang di sesi lain kami akan mencoba membuat indeks di atas meja. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| pg_backend_pid || ---------------- || 4782 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(acc_no);</code> </pre><br>  Perintah membeku untuk mengantisipasi pelepasan sumber daya.  Kunci apa yang dia coba tangkap?  Periksa: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4782</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 6/15 | | ExclusiveLock | t relation | accounts | | | ShareLock | f (2 rows)</code> </pre><br>  Kami melihat bahwa transaksi sedang mencoba untuk mendapatkan kunci tabel dalam mode ShareLock, tetapi tidak bisa (diberikan = f). <br><br>  Lebih mudah untuk menemukan jumlah proses pemblokiran, dan secara umum beberapa angka, menggunakan fungsi yang muncul di versi 9.6 (sebelum itu saya harus menarik kesimpulan dengan melihat semua isi pg_locks dengan hati-hati): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_blocking_pids ------------------ {4746} (1 row)</code> </pre><br>  Dan kemudian, untuk memahami situasinya, Anda dapat memperoleh informasi tentang sesi-sesi tersebut, yang mencakup angka-angka yang ditemukan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-keyword"><span class="hljs-keyword">ANY</span></span>(pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------------------------------------------------------------ datid | 16386 datname | test pid | 4746 usesysid | 16384 usename | student application_name | psql client_addr | client_hostname | client_port | -1 backend_start | 2019-08-07 15:02:53.811842+03 xact_start | 2019-08-07 15:02:54.090672+03 query_start | 2019-08-07 15:02:54.10621+03 state_change | 2019-08-07 15:02:54.106965+03 wait_event_type | Client wait_event | ClientRead state | idle in transaction backend_xid | 529404 backend_xmin | query | UPDATE accounts SET amount = amount + 100 WHERE acc_no = 1; backend_type | client backend</code> </pre><br>  Setelah transaksi selesai, kunci dilepaskan dan indeks dibuat. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| CREATE INDEX</code> </pre><br><h2>  Dalam antrian! .. </h2><br>  Untuk dapat membayangkan dengan lebih baik bagaimana tampilan kunci yang tidak kompatibel mengarah, kita akan melihat apa yang terjadi jika perintah VACUUM FULL dieksekusi selama operasi sistem. <br><br>  Biarkan perintah SELECT dijalankan terlebih dahulu di tabel kami.  Dia mendapat kunci pada tingkat Access Share yang paling lemah.  Untuk mengontrol waktu rilis kunci, kami menjalankan perintah ini di dalam transaksi - sampai transaksi berakhir, kunci tidak akan dirilis.  Pada kenyataannya, beberapa perintah dapat membaca (dan memodifikasi) tabel, dan beberapa pertanyaan bisa memakan waktu cukup lama. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+--------- 2 | 2000.00 3 | 3000.00 1 | 1100.00 (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+-----------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} (1 row)</code> </pre><br>  Kemudian administrator mengeksekusi perintah VACUUM FULL, yang membutuhkan kunci level Access Exclusive, tidak kompatibel dengan apa pun, bahkan dengan Access Share.  (Perintah LOCK TABLE juga memerlukan kunci yang sama.) Antrian transaksi. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">--  VACUUM FULL</span></span></code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} (2 rows)</code> </pre><br>  Tetapi aplikasi terus mengeluarkan permintaan, dan sekarang perintah SELECT muncul di sistem.  Secara teoritis, dia bisa saja “tergelincir” ketika VACUUM FULL sedang menunggu, tetapi tidak - dia dengan jujur ​​mengambil tempat dalam antrian untuk VACUUM FULL. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} relation | AccessShareLock | f | 4782 | {4746} (3 rows)</code> </pre><br>  Setelah transaksi pertama dengan perintah SELECT menyelesaikan dan melepaskan kunci, perintah VACUUM FULL dimulai (yang kami disimulasikan dengan perintah LOCK TABLE). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br><pre> <code class="plaintext hljs">| LOCK TABLE</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessExclusiveLock | t | 4746 | {} relation | AccessShareLock | f | 4782 | {4746} (2 rows)</code> </pre><br>  Dan hanya setelah VACUUM FULL menyelesaikan pekerjaannya dan menghilangkan kunci, semua perintah yang terakumulasi dalam antrian (PILIH dalam contoh kami) akan dapat menangkap kunci yang sesuai (Access Share) dan mengeksekusi. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| acc_no | amount || --------+--------- || 2 | 2000.00 || 3 | 3000.00 || 1 | 1100.00 || (3 rows)</code> </pre><br>  Dengan demikian, perintah yang tidak akurat dapat melumpuhkan operasi sistem untuk waktu yang secara signifikan lebih lama dari waktu pelaksanaan perintah itu sendiri. <br><br><h1>  Alat pemantauan </h1><br>  Tentu saja, kunci diperlukan untuk operasi yang benar, tetapi dapat menyebabkan harapan yang tidak diinginkan.  Harapan tersebut dapat dipantau untuk memahami penyebabnya dan, jika mungkin, menghilangkannya (misalnya, dengan mengubah algoritma aplikasi). <br><br>  Kami telah berkenalan dengan satu metode: pada saat kunci panjang, kami dapat mengeksekusi permintaan ke tampilan pg_locks, melihat transaksi yang dapat dikunci dan memblokir (fungsi pg_blocking_pids) dan mendekripsi mereka menggunakan pg_stat_activity. <br><br>  Cara lain adalah dengan mengaktifkan parameter <em>log_lock_waits</em> .  Dalam hal ini, informasi akan muncul di log pesan server jika transaksi telah menunggu lebih lama dari <em>deadlock_timeout</em> (terlepas dari kenyataan bahwa parameter untuk deadlock digunakan, kita berbicara tentang harapan normal). <br><br>  Ayo kita coba. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_lock_waits = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Nilai parameter <em>deadlock_timeout</em> default adalah satu detik: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> deadlock_timeout;</code> </pre><pre> <code class="plaintext hljs"> deadlock_timeout ------------------ 1s (1 row)</code> </pre><br>  Mainkan kuncinya. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Perintah UPDATE kedua mengharapkan kunci.  Tunggu sebentar dan selesaikan transaksi pertama. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br>  Sekarang transaksi kedua dapat diselesaikan. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br>  Dan semua informasi penting masuk ke jurnal: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.827 MSK [5898] student@test LOG: process 5898 still waiting for ShareLock on transaction 529427 after 1000.186 ms 2019-08-07 15:26:30.827 MSK [5898] student@test DETAIL: Process holding the lock: 5862. Wait queue: 5898. 2019-08-07 15:26:30.827 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.827 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.836 MSK [5898] student@test LOG: process 5898 acquired ShareLock on transaction 529427 after 1009.536 ms 2019-08-07 15:26:30.836 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.836 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dilanjutkan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462877/">https://habr.com/ru/post/id462877/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462859/index.html">Bagaimana perusahaan bus Eropa beroperasi di Rusia: bagaimana bus dan penumpang berbeda</a></li>
<li><a href="../id462863/index.html">21 Agustus menyiarkan Pertemuan Zabbix Moscow # 5</a></li>
<li><a href="../id462867/index.html">Memilih Skema Warna untuk Aplikasi Anda: Cara Membuatnya Sederhana?</a></li>
<li><a href="../id462869/index.html">Sistem Manajemen Proyek Agilean</a></li>
<li><a href="../id462875/index.html">Cara mengurangi biaya dan memberikan dukungan TI yang optimal untuk model bisnis. Kami mencari “jalan tengah keselamatan”</a></li>
<li><a href="../id462879/index.html">Slurm DevOps: dari Git ke SRE dengan semua berhenti</a></li>
<li><a href="../id462881/index.html">Mengapa begitu sulit untuk memilih film mana yang akan ditonton (dan apa yang bisa dilakukan)</a></li>
<li><a href="../id462883/index.html">Mendesain toko online untuk SEO: (teori + daftar periksa)</a></li>
<li><a href="../id462885/index.html">Jaringan IPoE yang toleran terhadap kesalahan sudah dekat</a></li>
<li><a href="../id462887/index.html">Pengalaman mempersonalisasi toko online menggunakan contoh rekomendasi dinamis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>