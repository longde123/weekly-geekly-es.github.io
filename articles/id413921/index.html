<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏼 🛀🏻 👨🏾‍🤝‍👨🏼 Bagaimana cara menyimpan proyek dari pound ekstra 👩🏾‍🏫 👨🏾‍🤝‍👨🏻 🚔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Nama saya Ilya, saya adalah pengembang iOS di Tinkoff.ru. Pada artikel ini saya ingin berbicara tentang cara mengurangi duplikasi kode ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara menyimpan proyek dari pound ekstra</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/413921/"><img src="https://habrastorage.org/webt/bh/r7/at/bhr7at_omfzwpf1mdp7rcrrb14m.jpeg"><br><br>  Halo semuanya!  Nama saya Ilya, saya adalah pengembang iOS di Tinkoff.ru.  Pada artikel ini saya ingin berbicara tentang cara mengurangi duplikasi kode di lapisan presentasi menggunakan protokol. <br><a name="habracut"></a><br><h3>  Apa masalahnya? </h3><br>  Ketika proyek tumbuh, jumlah duplikasi kode tumbuh.  Ini tidak segera menjadi jelas, dan menjadi sulit untuk memperbaiki kesalahan masa lalu.  Kami memperhatikan masalah ini pada proyek kami dan menyelesaikannya menggunakan satu pendekatan, sebut saja, kondisional, sifat. <br><br><h3>  Contoh hidup </h3><br>  Pendekatan ini dapat digunakan dengan berbagai solusi arsitektur yang berbeda, tetapi saya akan mempertimbangkannya menggunakan VIPER sebagai contoh. <br><br>  Pertimbangkan metode yang paling umum di router - metode yang menutup layar: <br><br><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionHandler.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> <br>  Ini hadir di banyak router, dan lebih baik menulisnya sekali saja. <br><br>  Warisan akan membantu kita dalam hal ini, tetapi di masa depan, ketika kita memiliki semakin banyak kelas dengan metode yang tidak perlu dalam aplikasi kita, atau kita tidak akan dapat membuat kelas yang kita butuhkan karena metode yang diperlukan ada di kelas dasar yang berbeda, yang besar akan muncul masalah. <br>  Akibatnya, proyek ini akan tumbuh menjadi banyak kelas dasar dan kelas turunan dengan metode berlebihan.  Warisan tidak akan membantu kita. <br><br>  Apa yang lebih baik dari warisan?  Tentu komposisi. <br><br>  Anda dapat membuat kelas terpisah untuk metode yang menutup layar dan menambahkannya ke setiap router yang membutuhkannya: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionHandler.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } }</code> </pre><br>  Kita masih harus mendeklarasikan metode ini dalam protokol input router dan mengimplementasikannya di router itu sendiri: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouterInput</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouterInput</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closeRouter = { <span class="hljs-type"><span class="hljs-type">CloseRouter</span></span>(transitionHandler: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>. transitionHandler) }() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.closeRouter.close() } }</code> </pre><br>  Ternyata terlalu banyak kode yang hanya proksi panggilan ke metode tutup.  Pemrogram <s>Malas yang</s> Baik tidak akan menghargai. <br><br><h3>  Solusi Protokol </h3><br>  Protokol datang untuk menyelamatkan.  Ini adalah alat yang cukup kuat yang memungkinkan Anda untuk mengimplementasikan komposisi dan mungkin berisi metode implementasi dalam ekstensi.  Jadi kita bisa membuat protokol yang berisi metode tutup dan mengimplementasikannya dalam ekstensi. <br><br>  Beginilah tampilannya: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionHandler.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } }</code> </pre><br>  Pertanyaannya adalah, mengapa kata sifat muncul dalam nama protokol?  Ini sederhana - Anda dapat menentukan bahwa protokol ini mengimplementasikan metodenya dalam ekstensi dan harus digunakan sebagai campuran ke tipe lain untuk memperluas fungsinya. <br><br>  Sekarang, mari kita lihat bagaimana penggunaan protokol tersebut akan terlihat: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> }</code> </pre><br>  Ya, itu saja.  Tampak hebat :).  Kami mendapat komposisi dengan menambahkan protokol ke kelas router, tidak menulis satu baris tambahan dan mendapat kesempatan untuk menggunakan kembali kode. <br><br><h3>  Apa yang tidak biasa tentang pendekatan ini? </h3><br>  Anda mungkin sudah menanyakan pertanyaan ini.  Menggunakan protokol sebagai suatu sifat cukup umum.  Perbedaan utama adalah menggunakan pendekatan ini sebagai solusi arsitektur dalam lapisan presentasi.  Seperti halnya solusi arsitektur, harus ada aturan dan rekomendasi mereka sendiri. <br><br>  Ini daftar saya: <br><br><ul><li>  Trait seharusnya tidak menyimpan dan mengubah status.  Mereka hanya dapat memiliki dependensi dalam bentuk layanan, dll., Yang merupakan properti get-only. </li><li>  Sifat tidak boleh memiliki metode yang tidak diterapkan dalam ekstensi, karena ini melanggar konsep mereka </li><li>  Nama-nama metode dalam sifat harus secara eksplisit mencerminkan apa yang mereka lakukan, tanpa terikat dengan nama protokol.  Ini akan membantu untuk menghindari tabrakan nama dan membuat kode lebih jelas. </li></ul><br><h3>  Dari VIPER ke MVP </h3><br>  Jika Anda benar-benar beralih menggunakan pendekatan ini dengan protokol, maka kelas router dan interaksor akan terlihat seperti ini: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OtherRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someService: <span class="hljs-type"><span class="hljs-type">SomeServiceInput!</span></span> }</code> </pre><br>  Ini tidak berlaku untuk semua kelas, dalam kebanyakan kasus, proyek hanya akan memiliki router dan interaksor kosong.  Dalam hal ini, Anda dapat mengganggu struktur modul VIPER dan dengan lancar beralih ke MVP dengan menambahkan protokol pengotor ke presenter. <br><br>  Sesuatu seperti ini: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomePresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OtherRouterTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OtherInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someService: <span class="hljs-type"><span class="hljs-type">SomeSericeInput!</span></span> }</code> </pre><br>  Ya, kemampuan untuk mengimplementasikan router dan interaksor sebagai dependensi hilang, tetapi dalam beberapa kasus ini adalah kasusnya. <br><br>  Satu-satunya kelemahan adalah transitionHandler = UIViewController.  Dan menurut aturan VIPER Presenter, tidak ada yang harus diketahui tentang layer View dan bagaimana itu diimplementasikan menggunakan teknologi apa.  Ini diselesaikan dalam kasus ini hanya - metode transisi dari UIViewController "ditutup" oleh protokol, misalnya, TransitionHandler.  Jadi Presenter akan berinteraksi dengan abstraksi. <br><br><h3>  Mengubah perilaku sifat </h3><br>  Mari kita lihat bagaimana Anda dapat mengubah perilaku dalam protokol semacam itu.  Ini akan menjadi analog dari penggantian beberapa bagian modul, misalnya, untuk tes atau rintisan sementara. <br><br>  Sebagai contoh, ambil interaksor sederhana dengan metode yang melakukan permintaan jaringan: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someService: <span class="hljs-type"><span class="hljs-type">SomeServiceInput!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Response)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Response)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { someService.performRequest(completion) } }</code> </pre><br>  Ini adalah kode abstrak, misalnya.  Misalkan kita tidak perlu mengirim permintaan, tetapi hanya perlu mengembalikan semacam rintisan.  Di sini kita pergi ke trik - buat protokol kosong bernama Mock dan lakukan hal berikut: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Response)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { completion(<span class="hljs-type"><span class="hljs-type">MockResponse</span></span>()) } }</code> </pre><br>  Di sini, implementasi metode performRequest telah diubah untuk tipe yang mengimplementasikan protokol Mock.  Sekarang Anda perlu mengimplementasikan protokol Mock untuk kelas yang akan mengimplementasikan SomeInteractor: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomePresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeInteractorTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mock { // Implementation }</span></span></span></span></code> </pre><br>  Untuk kelas SomePresenter, implementasi metode performRequest akan dipanggil, terletak di ekstensi, di mana Self memenuhi protokol Mock.  Ada baiknya menghapus protokol Mock dan implementasi metode performRequest akan diambil dari ekstensi biasa ke SomeInteractor. <br><br>  Jika Anda menggunakan ini hanya untuk pengujian, lebih baik menempatkan semua kode yang terkait dengan substitusi implementasi dalam target pengujian. <br><br><h3>  Untuk meringkas </h3><br>  Sebagai kesimpulan, perlu dicatat pro dan kontra dari pendekatan ini dan dalam kasus mana, menurut pendapat saya, itu layak digunakan. <br><br>  Mari kita mulai dengan kontra: <br><br><ul><li>  Jika Anda menyingkirkan perute dan interaksor, seperti yang ditunjukkan dalam contoh, maka kemampuan untuk mengimplementasikan dependensi ini hilang. </li><li>  Kekurangan lainnya adalah meningkatnya jumlah protokol. </li><li>  Terkadang kode mungkin tidak terlihat sejelas menggunakan pendekatan konvensional. </li></ul><br>  Aspek positif dari pendekatan ini adalah sebagai berikut: <br><br><ul><li>  Yang paling penting dan jelas, duplikasi sangat berkurang. </li><li>  Ikatan statis diterapkan pada metode protokol.  Ini berarti bahwa penentuan implementasi metode akan terjadi pada tahap kompilasi.  Oleh karena itu, selama pelaksanaan program, waktu tambahan tidak akan dihabiskan untuk mencari implementasi (meskipun waktu ini tidak terlalu signifikan). </li><li>  Karena protokolnya adalah "batu bata" kecil, komposisi apa pun dapat dengan mudah dibuat darinya.  Ditambah dalam karma untuk fleksibilitas dalam penggunaan. </li><li>  Kemudahan refactoring, tidak ada komentar di sini. </li><li>  Anda dapat mulai menggunakan pendekatan ini di setiap tahap proyek, karena itu tidak mempengaruhi keseluruhan proyek. </li></ul><br>  Mempertimbangkan keputusan ini baik atau tidak adalah masalah pribadi bagi semua orang.  Pengalaman kami dengan pendekatan ini adalah masalah positif dan terselesaikan. <br><br>  Itu saja! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413921/">https://habr.com/ru/post/id413921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413907/index.html">Intisari materi menarik untuk pengembang seluler # 256 (4 Juni - 12 Juni)</a></li>
<li><a href="../id413909/index.html">Di situlah kenangan masa kecil Anda pergi</a></li>
<li><a href="../id413913/index.html">Berkenalan dengan pameran peralatan audio dan video: secara singkat tentang acara terbesar - bagian satu</a></li>
<li><a href="../id413915/index.html">Menjadikan Tower Defense sebagai Game Persatuan - Bagian 2</a></li>
<li><a href="../id413917/index.html">Pemegang hak cipta percaya bahwa Yandex berkontribusi pada pertumbuhan pembajakan di negara ini</a></li>
<li><a href="../id413923/index.html">Mungkin atmosfer masih bisa dibersihkan dari karbon dioksida</a></li>
<li><a href="../id413925/index.html">CVT untuk Moskvich</a></li>
<li><a href="../id413927/index.html">Digispark di Attiny85 - Menghubungkan di bawah Windows 10</a></li>
<li><a href="../id413929/index.html">Sochi. Camera: fitur untuk membuat proyek secara umum, lengkap, sepenuhnya dari awal, tanpa standar dan contoh sudah diterapkan</a></li>
<li><a href="../id413931/index.html">Linux kernel 4.17 release: apa yang perlu Anda ketahui tentangnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>