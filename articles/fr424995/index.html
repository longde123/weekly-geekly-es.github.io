<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏾 👩🏻‍🤝‍👨🏾 🤜🏿 Un autre système de particules. Post mortem 🧑🏼‍🤝‍🧑🏻 👩🏽‍🤝‍👨🏾 👦🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En septembre de cette année, le jeu mobile Titan World d'Unstoppable, le bureau de Minsk de Glu mobile, devait sortir. Le projet a été annulé juste av...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un autre système de particules. Post mortem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424995/"><img src="https://habrastorage.org/webt/mr/k9/jt/mrk9jtkw0lnm7z8b6gh-hkxmwru.png" alt="image"><br><br>  <b>En septembre de cette année, le jeu mobile Titan World d'Unstoppable, le bureau de Minsk de Glu mobile, devait sortir.</b>  <b>Le projet a été annulé juste avant la sortie mondiale.</b>  <b>Mais les réalisations sont restées, et les plus intéressantes d'entre elles, avec l'aimable autorisation des responsables du studio Dennis Zdonov et Alex Paley, je voudrais partager avec le public.</b> <br><a name="habracut"></a><br>  En mars 2018, le chef d'équipe et moi avons tenu une réunion au cours de laquelle nous avons discuté de la suite des choses: le code de rendu était terminé, et il n'y avait pas de nouvelles fonctionnalités ni d'effets spéciaux dans les plans.  Cela semblait être un choix logique de réécrire le système de particules à partir de zéro - selon tous les tests, il a donné les plus grands baisses de productivité, et il a rendu les concepteurs fous avec son interface (fichier de configuration de texte) et ses capacités extrêmement maigres. <br><br>  Il convient de noter que la plupart du temps, l'équipe a travaillé sur le jeu en mode "version de demain", j'ai donc écrit tous les sous-systèmes, d'une part, en essayant de ne pas casser ce qui fonctionne déjà, et d'autre part, avec un cycle de développement court.  En particulier, la plupart des effets dont le système standard n'était pas capable ont été effectués dans le fragment shader sans affecter le code principal. <br><br>  La restriction sur le nombre de particules (des matrices de transformation pour chaque particule ont été formées sur cpu, la conclusion a été par le biais de l'installateur des ios extensibles par gl), par exemple, il était nécessaire d'écrire un shader qui «émulait» un large éventail de particules basé sur la représentation analytique de la forme des objets et composé avec l'espace retirer les fausses données dans le tampon de profondeur. <br><br>  La coordonnée z du fragment a été calculée pour une particule plane, comme si nous dessinions une sphère, et le rayon de cette sphère a été modulé par le sinus du bruit de Perlin en tenant compte du temps: <br><br><pre><code class="hljs pgsql">r=<span class="hljs-number"><span class="hljs-number">.5</span></span>+<span class="hljs-number"><span class="hljs-number">.5</span></span>*sin(perlin(specialUV)+<span class="hljs-type"><span class="hljs-type">time</span></span>)</code> </pre> <br>  Une description complète de la reconstruction de la profondeur de la sphère peut être trouvée à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Íñigo Quílez</a> , mais j'ai utilisé un code simplifié et plus rapide.  Bien sûr, c'était une approximation approximative, mais sur des formes géométriques complexes (fumée, explosions), il a donné une image assez décente. <br><br><img src="https://habrastorage.org/webt/tt/un/lw/ttunlwe3v4wj0snsxkjt-drx_fi.png" alt="image"><br>  <i>Capture d'écran du gameplay.</i>  <i>La "jupe" de fumée a été faite en une petite partie, plusieurs autres ont été laissées sur le corps principal de l'explosion.</i>  <i>Bien sûr, cela avait l'air le plus spectaculaire «du sol», lorsque la fumée enveloppait doucement les bâtiments et les unités, cependant, les propositions de changement de position de la caméra pendant l'explosion ne sont pas entrées en production.</i> <br><br><h4>  Énoncé du problème </h4><br>  Que vouliez-vous obtenir en sortant?  Nous sommes plutôt sortis des limites avec lesquelles nous étions tourmentés sur l'ancien système de particules.  La situation a été aggravée par le fait que le budget de trame était presque épuisé et que sur les appareils faibles (comme l'ipad air), les pipelines de pixels et de vertex étaient entièrement chargés.  Par conséquent, je voulais obtenir le système le plus productif, même si je limitais un peu les fonctionnalités. <br><br>  Les concepteurs ont compilé une liste de fonctionnalités et dessiné un croquis de l'interface utilisateur basé sur leur propre expérience et pratique avec unité, irréel et séquelle. <br><br><h4>  Technologie disponible </h4><br>  En raison de l'héritage et des restrictions imposées par le siège social, nous étions limités à opengl es 2. Par conséquent, les technologies telles que la rétroaction de transformation utilisées dans les systèmes de particules modernes n'étaient pas disponibles. <br><br>  Que restait-il?  Utiliser l'extraction de texture de sommet et stocker les positions / accélérations dans les textures?  Une option de travail, mais la mémoire est également presque terminée, les performances d'une telle solution ne sont pas les plus optimales et le résultat n'est pas différent en termes de beauté architecturale. <br><br>  À cette époque, j'avais lu de nombreux articles sur la mise en œuvre de systèmes de particules sur gpu.  La grande majorité contenait un titre brillant ("des millions de particules sur le GPU mobile, avec préférence et poétesses"), cependant, la mise en œuvre se résumait à des exemples d'émetteurs / attracteurs simples, mais amusants, et en général était presque inutile pour une utilisation réelle dans le jeu. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cet article a</a> apporté un bénéfice maximal: l'auteur a résolu le vrai problème et n'a pas fait de «particules sphériques dans le vide».  Les chiffres de référence de cet article et les résultats du profilage ont permis de gagner beaucoup de temps au stade de la conception. <br><br><h4>  Recherche d'approches </h4><br>  J'ai commencé par classer les problèmes résolus par le système de particules et à rechercher des cas particuliers.  Il s'est avéré approximativement ce qui suit (un morceau des vrais quais du concept de la correspondance avec le chef d'équipe): <br><blockquote>  «- Tableaux de particules / mailles à mouvement cyclique.  Aucune position de traitement, tout au long de l'équation du mouvement.  Applications - fumée des tuyaux, vapeur sur l'eau, neige / pluie, brouillard volumétrique, balancement des arbres, utilisation partielle sur les effets non cycliques des explosions aka est possible. <br><br>  - Cassettes.  Formation de vb par événement, traitement uniquement sur le GPU (tirs par rayons, vols le long d'une trajectoire fixe (?) Avec trace).  Peut-être que la variante avec le transfert des coordonnées début-fin aux uniformes et la construction de la bande par vertexID va décoller.  avec t.z.  rendre croix avec fresnel comme sur directlights + uvscroll. <br><br>  - Génération de particules et traitement rapide.  L'option la plus polyvalente et la plus difficile / la plus lente, voir le traitement de mouvement technique. » </blockquote><br>  En bref: il existe différents effets de particules, et certains d'entre eux peuvent être mis en œuvre plus facilement que d'autres. <br><br>  Nous avons décidé de diviser la tâche en plusieurs itérations - du plus simple au plus complexe.  Le prototypage a été fait sur mon moteur / éditeur sous windows / directx11 car la vitesse d'un tel développement était supérieure de plusieurs ordres de grandeur.  Le projet a été compilé en quelques secondes, et les shaders ont été complètement modifiés «à la volée» et compilés en arrière-plan, affichant le résultat en temps réel et sans nécessiter de gestes supplémentaires comme appuyer sur des boutons.  Quiconque a construit de grands projets avec un tas de macbook / xcode, je pense, comprendra les raisons de cette décision. <br><br>  Tous les exemples de code seront tirés du prototype Windows. <br><br><img src="https://habrastorage.org/webt/of/p6/pi/ofp6pi_sus1zqlyamxxkb8-zoem.png" alt="image"><br>  <i>Environnement de développement pour Windows.</i> <br><br><h4>  Implémentation </h4><br>  La première étape est la sortie statique d'un réseau de particules.  Rien de compliqué: démarrez le vertex bufffer, remplissez de quads (écrivez le bon uv pour chaque quad) et cousez l'id du vertex dans le uv "supplémentaire".  Après cela, dans le shader, par vertex id basé sur les paramètres de l'émetteur, nous formons les positions des particules, et par uv nous restaurons les coordonnées de l'écran. <br><br>  Si vertex_id est disponible en natif, vous pouvez complètement vous passer du tampon et sans uv pour restaurer les coordonnées de l'écran (comme cela a été fait dans la version Windows). <br><br>  Shader: <br><br><pre> <code class="hljs pgsql">struct VS_INPUT { … uint v_id:SV_VertexID; … } //<span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.uv2.x/<span class="hljs-number"><span class="hljs-number">6.0</span></span>;// vertex_id   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = floor(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>);// vertex_id float2 map[<span class="hljs-number"><span class="hljs-number">6</span></span>]={<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}; float2 quaduv=map[frac(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>)*<span class="hljs-number"><span class="hljs-number">6</span></span>];</code> </pre> <br>  Après cela, vous pouvez implémenter des scénarios simples avec une très petite quantité de code, par exemple, un mouvement cyclique avec de petites déviations convient à l'effet de neige.  Cependant, notre objectif était de donner le contrôle du comportement des particules au côté des artistes, et comme vous le savez, ils savent rarement comment shader.  L'option avec des préréglages de comportement et la modification des paramètres via les curseurs n'a pas non plus séduit - changement de shaders ou ramification à l'intérieur, multiplication des options prédéfinies, manque de contrôle total. <br><br>  La tâche suivante consistait à implémenter un fondu entrant / sortant pour un tel système.  Les particules ne doivent pas apparaître de nulle part et disparaître dans nulle part.  Dans l'implémentation classique d'un système de particules, nous traitons le tampon par programmation en utilisant cpu, en créant de nouvelles particules et en supprimant les anciennes.  En fait, pour obtenir de bonnes performances, vous devez écrire un gestionnaire de mémoire intelligent.  Mais que se passe-t-il si vous ne dessinez simplement pas les particules "mortes"? <br><br>  Supposons (pour commencer) que l'intervalle de temps de l'émission de particules et la durée de vie d'une particule soit une constante au sein d'un même émetteur. <br><br><img src="https://habrastorage.org/webt/96/bp/du/96bpdunpa_v6apnh6gqeoyh-7yq.jpeg" alt="image"><br>  Ensuite, nous pouvons présenter de manière spéculative notre tampon (qui ne contient que le vertex id) comme circulaire et déterminer sa taille maximale comme suit: <br><br><pre> <code class="cpp hljs">pCount = round (prtPerSec * LifeTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCountT = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span> (prtPerSec * EmissionEndTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCount=min (pCount, pCountT);</code> </pre> <br>  et dans le shader, calculer le temps en fonction de l'indice et du temps (temps écoulé depuis le début de l'effet) <br><br><pre> <code class="cpp hljs">pTime=time-index/prtPerSec;</code> </pre> <br>  Si l'émetteur est dans une phase cyclique (toutes les particules sont émises et meurent maintenant et naissent de manière synchrone), nous faisons une fracturation à partir du moment de la particule et obtenons ainsi une boucle. <br><br>  Nous n'avons pas besoin de dessiner des particules avec pTime inférieur à zéro - elles ne sont pas encore nées.  Il en va de même pour les particules dans lesquelles la somme de la durée de vie et du temps actuel dépasse le temps de fin d'émission.  Dans les deux cas, nous ne dessinerons rien en annulant la taille des particules et / ou en la laissant derrière l'écran.  Cette approche donnera une petite surcharge dans les phases de fadein / fadeout, tout en maintenant des performances maximales dans la phase de maintien. <br><br>  L'algorithme peut être légèrement amélioré en envoyant uniquement la partie du tampon de sommet qui contient des particules vivantes pour le rendu.  Du fait que l'émission se produit séquentiellement, les particules vivantes seront segmentées au plus une fois, c'est-à-dire  deux appels sont nécessaires. <br><br>  Maintenant, connaissant l'heure actuelle de chaque particule, vous pouvez définir la vitesse, l'accélération (et, en général, tout autre paramètre) pour écrire l'équation du mouvement, ce qui entraîne les coordonnées dans l'espace mondial. <br><br>  En utilisant restauré à partir de vertex_id uv, nous aurons déjà quatre points (plus précisément, nous déplacerons chacun des points quad dans la direction dont nous avons besoin), sur lesquels le vertex shader, après avoir terminé la projection, achèvera son travail. <br><br><pre> <code class="hljs">p.xy+=(quaduv-.5);</code> </pre><br>  Avec le bonus gratuit, nous avons eu l'occasion non seulement de mettre l'émetteur en pause, mais aussi de rembobiner le temps d'avant en arrière avec précision sur l'image.  Cette fonctionnalité s'est avérée très utile dans la conception d'effets complexes. <br><br><h4>  Nous augmentons la fonctionnalité </h4><br>  L'itération suivante du développement a été la solution au problème d'un émetteur en mouvement.  Notre système particulier ne savait rien de sa position, et lorsque l'émetteur se déplaçait, tout l'effet se déplaçait de manière synchrone derrière lui.  Pour la fumée du tuyau d'échappement et les effets similaires, cela semblait plus qu'étrange. <br><br>  L'idée était d'enregistrer la position de l'émetteur dans un tampon de vertex à la naissance d'une nouvelle particule.  Étant donné que le nombre de ces particules est faible, le surdébit aurait dû être minime. <br><br>  Un collègue a suggéré que lors du développement de sa propre interface utilisateur, il n'utilisait map / unmap qu'une partie du tampon vertex et était très satisfait des performances de cette solution.  J'ai fait des tests, et il s'est avéré que cette approche fonctionne vraiment bien sur les plates-formes de bureau et mobiles. <br><br>  La difficulté est apparue avec la synchronisation de l'heure sur cpu et gpu.  Il était nécessaire de s'assurer que la mise à jour du tampon était effectuée exactement lorsque la «nouvelle» particule bouclée était dans sa position de départ.  Autrement dit, par rapport au tampon en anneau, il est nécessaire de synchroniser les limites de la région de mise à jour avec le temps de fonctionnement de l'émetteur. <br><br>  J'ai transféré le code hlsl en C ++, pour le test j'ai écrit l'émetteur se déplaçant autour de Lissajous, et tout cela a soudainement fonctionné.  Cependant, de temps en temps, le système «crachait» sur une ou plusieurs particules, les tirant dans une direction arbitraire, ne les retirant pas à temps ou n'en créant pas de nouvelles dans des endroits arbitraires. <br><br>  Le problème a été résolu en vérifiant la précision du calcul de l'heure dans le moteur et en vérifiant simultanément le delta de temps lors de l'enregistrement de la nouvelle position de l'émetteur - de sorte que la section tampon entière qui n'était pas affectée par l'itération précédente a été mise à jour.  Il était également nécessaire que le système fonctionne dans les conditions d'une désynchronisation forcée - un retrait soudain de fps ne devrait pas casser l'effet, d'autant plus que pour différents appareils, notre jeu a enregistré des fps différents en fonction de la performance - 60/30/20. <br><br>  Le code de la méthode a beaucoup augmenté (le tampon en anneau est difficile à traiter avec élégance), cependant, après avoir pris en compte toutes les conditions, le système a fonctionné correctement et de manière stable. <br><br>  A cette époque, le partenaire avait déjà fait le «poisson» de l'éditeur, suffisant pour tester le système, et écrit les modèles / api pour intégrer le système dans notre moteur. <br><br>  J'ai porté tout le code sur ios / opengl, intégré et finalement fait de vrais tests d'effets sur un vrai appareil.  Il est devenu clair que le système fonctionne non seulement, mais est également adapté à la production.  Il restait à terminer l'éditeur d'interface utilisateur et à peaufiner le code à l'état «ce n'est pas effrayant de le donner pour le sortir demain». <br><br>  Nous étions déjà prêts à écrire un gestionnaire de mémoire afin de ne pas allouer / détruire un tampon (qui a finalement stocké vertex_id, uv, position et initial particule vector) pour chaque nouvel effet avec un émetteur dynamique, comme une autre idée m'est venue à l'esprit. <br><br>  Le fait de l'existence du vertex buffer dans ce système me hantait.  Il regardait clairement dans son archaïsme "l'héritage des âges sombres du convoyeur fixe".  Lorsque je faisais des effets de test sur un prototype Windows, je pensais que le mouvement de l'émetteur était toujours fluide et toujours beaucoup plus lent que le mouvement des particules.  De plus, avec un grand nombre de particules, la mise à jour de la position conduit au fait que des centaines de particules enregistrent les mêmes données.  La solution s'est avérée simple: nous introduisons un réseau fixe dans lequel «l'historique» de la position de l'émetteur, normalisé par la durée de vie de la particule, va tomber.  Et sur gpu, nous interpolerons les données.  Après cela, le besoin de tampons dynamiques a disparu dans la version ios / gles2 (seule la statique générale restait pour implémenter vertex_id), et dans les versions windows / dx11, les tampons ont complètement disparu en raison du vertex_id natif et de la capacité de l'api d3d à accepter null au lieu de se lier au tampon vertex. <br><br>  Ainsi, la version gagnant du système, selon les normes modernes, ne consomme pas du tout de mémoire, peu importe le nombre de particules que nous voulons afficher.  Seul un petit tampon constant avec paramètres, un tampon de positions / bases (60 paires de vecteurs se sont avérés être suffisants, avec une marge, dans tous les cas), et, si nécessaire, la texture.  Les mesures de performances montrent une vitesse proche des tests synthétiques. <br><br>  De plus, la «queue» d'effets comme des étincelles commençait à paraître beaucoup plus naturelle, puisque l'interpolation permettait de supprimer la discrétisation par images et donc l'émetteur changeait de position en douceur, comme si les appels de dessin étaient effectués à une fréquence de centaines de hertz. <br><br><h4>  CARACTÉRISTIQUES </h4><br>  En plus des fonctionnalités de base du vol des particules (vitesse, accélération, gravité, résistance du milieu), nous avions besoin d’une certaine quantité de «graisse» fonctionnelle. <br>  En conséquence, le flou de mouvement (étirement d'une particule le long d'un vecteur de mouvement), l'orientation des particules à travers le vecteur de mouvement (cela permet, par exemple, de créer une sphère de particules), le redimensionnement de la particule en fonction de l'heure actuelle de sa vie, et des dizaines d'autres petites choses ont été mises en œuvre. <br><br>  La complexité est apparue avec les champs vectoriels: le système ne stockant pas son état (position, accélération, etc.) pour chaque particule, mais les calculant à chaque fois par le biais de l'équation du mouvement, un certain nombre d'effets (comme le mouvement de la mousse lors de l'agitation du café) étaient en principe impossibles.  Cependant, une simple modulation de la vitesse et de l'accélération par le bruit du perlin a donné des résultats assez modernes.  Le calcul du bruit en temps réel pour tant de particules s'est révélé trop cher (même avec une limite de cinq octaves), donc une texture a été générée à partir de laquelle le vertex shader échantillonnerait.  Pour améliorer l'effet d'un faux champ vectoriel, un petit décalage des coordonnées de l'échantillon a été ajouté en fonction de l'heure actuelle de l'émetteur. <br><br><img src="https://habrastorage.org/webt/sq/vu/xs/sqvuxsyjwxocojucmja_ynqtnjc.png" alt="image"><br>  <i>Le test de fumée de cigarette fonctionne en répartissant la vitesse et l'accélération initiales sur le bruit perlin.</i> <br><br><h4>  Convoyeur de pixels </h4><br>  Initialement, nous avions seulement prévu de changer la couleur / transparence de la particule en fonction de son temps.  J'ai ajouté plusieurs algorithmes au pixel shader. <br><br>  Rotation des couleurs de la texture - simplifiée, sin (couleur + temps).  Permet dans une certaine mesure d'imiter l'effet de permutation d'AfterEffects. <br><br>  Faux éclairage - modulation de la couleur d'une particule par un gradient en coordonnées universelles, quel que soit l'angle de rotation de la particule. <br><br>  Évolution des frontières - lorsqu'une particule se déplace dans l'espace, ses frontières (canal alpha) sont modulées par une combinaison de projecteurs et de bruit perlin, ce qui donne leur dynamique d'écoulement, très similaire aux nuages, à la fumée et à d'autres effets de fluide. <br><br>  Pseudo-code du shader: <br><br><pre> <code class="hljs lisp">b=perlin(<span class="hljs-name"><span class="hljs-name">uv</span></span>)<span class="hljs-comment"><span class="hljs-comment">;// , uv      a=saturate(1-length(input.uv.xy-.5)*2);//     a-=abs(ab);//””,  </span></span></code> </pre> <br>  Dans une version légèrement compliquée, ce shader pouvait tracer des frontières avec une douceur arbitraire et un éclairage de contour, ce qui ajoutait des effets «explosifs» au réalisme. <br><br><img src="https://habrastorage.org/webt/fz/sp/lf/fzsplfbanmnupkdppk2gqj3mlcy.png" alt="image"><br>  <i>Les premières expériences avec l'évolution des frontières.</i> <br><br><h4>  Et ensuite? </h4><br>  Malgré l'éditeur, déjà prêt à travailler et intégré dans le moteur, les concepteurs n'ont pas eu le temps d'y faire un seul effet - le projet était clos.  Néanmoins, il n'y a aucun obstacle à l'utilisation de ces pratiques ailleurs - par exemple, pour effectuer un travail sur la version de démonstration. <br><br>  D'un point de vue technologique, il y a aussi de la place pour bouger - maintenant, par exemple, plusieurs effets de destruction d'objets filaires sont en action: <br><br><img src="https://habrastorage.org/webt/g7/-0/ab/g7-0abs_dlath0s8dxewlrgs1ju.png" alt="image"><br><br>  La question du tri des particules pour le mélange alpha reste ouverte jusqu'à présent: puisque tout est considéré analytiquement dans le shader, il n'y a en fait aucune donnée d'entrée pour le tri.  Mais il y a un large champ d'expérimentation! <br><br>  Pendant le développement de Titan World, de nombreuses astuces ont été appliquées dans la partie graphique du jeu, mais plus à ce sujet la prochaine fois. <br><br>  PS Vous pouvez creuser dans le moteur alpha source <a href="">ici</a> .  Les exemples sont dans le dossier release / samples, les touches de contrôle principales sont l'espace, alt | control + mouse.  Les shaders se trouvent directement dans les fichiers fxp, leur code est disponible via la fenêtre de l'éditeur. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424995/">https://habr.com/ru/post/fr424995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424985/index.html">Dans un précédent judiciaire important, les agences de renseignement américaines n'ont pas été en mesure d'écouter des appels dans le messager</a></li>
<li><a href="../fr424987/index.html">Récupérez des images floues et défocalisées à l'aide du filtre Wiener. Implémentation en C ++ OpenCV</a></li>
<li><a href="../fr424989/index.html">Processus de conception: 7 étapes pour un projet parfait</a></li>
<li><a href="../fr424991/index.html">Quand les anciennes méthodes ne fonctionnent pas: Vasily Mazin - sur une approche hybride du développement de l'IA</a></li>
<li><a href="../fr424993/index.html">Pratiques de commercialisation des produits à la conférence Epic Growth</a></li>
<li><a href="../fr424997/index.html">«L'application iOS VKontakte a un seuil d'entrée élevé»: entretien avec Alexei Savin</a></li>
<li><a href="../fr425001/index.html">Validation des paramètres génériques dans les contrôleurs Spring</a></li>
<li><a href="../fr425003/index.html">Comparez les achats de matériel TCO et les locations de cloud</a></li>
<li><a href="../fr425005/index.html">Rust News # 1 (septembre 2018)</a></li>
<li><a href="../fr425007/index.html">Iridium et Jeff Bezos AWS se sont associés pour développer un projet mondial d'Internet par satellite pour l'IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>