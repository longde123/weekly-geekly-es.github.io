<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèæ üë©üèª‚Äçü§ù‚Äçüë®üèæ ü§úüèø Un autre syst√®me de particules. Post mortem üßëüèº‚Äçü§ù‚Äçüßëüèª üë©üèΩ‚Äçü§ù‚Äçüë®üèæ üë¶üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En septembre de cette ann√©e, le jeu mobile Titan World d'Unstoppable, le bureau de Minsk de Glu mobile, devait sortir. Le projet a √©t√© annul√© juste av...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un autre syst√®me de particules. Post mortem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424995/"><img src="https://habrastorage.org/webt/mr/k9/jt/mrk9jtkw0lnm7z8b6gh-hkxmwru.png" alt="image"><br><br>  <b>En septembre de cette ann√©e, le jeu mobile Titan World d'Unstoppable, le bureau de Minsk de Glu mobile, devait sortir.</b>  <b>Le projet a √©t√© annul√© juste avant la sortie mondiale.</b>  <b>Mais les r√©alisations sont rest√©es, et les plus int√©ressantes d'entre elles, avec l'aimable autorisation des responsables du studio Dennis Zdonov et Alex Paley, je voudrais partager avec le public.</b> <br><a name="habracut"></a><br>  En mars 2018, le chef d'√©quipe et moi avons tenu une r√©union au cours de laquelle nous avons discut√© de la suite des choses: le code de rendu √©tait termin√©, et il n'y avait pas de nouvelles fonctionnalit√©s ni d'effets sp√©ciaux dans les plans.  Cela semblait √™tre un choix logique de r√©√©crire le syst√®me de particules √† partir de z√©ro - selon tous les tests, il a donn√© les plus grands baisses de productivit√©, et il a rendu les concepteurs fous avec son interface (fichier de configuration de texte) et ses capacit√©s extr√™mement maigres. <br><br>  Il convient de noter que la plupart du temps, l'√©quipe a travaill√© sur le jeu en mode "version de demain", j'ai donc √©crit tous les sous-syst√®mes, d'une part, en essayant de ne pas casser ce qui fonctionne d√©j√†, et d'autre part, avec un cycle de d√©veloppement court.  En particulier, la plupart des effets dont le syst√®me standard n'√©tait pas capable ont √©t√© effectu√©s dans le fragment shader sans affecter le code principal. <br><br>  La restriction sur le nombre de particules (des matrices de transformation pour chaque particule ont √©t√© form√©es sur cpu, la conclusion a √©t√© par le biais de l'installateur des ios extensibles par gl), par exemple, il √©tait n√©cessaire d'√©crire un shader qui ¬´√©mulait¬ª un large √©ventail de particules bas√© sur la repr√©sentation analytique de la forme des objets et compos√© avec l'espace retirer les fausses donn√©es dans le tampon de profondeur. <br><br>  La coordonn√©e z du fragment a √©t√© calcul√©e pour une particule plane, comme si nous dessinions une sph√®re, et le rayon de cette sph√®re a √©t√© modul√© par le sinus du bruit de Perlin en tenant compte du temps: <br><br><pre><code class="hljs pgsql">r=<span class="hljs-number"><span class="hljs-number">.5</span></span>+<span class="hljs-number"><span class="hljs-number">.5</span></span>*sin(perlin(specialUV)+<span class="hljs-type"><span class="hljs-type">time</span></span>)</code> </pre> <br>  Une description compl√®te de la reconstruction de la profondeur de la sph√®re peut √™tre trouv√©e √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√ç√±igo Qu√≠lez</a> , mais j'ai utilis√© un code simplifi√© et plus rapide.  Bien s√ªr, c'√©tait une approximation approximative, mais sur des formes g√©om√©triques complexes (fum√©e, explosions), il a donn√© une image assez d√©cente. <br><br><img src="https://habrastorage.org/webt/tt/un/lw/ttunlwe3v4wj0snsxkjt-drx_fi.png" alt="image"><br>  <i>Capture d'√©cran du gameplay.</i>  <i>La "jupe" de fum√©e a √©t√© faite en une petite partie, plusieurs autres ont √©t√© laiss√©es sur le corps principal de l'explosion.</i>  <i>Bien s√ªr, cela avait l'air le plus spectaculaire ¬´du sol¬ª, lorsque la fum√©e enveloppait doucement les b√¢timents et les unit√©s, cependant, les propositions de changement de position de la cam√©ra pendant l'explosion ne sont pas entr√©es en production.</i> <br><br><h4>  √ânonc√© du probl√®me </h4><br>  Que vouliez-vous obtenir en sortant?  Nous sommes plut√¥t sortis des limites avec lesquelles nous √©tions tourment√©s sur l'ancien syst√®me de particules.  La situation a √©t√© aggrav√©e par le fait que le budget de trame √©tait presque √©puis√© et que sur les appareils faibles (comme l'ipad air), les pipelines de pixels et de vertex √©taient enti√®rement charg√©s.  Par cons√©quent, je voulais obtenir le syst√®me le plus productif, m√™me si je limitais un peu les fonctionnalit√©s. <br><br>  Les concepteurs ont compil√© une liste de fonctionnalit√©s et dessin√© un croquis de l'interface utilisateur bas√© sur leur propre exp√©rience et pratique avec unit√©, irr√©el et s√©quelle. <br><br><h4>  Technologie disponible </h4><br>  En raison de l'h√©ritage et des restrictions impos√©es par le si√®ge social, nous √©tions limit√©s √† opengl es 2. Par cons√©quent, les technologies telles que la r√©troaction de transformation utilis√©es dans les syst√®mes de particules modernes n'√©taient pas disponibles. <br><br>  Que restait-il?  Utiliser l'extraction de texture de sommet et stocker les positions / acc√©l√©rations dans les textures?  Une option de travail, mais la m√©moire est √©galement presque termin√©e, les performances d'une telle solution ne sont pas les plus optimales et le r√©sultat n'est pas diff√©rent en termes de beaut√© architecturale. <br><br>  √Ä cette √©poque, j'avais lu de nombreux articles sur la mise en ≈ìuvre de syst√®mes de particules sur gpu.  La grande majorit√© contenait un titre brillant ("des millions de particules sur le GPU mobile, avec pr√©f√©rence et po√©tesses"), cependant, la mise en ≈ìuvre se r√©sumait √† des exemples d'√©metteurs / attracteurs simples, mais amusants, et en g√©n√©ral √©tait presque inutile pour une utilisation r√©elle dans le jeu. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cet article a</a> apport√© un b√©n√©fice maximal: l'auteur a r√©solu le vrai probl√®me et n'a pas fait de ¬´particules sph√©riques dans le vide¬ª.  Les chiffres de r√©f√©rence de cet article et les r√©sultats du profilage ont permis de gagner beaucoup de temps au stade de la conception. <br><br><h4>  Recherche d'approches </h4><br>  J'ai commenc√© par classer les probl√®mes r√©solus par le syst√®me de particules et √† rechercher des cas particuliers.  Il s'est av√©r√© approximativement ce qui suit (un morceau des vrais quais du concept de la correspondance avec le chef d'√©quipe): <br><blockquote>  ¬´- Tableaux de particules / mailles √† mouvement cyclique.  Aucune position de traitement, tout au long de l'√©quation du mouvement.  Applications - fum√©e des tuyaux, vapeur sur l'eau, neige / pluie, brouillard volum√©trique, balancement des arbres, utilisation partielle sur les effets non cycliques des explosions aka est possible. <br><br>  - Cassettes.  Formation de vb par √©v√©nement, traitement uniquement sur le GPU (tirs par rayons, vols le long d'une trajectoire fixe (?) Avec trace).  Peut-√™tre que la variante avec le transfert des coordonn√©es d√©but-fin aux uniformes et la construction de la bande par vertexID va d√©coller.  avec t.z.  rendre croix avec fresnel comme sur directlights + uvscroll. <br><br>  - G√©n√©ration de particules et traitement rapide.  L'option la plus polyvalente et la plus difficile / la plus lente, voir le traitement de mouvement technique. ¬ª </blockquote><br>  En bref: il existe diff√©rents effets de particules, et certains d'entre eux peuvent √™tre mis en ≈ìuvre plus facilement que d'autres. <br><br>  Nous avons d√©cid√© de diviser la t√¢che en plusieurs it√©rations - du plus simple au plus complexe.  Le prototypage a √©t√© fait sur mon moteur / √©diteur sous windows / directx11 car la vitesse d'un tel d√©veloppement √©tait sup√©rieure de plusieurs ordres de grandeur.  Le projet a √©t√© compil√© en quelques secondes, et les shaders ont √©t√© compl√®tement modifi√©s ¬´√† la vol√©e¬ª et compil√©s en arri√®re-plan, affichant le r√©sultat en temps r√©el et sans n√©cessiter de gestes suppl√©mentaires comme appuyer sur des boutons.  Quiconque a construit de grands projets avec un tas de macbook / xcode, je pense, comprendra les raisons de cette d√©cision. <br><br>  Tous les exemples de code seront tir√©s du prototype Windows. <br><br><img src="https://habrastorage.org/webt/of/p6/pi/ofp6pi_sus1zqlyamxxkb8-zoem.png" alt="image"><br>  <i>Environnement de d√©veloppement pour Windows.</i> <br><br><h4>  Impl√©mentation </h4><br>  La premi√®re √©tape est la sortie statique d'un r√©seau de particules.  Rien de compliqu√©: d√©marrez le vertex bufffer, remplissez de quads (√©crivez le bon uv pour chaque quad) et cousez l'id du vertex dans le uv "suppl√©mentaire".  Apr√®s cela, dans le shader, par vertex id bas√© sur les param√®tres de l'√©metteur, nous formons les positions des particules, et par uv nous restaurons les coordonn√©es de l'√©cran. <br><br>  Si vertex_id est disponible en natif, vous pouvez compl√®tement vous passer du tampon et sans uv pour restaurer les coordonn√©es de l'√©cran (comme cela a √©t√© fait dans la version Windows). <br><br>  Shader: <br><br><pre> <code class="hljs pgsql">struct VS_INPUT { ‚Ä¶ uint v_id:SV_VertexID; ‚Ä¶ } //<span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.uv2.x/<span class="hljs-number"><span class="hljs-number">6.0</span></span>;// vertex_id   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = floor(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>);// vertex_id float2 map[<span class="hljs-number"><span class="hljs-number">6</span></span>]={<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}; float2 quaduv=map[frac(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>)*<span class="hljs-number"><span class="hljs-number">6</span></span>];</code> </pre> <br>  Apr√®s cela, vous pouvez impl√©menter des sc√©narios simples avec une tr√®s petite quantit√© de code, par exemple, un mouvement cyclique avec de petites d√©viations convient √† l'effet de neige.  Cependant, notre objectif √©tait de donner le contr√¥le du comportement des particules au c√¥t√© des artistes, et comme vous le savez, ils savent rarement comment shader.  L'option avec des pr√©r√©glages de comportement et la modification des param√®tres via les curseurs n'a pas non plus s√©duit - changement de shaders ou ramification √† l'int√©rieur, multiplication des options pr√©d√©finies, manque de contr√¥le total. <br><br>  La t√¢che suivante consistait √† impl√©menter un fondu entrant / sortant pour un tel syst√®me.  Les particules ne doivent pas appara√Ætre de nulle part et dispara√Ætre dans nulle part.  Dans l'impl√©mentation classique d'un syst√®me de particules, nous traitons le tampon par programmation en utilisant cpu, en cr√©ant de nouvelles particules et en supprimant les anciennes.  En fait, pour obtenir de bonnes performances, vous devez √©crire un gestionnaire de m√©moire intelligent.  Mais que se passe-t-il si vous ne dessinez simplement pas les particules "mortes"? <br><br>  Supposons (pour commencer) que l'intervalle de temps de l'√©mission de particules et la dur√©e de vie d'une particule soit une constante au sein d'un m√™me √©metteur. <br><br><img src="https://habrastorage.org/webt/96/bp/du/96bpdunpa_v6apnh6gqeoyh-7yq.jpeg" alt="image"><br>  Ensuite, nous pouvons pr√©senter de mani√®re sp√©culative notre tampon (qui ne contient que le vertex id) comme circulaire et d√©terminer sa taille maximale comme suit: <br><br><pre> <code class="cpp hljs">pCount = round (prtPerSec * LifeTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCountT = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span> (prtPerSec * EmissionEndTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCount=min (pCount, pCountT);</code> </pre> <br>  et dans le shader, calculer le temps en fonction de l'indice et du temps (temps √©coul√© depuis le d√©but de l'effet) <br><br><pre> <code class="cpp hljs">pTime=time-index/prtPerSec;</code> </pre> <br>  Si l'√©metteur est dans une phase cyclique (toutes les particules sont √©mises et meurent maintenant et naissent de mani√®re synchrone), nous faisons une fracturation √† partir du moment de la particule et obtenons ainsi une boucle. <br><br>  Nous n'avons pas besoin de dessiner des particules avec pTime inf√©rieur √† z√©ro - elles ne sont pas encore n√©es.  Il en va de m√™me pour les particules dans lesquelles la somme de la dur√©e de vie et du temps actuel d√©passe le temps de fin d'√©mission.  Dans les deux cas, nous ne dessinerons rien en annulant la taille des particules et / ou en la laissant derri√®re l'√©cran.  Cette approche donnera une petite surcharge dans les phases de fadein / fadeout, tout en maintenant des performances maximales dans la phase de maintien. <br><br>  L'algorithme peut √™tre l√©g√®rement am√©lior√© en envoyant uniquement la partie du tampon de sommet qui contient des particules vivantes pour le rendu.  Du fait que l'√©mission se produit s√©quentiellement, les particules vivantes seront segment√©es au plus une fois, c'est-√†-dire  deux appels sont n√©cessaires. <br><br>  Maintenant, connaissant l'heure actuelle de chaque particule, vous pouvez d√©finir la vitesse, l'acc√©l√©ration (et, en g√©n√©ral, tout autre param√®tre) pour √©crire l'√©quation du mouvement, ce qui entra√Æne les coordonn√©es dans l'espace mondial. <br><br>  En utilisant restaur√© √† partir de vertex_id uv, nous aurons d√©j√† quatre points (plus pr√©cis√©ment, nous d√©placerons chacun des points quad dans la direction dont nous avons besoin), sur lesquels le vertex shader, apr√®s avoir termin√© la projection, ach√®vera son travail. <br><br><pre> <code class="hljs">p.xy+=(quaduv-.5);</code> </pre><br>  Avec le bonus gratuit, nous avons eu l'occasion non seulement de mettre l'√©metteur en pause, mais aussi de rembobiner le temps d'avant en arri√®re avec pr√©cision sur l'image.  Cette fonctionnalit√© s'est av√©r√©e tr√®s utile dans la conception d'effets complexes. <br><br><h4>  Nous augmentons la fonctionnalit√© </h4><br>  L'it√©ration suivante du d√©veloppement a √©t√© la solution au probl√®me d'un √©metteur en mouvement.  Notre syst√®me particulier ne savait rien de sa position, et lorsque l'√©metteur se d√©pla√ßait, tout l'effet se d√©pla√ßait de mani√®re synchrone derri√®re lui.  Pour la fum√©e du tuyau d'√©chappement et les effets similaires, cela semblait plus qu'√©trange. <br><br>  L'id√©e √©tait d'enregistrer la position de l'√©metteur dans un tampon de vertex √† la naissance d'une nouvelle particule.  √âtant donn√© que le nombre de ces particules est faible, le surd√©bit aurait d√ª √™tre minime. <br><br>  Un coll√®gue a sugg√©r√© que lors du d√©veloppement de sa propre interface utilisateur, il n'utilisait map / unmap qu'une partie du tampon vertex et √©tait tr√®s satisfait des performances de cette solution.  J'ai fait des tests, et il s'est av√©r√© que cette approche fonctionne vraiment bien sur les plates-formes de bureau et mobiles. <br><br>  La difficult√© est apparue avec la synchronisation de l'heure sur cpu et gpu.  Il √©tait n√©cessaire de s'assurer que la mise √† jour du tampon √©tait effectu√©e exactement lorsque la ¬´nouvelle¬ª particule boucl√©e √©tait dans sa position de d√©part.  Autrement dit, par rapport au tampon en anneau, il est n√©cessaire de synchroniser les limites de la r√©gion de mise √† jour avec le temps de fonctionnement de l'√©metteur. <br><br>  J'ai transf√©r√© le code hlsl en C ++, pour le test j'ai √©crit l'√©metteur se d√©pla√ßant autour de Lissajous, et tout cela a soudainement fonctionn√©.  Cependant, de temps en temps, le syst√®me ¬´crachait¬ª sur une ou plusieurs particules, les tirant dans une direction arbitraire, ne les retirant pas √† temps ou n'en cr√©ant pas de nouvelles dans des endroits arbitraires. <br><br>  Le probl√®me a √©t√© r√©solu en v√©rifiant la pr√©cision du calcul de l'heure dans le moteur et en v√©rifiant simultan√©ment le delta de temps lors de l'enregistrement de la nouvelle position de l'√©metteur - de sorte que la section tampon enti√®re qui n'√©tait pas affect√©e par l'it√©ration pr√©c√©dente a √©t√© mise √† jour.  Il √©tait √©galement n√©cessaire que le syst√®me fonctionne dans les conditions d'une d√©synchronisation forc√©e - un retrait soudain de fps ne devrait pas casser l'effet, d'autant plus que pour diff√©rents appareils, notre jeu a enregistr√© des fps diff√©rents en fonction de la performance - 60/30/20. <br><br>  Le code de la m√©thode a beaucoup augment√© (le tampon en anneau est difficile √† traiter avec √©l√©gance), cependant, apr√®s avoir pris en compte toutes les conditions, le syst√®me a fonctionn√© correctement et de mani√®re stable. <br><br>  A cette √©poque, le partenaire avait d√©j√† fait le ¬´poisson¬ª de l'√©diteur, suffisant pour tester le syst√®me, et √©crit les mod√®les / api pour int√©grer le syst√®me dans notre moteur. <br><br>  J'ai port√© tout le code sur ios / opengl, int√©gr√© et finalement fait de vrais tests d'effets sur un vrai appareil.  Il est devenu clair que le syst√®me fonctionne non seulement, mais est √©galement adapt√© √† la production.  Il restait √† terminer l'√©diteur d'interface utilisateur et √† peaufiner le code √† l'√©tat ¬´ce n'est pas effrayant de le donner pour le sortir demain¬ª. <br><br>  Nous √©tions d√©j√† pr√™ts √† √©crire un gestionnaire de m√©moire afin de ne pas allouer / d√©truire un tampon (qui a finalement stock√© vertex_id, uv, position et initial particule vector) pour chaque nouvel effet avec un √©metteur dynamique, comme une autre id√©e m'est venue √† l'esprit. <br><br>  Le fait de l'existence du vertex buffer dans ce syst√®me me hantait.  Il regardait clairement dans son archa√Øsme "l'h√©ritage des √¢ges sombres du convoyeur fixe".  Lorsque je faisais des effets de test sur un prototype Windows, je pensais que le mouvement de l'√©metteur √©tait toujours fluide et toujours beaucoup plus lent que le mouvement des particules.  De plus, avec un grand nombre de particules, la mise √† jour de la position conduit au fait que des centaines de particules enregistrent les m√™mes donn√©es.  La solution s'est av√©r√©e simple: nous introduisons un r√©seau fixe dans lequel ¬´l'historique¬ª de la position de l'√©metteur, normalis√© par la dur√©e de vie de la particule, va tomber.  Et sur gpu, nous interpolerons les donn√©es.  Apr√®s cela, le besoin de tampons dynamiques a disparu dans la version ios / gles2 (seule la statique g√©n√©rale restait pour impl√©menter vertex_id), et dans les versions windows / dx11, les tampons ont compl√®tement disparu en raison du vertex_id natif et de la capacit√© de l'api d3d √† accepter null au lieu de se lier au tampon vertex. <br><br>  Ainsi, la version gagnant du syst√®me, selon les normes modernes, ne consomme pas du tout de m√©moire, peu importe le nombre de particules que nous voulons afficher.  Seul un petit tampon constant avec param√®tres, un tampon de positions / bases (60 paires de vecteurs se sont av√©r√©s √™tre suffisants, avec une marge, dans tous les cas), et, si n√©cessaire, la texture.  Les mesures de performances montrent une vitesse proche des tests synth√©tiques. <br><br>  De plus, la ¬´queue¬ª d'effets comme des √©tincelles commen√ßait √† para√Ætre beaucoup plus naturelle, puisque l'interpolation permettait de supprimer la discr√©tisation par images et donc l'√©metteur changeait de position en douceur, comme si les appels de dessin √©taient effectu√©s √† une fr√©quence de centaines de hertz. <br><br><h4>  CARACT√âRISTIQUES </h4><br>  En plus des fonctionnalit√©s de base du vol des particules (vitesse, acc√©l√©ration, gravit√©, r√©sistance du milieu), nous avions besoin d‚Äôune certaine quantit√© de ¬´graisse¬ª fonctionnelle. <br>  En cons√©quence, le flou de mouvement (√©tirement d'une particule le long d'un vecteur de mouvement), l'orientation des particules √† travers le vecteur de mouvement (cela permet, par exemple, de cr√©er une sph√®re de particules), le redimensionnement de la particule en fonction de l'heure actuelle de sa vie, et des dizaines d'autres petites choses ont √©t√© mises en ≈ìuvre. <br><br>  La complexit√© est apparue avec les champs vectoriels: le syst√®me ne stockant pas son √©tat (position, acc√©l√©ration, etc.) pour chaque particule, mais les calculant √† chaque fois par le biais de l'√©quation du mouvement, un certain nombre d'effets (comme le mouvement de la mousse lors de l'agitation du caf√©) √©taient en principe impossibles.  Cependant, une simple modulation de la vitesse et de l'acc√©l√©ration par le bruit du perlin a donn√© des r√©sultats assez modernes.  Le calcul du bruit en temps r√©el pour tant de particules s'est r√©v√©l√© trop cher (m√™me avec une limite de cinq octaves), donc une texture a √©t√© g√©n√©r√©e √† partir de laquelle le vertex shader √©chantillonnerait.  Pour am√©liorer l'effet d'un faux champ vectoriel, un petit d√©calage des coordonn√©es de l'√©chantillon a √©t√© ajout√© en fonction de l'heure actuelle de l'√©metteur. <br><br><img src="https://habrastorage.org/webt/sq/vu/xs/sqvuxsyjwxocojucmja_ynqtnjc.png" alt="image"><br>  <i>Le test de fum√©e de cigarette fonctionne en r√©partissant la vitesse et l'acc√©l√©ration initiales sur le bruit perlin.</i> <br><br><h4>  Convoyeur de pixels </h4><br>  Initialement, nous avions seulement pr√©vu de changer la couleur / transparence de la particule en fonction de son temps.  J'ai ajout√© plusieurs algorithmes au pixel shader. <br><br>  Rotation des couleurs de la texture - simplifi√©e, sin (couleur + temps).  Permet dans une certaine mesure d'imiter l'effet de permutation d'AfterEffects. <br><br>  Faux √©clairage - modulation de la couleur d'une particule par un gradient en coordonn√©es universelles, quel que soit l'angle de rotation de la particule. <br><br>  √âvolution des fronti√®res - lorsqu'une particule se d√©place dans l'espace, ses fronti√®res (canal alpha) sont modul√©es par une combinaison de projecteurs et de bruit perlin, ce qui donne leur dynamique d'√©coulement, tr√®s similaire aux nuages, √† la fum√©e et √† d'autres effets de fluide. <br><br>  Pseudo-code du shader: <br><br><pre> <code class="hljs lisp">b=perlin(<span class="hljs-name"><span class="hljs-name">uv</span></span>)<span class="hljs-comment"><span class="hljs-comment">;// , uv      a=saturate(1-length(input.uv.xy-.5)*2);//     a-=abs(ab);//‚Äù‚Äù,  </span></span></code> </pre> <br>  Dans une version l√©g√®rement compliqu√©e, ce shader pouvait tracer des fronti√®res avec une douceur arbitraire et un √©clairage de contour, ce qui ajoutait des effets ¬´explosifs¬ª au r√©alisme. <br><br><img src="https://habrastorage.org/webt/fz/sp/lf/fzsplfbanmnupkdppk2gqj3mlcy.png" alt="image"><br>  <i>Les premi√®res exp√©riences avec l'√©volution des fronti√®res.</i> <br><br><h4>  Et ensuite? </h4><br>  Malgr√© l'√©diteur, d√©j√† pr√™t √† travailler et int√©gr√© dans le moteur, les concepteurs n'ont pas eu le temps d'y faire un seul effet - le projet √©tait clos.  N√©anmoins, il n'y a aucun obstacle √† l'utilisation de ces pratiques ailleurs - par exemple, pour effectuer un travail sur la version de d√©monstration. <br><br>  D'un point de vue technologique, il y a aussi de la place pour bouger - maintenant, par exemple, plusieurs effets de destruction d'objets filaires sont en action: <br><br><img src="https://habrastorage.org/webt/g7/-0/ab/g7-0abs_dlath0s8dxewlrgs1ju.png" alt="image"><br><br>  La question du tri des particules pour le m√©lange alpha reste ouverte jusqu'√† pr√©sent: puisque tout est consid√©r√© analytiquement dans le shader, il n'y a en fait aucune donn√©e d'entr√©e pour le tri.  Mais il y a un large champ d'exp√©rimentation! <br><br>  Pendant le d√©veloppement de Titan World, de nombreuses astuces ont √©t√© appliqu√©es dans la partie graphique du jeu, mais plus √† ce sujet la prochaine fois. <br><br>  PS Vous pouvez creuser dans le moteur alpha source <a href="">ici</a> .  Les exemples sont dans le dossier release / samples, les touches de contr√¥le principales sont l'espace, alt | control + mouse.  Les shaders se trouvent directement dans les fichiers fxp, leur code est disponible via la fen√™tre de l'√©diteur. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424995/">https://habr.com/ru/post/fr424995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424985/index.html">Dans un pr√©c√©dent judiciaire important, les agences de renseignement am√©ricaines n'ont pas √©t√© en mesure d'√©couter des appels dans le messager</a></li>
<li><a href="../fr424987/index.html">R√©cup√©rez des images floues et d√©focalis√©es √† l'aide du filtre Wiener. Impl√©mentation en C ++ OpenCV</a></li>
<li><a href="../fr424989/index.html">Processus de conception: 7 √©tapes pour un projet parfait</a></li>
<li><a href="../fr424991/index.html">Quand les anciennes m√©thodes ne fonctionnent pas: Vasily Mazin - sur une approche hybride du d√©veloppement de l'IA</a></li>
<li><a href="../fr424993/index.html">Pratiques de commercialisation des produits √† la conf√©rence Epic Growth</a></li>
<li><a href="../fr424997/index.html">¬´L'application iOS VKontakte a un seuil d'entr√©e √©lev√©¬ª: entretien avec Alexei Savin</a></li>
<li><a href="../fr425001/index.html">Validation des param√®tres g√©n√©riques dans les contr√¥leurs Spring</a></li>
<li><a href="../fr425003/index.html">Comparez les achats de mat√©riel TCO et les locations de cloud</a></li>
<li><a href="../fr425005/index.html">Rust News # 1 (septembre 2018)</a></li>
<li><a href="../fr425007/index.html">Iridium et Jeff Bezos AWS se sont associ√©s pour d√©velopper un projet mondial d'Internet par satellite pour l'IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>