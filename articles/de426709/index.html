<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌱 🚧 👩🏼‍💼 JavaScript-Timer: alles was Sie wissen müssen 👦🏽 🥀 👋🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Kollegen. Es war einmal ein Artikel über Habré von John Rezig zu diesem Thema. 10 Jahre sind vergangen, und das Thema muss noch geklärt werden. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Timer: alles was Sie wissen müssen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/426709/">  Hallo Kollegen.  Es war einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Artikel</a> über Habré von John Rezig zu diesem Thema.  10 Jahre sind vergangen, und das Thema muss noch geklärt werden.  Daher bieten wir Interessenten an, den Artikel von Samer Buna zu lesen, der nicht nur einen theoretischen Überblick über Timer in JavaScript (im Kontext von Node.js) gibt, sondern auch Aufgaben zu diesen. <br><br><img src="https://habrastorage.org/webt/zs/0c/vx/zs0cvxfhr8yi-cnds0y27thmg0u.png"><br><a name="habracut"></a><br><br>  Vor einigen Wochen habe ich die folgende Frage aus einem einzigen Interview getwittert: <br><br><blockquote>  „Wo ist der Quellcode für die Funktionen setTimeout und setInterval?  Wo würdest du ihn suchen?  Du kannst es nicht googeln :) " <br></blockquote><br>  *** Beantworte es selbst und lies dann weiter *** <br><br><hr><br>  Etwa die Hälfte der Antworten auf diesen Tweet war falsch.  Nein, der Fall ist NICHT mit V8 (oder anderen VMs) verbunden !!!  Funktionen wie <code>setTimeout</code> und <code>setInterval</code> , die stolz als JavaScript-JavaScript-Timer bezeichnet werden, sind nicht Teil einer ECMAScript-Spezifikation oder einer JavaScript-Engine-Implementierung.  Timer-Funktionen werden auf Browserebene implementiert, sodass sich ihre Implementierung in verschiedenen Browsern unterscheidet.  Timer sind auch nativ in der Node.js.-Laufzeit selbst implementiert. <br><br>  In Browsern beziehen sich die Hauptzeitgeberfunktionen auf die <code>Window</code> , die auch einigen anderen Funktionen und Objekten zugeordnet ist.  Diese Schnittstelle bietet globalen Zugriff auf alle Elemente im Hauptbereich von JavaScript.  Aus diesem Grund kann die Funktion <code>setTimeout</code> direkt in der Browserkonsole ausgeführt werden. <br><br>  In Node sind Timer Teil des <code>global</code> Objekts, das wie die Browser-Oberfläche von <code>Window</code> .  Der Quellcode für die Timer in Node wird <a href="">hier</a> angezeigt. <br><br>  Es mag jemandem scheinen, dass dies nur eine schlechte Frage aus dem Interview ist - was nützt es, das zu wissen ?!  Ich als JavaScript-Entwickler denke so: Es wird davon ausgegangen, dass Sie dies wissen sollten, da das Gegenteil darauf hindeutet, dass Sie nicht ganz verstehen, wie V8 (und andere virtuelle Maschinen) mit Browsern und Node interagieren. <br><br>  Schauen wir uns ein paar Beispiele an und lösen ein paar Timer-Aufgaben. <br><br>  <i>Mit dem Befehl node können Sie die Beispiele in diesem Artikel ausführen.</i>  <i>Die meisten der hier diskutierten Beispiele wurden in meinem Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erste Schritte mit Node.js</a> zu Pluralsight vorgestellt.</i> <br><br>  <b>Verzögerung der Funktionsausführung</b> <br><br>  Timer sind Funktionen höherer Ordnung, mit denen Sie die Ausführung anderer Funktionen verzögern oder wiederholen können (der Timer erhält eine solche Funktion als erstes Argument). <br><br>  Hier ist ein Beispiel für eine verzögerte Ausführung: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example1.js setTimeout( () =&gt; { console.log('Hello after 4 seconds'); }, 4 * 1000 );</span></span></code> </pre> <br>  In diesem Beispiel wird die Begrüßungsnachricht bei Verwendung von <code>setTimeout</code> um 4 Sekunden verzögert.  Das zweite Argument für <code>setTimeout</code> ist die Verzögerung (in ms).  Ich multipliziere 4 mit 1000, um 4 Sekunden zu erhalten. <br><br>  Das erste Argument für <code>setTimeout</code> ist eine Funktion, deren Ausführung verzögert wird. <br>  Wenn Sie die Datei <code>example1.js</code> mit dem Befehl node ausführen, hält Node 4 Sekunden lang an und zeigt dann eine Willkommensnachricht an (gefolgt von einem Exit). <br><br>  Bitte beachten Sie: Das erste Argument für <code>setTimeout</code> ist nur eine <b>Funktionsreferenz</b> .  Es sollte keine eingebaute Funktion sein - wie zum Beispiel <code>example1.js</code> .  Hier ist das gleiche Beispiel ohne Verwendung der integrierten Funktion: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> func = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello after 4 seconds'</span></span>); }; setTimeout(func, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  <b>Argumente übergeben</b> <br><br>  Wenn die Funktion, für die <code>setTimeout</code> zum Verzögern verwendet wird, Argumente akzeptiert, können Sie die verbleibenden Argumente der Funktion <code>setTimeout</code> selbst (nach den 2, die wir bereits untersucht haben) verwenden, um die Werte der Argumente an die verzögerte Funktion zu übertragen. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// : func(arg1, arg2, arg3, ...) //  : setTimeout(func, delay, arg1, arg2, arg3, ...)</span></span></code> </pre> <br>  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example2.js const rocks = who =&gt; { console.log(who + ' rocks'); }; setTimeout(rocks, 2 * 1000, 'Node.js');</span></span></code> </pre> <br>  Die obige <code>rocks</code> Funktion, die um 2 Sekunden verzögert ist, verwendet das <code>who</code> Argument, und beim Aufrufen von <code>setTimeout</code> wird der Wert "Node.js" als solches <code>who</code> Argument übergeben. <br><br>  Wenn Sie <code>example2.js</code> mit dem Befehl <code>node</code> ausführen, wird nach 2 Sekunden der Ausdruck "Node.js rockt" angezeigt. <br><br>  <b>Timer Aufgabe 1</b> <br><br>  Basierend auf dem bereits untersuchten Material zu <code>setTimeout</code> werden die folgenden 2 Meldungen nach den entsprechenden Verzögerungen angezeigt. <br><br><ul><li>  Die Meldung „Hallo nach 4 Sekunden“ wird nach 4 Sekunden angezeigt. </li><li>  Die Meldung „Hallo nach 8 Sekunden“ wird nach 8 Sekunden angezeigt. </li></ul><br>  <i>Einschränkung</i> <br><br>  In Ihrer Lösung können Sie nur eine Funktion definieren, die integrierte Funktionen enthält.  Dies bedeutet, dass viele <code>setTimeout</code> Aufrufe dieselbe Funktion verwenden müssen. <br><br>  <i>Lösung</i> <br><br>  So würde ich dieses Problem lösen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// solution1.js const theOneFunc = delay =&gt; { console.log('Hello after ' + delay + ' seconds'); }; setTimeout(theOneFunc, 4 * 1000, 4); setTimeout(theOneFunc, 8 * 1000, 8);</span></span></code> </pre> <br>  Für mich empfängt <code>theOneFunc</code> das <code>delay</code> und verwendet den Wert dieses <code>delay</code> in der auf dem Bildschirm angezeigten Nachricht.  Somit kann die Funktion unterschiedliche Meldungen anzeigen, je nachdem, welchen Verzögerungswert wir darüber informieren. <br><br>  Dann habe ich <code>theOneFunc</code> in zwei <code>setTimeout</code> Aufrufen verwendet, wobei der erste Aufruf nach 4 Sekunden und der zweite nach 8 Sekunden ausgelöst wurde.  Beide <code>setTimeout</code> Aufrufe erhalten auch ein <code>setTimeout</code> Argument, das das <code>delay</code> für <code>theOneFunc</code> . <br><br>  Wenn Sie die Datei <code>solution1.js</code> mit dem Befehl node ausführen, werden die Anforderungen der Aufgabe angezeigt. Die erste Meldung wird nach 4 Sekunden und die zweite nach 8 Sekunden angezeigt. <br><br>  <b>Wiederholen Sie die Funktion</b> <br><br>  Aber was ist, wenn ich Sie gebeten habe, unbegrenzt alle 4 Sekunden eine Nachricht anzuzeigen? <br>  Natürlich können Sie <code>setTimeout</code> in eine Schleife <code>setTimeout</code> , aber die Timer-API bietet auch die Funktion <code>setInterval</code> , mit der Sie die „ewige“ Ausführung jeder Operation programmieren können. <br><br>  Hier ist ein Beispiel für <code>setInterval</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example3.js setInterval( () =&gt; console.log('Hello every 3 seconds'), 3000 );</span></span></code> </pre> <br>  Dieser Code zeigt alle 3 Sekunden eine Meldung an.  Wenn Sie <code>example3.js</code> mit dem Befehl <code>node</code> ausführen, gibt Node diesen Befehl aus, bis Sie das <code>example3.js</code> des Prozesses erzwingen (STRG + C). <br><br>  <b>Timer abbrechen</b> <br><br>  Da beim Aufrufen der Timer-Funktion eine Aktion zugewiesen wird, kann diese Aktion auch rückgängig gemacht werden, bevor sie ausgeführt wird. <br><br>  Der Aufruf von <code>setTimeout</code> gibt eine Timer-ID zurück. Sie können diese Timer-ID beim Aufrufen von <code>clearTimeout</code> , um den Timer abzubrechen.  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example4.js const timerId = setTimeout( () =&gt; console.log('You will not see this one!'), 0 ); clearTimeout(timerId);</span></span></code> </pre> <br>  Dieser einfache Timer sollte nach 0 ms ( <code>timerId</code> sofort) <code>clearTimeout</code> . Dies ist jedoch nicht der Fall, da wir den Wert von <code>timerId</code> und diesen Timer sofort durch Aufrufen von <code>clearTimeout</code> . <br><br>  Wenn Sie <code>example4.js</code> mit dem Befehl <code>node</code> ausführen, <code>example4.js</code> Node nichts - der Vorgang wird einfach sofort beendet. <br><br>  Übrigens bietet Node.js auch eine andere Möglichkeit, <code>setTimeout</code> mit einem Wert von 0 ms <code>setTimeout</code> .  In der Node.js-Timer-API gibt es eine weitere Funktion namens <code>setImmediate</code> , die im Grunde dasselbe wie <code>setTimeout</code> mit einem Wert von 0 ms <code>setTimeout</code> In diesem Fall können Sie jedoch die Verzögerung weglassen: <br><br><pre> <code class="javascript hljs">setImmediate( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I am equivalent to setTimeout with 0 ms'</span></span>), );</code> </pre><br>  Die Funktion <code>setImmediate</code> wird <code>setImmediate</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in allen Browsern unterstützt</a> .  Verwenden Sie es nicht im Client-Code. <br><br>  Zusammen mit <code>clearTimeout</code> gibt es eine <code>clearInterval</code> Funktion, die dasselbe tut, jedoch mit <code>setInerval</code> Aufrufen, und es gibt auch einen <code>clearImmediate</code> Aufruf. <br><br>  <b>Timer Delay - eine Sache, die nicht garantiert ist</b> <br><br>  Haben Sie bemerkt, dass im vorherigen Beispiel beim Ausführen einer Operation mit <code>setTimeout</code> nach 0 ms diese Operation nicht sofort (nach <code>setTimeout</code> ) ausgeführt wird, sondern erst, nachdem der gesamte <code>clearTimeout</code> vollständig ausgeführt wurde (einschließlich des Aufrufs <code>clearTimeout</code> )? <br><br>  Lassen Sie mich diesen Punkt anhand eines Beispiels verdeutlichen.  Hier ist ein einfacher <code>setTimeout</code> Aufruf, der in einer halben Sekunde funktionieren sollte - aber das passiert nicht: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example5.js setTimeout( () =&gt; console.log('Hello after 0.5 seconds. MAYBE!'), 500, ); for (let i = 0; i &lt; 1e10; i++) { //    }</span></span></code> </pre><br>  Unmittelbar nach dem Definieren des Timers in diesem Beispiel blockieren wir die Laufzeitumgebung synchron mit einer großen <code>for</code> Schleife.  Der Wert von <code>1e10</code> ist 1 mit 10 Nullen, sodass der Zyklus 10 Milliarden Prozessorzyklen dauert (im Prinzip simuliert dies einen überlasteten Prozessor).  Der Knoten kann nichts tun, bis diese Schleife abgeschlossen ist. <br><br>  In der Praxis ist dies natürlich sehr schlecht, aber dieses Beispiel hilft zu verstehen, dass die <code>setTimeout</code> Verzögerung nicht garantiert ist, sondern der <b>Mindestwert</b> .  Ein Wert von 500 ms bedeutet, dass die Verzögerung mindestens 500 ms beträgt.  Tatsächlich dauert es viel länger, bis das Skript die Begrüßungszeile auf dem Bildschirm anzeigt.  Zunächst muss er warten, bis der Sperrzyklus abgeschlossen ist. <br><br>  <b>Timer Problem # 2</b> <br><br>  Schreiben Sie ein Skript, in dem die Meldung „Hallo Welt“ einmal pro Sekunde, jedoch nur fünfmal angezeigt wird.  Nach 5 Iterationen sollte das Skript die Meldung "Fertig" anzeigen. Danach wird der Knotenprozess abgeschlossen. <br><br>  <i>Einschränkung</i> : Wenn Sie dieses Problem lösen, können Sie <code>setTimeout</code> nicht aufrufen. <br><br>  <i>Hinweis</i> : brauche einen Zähler. <br><br>  <i>Lösung</i> <br><br>  So würde ich dieses Problem lösen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Done'</span></span>); clearInterval(intervalId); } }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Ich setze 0 als Anfangswert des <code>counter</code> und <code>setInterval</code> dann <code>setInterval</code> , das seine ID annimmt. <br><br>  Eine verzögerte Funktion zeigt eine Meldung an und erhöht den Zähler jedes Mal um eins.  Innerhalb der verzögerten Funktion haben wir eine if-Anweisung, die prüft, ob bereits 5 Iterationen bestanden wurden.  Nach 5 Iterationen zeigt das Programm „Fertig“ an und löscht den Intervallwert mithilfe der erfassten <code>intervalId</code> Konstante.  Die Intervallverzögerung beträgt 1000 ms. <br><br>  <b>Wer nennt genau verzögerte Funktionen?</b> <br><br>  Bei Verwendung von JavaScript <code>this</code> in einer regulären Funktion, wie zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whoCalledMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Caller is'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Der Wert im <code>this</code> mit dem <b>Anrufer</b> überein.  Wenn Sie die obige Funktion innerhalb des Knotens REPL definieren, wird sie vom <code>global</code> Objekt aufgerufen.  Wenn Sie eine Funktion in der Browserkonsole definieren, wird sie vom <code>window</code> aufgerufen. <br><br>  Definieren wir eine Funktion als Eigenschaft eines Objekts, um es etwas klarer zu machen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'42'</span></span>, whoCalledMe() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Caller is'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }; <span class="hljs-comment"><span class="hljs-comment">//     : obj.whoCallMe</span></span></code> </pre> <br>  Wenn wir nun bei der Arbeit mit der Funktion <code>obj</code> den Link direkt dazu verwenden, fungiert das Objekt <code>obj</code> (identifiziert durch seine <code>id</code> ) als Aufrufer: <br><br><img src="https://habrastorage.org/webt/-p/ws/xl/-pwsxloqfbioi6rnk02prkje_wg.png"><br><br>  Die Frage ist nun: Wer wird der Anrufer sein, wenn Sie den Link an <code>obj.whoCallMe</code> an <code>setTimetout</code> ? <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       ?? setTimeout(obj.whoCalledMe, 0);</span></span></code> </pre> <br>  <b>Wer ist in diesem Fall der Anrufer?</b> <br><br>  Die Antwort hängt davon ab, wo die Timer-Funktion ausgeführt wird.  In diesem Fall ist die Abhängigkeit davon, wer der Anrufer ist, einfach nicht akzeptabel.  Sie verlieren die Kontrolle über den Aufrufer, da dies von der Implementierung des Timers abhängt, der in diesem Fall Ihre Funktion aufruft.  Wenn Sie diesen Code in einem Node REPL testen, ist das <code>Timeout</code> Objekt der Aufrufer: <br><br><img src="https://habrastorage.org/webt/hx/bb/t5/hxbbt5rhcmm4l6e2hns0ph8icho.png"><br><br>  Bitte beachten Sie: Dies ist nur wichtig, wenn das JavaScript <code>this</code> in regulären Funktionen verwendet wird.  Bei Verwendung der Pfeilfunktionen sollte der Anrufer Sie überhaupt nicht stören. <br><br>  <b>Timer Problem # 3</b> <br><br>  Schreiben Sie ein Skript, das kontinuierlich eine Nachricht "Hallo Welt" mit unterschiedlichen Verzögerungen ausgibt.  Beginnen Sie mit einer Verzögerung von einer Sekunde und erhöhen Sie diese bei jeder Iteration um eine Sekunde.  Bei der zweiten Iteration beträgt die Verzögerung 2 Sekunden.  Am dritten - drei und so weiter. <br><br>  Fügen Sie der angezeigten Nachricht eine Verzögerung hinzu.  Sie sollten so etwas bekommen: <br><br> <code>Hello World. 1 <br> Hello World. 2 <br> Hello World. 3 <br> ...</code> <br> <br>  <i>Einschränkungen</i> : Variablen können nur mit const definiert werden.  Let oder var verwenden ist nicht. <br><br>  <i>Lösung</i> <br><br>  Da die Dauer der Verzögerung in dieser Aufgabe eine Variable ist, können Sie <code>setInterval</code> hier nicht verwenden, aber Sie können die Intervallausführung mithilfe von <code>setTimeout</code> innerhalb eines rekursiven Aufrufs manuell konfigurieren.  Die erste mit <code>setTimeout</code> ausgeführte Funktion erstellt den nächsten Timer usw. <br><br>  Da Sie <code>let</code> / <code>var</code> nicht verwenden können, können wir außerdem keinen Zähler haben, um die Verzögerung für jeden rekursiven Aufruf zu erhöhen.  Stattdessen können Sie die Argumente einer rekursiven Funktion verwenden, um während eines rekursiven Aufrufs ein Inkrement durchzuführen. <br><br>  So lösen Sie dieses Problem: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delay</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World. '</span></span> + delay); greeting(delay + <span class="hljs-number"><span class="hljs-number">1</span></span>); }, delay * <span class="hljs-number"><span class="hljs-number">1000</span></span>); greeting(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  <b>Timer Aufgabe 4</b> <br><br>  Schreiben Sie ein Skript, das die Nachricht „Hello World“ mit der gleichen Verzögerungsstruktur wie in Aufgabe 3 anzeigt, diesmal jedoch in Gruppen von 5 Nachrichten, und die Gruppe hat ein Hauptverzögerungsintervall.  Für die erste Gruppe von 5 Nachrichten wählen wir die anfängliche Verzögerung von 100 ms, für die nächsten - 200 ms, für die dritten - 300 ms und so weiter. <br><br>  So sollte dieses Skript funktionieren: <br><br><ul><li>  Bei 100 ms zeigt das Skript zum ersten Mal „Hallo Welt“ an, und zwar fünfmal mit einem Intervall von 100 ms.  Die erste Meldung erscheint nach 100 ms, die zweite nach 200 ms usw. </li><li>  Nach den ersten 5 Nachrichten sollte das Skript die Hauptverzögerung um 200 ms erhöhen.  Somit wird die 6. Nachricht nach 500 ms + 200 ms (700 ms), die 7. - 900 ms, die 8. Nachricht - nach 1100 ms usw. angezeigt. </li><li>  Nach 10 Nachrichten sollte das Skript das Hauptverzögerungsintervall um 300 ms erhöhen.  Die 11. Meldung sollte nach 500 ms + 1000 ms + 300 ms (18000 ms) angezeigt werden.  Die 12. Meldung sollte nach 2100 ms usw. angezeigt werden. </li></ul><br>  Nach diesem Prinzip sollte das Programm auf unbestimmte Zeit funktionieren. <br><br>  Fügen Sie der angezeigten Nachricht eine Verzögerung hinzu.  Sie sollten so etwas bekommen (kein Kommentar): <br><br> <code>Hello World. 100 //  100  <br> Hello World. 100 //  200  <br> Hello World. 100 //  300  <br> Hello World. 100 //  400  <br> Hello World. 100 //  500  <br> Hello World. 200 //  700  <br> Hello World. 200 //  900  <br> Hello World. 200 //  1100  <br> ...</code> <br> <br>  <i>Einschränkungen</i> : Sie können nur Aufrufe von <code>setInterval</code> (und nicht <code>setTimeout</code> ) und nur ONE <code>if</code> . <br><br>  <i>Lösung</i> <br><br>  Da wir nur mit <code>setInterval</code> Aufrufen arbeiten können, müssen wir hier die Rekursion verwenden und auch die Verzögerung des nächsten <code>setInterval</code> Aufrufs <code>setInterval</code> .  Außerdem benötigen wir die <code>if</code> , um dies erst nach 5 Aufrufen dieser rekursiven Funktion zu erreichen. <br><br>  Hier ist eine mögliche Lösung: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastIntervalId, counter = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delay</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">5</span></span>) { clearInterval(lastIntervalId); lastIntervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World. '</span></span>, delay); greeting(delay + <span class="hljs-number"><span class="hljs-number">100</span></span>); }, delay); counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; } counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; }; greeting(<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Vielen Dank an alle, die es gelesen haben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426709/">https://habr.com/ru/post/de426709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426699/index.html">Python-Test mit Pytest. Einfach, schnell, effizient und skalierbar. Vorwort und Einführung</a></li>
<li><a href="../de426701/index.html">Flattern - ein neuer Blick auf die plattformübergreifende Entwicklung</a></li>
<li><a href="../de426703/index.html">Was war am DataVizDay in Minsk interessant?</a></li>
<li><a href="../de426705/index.html">Entwicklung und Testen intelligenter Verträge für Hyperledger Fabric</a></li>
<li><a href="../de426707/index.html">Genehmigungssystem. Wie wir das Fahrrad erfunden haben</a></li>
<li><a href="../de426713/index.html">Intel Xeon W-3175X: 28 Kerne für zu Hause</a></li>
<li><a href="../de426717/index.html">Die Illusion der Täuschung: Eine visuelle optische Täuschung basierend auf Retro-Prognosen</a></li>
<li><a href="../de426719/index.html">Hackathon über Data Science in SIBUR: wie es war</a></li>
<li><a href="../de426721/index.html">Vermeiden von Fehlern während der Produktentwicklung: 10 Tipps von Rookee</a></li>
<li><a href="../de426723/index.html">Microsoft und Partner hoffen, eine Zeitkapsel auf dem Mond zu schaffen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>