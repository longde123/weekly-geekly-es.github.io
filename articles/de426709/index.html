<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå± üöß üë©üèº‚Äçüíº JavaScript-Timer: alles was Sie wissen m√ºssen üë¶üèΩ ü•Ä üëãüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Kollegen. Es war einmal ein Artikel √ºber Habr√© von John Rezig zu diesem Thema. 10 Jahre sind vergangen, und das Thema muss noch gekl√§rt werden. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Timer: alles was Sie wissen m√ºssen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/426709/">  Hallo Kollegen.  Es war einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Artikel</a> √ºber Habr√© von John Rezig zu diesem Thema.  10 Jahre sind vergangen, und das Thema muss noch gekl√§rt werden.  Daher bieten wir Interessenten an, den Artikel von Samer Buna zu lesen, der nicht nur einen theoretischen √úberblick √ºber Timer in JavaScript (im Kontext von Node.js) gibt, sondern auch Aufgaben zu diesen. <br><br><img src="https://habrastorage.org/webt/zs/0c/vx/zs0cvxfhr8yi-cnds0y27thmg0u.png"><br><a name="habracut"></a><br><br>  Vor einigen Wochen habe ich die folgende Frage aus einem einzigen Interview getwittert: <br><br><blockquote>  ‚ÄûWo ist der Quellcode f√ºr die Funktionen setTimeout und setInterval?  Wo w√ºrdest du ihn suchen?  Du kannst es nicht googeln :) " <br></blockquote><br>  *** Beantworte es selbst und lies dann weiter *** <br><br><hr><br>  Etwa die H√§lfte der Antworten auf diesen Tweet war falsch.  Nein, der Fall ist NICHT mit V8 (oder anderen VMs) verbunden !!!  Funktionen wie <code>setTimeout</code> und <code>setInterval</code> , die stolz als JavaScript-JavaScript-Timer bezeichnet werden, sind nicht Teil einer ECMAScript-Spezifikation oder einer JavaScript-Engine-Implementierung.  Timer-Funktionen werden auf Browserebene implementiert, sodass sich ihre Implementierung in verschiedenen Browsern unterscheidet.  Timer sind auch nativ in der Node.js.-Laufzeit selbst implementiert. <br><br>  In Browsern beziehen sich die Hauptzeitgeberfunktionen auf die <code>Window</code> , die auch einigen anderen Funktionen und Objekten zugeordnet ist.  Diese Schnittstelle bietet globalen Zugriff auf alle Elemente im Hauptbereich von JavaScript.  Aus diesem Grund kann die Funktion <code>setTimeout</code> direkt in der Browserkonsole ausgef√ºhrt werden. <br><br>  In Node sind Timer Teil des <code>global</code> Objekts, das wie die Browser-Oberfl√§che von <code>Window</code> .  Der Quellcode f√ºr die Timer in Node wird <a href="">hier</a> angezeigt. <br><br>  Es mag jemandem scheinen, dass dies nur eine schlechte Frage aus dem Interview ist - was n√ºtzt es, das zu wissen ?!  Ich als JavaScript-Entwickler denke so: Es wird davon ausgegangen, dass Sie dies wissen sollten, da das Gegenteil darauf hindeutet, dass Sie nicht ganz verstehen, wie V8 (und andere virtuelle Maschinen) mit Browsern und Node interagieren. <br><br>  Schauen wir uns ein paar Beispiele an und l√∂sen ein paar Timer-Aufgaben. <br><br>  <i>Mit dem Befehl node k√∂nnen Sie die Beispiele in diesem Artikel ausf√ºhren.</i>  <i>Die meisten der hier diskutierten Beispiele wurden in meinem Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erste Schritte mit Node.js</a> zu Pluralsight vorgestellt.</i> <br><br>  <b>Verz√∂gerung der Funktionsausf√ºhrung</b> <br><br>  Timer sind Funktionen h√∂herer Ordnung, mit denen Sie die Ausf√ºhrung anderer Funktionen verz√∂gern oder wiederholen k√∂nnen (der Timer erh√§lt eine solche Funktion als erstes Argument). <br><br>  Hier ist ein Beispiel f√ºr eine verz√∂gerte Ausf√ºhrung: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example1.js setTimeout( () =&gt; { console.log('Hello after 4 seconds'); }, 4 * 1000 );</span></span></code> </pre> <br>  In diesem Beispiel wird die Begr√º√üungsnachricht bei Verwendung von <code>setTimeout</code> um 4 Sekunden verz√∂gert.  Das zweite Argument f√ºr <code>setTimeout</code> ist die Verz√∂gerung (in ms).  Ich multipliziere 4 mit 1000, um 4 Sekunden zu erhalten. <br><br>  Das erste Argument f√ºr <code>setTimeout</code> ist eine Funktion, deren Ausf√ºhrung verz√∂gert wird. <br>  Wenn Sie die Datei <code>example1.js</code> mit dem Befehl node ausf√ºhren, h√§lt Node 4 Sekunden lang an und zeigt dann eine Willkommensnachricht an (gefolgt von einem Exit). <br><br>  Bitte beachten Sie: Das erste Argument f√ºr <code>setTimeout</code> ist nur eine <b>Funktionsreferenz</b> .  Es sollte keine eingebaute Funktion sein - wie zum Beispiel <code>example1.js</code> .  Hier ist das gleiche Beispiel ohne Verwendung der integrierten Funktion: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> func = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello after 4 seconds'</span></span>); }; setTimeout(func, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  <b>Argumente √ºbergeben</b> <br><br>  Wenn die Funktion, f√ºr die <code>setTimeout</code> zum Verz√∂gern verwendet wird, Argumente akzeptiert, k√∂nnen Sie die verbleibenden Argumente der Funktion <code>setTimeout</code> selbst (nach den 2, die wir bereits untersucht haben) verwenden, um die Werte der Argumente an die verz√∂gerte Funktion zu √ºbertragen. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// : func(arg1, arg2, arg3, ...) //  : setTimeout(func, delay, arg1, arg2, arg3, ...)</span></span></code> </pre> <br>  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example2.js const rocks = who =&gt; { console.log(who + ' rocks'); }; setTimeout(rocks, 2 * 1000, 'Node.js');</span></span></code> </pre> <br>  Die obige <code>rocks</code> Funktion, die um 2 Sekunden verz√∂gert ist, verwendet das <code>who</code> Argument, und beim Aufrufen von <code>setTimeout</code> wird der Wert "Node.js" als solches <code>who</code> Argument √ºbergeben. <br><br>  Wenn Sie <code>example2.js</code> mit dem Befehl <code>node</code> ausf√ºhren, wird nach 2 Sekunden der Ausdruck "Node.js rockt" angezeigt. <br><br>  <b>Timer Aufgabe 1</b> <br><br>  Basierend auf dem bereits untersuchten Material zu <code>setTimeout</code> werden die folgenden 2 Meldungen nach den entsprechenden Verz√∂gerungen angezeigt. <br><br><ul><li>  Die Meldung ‚ÄûHallo nach 4 Sekunden‚Äú wird nach 4 Sekunden angezeigt. </li><li>  Die Meldung ‚ÄûHallo nach 8 Sekunden‚Äú wird nach 8 Sekunden angezeigt. </li></ul><br>  <i>Einschr√§nkung</i> <br><br>  In Ihrer L√∂sung k√∂nnen Sie nur eine Funktion definieren, die integrierte Funktionen enth√§lt.  Dies bedeutet, dass viele <code>setTimeout</code> Aufrufe dieselbe Funktion verwenden m√ºssen. <br><br>  <i>L√∂sung</i> <br><br>  So w√ºrde ich dieses Problem l√∂sen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// solution1.js const theOneFunc = delay =&gt; { console.log('Hello after ' + delay + ' seconds'); }; setTimeout(theOneFunc, 4 * 1000, 4); setTimeout(theOneFunc, 8 * 1000, 8);</span></span></code> </pre> <br>  F√ºr mich empf√§ngt <code>theOneFunc</code> das <code>delay</code> und verwendet den Wert dieses <code>delay</code> in der auf dem Bildschirm angezeigten Nachricht.  Somit kann die Funktion unterschiedliche Meldungen anzeigen, je nachdem, welchen Verz√∂gerungswert wir dar√ºber informieren. <br><br>  Dann habe ich <code>theOneFunc</code> in zwei <code>setTimeout</code> Aufrufen verwendet, wobei der erste Aufruf nach 4 Sekunden und der zweite nach 8 Sekunden ausgel√∂st wurde.  Beide <code>setTimeout</code> Aufrufe erhalten auch ein <code>setTimeout</code> Argument, das das <code>delay</code> f√ºr <code>theOneFunc</code> . <br><br>  Wenn Sie die Datei <code>solution1.js</code> mit dem Befehl node ausf√ºhren, werden die Anforderungen der Aufgabe angezeigt. Die erste Meldung wird nach 4 Sekunden und die zweite nach 8 Sekunden angezeigt. <br><br>  <b>Wiederholen Sie die Funktion</b> <br><br>  Aber was ist, wenn ich Sie gebeten habe, unbegrenzt alle 4 Sekunden eine Nachricht anzuzeigen? <br>  Nat√ºrlich k√∂nnen Sie <code>setTimeout</code> in eine Schleife <code>setTimeout</code> , aber die Timer-API bietet auch die Funktion <code>setInterval</code> , mit der Sie die ‚Äûewige‚Äú Ausf√ºhrung jeder Operation programmieren k√∂nnen. <br><br>  Hier ist ein Beispiel f√ºr <code>setInterval</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example3.js setInterval( () =&gt; console.log('Hello every 3 seconds'), 3000 );</span></span></code> </pre> <br>  Dieser Code zeigt alle 3 Sekunden eine Meldung an.  Wenn Sie <code>example3.js</code> mit dem Befehl <code>node</code> ausf√ºhren, gibt Node diesen Befehl aus, bis Sie das <code>example3.js</code> des Prozesses erzwingen (STRG + C). <br><br>  <b>Timer abbrechen</b> <br><br>  Da beim Aufrufen der Timer-Funktion eine Aktion zugewiesen wird, kann diese Aktion auch r√ºckg√§ngig gemacht werden, bevor sie ausgef√ºhrt wird. <br><br>  Der Aufruf von <code>setTimeout</code> gibt eine Timer-ID zur√ºck. Sie k√∂nnen diese Timer-ID beim Aufrufen von <code>clearTimeout</code> , um den Timer abzubrechen.  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example4.js const timerId = setTimeout( () =&gt; console.log('You will not see this one!'), 0 ); clearTimeout(timerId);</span></span></code> </pre> <br>  Dieser einfache Timer sollte nach 0 ms ( <code>timerId</code> sofort) <code>clearTimeout</code> . Dies ist jedoch nicht der Fall, da wir den Wert von <code>timerId</code> und diesen Timer sofort durch Aufrufen von <code>clearTimeout</code> . <br><br>  Wenn Sie <code>example4.js</code> mit dem Befehl <code>node</code> ausf√ºhren, <code>example4.js</code> Node nichts - der Vorgang wird einfach sofort beendet. <br><br>  √úbrigens bietet Node.js auch eine andere M√∂glichkeit, <code>setTimeout</code> mit einem Wert von 0 ms <code>setTimeout</code> .  In der Node.js-Timer-API gibt es eine weitere Funktion namens <code>setImmediate</code> , die im Grunde dasselbe wie <code>setTimeout</code> mit einem Wert von 0 ms <code>setTimeout</code> In diesem Fall k√∂nnen Sie jedoch die Verz√∂gerung weglassen: <br><br><pre> <code class="javascript hljs">setImmediate( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I am equivalent to setTimeout with 0 ms'</span></span>), );</code> </pre><br>  Die Funktion <code>setImmediate</code> wird <code>setImmediate</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in allen Browsern unterst√ºtzt</a> .  Verwenden Sie es nicht im Client-Code. <br><br>  Zusammen mit <code>clearTimeout</code> gibt es eine <code>clearInterval</code> Funktion, die dasselbe tut, jedoch mit <code>setInerval</code> Aufrufen, und es gibt auch einen <code>clearImmediate</code> Aufruf. <br><br>  <b>Timer Delay - eine Sache, die nicht garantiert ist</b> <br><br>  Haben Sie bemerkt, dass im vorherigen Beispiel beim Ausf√ºhren einer Operation mit <code>setTimeout</code> nach 0 ms diese Operation nicht sofort (nach <code>setTimeout</code> ) ausgef√ºhrt wird, sondern erst, nachdem der gesamte <code>clearTimeout</code> vollst√§ndig ausgef√ºhrt wurde (einschlie√ülich des Aufrufs <code>clearTimeout</code> )? <br><br>  Lassen Sie mich diesen Punkt anhand eines Beispiels verdeutlichen.  Hier ist ein einfacher <code>setTimeout</code> Aufruf, der in einer halben Sekunde funktionieren sollte - aber das passiert nicht: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example5.js setTimeout( () =&gt; console.log('Hello after 0.5 seconds. MAYBE!'), 500, ); for (let i = 0; i &lt; 1e10; i++) { //    }</span></span></code> </pre><br>  Unmittelbar nach dem Definieren des Timers in diesem Beispiel blockieren wir die Laufzeitumgebung synchron mit einer gro√üen <code>for</code> Schleife.  Der Wert von <code>1e10</code> ist 1 mit 10 Nullen, sodass der Zyklus 10 Milliarden Prozessorzyklen dauert (im Prinzip simuliert dies einen √ºberlasteten Prozessor).  Der Knoten kann nichts tun, bis diese Schleife abgeschlossen ist. <br><br>  In der Praxis ist dies nat√ºrlich sehr schlecht, aber dieses Beispiel hilft zu verstehen, dass die <code>setTimeout</code> Verz√∂gerung nicht garantiert ist, sondern der <b>Mindestwert</b> .  Ein Wert von 500 ms bedeutet, dass die Verz√∂gerung mindestens 500 ms betr√§gt.  Tats√§chlich dauert es viel l√§nger, bis das Skript die Begr√º√üungszeile auf dem Bildschirm anzeigt.  Zun√§chst muss er warten, bis der Sperrzyklus abgeschlossen ist. <br><br>  <b>Timer Problem # 2</b> <br><br>  Schreiben Sie ein Skript, in dem die Meldung ‚ÄûHallo Welt‚Äú einmal pro Sekunde, jedoch nur f√ºnfmal angezeigt wird.  Nach 5 Iterationen sollte das Skript die Meldung "Fertig" anzeigen. Danach wird der Knotenprozess abgeschlossen. <br><br>  <i>Einschr√§nkung</i> : Wenn Sie dieses Problem l√∂sen, k√∂nnen Sie <code>setTimeout</code> nicht aufrufen. <br><br>  <i>Hinweis</i> : brauche einen Z√§hler. <br><br>  <i>L√∂sung</i> <br><br>  So w√ºrde ich dieses Problem l√∂sen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Done'</span></span>); clearInterval(intervalId); } }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Ich setze 0 als Anfangswert des <code>counter</code> und <code>setInterval</code> dann <code>setInterval</code> , das seine ID annimmt. <br><br>  Eine verz√∂gerte Funktion zeigt eine Meldung an und erh√∂ht den Z√§hler jedes Mal um eins.  Innerhalb der verz√∂gerten Funktion haben wir eine if-Anweisung, die pr√ºft, ob bereits 5 Iterationen bestanden wurden.  Nach 5 Iterationen zeigt das Programm ‚ÄûFertig‚Äú an und l√∂scht den Intervallwert mithilfe der erfassten <code>intervalId</code> Konstante.  Die Intervallverz√∂gerung betr√§gt 1000 ms. <br><br>  <b>Wer nennt genau verz√∂gerte Funktionen?</b> <br><br>  Bei Verwendung von JavaScript <code>this</code> in einer regul√§ren Funktion, wie zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whoCalledMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Caller is'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Der Wert im <code>this</code> mit dem <b>Anrufer</b> √ºberein.  Wenn Sie die obige Funktion innerhalb des Knotens REPL definieren, wird sie vom <code>global</code> Objekt aufgerufen.  Wenn Sie eine Funktion in der Browserkonsole definieren, wird sie vom <code>window</code> aufgerufen. <br><br>  Definieren wir eine Funktion als Eigenschaft eines Objekts, um es etwas klarer zu machen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'42'</span></span>, whoCalledMe() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Caller is'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }; <span class="hljs-comment"><span class="hljs-comment">//     : obj.whoCallMe</span></span></code> </pre> <br>  Wenn wir nun bei der Arbeit mit der Funktion <code>obj</code> den Link direkt dazu verwenden, fungiert das Objekt <code>obj</code> (identifiziert durch seine <code>id</code> ) als Aufrufer: <br><br><img src="https://habrastorage.org/webt/-p/ws/xl/-pwsxloqfbioi6rnk02prkje_wg.png"><br><br>  Die Frage ist nun: Wer wird der Anrufer sein, wenn Sie den Link an <code>obj.whoCallMe</code> an <code>setTimetout</code> ? <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       ?? setTimeout(obj.whoCalledMe, 0);</span></span></code> </pre> <br>  <b>Wer ist in diesem Fall der Anrufer?</b> <br><br>  Die Antwort h√§ngt davon ab, wo die Timer-Funktion ausgef√ºhrt wird.  In diesem Fall ist die Abh√§ngigkeit davon, wer der Anrufer ist, einfach nicht akzeptabel.  Sie verlieren die Kontrolle √ºber den Aufrufer, da dies von der Implementierung des Timers abh√§ngt, der in diesem Fall Ihre Funktion aufruft.  Wenn Sie diesen Code in einem Node REPL testen, ist das <code>Timeout</code> Objekt der Aufrufer: <br><br><img src="https://habrastorage.org/webt/hx/bb/t5/hxbbt5rhcmm4l6e2hns0ph8icho.png"><br><br>  Bitte beachten Sie: Dies ist nur wichtig, wenn das JavaScript <code>this</code> in regul√§ren Funktionen verwendet wird.  Bei Verwendung der Pfeilfunktionen sollte der Anrufer Sie √ºberhaupt nicht st√∂ren. <br><br>  <b>Timer Problem # 3</b> <br><br>  Schreiben Sie ein Skript, das kontinuierlich eine Nachricht "Hallo Welt" mit unterschiedlichen Verz√∂gerungen ausgibt.  Beginnen Sie mit einer Verz√∂gerung von einer Sekunde und erh√∂hen Sie diese bei jeder Iteration um eine Sekunde.  Bei der zweiten Iteration betr√§gt die Verz√∂gerung 2 Sekunden.  Am dritten - drei und so weiter. <br><br>  F√ºgen Sie der angezeigten Nachricht eine Verz√∂gerung hinzu.  Sie sollten so etwas bekommen: <br><br> <code>Hello World. 1 <br> Hello World. 2 <br> Hello World. 3 <br> ...</code> <br> <br>  <i>Einschr√§nkungen</i> : Variablen k√∂nnen nur mit const definiert werden.  Let oder var verwenden ist nicht. <br><br>  <i>L√∂sung</i> <br><br>  Da die Dauer der Verz√∂gerung in dieser Aufgabe eine Variable ist, k√∂nnen Sie <code>setInterval</code> hier nicht verwenden, aber Sie k√∂nnen die Intervallausf√ºhrung mithilfe von <code>setTimeout</code> innerhalb eines rekursiven Aufrufs manuell konfigurieren.  Die erste mit <code>setTimeout</code> ausgef√ºhrte Funktion erstellt den n√§chsten Timer usw. <br><br>  Da Sie <code>let</code> / <code>var</code> nicht verwenden k√∂nnen, k√∂nnen wir au√üerdem keinen Z√§hler haben, um die Verz√∂gerung f√ºr jeden rekursiven Aufruf zu erh√∂hen.  Stattdessen k√∂nnen Sie die Argumente einer rekursiven Funktion verwenden, um w√§hrend eines rekursiven Aufrufs ein Inkrement durchzuf√ºhren. <br><br>  So l√∂sen Sie dieses Problem: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delay</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World. '</span></span> + delay); greeting(delay + <span class="hljs-number"><span class="hljs-number">1</span></span>); }, delay * <span class="hljs-number"><span class="hljs-number">1000</span></span>); greeting(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  <b>Timer Aufgabe 4</b> <br><br>  Schreiben Sie ein Skript, das die Nachricht ‚ÄûHello World‚Äú mit der gleichen Verz√∂gerungsstruktur wie in Aufgabe 3 anzeigt, diesmal jedoch in Gruppen von 5 Nachrichten, und die Gruppe hat ein Hauptverz√∂gerungsintervall.  F√ºr die erste Gruppe von 5 Nachrichten w√§hlen wir die anf√§ngliche Verz√∂gerung von 100 ms, f√ºr die n√§chsten - 200 ms, f√ºr die dritten - 300 ms und so weiter. <br><br>  So sollte dieses Skript funktionieren: <br><br><ul><li>  Bei 100 ms zeigt das Skript zum ersten Mal ‚ÄûHallo Welt‚Äú an, und zwar f√ºnfmal mit einem Intervall von 100 ms.  Die erste Meldung erscheint nach 100 ms, die zweite nach 200 ms usw. </li><li>  Nach den ersten 5 Nachrichten sollte das Skript die Hauptverz√∂gerung um 200 ms erh√∂hen.  Somit wird die 6. Nachricht nach 500 ms + 200 ms (700 ms), die 7. - 900 ms, die 8. Nachricht - nach 1100 ms usw. angezeigt. </li><li>  Nach 10 Nachrichten sollte das Skript das Hauptverz√∂gerungsintervall um 300 ms erh√∂hen.  Die 11. Meldung sollte nach 500 ms + 1000 ms + 300 ms (18000 ms) angezeigt werden.  Die 12. Meldung sollte nach 2100 ms usw. angezeigt werden. </li></ul><br>  Nach diesem Prinzip sollte das Programm auf unbestimmte Zeit funktionieren. <br><br>  F√ºgen Sie der angezeigten Nachricht eine Verz√∂gerung hinzu.  Sie sollten so etwas bekommen (kein Kommentar): <br><br> <code>Hello World. 100 //  100  <br> Hello World. 100 //  200  <br> Hello World. 100 //  300  <br> Hello World. 100 //  400  <br> Hello World. 100 //  500  <br> Hello World. 200 //  700  <br> Hello World. 200 //  900  <br> Hello World. 200 //  1100  <br> ...</code> <br> <br>  <i>Einschr√§nkungen</i> : Sie k√∂nnen nur Aufrufe von <code>setInterval</code> (und nicht <code>setTimeout</code> ) und nur ONE <code>if</code> . <br><br>  <i>L√∂sung</i> <br><br>  Da wir nur mit <code>setInterval</code> Aufrufen arbeiten k√∂nnen, m√ºssen wir hier die Rekursion verwenden und auch die Verz√∂gerung des n√§chsten <code>setInterval</code> Aufrufs <code>setInterval</code> .  Au√üerdem ben√∂tigen wir die <code>if</code> , um dies erst nach 5 Aufrufen dieser rekursiven Funktion zu erreichen. <br><br>  Hier ist eine m√∂gliche L√∂sung: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastIntervalId, counter = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delay</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">5</span></span>) { clearInterval(lastIntervalId); lastIntervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World. '</span></span>, delay); greeting(delay + <span class="hljs-number"><span class="hljs-number">100</span></span>); }, delay); counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; } counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; }; greeting(<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Vielen Dank an alle, die es gelesen haben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426709/">https://habr.com/ru/post/de426709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426699/index.html">Python-Test mit Pytest. Einfach, schnell, effizient und skalierbar. Vorwort und Einf√ºhrung</a></li>
<li><a href="../de426701/index.html">Flattern - ein neuer Blick auf die plattform√ºbergreifende Entwicklung</a></li>
<li><a href="../de426703/index.html">Was war am DataVizDay in Minsk interessant?</a></li>
<li><a href="../de426705/index.html">Entwicklung und Testen intelligenter Vertr√§ge f√ºr Hyperledger Fabric</a></li>
<li><a href="../de426707/index.html">Genehmigungssystem. Wie wir das Fahrrad erfunden haben</a></li>
<li><a href="../de426713/index.html">Intel Xeon W-3175X: 28 Kerne f√ºr zu Hause</a></li>
<li><a href="../de426717/index.html">Die Illusion der T√§uschung: Eine visuelle optische T√§uschung basierend auf Retro-Prognosen</a></li>
<li><a href="../de426719/index.html">Hackathon √ºber Data Science in SIBUR: wie es war</a></li>
<li><a href="../de426721/index.html">Vermeiden von Fehlern w√§hrend der Produktentwicklung: 10 Tipps von Rookee</a></li>
<li><a href="../de426723/index.html">Microsoft und Partner hoffen, eine Zeitkapsel auf dem Mond zu schaffen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>