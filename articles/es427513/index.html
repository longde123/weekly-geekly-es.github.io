<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∑ üêò üë©üèø‚Äçüè≠ C√≥mo analizar el volcado de subprocesos üëàüèæ ü§±üèº üë®üèæ‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay bastantes temas sobre los aspectos internos de la JVM en el programa del curso Java Developer . Entendemos los mecanismos de trabajo de las colecc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo analizar el volcado de subprocesos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/427513/">  <i>Hay bastantes temas sobre los aspectos internos de la JVM en el programa del curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java Developer</a> .</i>  <i>Entendemos los mecanismos de trabajo de las colecciones, bytecode, recolectores de basura, etc.</i>  <i>Hoy ofrecemos su atenci√≥n a la traducci√≥n de un art√≠culo bastante interesante sobre el volcado de hilos.</i>  <i>Qu√© es, c√≥mo obtenerlo y c√≥mo usarlo.</i> <br><br>  ¬øQuieres aprender a analizar el volcado de subprocesos?  Ve debajo del gato para obtener m√°s informaci√≥n sobre c√≥mo obtener volcado de subprocesos en Java y qu√© hacer con √©l m√°s adelante. <br><a name="habracut"></a><br>  La mayor√≠a de las aplicaciones Java modernas son multiproceso.  El subprocesamiento m√∫ltiple puede expandir significativamente la funcionalidad de la aplicaci√≥n, al mismo tiempo que introduce una complejidad significativa. <br><br>  En una aplicaci√≥n de subproceso √∫nico, todos los recursos (memoria compartida, operaciones de entrada / salida, etc.) se pueden usar sin sincronizaci√≥n, porque  en un momento dado, solo un subproceso usa el recurso. <br><br>  En el caso de aplicaciones de subprocesos m√∫ltiples, es necesario encontrar un compromiso entre complicar el programa y un posible aumento en el rendimiento, cuando varios subprocesos pueden usar todos los procesadores (CPU) disponibles (a menudo m√°s de un) n√∫cleo.  Si todo se hace correctamente, utilizando el subprocesamiento m√∫ltiple (formalizado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la Ley de Amdahl</a> ), puede lograr un aumento significativo en el rendimiento de la aplicaci√≥n.  Sin embargo, uno debe recordar proporcionar acceso simult√°neo de varias corrientes a un recurso compartido.  En la mayor√≠a de los casos, los marcos como Spring encapsulan el trabajo con hilos y ocultan muchos detalles t√©cnicos de los usuarios.  Sin embargo, en el caso de utilizar marcos modernos y complejos, algo puede salir mal, y nosotros, como usuarios, encontraremos errores de subprocesamiento m√∫ltiple dif√≠ciles de resolver. <br><br>  Afortunadamente, Java est√° equipado con un mecanismo especial para obtener informaci√≥n sobre el estado actual de todos los subprocesos en un momento dado: es un volcado de subprocesos (una especie de instant√°nea).  En este art√≠culo, aprenderemos c√≥mo obtener un volcado de subprocesos para una aplicaci√≥n de tama√±o realista y c√≥mo analizar este volcado. <br><br>  Se supone que el lector tiene informaci√≥n b√°sica sobre programaci√≥n multiproceso y es consciente de los problemas de sincronizaci√≥n de subprocesos y el uso de recursos compartidos.  Sin embargo, no ser√° superfluo actualizar algunos t√©rminos y conceptos b√°sicos. <br><br><h4>  Terminolog√≠a b√°sica </h4><br>  A primera vista, los volcados de hilos de Java pueden parecer una "letra china", los siguientes conceptos son clave para entenderlo.  En general, repitamos los t√©rminos b√°sicos de subprocesamiento m√∫ltiple, que usaremos para analizar los volcados. <br><br><ul><li> <strong>Subproceso</strong> o subproceso es una unidad de subprocesamiento m√∫ltiple discreta administrada por la m√°quina virtual Java (JVM).  Los subprocesos JVM corresponden a subprocesos en el sistema operativo (SO): subprocesos nativos que implementan el mecanismo de ejecuci√≥n de c√≥digo. <br><br>  Cada hilo tiene un identificador y nombre √∫nicos.  Las corrientes pueden ser "demonios" y "no demonios". <br><br>  El programa finaliza cuando finalizan todos los subprocesos no daemon o cuando se <i>llama al</i> m√©todo <i>Runtime.exit</i> .  Los "demonios" que trabajan no afectan la finalizaci√≥n del programa.  Es decir  La JVM est√° esperando que todos los "no demonios" se finalicen y se apaguen; no est√°n prestando atenci√≥n a los "no demonios". <br><br>  Para obtener m√°s informaci√≥n, consulte la documentaci√≥n de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase Thread</a> . <br>  Una secuencia puede estar en uno de los siguientes estados: <br><br><ul><li>  <strong>Subproceso vivo</strong> o "en vivo": un subproceso que funciona (estado normal). </li><li>  <strong>Hilo bloqueado</strong> o "bloqueado": un hilo que intent√≥ ingresar a la secci√≥n sincronizada (sincronizado), pero otro hilo ya logr√≥ ingresar primero a este bloque, y todos los siguientes hilos que intentan ingresar al mismo bloque est√°n bloqueados. </li><li>  <strong>Subproceso en espera</strong> o "en espera": un subproceso que llam√≥ al m√©todo de <i>espera</i> (posiblemente con un tiempo de espera excedido) y ahora est√° esperando que otro m√©todo ejecute <i>notificar</i> o <i>notificar a</i> <i>todos</i> en el mismo objeto. <br><br>  Tenga en cuenta que el hilo no se considera "en espera" si se llama esperar con un tiempo de espera y este tiempo de espera ha expirado. </li><li>  <strong>Hilo para dormir</strong> o "dormir": un hilo que no se est√° ejecutando actualmente, porque  realiz√≥ el m√©todo Thread.sleep (que indica la duraci√≥n del "sue√±o"). </li></ul></li><li>  <strong>Monitor</strong> es un mecanismo utilizado por la JVM para proporcionar acceso multiproceso a un solo objeto.  El mecanismo se inicia utilizando la <i>palabra clave</i> especial <i>sincronizada</i> . <br><br>  Cada objeto en Java tiene un monitor con el que se puede sincronizar el hilo, es decir  establecer un bloqueo, lo que garantiza que ning√∫n otro hilo acceder√° a este objeto hasta que se libere el bloqueo, es decir  thread: el propietario del bloqueo no saldr√° del bloque <i>sincronizado</i> . <br><br>  Consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secci√≥n Sincronizaci√≥n (17.1) de la Especificaci√≥n de lenguaje Java (JLS) para obtener m√°s informaci√≥n</a> . <br></li><li>  <strong>El punto muerto</strong> es una situaci√≥n en la que un hilo, digamos A, bloquea un recurso, necesita otro recurso que est√© bloqueado por otro hilo, digamos B. La corriente B no libera este recurso, porque  Para completar una determinada operaci√≥n, necesita un recurso que est√© bloqueado por el subproceso A. Resulta que el subproceso A est√° esperando que el subproceso B desbloquee el recurso, que est√° esperando que otro subproceso sea desbloqueado por el subproceso A. Y, por lo tanto, los subprocesos se esperan entre s√≠.  Como resultado, todo el programa se cuelga y espera a que los hilos se desbloqueen de alguna manera y contin√∫en funcionando.  Puede haber muchos hilos en un punto muerto.  Este problema es bien conocido como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Problema de los fil√≥sofos gastron√≥micos"</a> . <br><br><img src="https://habrastorage.org/webt/8t/ll/jb/8tlljb_n-e80_dk_0uayobgil_s.png"><br></li><li>  <strong>Livelock</strong> es una situaci√≥n en la que el subproceso A obliga al subproceso B a realizar alguna acci√≥n, lo que a su vez hace que el subproceso A ejecute la acci√≥n original, lo que una vez m√°s provoca la acci√≥n del subproceso B. Se obtiene una dependencia c√≠clica.  Esto se puede imaginar como un perro corriendo tras su cola.  De manera similar a <i>Deadlock</i> , en una situaci√≥n de Livelock, el programa no avanza, es decir.  no realiza una acci√≥n √∫til, sin embargo, en esta situaci√≥n, los hilos no est√°n bloqueados. <br></li></ul><br>  La terminolog√≠a presentada no es exhaustiva para describir el mundo de los subprocesos m√∫ltiples, pero es suficiente para comenzar a analizar los volcados de subprocesos. <br><br>  Se puede encontrar informaci√≥n m√°s detallada en estas fuentes: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Secci√≥n 17 de la</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">concurrencia</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JLS</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java en la pr√°ctica</a> <br><br>  Usando estos conceptos simples sobre el flujo en Java, podemos crear una aplicaci√≥n de prueba.  Para esta aplicaci√≥n compilaremos volcado de subprocesos.  Analizaremos el volcado resultante y extraeremos informaci√≥n √∫til sobre los flujos de aplicaciones actuales. <br><br><h4>  Crear un programa de muestra </h4><br>  Antes de crear un volcado de subprocesos, necesitamos desarrollar una aplicaci√≥n Java.  El tradicional "hola, mundo!"  demasiado simple para nuestro prop√≥sito, y un volcado de tama√±o medio de la aplicaci√≥n puede ser demasiado complicado para demostrarlo.  En base a esto, crearemos una aplicaci√≥n bastante simple en la que se crean dos hilos.  Y los hilos se estancan: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceB, resourceA)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Este programa crea dos recursos: resourceA y resourceB, e inicia dos hilos: threadLockingResourceAFirst y threadLockingResourceBFirst, que bloquean los recursos del otro. <br><br>  La causa del punto muerto es un bloqueo "cruzado" de recursos por hilos. <br><br>  La raz√≥n de la existencia de un punto muerto es un intento de "mutuamente" aprovechar los recursos, es decir  El hilo threadLockingResourceAFirst captura el recurso resourceA, el hilo threadLockingResourceBFirst captura el recurso resourceB.  Despu√©s de eso, threadLockingResourceAFirst, sin liberar su recurso, intenta capturar resourceB, y threadLockingResourceBFirst, sin liberar su recurso, intenta capturar resourceA.  Como resultado, los hilos est√°n bloqueados.  Se ha agregado un retraso de 1s para garantizar el bloqueo.  Los hilos esperan la liberaci√≥n de los recursos necesarios, pero esto nunca suceder√°. <br><br>  El resultado del programa ser√° as√≠ (los n√∫meros despu√©s de java.lang.Object @ ser√°n diferentes para cada lanzamiento): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Thread-0</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">locked</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">resource</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Object</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">149bc794</span></span> Thread-<span class="hljs-number"><span class="hljs-number">1</span></span>: locked resource -&gt; java.lang.Object@<span class="hljs-number"><span class="hljs-number">17</span></span>c10009</code> </pre> <br>  Despu√©s de la salida de estos mensajes, el programa parecer√° que se est√° ejecutando (el proceso que ejecuta este programa no se ha completado), mientras que el programa no realiza ning√∫n trabajo.  As√≠ es como se ve un punto muerto en la pr√°ctica.  Para resolver el problema, necesitamos crear manualmente un volcado de banda de rodadura y analizar el estado de los hilos. <br><br><h4>  Generaci√≥n de volcado de subprocesos </h4><br>  En la pr√°ctica, un programa Java puede bloquearse al crear un volcado de subprocesos.  Sin embargo, en algunos casos (por ejemplo, en el caso de puntos muertos), el programa no finaliza y el volcado de subprocesos no se crea, simplemente se bloquea.  Para crear un volcado de dichos programas bloqueados, en primer lugar, debe encontrar el identificador del proceso del programa, es decir,  ID de proceso (PID).  Para hacer esto, puede utilizar la utilidad JVM Process Status (JPS), que, a partir de la versi√≥n 7, forma parte del Java Development Kit (JDK).  Para encontrar el PID de proceso de nuestro programa bloqueado, simplemente ejecutamos jps en el terminal (Windows o Linux): <br><br><pre> <code class="hljs ruby">$ jps <span class="hljs-number"><span class="hljs-number">11568</span></span> DeadlockProgram <span class="hljs-number"><span class="hljs-number">15584</span></span> Jps <span class="hljs-number"><span class="hljs-number">15636</span></span></code> </pre> <br>  La primera columna es el identificador de la m√°quina virtual local (ID de m√°quina virtual local, es decir, lvmid) para el proceso Java en ejecuci√≥n.  En el contexto de la JVM local, lvmid apunta al PID del proceso Java. <br><br>  Cabe se√±alar que es probable que este valor difiera del valor anterior.  La segunda columna es el nombre de la aplicaci√≥n, que puede apuntar al nombre de la clase principal, archivo jar o igual a "Desconocido".  Todo depende de c√≥mo se inici√≥ la aplicaci√≥n. <br><br>  En nuestro caso, el nombre de la aplicaci√≥n DeadlockProgram es el nombre de las clases principales que se iniciaron cuando se inici√≥ el programa.  En el ejemplo anterior PID del programa 11568, esta informaci√≥n es suficiente para generar un volcado de subprocesos.  Para generar el volcado, utilizaremos la utilidad <strong>jstack</strong> , que es parte del JDK, comenzando con la versi√≥n 7. Para obtener el volcado, pasaremos el PID de nuestro programa a <strong>jstack</strong> y especificaremos el indicador -l (creando una lista larga).  La salida de la utilidad se redirigir√° a un archivo de texto, es decir  thread_dump.txt: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">jstack</span></span> -l <span class="hljs-number"><span class="hljs-number">11568</span></span> &gt; thread_dump.txt</code> </pre> <br>  El archivo resultante thread_dump.txt contiene el volcado de subprocesos de nuestro programa bloqueado y contiene informaci√≥n importante para diagnosticar las causas del punto muerto. <br><br>  Si el JDK se usa hasta la versi√≥n 7, para generar un volcado, puede usar la utilidad Linux: <strong>matar</strong> con el indicador -3.  Llamar a kill -3 enviar√° al programa una se√±al SIGQUIT. <br><br>  En nuestro caso, la llamada ser√° as√≠: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">kill</span></span> <span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-number"><span class="hljs-number">11568</span></span></code> </pre> <br><h4>  An√°lisis simple de volcado de subprocesos </h4><br>  Al abrir el archivo thread_dump.txt, veremos algo como lo siguiente: <br><br><pre> 2018-06-19 16:44:44
 Full thread dump Java HotSpot (TM) VM de servidor de 64 bits (10.0.1 + 10 modo mixto):
 Informaci√≥n de clase SMR de subprocesos
 _java_thread_list = 0x00000250e5488a00, longitud = 13, elementos = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
 "Controlador de referencia" # 2 daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 esperando en condici√≥n [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     en java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     en java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     en java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     en java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "Finalizador" # 3 daemon prio = 8 os_prio = 1 tid = 0x00000250e4982800 nid = 0x2a54 en Object.wait () [0x000000b82aaff000]
    java.lang.Thread.State: WAITING (en el monitor de objetos)
     en java.lang.Object.wait (java.base@10.0.1/Native Method)
     - esperando en &lt;0x0000000089509410&gt; (un java.lang.ref.ReferenceQueue $ Lock)
     en java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - esperando para volver a bloquear en wait () &lt;0x0000000089509410&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     en java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 172)
     en java.lang.ref.Finalizer $ FinalizerThread.run (java.base@10.0.1/Finalizer.java: 216)
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "Despachador de se√±al" # 4 daemon prio = 9 os_prio = 2 tid = 0x00000250e52f2800 nid = 0x2184 ejecutable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "Attach Listener" # 5 daemon prio = 5 os_prio = 2 tid = 0x00000250e4992800 nid = 0x1624 esperando en condici√≥n [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "C2 CompilerThread0" # 6 daemon prio = 9 os_prio = 2 tid = 0x00000250e4995800 nid = 0x4198 esperando en condici√≥n [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sin tarea de compilaci√≥n
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "C2 CompilerThread1" # 7 daemon prio = 9 os_prio = 2 tid = 0x00000250e49a5800 nid = 0x3b98 esperando en condici√≥n [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sin tarea de compilaci√≥n
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "C1 CompilerThread2" # 8 daemon prio = 9 os_prio = 2 tid = 0x00000250e49ae800 nid = 0x1a84 esperando en condici√≥n [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sin tarea de compilaci√≥n
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "Thread Sweeper" # 9 daemon prio = 9 os_prio = 2 tid = 0x00000250e5324000 nid = 0x5f0 ejecutable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "Hilo de servicio" # 10 daemon prio = 9 os_prio = 0 tid = 0x00000250e54cd800 nid = 0x169c ejecutable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "Common-Cleaner" # 11 daemon prio = 8 os_prio = 1 tid = 0x00000250e54cf000 nid = 0x1610 en Object.wait () [0x000000b82b2fe000]
    java.lang.Thread.State: TIMED_WAITING (en el monitor de objetos)
     en java.lang.Object.wait (java.base@10.0.1/Native Method)
     - esperando en &lt;0x000000008943e600&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     en java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - esperando para volver a bloquear en wait () &lt;0x000000008943e600&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     en jdk.internal.ref.CleanerImpl.run (java.base@10.0.1/CleanerImpl.java: 148)
     en java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
     en jdk.internal.misc.InnocuousThread.run (java.base@10.0.1/InnocuousThread.java: 134)
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec esperando la entrada del monitor [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (en el monitor de objetos)
     en DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - esperando para bloquear &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - bloqueado &lt;0x00000000894465a0&gt; (un java.lang.Object)
     en java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "Thread-1" # 13 prio = 5 os_prio = 0 tid = 0x00000250e54d2000 nid = 0x415c esperando la entrada del monitor [0x000000b82b5ff000]
    java.lang.Thread.State: BLOCKED (en el monitor de objetos)
     en DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - esperando para bloquear &lt;0x00000000894465a0&gt; (un java.lang.Object)
     - bloqueado &lt;0x00000000894465b0&gt; (un java.lang.Object)
     en java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "DestroyJavaVM" # 14 prio = 5 os_prio = 0 tid = 0x00000250e54d0800 nid = 0x2b8c esperando en condici√≥n [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sincronizadores de propiedad bloqueados:
     - ninguno
 "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 ejecutable  
 "Tema de GC # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c ejecutable  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 ejecutable  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 ejecutable  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 ejecutable  
 "Marcador principal G1" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 ejecutable  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 ejecutable  
 "G1 Refine # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c ejecutable  
 "G1 Refine # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 ejecutable  
 "G1 Refine # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 ejecutable  
 "G1 Refine # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 ejecutable  
 "Muestreo RemSet Young G1" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 ejecutable  
 "Subproceso de tarea peri√≥dica de VM" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 esperando en condici√≥n  
 Referencias globales de JNI: 2
 Encontrado un punto muerto de nivel Java:
 ===============================
 "Hilo-0":
   esperando para bloquear el monitor 0x00000250e4982480 (objeto 0x00000000894465b0, un java.lang.Object),
   que est√° en manos de "Thread-1"
 "Hilo-1":
   esperando para bloquear el monitor 0x00000250e4982380 (objeto 0x00000000894465a0, un java.lang.Object),
   que est√° en manos de "Thread-0"
 Informaci√≥n de la pila de Java para los hilos enumerados anteriormente:
 =================================================== =
 "Hilo-0":
     en DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - esperando para bloquear &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - bloqueado &lt;0x00000000894465a0&gt; (un java.lang.Object)
     en java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Hilo-1":
     en DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - esperando para bloquear &lt;0x00000000894465a0&gt; (un java.lang.Object)
     - bloqueado &lt;0x00000000894465b0&gt; (un java.lang.Object)
     en java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Encontrado 1 punto muerto.
</pre><br><h3>  Informaci√≥n introductoria </h3><br>  Aunque a primera vista este archivo puede parecer demasiado complicado y confuso, en realidad es bastante simple si lo desmonta en partes paso a paso. <br><br>  La primera l√≠nea indica el momento en que se form√≥ el volcado, la segunda: informaci√≥n de diagn√≥stico sobre la JVM, en la que se recibi√≥ el volcado: <br><br><pre> <code class="hljs css">2018<span class="hljs-selector-tag"><span class="hljs-selector-tag">-06-19</span></span> 16<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Full</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Java</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">HotSpot</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TM</span></span>) 64<span class="hljs-selector-tag"><span class="hljs-selector-tag">-Bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Server</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VM</span></span> (10<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>+10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mixed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mode</span></span>):</code> </pre> <br>  No hay informaci√≥n de flujo en esta secci√≥n.  Aqu√≠ se establece el contexto general del sistema en el que se recopil√≥ el volcado. <br><br><h4>  Informaci√≥n general de flujo </h4><br>  La siguiente secci√≥n proporciona informaci√≥n sobre los subprocesos que se estaban ejecutando en el sistema en el momento de la recopilaci√≥n de volcados: <br><br><pre> Informaci√≥n de SMR de clase de subprocesos:
 _java_thread_list = 0x00000250e5488a00, longitud = 13, elementos = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
</pre><br>  La siguiente secci√≥n enumera: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informaci√≥n de recuperaci√≥n de memoria segura (SMR)</a> <br><br>  Contiene informaci√≥n sobre hilos fuera de la JVM, es decir.  estos no son hilos de m√°quinas virtuales o hilos de recolecci√≥n de basura.  Si observa las direcciones de estos subprocesos, notar√° que corresponden al valor de <i>tid</i> : la direcci√≥n ‚Äúnatural, de hierro‚Äù (nativa) en el sistema operativo y no la ID de subproceso. <br><br>  Las elipses se utilizan para ocultar informaci√≥n redundante: <br><br><pre> "Controlador de referencia" # 2 ... tid = 0x00000250e4979000 ...
 "Finalizador" # 3 ... tid = 0x00000250e4982800 ...
 "Despachador de se√±al" # 4 ... tid = 0x00000250e52f2800 ...
 "Adjuntar escucha" # 5 ... tid = 0x00000250e4992800 ...
 "C2 CompilerThread0" # 6 ... tid = 0x00000250e4995800 ...
 "C2 CompilerThread1" # 7 ... tid = 0x00000250e49a5800 ...
 "C1 CompilerThread2" # 8 ... tid = 0x00000250e49ae800 ...
 "Hilo de barrido" # 9 ... tid = 0x00000250e5324000 ...
 "Hilo de servicio" # 10 ... tid = 0x00000250e54cd800 ...
 "Limpiador com√∫n" # 11 ... tid = 0x00000250e54cf000 ...
 "Hilo-0" # 12 ... tid = 0x00000250e54d1800 ...
 "Hilo-1" # 13 ... tid = 0x00000250e54d2000 ...
 "DestroyJavaVM" # 14 ... tid = 0x00000250e54d0800 ...
</pre><br><h3>  Corrientes </h3><br>  Justo despu√©s del bloque SMR hay una lista de hilos.  El primer hilo de nuestra lista es el controlador de referencia: <br><br><pre> "Controlador de referencia" # 2 daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 esperando en condici√≥n [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     en java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     en java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     en java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     en java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Sincronizadores de propiedad bloqueados:
     - ninguno
</pre><br><h4>  Breve descripci√≥n de la transmisi√≥n. </h4><br>  La primera l√≠nea para cada hilo proporciona una descripci√≥n general.  La descripci√≥n contiene los siguientes elementos: <br><table><tbody><tr><th width="70">  Seccion </th><th width="100">  Ejemplo </th><th>  Descripci√≥n </th></tr><tr><td>  Nombre </td><td>  "Controlador de referencia" </td><td>  Nombre de secuencia legible para humanos.  El nombre se puede especificar llamando al m√©todo <i>setName</i> del objeto <i>Thread</i> .  Y recibe una llamada a <i>getName</i> </td></tr><tr><td>  ID </td><td>  # 2 </td><td>  Una identificaci√≥n √∫nica asignada a cada objeto de la clase <i>Thread</i> .  ID se genera para subprocesos en el sistema.  El valor inicial es 1. A cada subproceso reci√©n creado se le asigna su propia ID, previamente aumentada en 1. Esta propiedad de subproceso de solo lectura se puede obtener mediante la funci√≥n <i>getId</i> de <i>un</i> objeto de la clase <i>Subproceso</i> . </td></tr><tr><td>  Estado del demonio </td><td>  demonio </td><td>  La bandera es una se√±al de que el hilo es un demonio.  Si es un demonio, se establecer√° la bandera.  Por ejemplo, el hilo <i>-0</i> no <i>es</i> un demonio. </td></tr><tr><td>  Prioridad </td><td>  prio = 10 </td><td>  La prioridad num√©rica de la secuencia de Java.  Tenga en cuenta que esta prioridad no se corresponde necesariamente con la prioridad del subproceso asociado en el sistema operativo.  Para establecer la prioridad, puedes <br>  use el m√©todo <i>setPriority</i> de <i>un</i> objeto de clase <i>Thread</i> , y para obtener <br>  M√©todo <i>getPriority</i> . </td></tr><tr><td>  Prioridad de subproceso del sistema operativo </td><td>  os_prio = 2 </td><td>  Tema prioritario en el sistema operativo.  Esta prioridad puede diferir de la asignada al hilo de Java vinculado. </td></tr><tr><td>  Direcci√≥n </td><td>  tid = 0x00000250e4979000 </td><td>  La direcci√≥n de la secuencia de Java.  Esta direcci√≥n es un puntero al objeto nativo de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Interfaz nativa de Java (JNI)</a> de la clase <i>Thread</i> (un objeto <i>Thread</i> C ++ que est√° conectado al hilo Java a trav√©s de JNI).  Este valor se obtiene al lanzar un puntero a este <br>  (el objeto C ++ que est√° asociado con este hilo de Java) a entero.  Ver <br>  <a href="">l√≠nea 879 en hotspot / share / runtime / thread.cpp</a> : <br><pre> st-&gt; print ("tid =" INTPTR_FORMAT "", p2i (este));
</pre><br>  Aunque la clave para este objeto ( <i>tid</i> ) puede parecer una ID de flujo, <br>  de hecho, esta es la direcci√≥n del objeto conectado <i>JNI C ++ Thread</i> , y este no es el valor que <br>  devuelve el m√©todo <i>getId</i> del <i>hilo</i> Java. </td></tr><tr><td>  ID de subproceso del sistema operativo </td><td>  nid = 0x3c28 </td><td>  El identificador √∫nico del subproceso del sistema operativo al que est√° enlazado el subproceso Java. <br>  Este valor se genera con el siguiente c√≥digo: <br>  <a href="">l√≠nea 42 en hotspot / share / runtime / osThread.cpp</a> : <br><pre> st-&gt; print ("nid = 0x% x", thread_id ());
</pre><br></td></tr><tr><td>  Estado </td><td>  esperando en condici√≥n </td><td>  Estado legible por humanos del hilo actual. <br>  Esta l√≠nea muestra informaci√≥n adicional sobre el estado simple de la transmisi√≥n (ver m√°s abajo), que puede ser <br>  sol√≠a entender lo que iba a hacer el hilo (es decir, si el hilo intentaba obtener un bloqueo <br>  o esperando que se cumpla la condici√≥n de desbloqueo). </td></tr><tr><td>  √öltimo puntero de pila Java conocido </td><td>  [0x000000b82a9ff000] </td><td>  El √∫ltimo puntero de pila (SP) conocido asociado con esta secuencia. <br>  Este valor se obtiene usando c√≥digo nativo de C ++ mezclado con c√≥digo Java usando JNI.  El valor es devuelto por la funci√≥n <i>last_Java_sp ()</i> , <br>  <a href="">l√≠nea 2886 en hotspot / share / runtime / thread.cpp</a> : <br><pre>   st-&gt; print_cr ("[" INTPTR_FORMAT "]", 
     (intptr_t) last_Java_sp () &amp; ~ right_n_bits (12));
</pre><br>  Para volcados de subprocesos simples, esta informaci√≥n es casi in√∫til.  Sin embargo, en casos complejos, SP puede <br>  ser utilizado para rastrear cerraduras. </td></tr></tbody></table><br><h4>  Estado de la transmisi√≥n </h4><br>  La segunda l√≠nea es el estado actual de la secuencia.  Los posibles estados de flujo se enumeran en enum: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Hilo Estado</a> : <br><br>  Nuevo <br>  Ejecutable <br>  BLOQUEADO <br>  ESPERANDO <br>  TIMED_WAITING <br>  TERMINADO <br><br>  Consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">documentaci√≥n para</a> m√°s detalles. <br><br><h4>  Hilo de pila de seguimiento </h4><br>  La siguiente secci√≥n contiene el seguimiento de la pila de la secuencia en el momento en que se realiz√≥ el volcado.  Esta traza de pila es muy similar a una traza de pila, que se produce por una excepci√≥n no detectada.  Y contiene los nombres de clases y cadenas que se ejecutaron en el momento en que se form√≥ el volcado.  En el caso de la secuencia del controlador de referencia, no vemos nada interesante. <br><br>  Sin embargo, hay algo interesante sobre el rastreo de subprocesos Thread-02 que es diferente del rastreo est√°ndar: <br><br><pre> "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec esperando la entrada del monitor [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (en el monitor de objetos)
     en DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - esperando para bloquear &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - bloqueado &lt;0x00000000894465a0&gt; (un java.lang.Object)
     en java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Sincronizadores de propiedad bloqueados:
     - ninguno
</pre><br>  En el seguimiento, vemos que se ha agregado informaci√≥n sobre el bloqueo.  Este hilo espera un bloqueo en el objeto con la direcci√≥n 0x00000000894465b0 (tipo de objeto java.lang.Object).  Adem√°s, el hilo en s√≠ mismo mantiene el bloqueo con la direcci√≥n 0x00000000894465a0 (tambi√©n un objeto java.lang.Object).  Esta informaci√≥n nos ser√° √∫til m√°s adelante para el diagn√≥stico de punto muerto. <br><br><h4>  Primitivas de sincronizaci√≥n capturadas (Sincronizador propietario) </h4><br>  La √∫ltima secci√≥n enumera las primitivas de sincronizaci√≥n capturadas por la secuencia.  Estos son objetos que se pueden usar para sincronizar hilos, por ejemplo, bloqueos. <br><br>  De acuerdo con la documentaci√≥n oficial de Java, <strong>Ownable Synchronizer</strong> es descendiente de <i>AbstractOwnableSynchronizer</i> (o su subclase), que el flujo puede capturar exclusivamente para la sincronizaci√≥n. <br><br>  <i>ReentrantLock</i> y <i>write-lock</i> , pero no el <i>read-lock</i> de la clase <i>ReentrantReadWriteLock</i> son dos buenos ejemplos de tales "sincronizadores que se pueden usar" ofrecidos por la plataforma. <br><br>  Para obtener m√°s informaci√≥n sobre este tema, puede consultar este <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Publicar</a> <br><br><h4>  Subprocesos JVM </h4><br>  La siguiente secci√≥n del volcado contiene informaci√≥n sobre subprocesos t√©cnicos JVM que no son parte de la aplicaci√≥n y est√°n asociados con subprocesos del sistema operativo.  Porque  Estos flujos funcionan fuera de la aplicaci√≥n, no tienen identificadores de flujo.  Muy a menudo, estos son hilos de recolecci√≥n de basura y otros hilos t√©cnicos de JVM: <br><br><pre> "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 ejecutable  
 "Tema de GC # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c ejecutable  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 ejecutable  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 ejecutable  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 ejecutable  
 "Marcador principal G1" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 ejecutable  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 ejecutable  
 "G1 Refine # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c ejecutable  
 "G1 Refine # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 ejecutable  
 "G1 Refine # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 ejecutable  
 "G1 Refine # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 ejecutable  
 "Muestreo RemSet Young G1" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 ejecutable  
 "Subproceso de tarea peri√≥dica de VM" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 esperando en condici√≥n
</pre><br><h4>  Enlaces globales de JNI </h4><br>  Esta secci√≥n indica el n√∫mero de referencias globales utilizadas por la JVM a trav√©s de la JNI.  Estos enlaces no son atendidos por el recolector de basura y pueden causar una p√©rdida de memoria en ciertas circunstancias. <br><br><pre> Referencias globales de JNI: 2
</pre><br>  En la mayor√≠a de los casos simples, esta informaci√≥n no se utiliza.  Sin embargo, se debe entender la importancia de las referencias globales.  Vea esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">publicaci√≥n para</a> m√°s detalles. <br><br><h4>  Hilos estancados </h4><br>  La √∫ltima secci√≥n contiene informaci√≥n sobre puntos muertos encontrados. <br>  Si no se encuentran, la secci√≥n estar√° vac√≠a.  Porque  Desarrollamos espec√≠ficamente una aplicaci√≥n con bloqueos, en nuestro caso esta secci√≥n es.  Se detect√≥ un bloqueo durante el volcado y se le presenta el siguiente mensaje: <br><br><pre> Encontrado un punto muerto de nivel Java:
 ===============================
 "Hilo-0":
   esperando para bloquear el monitor 0x00000250e4982480 (objeto 0x00000000894465b0, un java.lang.Object),
   que est√° en manos de "Thread-1"
 "Hilo-1":
   esperando para bloquear el monitor 0x00000250e4982380 (objeto 0x00000000894465a0, un java.lang.Object),
   que est√° en manos de "Thread-0"
 Informaci√≥n de la pila de Java para los hilos enumerados anteriormente:
 =================================================== =
 "Hilo-0":
     en DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - esperando para bloquear &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - bloqueado &lt;0x00000000894465a0&gt; (un java.lang.Object)
     en java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Hilo-1":
     en DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - esperando para bloquear &lt;0x00000000894465a0&gt; (un java.lang.Object)
     - bloqueado &lt;0x00000000894465b0&gt; (un java.lang.Object)
     en java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Encontrado 1 punto muerto.
</pre><br>  La primera subsecci√≥n describe el escenario de punto muerto: <br><br>  Thread-0 espera poder capturar el monitor (este es un acceso al bloque <i>sincronizado (secondResource)</i> en nuestra aplicaci√≥n), al mismo tiempo, este hilo tiene un monitor que intenta capturar el Thread-1 (est√° accediendo al mismo fragmento de c√≥digo: <i>sincronizado (secondResource )</i> en nuestra aplicaci√≥n). <br><br>  Este bloqueo circular tambi√©n se llama <strong>punto muerto</strong> .  En la imagen de abajo <br>  Esta situaci√≥n se presenta en forma gr√°fica: <br><br><img src="https://habrastorage.org/webt/11/yd/kr/11ydkrm0xkbw8aqxb8t71kypskg.png"><br><br>  En la segunda subsecci√≥n, se da seguimiento de pila para ambos subprocesos bloqueados. <br><br>  Este seguimiento de la pila nos permite rastrear el funcionamiento de cada subproceso hasta que se produce un bloqueo. <br>  En nuestro caso, si miramos la l√≠nea: <br><br>  <i>en DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)</i> , luego veremos la parte del problema del c√≥digo: <br><br><pre> printLockedResource (secondResource);
</pre><br>  Esta l√≠nea es la primera l√≠nea del bloque sincronizado, que es la raz√≥n del bloqueo, y nos dice que la sincronizaci√≥n en el segundo recurso es la raz√≥n del bloqueo mutuo.  Para remediar la situaci√≥n, debemos asegurarnos de que ambos hilos tengan el mismo orden de sincronizaci√≥n en los recursos resourceA y resourceB.  Si hacemos esto, llegaremos a la siguiente aplicaci√≥n: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Esta aplicaci√≥n finalizar√° sin enclavamiento, y como resultado obtendremos el siguiente resultado (tenga en cuenta que las direcciones de la clase Object han cambiado): <br><br><pre> Hilo-0: recurso bloqueado -&gt; java.lang.Object@1ad895d1
 Hilo-0: recurso bloqueado -&gt; java.lang.Object@6e41d7dd
 Hilo-1: recurso bloqueado -&gt; java.lang.Object@1ad895d1
 Hilo-1: recurso bloqueado -&gt; java.lang.Object@6e41d7dd
</pre><br>  ,   ,   thread dump,           .        (     deadlock-).      ,   . <br><br><h3>    Thread Dump- </h3><br>         . <br><br>   JVM       .         (     ,   ). <br><br>         . <br><br>       - ‚Äî Thread Dump Analyzers (TDAs).    Java thread dump-     - ,     .  ,           . ,        . <br><br>        TDA: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">fastThread</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Spotify TDA</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">IBM Thread and Monitor Dump Analyze for Java</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">irockel TDA</a> </li></ul><br>        .               . <br><br><h4>  Conclusi√≥n </h4><br> Thread dump- ‚Äî      Java-,       .     ,           . <br><br>        deadlock,    .         .     ,           ‚Äî . <br><br>   ,   Java-     thread dump-.     ,             . <br><br> , thread dump ‚Äî   ¬´ ¬ª   ,        ,      Java-. <br><br> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> Java</a>     .       ,        deadlock- .</i> <br><br> <i>      ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427513/">https://habr.com/ru/post/es427513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427499/index.html">¬øSobre qu√© escriben en el soporte t√©cnico del transmisor de video?</a></li>
<li><a href="../es427501/index.html">Seymour Papert: diversi√≥n dura</a></li>
<li><a href="../es427505/index.html">Presunci√≥n de mente</a></li>
<li><a href="../es427507/index.html">Seymour Papert: el delicioso descubrimiento de "Nothing"</a></li>
<li><a href="../es427509/index.html">Servidores web: experiencia y pr√°ctica de Southbridge</a></li>
<li><a href="../es427517/index.html">Resumen de los informes m√°s interesantes de Joker 2018: versi√≥n de EastBanc Technologies</a></li>
<li><a href="../es427519/index.html">@Kubernetes Meetup en Mail.Ru Group: 29 de octubre y siempre</a></li>
<li><a href="../es427521/index.html">Breakthrough Prize 2019. Anunciados los ganadores del Premio de Ciencias Milner, Brin y Zuckerberg.</a></li>
<li><a href="../es427523/index.html">√âxito de cobertura</a></li>
<li><a href="../es427525/index.html">Intel Core 9th Gen en n√∫meros y puntos de referencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>