<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥩 🤱🏾 👴🏽 Akselerasi SQLAlchemy untuk Astronot Arsitektur 🧑🏾‍🤝‍🧑🏼 📬 👩‍👩‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habr, ini adalah laporan oleh insinyur perangkat lunak Alexei Starkov pada konferensi Moscow Python Conf ++ 2018 di Moskow. Video di akhir pos.  Halo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Akselerasi SQLAlchemy untuk Astronot Arsitektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/430818/"><img src="https://habrastorage.org/webt/nk/mr/3o/nkmr3o45oaha-8h6n1elhxx3nai.png"><br><blockquote> Habr, ini adalah laporan oleh insinyur perangkat lunak Alexei Starkov pada konferensi Moscow Python Conf ++ 2018 di Moskow.  Video di akhir pos. </blockquote>  Halo semuanya!  Nama saya Alexei Starkov - ini saya, dalam tahun-tahun terbaik saya, saya bekerja di sebuah pabrik. <br>  Sekarang saya bekerja di Qrator Labs.  Pada dasarnya, sepanjang hidup saya, saya belajar C dan C ++ - Saya suka Alexandrescu, The Gang of Four, prinsip-prinsip SOLID - itu saja.  Yang membuat saya menjadi astronot arsitektur.  Saya telah menulis Python selama beberapa tahun terakhir karena saya menyukainya. <br><br>  Sebenarnya, siapa "kosmonot arsitektur"?  Pertama kali saya bertemu dengan Joel Spolsky, Anda mungkin membacanya.  Dia menggambarkan "astronot" sebagai orang yang ingin membangun arsitektur yang ideal, yang menggantung abstraksi, atas abstraksi, atas abstraksi, yang menjadi semakin umum.  Pada akhirnya, level ini sangat tinggi sehingga menggambarkan semua program yang mungkin, tetapi tidak menyelesaikan masalah praktis.  Pada saat ini, "astronot" (ini terakhir kali istilah ini dikelilingi oleh tanda kutip) kehabisan udara dan dia mati. <br><br>  Saya juga memiliki kecenderungan ke arah eksplorasi ruang arsitektur, tetapi dalam laporan ini saya akan berbicara sedikit tentang bagaimana itu menggigit saya dan tidak memungkinkan saya untuk membangun sebuah sistem dengan kinerja yang diperlukan.  Yang utama adalah bagaimana saya mengatasinya. <br><br>  Ringkasan laporan saya: was / was. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/wj/_u/7c/wj_u7c0h2uaody3dj48xsbytsb4.png"><br><br>  Peningkatan ribuan dan jutaan kali.  Ketika saya membuat slide ini, satu-satunya pikiran saya adalah "Bagaimana?" <br><br><img src="https://habrastorage.org/webt/of/cb/q_/ofcbq_bd033u4wh31hzexjkstfc.png"><br><br>  Di mana saya bisa begitu banyak mengacau?  Jika Anda tidak ingin mengacaukan seperti saya - baca terus. <br><br><img src="https://habrastorage.org/webt/md/ni/gt/mdnigtyu3igzmlqmcf89isptecc.png"><br><br>  Saya akan berbicara tentang sistem konfigurasi.  Sistem konfigurasi adalah alat internal di Qrator Labs yang menyimpan konfigurasi untuk Software Defined Network (SDN) - jaringan penyaringan kami.  Ini berkomitmen untuk menyinkronkan konfigurasi antara komponen dan memonitor statusnya. <br><br><img src="https://habrastorage.org/webt/xz/kg/zr/xzkgzr2wrphmvslxnx3v2qezxta.png"><br><br>  Singkatnya, terdiri dari apa itu?  Kami memiliki database yang menyimpan snapshot dari konfigurasi kami untuk seluruh jaringan, dan kami memiliki server yang memproses perintah yang datang kepadanya dan entah bagaimana mengubah konfigurasi. <br><br>  Administrator teknis dan klien kami datang ke server ini dan menggunakan konsol, melalui API titik akhir, API REST, JSON RPC, dan hal-hal lain, mengeluarkan perintah ke server, sehingga mengubah konfigurasi kami. <br><br>  Tim bisa sangat sederhana atau lebih rumit.  Kemudian, kami memiliki satu set penerima yang membentuk SDN kami dan server mendorong konfigurasi ke penerima ini.  Itu terdengar sangat sederhana.  Pada dasarnya, saya akan berbicara tentang bagian ini. <br><br><img src="https://habrastorage.org/webt/yp/uq/c7/ypuqc7pzaeqvmbzsrksb9gefq-w.png"><br><br>  Karena dialah yang terkait dengan database dan alkimia. <br><br><img src="https://habrastorage.org/webt/qg/sz/np/qgsznprvrp4smdpbuoxopevxxt4.png"><br><br>  Apa kekhasan sistem ini?  Cukup kecil - biasa-biasa saja.  Ratusan ribu, hingga jutaan, entitas disimpan dalam database ini.  Keunikannya adalah grafik hubungan antar entitas cukup kompleks.  Ada beberapa hierarki pewarisan antara entitas, ada inklusi, hanya ada dependensi di antara entitas.  Semua batasan ini ditentukan oleh logika bisnis dan kita harus mematuhinya. <br><br>  Rasio permintaan tulis untuk membaca permintaan adalah sekitar 15: 1.  Ini jelas: ada banyak perintah untuk mengubah konfigurasi dan sekali dalam jangka waktu tertentu kami memiliki konfigurasi push ke titik akhir. <br><br>  MySQL digunakan secara internal - juga tersedia di produk-produk lain dari perusahaan kami, kami memiliki keahlian yang cukup serius pada database ini, ada orang yang dapat bekerja dengannya: membangun skema data, permintaan desain, dan yang lainnya.  Oleh karena itu, kami menggunakan MySQL sebagai basis data relasional universal. <br><br><img src="https://habrastorage.org/webt/x0/xs/ae/x0xsae3wqaqw4dfth-y8q7i3tqk.png"><br><br>  Apa masalahnya setelah kami merancang sistem ini?  Eksekusi satu perintah memakan waktu dari satu hingga tiga puluh detik, tergantung pada kompleksitas tim.  Dengan demikian, penundaan eksekusi mencapai lima menit.  Satu tim tiba - 30 detik, yang kedua dan seterusnya, setumpuk akumulasi - penundaan 5 menit. <br><br>  Keterlambatan dalam menerapkan konfigurasi hingga sepuluh menit.  Diputuskan bahwa ini tidak cukup bagi kami dan bahwa optimasi diperlukan. <br><br><img src="https://habrastorage.org/webt/ah/6t/fj/ah6tfjmleq-fzvoecldzw5qxxu0.png"><br><br>  Pertama, sebelum melakukan optimasi apa pun, perlu untuk melakukan penyelidikan dan mencari tahu apa yang sebenarnya terjadi. <br><br><img src="https://habrastorage.org/webt/nu/wf/g6/nuwfg6v2hg2jangw6agmu9i6bw0.png"><br><br>  Ternyata, kami tidak memiliki komponen yang paling penting untuk penyelidikan - kami tidak memiliki telemetri.  Karena itu, jika Anda merancang semacam sistem, pertama, pada tahap desain, masukkan telemetri ke dalamnya.  Sekalipun sistem awalnya kecil, lalu sedikit lagi, lalu bahkan lebih lagi - pada akhirnya, semua orang sampai pada situasi di mana Anda perlu menonton trek, tetapi tidak ada telemetri. <br><br><img src="https://habrastorage.org/webt/eh/ws/3t/ehws3tezqmrdlvfcljs1pxbttgm.png"><br><br>  Apa yang dapat dilakukan selanjutnya jika Anda tidak memiliki telemetri?  Anda dapat menganalisis log.  Di sini, skrip yang cukup sederhana memeriksa log kami dan mengubahnya menjadi tabel seperti itu, menggambarkan waktu eksekusi perintah tercepat, paling lambat, dan rata-rata.  Mulai dari sini, kita sudah bisa melihat di mana kita memiliki lelucon: tim mana yang membutuhkan waktu lebih lama untuk mengeksekusi, mana yang lebih cepat. <br><br><img src="https://habrastorage.org/webt/m6/0a/gc/m60agccykga4hl82ktrjfjglzqq.png"><br><br>  Satu-satunya hal yang perlu diperhatikan adalah ketika menganalisis log, kami hanya mempertimbangkan waktu eksekusi dari perintah-perintah ini di server.  Ini adalah tahap pertama - yang ditandai sebagai t2.  t1 - ini adalah bagaimana klien akan melihat waktu eksekusi tim kami: masuk ke antrian, menunggu, eksekusi di server.  Waktu ini akan lebih lama, jadi kami mengoptimalkan waktu t2, dan kemudian menggunakan waktu t1 untuk menentukan apakah kami telah mencapai tujuan. <br><br>  t1 adalah metrik kualitas kinerja kami. <br><br><img src="https://habrastorage.org/webt/dx/dd/05/dxdd05sisxq1ciu6nu-na0zons8.png"><br><br>  Dengan demikian, ini adalah bagaimana kami membuat profil semua tim - yaitu, kami mengambil log dari server, mengendarainya melalui skrip kami, melihat dan mengidentifikasi komponen yang bekerja paling lambat.  Server dibangun cukup modular, komponen terpisah bertanggung jawab untuk setiap perintah, dan kami dapat membuat profil komponen secara terpisah - dan membuat tolok ukur untuknya.  Jadi di sini kami memiliki kelas - untuk setiap komponen bermasalah yang kami tulis di mana dalam code_under_test () kami melakukan beberapa kegiatan yang menggambarkan penggunaan komponen tempur.  Dan ada dua metode: profil () dan bangku ().  Panggilan pertama cProfile, menunjukkan berapa kali apa yang dipanggil, di mana kemacetan berada. <br><br>  bench () dijalankan beberapa kali dan dianggap metrik yang berbeda untuk kami - ini adalah cara kami mengevaluasi kinerja. <br><br>  Tapi ternyata ini bukan masalahnya! <br><br><img src="https://habrastorage.org/webt/wz/r8/-p/wzr8-pc9epal61cjoraog7bkvxc.png"><br><br>  Masalah utama adalah jumlah permintaan basis data.  Ada banyak permintaan, dan untuk memahami mengapa ada begitu banyak, mari kita lihat bagaimana semuanya diatur. <br><br><img src="https://habrastorage.org/webt/bg/r0/rz/bgr0rzhohcouyykpc3raznbi4rq.png"><br><br>  Di depan kita ada sepotong sirkuit sederhana yang mewakili penerima kita, disajikan dalam bentuk kelas Penerima.  Mereka disatukan dalam beberapa grup - grup penerima.  Dan, dengan demikian, ada beberapa bidang konfigurasi - potongan konfigurasi, yang merupakan bagian dari konfigurasi yang bertanggung jawab untuk satu "peran" penerima ini.  Misalnya saja untuk routing - routing plane.  Dataran dengan penerima dapat dihubungkan dalam urutan apa pun - yaitu, ini adalah hubungan banyak-ke-banyak. <br><br>  Ini adalah bagian dari garis besar yang saya presentasikan di sini sehingga contoh-contoh dapat dipahami lebih lanjut. <br><br>  Apa yang ingin dilakukan setiap kosmonot arsitektur ketika dia melihat API orang lain?  Dia ingin menyembunyikannya, abstrak dan menulis antarmuka-nya agar dapat menghapus API ini, atau lebih tepatnya menyembunyikannya. <br><br><img src="https://habrastorage.org/webt/nq/zq/7-/nqzq7-zlnbxkkmy7mywbp8lqvq4.png"><br><br>  Oleh karena itu, ada API alkimia "kotor", di mana ada, pada kenyataannya, pemetaan dan kelas "murni" kami - Receiver, di mana beberapa konfigurasi disimpan dan ada metode: load (), save (), save (), delete ().  Dan semua kelas lain yang terkait dengannya.  Kami mendapatkan grafik objek Python, yang entah bagaimana terhubung satu sama lain - masing-masingnya memiliki metode load (), save (), delete (), yang mengacu pada mapper alkimia, yang, pada gilirannya, memanggil API. <br><br><img src="https://habrastorage.org/webt/cs/bo/lr/csbolr6uozuvbxhimmqik_llgak.png"><br><br>  Implementasinya di sini sangat sederhana.  Kami memiliki metode memuat yang membuat kueri ke database dan untuk setiap objek yang diterima membuat objek Python sendiri.  Ada metode simpan yang melakukan operasi yang berlawanan - terlihat jika ada objek dalam database menggunakan kunci utama, jika tidak - itu membuat, menambah, dan kemudian kita menyimpan keadaan objek ini.  hapus pada kunci utama menerima dan menghapus objek dari database. <br><br><img src="https://habrastorage.org/webt/fl/hq/lp/flhqlp2vg6srgo7wswpbowrlq6e.png"><br><br>  Masalah utama segera terlihat - ini adalah pemetaan.  Pertama, kita melakukannya sekali dari objek Python ke mapper, lalu mapper ke pangkalan.  Pemetaan tambahan adalah satu atau dua panggilan, yang mungkin belum menakutkan.  Masalah utama adalah sinkronisasi manual.  Kami memiliki dua objek antarmuka "bersih" dan salah satunya mengubah atribut - bagaimana kita melihat bahwa atribut telah berubah di yang lain?  Tidak mungkin.  Hal ini diperlukan untuk menggabungkan perubahan ke dalam basis data dan mendapatkan atribut di objek lain.  Tentu saja, jika kita tahu bahwa objek hadir dalam konteks yang sama, kita dapat melacaknya.  Tetapi jika kita memiliki dua sesi di tempat yang berbeda - hanya melalui pangkalan, atau memblokir pangkalan di memori, yang tidak kita lakukan. <br><br>  Load / save / delete ini adalah mapper lain yang sepenuhnya menduplikasi bagian dalam alkimia, yang ditulis dengan baik, diuji.  Alat ini sudah berumur bertahun-tahun, ada banyak bantuan di internet dan menggandakannya juga tidak terlalu bagus. <br><br>  Lihat ikon di sudut kanan atas?  Jadi saya akan menandai slide di mana sesuatu dilakukan untuk "kemurnian", untuk meningkatkan tingkat abstraksi, untuk astronotika arsitektur.  Artinya, slide tanpa ikon ini bersifat pragmatis dan membosankan, tidak menarik dan tidak bisa dibaca. <br><br>  Apa yang harus dilakukan jika banyak pertanyaan lambat.  Berapa banyak?  Sebenarnya banyak.  Bayangkan sebuah rantai warisan: satu objek, ia memiliki satu orangtua, bahwa satu memiliki orangtua lain.  Kami menyinkronkan objek anak - untuk melakukan ini, Anda harus terlebih dahulu menyinkronkan orang tua.  Untuk menyinkronkan induk, Anda perlu menyinkronkan induknya.  Yah, semua orang disinkronkan.  Faktanya, tergantung pada bagaimana kita telah membangun grafik, kita dapat berjalan dan menyinkronkan semua objek ini seratus kali - karenanya sejumlah besar permintaan. <br><br><img src="https://habrastorage.org/webt/zo/n7/uh/zon7uhhtngwjd5rnaztxexuatsu.png"><br><br>  Apa yang telah kita lakukan  Kami mengambil semua logika bisnis kami dan memasukkannya ke mapper.  Semua objek lain di sini juga bergabung dengan pemetaan, dan seluruh API kami, seluruh lapisan abstraksi data, ternyata kotor. <br><br><img src="https://habrastorage.org/webt/qn/4a/fz/qn4afzy7q6yrh0t-yw4r4m6c9se.png"><br><br>  Ini adalah tampilannya di Python - mapper kami memiliki semacam logika bisnis, ada deskripsi deklaratif dari plat ini di sana.  Kolom terdaftar, hubungan.  Di sini kita memiliki kelas seperti itu. <br><br><img src="https://habrastorage.org/webt/ez/ud/sg/ezudsgqk1b9domctg8sdvzh4uj8.png"><br><br>  Tentu saja, dari sudut pandang astronot mana pun, API yang kotor adalah kelemahannya.  Logika bisnis dalam deskripsi deklaratif dari pangkalan.  Skema dicampur dengan logika bisnis.  Fiuh.  Jelek. <br><br>  Deskripsi sirkuit berantakan.  Ini sebenarnya masalah - jika logika bisnis tidak memiliki dua baris, tetapi volume yang lebih besar, maka di kelas ini kita perlu menggulir atau mencari waktu yang sangat lama untuk mendapatkan deskripsi spesifik.  Sebelum itu, semuanya indah: di satu tempat deskripsi dasar, deklaratif, deskripsi skema, di tempat lain logika bisnis.  Dan kemudian sirkuit itu berantakan. <br><br>  Tetapi, di sisi lain, kami segera mendapatkan mekanisme alkimia: unit kerja, yang memungkinkan Anda untuk melacak objek mana yang kotor dan relay mana yang perlu diperbarui;  kami mendapatkan hubungan yang memungkinkan kami untuk menyingkirkan pertanyaan tambahan dalam database, tanpa memastikan bahwa koleksi yang relevan diisi;  dan peta identitas yang paling membantu kami.  Peta identitas memastikan bahwa dua objek Python akan menjadi objek Python yang sama jika mereka memiliki kunci utama yang sama. <br><br>  Oleh karena itu, kami segera mengurangi kompleksitas menjadi linier. <br><br><img src="https://habrastorage.org/webt/j4/ek/x8/j4ekx8dvwphpdavetrxejd1uvxg.png"><br><br>  Ini adalah hasil antara.  Kinerja segera meningkat 10 kali lipat, jumlah permintaan ke database turun sekitar 40-80 kali dan RPS naik menjadi 1-5.  Bagus  Tapi APInya kotor.  Apa yang harus dilakukan <br><br><img src="https://habrastorage.org/webt/kj/po/hs/kjpohswqs8svlzroeizbub0tpmk.png"><br><br>  Mixin.  Kami mengambil logika bisnis, sekali lagi kami menghapusnya dari mapper kami, tetapi agar tidak ada pemetaan lagi, kami akan mewarisi mapper kami di dalam alkimia dari mixin kami.  Kenapa tidak sebaliknya?  Ini tidak akan bekerja dalam alkimia, dia akan bersumpah dan berkata: "Anda memiliki dua kelas yang berbeda mengacu pada satu tablet, tidak ada polyformism - pergi dari sini."  Jadi - itu mungkin. <br><br>  Dengan demikian, kami memiliki deskripsi deklaratif di mapper, yang diwarisi dari mixin dan menerima semua logika bisnis.  Sangat nyaman  Dan kelas-kelas lainnya persis sama.  Tampaknya - keren, semuanya bersih.  Tetapi ada satu peringatan - koneksi dan relay tetap di dalam alkimia, dan ketika kita, katakanlah, bergabung melalui tabel sekunder plat menengah, maka mapper dari plat ini entah bagaimana akan ada dalam kode klien, yang tidak terlalu indah. <br><br>  Alkimia tidak akan menjadi kerangka kerja yang baik, terkenal, jika itu tidak memberi saya kesempatan untuk melawan ini. <br><br><img src="https://habrastorage.org/webt/g6/dz/gg/g6dzggup-pvokdl7h4mguhedazc.png"><br><br>  Seperti apa bentuk mixin.  Dia memiliki logika bisnis, pemetaan secara terpisah, deskripsi deklaratif piring.  Koneksi tetap dalam alkimia, tetapi logika bisnis terpisah. <br><br>  Seperti apakah garis besar umum itu? <br><br><img src="https://habrastorage.org/webt/xl/1c/eh/xl1cehyjtaoqytk_gz5h-wbc5we.png"><br><br>  Kami memiliki file dengan skema di mana semua kelas deklaratif kami dikumpulkan - sebut saja schema.py.  Dan kami memiliki entitas dalam logika bisnis, secara terpisah.  Dan, entitas ini diwarisi di dalam file skema - kami menulis kelas terpisah untuk setiap entitas, dan mewarisinya dalam skema.  Dengan demikian, logika bisnis terletak di satu tumpukan, skema di yang lain dan mereka dapat diubah secara independen. <br><br><img src="https://habrastorage.org/webt/rj/cl/ql/rjclqll79e8wcjwkjfxova8hhpe.png"><br><br>  Sebagai contoh peningkatan, kami akan mempertimbangkan skema sederhana dari dua label: penerima (tabel Receiver) dan potongan konfigurasi (tabel ReceiverPlanes).  Irisan konfigurasi banyak-ke-satu dikaitkan dengan label receiver.  Tidak ada yang rumit. <br><br>  Untuk menyembunyikan hubungan di dalam antarmuka alkimia yang "kotor", kami menggunakan hubungan dan koleksi. <br><br><img src="https://habrastorage.org/webt/mz/ih/qg/mzihqg-lfqb8vhflbkxjpf8igp8.png"><br><br>  Mereka memungkinkan kita untuk menyembunyikan pembuat peta kita dari kode klien. <br><br><img src="https://habrastorage.org/webt/y8/qc/v1/y8qcv1qj8_jq3y_pn-2xw-t6bji.png"><br><br>  Secara khusus, dua koleksi yang sangat berguna adalah association_proxy dan atribut_mapped_collection.  Kami menggunakannya bersama.  Bagaimana hubungan klasik bekerja dalam alkimia: kita memiliki hubungan - ini adalah kumpulan, daftar, pemetaan tertentu.  Pemetaan adalah objek hubungan ujung-jauh.  Attribute_mapped_collection memungkinkan Anda mengganti daftar ini dengan dict, kunci yang akan menjadi beberapa atribut pemetaan, dan nilainya adalah pemetaan itu sendiri. <br><br>  Ini adalah langkah pertama. <br><br><img src="https://habrastorage.org/webt/ho/tj/tt/hotjtty0hmg99f_kquecwyo4ms4.png"><br><br>  Langkah kedua, kami melakukan asosiasi_proksi atas hubungan ini.  Ini memungkinkan kita untuk tidak meneruskan mapper ke koleksi, tetapi untuk memberikan beberapa nilai yang nantinya akan digunakan untuk menginisialisasi mapper kita, ReceiverPlanes. <br><br>  Di sini kita memiliki lambda, di mana kita memberikan kunci dan nilai.  Kunci berubah menjadi nama irisan konfigurasi, dan nilai menjadi nilai irisan konfigurasi.  Akibatnya, dalam kode klien, semuanya terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/ko/00/s7/ko00s71bgaxu6i-h_baocnnqz-w.png"><br><br>  Kami hanya menempatkan semacam dikte dalam semacam kamus.  Semuanya berfungsi: tidak ada pemetaan, tidak ada alkimia, tidak ada database. <br><br>  Benar, ada jebakan. <br><br><img src="https://habrastorage.org/webt/ux/ji/uy/uxjiuybsymdbtrvqlazqhckdv8c.png"><br><br>  Jika kita menetapkan nilai yang berbeda, atau bahkan satu, ke kunci yang sama dua kali - lambda dipanggil untuk setiap item set tersebut, sebuah objek dibuat - seorang mapper.  Dan, tergantung pada bagaimana skema disusun, ini dapat menyebabkan berbagai konsekuensi, dari "pelanggaran konstanta" hingga konsekuensi yang tidak terduga.  Misalnya, Anda semacam menghapus objek dari koleksi, tetapi masih ada di sana: Anda hanya menghapus satu.  Ketika saya mulai, saya menghabiskan banyak waktu untuk hal-hal seperti itu. <br><br>  Dan sedikit sinkronisasi implisit.  Association_proxy dan atribut_mapped_collection mungkin sedikit tertunda: ketika kita membuat objek mapper - itu ditambahkan ke database, tetapi belum hadir dalam atribut koleksi.  Itu akan muncul di sana hanya ketika atribut berakhir pada sesi ini.  Ketika kedaluwarsa, sinkronisasi baru dengan database akan terjadi dan itu akan sampai di sana. <br><br>  Untuk mengatasi ini, kami menggunakan koleksi kami sendiri yang ditulis sendiri.  Ini bahkan bukan alkimia - Anda bisa membuat koleksi sendiri untuk mengatasi semua ini. <br><br><img src="https://habrastorage.org/webt/bk/l6/ya/bkl6yaerwagttjp6qprlfbsdpaw.png"><br><br>  Ada lebih banyak kode dan bagian terpenting disorot.  Kami memiliki koleksi tertentu yang diwarisi dari pemetaan bisu - ini adalah dict, di mana Anda dapat mengubah nilainya.  Dan ada metode _get_plane_obj - untuk mendapatkan objek konfigurasi slice. <br><br>  Di sini kami melakukan hal-hal sederhana - kami mencoba untuk mendapatkannya dengan nama, dengan beberapa kunci utama dan, jika tidak, maka kami membuat dan mengembalikan objek ini. <br><br>  Selanjutnya, kami mendefinisikan ulang hanya dua metode: __setitem__ dan __getitem__ <br>  Dalam __setitem__, kami menempatkan benda-benda ini dalam koleksi kami, dalam suatu hubungan.  Satu-satunya hal adalah kami memberikan nilai di bagian paling akhir.  Jadi, kami menerapkan mekanisme yang sama dengan associ_proxy - meneruskan nilainya, dict sana, dan ditugaskan ke atribut yang sesuai. <br><br>  __getitem__ melakukan manipulasi balik.  Ini menerima dengan kunci beberapa objek dari relay dan mengembalikan atributnya.  Ada juga jebakan kecil di sini - jika Anda cache koleksi di dalam pemetaan kami, mungkin untuk keluar dari sinkronisasi sedikit.  Karena ketika atribut koleksi kedaluwarsa dalam alkimia, koleksi diganti dengan yang lain, setelah kedaluwarsa.  Oleh karena itu, kami dapat menyimpan referensi ke koleksi lama dan tidak tahu bahwa yang lama telah kedaluwarsa dan yang baru telah muncul.  Oleh karena itu, pada bagian terakhir, kita langsung menuju contoh alkimia, sekali lagi kita mendapatkan koleksi melalui __getattr__ dan kita melakukan __getitem__ dengan itu.  Artinya, kami tidak dapat men-cache koleksi Planes di sini. <br><br><img src="https://habrastorage.org/webt/_0/l6/tt/_0l6tt3pcdjmsxlwy2hivf1b4ty.png"><br><br>  Bagaimana koleksi ini menampar mixin kami?  Seperti biasa - mengatur atribut koleksi.  Satu-satunya tempat yang menarik adalah ketika kita memuat instance dari database, metode __init__ tidak dipanggil.  Semua atribut diganti ex post. <br><br>  Alchemy memberikan dekorator pengarah standar, yang memungkinkan Anda menandai beberapa metode yang dipanggil setelah memuat objek dari basis data.  Dan saat boot kita harus menginisialisasi koleksi kita.  Diri hanyalah contoh itu.  Penggunaannya persis sama seperti pada contoh sebelumnya. <br><br><img src="https://habrastorage.org/webt/qe/yr/h4/qeyrh4fd3cmfpm8-exbfd1rwpkw.png"><br><br>  Namun dalam skema kami, telinga basis data masih terlihat - ini adalah konfigurasi.  Jenis konfigurasi apa?  Apakah itu varchar atau itu gumpalan?  Faktanya, klien tidak tertarik.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia harus bekerja dengan entitas abstrak dari levelnya. Untuk ini, alkimia menyediakan jenis dekorasi. </font></font><br><br><img src="https://habrastorage.org/webt/ds/lc/ic/dslcicbf3yrljfchfwbxhcucleq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh sederhana. Basis data kami menyimpan IPAddress sebagai varchar. Kami menggunakan kelas TypeDecorator, yang merupakan bagian dari alkimia, yang memungkinkan, pertama, untuk menunjukkan tipe database yang mendasari yang akan digunakan untuk tipe ini dan, kedua, untuk mendefinisikan dua parameter: process_bind_param mengonversi nilai ke tipe database dan process_result_value saat kami menilai dari jenis database, konversikan ke objek Python.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribut dari alamat mengambil tipe python IPAddress. Dan kita bisa memanggil metode jenis ini, dan menetapkan objek jenis ini untuknya, dan semuanya bekerja untuk kita. Dan itu disimpan dalam database ... Saya tidak tahu apa yang disimpan, varchar (45), tetapi kita bisa mengganti garis itu dan gumpalan itu akan disimpan. Atau jika beberapa tipe asli mendukung alamat IP, maka Anda dapat menggunakannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode klien tidak tergantung pada ini, tidak perlu ditulis ulang. </font></font><br><br><img src="https://habrastorage.org/webt/xb/m5/uu/xbm5uu_ryeji94kthsv0rp2ogdw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal lain yang menarik adalah kami memiliki versi. Kami ingin itu segera setelah kami mengubah objek kami, versi segera meningkat. Kami memiliki beberapa penghitung versi, kami mengubah objek - ia telah berubah, versinya telah meningkat. Kami melakukan ini secara otomatis agar tidak lupa.</font></font><br><br><img src="https://habrastorage.org/webt/zy/g5/ro/zyg5rofkv1ibi-yb-kuv3kikbww.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk ini, kami menggunakan acara. Peristiwa adalah peristiwa yang terjadi pada berbagai tahap kehidupan mapper dan mereka dapat dipicu ketika atribut berubah, ketika suatu entitas berubah dari satu negara ke yang lain, misalnya, "dibuat", "disimpan ke database", "dimuat dari database", "dihapus"; dan juga - pada acara tingkat sesi, sebelum kode sql dipancarkan ke database, sebelum komit, setelah komit, dan juga setelah rollback. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alkimia memungkinkan kita untuk menetapkan penangan untuk semua peristiwa ini, tetapi urutan penangan dieksekusi untuk acara yang sama tidak dijamin. Artinya, itu spesifik, tetapi tidak diketahui yang mana. Karena itu, jika perintah eksekusi penting bagi Anda, maka Anda perlu melakukan mekanisme pendaftaran. </font></font><br><br><img src="https://habrastorage.org/webt/wb/h2/w1/wbh2w1k4s4y6jqemt4oatlknwug.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini sebuah contoh. Tiga acara digunakan di sini:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on_before_flush - sebelum kode sql dipancarkan ke database, kita melihat semua objek yang alkimia ditandai sebagai kotor dalam sesi ini dan memeriksa apakah objek ini dimodifikasi atau tidak. Mengapa ini perlu jika alkimia telah menandai segalanya? Alkimia menandai sebuah objek kotor segera setelah beberapa atribut berubah. Jika kami memberikan nilai yang sama untuk atribut ini, atribut itu akan ditandai sebagai kotor. Ada metode sesi is_modified untuk ini - ini digunakan secara internal, saya tidak menggambarnya. Lebih jauh, dari sudut pandang semantik kita, dari sudut pandang logika bisnis kita, bahkan jika atributnya telah berubah, objeknya masih dapat tetap tidak dimodifikasi. Misalnya, ada daftar tertentu di mana dua elemen dipertukarkan - dari sudut pandang alkimia, atribut telah berubah, tetapi itu tidak masalah untuk logika bisnis jika, katakanlah,semacam.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan, pada akhirnya, kami memanggil metode lain khusus untuk setiap objek untuk memahami apakah objek tersebut dimodifikasi atau tidak. Dan kami menambahkannya ke variabel tertentu yang terkait dengan sesi yang kami ajukan sendiri - ini adalah variabel dirty_inances kami, di mana kami menambahkan objek ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acara berikut terjadi sebelum komit - before_commit. Ada juga jebakan kecil: jika kita tidak memiliki satu flush untuk seluruh transaksi, maka flush akan dipanggil sebelum komit - dalam kasus saya, pawang dipanggil sebelum komit sebelum flush. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, apa yang kami lakukan pada paragraf sebelumnya mungkin tidak membantu kami dan session.dirty_inances akan kosong. Oleh karena itu, di dalam handler, kami kembali membuat flush sehingga semua penangan dipanggil sebelum flush dan hanya menambah versi satu per satu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after_commit, after_soft_rollback - setelah komit, kami hanya membersihkannya sehingga tidak ada kelebihan di waktu berikutnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, Anda lihat - metode install_handler ini menginstal penangan untuk tiga acara sekaligus. Sebagai sebuah kelas, kami melewati sesi di sini, karena ini adalah acara levelnya. </font></font><br><br><img src="https://habrastorage.org/webt/oi/w8/pk/oiw8pkhgdpx7shz7rqrovfmg6lk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baik di sini. Saya akan mengingatkan Anda apa yang telah kami capai - kecepatan 30-40 detik untuk tim yang kompleks dan besar. Tidak sama sekali, beberapa diselesaikan dalam sedetik, yang lain dalam 200 milidetik, seperti yang Anda lihat di RPS. Permintaan basis data mulai dihitung dalam ratusan. </font></font><br><br><img src="https://habrastorage.org/webt/7p/wk/qo/7pwkqo4-g_hksl5m_cqoo3xph5y.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasilnya adalah sistem yang cukup seimbang. Namun, ada satu peringatan. Beberapa permintaan datang dari kami dalam batch, emisi. Yaitu, sekitar 30 permintaan tiba dan masing-masing seperti itu! (pembicara menunjukkan jempol)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kami memprosesnya satu detik setiap kali, maka permintaan terakhir dalam antrian akan berfungsi selama 30 detik. Yang pertama, yang kedua, dan seterusnya. </font></font><br><br><img src="https://habrastorage.org/webt/ut/br/gl/utbrglrwurgv0uux2yk8eme4owg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena itu, kita masih perlu berakselerasi. Apa yang akan kita lakukan </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padahal, alkimia memiliki dua bagian. Yang pertama adalah abstraksi atas database sql yang disebut SQLAlchemy Core. Yang kedua adalah ORM, pemetaan aktual antara database relasional dan representasi objek. Oleh karena itu, inti alkimia adalah sekitar 1-1 bertepatan dengan sql - jika Anda tahu yang terakhir, maka Anda tidak akan memiliki masalah dengan inti. Jika Anda tidak tahu sql - pelajari sql. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, inti merupakan overhead terkecil. Praktis tidak ada pemompaan - kueri dihasilkan menggunakan generator kueri, dan kemudian dieksekusi. Overhead over dbapi minimal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat membangun permintaan dengan kompleksitas apa pun, apa pun jenisnya, kami dapat mengoptimalkannya untuk tugas tersebut. Yaitu, jika dalam kasus umum ORM tidak peduli bagaimana skema database dibangun - ada beberapa deskripsi tabel, itu menghasilkan beberapa pertanyaan, tidak mengetahui bahwa dalam kasus ini akan, misalnya, optimal untuk dipilih dari sini, di lain - dari sana, seperti terapkan filternya, dan di sana - lainnya, maka di sini kita bisa membuat permintaan untuk tugas tersebut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerugiannya adalah kita kembali ke sinkronisasi manual. Semua acara, relay - semua ini pada intinya tidak berfungsi. Kami membuat pilihan, objek datang kepada kami, kami melakukan sesuatu dengan mereka, kemudian memperbarui, masukkan ... Anda perlu meningkatkan versi dengan tangan Anda, periksa konstanta sendiri. Core tidak memungkinkan semua ini dilakukan dengan nyaman, pada level tinggi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yah, kita tidak hidup di hari pertama.</font></font><br><br><img src="https://habrastorage.org/webt/qx/kk/bx/qxkkbxwleeqwvdukaghimiat7sw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasing sederhana. Setiap mapper secara internal berisi objek __table__, yang digunakan dalam inti. Selanjutnya Anda melihat - kita pilih biasa, daftar kolom, bergabung dua piring, menunjukkan kiri dan kanan, ditunjukkan dengan kondisi apa kita bergabung, baik, untuk rasa kita tambahkan pesanan beli. Kemudian kami memasukkan permintaan yang dihasilkan ini ke dalam sesi dan mengembalikannya kepada kami, di mana objek seperti ketuk diindeks baik dengan nama kolom dan nomor. Nomornya sesuai dengan urutan daftar mereka pilih. </font></font><br><br><img src="https://habrastorage.org/webt/r2/uq/f4/r2uqf4wn-wa-cvigivokusan6um.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu menjadi jauh lebih baik. Kinerja dalam kasus terburuk turun menjadi 2-4 detik, permintaan paling kompleks dan terpanjang berisi 14 perintah dan RPS 10-15. Itu solid. </font></font><br><br><img src="https://habrastorage.org/webt/m9/8d/mw/m98dmwpmo0trjpw3vta7dylmryw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang ingin saya katakan sebagai kesimpulan.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jangan menghasilkan entitas di mana mereka tidak diperlukan - jangan sekrup Anda di mana ada yang siap. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gunakan SQLA ORM - ini adalah alat yang sangat nyaman yang memungkinkan Anda untuk melacak peristiwa di tingkat tinggi, merespons berbagai peristiwa yang terkait dengan database, menyembunyikan semua telinga alkimia. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika semuanya gagal, kinerja tidak cukup - gunakan SQLA Core. </font><font style="vertical-align: inherit;">Ini masih lebih baik daripada menggunakan SQL mentah murni karena menyediakan abstraksi relasional atas database. </font><font style="vertical-align: inherit;">Secara otomatis lolos dari parameter, tidak mengikat dengan benar, tidak masalah apa pun basis data di bawahnya - itu dapat diubah dan Core mendukung dialek yang berbeda.</font></font> Sangat nyaman. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itu saja yang ingin saya sampaikan kepada Anda hari ini. </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/flA2lEl2a0M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430818/">https://habr.com/ru/post/id430818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430804/index.html">Baterai Tesla / Panasonic adalah baterai kendaraan listrik paling terjangkau di pasaran</a></li>
<li><a href="../id430806/index.html">Kami mulai belajar bahasa Inggris - menulis aplikasi: EWM - pengalaman dalam membuat proyek pelatihan</a></li>
<li><a href="../id430808/index.html">Teori Speaker: 16 materi tentang cara kerja speaker dan speaker</a></li>
<li><a href="../id430810/index.html">Muat pengujian dengan belalang. Bagian 2</a></li>
<li><a href="../id430812/index.html">Apa yang developer.android.com bicarakan tentang RecyclerView</a></li>
<li><a href="../id430820/index.html">Black Friday 2018 - VDS di Moskow dan Amsterdam</a></li>
<li><a href="../id430822/index.html">Keamanan informasi Internet tentang hal-hal: siapa itu barangnya dan siapa tuannya?</a></li>
<li><a href="../id430824/index.html">Cari objek yang rusak dengan nomor halaman yang rusak di MS SQL Server 2005</a></li>
<li><a href="../id430826/index.html">Bagaimana cara mengembangkan manajer pengembangan</a></li>
<li><a href="../id430828/index.html">Pengalaman dalam menggunakan layar LCD berdasarkan produk MELT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>