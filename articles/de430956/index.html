<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚠 ✏️ 🚴🏽 Wir bringen einem Schwein auf Monoiden bei, an sich selbst zu glauben und zu fliegen 🐨 👩🏾‍🎤 🔭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem der vorherigen Artikel habe ich darüber gesprochen, wie Sie einen Programm-Executor für eine virtuelle Stack-Maschine mithilfe funktionaler u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir bringen einem Schwein auf Monoiden bei, an sich selbst zu glauben und zu fliegen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430956/"><p> In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem</a> der vorherigen Artikel habe ich darüber gesprochen, wie Sie einen Programm-Executor für eine virtuelle Stack-Maschine mithilfe funktionaler und sprachorientierter Programmieransätze erstellen können.  Die mathematische Struktur der Sprache schlug die Grundstruktur für die Implementierung ihres Übersetzers vor, die auf dem Konzept von Halbgruppen und Monoiden basiert.  Dieser Ansatz ermöglichte es mir, eine schöne und erweiterbare Implementierung zu erstellen und den Applaus zu brechen, aber die erste Frage des Publikums ließ mich vom Podium steigen und wieder in Emacs einsteigen. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/ln/ne/n2lnneohm_d4rsc-qkw_n4cguyw.png" width="80%"></div><br><p>  Ich habe einen einfachen Test durchgeführt und sichergestellt, dass bei einfachen Aufgaben, bei denen nur der Stapel verwendet wird, die virtuelle Maschine intelligent funktioniert und bei Verwendung des "Speichers" - eines Arrays mit wahlfreiem Zugriff - große Probleme auftreten.  Wie wir es geschafft haben, sie zu lösen, ohne die Grundprinzipien der Programmarchitektur zu ändern und eine tausendfache Beschleunigung des Programms zu erreichen, wird in diesem Artikel erörtert. </p><a name="habracut"></a><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>∗</mo><mtext>&nbsp;</mtext><mo>∗</mo><mtext>&nbsp;</mtext><mo>∗</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> * \ * \ * </script></p><br><p>  Haskell ist eine eigenartige Sprache mit einer besonderen Nische.  Das Hauptziel seiner Schaffung und Entwicklung war die Notwendigkeit der Verkehrssprache, Ideen der funktionalen Programmierung auszudrücken und zu testen.  Dies rechtfertigt seine auffälligsten Merkmale: Faulheit, extreme Reinheit, Betonung von Typen und Manipulationen mit ihnen.  Es war nicht für die alltägliche Entwicklung gedacht, nicht für die industrielle Programmierung, nicht für den weit verbreiteten Gebrauch.  Die Tatsache, dass es wirklich zur Erstellung von Großprojekten in der Netzwerkbranche und in der Datenverarbeitung verwendet wird, ist der gute Wille der Entwickler, ein Proof of Concept, wenn Sie möchten.  Aber das wichtigste, weit verbreitete und erstaunlich leistungsfähige Produkt, das in Haskell geschrieben wurde, ist ... der ghc-Compiler.  Und dies ist unter dem Gesichtspunkt seines Zwecks völlig gerechtfertigt - ein Werkzeug für die Forschung auf dem Gebiet der Informatik zu sein.  Das von Simon Payton-Johnson proklamierte Prinzip: „Vermeiden Sie Erfolg um jeden Preis“ ist notwendig, damit die Sprache ein solches Instrument bleibt.  Haskell ist wie eine sterile Kammer im Labor eines Forschungszentrums, das Halbleitertechnologien oder Nanomaterialien entwickelt.  Es ist furchtbar unpraktisch, darin zu arbeiten, und für die tägliche Praxis schränkt es auch die Handlungsfreiheit ein, aber ohne diese Unannehmlichkeiten und ohne kompromisslose Einhaltung von Beschränkungen wird es nicht möglich sein, die subtilen Auswirkungen zu beobachten und zu untersuchen, die später die Grundlage industrieller Entwicklungen werden.  Gleichzeitig wird in der Industrie Sterilität nur in dem notwendigsten Volumen benötigt, und die Ergebnisse dieser Experimente werden in Form von Geräten in unseren Taschen erscheinen.  Wir untersuchen Sterne und Galaxien nicht, weil wir erwarten, dass sie direkten Nutzen daraus ziehen, sondern weil auf der Skala dieser unpraktischen Objekte quanten- und relativistische Effekte beobachtet und untersucht werden, so dass wir dieses Wissen später nutzen können, um etwas sehr Nützliches zu entwickeln.  Haskell mit seinen "falschen" Linien, der unpraktischen Faulheit der Berechnungen, der Starrheit einiger Inferenzalgorithmen mit einer extrem steilen Eingabekurve ermöglicht es Ihnen schließlich nicht, einfach eine intelligente Anwendung auf dem Knie oder einem Betriebssystem zu erstellen.  Linsen, Monaden, kombinatorisches Parsen, die weit verbreitete Verwendung von Monoiden, Methoden zur automatischen Theoremprüfung, deklarative Funktionspaketmanager, lineare und abhängige Typen nähern sich jedoch der praktischen Welt.  Dies findet Anwendung unter weniger sterilen Bedingungen in den Sprachen Python, Scala, Kotlin, F #, Rust und vielen anderen.  Aber ich würde keine dieser wunderbaren Sprachen verwenden, um die Prinzipien der funktionalen Programmierung zu lehren: Ich würde den Schüler ins Labor bringen, in hellen und sauberen Beispielen zeigen, wie es funktioniert, und dann können Sie diese Prinzipien in der Fabrik in Aktion sehen eine große und unverständliche, aber sehr schnelle Maschine.  Erfolg um jeden Preis zu vermeiden, ist ein Schutz vor Versuchen, eine Kaffeemaschine in ein Elektronenmikroskop zu stecken, um sie bekannt zu machen.  Und bei Wettbewerben, deren Sprache cooler ist, wird Haskell immer außerhalb der üblichen Nominierungen liegen. </p><br><p>  Die Person ist jedoch schwach und ein Dämon lebt auch in mir, was mich dazu bringt, „meine Lieblingssprache“ vor anderen zu vergleichen, zu bewerten und zu verteidigen.  Nachdem ich eine elegante Implementierung einer gestapelten Maschine geschrieben hatte, die auf einer monoidalen Komposition basiert, um zu sehen, ob diese Idee für mich funktioniert, war ich sofort verärgert, dass mir klar wurde, dass die Implementierung brillant, aber schrecklich ineffizient funktionierte!  Es ist, als würde ich es wirklich für ernsthafte Aufgaben verwenden oder meine gestapelte Maschine auf demselben Markt verkaufen, auf dem virtuelle Python- oder Java-Maschinen angeboten werden.  Aber verdammt noch mal, der Artikel über das Ferkel, mit dem dieses ganze Gespräch begann, gibt so leckere Zahlen: Hunderte von Millisekunden für das Ferkel, Sekunden für Python ... und mein wunderschöner Monoid kann dieselbe Aufgabe nicht in einer Stunde bewältigen!  Ich muss es schaffen!  Mein Mikroskop brüht Espresso nicht schlechter als eine Kaffeemaschine im Flur des Instituts!  Der Kristallpalast kann zerstreut und ins All gebracht werden! </p><br><p>  Aber was willst du aufgeben, fragt mich der Mathematiker-Engel?  Die Reinheit und Transparenz der Palastarchitektur?  Welche Flexibilität und Erweiterbarkeit bieten Homomorphismen von Programmen zu anderen Lösungen?  Der Dämon und der Engel sind beide hartnäckig, und der weise Taoist, den auch ich leben lasse, schlug vor, dass wir den Weg gehen, der zu beiden passt, und ihm so lange wie möglich folgen.  Nicht mit dem Ziel, den Gewinner zu identifizieren, sondern um den Weg selbst zu kennen, herauszufinden, wie weit er führt, und um neue Erfahrungen zu sammeln.  Und so kannte ich die vergebliche Traurigkeit und Freude an der Optimierung. </p><br><p> Bevor wir beginnen, fügen wir hinzu, dass Vergleiche von <em>Sprachen</em> hinsichtlich ihrer Effektivität sinnlos sind.  Sie müssen Übersetzer (Dolmetscher oder Compiler) oder die Leistung eines Programmierers vergleichen, der die Sprache verwendet.  Am Ende lässt sich die Behauptung, dass C-Programme am schnellsten sind, leicht widerlegen, indem beispielsweise ein vollständiger C-Interpreter in BASIC geschrieben wird.  Wir vergleichen also nicht Haskell und Javascript, sondern die Leistung von Programmen, die von einem von <code>ghc</code> kompilierten Übersetzer ausgeführt werden, und von Programmen, die beispielsweise in einem bestimmten Browser ausgeführt werden.  Die gesamte Schweine-Terminologie stammt aus einem inspirierenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> über gestapelte Maschinen.  Der gesamte Haskell-Code, der dem Artikel beiliegt, kann im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository untersucht werden</a> . </p><br><h3 id="vyhodim-iz-zony-komforta">  Wir verlassen die Komfortzone </h3><br><p>  Die Ausgangsposition wird die Implementierung einer monoidalen Stapelmaschine in Form von <abbr title="Eingebettete domänenorientierte Sprache">EDSL sein</abbr> - einer kleinen einfachen Sprache, die es ermöglicht, zwei Dutzend <abbr title="Eingebettete domänenorientierte Sprache">Grundelemente zu</abbr> kombinieren, um Programme für eine virtuelle Stapelmaschine zu rendern.  Sobald er in den zweiten Artikel gekommen ist, geben wir ihm den Namen <code>monopig</code> .  Es basiert auf der Tatsache, dass Sprachen für gestapelte Maschinen ein <em>Monoid</em> mit einer Verkettungsoperation und einer leeren Operation als Einheit bilden.  Dementsprechend wurde er selbst in Form einer monoiden Transformation des Maschinenzustands aufgebaut.  Der Zustand umfasst einen Stapel, einen Speicher in Form eines Vektors (eine Struktur, die einen zufälligen Zugriff auf Elemente ermöglicht), ein Not-Aus-Flag und eine monoidale Batterie zum Sammeln von Debugging-Informationen.  Diese gesamte Struktur wird entlang einer Kette von Endomorphismen von Operation zu Operation übertragen, wobei ein Rechenprozess ausgeführt wird.  Eine isomorphe Struktur <em>von</em> Programmcodes wurde aus der Struktur, die die Programme bilden, und daraus Homomorphismen in andere nützliche Strukturen aufgebaut, die die Anforderungen an das Programm in Bezug auf die Anzahl der Argumente und den Speicher darstellen.  Die letzte Phase der Konstruktion war die Erstellung von Transformationsmonoiden in der Kategorie Claysley, mit denen Sie Berechnungen in eine beliebige Monade eintauchen können.  So erhielt die Maschine die Fähigkeit zur Eingabe / Ausgabe und zu mehrdeutigen Berechnungen.  Wir beginnen mit dieser Implementierung.  Ihren Code finden Sie <a href="">hier</a> . </p><br><p>  Wir werden die Wirksamkeit des Programms auf die naive Implementierung des Eratosthenes-Siebs testen, das den Speicher (Array) mit Nullen und Einsen füllt und Primzahlen mit Null bezeichnet.  Wir geben den Verfahrenscode des Algorithmus in <code>javascript</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memSize = <span class="hljs-number"><span class="hljs-number">65536</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; memSize; i++) arr.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sieve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n*n &lt; memSize) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!arr[n]) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = n; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &lt; memSize) { k+=n; arr[k] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } n++; } }</code> </pre> <br><p>  Der Algorithmus wird sofort leicht optimiert.  Es beseitigt schlechtes Gehen durch bereits gefüllte Speicherzellen.  Mein mathematischer Engel stimmte einer <em>wirklich</em> naiven Version aus einem Beispiel im <code>PorosenokVM</code> Projekt nicht zu, da diese Optimierung nur fünf Anweisungen der Stapelsprache kostet.  So übersetzt sich der Algorithmus in <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve</span></span> = push <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;&gt; while (dup &lt;&gt; dup &lt;&gt; mul &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; get &lt;&gt; branch mempty fill &lt;&gt; inc) &lt;&gt; pop fill = dup &lt;&gt; dup &lt;&gt; add &lt;&gt; while (dup &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; push <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; swap &lt;&gt; put &lt;&gt; exch &lt;&gt; add) &lt;&gt; pop</code> </pre> <br><p>  Und so können Sie eine äquivalente Implementierung dieses Algorithmus auf dem idiomatischen Haskell schreiben, wobei Sie dieselben Typen wie in <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> sieve' km | k*k &lt; memSize = sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m ! k == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m | otherwise = m fill' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> fill' knm | n &lt; memSize = fill' k (n+k) $ m // [(n,<span class="hljs-number"><span class="hljs-number">1</span></span>)] | otherwise = m</code> </pre> <br><p>  Es verwendet den <code>Data.Vector</code> Typ und die Tools für die Arbeit damit, die für die tägliche Arbeit in Haskell nicht allzu häufig sind.  Ausdruck <code>m ! k</code>  <code>m ! k</code> gibt das <code>k</code> te Element des Vektors <code>m</code> und <code>m // [(n,1)]</code> - setzt das Element mit der Zahl <code>n</code> auf 1. Ich schreibe dies hier, weil ich zu ihnen gehen musste, um Hilfe zu erhalten, obwohl ich in Haskell arbeite fast jeden Tag.  Tatsache ist, dass Strukturen mit wahlfreiem Zugriff in einer funktionalen Implementierung ineffizient und aus diesem Grund ungeliebt sind. </p><br><p>  Gemäß den im Artikel über das Ferkel angegebenen Wettbewerbsbedingungen wird der Algorithmus 100 Mal ausgeführt.  Um einen bestimmten Computer loszuwerden, vergleichen wir die Ausführungsgeschwindigkeiten dieser drei Programme und verweisen sie auf die Leistung des in Chrome ausgeführten <code>javascript</code> Programms. </p><br><p><img src="https://habrastorage.org/webt/ir/hi/mj/irhimjjtdgec7vw1vduvivmzonm.png"></p><br><p>  Horror Horror !!!  <code>monopig</code> verlangsamt sich nicht nur gottlos, die native Version ist auch nicht viel besser!  Haskell ist natürlich cool, aber einem Programm, das in einem Browser ausgeführt wird, nicht unterlegen ?!  Wie Trainer uns lehren, können Sie nicht so leben, es ist Zeit, die Komfortzone zu verlassen, die Haskell uns bietet! </p><br><h3 id="preodolevaem-len">  Faulheit überwinden </h3><br><p>  Lass es uns richtig machen.  Kompilieren Sie dazu ein Programm auf <code>monopig</code> mit dem Flag <code>-rtsopts</code> , um die <code>-rtsopts</code> zu <code>-rtsopts</code> und zu sehen, was wir brauchen, um das Eratosthenes-Sieb einmal auszuführen: </p><br><pre> <code class="plaintext hljs">$ ghc -O -rtsopts ./Monopig4.hs [1 of 1] Compiling Main ( Monopig4.hs, Monopig4.o ) Linking Monopig4 ... $ ./Monopig4 -RTS -sstderr "Ok" 68,243,040,608 bytes allocated in the heap 6,471,530,040 bytes copied during GC 2,950,952 bytes maximum residency (30667 sample(s)) 42,264 bytes maximum slop 15 MB total memory in use (7 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 99408 colls, 0 par 2.758s 2.718s 0.0000s 0.0015s Gen 1 30667 colls, 0 par 57.654s 57.777s 0.0019s 0.0133s INIT time 0.000s ( 0.000s elapsed) MUT time 29.008s ( 29.111s elapsed) GC time 60.411s ( 60.495s elapsed) &lt;--   ! EXIT time 0.000s ( 0.000s elapsed) Total time 89.423s ( 89.607s elapsed) %GC time 67.6% (67.5% elapsed) Alloc rate 2,352,591,525 bytes per MUT second Productivity 32.4% of total user, 32.4% of total elapsed</code> </pre> <br><p>  Die letzte Zeile sagt uns, dass das Programm nur ein Drittel der Zeit mit produktivem Computing beschäftigt war.  Für den Rest der Zeit lief der Garbage Collector aus dem Speicher und räumte für träge Berechnungen auf.  Wie oft wurde uns in der Kindheit gesagt, dass Faulheit nicht gut ist!  Hier hat uns das Hauptmerkmal von Haskell einen schlechten Dienst erwiesen und versucht, mehrere Milliarden verzögerte Vektor- und Stapeltransformationen zu erstellen. </p><br><p>  Ein mathematischer Engel hebt an dieser Stelle den Finger und spricht glücklich darüber, dass es seit der Zeit der Alonzo-Kirche einen Satz gibt, der besagt, dass die Berechnungsstrategie das Ergebnis nicht beeinflusst, was bedeutet, dass wir sie aus Effizienzgründen frei wählen können.  Die Berechnungen auf streng zu ändern ist überhaupt nicht schwierig - setzen Sie ein Zeichen <code>!</code>  in der Deklaration der Art des Stapels und des Speichers, und machen Sie dadurch diese Felder streng. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Wir werden nichts anderes ändern und sofort das Ergebnis überprüfen: </p><br><pre> <code class="plaintext hljs">$ ./Monopig41 +RTS -sstderr "Ok" 68,244,819,008 bytes allocated in the heap 7,386,896 bytes copied during GC 528,088 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 16 MB total memory in use (14 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 129923 colls, 0 par 0.666s 0.654s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.001s 0.001s 0.0006s 0.0007s INIT time 0.000s ( 0.000s elapsed) MUT time 13.029s ( 13.048s elapsed) GC time 0.667s ( 0.655s elapsed) EXIT time 0.001s ( 0.001s elapsed) Total time 13.700s ( 13.704s elapsed) %GC time 4.9% (4.8% elapsed) Alloc rate 5,238,049,412 bytes per MUT second Productivity 95.1% of total user, 95.1% of total elapsed</code> </pre> <br><p>  Die Produktivität ist deutlich gestiegen.  Die Gesamtspeicherkosten blieben aufgrund der Unveränderlichkeit der Daten immer noch beeindruckend, aber vor allem, da wir die Faulheit der Daten begrenzt haben, hat der Garbage Collector die Möglichkeit, faul zu sein, nur 5% der Arbeit verbleiben darauf.  Geben Sie einen neuen Eintrag in die Bewertung ein. </p><br><p><img src="https://habrastorage.org/webt/6z/z4/6j/6zz46jgmso3w95efydonusy8pok.png"></p><br><p>  Nun, strenge Berechnungen haben uns der Geschwindigkeit des nativen Haskell-Codes näher gebracht, der ohne virtuelle Maschine schändlich langsamer wird.  Dies bedeutet, dass der Aufwand für die Verwendung eines unveränderlichen Vektors die Kosten für die Wartung einer gestapelten Maschine <em>erheblich</em> übersteigt.  Und das bedeutet, dass es Zeit ist, sich von der Unveränderlichkeit des Gedächtnisses zu verabschieden. </p><br><h3 id="vpuskaem-izmeneniya-v-zhizn">  Veränderungen ins Leben lassen </h3><br><p>  Der <code>Data.Vector</code> Typ <code>Data.Vector</code> gut, aber wenn wir ihn verwenden, verbringen wir viel Zeit mit dem Kopieren, um die Reinheit des Rechenprozesses zu erhalten.  <code>Data.Vector.Unpacked</code> wir es durch den Typ <code>Data.Vector.Unpacked</code> ersetzen <code>Data.Vector.Unpacked</code> sparen wir zumindest die Verpackung der Struktur, aber dies ändert das Bild nicht grundlegend.  Die richtige Lösung wäre, den Speicher aus dem Zustand der Maschine zu entfernen und mithilfe der Kategorie Kleisley Zugriff auf den externen Vektor zu gewähren.  Gleichzeitig können Sie zusammen mit reinen Vektoren die sogenannten veränderlichen (veränderlichen) Vektoren <code>Data.Vector.Mutable</code> . </p><br><p>  Wir werden die entsprechenden Module verbinden und darüber nachdenken, wie mit veränderlichen Daten in einem sauberen Funktionsprogramm umgegangen werden soll. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Primitive <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> V <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed.Mutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M</code> </pre> <br><p>  Diese schmutzigen Typen sollen von der reinen Öffentlichkeit isoliert sein.  Sie sind in den Monaden der <code>PrimMonad</code> Klasse enthalten (einschließlich <code>ST</code> oder <code>IO</code> ), in denen saubere Programme sorgfältig Anweisungen für Aktionen einfügen, die in einer Kristallfunktionssprache auf wertvollem Pergament geschrieben sind.  Daher wird das Verhalten dieser unreinen Tiere durch streng orthodoxe Szenarien bestimmt und ist nicht gefährlich.  Nicht alle Programme für unsere Maschine verwenden Speicher, daher muss die gesamte Architektur nicht zum Eintauchen in die <code>IO</code> Monade verurteilt werden.  Zusammen mit einer sauberen Teilmenge der <code>monopig</code> Sprache <code>monopig</code> wir vier Anweisungen erstellen, die den Zugriff auf den Speicher ermöglichen, und nur sie haben Zugriff auf das gefährliche Gebiet. </p><br><p>  Die Art der sauberen Maschine wird immer kürzer: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Programmdesigner und die Programme selbst werden diese Änderung kaum bemerken, aber ihre Typen werden sich ändern.  Darüber hinaus ist es sinnvoll, verschiedene Arten von Synonymen zu definieren, um die Signaturen zu vereinfachen. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MVector</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrimState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Code</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a -&gt; m (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program'</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class"> ma</span></span></code> </pre> <br><p>  Konstruktoren haben ein weiteres Argument, das den Speicherzugriff darstellt.  Ausführende werden sich erheblich ändern, insbesondere diejenigen, die ein Berechnungsprotokoll führen, da sie jetzt den Status des Variablenvektors danach fragen müssen.  Der vollständige <a href="">Code</a> kann im Repository angezeigt und studiert werden, aber hier werde ich das Interessanteste geben: die Implementierung der grundlegenden Komponenten für die Arbeit mit dem Speicher, um zu zeigen, wie dies gemacht wird. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">geti</span></span> :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma geti i = programM (<span class="hljs-type"><span class="hljs-type">GETI</span></span> i) $ \mem -&gt; \s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mem i setStack (x:s) vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> puti :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma puti i = programM (<span class="hljs-type"><span class="hljs-type">PUTI</span></span> i) $ \mem -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (x:s) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mem ix setStack s vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> get :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma get = programM (<span class="hljs-type"><span class="hljs-type">GET</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:s) -&gt; \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.read mi setStack (x:s) vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> put :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma put = programM (<span class="hljs-type"><span class="hljs-type">PUT</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:x:s) -&gt; \vm -&gt; <span class="hljs-type"><span class="hljs-type">M</span></span>.write mix &gt;&gt; setStack s vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected two elemets"</span></span></code> </pre> <br><p>  Der Optimizer-Daemon bot sofort an, beim Überprüfen der zulässigen Indexwerte im Speicher etwas mehr zu sparen, da bei <code>puti</code> und <code>geti</code> Indizes in der Phase der Programmerstellung bekannt sind und falsche Werte im Voraus beseitigt werden können.  Dynamisch definierte Indizes für <code>put</code> und <code>get</code> Befehle garantieren keine Sicherheit, und der Mathematiker-Engel erlaubte keine gefährlichen Aufrufe an sie. </p><br><p>  All diese Aufregung, das Gedächtnis in ein separates Argument zu setzen, scheint kompliziert.  Aber es zeigt sehr deutlich, welche Daten von ihrem Ort geändert werden müssen - <em>sie sollten draußen sein</em> .  Ich erinnere Sie daran, dass wir versuchen, einen Pizzaboten in ein steriles Labor zu bringen.  Reine Funktionen wissen, was sie damit anfangen sollen, aber diese Objekte werden niemals zu erstklassigen Bürgern, und es lohnt sich nicht, Pizza direkt im Labor zuzubereiten. </p><br><p>  Lassen Sie uns überprüfen, was wir mit diesen Änderungen gekauft haben: </p><br><pre> <code class="plaintext hljs">$ ./Monopig5 +RTS -sstderr "Ok" 9,169,192,928 bytes allocated in the heap 2,006,680 bytes copied during GC 529,608 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 2 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 17693 colls, 0 par 0.094s 0.093s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.000s 0.000s 0.0002s 0.0003s INIT time 0.000s ( 0.000s elapsed) MUT time 7.228s ( 7.232s elapsed) GC time 0.094s ( 0.093s elapsed) EXIT time 0.000s ( 0.000s elapsed) Total time 7.325s ( 7.326s elapsed) %GC time 1.3% (1.3% elapsed) Alloc rate 1,268,570,828 bytes per MUT second Productivity 98.7% of total user, 98.7% of total elapsed</code> </pre> <br><p>  Das ist schon ein Fortschritt!  Die Speichernutzung wurde um das Achtfache reduziert, die Programmausführungsgeschwindigkeit um das 180-fache erhöht und der Garbage Collector blieb fast vollständig ohne Arbeit. </p><br><p><img src="https://habrastorage.org/webt/o7/cw/f8/o7cwf8ptddtz8x1gdy0lunionis.png"></p><br><p>  Die Lösung erschien <em>monopig st.</em>  <em>mut.</em>  <code>js</code> ist zehnmal langsamer als die native Lösung auf <code>js</code> , aber abgesehen davon die native Lösung auf Haskell unter Verwendung veränderlicher Vektoren.  Hier ist sein Code: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fill'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) fill' knm | n &gt; memSize-k = return m | otherwise = <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mn <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; fill' k (n+k) m sieve' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) sieve' km | k*k &lt; memSize = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mk <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m &gt;&gt;= sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) m | otherwise = return m</code> </pre> <br><p>  Es beginnt wie folgt </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> m &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.replicate memSize <span class="hljs-number"><span class="hljs-number">0</span></span> stimes <span class="hljs-number"><span class="hljs-number">100</span></span> (sieve' <span class="hljs-number"><span class="hljs-number">2</span></span> m &gt;&gt; return ()) print <span class="hljs-string"><span class="hljs-string">"Ok"</span></span></code> </pre> <br><p>  Und jetzt zeigt Haskell endlich, dass er keine Spielzeugsprache ist.  Sie müssen es nur mit Bedacht einsetzen.  Übrigens verwendet der obige Code die Tatsache, dass der Typ <code>IO ()</code> eine Halbgruppe mit der Operation der sequentiellen Ausführung von Programmen <code>(&gt;&gt;)</code> , und mit Hilfe von <code>stimes</code> wir die Berechnung des Testproblems 100-mal wiederholt. </p><br><p>  Jetzt ist klar, warum es eine solche Abneigung gegen funktionale Arrays gibt und warum sich niemand daran erinnert, wie man mit ihnen arbeitet: Sobald ein Haskell-Programmierer wirklich Direktzugriffsstrukturen benötigt, konzentriert er sich wieder auf veränderbare Daten und arbeitet in ST- oder IO-Monaden. </p><br><p>  Das Herausbringen eines Teils von Befehlen in eine spezielle Zone stellt die Rechtmäßigkeit des Isomorphismus in Frage <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="20.072ex" height="2.419ex" viewBox="0 -780.1 8642 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6C" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-65" x="2413" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-66" x="2880" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-74" x="3430" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="3792" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-69" x="4243" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-67" x="4589" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-68" x="5069" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-74" x="5646" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-61" x="6007" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="6537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="6988" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6F" x="7440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-77" x="7925" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> \ longleftrightarrow </script>  <em>das Programm</em> .  Schließlich können wir den Code nicht gleichzeitig in reine und monadische Programme umwandeln, dies erlaubt dem Typsystem dies nicht.  Typklassen sind jedoch flexibel genug, damit dieser Isomorphismus existiert.  Homomorphismus- <em>Code</em> <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.177ex" height="2.419ex" viewBox="0 -780.1 6965 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-69" x="2566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-67" x="2912" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-68" x="3392" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-74" x="3969" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-61" x="4330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="4860" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="5311" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6F" x="5763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-77" x="6248" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ longrightarrow </script>  <em>Das Programm ist</em> nun in mehrere Homomorphismen für verschiedene Teilmengen der Sprache unterteilt.  Wie genau dies gemacht wird, sehen Sie im vollständigen [Code] () des Programms. </p><br><h3 id="ne-ostanavlivaysya-na-dostignutom">  Hör hier nicht auf </h3><br><p>  Durch das Eliminieren unnötiger Funktionsaufrufe und das direkte Einbetten des Codes mithilfe des <code>{-# INLINE #-}</code> die Produktivität des Programms geringfügig geändert werden.  Diese Methode ist für rekursive Funktionen ungeeignet, eignet sich jedoch hervorragend für grundlegende Komponenten und Setterfunktionen.  Es reduziert die Ausführungszeit des Testprogramms um weitere 25% (siehe <a href="">Monopig51.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/0k/-l/hu/0k-lhu49_zsiihqoom7c5g0ize8.png"></p><br><p>  Der nächste vernünftige Schritt besteht darin, die Protokollierungswerkzeuge zu entfernen, wenn sie nicht benötigt werden.  In der Phase der Bildung des Endomorphismus, der das Programm darstellt, verwenden wir ein externes Argument, das wir beim Start bestimmen.  Smart-Konstruktoren <code>program</code> und <code>programM</code> können gewarnt werden, dass möglicherweise kein Argument-Logger vorhanden ist.  In diesem Fall enthält der Konvertercode nichts Überflüssiges: nur die Funktionalität und die Überprüfung des Maschinenstatus. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">program</span></span> code f = programM code (const f) programM code f (<span class="hljs-type"><span class="hljs-type">Just</span></span> logger) mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; logger mem code =&lt;&lt; f mem (stack vm) vm _ -&gt; return vm programM code f _ mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; f mem (stack vm) vm _ -&gt; return vm</code> </pre> <br><p>  Jetzt muss das Ausführen von Funktionen explizit das Vorhandensein oder Fehlen einer Protokollierung anzeigen, die nicht den Stub <code>none</code> , sondern den Typ <code>Maybe (Logger ma)</code> .  Warum sollte dies funktionieren, denn wenn es eine Protokollierung gibt oder nicht, werden die Programmkomponenten "im letzten Moment" vor der Ausführung herausfinden?  Würde der unnötige Code nicht beim Erstellen der Programmkomposition genäht?  Haskell ist eine faule Sprache und hier spielt sie uns in die Hände.  Vor der Ausführung wird der endgültige Code für eine bestimmte Aufgabe optimiert.  Diese Optimierung reduzierte die Programmausführungszeit um weitere 40% (siehe <a href="">Monopig52.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/co/gd/vy/cogdvyw-zsyliuiwsmhxs5gadhe.png"></p><br><p>  Damit werden wir die Arbeiten zur Beschleunigung des monoidalen Ferkels abschließen.  Er rennt bereits schnell genug, damit sich sowohl der Engel als auch der Dämon beruhigen können.  Dies ist natürlich nicht C, wir verwenden immer noch eine saubere Liste als Stapel, aber das Ersetzen durch ein Array führt zu einer gründlichen Ausgrabung des Codes und der Weigerung, elegante Vorlagen in den Definitionen grundlegender Befehle zu verwenden.  Ich wollte mit minimalen Änderungen auskommen, hauptsächlich auf der Ebene der Typen. </p><br><p>  Einige Probleme bleiben bei der Protokollierung bestehen.  Eine einfache Zählung der Anzahl der Schritte oder die Verwendung des Stapels funktioniert gut (wir haben das Protokollfeld streng gemacht), aber wenn Sie sie <code>seq</code> , wird bereits Speicherplatz verbraucht. Sie müssen sich mit Kicks mit <code>seq</code> , was bereits ziemlich ärgerlich ist.  Aber sagen Sie mir, wer wird die 14 Milliarden Schritte protokollieren, wenn Sie die Aufgabe in den ersten Hunderten debuggen können?  Ich werde also nicht meine Zeit damit verbringen, für die Beschleunigung zu beschleunigen. </p><br><p>  Es muss nur hinzugefügt werden, dass in dem Artikel über das Ferkel als eine der Methoden zur Optimierung von Berechnungen die Ablaufverfolgung angegeben wird: die Zuordnung von linearen Codeabschnitten, Ablaufverfolgungen, innerhalb derer Berechnungen unter Umgehung des Hauptbefehlsversandzyklus ( <code>switch</code> ) durchgeführt werden können.  In unserem Fall erzeugt die monoidale Zusammensetzung der Programmkomponenten solche Spuren entweder während der Bildung des Programms aus den EDSL-Komponenten oder während des Betriebs des <code>fromCode</code> Homomorphismus.  Diese Optimierungsmethode steht uns sozusagen kostenlos zur Verfügung. </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>∗</mo><mtext>&nbsp;</mtext><mo>∗</mo><mtext>&nbsp;</mtext><mo>∗</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-4"> * \ * \ * </script></p><br><p>  Es gibt viele <code>Conduits</code> und schnelle Lösungen im Haskell-Ökosystem, wie z. B. <code>Conduits</code> oder <code>Pipes</code> Streams, ausgezeichnete <code>String</code> Ersetzungen und flinke XML-Ersteller wie <code>attoparsec</code> -html, und der <code>attoparsec</code> Parser ist ein Standard für die kombinatorische Analyse von LL (∞) -Grammatiken.  All dies ist für den normalen Betrieb notwendig.  Noch notwendiger ist jedoch die Forschung, die zu diesen Entscheidungen führt.  Haskell war und ist ein Forschungsinstrument, das bestimmte Anforderungen erfüllt, die von der Öffentlichkeit nicht benötigt werden.  Ich sah in Kamtschatka, wie Asse in einem Mi-4-Hubschrauber bei einem Streit Streichholzschachteln schlossen und das Fahrwerk mit einem Rad drückten, während sie in der Luft hingen.  Dies ist möglich und cool, aber nicht erforderlich. </p><br><p>  Aber trotzdem ist das cool !! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430956/">https://habr.com/ru/post/de430956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430944/index.html">Die NASA hat die Teilnehmer für ihren Mini-Moon-Rover-Wettbewerb ausgewählt</a></li>
<li><a href="../de430948/index.html">Das Kommunikationsministerium schlägt vor, die Kontrolle über personenbezogene Daten zu verschärfen</a></li>
<li><a href="../de430950/index.html">Modernes Bauen</a></li>
<li><a href="../de430952/index.html">Elektroautos und Hybridautos müssen zusätzliche Geräusche machen: Warum wird das benötigt?</a></li>
<li><a href="../de430954/index.html">Qt Everywhere: WebAssembly und WebGL-Streaming</a></li>
<li><a href="../de430958/index.html">Wir starten den Container mit Unit-Tests in Azure DevOps (VSTS).</a></li>
<li><a href="../de430960/index.html">Über Gamedev aus einer Desktop-Ausstellung</a></li>
<li><a href="../de430962/index.html">Razor-Unterstützung in Visual Studio-Code</a></li>
<li><a href="../de430964/index.html">Deklaratives Denken</a></li>
<li><a href="../de430966/index.html">Allgemeine Sprints bei Atlassian Jira Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>