<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö† ‚úèÔ∏è üö¥üèΩ Wir bringen einem Schwein auf Monoiden bei, an sich selbst zu glauben und zu fliegen üê® üë©üèæ‚Äçüé§ üî≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem der vorherigen Artikel habe ich dar√ºber gesprochen, wie Sie einen Programm-Executor f√ºr eine virtuelle Stack-Maschine mithilfe funktionaler u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir bringen einem Schwein auf Monoiden bei, an sich selbst zu glauben und zu fliegen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430956/"><p> In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem</a> der vorherigen Artikel habe ich dar√ºber gesprochen, wie Sie einen Programm-Executor f√ºr eine virtuelle Stack-Maschine mithilfe funktionaler und sprachorientierter Programmierans√§tze erstellen k√∂nnen.  Die mathematische Struktur der Sprache schlug die Grundstruktur f√ºr die Implementierung ihres √úbersetzers vor, die auf dem Konzept von Halbgruppen und Monoiden basiert.  Dieser Ansatz erm√∂glichte es mir, eine sch√∂ne und erweiterbare Implementierung zu erstellen und den Applaus zu brechen, aber die erste Frage des Publikums lie√ü mich vom Podium steigen und wieder in Emacs einsteigen. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/ln/ne/n2lnneohm_d4rsc-qkw_n4cguyw.png" width="80%"></div><br><p>  Ich habe einen einfachen Test durchgef√ºhrt und sichergestellt, dass bei einfachen Aufgaben, bei denen nur der Stapel verwendet wird, die virtuelle Maschine intelligent funktioniert und bei Verwendung des "Speichers" - eines Arrays mit wahlfreiem Zugriff - gro√üe Probleme auftreten.  Wie wir es geschafft haben, sie zu l√∂sen, ohne die Grundprinzipien der Programmarchitektur zu √§ndern und eine tausendfache Beschleunigung des Programms zu erreichen, wird in diesem Artikel er√∂rtert. </p><a name="habracut"></a><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> * \ * \ * </script></p><br><p>  Haskell ist eine eigenartige Sprache mit einer besonderen Nische.  Das Hauptziel seiner Schaffung und Entwicklung war die Notwendigkeit der Verkehrssprache, Ideen der funktionalen Programmierung auszudr√ºcken und zu testen.  Dies rechtfertigt seine auff√§lligsten Merkmale: Faulheit, extreme Reinheit, Betonung von Typen und Manipulationen mit ihnen.  Es war nicht f√ºr die allt√§gliche Entwicklung gedacht, nicht f√ºr die industrielle Programmierung, nicht f√ºr den weit verbreiteten Gebrauch.  Die Tatsache, dass es wirklich zur Erstellung von Gro√üprojekten in der Netzwerkbranche und in der Datenverarbeitung verwendet wird, ist der gute Wille der Entwickler, ein Proof of Concept, wenn Sie m√∂chten.  Aber das wichtigste, weit verbreitete und erstaunlich leistungsf√§hige Produkt, das in Haskell geschrieben wurde, ist ... der ghc-Compiler.  Und dies ist unter dem Gesichtspunkt seines Zwecks v√∂llig gerechtfertigt - ein Werkzeug f√ºr die Forschung auf dem Gebiet der Informatik zu sein.  Das von Simon Payton-Johnson proklamierte Prinzip: ‚ÄûVermeiden Sie Erfolg um jeden Preis‚Äú ist notwendig, damit die Sprache ein solches Instrument bleibt.  Haskell ist wie eine sterile Kammer im Labor eines Forschungszentrums, das Halbleitertechnologien oder Nanomaterialien entwickelt.  Es ist furchtbar unpraktisch, darin zu arbeiten, und f√ºr die t√§gliche Praxis schr√§nkt es auch die Handlungsfreiheit ein, aber ohne diese Unannehmlichkeiten und ohne kompromisslose Einhaltung von Beschr√§nkungen wird es nicht m√∂glich sein, die subtilen Auswirkungen zu beobachten und zu untersuchen, die sp√§ter die Grundlage industrieller Entwicklungen werden.  Gleichzeitig wird in der Industrie Sterilit√§t nur in dem notwendigsten Volumen ben√∂tigt, und die Ergebnisse dieser Experimente werden in Form von Ger√§ten in unseren Taschen erscheinen.  Wir untersuchen Sterne und Galaxien nicht, weil wir erwarten, dass sie direkten Nutzen daraus ziehen, sondern weil auf der Skala dieser unpraktischen Objekte quanten- und relativistische Effekte beobachtet und untersucht werden, so dass wir dieses Wissen sp√§ter nutzen k√∂nnen, um etwas sehr N√ºtzliches zu entwickeln.  Haskell mit seinen "falschen" Linien, der unpraktischen Faulheit der Berechnungen, der Starrheit einiger Inferenzalgorithmen mit einer extrem steilen Eingabekurve erm√∂glicht es Ihnen schlie√ülich nicht, einfach eine intelligente Anwendung auf dem Knie oder einem Betriebssystem zu erstellen.  Linsen, Monaden, kombinatorisches Parsen, die weit verbreitete Verwendung von Monoiden, Methoden zur automatischen Theorempr√ºfung, deklarative Funktionspaketmanager, lineare und abh√§ngige Typen n√§hern sich jedoch der praktischen Welt.  Dies findet Anwendung unter weniger sterilen Bedingungen in den Sprachen Python, Scala, Kotlin, F #, Rust und vielen anderen.  Aber ich w√ºrde keine dieser wunderbaren Sprachen verwenden, um die Prinzipien der funktionalen Programmierung zu lehren: Ich w√ºrde den Sch√ºler ins Labor bringen, in hellen und sauberen Beispielen zeigen, wie es funktioniert, und dann k√∂nnen Sie diese Prinzipien in der Fabrik in Aktion sehen eine gro√üe und unverst√§ndliche, aber sehr schnelle Maschine.  Erfolg um jeden Preis zu vermeiden, ist ein Schutz vor Versuchen, eine Kaffeemaschine in ein Elektronenmikroskop zu stecken, um sie bekannt zu machen.  Und bei Wettbewerben, deren Sprache cooler ist, wird Haskell immer au√üerhalb der √ºblichen Nominierungen liegen. </p><br><p>  Die Person ist jedoch schwach und ein D√§mon lebt auch in mir, was mich dazu bringt, ‚Äûmeine Lieblingssprache‚Äú vor anderen zu vergleichen, zu bewerten und zu verteidigen.  Nachdem ich eine elegante Implementierung einer gestapelten Maschine geschrieben hatte, die auf einer monoidalen Komposition basiert, um zu sehen, ob diese Idee f√ºr mich funktioniert, war ich sofort ver√§rgert, dass mir klar wurde, dass die Implementierung brillant, aber schrecklich ineffizient funktionierte!  Es ist, als w√ºrde ich es wirklich f√ºr ernsthafte Aufgaben verwenden oder meine gestapelte Maschine auf demselben Markt verkaufen, auf dem virtuelle Python- oder Java-Maschinen angeboten werden.  Aber verdammt noch mal, der Artikel √ºber das Ferkel, mit dem dieses ganze Gespr√§ch begann, gibt so leckere Zahlen: Hunderte von Millisekunden f√ºr das Ferkel, Sekunden f√ºr Python ... und mein wundersch√∂ner Monoid kann dieselbe Aufgabe nicht in einer Stunde bew√§ltigen!  Ich muss es schaffen!  Mein Mikroskop br√ºht Espresso nicht schlechter als eine Kaffeemaschine im Flur des Instituts!  Der Kristallpalast kann zerstreut und ins All gebracht werden! </p><br><p>  Aber was willst du aufgeben, fragt mich der Mathematiker-Engel?  Die Reinheit und Transparenz der Palastarchitektur?  Welche Flexibilit√§t und Erweiterbarkeit bieten Homomorphismen von Programmen zu anderen L√∂sungen?  Der D√§mon und der Engel sind beide hartn√§ckig, und der weise Taoist, den auch ich leben lasse, schlug vor, dass wir den Weg gehen, der zu beiden passt, und ihm so lange wie m√∂glich folgen.  Nicht mit dem Ziel, den Gewinner zu identifizieren, sondern um den Weg selbst zu kennen, herauszufinden, wie weit er f√ºhrt, und um neue Erfahrungen zu sammeln.  Und so kannte ich die vergebliche Traurigkeit und Freude an der Optimierung. </p><br><p> Bevor wir beginnen, f√ºgen wir hinzu, dass Vergleiche von <em>Sprachen</em> hinsichtlich ihrer Effektivit√§t sinnlos sind.  Sie m√ºssen √úbersetzer (Dolmetscher oder Compiler) oder die Leistung eines Programmierers vergleichen, der die Sprache verwendet.  Am Ende l√§sst sich die Behauptung, dass C-Programme am schnellsten sind, leicht widerlegen, indem beispielsweise ein vollst√§ndiger C-Interpreter in BASIC geschrieben wird.  Wir vergleichen also nicht Haskell und Javascript, sondern die Leistung von Programmen, die von einem von <code>ghc</code> kompilierten √úbersetzer ausgef√ºhrt werden, und von Programmen, die beispielsweise in einem bestimmten Browser ausgef√ºhrt werden.  Die gesamte Schweine-Terminologie stammt aus einem inspirierenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber gestapelte Maschinen.  Der gesamte Haskell-Code, der dem Artikel beiliegt, kann im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository untersucht werden</a> . </p><br><h3 id="vyhodim-iz-zony-komforta">  Wir verlassen die Komfortzone </h3><br><p>  Die Ausgangsposition wird die Implementierung einer monoidalen Stapelmaschine in Form von <abbr title="Eingebettete dom√§nenorientierte Sprache">EDSL sein</abbr> - einer kleinen einfachen Sprache, die es erm√∂glicht, zwei Dutzend <abbr title="Eingebettete dom√§nenorientierte Sprache">Grundelemente zu</abbr> kombinieren, um Programme f√ºr eine virtuelle Stapelmaschine zu rendern.  Sobald er in den zweiten Artikel gekommen ist, geben wir ihm den Namen <code>monopig</code> .  Es basiert auf der Tatsache, dass Sprachen f√ºr gestapelte Maschinen ein <em>Monoid</em> mit einer Verkettungsoperation und einer leeren Operation als Einheit bilden.  Dementsprechend wurde er selbst in Form einer monoiden Transformation des Maschinenzustands aufgebaut.  Der Zustand umfasst einen Stapel, einen Speicher in Form eines Vektors (eine Struktur, die einen zuf√§lligen Zugriff auf Elemente erm√∂glicht), ein Not-Aus-Flag und eine monoidale Batterie zum Sammeln von Debugging-Informationen.  Diese gesamte Struktur wird entlang einer Kette von Endomorphismen von Operation zu Operation √ºbertragen, wobei ein Rechenprozess ausgef√ºhrt wird.  Eine isomorphe Struktur <em>von</em> Programmcodes wurde aus der Struktur, die die Programme bilden, und daraus Homomorphismen in andere n√ºtzliche Strukturen aufgebaut, die die Anforderungen an das Programm in Bezug auf die Anzahl der Argumente und den Speicher darstellen.  Die letzte Phase der Konstruktion war die Erstellung von Transformationsmonoiden in der Kategorie Claysley, mit denen Sie Berechnungen in eine beliebige Monade eintauchen k√∂nnen.  So erhielt die Maschine die F√§higkeit zur Eingabe / Ausgabe und zu mehrdeutigen Berechnungen.  Wir beginnen mit dieser Implementierung.  Ihren Code finden Sie <a href="">hier</a> . </p><br><p>  Wir werden die Wirksamkeit des Programms auf die naive Implementierung des Eratosthenes-Siebs testen, das den Speicher (Array) mit Nullen und Einsen f√ºllt und Primzahlen mit Null bezeichnet.  Wir geben den Verfahrenscode des Algorithmus in <code>javascript</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memSize = <span class="hljs-number"><span class="hljs-number">65536</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; memSize; i++) arr.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sieve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n*n &lt; memSize) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!arr[n]) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = n; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &lt; memSize) { k+=n; arr[k] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } n++; } }</code> </pre> <br><p>  Der Algorithmus wird sofort leicht optimiert.  Es beseitigt schlechtes Gehen durch bereits gef√ºllte Speicherzellen.  Mein mathematischer Engel stimmte einer <em>wirklich</em> naiven Version aus einem Beispiel im <code>PorosenokVM</code> Projekt nicht zu, da diese Optimierung nur f√ºnf Anweisungen der Stapelsprache kostet.  So √ºbersetzt sich der Algorithmus in <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve</span></span> = push <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;&gt; while (dup &lt;&gt; dup &lt;&gt; mul &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; get &lt;&gt; branch mempty fill &lt;&gt; inc) &lt;&gt; pop fill = dup &lt;&gt; dup &lt;&gt; add &lt;&gt; while (dup &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; push <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; swap &lt;&gt; put &lt;&gt; exch &lt;&gt; add) &lt;&gt; pop</code> </pre> <br><p>  Und so k√∂nnen Sie eine √§quivalente Implementierung dieses Algorithmus auf dem idiomatischen Haskell schreiben, wobei Sie dieselben Typen wie in <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> sieve' km | k*k &lt; memSize = sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m ! k == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m | otherwise = m fill' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> fill' knm | n &lt; memSize = fill' k (n+k) $ m // [(n,<span class="hljs-number"><span class="hljs-number">1</span></span>)] | otherwise = m</code> </pre> <br><p>  Es verwendet den <code>Data.Vector</code> Typ und die Tools f√ºr die Arbeit damit, die f√ºr die t√§gliche Arbeit in Haskell nicht allzu h√§ufig sind.  Ausdruck <code>m ! k</code>  <code>m ! k</code> gibt das <code>k</code> te Element des Vektors <code>m</code> und <code>m // [(n,1)]</code> - setzt das Element mit der Zahl <code>n</code> auf 1. Ich schreibe dies hier, weil ich zu ihnen gehen musste, um Hilfe zu erhalten, obwohl ich in Haskell arbeite fast jeden Tag.  Tatsache ist, dass Strukturen mit wahlfreiem Zugriff in einer funktionalen Implementierung ineffizient und aus diesem Grund ungeliebt sind. </p><br><p>  Gem√§√ü den im Artikel √ºber das Ferkel angegebenen Wettbewerbsbedingungen wird der Algorithmus 100 Mal ausgef√ºhrt.  Um einen bestimmten Computer loszuwerden, vergleichen wir die Ausf√ºhrungsgeschwindigkeiten dieser drei Programme und verweisen sie auf die Leistung des in Chrome ausgef√ºhrten <code>javascript</code> Programms. </p><br><p><img src="https://habrastorage.org/webt/ir/hi/mj/irhimjjtdgec7vw1vduvivmzonm.png"></p><br><p>  Horror Horror !!!  <code>monopig</code> verlangsamt sich nicht nur gottlos, die native Version ist auch nicht viel besser!  Haskell ist nat√ºrlich cool, aber einem Programm, das in einem Browser ausgef√ºhrt wird, nicht unterlegen ?!  Wie Trainer uns lehren, k√∂nnen Sie nicht so leben, es ist Zeit, die Komfortzone zu verlassen, die Haskell uns bietet! </p><br><h3 id="preodolevaem-len">  Faulheit √ºberwinden </h3><br><p>  Lass es uns richtig machen.  Kompilieren Sie dazu ein Programm auf <code>monopig</code> mit dem Flag <code>-rtsopts</code> , um die <code>-rtsopts</code> zu <code>-rtsopts</code> und zu sehen, was wir brauchen, um das Eratosthenes-Sieb einmal auszuf√ºhren: </p><br><pre> <code class="plaintext hljs">$ ghc -O -rtsopts ./Monopig4.hs [1 of 1] Compiling Main ( Monopig4.hs, Monopig4.o ) Linking Monopig4 ... $ ./Monopig4 -RTS -sstderr "Ok" 68,243,040,608 bytes allocated in the heap 6,471,530,040 bytes copied during GC 2,950,952 bytes maximum residency (30667 sample(s)) 42,264 bytes maximum slop 15 MB total memory in use (7 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 99408 colls, 0 par 2.758s 2.718s 0.0000s 0.0015s Gen 1 30667 colls, 0 par 57.654s 57.777s 0.0019s 0.0133s INIT time 0.000s ( 0.000s elapsed) MUT time 29.008s ( 29.111s elapsed) GC time 60.411s ( 60.495s elapsed) &lt;--   ! EXIT time 0.000s ( 0.000s elapsed) Total time 89.423s ( 89.607s elapsed) %GC time 67.6% (67.5% elapsed) Alloc rate 2,352,591,525 bytes per MUT second Productivity 32.4% of total user, 32.4% of total elapsed</code> </pre> <br><p>  Die letzte Zeile sagt uns, dass das Programm nur ein Drittel der Zeit mit produktivem Computing besch√§ftigt war.  F√ºr den Rest der Zeit lief der Garbage Collector aus dem Speicher und r√§umte f√ºr tr√§ge Berechnungen auf.  Wie oft wurde uns in der Kindheit gesagt, dass Faulheit nicht gut ist!  Hier hat uns das Hauptmerkmal von Haskell einen schlechten Dienst erwiesen und versucht, mehrere Milliarden verz√∂gerte Vektor- und Stapeltransformationen zu erstellen. </p><br><p>  Ein mathematischer Engel hebt an dieser Stelle den Finger und spricht gl√ºcklich dar√ºber, dass es seit der Zeit der Alonzo-Kirche einen Satz gibt, der besagt, dass die Berechnungsstrategie das Ergebnis nicht beeinflusst, was bedeutet, dass wir sie aus Effizienzgr√ºnden frei w√§hlen k√∂nnen.  Die Berechnungen auf streng zu √§ndern ist √ºberhaupt nicht schwierig - setzen Sie ein Zeichen <code>!</code>  in der Deklaration der Art des Stapels und des Speichers, und machen Sie dadurch diese Felder streng. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Wir werden nichts anderes √§ndern und sofort das Ergebnis √ºberpr√ºfen: </p><br><pre> <code class="plaintext hljs">$ ./Monopig41 +RTS -sstderr "Ok" 68,244,819,008 bytes allocated in the heap 7,386,896 bytes copied during GC 528,088 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 16 MB total memory in use (14 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 129923 colls, 0 par 0.666s 0.654s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.001s 0.001s 0.0006s 0.0007s INIT time 0.000s ( 0.000s elapsed) MUT time 13.029s ( 13.048s elapsed) GC time 0.667s ( 0.655s elapsed) EXIT time 0.001s ( 0.001s elapsed) Total time 13.700s ( 13.704s elapsed) %GC time 4.9% (4.8% elapsed) Alloc rate 5,238,049,412 bytes per MUT second Productivity 95.1% of total user, 95.1% of total elapsed</code> </pre> <br><p>  Die Produktivit√§t ist deutlich gestiegen.  Die Gesamtspeicherkosten blieben aufgrund der Unver√§nderlichkeit der Daten immer noch beeindruckend, aber vor allem, da wir die Faulheit der Daten begrenzt haben, hat der Garbage Collector die M√∂glichkeit, faul zu sein, nur 5% der Arbeit verbleiben darauf.  Geben Sie einen neuen Eintrag in die Bewertung ein. </p><br><p><img src="https://habrastorage.org/webt/6z/z4/6j/6zz46jgmso3w95efydonusy8pok.png"></p><br><p>  Nun, strenge Berechnungen haben uns der Geschwindigkeit des nativen Haskell-Codes n√§her gebracht, der ohne virtuelle Maschine sch√§ndlich langsamer wird.  Dies bedeutet, dass der Aufwand f√ºr die Verwendung eines unver√§nderlichen Vektors die Kosten f√ºr die Wartung einer gestapelten Maschine <em>erheblich</em> √ºbersteigt.  Und das bedeutet, dass es Zeit ist, sich von der Unver√§nderlichkeit des Ged√§chtnisses zu verabschieden. </p><br><h3 id="vpuskaem-izmeneniya-v-zhizn">  Ver√§nderungen ins Leben lassen </h3><br><p>  Der <code>Data.Vector</code> Typ <code>Data.Vector</code> gut, aber wenn wir ihn verwenden, verbringen wir viel Zeit mit dem Kopieren, um die Reinheit des Rechenprozesses zu erhalten.  <code>Data.Vector.Unpacked</code> wir es durch den Typ <code>Data.Vector.Unpacked</code> ersetzen <code>Data.Vector.Unpacked</code> sparen wir zumindest die Verpackung der Struktur, aber dies √§ndert das Bild nicht grundlegend.  Die richtige L√∂sung w√§re, den Speicher aus dem Zustand der Maschine zu entfernen und mithilfe der Kategorie Kleisley Zugriff auf den externen Vektor zu gew√§hren.  Gleichzeitig k√∂nnen Sie zusammen mit reinen Vektoren die sogenannten ver√§nderlichen (ver√§nderlichen) Vektoren <code>Data.Vector.Mutable</code> . </p><br><p>  Wir werden die entsprechenden Module verbinden und dar√ºber nachdenken, wie mit ver√§nderlichen Daten in einem sauberen Funktionsprogramm umgegangen werden soll. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Primitive <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> V <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed.Mutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M</code> </pre> <br><p>  Diese schmutzigen Typen sollen von der reinen √ñffentlichkeit isoliert sein.  Sie sind in den Monaden der <code>PrimMonad</code> Klasse enthalten (einschlie√ülich <code>ST</code> oder <code>IO</code> ), in denen saubere Programme sorgf√§ltig Anweisungen f√ºr Aktionen einf√ºgen, die in einer Kristallfunktionssprache auf wertvollem Pergament geschrieben sind.  Daher wird das Verhalten dieser unreinen Tiere durch streng orthodoxe Szenarien bestimmt und ist nicht gef√§hrlich.  Nicht alle Programme f√ºr unsere Maschine verwenden Speicher, daher muss die gesamte Architektur nicht zum Eintauchen in die <code>IO</code> Monade verurteilt werden.  Zusammen mit einer sauberen Teilmenge der <code>monopig</code> Sprache <code>monopig</code> wir vier Anweisungen erstellen, die den Zugriff auf den Speicher erm√∂glichen, und nur sie haben Zugriff auf das gef√§hrliche Gebiet. </p><br><p>  Die Art der sauberen Maschine wird immer k√ºrzer: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Programmdesigner und die Programme selbst werden diese √Ñnderung kaum bemerken, aber ihre Typen werden sich √§ndern.  Dar√ºber hinaus ist es sinnvoll, verschiedene Arten von Synonymen zu definieren, um die Signaturen zu vereinfachen. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MVector</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrimState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Code</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a -&gt; m (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program'</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class"> ma</span></span></code> </pre> <br><p>  Konstruktoren haben ein weiteres Argument, das den Speicherzugriff darstellt.  Ausf√ºhrende werden sich erheblich √§ndern, insbesondere diejenigen, die ein Berechnungsprotokoll f√ºhren, da sie jetzt den Status des Variablenvektors danach fragen m√ºssen.  Der vollst√§ndige <a href="">Code</a> kann im Repository angezeigt und studiert werden, aber hier werde ich das Interessanteste geben: die Implementierung der grundlegenden Komponenten f√ºr die Arbeit mit dem Speicher, um zu zeigen, wie dies gemacht wird. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">geti</span></span> :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma geti i = programM (<span class="hljs-type"><span class="hljs-type">GETI</span></span> i) $ \mem -&gt; \s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mem i setStack (x:s) vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> puti :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma puti i = programM (<span class="hljs-type"><span class="hljs-type">PUTI</span></span> i) $ \mem -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (x:s) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mem ix setStack s vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> get :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma get = programM (<span class="hljs-type"><span class="hljs-type">GET</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:s) -&gt; \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.read mi setStack (x:s) vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> put :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma put = programM (<span class="hljs-type"><span class="hljs-type">PUT</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:x:s) -&gt; \vm -&gt; <span class="hljs-type"><span class="hljs-type">M</span></span>.write mix &gt;&gt; setStack s vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected two elemets"</span></span></code> </pre> <br><p>  Der Optimizer-Daemon bot sofort an, beim √úberpr√ºfen der zul√§ssigen Indexwerte im Speicher etwas mehr zu sparen, da bei <code>puti</code> und <code>geti</code> Indizes in der Phase der Programmerstellung bekannt sind und falsche Werte im Voraus beseitigt werden k√∂nnen.  Dynamisch definierte Indizes f√ºr <code>put</code> und <code>get</code> Befehle garantieren keine Sicherheit, und der Mathematiker-Engel erlaubte keine gef√§hrlichen Aufrufe an sie. </p><br><p>  All diese Aufregung, das Ged√§chtnis in ein separates Argument zu setzen, scheint kompliziert.  Aber es zeigt sehr deutlich, welche Daten von ihrem Ort ge√§ndert werden m√ºssen - <em>sie sollten drau√üen sein</em> .  Ich erinnere Sie daran, dass wir versuchen, einen Pizzaboten in ein steriles Labor zu bringen.  Reine Funktionen wissen, was sie damit anfangen sollen, aber diese Objekte werden niemals zu erstklassigen B√ºrgern, und es lohnt sich nicht, Pizza direkt im Labor zuzubereiten. </p><br><p>  Lassen Sie uns √ºberpr√ºfen, was wir mit diesen √Ñnderungen gekauft haben: </p><br><pre> <code class="plaintext hljs">$ ./Monopig5 +RTS -sstderr "Ok" 9,169,192,928 bytes allocated in the heap 2,006,680 bytes copied during GC 529,608 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 2 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 17693 colls, 0 par 0.094s 0.093s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.000s 0.000s 0.0002s 0.0003s INIT time 0.000s ( 0.000s elapsed) MUT time 7.228s ( 7.232s elapsed) GC time 0.094s ( 0.093s elapsed) EXIT time 0.000s ( 0.000s elapsed) Total time 7.325s ( 7.326s elapsed) %GC time 1.3% (1.3% elapsed) Alloc rate 1,268,570,828 bytes per MUT second Productivity 98.7% of total user, 98.7% of total elapsed</code> </pre> <br><p>  Das ist schon ein Fortschritt!  Die Speichernutzung wurde um das Achtfache reduziert, die Programmausf√ºhrungsgeschwindigkeit um das 180-fache erh√∂ht und der Garbage Collector blieb fast vollst√§ndig ohne Arbeit. </p><br><p><img src="https://habrastorage.org/webt/o7/cw/f8/o7cwf8ptddtz8x1gdy0lunionis.png"></p><br><p>  Die L√∂sung erschien <em>monopig st.</em>  <em>mut.</em>  <code>js</code> ist zehnmal langsamer als die native L√∂sung auf <code>js</code> , aber abgesehen davon die native L√∂sung auf Haskell unter Verwendung ver√§nderlicher Vektoren.  Hier ist sein Code: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fill'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) fill' knm | n &gt; memSize-k = return m | otherwise = <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mn <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; fill' k (n+k) m sieve' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) sieve' km | k*k &lt; memSize = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mk <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m &gt;&gt;= sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) m | otherwise = return m</code> </pre> <br><p>  Es beginnt wie folgt </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> m &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.replicate memSize <span class="hljs-number"><span class="hljs-number">0</span></span> stimes <span class="hljs-number"><span class="hljs-number">100</span></span> (sieve' <span class="hljs-number"><span class="hljs-number">2</span></span> m &gt;&gt; return ()) print <span class="hljs-string"><span class="hljs-string">"Ok"</span></span></code> </pre> <br><p>  Und jetzt zeigt Haskell endlich, dass er keine Spielzeugsprache ist.  Sie m√ºssen es nur mit Bedacht einsetzen.  √úbrigens verwendet der obige Code die Tatsache, dass der Typ <code>IO ()</code> eine Halbgruppe mit der Operation der sequentiellen Ausf√ºhrung von Programmen <code>(&gt;&gt;)</code> , und mit Hilfe von <code>stimes</code> wir die Berechnung des Testproblems 100-mal wiederholt. </p><br><p>  Jetzt ist klar, warum es eine solche Abneigung gegen funktionale Arrays gibt und warum sich niemand daran erinnert, wie man mit ihnen arbeitet: Sobald ein Haskell-Programmierer wirklich Direktzugriffsstrukturen ben√∂tigt, konzentriert er sich wieder auf ver√§nderbare Daten und arbeitet in ST- oder IO-Monaden. </p><br><p>  Das Herausbringen eines Teils von Befehlen in eine spezielle Zone stellt die Rechtm√§√üigkeit des Isomorphismus in Frage <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="20.072ex" height="2.419ex" viewBox="0 -780.1 8642 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6C" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-65" x="2413" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-66" x="2880" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-74" x="3430" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="3792" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-69" x="4243" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-67" x="4589" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-68" x="5069" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-74" x="5646" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-61" x="6007" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="6537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="6988" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6F" x="7440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-77" x="7925" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> \ longleftrightarrow </script>  <em>das Programm</em> .  Schlie√ülich k√∂nnen wir den Code nicht gleichzeitig in reine und monadische Programme umwandeln, dies erlaubt dem Typsystem dies nicht.  Typklassen sind jedoch flexibel genug, damit dieser Isomorphismus existiert.  Homomorphismus- <em>Code</em> <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.177ex" height="2.419ex" viewBox="0 -780.1 6965 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-69" x="2566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-67" x="2912" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-68" x="3392" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-74" x="3969" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-61" x="4330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="4860" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-72" x="5311" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-6F" x="5763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMATHI-77" x="6248" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ longrightarrow </script>  <em>Das Programm ist</em> nun in mehrere Homomorphismen f√ºr verschiedene Teilmengen der Sprache unterteilt.  Wie genau dies gemacht wird, sehen Sie im vollst√§ndigen [Code] () des Programms. </p><br><h3 id="ne-ostanavlivaysya-na-dostignutom">  H√∂r hier nicht auf </h3><br><p>  Durch das Eliminieren unn√∂tiger Funktionsaufrufe und das direkte Einbetten des Codes mithilfe des <code>{-# INLINE #-}</code> die Produktivit√§t des Programms geringf√ºgig ge√§ndert werden.  Diese Methode ist f√ºr rekursive Funktionen ungeeignet, eignet sich jedoch hervorragend f√ºr grundlegende Komponenten und Setterfunktionen.  Es reduziert die Ausf√ºhrungszeit des Testprogramms um weitere 25% (siehe <a href="">Monopig51.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/0k/-l/hu/0k-lhu49_zsiihqoom7c5g0ize8.png"></p><br><p>  Der n√§chste vern√ºnftige Schritt besteht darin, die Protokollierungswerkzeuge zu entfernen, wenn sie nicht ben√∂tigt werden.  In der Phase der Bildung des Endomorphismus, der das Programm darstellt, verwenden wir ein externes Argument, das wir beim Start bestimmen.  Smart-Konstruktoren <code>program</code> und <code>programM</code> k√∂nnen gewarnt werden, dass m√∂glicherweise kein Argument-Logger vorhanden ist.  In diesem Fall enth√§lt der Konvertercode nichts √úberfl√ºssiges: nur die Funktionalit√§t und die √úberpr√ºfung des Maschinenstatus. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">program</span></span> code f = programM code (const f) programM code f (<span class="hljs-type"><span class="hljs-type">Just</span></span> logger) mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; logger mem code =&lt;&lt; f mem (stack vm) vm _ -&gt; return vm programM code f _ mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; f mem (stack vm) vm _ -&gt; return vm</code> </pre> <br><p>  Jetzt muss das Ausf√ºhren von Funktionen explizit das Vorhandensein oder Fehlen einer Protokollierung anzeigen, die nicht den Stub <code>none</code> , sondern den Typ <code>Maybe (Logger ma)</code> .  Warum sollte dies funktionieren, denn wenn es eine Protokollierung gibt oder nicht, werden die Programmkomponenten "im letzten Moment" vor der Ausf√ºhrung herausfinden?  W√ºrde der unn√∂tige Code nicht beim Erstellen der Programmkomposition gen√§ht?  Haskell ist eine faule Sprache und hier spielt sie uns in die H√§nde.  Vor der Ausf√ºhrung wird der endg√ºltige Code f√ºr eine bestimmte Aufgabe optimiert.  Diese Optimierung reduzierte die Programmausf√ºhrungszeit um weitere 40% (siehe <a href="">Monopig52.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/co/gd/vy/cogdvyw-zsyliuiwsmhxs5gadhe.png"></p><br><p>  Damit werden wir die Arbeiten zur Beschleunigung des monoidalen Ferkels abschlie√üen.  Er rennt bereits schnell genug, damit sich sowohl der Engel als auch der D√§mon beruhigen k√∂nnen.  Dies ist nat√ºrlich nicht C, wir verwenden immer noch eine saubere Liste als Stapel, aber das Ersetzen durch ein Array f√ºhrt zu einer gr√ºndlichen Ausgrabung des Codes und der Weigerung, elegante Vorlagen in den Definitionen grundlegender Befehle zu verwenden.  Ich wollte mit minimalen √Ñnderungen auskommen, haupts√§chlich auf der Ebene der Typen. </p><br><p>  Einige Probleme bleiben bei der Protokollierung bestehen.  Eine einfache Z√§hlung der Anzahl der Schritte oder die Verwendung des Stapels funktioniert gut (wir haben das Protokollfeld streng gemacht), aber wenn Sie sie <code>seq</code> , wird bereits Speicherplatz verbraucht. Sie m√ºssen sich mit Kicks mit <code>seq</code> , was bereits ziemlich √§rgerlich ist.  Aber sagen Sie mir, wer wird die 14 Milliarden Schritte protokollieren, wenn Sie die Aufgabe in den ersten Hunderten debuggen k√∂nnen?  Ich werde also nicht meine Zeit damit verbringen, f√ºr die Beschleunigung zu beschleunigen. </p><br><p>  Es muss nur hinzugef√ºgt werden, dass in dem Artikel √ºber das Ferkel als eine der Methoden zur Optimierung von Berechnungen die Ablaufverfolgung angegeben wird: die Zuordnung von linearen Codeabschnitten, Ablaufverfolgungen, innerhalb derer Berechnungen unter Umgehung des Hauptbefehlsversandzyklus ( <code>switch</code> ) durchgef√ºhrt werden k√∂nnen.  In unserem Fall erzeugt die monoidale Zusammensetzung der Programmkomponenten solche Spuren entweder w√§hrend der Bildung des Programms aus den EDSL-Komponenten oder w√§hrend des Betriebs des <code>fromCode</code> Homomorphismus.  Diese Optimierungsmethode steht uns sozusagen kostenlos zur Verf√ºgung. </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgpXeasRU8IwD7U8riEFQh8HN_fZw#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-4"> * \ * \ * </script></p><br><p>  Es gibt viele <code>Conduits</code> und schnelle L√∂sungen im Haskell-√ñkosystem, wie z. B. <code>Conduits</code> oder <code>Pipes</code> Streams, ausgezeichnete <code>String</code> Ersetzungen und flinke XML-Ersteller wie <code>attoparsec</code> -html, und der <code>attoparsec</code> Parser ist ein Standard f√ºr die kombinatorische Analyse von LL (‚àû) -Grammatiken.  All dies ist f√ºr den normalen Betrieb notwendig.  Noch notwendiger ist jedoch die Forschung, die zu diesen Entscheidungen f√ºhrt.  Haskell war und ist ein Forschungsinstrument, das bestimmte Anforderungen erf√ºllt, die von der √ñffentlichkeit nicht ben√∂tigt werden.  Ich sah in Kamtschatka, wie Asse in einem Mi-4-Hubschrauber bei einem Streit Streichholzschachteln schlossen und das Fahrwerk mit einem Rad dr√ºckten, w√§hrend sie in der Luft hingen.  Dies ist m√∂glich und cool, aber nicht erforderlich. </p><br><p>  Aber trotzdem ist das cool !! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430956/">https://habr.com/ru/post/de430956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430944/index.html">Die NASA hat die Teilnehmer f√ºr ihren Mini-Moon-Rover-Wettbewerb ausgew√§hlt</a></li>
<li><a href="../de430948/index.html">Das Kommunikationsministerium schl√§gt vor, die Kontrolle √ºber personenbezogene Daten zu versch√§rfen</a></li>
<li><a href="../de430950/index.html">Modernes Bauen</a></li>
<li><a href="../de430952/index.html">Elektroautos und Hybridautos m√ºssen zus√§tzliche Ger√§usche machen: Warum wird das ben√∂tigt?</a></li>
<li><a href="../de430954/index.html">Qt Everywhere: WebAssembly und WebGL-Streaming</a></li>
<li><a href="../de430958/index.html">Wir starten den Container mit Unit-Tests in Azure DevOps (VSTS).</a></li>
<li><a href="../de430960/index.html">√úber Gamedev aus einer Desktop-Ausstellung</a></li>
<li><a href="../de430962/index.html">Razor-Unterst√ºtzung in Visual Studio-Code</a></li>
<li><a href="../de430964/index.html">Deklaratives Denken</a></li>
<li><a href="../de430966/index.html">Allgemeine Sprints bei Atlassian Jira Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>