<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍✈️ 🤛🏼 💺 PVS-Studio走向云端-在Travis CI上启动分析 👸🏽 🍡 👨🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="目前，云CI系统是一项非常受欢迎的服务。 在本文中，我们将介绍如何使用PVS-Studio提供的现有工具，以Travis CI服务为例，将源代码分析与Cloud CI平台集成。 



 为什么我们要看第三方云而不是自己做？ 原因有很多，主要原因是SaaS是一个相当昂贵且困难的过程。 实际上，将PV...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio走向云端-在Travis CI上启动分析</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/458072/"> 目前，云CI系统是一项非常受欢迎的服务。 在本文中，我们将介绍如何使用PVS-Studio提供的现有工具，以Travis CI服务为例，将源代码分析与Cloud CI平台集成。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee1/252/191/ee125219104f0ff7d27f8c9dfc2db8bf.png" alt="图片1"></div><br><a name="habracut"></a><br> 为什么我们要看第三方云而不是自己做？ 原因有很多，主要原因是SaaS是一个相当昂贵且困难的过程。 实际上，将PVS-Studio分析与第三方云平台直接集成（无论是CircleCI，Travis CI，GitLab之类的开放平台，还是仅在一个特定公司中使用的某些专业企业解决方案）都是相当简单而琐碎的任务。 也就是说，我们可以说<i>PVS-Studio已经“在云端”可用</i> 。 完全不同的问题是24/7全天候工作的组织和基础设施的提供。 这是完全不同的任务，PVS-Studio没有计划直接提供自己的云平台来在其上运行分析。 <br><br>
<h2> 有关所用软件的信息 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Travis CI</a>是用于构建和测试使用GitHub作为存储的软件的服务。  Travis CI不需要更改程序代码即可使用该服务，所有设置都在存储库根目录中的<i>.travis.yml</i>文件中进行。 <br><br> 我们将把<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LXC</a> （Linux容器）作为一个测试项目，以使用PVS-Studio进行测试。 它是一个操作系统级虚拟化系统，用于在单个节点上运行Linux操作系统的多个实例。 <br><br> 该项目很小，但足以演示。  cloc命令的输出： <br><div class="scrollable-table"><table><tbody><tr><td> 语言能力 <br></td><td> 档案 <br></td><td> 空白 <br></td><td> 评论 <br></td><td> 代号 <br></td></tr><tr><td>  ç <br></td><td>  124 <br></td><td>  11937 <br></td><td>  6758 <br></td><td>  50836 <br></td></tr><tr><td>  C / C ++标题 <br></td><td>  65岁 <br></td><td>  1117 <br></td><td>  3676 <br></td><td>  3774 <br></td></tr></tbody></table></div>  <b>注意：</b> LXC开发人员已经在使用Travis CI，因此我们将以他们的配置文件为基础并对其进行编辑。 <br><br><h2> 客制化 </h2><br> 要开始使用Travis CI，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">点击链接</a>并使用Gi​​tHub帐户进行身份验证。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ba/8fc/c5a/1ba8fcc5a0caf41da255093cf4feaa8e.png" alt="图片17"></div><br> 在打开的窗口中，您需要授权Travis CI。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d7/aec/13d/2d7aec13dec45022c952ff0498a6acae.png" alt="图片16"></div><br> 授权后，重定向到欢迎页面“第一次来这里？ 让您开始吧！”  <b>，</b>简要介绍了下一步需要做什么： <br><br><ul><li> 激活存储库； </li><li> 将.travis.yml文件添加到存储库中； </li><li> 运行第一个版本。 </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29c/17f/c83/29c17fc830db9fad9d6d9dcb7fa047d7.png" alt="图片18"></div><br> 我们将开始执行这些要点。 <br><br> 要将我们的存储库添加到Travis CI，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过链接</a>转到配置文件设置，然后单击“激活”按钮。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab8/1f7/75e/ab81f775edc51c92b3238bf30b40527d.png" alt="图片19"></div><br> 单击后，将打开一个窗口，其中包含可供Travis CI应用程序访问的存储库。 <br>  <b>注意：</b>要提供对存储库的访问权限，该帐户必须具有该存储库的管理员权限。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/4fe/351/1e84fe351a57fcff37b5b70ec77e9cc5.png" alt="图片38"></div><br> 我们选择所需的存储库，单击“批准并安装”按钮确认选择，然后我们将被重定向回配置文件设置页面。 <br><br> 立即创建用于创建分析器许可证文件并发送其报告的变量。 为此，请转到设置页面-所需存储库右侧的“设置”按钮。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/f44/907/d35f449074bd079c1b35140dd8336173.png" alt="图片39"></div><br> 设置窗口将打开。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfe/c5f/1a8/cfec5f1a8ea19bf2c6e9e63c7af4c68c.png" alt="图片41"></div><br> 设置的简短说明： <br><br><ul><li>  “常规”部分-设置自动运行任务的触发器； </li><li>  “自动取消”部分-允许您配置自动取消装配； </li><li>  “环境变量”部分-允许您定义包含公共和机密信息（例如凭据，ssh密钥）的环境变量； </li><li>  “ Cron Jobs”部分-设置任务启动时间表。 </li></ul><br> 在“环境变量”部分中，我们创建<i>PVS_USERNAME</i>和<i>PVS_KEY</i>变量，分别包含静态分析器的用户名和许可证密钥。 如果您没有永久性的PVS-Studio许可证，则可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">申请试用许可证</a> 。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8aa/731/483/8aa731483fc391273980c7de338f83be.png" alt="图片5"></div><br> 立即创建包含邮箱用户名和密码的变量<i>MAIL_USER</i>和<i>MAIL_PASSWORD</i> ，我们将使用它们发送报告。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37d/a42/9b4/37da429b49812239ab900e3b6fe5a90d.png" alt="图片4"></div><br> 启动任务后，Travis CI从位于存储库根目录的.travis.yml文件中获取指令。 <br><br> 使用Travis CI，我们可以直接在虚拟机中运行静态分析，或为此使用预先配置的容器。 这些方法的结果互不相同，但是使用预先配置的容器可能会派上用场，例如，如果我们已经拥有一个在其中构建和测试了软件产品的特定环境的容器，并且不希望在Travis CI中还原此环境。 <br><br> 让我们创建一个在虚拟机中运行分析器的配置。 <br><br> 对于组装和测试，我们将使用基于Ubuntu Trusty的虚拟机，其说明可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到。 <br><br> 首先，我们指示该项目是用C编写的，并且列出了将用于汇编的编译器： <br><br><pre><code class="cpp hljs">language: c compiler: - gcc - clang</code> </pre> <br>  <b>注意</b> ：如果您指定多个编译器，则将为每个任务并行启动任务。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在文档中</a>阅读更多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内容</a> 。 <br><br> 在开始构建之前，我们需要添加分析器存储库，安装依赖项和其他软件包： <br><br><pre> <code class="cpp hljs">before_install: - sudo add-apt-repository ppa:ubuntu-lxc/daily -y - wget -q -O - https:<span class="hljs-comment"><span class="hljs-comment">//files.viva64.com/etc/pubkey.txt | sudo apt-key add - - sudo wget -O /etc/apt/sources.list.d/viva64.list https://files.viva64.com/etc/viva64.list - sudo apt-get update -qq - sudo apt-get install -qq coccinelle parallel libapparmor-dev libcap-dev libseccomp-dev python3-dev python3-setuptools docbook2x libgnutls-dev libselinux1-dev linux-libc-dev pvs-studio libio-socket-ssl-perl libnet-ssleay-perl sendemail ca-certificates</span></span></code> </pre> <br> 在构建项目之前，您需要准备环境： <br><br><pre> <code class="cpp hljs">script: - ./coccinelle/run-coccinelle.sh -i - git diff --<span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>-code - <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> CFLAGS=<span class="hljs-string"><span class="hljs-string">"-Wall -Werror"</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> LDFLAGS=<span class="hljs-string"><span class="hljs-string">"-pthread -lpthread"</span></span> - ./autogen.sh - rm -Rf build - mkdir build - cd build - ../configure --enable-tests --with-distro=unknown</code> </pre> <br> 接下来，我们需要创建一个具有许可证的文件并运行项目分析。 <br><br> 第一个命令为分析仪创建许可证文件。 变量<i>$ PVS_USERNAME</i>和<i>$ PVS_KEY的</i>数据来自项目设置。 <br><br><pre> <code class="cpp hljs">- pvs-studio-analyzer credentials $PVS_USERNAME $PVS_KEY -o PVS-Studio.lic</code> </pre> <br> 以下命令启动项目程序集跟踪： <br><br><pre> <code class="cpp hljs">- pvs-studio-analyzer trace -- make -j4</code> </pre> <br> 在我们开始静态分析之后。 <br>  <b>注意：</b>使用试用许可证时，必须指定<i>--disableLicenseExpirationCheck</i>参数。 <br><br><pre> <code class="cpp hljs"> - pvs-studio-analyzer analyze -j2 -l PVS-Studio.lic -o PVS-Studio-${CC}.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> –-disableLicenseExpirationCheck</code> </pre> <br> 使用最后一条命令，分析器结果文件将转换为html报告。 <br><br><pre> <code class="cpp hljs">- plog-converter -t html PVS-Studio-${CC}.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> -o PVS-Studio-${CC}.html</code> </pre> <br> 由于TravisCI不允许更改电子邮件通知的格式，因此我们将使用sendemail包在最后一步发送报告： <br><br><pre> <code class="cpp hljs">- sendemail -t mail@domain.com -u <span class="hljs-string"><span class="hljs-string">"PVS-Studio $CC report, commit:$TRAVIS_COMMIT"</span></span> -m <span class="hljs-string"><span class="hljs-string">"PVS-Studio $CC report, commit:$TRAVIS_COMMIT"</span></span> -s smtp.gmail.com:<span class="hljs-number"><span class="hljs-number">587</span></span> -xu $MAIL_USER -xp $MAIL_PASSWORD -o tls=yes -f $MAIL_USER -a PVS-Studio-${CC}.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> PVS-Studio-${CC}.html</code> </pre> <br> 用于在虚拟机中运行分析器的配置文件的全文： <br><br><pre> <code class="cpp hljs">language: c compiler: - gcc - clang before_install: - sudo add-apt-repository ppa:ubuntu-lxc/daily -y - wget -q -O - https:<span class="hljs-comment"><span class="hljs-comment">//files.viva64.com/etc/pubkey.txt | sudo apt-key add - - sudo wget -O /etc/apt/sources.list.d/viva64.list https://files.viva64.com/etc/viva64.list - sudo apt-get update -qq - sudo apt-get install -qq coccinelle parallel libapparmor-dev libcap-dev libseccomp-dev python3-dev python3-setuptools docbook2x libgnutls-dev libselinux1-dev linux-libc-dev pvs-studio libio-socket-ssl-perl libnet-ssleay-perl sendemail ca-certificates script: - ./coccinelle/run-coccinelle.sh -i - git diff --exit-code - export CFLAGS="-Wall -Werror" - export LDFLAGS="-pthread -lpthread" - ./autogen.sh - rm -Rf build - mkdir build - cd build - ../configure --enable-tests --with-distro=unknown - pvs-studio-analyzer credentials $PVS_USERNAME $PVS_KEY -o PVS-Studio.lic - pvs-studio-analyzer trace -- make -j4 - pvs-studio-analyzer analyze -j2 -l PVS-Studio.lic -o PVS-Studio-${CC}.log --disableLicenseExpirationCheck - plog-converter -t html PVS-Studio-${CC}.log -o PVS-Studio-${CC}.html - sendemail -t mail@domain.com -u "PVS-Studio $CC report, commit:$TRAVIS_COMMIT" -m "PVS-Studio $CC report, commit:$TRAVIS_COMMIT" -s smtp.gmail.com:587 -xu $MAIL_USER -xp $MAIL_PASSWORD -o tls=yes -f $MAIL_USER -a PVS-Studio-${CC}.log PVS-Studio-${CC}.html</span></span></code> </pre> <br> 要在容器中运行静态分析器，请首先使用以下Dockerfile创建它： <br><br><pre> <code class="cpp hljs">FROM docker.io/ubuntu:trusty ENV CFLAGS=<span class="hljs-string"><span class="hljs-string">"-Wall -Werror"</span></span> ENV LDFLAGS=<span class="hljs-string"><span class="hljs-string">"-pthread -lpthread"</span></span> RUN apt-get update &amp;&amp; apt-get install -y software-properties-common wget \ &amp;&amp; wget -q -O - https:<span class="hljs-comment"><span class="hljs-comment">//files.viva64.com/etc/pubkey.txt | sudo apt-key add - \ &amp;&amp; wget -O /etc/apt/sources.list.d/viva64.list https://files.viva64.com/etc/viva64.list \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install -yqq coccinelle parallel libapparmor-dev libcap-dev libseccomp-dev python3-dev python3-setuptools docbook2x libgnutls-dev libselinux1-dev linux-libc-dev pvs-studio git libtool autotools-dev automake pkg-config clang make libio-socket-ssl-perl libnet-ssleay-perl sendemail ca-certificates \ &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span></code> </pre> <br> 在这种情况下，配置文件可能如下所示： <br><br><pre> <code class="cpp hljs">before_install: - docker pull docker.io/oandreev/lxc env: - CC=gcc - CC=clang script: - docker run --rm --cap-add SYS_PTRACE -v $(pwd):/pvs -w /pvs docker.io/oandreev/lxc /bin/bash -c <span class="hljs-string"><span class="hljs-string">" ./coccinelle/run-coccinelle.sh -i &amp;&amp; git diff --exit-code &amp;&amp; ./autogen.sh &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; ../configure CC=$CC &amp;&amp; pvs-studio-analyzer credentials $PVS_USERNAME $PVS_KEY -o PVS-Studio.lic &amp;&amp; pvs-studio-analyzer trace -- make -j4 &amp;&amp; pvs-studio-analyzer analyze -j2 -l PVS-Studio.lic -o PVS-Studio-$CC.log --disableLicenseExpirationCheck &amp;&amp; plog-converter -t html -o PVS-Studio-$CC.html PVS-Studio-$CC.log &amp;&amp; sendemail -t mail@domain.com -u 'PVS-Studio $CC report, commit:$TRAVIS_COMMIT' -m 'PVS-Studio $CC report, commit:$TRAVIS_COMMIT' -s smtp.gmail.com:587 -xu $MAIL_USER -xp $MAIL_PASSWORD -o tls=yes -f $MAIL_USER -a PVS-Studio-${CC}.log PVS-Studio-${CC}.html"</span></span></code> </pre> <br> 如您所见，在这种情况下，我们没有在虚拟机内做任何事情，并且组装和测试项目的所有操作绝对都在容器内进行。 <br><br>  <b>注意</b> ：启动容器时，必须指定<i>--cap-add SYS_PTRACE</i>或<i>--security-opt seccomp：unconfined参数</i> ，因为ptrace系统调用用于编译跟踪。 <br><br> 我们将配置文件加载到存储库的根目录中，然后看到Travis CI收到有关项目中存在更改的通知，并自动启动了程序集。 <br><br> 可以在控制台中查看有关组装进度和分析仪验证的详细信息。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00a/846/95d/00a84695de9e00013c89760219f5292e.png" alt="图片2"></div><br> 测试完成后，我们将在邮件中收到2个字母：一个带有使用gcc构建项目的静态分析结果，第二个带有clang。 <br><br><h2> 简要介绍一下测试结果 </h2><br> 总的来说，该项目非常干净，分析仪仅发出24次严重警告和46次平均警告。 为了演示这项工作，请考虑几个有趣的通知： <br><br><h3>  if中的冗余条件 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V590</a>考虑检查'ret！=（-1）&amp;&amp; ret == 1'表达式。 表达式过多或打印错误。 附件107 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EOF -1 static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid) { .... while (getline(&amp;</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta">, &amp;line_bufsz, proc_file) != -1) { ret = sscanf(</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CapBnd: %llx"</span></span></span><span class="hljs-meta">, &amp;info-&gt;capability_mask); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ret != EOF &amp;&amp; ret == 1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= { found = true; break; } } .... }</span></span></span></span></code> </pre> <br> 如果<i>ret == 1</i> ，那么它绝对不等于-1（EOF）。 验证过多， <i>ret！= EOF</i>可以删除。 <br><br> 发出了另外两个警告： <br><br><ul><li>  V590考虑检查'ret！=（-1）&amp;&amp; ret == 1'表达式。 表达式过多或打印错误。 附件579 </li><li>  V590考虑检查'ret！=（-1）&amp;&amp; ret == 1'表达式。 表达式过多或打印错误。 附件c.583 </li></ul><br><h3> 高位丢失 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V784</a>位掩码的大小小于第一个操作数的大小。 这将导致丢失更高的位。  1879年的会议 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mount_opt</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> clear; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flag; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_mntopt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *opt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *flags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mount_opt</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mo</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* If opt is found in mount_opt, set or clear flags. * Otherwise append it to data. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (mo = &amp;mount_opt[<span class="hljs-number"><span class="hljs-number">0</span></span>]; mo-&gt;name != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; mo++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strncmp</span></span>(opt, mo-&gt;name, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(mo-&gt;name)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mo-&gt;clear) { *flags &amp;= ~mo-&gt;flag; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } else { *flags |= mo-&gt;flag; } return; } } .... }</span></span></code> </pre> <br> 在Linux下， <i>long</i>是64位整数变量， <i>mo-&gt;标志</i>是32位整数变量。 使用<i>mo-&gt;标志</i>作为位掩码将导致丢失32个最高有效位。 在按位求反后，将位掩码隐式转换为64位整数变量。 此掩码的高位将为零。 <br><br> 举例说明： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> y; .... x &amp;= ~y;</code> </pre> <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a3/59f/a71/1a359fa7163d8a99c8632ffc17cf7eb0.png" alt="图片3"></div><br><br> 正确的代码是： <br><br><pre> <code class="cpp hljs">*flags &amp;= ~(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(mo-&gt;flag);</code> </pre> <br> 分析仪发出了另一个类似的警告： <br><br><ul><li>  V784位掩码的大小小于第一个操作数的大小。 这将导致丢失更高的位。  1933年 </li></ul><br><h3> 可疑周期 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V612</a>循环内无条件的“返回”。  3477号会议 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> lxc_list_for_each(__iterator, __list) \ for (__iterator = (__list)-&gt;next; __iterator != __list; \ __iterator = __iterator-&gt;next) static bool verify_start_hooks(struct lxc_conf *conf) { char path[PATH_MAX]; struct lxc_list *it; lxc_list_for_each (it, &amp;conf-&gt;hooks[LXCHOOK_START]) { int ret; char *hookname = it-&gt;elem; ret = snprintf(path, PATH_MAX, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s%s"</span></span></span><span class="hljs-meta">, conf-&gt;rootfs.path ? conf-&gt;rootfs.mount : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">, hookname); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ret </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 0 || ret &gt;= PATH_MAX) return false; ret = access(path, X_OK); if (ret &lt; 0) { SYSERROR("Start hook \"%s\" not found in container", hookname); return false; } return true; // &lt;= } return true; }</span></span></span></span></code> </pre> <br> 循环开始，并在第一次迭代时中断。 也许这是有意的，但是可以省略该循环。 <br><br><h3> 超越数组的界限 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V557</a>阵列欠载是可能的。  “字节-1”索引的值可能达到-1。 网络.c 2570 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lxc_create_network_unpriv_exec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lxcpath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lxcname, struct lxc_netdev *netdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hooks_version)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytes; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[PATH_MAX] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; .... bytes = lxc_read_nointr(pipefd[<span class="hljs-number"><span class="hljs-number">0</span></span>], &amp;buffer, PATH_MAX); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytes &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { SYSERROR(<span class="hljs-string"><span class="hljs-string">"Failed to read from pipe file descriptor"</span></span>); close(pipefd[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { buffer[bytes - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } .... }</code> </pre> <br> 字节从管道读入缓冲区。 如果发生错误， <i>lxc_read_nointr</i>函数将返回负值。 如果一切顺利，则将null终端写入最后一个元素。 但是，如果读取0字节，则缓冲区将超出范围，这将导致未定义的行为。 <br><br> 分析仪发出了另一个类似的警告： <br><br><ul><li>  V557阵列欠载是可能的。  “字节-1”索引的值可能达到-1。 网络.c 2725 </li></ul><br><h3> 缓冲区溢出 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V576</a>格式错误。 考虑检查“ sscanf”函数的第三个实际参数。 使用不带宽度说明的字符串说明符很危险。 缓冲区溢出是可能的。  lxc_unshare.c 205 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookup_user</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *oparg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *uid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> name[PATH_MAX]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(oparg, <span class="hljs-string"><span class="hljs-string">"%u"</span></span>, uid) &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* not a uid -- perhaps a username */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(oparg, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, name) &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { free(buf); return false; } .... } .... }</span></span></code> </pre> <br> 在这种情况下使用<i>sscanf</i>可能会很危险，因为如果<i>oparq</i>缓冲区的长度大于<i>名称</i>缓冲区的长度，则在形成<i>名称</i>缓冲区时它将<i>消失</i> 。 <br><br><h2> 结论 </h2><br> 如我们所见，在云中为我们的项目设置静态代码分析器检查是一项相当简单的任务。 为此，您只需要向存储库中添加一个文件，并花费最少的时间来设置CI系统。 结果，我们得到了一个工具，该工具使您可以在编写阶段识别出有问题的代码，并且不允许错误进入下一阶段的测试，在该阶段的纠正将花费更多的时间和资源。 <br><br> 当然，结合使用PVS-Studio和云平台不限于Travis CI。 与本文中描述的方法类似，PVS-Studio分析可以与其他流行的基于云的CI解决方案（例如CircleCI，GitLab等）集成在一起，并且差异最小。 <br><br><h2> 有用的链接 </h2><br><ul><li> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到有关在Linux和MacOS上启动PVS-Studio的其他信息。 </li><li> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关使用已安装的PVS-Studio静态分析器创建，配置和使用容器的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TravisCI文档</a> 。 </li></ul><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br> 如果您想与讲英语的读者分享这篇文章，请使用翻译链接：Oleg Andreev。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">云中的PVS-Studio-在Travis CI上运行分析</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458072/">https://habr.com/ru/post/zh-CN458072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458060/index.html">在Unity引擎中创建草着色器</a></li>
<li><a href="../zh-CN458062/index.html">UserGate平台概述</a></li>
<li><a href="../zh-CN458064/index.html">云中的PVS-Studio-在Travis CI上运行分析</a></li>
<li><a href="../zh-CN458068/index.html">PVS-Studio for Visual Studio</a></li>
<li><a href="../zh-CN458070/index.html">PVS-Studio for Visual Studio</a></li>
<li><a href="../zh-CN458074/index.html">语言：ORM选择</a></li>
<li><a href="../zh-CN458076/index.html">通过ML决策进行营销</a></li>
<li><a href="../zh-CN458080/index.html">7月25日，莫斯科-QIWI iOS聚会</a></li>
<li><a href="../zh-CN458084/index.html">精选了50种有关音乐家的收入，游戏和电影中的声音，不寻常的乐器以及被遗忘的古老乐器的资料</a></li>
<li><a href="../zh-CN458088/index.html">适用于旧计算机的最佳Linux发行版</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>