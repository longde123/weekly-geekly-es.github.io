<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😕 👎🏼 👩🏿 Python als ultimativer Fall von C ++. Teil 2/2 🦒 📗 🐮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fortsetzung folgt. Beginnend in Python als ultimativer Fall von C ++. Teil 1/2 ". 
 Variablen und Datentypen 


 Nachdem wir endlich die Mathematik he...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python als ultimativer Fall von C ++. Teil 2/2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464405/"><p>  Fortsetzung folgt.  Beginnend in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python als ultimativer Fall von C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1/2</a> ". </p><br><h1>  Variablen und Datentypen </h1><br><p>  Nachdem wir endlich die Mathematik herausgefunden haben, wollen wir entscheiden, was Variablen in unserer Sprache bedeuten sollen. </p><br><p>  In C ++ hat ein Programmierer die Wahl: Verwenden Sie automatische Variablen, die auf dem Stapel platziert sind, oder behalten Sie Werte im Programmdatenspeicher bei, indem Sie nur Zeiger auf diese Werte auf dem Stapel platzieren.  Was ist, wenn wir nur eine dieser Optionen für Python auswählen? </p><br><p>  Natürlich können wir nicht immer nur die Werte von Variablen verwenden, da große Datenstrukturen nicht auf den Stapel passen oder ihre ständige Bewegung auf dem Stapel zu Leistungsproblemen führt.  Daher werden in Python nur Zeiger verwendet.  Dies wird die Sprache konzeptionell vereinfachen. </p><a name="habracut"></a><br><p>  Also der Ausdruck </p><br><pre><code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  bedeutet, dass wir im Programmdatenspeicher ein Objekt „3“ erstellt haben (den sogenannten „Heap“) und den Namen „a“ zu einem Verweis darauf gemacht haben.  Und der Ausdruck </p><br><pre> <code class="python hljs">b = a</code> </pre> <br><p>  In diesem Fall bedeutet dies, dass wir die Variable "b" gezwungen haben, auf dasselbe Objekt im Speicher zu verweisen, auf das sich "a" bezieht. Mit anderen Worten, wir haben den Zeiger kopiert. </p><br><p>  Wenn alles ein Zeiger ist, wie viele Listentypen müssen wir dann in unserer Sprache implementieren?  Natürlich ist nur einer eine Liste von Zeigern!  Sie können damit Ganzzahlen, Zeichenfolgen und andere Listen speichern - schließlich handelt es sich hierbei um Zeiger. </p><br><p>  Wie viele Arten von Hash-Tabellen müssen wir implementieren?  (In Python wird dieser Typ als "Wörterbuch" bezeichnet.) Eins!  Lassen Sie Zeiger auf Schlüssel mit Zeigern auf Werte verknüpfen. </p><br><p>  Daher müssen wir keinen großen Teil der C ++ - Spezifikationsvorlagen in unserer Sprache implementieren, da wir alle Operationen an Objekten ausführen und auf Objekte immer per Zeiger zugegriffen werden kann.  Natürlich müssen sich in Python geschriebene Programme nicht auf die Arbeit mit Zeigern beschränken: Es gibt Bibliotheken wie NumPy, mit denen Wissenschaftler wie in Fortran mit Datenfeldern im Speicher arbeiten können.  Die Basis der Sprache - Ausdrücke wie „a = 3“ - funktioniert jedoch immer mit Zeigern. </p><br><p>  Das Konzept „Alles ist ein Zeiger“ vereinfacht auch die Zusammensetzung von Typen bis an die Grenzen.  Möchten Sie eine Liste mit Wörterbüchern?  Erstellen Sie einfach eine Liste und legen Sie dort Wörterbücher ab!  Sie müssen Python nicht um Erlaubnis bitten, Sie müssen keine zusätzlichen Typen deklarieren, alles funktioniert sofort. </p><br><p>  Aber was ist, wenn wir zusammengesetzte Objekte als Schlüssel verwenden möchten?  Der Schlüssel im Wörterbuch muss einen unveränderlichen Wert haben. Wie kann man sonst nach Werten suchen?  Listen können sich ändern, daher können sie nicht in dieser Funktion verwendet werden.  In solchen Situationen hat Python einen Datentyp, der wie eine Liste eine Folge von Objekten ist, aber im Gegensatz zu einer Liste ändert sich diese Reihenfolge nicht.  Dieser Typ wird als Tupel oder <code>tuple</code> (ausgesprochen „Tupel“ oder „Tupel“). </p><br><p>  Tupel in Python lösen ein langjähriges Problem mit der Skriptsprache.  Wenn Sie von dieser Funktion nicht beeindruckt sind, haben Sie wahrscheinlich noch nie versucht, Skriptsprachen für ernsthafte Arbeiten mit Daten zu verwenden, bei denen Sie nur Zeichenfolgen oder nur primitive Typen als Schlüssel in Hash-Tabellen verwenden können. </p><br><p>  Eine andere Möglichkeit, die uns Tupel geben, besteht darin, mehrere Werte von einer Funktion zurückzugeben, ohne dafür zusätzliche Datentypen deklarieren zu müssen, wie dies in C und C ++ der Fall ist.  Um die Verwendung dieser Funktion zu vereinfachen, konnte der Zuweisungsoperator außerdem Tupel automatisch in separate Variablen entpacken. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host, port host, port = get_address()</code> </pre> <br><p>  Das Auspacken hat mehrere nützliche Nebenwirkungen. Beispielsweise kann der Austausch von Variablenwerten wie folgt geschrieben werden: </p><br><pre> <code class="python hljs">x, y = y, x</code> </pre> <br><p>  Alles ist ein Zeiger, dh Funktionen und Datentypen können als Daten verwendet werden.  Wenn Sie mit dem Buch „Design Patterns“ von „The Gang of Four“ vertraut sind, müssen Sie sich daran erinnern, welche komplexen und verwirrenden Methoden es bietet, um die Auswahl des von Ihrem Programm zur Laufzeit erstellten Objekttyps zu parametrisieren.  In vielen Programmiersprachen ist dies in der Tat schwierig!  In Python verschwinden all diese Schwierigkeiten, weil wir wissen, dass eine Funktion einen Datentyp zurückgeben kann, dass sowohl Funktionen als auch Datentypen nur Verknüpfungen sind und Verknüpfungen beispielsweise in Wörterbüchern gespeichert werden können.  Dies vereinfacht die Aufgabe bis an die Grenzen. </p><br><p>  David Wheeler sagte: "Alle Programmierprobleme werden durch die Schaffung einer zusätzlichen Indirektionsebene gelöst."  Die Verwendung von Links in Python ist die Indirektionsebene, die traditionell verwendet wurde, um viele Probleme in vielen Sprachen, einschließlich C ++, zu lösen.  Wenn es dort jedoch explizit verwendet wird und dies die Programme kompliziert, wird es in Python implizit, einheitlich in Bezug auf Daten aller Art verwendet und ist benutzerfreundlich. </p><br><p>  Aber wenn alles ein Link ist, worauf beziehen sich diese Links dann?  Sprachen wie C ++ haben viele Typen.  Lassen wir in Python nur einen Datentyp - ein Objekt!  Spezialisten auf dem Gebiet der Typentheorie schütteln missbilligend den Kopf, aber ich glaube, dass ein Quelldatentyp, von dem alle anderen Typen in der Sprache abgeleitet sind, eine gute Idee ist, die die Einheitlichkeit der Sprache und ihre Benutzerfreundlichkeit gewährleistet. </p><br><p>  Für bestimmte Speicherinhalte können verschiedene Python-Implementierungen (PyPy, Jython oder MicroPython) den Speicher auf unterschiedliche Weise verwalten.  Um jedoch besser zu verstehen, wie die Einfachheit und Einheitlichkeit von Python implementiert wird, um das richtige mentale Modell zu bilden, ist es besser, sich an die Python-Referenzimplementierung in C mit dem Namen CPython zu wenden, die wir auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">python.org</a> herunterladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ob_type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* followed by object's data */</span></span> }</code> </pre> <br><p>  Was wir im CPython-Quellcode sehen werden, ist eine Struktur, die aus einem Zeiger auf Informationen über den Typ einer bestimmten Variablen und einer Nutzlast besteht, die den spezifischen Wert der Variablen definiert. </p><br><p>  Wie funktionieren Typinformationen?  Lassen Sie uns noch einmal in den CPython-Quellcode eintauchen. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> getattrfunc tp_getattr; setattrfunc tp_setattr; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> newfunc tp_new; freefunc tp_free; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> binaryfunc nb_add; binaryfunc nb_subtract; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> richcmpfunc tp_richcompare; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Wir sehen Zeiger auf Funktionen, die alle Operationen bereitstellen, die für einen bestimmten Typ möglich sind: Addition, Subtraktion, Vergleich, Zugriff auf Attribute, Indizierung, Slicing usw. Diese Operationen wissen, wie sie mit der im Speicher befindlichen Nutzlast arbeiten Unterhalb eines Zeigers auf Typinformationen, sei es eine Ganzzahl, eine Zeichenfolge oder ein Objekt eines vom Benutzer erstellten Typs. </p><br><p>  Dies unterscheidet sich grundlegend von C und C ++, bei denen Typinformationen mit Namen verknüpft sind, nicht mit Werten von Variablen.  In Python sind alle Namen mit Links verknüpft.  Der Referenzwert ist wiederum vom Typ.  Dies ist die Essenz dynamischer Sprachen. </p><br><p>  Um alle Merkmale der Sprache zu realisieren, reicht es aus, zwei Operationen für Links zu definieren.  Eines der offensichtlichsten ist das Kopieren.  Wenn wir einer Variablen, einem Slot in einem Wörterbuch oder einem Attribut eines Objekts einen Wert zuweisen, kopieren wir die Links.  Dies ist eine einfache, schnelle und absolut sichere Operation: Durch das Kopieren von Links wird der Inhalt des Objekts nicht geändert. </p><br><p>  Die zweite Operation ist ein Funktions- oder Methodenaufruf.  Wie oben gezeigt, kann ein Python-Programm nur über in integrierten Objekten implementierte Methoden mit dem Speicher interagieren.  Daher kann es keinen Fehler im Zusammenhang mit einem Speicherzugriff verursachen. </p><br><p>  Möglicherweise haben Sie eine Frage: Wenn alle Variablen Referenzen enthalten, wie kann ich dann den Wert einer Variablen vor Änderungen schützen, indem ich ihn als Parameter an die Funktion übergebe? </p><br><pre> <code class="python hljs">n = <span class="hljs-number"><span class="hljs-number">3</span></span> some_function(n) <span class="hljs-comment"><span class="hljs-comment"># Q: I just passed a pointer! # Could some_function() have changed “3”?</span></span></code> </pre> <br><p>  Die Antwort ist, dass einfache Typen in Python unveränderlich sind: Sie implementieren einfach nicht die Methode, die für die Änderung ihres Werts verantwortlich ist.  Das unveränderliche (unveränderliche) <code>int</code> , <code>float</code> , <code>tuple</code> oder <code>str</code> bietet in Sprachen wie "alles ist ein Zeiger" den gleichen semantischen Effekt wie automatische Variablen in C. </p><br><p>  Einheitliche Typen und Methoden vereinfachen die Verwendung von generalisierter Programmierung oder Generika so weit wie möglich.  Die Funktionen <code>min()</code> , <code>max()</code> , <code>sum()</code> und dergleichen sind integriert, sie müssen nicht importiert werden.  Und sie funktionieren mit allen Datentypen, in denen Vergleichsoperationen für <code>min()</code> und <code>max()</code> implementiert sind, Additionen für <code>sum()</code> usw. </p><br><h1>  Objekte erstellen </h1><br><p>  Wir haben allgemein herausgefunden, wie sich Objekte verhalten sollen.  Jetzt werden wir bestimmen, wie wir sie erstellen werden.  Dies ist eine Frage der Sprachsyntax.  C ++ unterstützt mindestens drei Möglichkeiten zum Erstellen eines Objekts: </p><br><ol><li>  Automatisch durch Deklarieren einer Variablen dieser Klasse: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">my_class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span></span>;</code> </pre> </li><li>  Verwenden des <code>new</code> Operators: <br><pre> <code class="cpp hljs">my_class *c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_class(arg);</code> </pre> </li><li>  Factory durch Aufrufen einer beliebigen Funktion, die einen Zeiger zurückgibt: <br><pre> <code class="cpp hljs">my_class *c = my_factory(arg);</code> </pre> </li></ol><br><p>  Wie Sie wahrscheinlich bereits vermutet haben, müssen wir, nachdem wir in den obigen Beispielen die Denkweise der Schöpfer von Python studiert haben, eine davon auswählen. </p><br><p>  Aus demselben Buch, The Gangs of Four, haben wir gelernt, dass eine Fabrik die flexibelste und universellste Art ist, Objekte zu erstellen.  Daher ist in Python nur diese Methode implementiert. </p><br><p>  Zusätzlich zur Universalität ist diese Methode insofern gut, als Sie die Sprache nicht mit unnötiger Syntax überladen müssen, um dies sicherzustellen: Ein Funktionsaufruf ist bereits in unserer Sprache implementiert, und eine Factory ist nichts anderes als eine Funktion. </p><br><p>  Eine weitere Regel zum Erstellen von Objekten in Python lautet: Jeder Datentyp ist eine eigene Factory.  Natürlich können Sie eine beliebige Anzahl zusätzlicher benutzerdefinierter Fabriken schreiben (dies sind natürlich gewöhnliche Funktionen oder Methoden), aber die allgemeine Regel bleibt gültig: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Let's make type objects # their own type's factories! c = MyClass() i = int('7') f = float(length) s = str(bytes)</span></span></code> </pre> <br><p>  Alle Typen werden als Objekte bezeichnet, und alle geben Werte ihres Typs zurück, die durch die im Aufruf übergebenen Argumente bestimmt werden. </p><br><p>  Wenn Sie also nur die grundlegende Syntax der Sprache verwenden, können alle Manipulationen beim Erstellen von Objekten, wie z. B. die Muster "Arena" oder "Anpassung", gekapselt werden, da eine weitere großartige Idee aus C ++ darin besteht, dass der Typ selbst bestimmt, wie dies geschieht Laichen seiner Objekte, wie der <code>new</code> Operator für ihn arbeitet. </p><br><h1>  Wie wäre es mit NULL? </h1><br><p>  Die Behandlung eines Nullzeigers erhöht die Komplexität des Programms, sodass wir NULL verbieten.  Die Python-Syntax macht es unmöglich, einen Nullzeiger zu erstellen.  Zwei elementare Operationen an Zeigern, über die wir bereits gesprochen haben, sind so definiert, dass jede Variable auf ein Objekt zeigt. </p><br><p>  Infolgedessen kann der Benutzer Python nicht verwenden, um einen Fehler im Zusammenhang mit einem Speicherzugriff zu erstellen, z. B. einen Segmentierungsfehler oder außerhalb der Puffergrenzen.  Mit anderen Worten, Python-Programme sind in den letzten 20 Jahren nicht von den beiden gefährlichsten Arten von Sicherheitslücken betroffen, die die Sicherheit des Internets gefährden. </p><br><p>  Sie können fragen: "Wenn die Struktur von Operationen an Objekten unverändert ist, wie wir zuvor gesehen haben, wie werden Benutzer dann ihre eigenen Klassen mit Methoden und Attributen erstellen, die in dieser Struktur nicht aufgeführt sind?" </p><br><p>  Die Magie liegt in der Tatsache, dass Python für benutzerdefinierte Klassen eine sehr einfache "Vorbereitung" mit einer kleinen Anzahl von implementierten Methoden hat.  Hier sind die wichtigsten: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> {</span></span> getattrfunc tr_getattr; setattrfunc tr_setattr; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> newfunc tp_new; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  <code>tp_new()</code> erstellt eine Hash-Tabelle für die Benutzerklasse, genau wie für den <code>dict</code> .  <code>tp_getattr()</code> extrahiert etwas aus dieser Hash-Tabelle, und <code>tp_setattr()</code> im Gegenteil etwas dort ab.  Somit wird die Fähigkeit beliebiger Klassen, Methoden und Attribute zu speichern, nicht auf der Ebene der C-Sprachstrukturen bereitgestellt, sondern auf einer höheren Ebene - einer Hash-Tabelle.  (Natürlich mit Ausnahme einiger Fälle im Zusammenhang mit der Leistungsoptimierung.) </p><br><h1>  Zugriffsmodifikatoren </h1><br><p>  Was machen wir mit all den Regeln und Konzepten, die auf <code>private</code> und <code>protected</code> C ++ - Schlüsselwörtern basieren?  Python, eine Skriptsprache, benötigt sie nicht.  Wir haben bereits "geschützte" Teile der Sprache - dies sind Daten von eingebauten Typen.  Unter keinen Umständen erlaubt Python einem Programm, beispielsweise die Bits einer Gleitkommazahl zu manipulieren!  Diese Kapselungsstufe reicht aus, um die Integrität der Sprache selbst aufrechtzuerhalten.  Wir, die Entwickler von Python, glauben, dass Sprachintegrität der einzig gute Vorwand ist, um Informationen zu verbergen.  Alle anderen Strukturen und Benutzerprogrammdaten gelten als öffentlich. </p><br><p>  Sie können einen Unterstrich ( <code>_</code> ) am Anfang eines Klassenattributnamens schreiben, um einen Kollegen zu warnen: Sie sollten sich nicht auf dieses Attribut verlassen.  Aber der Rest von Python hat die Lehren aus den frühen 90ern gezogen: Dann glaubten viele, dass der Hauptgrund, warum wir aufgeblähte, unlesbare und fehlerhafte Programme schreiben, das Fehlen privater Variablen ist.  Ich denke, die nächsten 20 Jahre haben alle in der Programmierbranche überzeugt: Private Variablen sind nicht die einzigen und bei weitem nicht das wirksamste Mittel gegen aufgeblähte und fehlerhafte Programme.  Daher haben die Entwickler von Python beschlossen, sich nicht einmal um private Variablen zu kümmern, und wie Sie sehen, sind sie nicht gescheitert. </p><br><h1>  Speicherverwaltung </h1><br><p>  Was passiert mit unseren Objekten, Zahlen und Zeichenfolgen auf einer niedrigeren Ebene?  Wie genau werden sie im Speicher gespeichert, wie bietet CPython ihnen gemeinsamen Zugriff, wann und unter welchen Bedingungen werden sie zerstört? </p><br><p>  In diesem Fall haben wir die allgemeinste, vorhersehbarste und produktivste Art der Arbeit mit dem Speicher gewählt: Von der Seite des C-Programms sind alle unsere Objekte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gemeinsame Zeiger</a> . </p><br><p>  Vor diesem Hintergrund sollten die Datenstrukturen, die wir zuvor im Abschnitt „Variablen und Datentypen“ untersucht haben, wie folgt ergänzt werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Py_ssize_t ob_refcnt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ob_type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* followed by object's data */</span></span> } }</code> </pre> <br><p>  Jedes Objekt in Python (wir meinen natürlich die Implementierung von CPython) hat also einen eigenen Referenzzähler.  Sobald es Null wird, kann das Objekt gelöscht werden. </p><br><p>  Der Linkzählmechanismus beruht nicht auf zusätzlichen Berechnungen oder Hintergrundprozessen - ein Objekt kann sofort zerstört werden.  Darüber hinaus bietet es eine hohe Datenlokalität: Oft wird der Speicher unmittelbar nach der Freigabe wieder verwendet.  Das gerade zerstörte Objekt wurde höchstwahrscheinlich kürzlich verwendet, was bedeutet, dass es sich im Prozessor-Cache befand.  Daher bleibt das neu erstellte Objekt im Cache.  Diese beiden Faktoren - Einfachheit und Lokalität - machen das Zählen von Links zu einer sehr produktiven Methode der Speicherbereinigung. </p><br><p>  (Aufgrund der Tatsache, dass Objekte in realen Programmen häufig aufeinander verweisen, kann der Referenzzähler in bestimmten Fällen nicht auf Null fallen, selbst wenn Objekte nicht mehr im Programm verwendet werden. Daher verfügt CPython auch über einen zweiten Speicherbereinigungsmechanismus - einen Hintergrundmechanismus, der auf basiert auf Generationen von Objekten. - <em>ca. transl.</em> ) </p><br><h1>  Python-Entwicklerfehler </h1><br><p>  Wir haben versucht, eine Sprache zu entwickeln, die für Anfänger einfach, aber auch für Profis attraktiv genug ist.  Gleichzeitig konnten wir Fehler beim Verstehen und Verwenden der von uns selbst erstellten Tools nicht vermeiden. </p><br><p>  Python 2 versuchte aufgrund der Trägheit des Denkens in Verbindung mit Skriptsprachen, Zeichenfolgentypen zu konvertieren, wie es eine Sprache mit schwacher Typisierung tun würde.  Wenn Sie versuchen, eine Bytezeichenfolge mit einer Zeichenfolge in Unicode zu kombinieren, konvertiert der Interpreter die Bytezeichenfolge implizit in Unicode unter Verwendung der auf dem System verfügbaren Codetabelle und zeigt das Ergebnis in Unicode an: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">'byte string '</span></span> + <span class="hljs-string"><span class="hljs-string">u'unicode string'</span></span> <span class="hljs-string"><span class="hljs-string">u'byte string unicode string'</span></span></code> </pre> <br><p>  Infolgedessen funktionierten einige Websites einwandfrei, während ihre Benutzer Englisch verwendeten, aber sie erzeugten kryptische Fehler, wenn sie Zeichen aus anderen Alphabeten verwendeten. </p><br><p>  Dieser Sprachdesignfehler wurde in Python 3 behoben: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">b'byte string '</span></span> + <span class="hljs-string"><span class="hljs-string">u'unicode string'</span></span> TypeError: can<span class="hljs-string"><span class="hljs-string">'t concat bytes to str</span></span></code> </pre> <br><p>  Ein ähnlicher Fehler in Python 2 hing mit der „naiven“ Sortierung von Listen zusammen, die aus unvergleichlichen Elementen bestehen: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>sorted([<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]</code> </pre> <br><p>  Python 3 macht dem Benutzer in diesem Fall klar, dass er versucht, etwas zu tun, das nicht sehr aussagekräftig ist: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>sorted([<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) TypeError: unorderable types: int() &lt; str()</code> </pre> <br><h1>  Missbrauch </h1><br><p>  Benutzer missbrauchen gelegentlich die Dynamik der Python-Sprache, und in den 90er Jahren, als Best Practices noch nicht allgemein bekannt waren, geschah dies besonders häufig: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, host, port)</span></span></span><span class="hljs-function">:</span></span> self.host = host self.port = port</code> </pre> <br><p>  "Aber das ist nicht optimal!"  - Einige sagten: - „Was ist, wenn der Port nicht vom Standardwert abweicht?  Wie auch immer, wir geben ein ganzes Klassenattribut für seine Speicherung aus! “  Und das Ergebnis ist so etwas wie </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, host, port=None)</span></span></span><span class="hljs-function">:</span></span> self.host = host <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> port <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-comment"><span class="hljs-comment"># so terrible self.port = port</span></span></code> </pre> <br><p>  Es erscheinen also Objekte des gleichen Typs im Programm, die jedoch nicht einheitlich bedient werden können, da einige von ihnen ein bestimmtes Attribut haben, andere nicht!  Und wir können dieses Attribut nicht berühren, ohne vorher seine Anwesenheit zu überprüfen: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># code was forced to use introspection # (terrible!) if hasattr(addr, 'port'): print(addr.port)</span></span></code> </pre> <br><p>  Derzeit ist die Fülle an <code>hasattr()</code> , <code>isinstance()</code> und anderer Selbstbeobachtung ein sicheres Zeichen für schlechten Code, und es wird als bewährte <code>isinstance()</code> , Attribute immer im Objekt vorhanden zu machen.  Dies bietet eine einfachere Syntax beim Zugriff darauf: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># today's best practice: # every atribute always present if addr.port is not None: print(addr.port)</span></span></code> </pre> <br><p>  Die frühen Experimente mit dynamisch hinzugefügten und gelöschten Attributen endeten also, und jetzt betrachten wir Klassen in Python ähnlich wie in C ++. </p><br><p>  Eine andere schlechte Angewohnheit des frühen Python war die Verwendung von Funktionen, bei denen ein Argument völlig unterschiedliche Typen haben kann.  Sie könnten beispielsweise denken, dass es für den Benutzer zu schwierig sein könnte, jedes Mal eine Liste von Spaltennamen zu erstellen, und Sie sollten ihm erlauben, diese auch als einzelne Zeile zu übergeben, wobei die Namen einzelner Spalten beispielsweise durch ein Komma getrennt sind: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dataframe</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, columns)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(columns, str): columns = columns.split(<span class="hljs-string"><span class="hljs-string">','</span></span>) self.columns = columns</code> </pre> <br><p>  Dieser Ansatz kann jedoch zu Problemen führen.  Was ist zum Beispiel, wenn ein Benutzer uns versehentlich eine Zeile gibt, die nicht als Liste von Spaltennamen verwendet werden soll?  Oder ob der Spaltenname ein Komma enthalten soll? </p><br><p>  Außerdem ist es schwieriger, einen solchen Code zu warten, zu debuggen und insbesondere zu testen: In Tests kann nur einer der beiden von uns unterstützten Typen überprüft werden, die Abdeckung beträgt jedoch weiterhin 100%, und der andere Typ wird nicht getestet. </p><br><p>  Als Ergebnis kamen wir zu dem Schluss, dass Python es dem Benutzer ermöglicht, Argumente eines beliebigen Typs an Funktionen zu übergeben, aber die meisten von ihnen verwenden in den meisten Situationen eine Funktion auf dieselbe Weise wie in C: Übergeben Sie ein Argument desselben Typs an sie. </p><br><p>  Die Notwendigkeit, <code>eval()</code> in einem Programm zu verwenden, wird als explizite Fehlkalkulation der Architektur angesehen.  Höchstwahrscheinlich haben Sie einfach nicht herausgefunden, wie Sie dasselbe auf normale Weise tun können.     − ,      Jupyter notebook  -       −  <code>eval()</code>  ,      Python   ! ,     C++    . </p><br><p>     ,  ( <code>getattr()</code> , <code>hasattr()</code> , <code>isinstance()</code> )          .   ,   ,   ,      ,       : , ,  , ! </p><br><h1>   </h1><br><p>      :     ,           . 20             ,   C++  Python.   ,     ,    .         . </p><br><p>        ,    <code>shared_ptr</code>  TensorFlow   2016  2018 . </p><br><p> TensorFlow −       C++-,         Python- ( C++ −     TensorFlow, ). </p><br><p><img src="https://habrastorage.org/webt/dm/1g/zo/dm1gzovjtl2qbda7muz5wjzzjhq.png" alt="Bild"></p><br><p>         TensorFlow,  <code>shared_ptr</code> ,     .     ,     . </p><br><p>      C++?       .    ,   ?     ,     ,  C++  Python! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464405/">https://habr.com/ru/post/de464405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464391/index.html">10 interessante Berichte von Hacker-Konferenzen</a></li>
<li><a href="../de464393/index.html">Wie finde ich Programmierkurse und was sind die Beschäftigungsgarantien?</a></li>
<li><a href="../de464395/index.html">Blockchain RSA-basierter Zufall</a></li>
<li><a href="../de464399/index.html">Web Scraping in R, Teil 2. Beschleunigen Sie den Prozess durch paralleles Rechnen und Verwenden des Rcrawler-Pakets</a></li>
<li><a href="../de464403/index.html">So führen Sie ein Java-Projekt auf einem Shell-Runner aus, wenn Sie in ein GitLab-Repository pushen</a></li>
<li><a href="../de464407/index.html">Wie die weltweit größten Videoüberwachungssysteme funktionieren</a></li>
<li><a href="../de464409/index.html">Wie sich die Politik des 19. Jahrhunderts heute auf die Standorte von Rechenzentren auswirkte</a></li>
<li><a href="../de464411/index.html">PVS-Studio: Motor des Fortschritts</a></li>
<li><a href="../de464413/index.html">PVS-Studio - Motor des Fortschritts</a></li>
<li><a href="../de464415/index.html">Neuer Hinweisservice für die Suche nach hh.ru.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>