<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòï üëéüèº üë©üèø Python als ultimativer Fall von C ++. Teil 2/2 ü¶í üìó üêÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fortsetzung folgt. Beginnend in Python als ultimativer Fall von C ++. Teil 1/2 ". 
 Variablen und Datentypen 


 Nachdem wir endlich die Mathematik he...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python als ultimativer Fall von C ++. Teil 2/2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464405/"><p>  Fortsetzung folgt.  Beginnend in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python als ultimativer Fall von C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1/2</a> ". </p><br><h1>  Variablen und Datentypen </h1><br><p>  Nachdem wir endlich die Mathematik herausgefunden haben, wollen wir entscheiden, was Variablen in unserer Sprache bedeuten sollen. </p><br><p>  In C ++ hat ein Programmierer die Wahl: Verwenden Sie automatische Variablen, die auf dem Stapel platziert sind, oder behalten Sie Werte im Programmdatenspeicher bei, indem Sie nur Zeiger auf diese Werte auf dem Stapel platzieren.  Was ist, wenn wir nur eine dieser Optionen f√ºr Python ausw√§hlen? </p><br><p>  Nat√ºrlich k√∂nnen wir nicht immer nur die Werte von Variablen verwenden, da gro√üe Datenstrukturen nicht auf den Stapel passen oder ihre st√§ndige Bewegung auf dem Stapel zu Leistungsproblemen f√ºhrt.  Daher werden in Python nur Zeiger verwendet.  Dies wird die Sprache konzeptionell vereinfachen. </p><a name="habracut"></a><br><p>  Also der Ausdruck </p><br><pre><code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  bedeutet, dass wir im Programmdatenspeicher ein Objekt ‚Äû3‚Äú erstellt haben (den sogenannten ‚ÄûHeap‚Äú) und den Namen ‚Äûa‚Äú zu einem Verweis darauf gemacht haben.  Und der Ausdruck </p><br><pre> <code class="python hljs">b = a</code> </pre> <br><p>  In diesem Fall bedeutet dies, dass wir die Variable "b" gezwungen haben, auf dasselbe Objekt im Speicher zu verweisen, auf das sich "a" bezieht. Mit anderen Worten, wir haben den Zeiger kopiert. </p><br><p>  Wenn alles ein Zeiger ist, wie viele Listentypen m√ºssen wir dann in unserer Sprache implementieren?  Nat√ºrlich ist nur einer eine Liste von Zeigern!  Sie k√∂nnen damit Ganzzahlen, Zeichenfolgen und andere Listen speichern - schlie√ülich handelt es sich hierbei um Zeiger. </p><br><p>  Wie viele Arten von Hash-Tabellen m√ºssen wir implementieren?  (In Python wird dieser Typ als "W√∂rterbuch" bezeichnet.) Eins!  Lassen Sie Zeiger auf Schl√ºssel mit Zeigern auf Werte verkn√ºpfen. </p><br><p>  Daher m√ºssen wir keinen gro√üen Teil der C ++ - Spezifikationsvorlagen in unserer Sprache implementieren, da wir alle Operationen an Objekten ausf√ºhren und auf Objekte immer per Zeiger zugegriffen werden kann.  Nat√ºrlich m√ºssen sich in Python geschriebene Programme nicht auf die Arbeit mit Zeigern beschr√§nken: Es gibt Bibliotheken wie NumPy, mit denen Wissenschaftler wie in Fortran mit Datenfeldern im Speicher arbeiten k√∂nnen.  Die Basis der Sprache - Ausdr√ºcke wie ‚Äûa = 3‚Äú - funktioniert jedoch immer mit Zeigern. </p><br><p>  Das Konzept ‚ÄûAlles ist ein Zeiger‚Äú vereinfacht auch die Zusammensetzung von Typen bis an die Grenzen.  M√∂chten Sie eine Liste mit W√∂rterb√ºchern?  Erstellen Sie einfach eine Liste und legen Sie dort W√∂rterb√ºcher ab!  Sie m√ºssen Python nicht um Erlaubnis bitten, Sie m√ºssen keine zus√§tzlichen Typen deklarieren, alles funktioniert sofort. </p><br><p>  Aber was ist, wenn wir zusammengesetzte Objekte als Schl√ºssel verwenden m√∂chten?  Der Schl√ºssel im W√∂rterbuch muss einen unver√§nderlichen Wert haben. Wie kann man sonst nach Werten suchen?  Listen k√∂nnen sich √§ndern, daher k√∂nnen sie nicht in dieser Funktion verwendet werden.  In solchen Situationen hat Python einen Datentyp, der wie eine Liste eine Folge von Objekten ist, aber im Gegensatz zu einer Liste √§ndert sich diese Reihenfolge nicht.  Dieser Typ wird als Tupel oder <code>tuple</code> (ausgesprochen ‚ÄûTupel‚Äú oder ‚ÄûTupel‚Äú). </p><br><p>  Tupel in Python l√∂sen ein langj√§hriges Problem mit der Skriptsprache.  Wenn Sie von dieser Funktion nicht beeindruckt sind, haben Sie wahrscheinlich noch nie versucht, Skriptsprachen f√ºr ernsthafte Arbeiten mit Daten zu verwenden, bei denen Sie nur Zeichenfolgen oder nur primitive Typen als Schl√ºssel in Hash-Tabellen verwenden k√∂nnen. </p><br><p>  Eine andere M√∂glichkeit, die uns Tupel geben, besteht darin, mehrere Werte von einer Funktion zur√ºckzugeben, ohne daf√ºr zus√§tzliche Datentypen deklarieren zu m√ºssen, wie dies in C und C ++ der Fall ist.  Um die Verwendung dieser Funktion zu vereinfachen, konnte der Zuweisungsoperator au√üerdem Tupel automatisch in separate Variablen entpacken. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host, port host, port = get_address()</code> </pre> <br><p>  Das Auspacken hat mehrere n√ºtzliche Nebenwirkungen. Beispielsweise kann der Austausch von Variablenwerten wie folgt geschrieben werden: </p><br><pre> <code class="python hljs">x, y = y, x</code> </pre> <br><p>  Alles ist ein Zeiger, dh Funktionen und Datentypen k√∂nnen als Daten verwendet werden.  Wenn Sie mit dem Buch ‚ÄûDesign Patterns‚Äú von ‚ÄûThe Gang of Four‚Äú vertraut sind, m√ºssen Sie sich daran erinnern, welche komplexen und verwirrenden Methoden es bietet, um die Auswahl des von Ihrem Programm zur Laufzeit erstellten Objekttyps zu parametrisieren.  In vielen Programmiersprachen ist dies in der Tat schwierig!  In Python verschwinden all diese Schwierigkeiten, weil wir wissen, dass eine Funktion einen Datentyp zur√ºckgeben kann, dass sowohl Funktionen als auch Datentypen nur Verkn√ºpfungen sind und Verkn√ºpfungen beispielsweise in W√∂rterb√ºchern gespeichert werden k√∂nnen.  Dies vereinfacht die Aufgabe bis an die Grenzen. </p><br><p>  David Wheeler sagte: "Alle Programmierprobleme werden durch die Schaffung einer zus√§tzlichen Indirektionsebene gel√∂st."  Die Verwendung von Links in Python ist die Indirektionsebene, die traditionell verwendet wurde, um viele Probleme in vielen Sprachen, einschlie√ülich C ++, zu l√∂sen.  Wenn es dort jedoch explizit verwendet wird und dies die Programme kompliziert, wird es in Python implizit, einheitlich in Bezug auf Daten aller Art verwendet und ist benutzerfreundlich. </p><br><p>  Aber wenn alles ein Link ist, worauf beziehen sich diese Links dann?  Sprachen wie C ++ haben viele Typen.  Lassen wir in Python nur einen Datentyp - ein Objekt!  Spezialisten auf dem Gebiet der Typentheorie sch√ºtteln missbilligend den Kopf, aber ich glaube, dass ein Quelldatentyp, von dem alle anderen Typen in der Sprache abgeleitet sind, eine gute Idee ist, die die Einheitlichkeit der Sprache und ihre Benutzerfreundlichkeit gew√§hrleistet. </p><br><p>  F√ºr bestimmte Speicherinhalte k√∂nnen verschiedene Python-Implementierungen (PyPy, Jython oder MicroPython) den Speicher auf unterschiedliche Weise verwalten.  Um jedoch besser zu verstehen, wie die Einfachheit und Einheitlichkeit von Python implementiert wird, um das richtige mentale Modell zu bilden, ist es besser, sich an die Python-Referenzimplementierung in C mit dem Namen CPython zu wenden, die wir auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">python.org</a> herunterladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√∂nnen</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ob_type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* followed by object's data */</span></span> }</code> </pre> <br><p>  Was wir im CPython-Quellcode sehen werden, ist eine Struktur, die aus einem Zeiger auf Informationen √ºber den Typ einer bestimmten Variablen und einer Nutzlast besteht, die den spezifischen Wert der Variablen definiert. </p><br><p>  Wie funktionieren Typinformationen?  Lassen Sie uns noch einmal in den CPython-Quellcode eintauchen. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> getattrfunc tp_getattr; setattrfunc tp_setattr; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> newfunc tp_new; freefunc tp_free; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> binaryfunc nb_add; binaryfunc nb_subtract; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> richcmpfunc tp_richcompare; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Wir sehen Zeiger auf Funktionen, die alle Operationen bereitstellen, die f√ºr einen bestimmten Typ m√∂glich sind: Addition, Subtraktion, Vergleich, Zugriff auf Attribute, Indizierung, Slicing usw. Diese Operationen wissen, wie sie mit der im Speicher befindlichen Nutzlast arbeiten Unterhalb eines Zeigers auf Typinformationen, sei es eine Ganzzahl, eine Zeichenfolge oder ein Objekt eines vom Benutzer erstellten Typs. </p><br><p>  Dies unterscheidet sich grundlegend von C und C ++, bei denen Typinformationen mit Namen verkn√ºpft sind, nicht mit Werten von Variablen.  In Python sind alle Namen mit Links verkn√ºpft.  Der Referenzwert ist wiederum vom Typ.  Dies ist die Essenz dynamischer Sprachen. </p><br><p>  Um alle Merkmale der Sprache zu realisieren, reicht es aus, zwei Operationen f√ºr Links zu definieren.  Eines der offensichtlichsten ist das Kopieren.  Wenn wir einer Variablen, einem Slot in einem W√∂rterbuch oder einem Attribut eines Objekts einen Wert zuweisen, kopieren wir die Links.  Dies ist eine einfache, schnelle und absolut sichere Operation: Durch das Kopieren von Links wird der Inhalt des Objekts nicht ge√§ndert. </p><br><p>  Die zweite Operation ist ein Funktions- oder Methodenaufruf.  Wie oben gezeigt, kann ein Python-Programm nur √ºber in integrierten Objekten implementierte Methoden mit dem Speicher interagieren.  Daher kann es keinen Fehler im Zusammenhang mit einem Speicherzugriff verursachen. </p><br><p>  M√∂glicherweise haben Sie eine Frage: Wenn alle Variablen Referenzen enthalten, wie kann ich dann den Wert einer Variablen vor √Ñnderungen sch√ºtzen, indem ich ihn als Parameter an die Funktion √ºbergebe? </p><br><pre> <code class="python hljs">n = <span class="hljs-number"><span class="hljs-number">3</span></span> some_function(n) <span class="hljs-comment"><span class="hljs-comment"># Q: I just passed a pointer! # Could some_function() have changed ‚Äú3‚Äù?</span></span></code> </pre> <br><p>  Die Antwort ist, dass einfache Typen in Python unver√§nderlich sind: Sie implementieren einfach nicht die Methode, die f√ºr die √Ñnderung ihres Werts verantwortlich ist.  Das unver√§nderliche (unver√§nderliche) <code>int</code> , <code>float</code> , <code>tuple</code> oder <code>str</code> bietet in Sprachen wie "alles ist ein Zeiger" den gleichen semantischen Effekt wie automatische Variablen in C. </p><br><p>  Einheitliche Typen und Methoden vereinfachen die Verwendung von generalisierter Programmierung oder Generika so weit wie m√∂glich.  Die Funktionen <code>min()</code> , <code>max()</code> , <code>sum()</code> und dergleichen sind integriert, sie m√ºssen nicht importiert werden.  Und sie funktionieren mit allen Datentypen, in denen Vergleichsoperationen f√ºr <code>min()</code> und <code>max()</code> implementiert sind, Additionen f√ºr <code>sum()</code> usw. </p><br><h1>  Objekte erstellen </h1><br><p>  Wir haben allgemein herausgefunden, wie sich Objekte verhalten sollen.  Jetzt werden wir bestimmen, wie wir sie erstellen werden.  Dies ist eine Frage der Sprachsyntax.  C ++ unterst√ºtzt mindestens drei M√∂glichkeiten zum Erstellen eines Objekts: </p><br><ol><li>  Automatisch durch Deklarieren einer Variablen dieser Klasse: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">my_class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span></span>;</code> </pre> </li><li>  Verwenden des <code>new</code> Operators: <br><pre> <code class="cpp hljs">my_class *c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_class(arg);</code> </pre> </li><li>  Factory durch Aufrufen einer beliebigen Funktion, die einen Zeiger zur√ºckgibt: <br><pre> <code class="cpp hljs">my_class *c = my_factory(arg);</code> </pre> </li></ol><br><p>  Wie Sie wahrscheinlich bereits vermutet haben, m√ºssen wir, nachdem wir in den obigen Beispielen die Denkweise der Sch√∂pfer von Python studiert haben, eine davon ausw√§hlen. </p><br><p>  Aus demselben Buch, The Gangs of Four, haben wir gelernt, dass eine Fabrik die flexibelste und universellste Art ist, Objekte zu erstellen.  Daher ist in Python nur diese Methode implementiert. </p><br><p>  Zus√§tzlich zur Universalit√§t ist diese Methode insofern gut, als Sie die Sprache nicht mit unn√∂tiger Syntax √ºberladen m√ºssen, um dies sicherzustellen: Ein Funktionsaufruf ist bereits in unserer Sprache implementiert, und eine Factory ist nichts anderes als eine Funktion. </p><br><p>  Eine weitere Regel zum Erstellen von Objekten in Python lautet: Jeder Datentyp ist eine eigene Factory.  Nat√ºrlich k√∂nnen Sie eine beliebige Anzahl zus√§tzlicher benutzerdefinierter Fabriken schreiben (dies sind nat√ºrlich gew√∂hnliche Funktionen oder Methoden), aber die allgemeine Regel bleibt g√ºltig: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Let's make type objects # their own type's factories! c = MyClass() i = int('7') f = float(length) s = str(bytes)</span></span></code> </pre> <br><p>  Alle Typen werden als Objekte bezeichnet, und alle geben Werte ihres Typs zur√ºck, die durch die im Aufruf √ºbergebenen Argumente bestimmt werden. </p><br><p>  Wenn Sie also nur die grundlegende Syntax der Sprache verwenden, k√∂nnen alle Manipulationen beim Erstellen von Objekten, wie z. B. die Muster "Arena" oder "Anpassung", gekapselt werden, da eine weitere gro√üartige Idee aus C ++ darin besteht, dass der Typ selbst bestimmt, wie dies geschieht Laichen seiner Objekte, wie der <code>new</code> Operator f√ºr ihn arbeitet. </p><br><h1>  Wie w√§re es mit NULL? </h1><br><p>  Die Behandlung eines Nullzeigers erh√∂ht die Komplexit√§t des Programms, sodass wir NULL verbieten.  Die Python-Syntax macht es unm√∂glich, einen Nullzeiger zu erstellen.  Zwei elementare Operationen an Zeigern, √ºber die wir bereits gesprochen haben, sind so definiert, dass jede Variable auf ein Objekt zeigt. </p><br><p>  Infolgedessen kann der Benutzer Python nicht verwenden, um einen Fehler im Zusammenhang mit einem Speicherzugriff zu erstellen, z. B. einen Segmentierungsfehler oder au√üerhalb der Puffergrenzen.  Mit anderen Worten, Python-Programme sind in den letzten 20 Jahren nicht von den beiden gef√§hrlichsten Arten von Sicherheitsl√ºcken betroffen, die die Sicherheit des Internets gef√§hrden. </p><br><p>  Sie k√∂nnen fragen: "Wenn die Struktur von Operationen an Objekten unver√§ndert ist, wie wir zuvor gesehen haben, wie werden Benutzer dann ihre eigenen Klassen mit Methoden und Attributen erstellen, die in dieser Struktur nicht aufgef√ºhrt sind?" </p><br><p>  Die Magie liegt in der Tatsache, dass Python f√ºr benutzerdefinierte Klassen eine sehr einfache "Vorbereitung" mit einer kleinen Anzahl von implementierten Methoden hat.  Hier sind die wichtigsten: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> {</span></span> getattrfunc tr_getattr; setattrfunc tr_setattr; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> newfunc tp_new; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  <code>tp_new()</code> erstellt eine Hash-Tabelle f√ºr die Benutzerklasse, genau wie f√ºr den <code>dict</code> .  <code>tp_getattr()</code> extrahiert etwas aus dieser Hash-Tabelle, und <code>tp_setattr()</code> im Gegenteil etwas dort ab.  Somit wird die F√§higkeit beliebiger Klassen, Methoden und Attribute zu speichern, nicht auf der Ebene der C-Sprachstrukturen bereitgestellt, sondern auf einer h√∂heren Ebene - einer Hash-Tabelle.  (Nat√ºrlich mit Ausnahme einiger F√§lle im Zusammenhang mit der Leistungsoptimierung.) </p><br><h1>  Zugriffsmodifikatoren </h1><br><p>  Was machen wir mit all den Regeln und Konzepten, die auf <code>private</code> und <code>protected</code> C ++ - Schl√ºsselw√∂rtern basieren?  Python, eine Skriptsprache, ben√∂tigt sie nicht.  Wir haben bereits "gesch√ºtzte" Teile der Sprache - dies sind Daten von eingebauten Typen.  Unter keinen Umst√§nden erlaubt Python einem Programm, beispielsweise die Bits einer Gleitkommazahl zu manipulieren!  Diese Kapselungsstufe reicht aus, um die Integrit√§t der Sprache selbst aufrechtzuerhalten.  Wir, die Entwickler von Python, glauben, dass Sprachintegrit√§t der einzig gute Vorwand ist, um Informationen zu verbergen.  Alle anderen Strukturen und Benutzerprogrammdaten gelten als √∂ffentlich. </p><br><p>  Sie k√∂nnen einen Unterstrich ( <code>_</code> ) am Anfang eines Klassenattributnamens schreiben, um einen Kollegen zu warnen: Sie sollten sich nicht auf dieses Attribut verlassen.  Aber der Rest von Python hat die Lehren aus den fr√ºhen 90ern gezogen: Dann glaubten viele, dass der Hauptgrund, warum wir aufgebl√§hte, unlesbare und fehlerhafte Programme schreiben, das Fehlen privater Variablen ist.  Ich denke, die n√§chsten 20 Jahre haben alle in der Programmierbranche √ºberzeugt: Private Variablen sind nicht die einzigen und bei weitem nicht das wirksamste Mittel gegen aufgebl√§hte und fehlerhafte Programme.  Daher haben die Entwickler von Python beschlossen, sich nicht einmal um private Variablen zu k√ºmmern, und wie Sie sehen, sind sie nicht gescheitert. </p><br><h1>  Speicherverwaltung </h1><br><p>  Was passiert mit unseren Objekten, Zahlen und Zeichenfolgen auf einer niedrigeren Ebene?  Wie genau werden sie im Speicher gespeichert, wie bietet CPython ihnen gemeinsamen Zugriff, wann und unter welchen Bedingungen werden sie zerst√∂rt? </p><br><p>  In diesem Fall haben wir die allgemeinste, vorhersehbarste und produktivste Art der Arbeit mit dem Speicher gew√§hlt: Von der Seite des C-Programms sind alle unsere Objekte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gemeinsame Zeiger</a> . </p><br><p>  Vor diesem Hintergrund sollten die Datenstrukturen, die wir zuvor im Abschnitt ‚ÄûVariablen und Datentypen‚Äú untersucht haben, wie folgt erg√§nzt werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Py_ssize_t ob_refcnt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ob_type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* followed by object's data */</span></span> } }</code> </pre> <br><p>  Jedes Objekt in Python (wir meinen nat√ºrlich die Implementierung von CPython) hat also einen eigenen Referenzz√§hler.  Sobald es Null wird, kann das Objekt gel√∂scht werden. </p><br><p>  Der Linkz√§hlmechanismus beruht nicht auf zus√§tzlichen Berechnungen oder Hintergrundprozessen - ein Objekt kann sofort zerst√∂rt werden.  Dar√ºber hinaus bietet es eine hohe Datenlokalit√§t: Oft wird der Speicher unmittelbar nach der Freigabe wieder verwendet.  Das gerade zerst√∂rte Objekt wurde h√∂chstwahrscheinlich k√ºrzlich verwendet, was bedeutet, dass es sich im Prozessor-Cache befand.  Daher bleibt das neu erstellte Objekt im Cache.  Diese beiden Faktoren - Einfachheit und Lokalit√§t - machen das Z√§hlen von Links zu einer sehr produktiven Methode der Speicherbereinigung. </p><br><p>  (Aufgrund der Tatsache, dass Objekte in realen Programmen h√§ufig aufeinander verweisen, kann der Referenzz√§hler in bestimmten F√§llen nicht auf Null fallen, selbst wenn Objekte nicht mehr im Programm verwendet werden. Daher verf√ºgt CPython auch √ºber einen zweiten Speicherbereinigungsmechanismus - einen Hintergrundmechanismus, der auf basiert auf Generationen von Objekten. - <em>ca. transl.</em> ) </p><br><h1>  Python-Entwicklerfehler </h1><br><p>  Wir haben versucht, eine Sprache zu entwickeln, die f√ºr Anf√§nger einfach, aber auch f√ºr Profis attraktiv genug ist.  Gleichzeitig konnten wir Fehler beim Verstehen und Verwenden der von uns selbst erstellten Tools nicht vermeiden. </p><br><p>  Python 2 versuchte aufgrund der Tr√§gheit des Denkens in Verbindung mit Skriptsprachen, Zeichenfolgentypen zu konvertieren, wie es eine Sprache mit schwacher Typisierung tun w√ºrde.  Wenn Sie versuchen, eine Bytezeichenfolge mit einer Zeichenfolge in Unicode zu kombinieren, konvertiert der Interpreter die Bytezeichenfolge implizit in Unicode unter Verwendung der auf dem System verf√ºgbaren Codetabelle und zeigt das Ergebnis in Unicode an: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">'byte string '</span></span> + <span class="hljs-string"><span class="hljs-string">u'unicode string'</span></span> <span class="hljs-string"><span class="hljs-string">u'byte string unicode string'</span></span></code> </pre> <br><p>  Infolgedessen funktionierten einige Websites einwandfrei, w√§hrend ihre Benutzer Englisch verwendeten, aber sie erzeugten kryptische Fehler, wenn sie Zeichen aus anderen Alphabeten verwendeten. </p><br><p>  Dieser Sprachdesignfehler wurde in Python 3 behoben: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">b'byte string '</span></span> + <span class="hljs-string"><span class="hljs-string">u'unicode string'</span></span> TypeError: can<span class="hljs-string"><span class="hljs-string">'t concat bytes to str</span></span></code> </pre> <br><p>  Ein √§hnlicher Fehler in Python 2 hing mit der ‚Äûnaiven‚Äú Sortierung von Listen zusammen, die aus unvergleichlichen Elementen bestehen: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>sorted([<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]</code> </pre> <br><p>  Python 3 macht dem Benutzer in diesem Fall klar, dass er versucht, etwas zu tun, das nicht sehr aussagekr√§ftig ist: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>sorted([<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) TypeError: unorderable types: int() &lt; str()</code> </pre> <br><h1>  Missbrauch </h1><br><p>  Benutzer missbrauchen gelegentlich die Dynamik der Python-Sprache, und in den 90er Jahren, als Best Practices noch nicht allgemein bekannt waren, geschah dies besonders h√§ufig: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, host, port)</span></span></span><span class="hljs-function">:</span></span> self.host = host self.port = port</code> </pre> <br><p>  "Aber das ist nicht optimal!"  - Einige sagten: - ‚ÄûWas ist, wenn der Port nicht vom Standardwert abweicht?  Wie auch immer, wir geben ein ganzes Klassenattribut f√ºr seine Speicherung aus! ‚Äú  Und das Ergebnis ist so etwas wie </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, host, port=None)</span></span></span><span class="hljs-function">:</span></span> self.host = host <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> port <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-comment"><span class="hljs-comment"># so terrible self.port = port</span></span></code> </pre> <br><p>  Es erscheinen also Objekte des gleichen Typs im Programm, die jedoch nicht einheitlich bedient werden k√∂nnen, da einige von ihnen ein bestimmtes Attribut haben, andere nicht!  Und wir k√∂nnen dieses Attribut nicht ber√ºhren, ohne vorher seine Anwesenheit zu √ºberpr√ºfen: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># code was forced to use introspection # (terrible!) if hasattr(addr, 'port'): print(addr.port)</span></span></code> </pre> <br><p>  Derzeit ist die F√ºlle an <code>hasattr()</code> , <code>isinstance()</code> und anderer Selbstbeobachtung ein sicheres Zeichen f√ºr schlechten Code, und es wird als bew√§hrte <code>isinstance()</code> , Attribute immer im Objekt vorhanden zu machen.  Dies bietet eine einfachere Syntax beim Zugriff darauf: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># today's best practice: # every atribute always present if addr.port is not None: print(addr.port)</span></span></code> </pre> <br><p>  Die fr√ºhen Experimente mit dynamisch hinzugef√ºgten und gel√∂schten Attributen endeten also, und jetzt betrachten wir Klassen in Python √§hnlich wie in C ++. </p><br><p>  Eine andere schlechte Angewohnheit des fr√ºhen Python war die Verwendung von Funktionen, bei denen ein Argument v√∂llig unterschiedliche Typen haben kann.  Sie k√∂nnten beispielsweise denken, dass es f√ºr den Benutzer zu schwierig sein k√∂nnte, jedes Mal eine Liste von Spaltennamen zu erstellen, und Sie sollten ihm erlauben, diese auch als einzelne Zeile zu √ºbergeben, wobei die Namen einzelner Spalten beispielsweise durch ein Komma getrennt sind: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dataframe</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, columns)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(columns, str): columns = columns.split(<span class="hljs-string"><span class="hljs-string">','</span></span>) self.columns = columns</code> </pre> <br><p>  Dieser Ansatz kann jedoch zu Problemen f√ºhren.  Was ist zum Beispiel, wenn ein Benutzer uns versehentlich eine Zeile gibt, die nicht als Liste von Spaltennamen verwendet werden soll?  Oder ob der Spaltenname ein Komma enthalten soll? </p><br><p>  Au√üerdem ist es schwieriger, einen solchen Code zu warten, zu debuggen und insbesondere zu testen: In Tests kann nur einer der beiden von uns unterst√ºtzten Typen √ºberpr√ºft werden, die Abdeckung betr√§gt jedoch weiterhin 100%, und der andere Typ wird nicht getestet. </p><br><p>  Als Ergebnis kamen wir zu dem Schluss, dass Python es dem Benutzer erm√∂glicht, Argumente eines beliebigen Typs an Funktionen zu √ºbergeben, aber die meisten von ihnen verwenden in den meisten Situationen eine Funktion auf dieselbe Weise wie in C: √úbergeben Sie ein Argument desselben Typs an sie. </p><br><p>  Die Notwendigkeit, <code>eval()</code> in einem Programm zu verwenden, wird als explizite Fehlkalkulation der Architektur angesehen.  H√∂chstwahrscheinlich haben Sie einfach nicht herausgefunden, wie Sie dasselbe auf normale Weise tun k√∂nnen.     ‚àí ,      Jupyter notebook  -       ‚àí  <code>eval()</code>  ,      Python   ! ,     C++    . </p><br><p>     ,  ( <code>getattr()</code> , <code>hasattr()</code> , <code>isinstance()</code> )          .   ,   ,   ,      ,       : , ,  , ! </p><br><h1>   </h1><br><p>      :     ,           . 20             ,   C++  Python.   ,     ,    .         . </p><br><p>        ,    <code>shared_ptr</code>  TensorFlow   2016  2018 . </p><br><p> TensorFlow ‚àí       C++-,         Python- ( C++ ‚àí     TensorFlow, ). </p><br><p><img src="https://habrastorage.org/webt/dm/1g/zo/dm1gzovjtl2qbda7muz5wjzzjhq.png" alt="Bild"></p><br><p>         TensorFlow,  <code>shared_ptr</code> ,     .     ,     . </p><br><p>      C++?       .    ,   ?     ,     ,  C++  Python! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464405/">https://habr.com/ru/post/de464405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464391/index.html">10 interessante Berichte von Hacker-Konferenzen</a></li>
<li><a href="../de464393/index.html">Wie finde ich Programmierkurse und was sind die Besch√§ftigungsgarantien?</a></li>
<li><a href="../de464395/index.html">Blockchain RSA-basierter Zufall</a></li>
<li><a href="../de464399/index.html">Web Scraping in R, Teil 2. Beschleunigen Sie den Prozess durch paralleles Rechnen und Verwenden des Rcrawler-Pakets</a></li>
<li><a href="../de464403/index.html">So f√ºhren Sie ein Java-Projekt auf einem Shell-Runner aus, wenn Sie in ein GitLab-Repository pushen</a></li>
<li><a href="../de464407/index.html">Wie die weltweit gr√∂√üten Video√ºberwachungssysteme funktionieren</a></li>
<li><a href="../de464409/index.html">Wie sich die Politik des 19. Jahrhunderts heute auf die Standorte von Rechenzentren auswirkte</a></li>
<li><a href="../de464411/index.html">PVS-Studio: Motor des Fortschritts</a></li>
<li><a href="../de464413/index.html">PVS-Studio - Motor des Fortschritts</a></li>
<li><a href="../de464415/index.html">Neuer Hinweisservice f√ºr die Suche nach hh.ru.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>