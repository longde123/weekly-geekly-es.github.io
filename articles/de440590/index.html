<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜì üéõÔ∏è üö¥üèΩ Wo sind die Beine aus dem Java-Speichermodell? üë®üèª‚Äçüç≥ ‚úçÔ∏è üßõüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Moderne Hardware und Compiler sind bereit, unseren Code auf den Kopf zu stellen, wenn er nur schneller funktioniert. Und ihre Hersteller verstecken so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wo sind die Beine aus dem Java-Speichermodell?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440590/"> Moderne Hardware und Compiler sind bereit, unseren Code auf den Kopf zu stellen, wenn er nur schneller funktioniert.  Und ihre Hersteller verstecken sorgf√§ltig ihre innere K√ºche.  Und alles ist in Ordnung, solange der Code in einem Thread ausgef√ºhrt wird. <br><br>  In einer Multithread-Umgebung k√∂nnen Sie zwangsl√§ufig interessante Dinge beobachten.  Beispielsweise erfolgt die Ausf√ºhrung von Programmanweisungen nicht in der Reihenfolge, die im Quellcode angegeben ist.  Stimmen Sie zu, es ist unangenehm zu erkennen, dass die zeilenweise Ausf√ºhrung des Quellcodes nur unsere Vorstellung ist. <br><br>  Aber jeder hat es schon gemerkt, denn irgendwie muss man damit leben.  Und Java-Programmierer leben sogar gut.  Weil Java ein Speichermodell hat - das Java Memory Model (JMM), das ziemlich einfache Regeln zum Schreiben des richtigen Multithread-Codes bietet. <br><br>  Und diese Regeln reichen f√ºr die meisten Programme aus.  Wenn Sie sie nicht kennen, aber Multithread-Programme in Java schreiben oder schreiben m√∂chten, sollten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sich</a> so schnell wie m√∂glich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ihnen</a> vertraut machen.  Und wenn Sie es wissen, aber nicht genug Kontext haben oder es interessant ist zu wissen, woher JMMs Beine wachsen, kann Ihnen dieser Artikel helfen. <br><a name="habracut"></a><br><h2>  Und der Abstraktion nachjagen </h2><br>  Meiner Meinung nach gibt es einen Kuchen oder besser einen Eisberg.  JMM ist die Spitze des Eisbergs.  Der Eisberg selbst ist eine Theorie der Multithread-Programmierung unter Wasser.  Unter dem Eisberg ist die H√∂lle. <br><br><img src="https://habrastorage.org/webt/ub/jg/rf/ubjgrfe8bec3-ix9qgnkik3avoy.png"><br><br>  Ein Eisberg ist eine Abstraktion, wenn er leckt, werden wir mit Sicherheit die H√∂lle sehen.  Obwohl dort viele interessante Dinge passieren, werden wir im √úbersichtsartikel nicht darauf eingehen. <br><br>  In dem Artikel interessieren mich mehr folgende Themen: <br><br><ul><li>  Theorie und Terminologie </li><li>  Wie spiegelt sich die Theorie der Multithread-Programmierung in JMM wider? </li><li>  Wettbewerbsf√§hige Programmiermodelle </li></ul><br>  Die Theorie der Multithread-Programmierung erm√∂glicht es Ihnen, sich von der Komplexit√§t moderner Prozessoren und Compiler zu l√∂sen, die Ausf√ºhrung von Multithread-Programmen zu simulieren und deren Eigenschaften zu untersuchen.  Roman Elizarov hat einen ausgezeichneten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht verfasst</a> , dessen Zweck es ist, eine theoretische Grundlage f√ºr das Verst√§ndnis von JMM zu schaffen.  Ich empfehle den Bericht jedem, der sich f√ºr dieses Thema interessiert. <br><br>  Warum ist es wichtig, die Theorie zu kennen?  Meiner Meinung nach hoffe ich nur f√ºr mich, dass einige Programmierer der Meinung sind, dass JMM eine Komplikation der Sprache und das Patchen einiger Plattformprobleme mit Multithreading ist.  Die Theorie zeigt, dass Java die sehr komplexe Multithread-Programmierung nicht kompliziert, sondern vereinfacht und vorhersehbarer gemacht hat. <br><br><h2>  Wettbewerb und Parallelit√§t </h2><br>  Schauen wir uns zun√§chst die Terminologie an.  Leider gibt es keinen Konsens in der Terminologie. Wenn Sie verschiedene Materialien studieren, sto√üen Sie m√∂glicherweise auf unterschiedliche Definitionen von Wettbewerb und Parallelit√§t. <br><br>  Das Problem ist, dass selbst wenn wir der Wahrheit auf den Grund gehen und die genauen Definitionen dieser Konzepte finden, es kaum die Erwartung wert ist, dass jeder mit diesen Konzepten dasselbe bedeutet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die</a> Enden finden Sie hier nicht. <br><br>  Roman Elizarov legt in einem Bericht die Theorie der parallelen Programmierung f√ºr Praktiker nahe, dass diese Konzepte manchmal gemischt sind.  Parallele Programmierung wird manchmal als allgemeines Konzept unterschieden, das in wettbewerbsorientierte und verteilte unterteilt ist. <br><br>  Es scheint mir, dass Sie im Kontext von JMM immer noch Wettbewerb und Parallelit√§t trennen m√ºssen oder vielmehr verstehen m√ºssen, dass es zwei verschiedene Paradigmen gibt, egal wie sie genannt werden. <br><br>  Oft zitiert von Rob Pike, der Konzepte wie folgt unterscheidet: <br><br><ul><li>  Wettbewerb ist ein Weg, um viele Probleme gleichzeitig zu l√∂sen </li><li>  Parallelit√§t ist eine M√∂glichkeit, verschiedene Teile einer einzelnen Aufgabe auszuf√ºhren. </li></ul><br>  Die Meinung von Rob Pike ist kein Standard, aber meiner Meinung nach ist es zweckm√§√üig, darauf aufzubauen, um das Problem weiter zu untersuchen.  Lesen Sie hier mehr √ºber die Unterschiede. <br><br>  H√∂chstwahrscheinlich wird sich ein besseres Verst√§ndnis des Problems ergeben, wenn wir die Hauptmerkmale eines wettbewerbsorientierten und parallelen Programms hervorheben.  Es gibt viele Anzeichen, die als die bedeutendsten gelten. <br><br>  Zeichen des Wettbewerbs. <br><br><ul><li>  Das Vorhandensein mehrerer Kontrollfl√ºsse (z. B. Thread in Java, Coroutine in Kotlin): Wenn nur ein Kontrollfluss vorhanden ist, kann keine wettbewerbsf√§hige Ausf√ºhrung erfolgen </li><li>  Nicht deterministisches Ergebnis.  Das Ergebnis h√§ngt von zuf√§lligen Ereignissen, der Implementierung und der Durchf√ºhrung der Synchronisierung ab.  Selbst wenn jeder Stream vollst√§ndig deterministisch ist, ist das Endergebnis nicht deterministisch </li></ul><br>  Ein paralleles Programm verf√ºgt √ºber andere Funktionen. <br><br><ul><li>  Optional gibt es mehrere Kontrollabl√§ufe </li><li>  Dies kann zu einem deterministischen Ergebnis f√ºhren. Beispielsweise √§ndert sich das Ergebnis der Multiplikation jedes Elements des Arrays mit einer Zahl nicht, wenn Sie es in Teilen parallel multiplizieren </li></ul><br>  Seltsamerweise ist eine parallele Ausf√ºhrung in einem einzelnen Steuerungsfluss und sogar in einer Single-Core-Architektur m√∂glich.  Tatsache ist, dass Parallelit√§t auf der Ebene der Aufgaben (oder Kontrollfl√ºsse), an die wir gew√∂hnt sind, nicht die einzige M√∂glichkeit ist, Berechnungen parallel durchzuf√ºhren. <br><br>  Parallelit√§t ist m√∂glich auf der Ebene von: <br><br><ul><li>  Bits (auf 32-Bit-Computern erfolgt die Addition beispielsweise in einer Aktion, wobei alle 4 Bytes einer 32-Bit-Zahl parallel verarbeitet werden). </li><li>  Anweisungen (auf einem Kern, in einem Thread kann der Prozessor Anweisungen parallel ausf√ºhren, obwohl der Code sequentiell ist) </li><li>  Daten (es gibt Architekturen mit paralleler Datenverarbeitung (Single Instruction Multiple Data), die einen Befehl f√ºr einen gro√üen Datensatz ausf√ºhren k√∂nnen) </li><li>  Aufgaben (impliziert das Vorhandensein mehrerer Prozessoren oder Kerne) </li></ul><br>  Die Parallelit√§t auf Befehlsebene ist ein Beispiel f√ºr Optimierungen bei der Codeausf√ºhrung, die dem Programmierer verborgen bleiben. <br><br>  Es wird garantiert, dass der optimierte Code im Rahmen eines Threads dem Original entspricht, da es unm√∂glich ist, angemessenen und vorhersehbaren Code zu schreiben, wenn er nicht das tut, was der Programmierer beabsichtigt hat. <br><br>  Nicht alles, was parallel l√§uft, ist f√ºr JMM von Bedeutung.  Die gleichzeitige Ausf√ºhrung auf Befehlsebene innerhalb eines einzelnen Threads wird in JMM nicht ber√ºcksichtigt. <br><br>  Die Terminologie ist sehr wackelig, mit einer Rede von Roman Elizarov namens "Theorie der <b>parallelen</b> Programmierung f√ºr Praktiker", obwohl es mehr √ºber wettbewerbsf√§hige Programmierung gibt, wenn Sie sich an das oben Gesagte halten. <br><br>  Im Zusammenhang mit JMM werde ich mich in dem Artikel an den Begriff Wettbewerb halten, da es beim Wettbewerb h√§ufig um den allgemeinen Zustand geht.  Aber hier muss man aufpassen, dass man sich nicht an Begriffe klammert, sondern versteht, dass es verschiedene Paradigmen gibt. <br><br><h2>  Modelle mit einem gemeinsamen Zustand: "Rotation von Operationen" und "vorher passiert" </h2><br>  In seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> schreibt Maurice Herlichi (Autor von The Art Of Multiprocessor Programming), dass ein Wettbewerbssystem eine Sammlung sequentieller Prozesse enth√§lt (in theoretischen Arbeiten bedeutet dies dasselbe wie ein Thread), die √ºber das gemeinsame Ged√§chtnis kommunizieren. <br><br>  Das allgemeine Zustandsmodell umfasst Berechnungen mit Nachrichten, wobei der gemeinsam genutzte Zustand eine Nachrichtenwarteschlange ist, und Berechnungen mit gemeinsamem Speicher, wobei der gemeinsame Zustand Strukturen im Speicher sind. <br><br>  Jede der Berechnungen kann simuliert werden. <br><br>  Das Modell basiert auf einer Finite-State-Maschine.  Das Modell konzentriert sich ausschlie√ülich auf den gemeinsam genutzten Status und die lokalen Daten jedes Flusses werden vollst√§ndig ignoriert.  Jede Aktion von Fl√ºssen √ºber einen gemeinsam genutzten Zustand ist eine Funktion des √úbergangs in einen neuen Zustand. <br><br>  Wenn beispielsweise 4 Threads Daten in eine gemeinsam genutzte Variable schreiben, gibt es 4 Funktionen f√ºr den √úbergang in einen neuen Status.  Welche dieser Funktionen angewendet werden, h√§ngt von der Chronologie der Ereignisse im System ab. <br><br>  Nachrichten√ºbermittlungsberechnungen werden auf √§hnliche Weise modelliert, nur die Status- und √úbergangsfunktionen h√§ngen vom Senden oder Empfangen von Nachrichten ab. <br><br>  Wenn Ihnen das Modell kompliziert erschien, werden wir es im Beispiel beheben.  Es ist wirklich sehr einfach und intuitiv.  So sehr, dass die meisten Menschen das Programm, ohne √ºber die Existenz dieses Modells Bescheid zu wissen, immer noch analysieren, wie es das Modell vorschl√§gt. <br><br>  Ein solches Modell wird <b>durch den Wechsel der Operationen</b> als <b>Leistungsmodell bezeichnet</b> (der Name wurde in einem Bericht von Roman Elizarov geh√∂rt). <br><br>  In die Intuitivit√§t und Nat√ºrlichkeit k√∂nnen Sie die Vorteile des Modells sicher aufschreiben.  Sie k√∂nnen mit den Schl√ºsselw√∂rtern <b>Sequentielle Konsistenz</b> und der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeit von</a> Leslie Lamport in die Wildnis gehen. <br><br>  Es gibt jedoch eine wichtige Klarstellung zu diesem Modell.  Das Modell hat die Einschr√§nkung, dass alle Aktionen in einem gemeinsam genutzten Status sofort ausgef√ºhrt werden m√ºssen und gleichzeitig Aktionen nicht gleichzeitig ausgef√ºhrt werden k√∂nnen.  Sie sagen, dass ein solches System eine <b>lineare Reihenfolge hat</b> - alle Aktionen im System sind geordnet. <br><br>  In der Praxis passiert dies nicht.  Die Operation erfolgt nicht sofort, sondern wird in einem Intervall ausgef√ºhrt. Auf Mehrkernsystemen k√∂nnen sich diese Intervalle √ºberschneiden.  Dies bedeutet nat√ºrlich nicht, dass das Modell in der Praxis unbrauchbar ist. Sie m√ºssen lediglich bestimmte Bedingungen f√ºr seine Verwendung erstellen. <br><br>  Betrachten Sie in der Zwischenzeit ein anderes <b>Modell - ‚ÄûVorher passiert‚Äú -,</b> das sich nicht auf den Status konzentriert, sondern auf die Menge der Lese- und Schreibspeicherzellen w√§hrend der Ausf√ºhrung (Verlauf) und deren Beziehungen. <br><br>  Das Modell besagt, dass Ereignisse in verschiedenen Fl√ºssen nicht augenblicklich und atomar sind, sondern parallel, und es ist nicht m√∂glich, eine Ordnung zwischen ihnen aufzubauen.  Ereignisse (Schreiben und Lesen gemeinsam genutzter Daten) in Streams auf einer Multiprozessor- oder Multi-Core-Architektur treten tats√§chlich parallel auf.  Es gibt kein Konzept der globalen Zeit im System, wir k√∂nnen nicht verstehen, wann eine Operation beendet und eine andere gestartet wurde. <br><br>  In der Praxis bedeutet dies, dass wir einen Wert in eine Variable in einem Thread schreiben und dies beispielsweise am Morgen tun und den Wert dieser Variablen in einem anderen Thread am Abend lesen k√∂nnen, und wir k√∂nnen nicht sagen, dass wir den am Morgen geschriebenen Wert sicher lesen werden.  Theoretisch finden diese Operationen parallel statt und es ist nicht klar, wann eine endet und eine andere beginnt. <br><br>  Es ist schwer vorstellbar, wie sich herausstellt, dass einfache Lese- und Schreibvorg√§nge, die zu verschiedenen Tageszeiten ausgef√ºhrt werden, gleichzeitig stattfinden.  Aber wenn Sie dar√ºber nachdenken, ist es uns wirklich egal, wann die Ereignisse des Schreibens und Lesens eintreten, wenn wir nicht garantieren k√∂nnen, dass wir das Ergebnis der Aufnahme sehen werden. <br><br>  Und wir k√∂nnen das Ergebnis der Aufnahme wirklich nicht sehen, d.h.  In eine Variable, deren Wert in Strom <i>P</i> <i>0</i> ist <i>,</i> schreiben wir <i>1</i> , und in Strom <i>Q</i> lesen wir diese Variable.  Egal wie viel physische Zeit nach der Aufnahme vergeht, wir k√∂nnen immer noch <i>0</i> lesen. <br><br>  <b>So funktionieren Computer und das Modell spiegelt dies wider.</b> <br><br>  Das Modell ist vollst√§ndig abstrakt und ben√∂tigt eine bequeme Visualisierung f√ºr bequemes Arbeiten.  Zur Visualisierung und nur daf√ºr wird ein Modell mit globaler Zeit verwendet, mit dem Vorbehalt, dass beim Nachweis der Eigenschaften von Programmen keine globale Zeit verwendet wird.  In der Visualisierung wird jedes Ereignis als Intervall mit einem Anfang und einem Ende dargestellt. <br><br>  Die Veranstaltungen finden parallel statt, wie wir herausgefunden haben.  Dennoch hat das System eine <b>Teilreihenfolge</b> , da es spezielle Ereignispaare gibt, die eine Reihenfolge haben. In diesem Fall sagen sie, dass diese Ereignisse eine Beziehung haben, die vorher passiert ist.  Wenn Sie zum ersten Mal von der Beziehung ‚ÄûVorher passiert‚Äú h√∂ren, hilft es Ihnen wahrscheinlich nicht viel, wenn Sie wissen, dass diese Beziehung Ereignisse arrangiert. <br><br><h2>  Versuch, ein Java-Programm zu analysieren </h2><br>  Wir haben ein theoretisches Minimum betrachtet. Versuchen wir, ein Multithread-Programm in einer bestimmten Sprache - Java - aus zwei Threads mit einem gemeinsamen ver√§nderlichen Status zu betrachten. <br><br>  Ein klassisches Beispiel. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { a = <span class="hljs-number"><span class="hljs-number">0</span></span>; b = <span class="hljs-number"><span class="hljs-number">0</span></span>; x = <span class="hljs-number"><span class="hljs-number">0</span></span>; y = <span class="hljs-number"><span class="hljs-number">0</span></span>; } Thread p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { a = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = b; }); Thread q = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { b = <span class="hljs-number"><span class="hljs-number">1</span></span>; y = a; }); p.start(); q.start(); p.join(); q.join(); System.out.println(<span class="hljs-string"><span class="hljs-string">"x="</span></span> + x + <span class="hljs-string"><span class="hljs-string">", y="</span></span> + y);</code> </pre> <br>  Wir m√ºssen die Ausf√ºhrung dieses Programms simulieren und alle m√∂glichen Ergebnisse erhalten - die Werte der Variablen x und y.  Wie wir uns aus der Theorie erinnern, wird es mehrere Ergebnisse geben, ein solches Programm ist nicht deterministisch. <br><br>  Wie werden wir modellieren?  Ich m√∂chte sofort das Interleaving-Modell von Operationen verwenden.  Das Modell "Vorher passiert" sagt uns jedoch, dass Ereignisse in einem Thread parallel zu Ereignissen aus einem anderen Thread sind.  Daher ist das Modell alternierender Operationen hier nicht geeignet, wenn zwischen den Operationen keine Beziehung besteht, die zuvor aufgetreten ist. <br><br>  Das Ergebnis der Ausf√ºhrung jedes Threads ist immer deterministisch, da die Ereignisse in einem Thread immer geordnet sind. Beachten Sie, dass sie kostenlos eine Beziehung erhalten, die zuvor aufgetreten ist.  Es ist jedoch nicht ganz offensichtlich, wie Ereignisse in verschiedenen Fl√ºssen zu einer Beziehung f√ºhren k√∂nnen, die vorher passiert ist.  Nat√ºrlich ist diese Beziehung im Modell formalisiert, das gesamte Modell ist in mathematischer Sprache geschrieben.  Was damit in der Praxis in einer bestimmten Sprache zu tun ist, wird jedoch nicht sofort verstanden. <br><br>  Welche M√∂glichkeiten gibt es? <br><br>  Ignorieren Sie Einschr√§nkungen und simulieren Sie Interleaving.  Sie k√∂nnen es versuchen, vielleicht passiert nichts Schlimmes. <br><br>  Um zu verstehen, welche Ergebnisse erzielt werden k√∂nnen, z√§hlen wir einfach alle m√∂glichen Ausf√ºhrungsvarianten auf. <br><br>  Alle m√∂glichen Programmausf√ºhrungen k√∂nnen als endliche Zustandsmaschine dargestellt werden. <br><br><img src="https://habrastorage.org/webt/z_/nb/a4/z_nba4dq4_xlfkdvw7vypddxo3s.jpeg"><br><br>  Jeder Kreis ist ein Zustand des Systems, in unserem Fall die Variablen <i>a, b, x, y</i> .  Eine √úbergangsfunktion ist eine Aktion f√ºr einen Zustand, die das System in einen neuen Zustand versetzt.  Da zwei Fl√ºsse Aktionen f√ºr den allgemeinen Zustand ausf√ºhren k√∂nnen, gibt es zwei √úberg√§nge von jedem Zustand.  Doppelkreise sind der End- und Anfangszustand des Systems. <br><br>  Insgesamt sind 6 verschiedene Ausf√ºhrungen m√∂glich, die zu Paaren von x, y-Werten f√ºhren: <br> <code>(1, 1), (1, 0), (0, 1) <br></code> <br><img src="https://habrastorage.org/webt/uu/dn/ev/uudnevagixnomxjnrydhfgrph4i.png"><br><br>  Wir k√∂nnen das Programm ausf√ºhren und die Ergebnisse √ºberpr√ºfen.  Wie es sich f√ºr ein Wettbewerbsprogramm geh√∂rt, wird es ein nicht deterministisches Ergebnis haben. <br><br>  Zum Testen wettbewerbsf√§higer Programme ist es besser, spezielle Tools ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tool</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> ) zu verwenden. <br><br>  Sie k√∂nnen jedoch versuchen, das Programm mehrere Millionen Mal auszuf√ºhren, oder noch besser, einen Zyklus schreiben, der dies f√ºr uns erledigt. <br><br>  Wenn wir den Code auf einer Single-Core- oder Single-Prozessor-Architektur ausf√ºhren, sollten wir das Ergebnis aus der erwarteten Menge erhalten.  Das Rotationsmodell funktioniert einwandfrei.  Bei einer Multi-Core-Architektur, z. B. x86, kann das Ergebnis uns √ºberraschen - wir k√∂nnen das Ergebnis (0,0) erhalten, das nicht unserer Modellierung entspricht. <br><br>  Die Erkl√§rung hierf√ºr finden Sie im Internet unter dem Schl√ºsselwort - <b>Neuordnung</b> .  Jetzt ist es wichtig zu verstehen, dass <b>Interleaving-Modellierung in einer Situation, in der wir die Reihenfolge des Zugriffs auf den gemeinsam genutzten Status nicht bestimmen k√∂nnen, wirklich nicht geeignet ist</b> . <br><br><h2>  Theorie der kompetitiven Programmierung und JMM </h2><br>  Es ist Zeit, sich die Beziehung ‚ÄûVorher passiert‚Äú genauer anzusehen und wie sie mit JMM befreundet ist.  Die urspr√ºngliche Definition der Beziehung ‚ÄûVorher passiert‚Äú finden Sie unter Zeit, Uhren und Reihenfolge der Ereignisse in einem verteilten System. <br><br>  Das Sprachspeichermodell hilft beim Schreiben von Wettbewerbscode, da es bestimmt, welche Operationen mit ‚Äûzuvor geschehen‚Äú zusammenh√§ngen.  Eine Liste solcher Vorg√§nge finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> im Abschnitt Happens-before-Order.  In diesem Abschnitt wird die Frage beantwortet: Unter welchen Bedingungen wird das Ergebnis der Aufzeichnung in einem anderen Stream angezeigt? <br><br>  Es gibt verschiedene Bestellungen in JMM.  Alexei Shipilev spricht in einem seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berichte</a> sehr energisch √ºber die Regeln. <br><br>  Im globalen Zeitmodell sind alle Operationen im selben Thread in Ordnung.  Beispielsweise k√∂nnen die Ereignisse beim Schreiben und Lesen einer Variablen als zwei Intervalle dargestellt werden. Das Modell garantiert dann, dass sich diese Intervalle niemals im Rahmen eines einzelnen Streams √ºberschneiden.  In JMM wird diese Reihenfolge als Programmreihenfolge ( <i>PO</i> ) bezeichnet. <br><br>  <i>PO</i> bindet Aktionen in einem einzelnen Thread und sagt nichts √ºber die Ausf√ºhrungsreihenfolge aus, sondern spricht nur √ºber die Reihenfolge im Quellcode.  Dies reicht v√∂llig aus, um den <b>Determinismus f√ºr jeden Stream separat</b> zu gew√§hrleisten.  <i>PO</i> kann als Rohdaten betrachtet werden.  <i>PO ist</i> immer einfach in einem Programm anzuordnen - alle Operationen (lineare Reihenfolge) im Quellcode innerhalb eines einzelnen Streams haben <i>PO</i> . <br><br>  In unserem Beispiel erhalten wir ungef√§hr Folgendes: <br><br>  <code>P: a = 1 PO x = b</code> - Schreiben in a und Lesen von b hat eine PO-Reihenfolge <br>  <code>Q: b = 1 PO y = a</code> - schreibe in b und lese a hat eine PO-Reihenfolge <br><br>  Ich habe diese Form des Schreibens ausspioniert <i>w (a, 1) PO r (b): 0.</i> Ich hoffe wirklich, dass niemand sie f√ºr Berichte patentiert hat.  Die Spezifikation hat jedoch eine √§hnliche Form. <br><br>  Aber jeder Thread einzeln ist f√ºr uns nicht besonders interessant, da die Threads einen gemeinsamen Zustand haben, sind wir mehr an der Interaktion der Fl√ºsse interessiert.  Wir m√∂chten nur sicherstellen, dass wir eine Aufzeichnung von Variablen in anderen Threads sehen. <br><br>  Ich m√∂chte Sie daran erinnern, dass dies f√ºr uns nicht funktioniert hat, da die Operationen zum Schreiben und Lesen von Variablen in verschiedenen Streams nicht sofort erfolgen (dies sind Segmente, die sich √ºberschneiden). Es ist unm√∂glich zu analysieren, wo der Beginn und das Ende von Operationen liegen. <br><br>  Die Idee ist einfach: In dem Moment, in dem wir die Variable a im Stream <i>Q</i> lesen, endet die Aufzeichnung derselben Variablen im Stream <i>P</i> m√∂glicherweise noch nicht.  Und egal wie viel physische Zeit diese Ereignisse gemeinsam haben - eine Nanosekunde oder einige Stunden. <br><br>  Um Ereignisse zu bestellen, ben√∂tigen wir die Beziehung ‚ÄûVorher passiert‚Äú.  JMM definiert diese Beziehung.  Die Spezifikation legt die Reihenfolge in einem Thread fest: <br><br>  <i>Wenn sich die Operation x und y im selben Thread befinden und in <i>PO</i> zuerst x und dann y auftritt, ist x vor y aufgetreten.</i> <i><br></i> <br><br>  Mit Blick auf die Zukunft k√∂nnen wir sagen, dass wir alle <i>Bestellungen</i> durch Happens-before ( <i>HB</i> ) ersetzen k√∂nnen: <br><br><pre> <code class="plaintext hljs">P: w(a, 1) HB r(b) Q: w(b, 1) HB r(a)</code> </pre> <br>  Aber wir kehren wieder im Rahmen eines Stroms zur√ºck.  <i>HB ist</i> zwischen Operationen in verschiedenen Threads m√∂glich. Um diese F√§lle zu behandeln, werden wir uns mit anderen Auftr√§gen vertraut machen. <br><br>  Synchronisationsreihenfolge ( <i>SO</i> ) - Links Synchronisationsaktionen ( <i>SA</i> ). Eine vollst√§ndige Liste der <i>SA finden Sie</i> in der Spezifikation in Abschnitt 17.4.2.  Aktionen  Hier sind einige davon: <br><br><ul><li>  Fl√ºchtige Variable lesen </li><li>  Fl√ºchtige Variable schreiben </li><li>  Monitorschloss </li><li>  Monitor entsperren </li></ul><br>  <i>SO</i> ist f√ºr uns interessant, weil es die Eigenschaft hat, dass alle Messwerte in der <i>SO-</i> Reihenfolge die letzten Eintr√§ge in <i>SO sehen</i> .  Und ich erinnere Sie daran, dass wir dies nur erreichen. <br><br>  An dieser Stelle werde ich wiederholen, wonach wir streben.  Wir haben ein Multithread-Programm, wir wollen alle m√∂glichen Ausf√ºhrungen simulieren und alle Ergebnisse erhalten, die es liefern kann.  Es gibt Modelle, mit denen dies ganz einfach m√∂glich ist.  Sie erfordern jedoch, dass alle Aktionen f√ºr den gemeinsam genutzten Status angeordnet werden. <br><br>  Laut der <i>SO-</i> Eigenschaft - wenn alle Aktionen im Programm <i>SA sind, werden</i> wir unser Ziel erreichen.  Das hei√üt,  Wir k√∂nnen den <i>fl√ºchtigen Modifikator</i> f√ºr alle Variablen einstellen und das Wechselmodell verwenden.  Wenn Ihnen die Intuition sagt, dass sich das nicht lohnt, dann haben Sie absolut Recht.  Mit diesen Aktionen verbieten wir einfach die Optimierung des Codes. Manchmal ist dies nat√ºrlich eine gute Option, aber dies ist definitiv kein allgemeiner Fall. <br><br>  Betrachten Sie eine andere Synchronizes-With Order ( <i>SW</i> ) - SO-Reihenfolge f√ºr bestimmte fl√ºchtige Paare zum Entsperren / Sperren, Schreiben / Lesen.  Es spielt keine Rolle, in welchen Fl√ºssen sich diese Aktionen befinden. Hauptsache, sie befinden sich auf derselben fl√ºchtigen Monitorvariablen.  <i>SW</i> bietet eine Br√ºcke zwischen Threads. <br><br>  Und jetzt kommen wir zu der interessantesten Reihenfolge - Happens-before ( <i>HB</i> ). <br>  <i>HB</i> ist eine transitive Schlie√üung der Vereinigung von <i>SW</i> und <i>PO</i> .  <i>PO</i> gibt eine lineare Ordnung innerhalb des Stroms an, und <i>SW</i> stellt eine Br√ºcke zwischen den Str√∂men bereit.  <i>HB ist</i> transitiv, d.h.  wenn <br><br><pre> <code class="plaintext hljs">x HB y  y HB z,  x HB z</code> </pre> <br>  Die Spezifikation enth√§lt eine Liste von <i>HB-</i> Beziehungen, mit denen Sie sich genauer vertraut machen k√∂nnen. Hier einige Beispiele aus der Liste: <br><br>  Innerhalb eines einzelnen Threads wird jede Operation ausgef√ºhrt, bevor eine Operation im Quellcode darauf folgt. <br><br>  Das Beenden eines synchronisierten Blocks / einer synchronisierten Methode erfolgt, bevor ein synchronisierter Block / eine synchronisierte Methode auf demselben Monitor eingegeben wird. <br><br>  Das Schreiben eines <i>fl√ºchtigen</i> Feldes erfolgt, bevor dasselbe <i>fl√ºchtige</i> Feld gelesen wird. <br><br>  Kehren wir zu unserem Beispiel zur√ºck: <br><br><pre> <code class="plaintext hljs">P: a = 1 PO x = b Q: b = 1 PO y = a</code> </pre> <br>  Kehren wir zu unserem Beispiel zur√ºck und versuchen, das Programm unter Ber√ºcksichtigung der Bestellungen zu analysieren. <br><br>  Die Analyse des Programms mit JMM basiert darauf, Hypothesen aufzustellen und diese zu best√§tigen oder zu widerlegen. <br><br><img src="https://habrastorage.org/webt/pu/hy/nz/puhynztfclug7afvnbpfht54wsg.png"><br><br>  Wir beginnen unsere Analyse mit der Hypothese, dass keine einzige Programmausf√ºhrung das Ergebnis liefert (0, 0).  Das Fehlen eines Ergebnisses (0, 0) bei allen Ausf√ºhrungen ist eine vermeintliche Eigenschaft des Programms. <br><br>  Wir testen die Hypothese, indem wir verschiedene Ausf√ºhrungen erstellen. <br><br>  Ich habe die Nomenklatur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier entdeckt</a> (manchmal erscheint sie anstelle von <code>‚Ä¶</code> Wort <code>race</code> mit einem Pfeil, Alexey selbst verwendet den Pfeil und das Wort Rennen in seinen Berichten, warnt jedoch davor, dass diese Reihenfolge in JMM nicht vorhanden ist, und verwendet diese Notation aus Gr√ºnden der Klarheit). <br><br>  Wir machen eine kleine Reservierung. <br><br>  Da alle Aktionen f√ºr gemeinsame Variablen f√ºr uns wichtig sind und im Beispiel gemeinsame Variablen <i>a, b, x, y sind</i> .  Dann muss zum Beispiel die Operation x = b als r (b) und w (x, b) betrachtet werden, und <code>r(b) HB w(x,b)</code> (basierend auf <i>PO</i> ).  Da die Variable x jedoch nirgendwo in den Threads gelesen wird (das Lesen in gedruckter Form am Ende des Codes ist nicht interessant, da nach der Verkn√ºpfungsoperation im Thread der Wert x angezeigt wird), k√∂nnen wir die Aktion w (x, b) nicht ber√ºcksichtigen. <br><br>  √úberpr√ºfen Sie die erste Leistung. <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(b): 0 ‚Ä¶ w(b, 1) HB r(a): 0</code> </pre> <br>  Im Strom <i>Q</i> lesen wir die Variable a, schreiben in diese Variable im Strom <i>P.</i>  Es gibt keine Reihenfolge zwischen Schreiben und Lesen <i>(PO, SW, HB)</i> . <br><br>  Wenn die Variable in einen Thread geschrieben ist und der Lesevorgang in einem anderen Thread erfolgt und keine <i>HB-</i> Beziehung zwischen Operationen besteht, wird angegeben, dass die Variable unter Race gelesen wird.  Und unter dem Rennen nach JMM k√∂nnen wir entweder den zuletzt aufgezeichneten Wert in <i>HB</i> oder einen anderen Wert lesen. <br><br>  Eine solche Leistung ist m√∂glich.  Die Ausf√ºhrung <b>verst√∂√üt nicht gegen JMM</b> .  Wenn Sie die Variable a lesen, k√∂nnen Sie einen beliebigen Wert sehen, da das Lesen unter dem Rennen erfolgt und es keine Garantie gibt, dass die Aktion w (a, 1) angezeigt wird.  Dies bedeutet nicht, dass das Programm korrekt funktioniert, sondern lediglich, dass ein solches Ergebnis erwartet wird. <br><br>  Es macht keinen Sinn, den Rest der Ausf√ºhrung zu ber√ºcksichtigen, da die <b>Hypothese bereits zerst√∂rt ist</b> . <br><br>  JMM sagt, wenn das Programm keine Datenrennen hat, k√∂nnen alle Ausf√ºhrungen als sequentiell betrachtet werden.  Lassen Sie uns das Rennen loswerden, daf√ºr m√ºssen wir die Lese- und Schreibvorg√§nge in verschiedenen Threads optimieren.  Es ist wichtig zu verstehen, dass ein Multithread-Programm im Gegensatz zu einem sequentiellen Programm mehrere Ausf√ºhrungen hat.  Und um zu sagen, dass ein Programm eine Eigenschaft hat, muss nachgewiesen werden, dass das Programm diese Eigenschaft nicht bei einer der Ausf√ºhrungen, sondern bei allen Ausf√ºhrungen hat. <br><br>  Um zu beweisen, dass das Programm kein Rennen ist, m√ºssen Sie dies f√ºr alle Auff√ºhrungen tun.  Versuchen wir, <i>SA</i> zu <i>erstellen</i> und die Variable a mit einem <i>fl√ºchtigen Modifikator zu</i> markieren.  <i>Fl√ºchtigen</i> Variablen wird v vorangestellt. <br><br>  Wir stellen <b>eine neue Hypothese auf</b> .  Wenn die Variable a <i>fl√ºchtig</i> gemacht wird, ergibt keine Ausf√ºhrung des Programms das Ergebnis (0, 0). <br><br><pre> <code class="plaintext hljs">w(va, 1) HB r(b): 0 ‚Ä¶ w(b, 1) HB r(va): 0</code> </pre> <br>  Die Ausf√ºhrung <b>verst√∂√üt nicht gegen JMM</b> .  Das Lesen von Va geschieht unter dem Rennen.  Jede Rasse zerst√∂rt die Transitivit√§t von HB. <br><br>  Wir stellen eine <b>andere Hypothese auf</b> .  Wenn die Variable b <i>fl√ºchtig</i> gemacht wird, ergibt keine Ausf√ºhrung des Programms das Ergebnis (0, 0). <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(vb): 0 ‚Ä¶ w(vb, 1) HB r(a): 0</code> </pre> <br>  Die Ausf√ºhrung verst√∂√üt nicht gegen JMM.  Das Lesen von a erfolgt unter dem Rennen. <br><br>  <b>Testen</b> wir <b>die Hypothese,</b> dass, wenn die Variablen a und b <i>fl√ºchtig sind</i> , keine Programmausf√ºhrung das Ergebnis (0, 0) ergibt. <br><br>  √úberpr√ºfen Sie die erste Leistung. <br><br><pre> <code class="plaintext hljs">w(va, 1) SO r(vb): 0 SO w(vb, 1) SO r(va): 0</code> </pre> <br>  Da alle Aktionen im <i>SA-</i> Programm (insbesondere das Lesen oder Schreiben einer <i>fl√ºchtigen</i> Variablen), erhalten wir die vollst√§ndige <i>SO-</i> Reihenfolge zwischen allen Aktionen.  Dies bedeutet, dass r (va) w (va, 1) sehen sollte.  Diese <b>Ausf√ºhrung verst√∂√üt gegen JMM</b> . <br><br>  Es ist notwendig, mit der n√§chsten Ausf√ºhrung fortzufahren, um die Hypothese zu best√§tigen.  Da es jedoch f√ºr jede Ausf√ºhrung <i>SO</i> gibt, k√∂nnen Sie vom Formalismus abweichen - es ist offensichtlich, dass das Ergebnis (0, 0) das JMM f√ºr jede Ausf√ºhrung verletzt. <br><br>  Um das Rotationsmodell zu verwenden, m√ºssen Sie f√ºr die Variablen a und b <i>fl√ºchtig</i> hinzuf√ºgen.  Ein solches Programm liefert die Ergebnisse (1,1), (1,0) oder (0,1). <br><br>  Am Ende k√∂nnen wir sagen, dass sehr einfache Programme recht einfach zu analysieren sind. <br><br>  Komplexe Programme mit einer gro√üen Anzahl von Ausf√ºhrungen und gemeinsam genutzten Daten sind jedoch schwer zu analysieren, da Sie alle Ausf√ºhrungen √ºberpr√ºfen m√ºssen. <br><br><h2>  Andere wettbewerbsf√§hige Ausf√ºhrungsmodelle </h2><br>  Warum andere wettbewerbsf√§hige Programmiermodelle in Betracht ziehen? <br><br>  Die Verwendung von Threads und Synchronisationsprimitiven kann alle Probleme l√∂sen.  Dies ist alles wahr, aber das Problem ist, dass wir ein Beispiel f√ºr ein Dutzend Codezeilen untersucht haben, bei denen 4 Codezeilen n√ºtzliche Arbeit leisten. <br><br>  Und dort stie√üen wir auf eine Reihe von Fragen, bis zu dem Punkt, dass wir ohne die Spezifikation nicht einmal alle m√∂glichen Ergebnisse korrekt berechnen k√∂nnten.  Threads und Synchronisationsprimitive sind eine sehr schwierige Sache, deren Verwendung in einigen F√§llen sicherlich gerechtfertigt ist.  Grunds√§tzlich beziehen sich diese F√§lle auf die Leistung. <br><br>  Entschuldigung, ich beziehe mich viel auf Elizarov, aber was kann ich tun, wenn eine Person wirklich Erfahrung auf diesem Gebiet hat?  Also hat er einen weiteren wunderbaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht,</a> "Millionen von Zitaten pro Sekunde in reinem Java", in dem er sagt, dass ein unver√§nderlicher Zustand gut ist, aber ich werde meine Millionen von Zitaten nicht in jeden Stream kopieren, sorry.  Aber nicht alle haben Millionen von Zitaten, viele haben nat√ºrlich bescheidenere Aufgaben.  Gibt es wettbewerbsf√§hige Programmiermodelle, mit denen Sie JMM vergessen und dennoch sicheren, wettbewerbsf√§higen Code schreiben k√∂nnen? <br><br>  Wenn Sie sich wirklich f√ºr diese Frage interessieren, empfehle ich Paul Butchers Buch ‚ÄûSieben Modelle des Wettbewerbs in sieben Wochen.  Wir enth√ºllen die Geheimnisse der Fl√ºsse. ‚Äú  Leider war es nicht m√∂glich, gen√ºgend Informationen √ºber den Autor zu finden, aber das Buch sollte Ihre Augen f√ºr neue Paradigmen √∂ffnen.  Leider habe ich keine Erfahrung mit vielen anderen Wettbewerbsmodellen, daher habe ich die Rezension aus diesem Buch erhalten. <br><br>  Beantwortung der obigen Frage.  Soweit ich wei√ü, gibt es wettbewerbsf√§hige Programmiermodelle, die den Bedarf an Kenntnissen √ºber die Nuancen von JMM zumindest erheblich reduzieren k√∂nnen.  Wenn es jedoch einen ver√§nderlichen Zustand und Fl√ºsse gibt, dann vermasseln Sie keine Abstraktionen dar√ºber, es wird immer noch einen Ort geben, an dem diese Fl√ºsse den Zugriff auf den Zustand synchronisieren sollten.  Eine andere Frage ist, dass Sie den Zugriff wahrscheinlich nicht selbst synchronisieren m√ºssen. Ein Framework kann dies beispielsweise beantworten.  Aber wie gesagt, fr√ºher oder sp√§ter kann es zu einer Abstraktion kommen. <br><br>  Sie k√∂nnen den ver√§nderlichen Status √ºberhaupt ausschlie√üen.  In der Welt der funktionalen Programmierung ist dies √ºbliche Praxis.  Wenn es keine ver√§nderlichen Strukturen gibt, gibt es per Definition wahrscheinlich keine Probleme mit dem gemeinsam genutzten Speicher.  In der JVM gibt es Vertreter funktionaler Sprachen wie Clojure.  Clojure ist eine hybride Funktionssprache, da Sie damit weiterhin Datenstrukturen √§ndern k√∂nnen, aber effizientere und sicherere Tools daf√ºr bereitstellen. <br><br>  Funktionale Sprachen sind ein gro√üartiges Werkzeug f√ºr die Arbeit mit wettbewerbsf√§higem Code.  Pers√∂nlich benutze ich es nicht, weil mein T√§tigkeitsbereich die mobile Entwicklung ist und es dort einfach nicht zum Mainstream geh√∂rt.  Obwohl bestimmte Ans√§tze √ºbernommen werden k√∂nnen. <br><br>  Eine andere M√∂glichkeit, mit ver√§nderlichen Daten zu arbeiten, besteht darin, die gemeinsame Nutzung von Daten zu verhindern.  Schauspieler sind ein solches Programmiermodell.  Akteure vereinfachen die Programmierung, indem sie den gleichzeitigen Zugriff auf Daten nicht zulassen.  Dies wird durch die Tatsache erreicht, dass eine Funktion, die zu einem bestimmten Zeitpunkt Arbeit ausf√ºhrt, nur in einem Thread arbeiten kann. <br><br>  Ein Akteur kann jedoch den internen Status √§ndern.  Da zum n√§chsten Zeitpunkt derselbe Akteur in einem anderen Thread ausgef√ºhrt werden kann, kann dies ein Problem sein.  Das Problem kann auf verschiedene Arten gel√∂st werden. In Programmiersprachen wie Erlang oder Elixir, in denen das Akteurmodell ein integraler Bestandteil der Sprache ist, k√∂nnen Sie mithilfe der Rekursion einen Akteur mit einem neuen Status aufrufen. <br><br>  In Java k√∂nnen Rekursionen zu teuer sein.  In Java gibt es jedoch Frameworks f√ºr die bequeme Arbeit mit diesem Modell. Das wahrscheinlich beliebteste ist Akka.  Akka-Entwickler haben sich um alles gek√ºmmert. Sie k√∂nnen im Dokumentationsabschnitt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akka und im Java-Speichermodell</a> zwei F√§lle lesen, in denen der Zugriff auf einen gemeinsam genutzten Status von verschiedenen Threads aus erfolgen kann.  Noch wichtiger ist jedoch, dass in der Dokumentation angegeben ist, welche Ereignisse sich auf ‚Äûzuvor geschehen‚Äú beziehen.  Das hei√üt,  Dies bedeutet, dass wir den Status des Akteurs beliebig √§ndern k√∂nnen. Wenn wir jedoch die n√§chste Nachricht erhalten und m√∂glicherweise in einem anderen Thread verarbeiten, werden garantiert alle √Ñnderungen in einem anderen Thread angezeigt. <br><br><h2>  Warum ist das Threading-Modell so beliebt? </h2><br>  Wir haben zwei Modelle wettbewerbsf√§higer Programmierung untersucht. Tats√§chlich gibt es noch mehr, die wettbewerbsf√§hige Programmierung einfacher und sicherer machen. <br><br>  Aber warum sind Threads und Schl√∂sser dann immer noch so beliebt? <br><br>  Ich denke, der Grund ist die Einfachheit des Ansatzes. Nat√ºrlich ist es einerseits einfach, viele nicht offensichtliche Fehler mit Streams zu machen, sich in den Fu√ü zu schie√üen usw.  Auf der anderen Seite <b>gibt es nichts Kompliziertes in den Fl√ºssen, besonders wenn Sie nicht √ºber die Konsequenzen nachdenken</b> . <br><br>  Zu einem bestimmten Zeitpunkt kann der Kernel einen Befehl ausf√ºhren (eigentlich nicht, Parallelit√§t besteht auf Befehlsebene, aber jetzt spielt es keine Rolle), aber aufgrund von Multitasking k√∂nnen selbst auf Single-Core-Computern mehrere Programme gleichzeitig ausgef√ºhrt werden (nat√ºrlich Pseudo gleichzeitig). <br><br>  Damit Multitasking funktioniert, brauchen Sie Wettbewerb.  Wie wir bereits herausgefunden haben, ist Wettbewerb ohne mehrere Managementfl√ºsse nicht m√∂glich. <br><br>  Wie viele Threads muss Ihrer Meinung nach ein Programm, das auf einem Quad-Core-Handyprozessor ausgef√ºhrt wird, so schnell und reaktionsschnell wie m√∂glich sein? <br><br>  Es kann mehrere Dutzend geben.  Die Frage ist nun, warum wir so viele Threads f√ºr ein Programm ben√∂tigen, das auf Hardware ausgef√ºhrt wird, mit der Sie jeweils nur 2-4 Threads ausf√ºhren k√∂nnen. <br><br>  Um diese Frage zu beantworten, nehmen wir an, dass nur unser Programm auf dem Ger√§t ausgef√ºhrt wird und sonst nichts.  Wie w√ºrden wir die uns zur Verf√ºgung gestellten Ressourcen verwalten? <br><br>  Sie k√∂nnen einen Kern f√ºr die Benutzeroberfl√§che und den Rest des Kernels f√ºr alle anderen Aufgaben angeben.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn beispielsweise einer der Threads blockiert ist, kann der Thread zum Speichercontroller gehen und auf eine Antwort warten, dann erhalten wir einen blockierten Kernel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Technologien gibt es, um das Problem zu l√∂sen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt Threads in Java, wir k√∂nnen viele Threads erstellen, und dann k√∂nnen andere Threads Operationen ausf√ºhren, w√§hrend ein Thread blockiert ist. Mit einem Werkzeug wie Threads k√∂nnen wir unser Leben vereinfachen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Ansatz mit Threads ist nicht kostenlos, das Erstellen von Threads ben√∂tigt normalerweise Zeit (dies wird von den Thread-Pools festgelegt), ihnen wird Speicher zugewiesen, das Wechseln zwischen Threads ist eine teure Operation. Es ist jedoch relativ einfach, mit ihnen zu programmieren. Dies ist eine massive Technologie, die in allgemeinen Sprachen wie Java so h√§ufig verwendet wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java liebt Streams im Allgemeinen. Es ist nicht erforderlich, f√ºr jede Aktion einen Stream zu erstellen. Es gibt √ºbergeordnete Dinge wie Executors, mit denen Sie mit Pools arbeiten und skalierbareren und flexibleren Code schreiben k√∂nnen. Streams sind sehr praktisch. Sie k√∂nnen eine Blockierungsanforderung an das Netzwerk senden und die Ergebnisverarbeitung in die n√§chste Zeile schreiben. Selbst wenn wir einige Sekunden auf das Ergebnis warten, k√∂nnen wir dennoch andere Aufgaben ausf√ºhren, da das Betriebssystem die Verteilung der Prozessorzeit zwischen den Threads √ºbernimmt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams sind nicht nur in der Backend-Entwicklung beliebt. In der mobilen Entwicklung wird es als ganz normal angesehen, Dutzende von Streams zu erstellen, damit Sie einen Stream f√ºr einige Sekunden blockieren und darauf warten k√∂nnen, dass Daten √ºber das Netzwerk oder Daten aus dem Socket heruntergeladen werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachen wie Erlang oder Clojure sind immer noch eine Nische, und daher sind die von ihnen verwendeten wettbewerbsf√§higen Programmiermodelle nicht so beliebt. </font><font style="vertical-align: inherit;">Die Prognosen f√ºr sie sind jedoch am optimistischsten.</font></font><br><br><h2>  Schlussfolgerungen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie auf der JVM-Plattform entwickeln, m√ºssen Sie die von der Plattform angegebenen Spielregeln akzeptieren. </font><font style="vertical-align: inherit;">Dies ist die einzige M√∂glichkeit, normalen Multithread-Code zu schreiben. </font><font style="vertical-align: inherit;">Es ist sehr w√ºnschenswert, den Kontext von allem zu verstehen, was passiert, damit es einfacher ist, die Spielregeln zu akzeptieren. </font><font style="vertical-align: inherit;">Es ist noch besser, sich umzuschauen und sich mit anderen Paradigmen vertraut zu machen, obwohl Sie vom U-Boot aus nichts erreichen k√∂nnen, aber neue Ans√§tze und Werkzeuge entdecken k√∂nnen.</font></font><br><br><h2>  Zus√§tzliche Materialien </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe versucht, im Text des Artikels Links zu Quellen zu platzieren, aus denen ich Informationen erhalten habe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen ist JMM-Material im Internet leicht zu finden. </font><font style="vertical-align: inherit;">Hier werde ich Links zu zus√§tzlichem Material ver√∂ffentlichen, das mit JMM in Verbindung steht und m√∂glicherweise nicht sofort auff√§llt. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Shipilevs Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ich wei√ü, was offensichtlich ist, aber es ist nur eine S√ºnde, ganz zu schweigen davon</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheremin Ruslans Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - er hat in letzter Zeit nicht aktiv geschrieben, Sie m√ºssen nach seinen alten Eintr√§gen im Blog suchen, glauben Sie mir, es lohnt sich - es gibt eine Quelle</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr Gleb Smirnov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - es gibt ausgezeichnete Artikel √ºber Multithreading und das Speichermodell</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Elizarovs Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird aufgegeben, aber arch√§ologische Ausgrabungen m√ºssen durchgef√ºhrt werden. </font><font style="vertical-align: inherit;">Im Allgemeinen hat Roman viel getan, um die Menschen in der Theorie der Multithread-Programmierung zu unterrichten. Suchen Sie in den Medien danach.</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podcasts</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Themen, die ich besonders interessant fand. </font><font style="vertical-align: inherit;">Es geht nicht um JMM, es geht um die H√∂lle, die in der Dr√ºse geschieht. </font><font style="vertical-align: inherit;">Aber nachdem ich ihnen zugeh√∂rt habe, m√∂chte ich die Sch√∂pfer von JMM k√ºssen, die uns vor all dem gesch√ºtzt haben.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 62</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ausw√§rts Alexander Titov und Amir Ayupov, Intel-Ingenieure und Alexei Markin, Programmierer vom ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 63</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Alexei Markin, Programmierer von ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachbesprechung: # 107 Climbers Stories</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachbesprechung: # 154 Guts - Neujahrsangriff</font></font></a> <br></li></ul><br>  <b>Video</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Achten Sie neben den Reden der oben genannten Personen auch auf das akademische Video. </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computer Science Center ‚Äî  11.     </a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440590/">https://habr.com/ru/post/de440590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440576/index.html">Wichtige √Ñnderungen an CTE in PostgreSQL 12</a></li>
<li><a href="../de440582/index.html">Werden Elektroautos auf den Grund des Autokonzerns gezogen?</a></li>
<li><a href="../de440584/index.html">Was ist los mit dem Raspberry Pi</a></li>
<li><a href="../de440586/index.html">Exonum-Konsens: Wie es funktioniert</a></li>
<li><a href="../de440588/index.html">Das MIT hat gelernt, wie man Schall mit einem Laser √ºbertr√§gt</a></li>
<li><a href="../de440592/index.html">Erstellen eines AR-Spiels mit Vuforia</a></li>
<li><a href="../de440594/index.html">1C und Yandex. Cloud Compute Cloud. Auf und ab</a></li>
<li><a href="../de440596/index.html">Flightradar24 - wie geht das?</a></li>
<li><a href="../de440598/index.html">Die InSight Martian-Sonde funktioniert erfolgreich auf dem Roten Planeten</a></li>
<li><a href="../de440600/index.html">Wie viele .com-Domainnamen werden nicht verwendet?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>