<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎫 👇🏻 🙎 Hase und Igel中的AI：三人制 😮 💇🏽 🕳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在20世纪90年代末的棋盘游戏真正繁荣之后，这个家庭留下了数个装有游戏的盒子。 其中之一是原始德语版本的“野兔与刺猬”游戏。 一种适合多名玩家的游戏，其中随机性的元素被最小化，其敏锐的计算能力和几步之遥的“向前看”能力将获胜。 

 我在游戏中屡屡失利，导致我编写计算机“情报”以选择最佳举动。 智力...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hase und Igel中的AI：三人制</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432382/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/z2/ng/inz2ngydxteyo76jh1r9du9oxx8.jpeg"></div><br> 在20世纪90年代末的棋盘游戏真正繁荣之后，这个家庭留下了数个装有游戏的盒子。 其中之一是原始德语版本的“野兔与刺猬”游戏。 一种适合多名玩家的游戏，其中随机性的元素被最小化，其敏锐的计算能力和几步之遥的“向前看”能力将获胜。 <br><br> 我在游戏中屡屡失利，导致我编写计算机“情报”以选择最佳举动。 智力，理想情况下可以与野兔和刺猬的宗师作战（并且，茶，而不是国际象棋，游戏会更容易）。 本文的其余部分描述了开发过程，AI逻辑以及到源的链接。 <br><a name="habracut"></a><br><h1> 游戏规则野兔和刺猬 </h1><br> 在65个单元的比赛场上，有几位玩家筹码，从2到6位参与者（我的绘画，非规范，外观，当然是这样）： <br><br><img src="https://habrastorage.org/webt/rf/8w/8x/rf8w8xapxkminuwc_r78qrwlr_c.png"><br><br> 除了索引为0（开始）和64（结束）的单元外，每个单元中只能放置一个玩家。 每个玩家的目标是领先竞争对手进入终点站。 <br><br> 前进的“燃料”是胡萝卜-游戏的“ <b>货币”</b> 。 开始时，每个玩家都会收到68根胡萝卜，他在移动时会给予（有时还会收到）。 <br><br> 除了胡萝卜，玩家一开始会收到3张色卡。 沙拉是特殊的“神器”，玩家必须在完成比赛之前将其<b>清除</b> 。 摆脱生菜（这只能在特殊的生菜笼中完成，如下所示： <br><img src="https://habrastorage.org/webt/yk/ie/c9/ykiec9ojz0bdaawaedp8yo2lsy4.png" align="left"><br>  ），包括在内的玩家将获得额外的胡萝卜。 在此之前，跳过您的举动。 沙拉旁离开牌的玩家越多，该玩家获得的胡萝卜就越多：10 x（该玩家在场上相对于其他玩家的位置）。 也就是说，第二名的选手将获得20根胡萝卜，离开沙拉笼。 <br><br> 如果将玩家的位置与该单元格上的数字相匹配（1-4，则数字1的单元格也适合该字段的第四和第六位置），则编号为1-4的单元格可以带出几十个胡萝卜。 <br><br> 玩家可以跳过移动，留下带有胡萝卜图像的笼子，并为此动作接收或给予10个胡萝卜。 玩家为什么要给“加油”？ 事实是，玩家在最后一步之后只能完成10根胡萝卜（如果获得第二，则获得20根胡萝卜，如果获得第三，则获得30根胡萝卜，依此类推）。 <br><br> 最后，玩家可以通过在<b>最近的免费</b>刺猬上踩N步来获得10 x N的胡萝卜（如果最近的刺猬很忙，那么这样的举动是不可能的）。 <br><br> 根据公式（向上取整），向前移动的成本与移动的数量不成比例地计算： <br><br><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mtext" id="MJXp-Span-2">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">c</span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">N</span><span class="MJXp-mo" id="MJXp-Span-9" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-10"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11" style="margin-right: 0.05em;">N</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-12" style="vertical-align: 0.5em;">2</span></span></span><span class="MJXp-mrow" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.388ex" height="2.78ex" viewBox="0 -935.7 6194.9 1197.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-63" x="1781" y="0"></use><g transform="translate(2215,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-4E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-2B" x="1110" y="0"></use><g transform="translate(2111,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-4E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-32" x="1292" y="513"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-32" x="5694" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> \ frac {N + N ^ 2} {2} </script>  ， <br> 其中N是前进的步数。 <br><br> 因此，要向前移动一个单元格，玩家会给1个胡萝卜，3个2个单元格的胡萝卜，6个3个单元格的胡萝卜，10个4个单元格...，210个向前移动20个单元格的胡萝卜。 <br><br> 最后一个单元-具有野兔图像的单元-将随机性元素引入游戏。 站在野兔的笼子上，玩家从堆子中抽出一张特殊的纸牌，然后执行一些操作。 根据卡牌和游戏情况的不同，玩家可能会损失一些胡萝卜，获得额外的胡萝卜或跳过一圈。 值得注意的是，在具有“效果”的牌中，对玩家来说还有更多的负面场景，这鼓励了游戏的谨慎性和计算性。 <br><br><h2>  <font color="#3050ff">没有AI的实施</font> </h2><br> 在最初的实现中，这将成为开发“智力”游戏的基础，我将自己限制在每个玩家（一个人）采取行动的选项上。 <br><br> 我决定将游戏作为客户端实施-一个静态的单页网站，其所有“逻辑”都在JS和服务器上实现-WEB API应用程序。 该服务器使用.NET Core 2.1编写，并生成一个程序集工件-dll文件，该文件可以在Windows / Linux / Mac OS下运行。 <br><br> 客户端部分的“逻辑”被最小化（与UX一样，因为GUI完全是功利主义的）。 例如，Web客户端本身不会执行检查以查看播放器请求的规则是否可接受。 此检查在服务器上执行。 服务器告诉客户端玩家可以从当前游戏位置做出什么动作。 <br><br> 该服务器是经典的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Moore机器</a> 。 服务器逻辑缺少“连接的客户端”，“游戏会话”等概念。 <br><br> 服务器所做的只是处理收到的（HTTP POST）命令。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“命令”模式</a>在服务器上实现。 客户端可以请求执行以下命令之一： <br><br><ul><li> 开始一个新游戏，即 将指定数量的玩家筹码“放置”在“干净”板上 </li><li> 进行命令中指示的移动 </li></ul><br> 对于第二个团队，客户端向服务器发送当前游戏位置（Disposition类的对象），即以下形式的描述： <br><br><ul><li> 位置，每种野兔的胡萝卜和生菜的数量，以及一个附加的布尔字段，指示野兔缺少轮到 </li><li> 移动的野兔的索引。 </li></ul><br> 服务器不需要发送其他信息-例如，有关运动场的信息。 就像记录国际象棋素描一样，不必在板上绘出黑白单元的排列，该信息被视为常数。 <br><br> 作为响应，服务器指示命令是否成功完成。 从技术上讲，客户可能会例如请求无效举动。 或者尝试为单个参与者创建一个新游戏，这显然没有意义。 <br><br> 如果团队成功，则响应将包含一个新的游戏<b>位置</b> ，以及队列中下一位玩家可以做出的动作列表（新位置的当前动作）。 <br><br> 除此之外，服务器响应还包含一些服务字段。 例如，玩家在相应笼子上的台阶上“拔出”野兔牌的文本。 <br><br><h4> 玩家回合 </h4><br> 玩家的回合编码为整数： <br><br><ol><li>  0，如果播放器被迫停留在当前单元格中， <br>  1，2，... N代表1，... N前进， </li><li>  -1，-2，... -M将1 ... M个细胞移回最近的自由刺猬， </li><li>  1001、1002-决定停留在胡萝卜单元上并接收（1001）或给予（1002）10根胡萝卜的玩家的特殊代码。 </li></ol><br><h3> 软件实施 </h3><br> 服务器接收请求的命令的JSON，将其解析为相应的请求类之一，然后执行请求的操作。 <br><br> 如果客户（球员）要求从转移到团​​队的位置（POS）使用CMD代码进行移动，则服务器将执行以下操作： <br><br><ul><li> 检查这样的举动是否可能 </li><li> 从当前位置创建一个新位置，对其进行相应的修改， <br> 获得一个新职位的许多可能动作。 让我提醒您，进行位置移动的玩家的索引已经包含在描述<abbr title="特定状态，力的对齐，游戏的“快照”">位置</abbr>的对象中， </li><li> 向客户返回新位置的答案，可能的举动或成功标志等于false以及错误说明。 </li></ul><br> 检查所请求举动（CMD）的可接受性并构造新位置的逻辑比我们想要的紧密得多。 按照这种逻辑，找到可接受的动作的方法有一些共同点。 所有这些功能都由TurnChecker类实现。 <br><br> 在输入check / execute方法时，TurnChecker会收到一个游戏位置类别的对象（处置）。  Disposition对象包含一个播放器数据数组（Haze []雾度），该播放器的索引进行移动+在TurnChecker对象操作期间填写的一些服务信息。 <br><br> 运动场描述FieldMap类，该类实现为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">singleton</a> 。 该类包含一个单元格数组和一些用于简化/加速后续计算的开销信息。 <br><br><div class="spoiler">  <b class="spoiler_title">性能考量</b> <div class="spoiler_text"> 在TurnChecker类的实现中，我尝试尽可能避免循环。 事实是，在准最佳移动的搜索过程中，随后将获取用于获得一组允许移动/执行某个移动的方法的次数称为数千次（成千上万次）。 <br><br> 因此，举例来说，我使用以下公式计算出玩家可以用N个胡萝卜前进多少格： <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Pow(<span class="hljs-number"><span class="hljs-number">8</span></span> * N + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br> 检查单元格i是否被其中一个玩家占用，我没有浏览玩家列表（因为此动作可能必须执行多次），但我要<i>查看</i>预先填写的<i>[cell_index，busy_cell_ flag]</i>形式的字典。 <br><br> 在检查指定的刺猬细胞是否最接近（当前）玩家所占据的当前细胞时，我还将请求的位置与<i>[cell_index，最近的back_de_dezh] _index]</i> -静态信息形式的字典中的值进行比较。 <br></div></div><br><h2>  <font color="#3050ff">用AI实施</font> </h2><br> 一个命令被添加到服务器处理的命令列表中：执行程序选择的准最佳移动。 该团队是对“玩家的移动”命令的小修改，实际上，该命令已从其中删除了移动字段（ <abbr title="该命令的数字代码，例如4向前移动4个单元格，0等待，1002-给10根胡萝卜...">CMD</abbr> ）。 <br><br> 想到的第一个决定是使用试探法选择“最佳可能”的举动。 与国际象棋类似，我们可以通过为该位置设置某种等级来评估通过此举获得的每个游戏位置。 <br><br><h3> 启发式位置评估 </h3><br> 例如，在国际象棋中，进行评估（不爬到开口的荒野中）非常简单：至少，您可以通过将3个棋子的骑士/主教值，5个典当的车子价值，9的皇后数和9的国王价值来计算零件的总“成本”。 <i>.MaxValue</i>典当。 可以很容易地改进估计值，例如将其添加（带有校正因子-因子/指数或其他函数）： <br><br><ul><li> 从当前位置可能移动的次数， </li><li> 威胁与敌人人物的比率/来自敌人的威胁。 </li></ul><br> 对垫子的位置进行了特殊评估： <i>int.MaxValue</i> ，如果将<i>死者</i>放置了计算机， <i>则为</i> <i>int.MinValue</i> ，如果将<i>死者</i>放置了计算机。 <br><br> 如果您命令象棋处理器选择下一个动作，仅在这种评估的指导下，处理器可能不会选择最差的动作。 特别是： <br><br><ul><li> 千万不要错过机会选一个更大的棋子或将棋子， </li><li> 最有可能的是，它不会推动数字增长， </li><li> 鉴于评估中的威胁数量，它不会再次使该数字受到攻击。 </li></ul><br> 当然，计算机的这种移动不会给他留下与对手进行成功的机会，而对手在丝毫意义上做出了移动。 计算机将忽略任何插头。 此外，他甚至可能会毫不犹豫地将女王换成典当。 <br><br> 但是，用于启发式评估国际象棋当前下注位置的算法（无需声明冠军程序的桂冠）是相当透明的。 您不能说游戏野兔和刺猬。 <br><br> 在一般情况下，在野兔和刺猬的游戏中，一个相当模糊的格言起作用了：“ <b><i>最好多吃些胡萝卜，少些生菜，以更好的表现</i></b> ”。 但是，并非一切都那么简单。 假设，如果玩家在游戏中途有一张沙拉卡，则此选项可能会很好。 但是拿着沙拉卡站在终点线上的玩家显然将处于失败状态。 除了评估算法之外，我还希望能够进一步“窥视”一步，就像可以通过对棋局的启发式评估来计算对棋子的威胁一样。 例如，值得考虑的是，离开生菜室/位置室（1 ... 4）的玩家收到的胡萝卜的奖金，要考虑到前面的玩家数量。 <br><br> 我推断出最终成绩是一个函数： <br><br>  <abbr title="E（预科），最终成绩">E</abbr> = Ks * S + Kc * C + Kp * P， <br><br> 其中S，C，P是使用玩家手中的色卡（S）和胡萝卜©计算出的等级，P是给予玩家的行进距离的等级。 <br><br>  Ks，Kc，Kp是相应的校正因子（稍后将进行讨论）。 <br><br> 最简单的方法是我确定<b>行进路线</b>的标记： <br>  P = i * 3，其中i是播放器所在的单元格的索引。 <br><br> 对C（胡萝卜）进行分级已经更加困难。 <br><br> 为了获得特定的C值，我选择了以下三个函数之一 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-msubsup" id="MJXp-Span-16"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17" style="margin-right: 0.05em;">C</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-18" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mrow" id="MJXp-Span-19"><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-msubsup" id="MJXp-Span-21"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22" style="margin-right: 0.05em;">C</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-23" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mrow" id="MJXp-Span-24"><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-msubsup" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27" style="margin-right: 0.05em;">C</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-28" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.004ex" height="2.419ex" viewBox="0 -780.1 5168.2 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-43" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-30" x="1011" y="-213"></use><g transform="translate(1169,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">，</text></g><g transform="translate(1999,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-43" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-31" x="1011" y="-213"></use></g><g transform="translate(3168,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">，</text></g><g transform="translate(3998,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-43" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-32" x="1011" y="-213"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-2"> C_0，C_1，C_2 </script> 从一个论点（手上胡萝卜的数量）开始。 函数C的索引（[0，1，2]）由玩家在运动场上的相对位置确定： <br><br><ul><li>  [0]如果玩家完成的比赛场地不足一半， </li><li>  [2]如果玩家有足够（胡萝卜，甚至丰富）的胡萝卜来完成， </li><li>  [1]在其他情况下。 </li></ul><br><img src="https://habrastorage.org/webt/fo/cv/hr/focvhrlzpl_xuxxd8dmuw9atok8.png"><br><br> 功能0和1相似：玩家手中每个胡萝卜的“值”随着手中胡萝卜数量的增加而逐渐减小。 游戏很少鼓励Plyushkins。 在第一种情况（通过的字段的一半）中，胡萝卜的值下降得更快。 <br><br> 相反，功能2（玩家可以完成）对玩家手中的每根胡萝卜都施加了较大的罚款（负系数值）-胡萝卜越多，惩罚系数越大。 由于过量的胡萝卜，比赛规则禁止涂饰。 <br><br> 在计算玩家手上的胡萝卜量之前，要先考虑生菜单元格/单元格编号1 ... 4中每步移动的胡萝卜。 <br><br> 以类似的方式得出“ <b>生菜</b> ”等级S。 根据玩家手上的沙拉量（0 ... 3），选择一个功能 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-29"><span class="MJXp-msubsup" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31" style="margin-right: 0.05em;">S</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-32" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mrow" id="MJXp-Span-33"><span class="MJXp-mo" id="MJXp-Span-34" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-msubsup" id="MJXp-Span-35"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36" style="margin-right: 0.05em;">S</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-37" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mrow" id="MJXp-Span-38"><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-msubsup" id="MJXp-Span-40"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41" style="margin-right: 0.05em;">S</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-42" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.293ex" height="2.419ex" viewBox="0 -780.1 4862.2 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-30" x="867" y="-213"></use><g transform="translate(1067,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">，</text></g><g transform="translate(1897,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-31" x="867" y="-213"></use></g><g transform="translate(2964,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">，</text></g><g transform="translate(3794,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-32" x="867" y="-213"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-3"> S_0，S_1，S_2 </script> 或 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-43"><span class="MJXp-msubsup" id="MJXp-Span-44"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45" style="margin-right: 0.05em;">S</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-46" style="vertical-align: -0.4em;">3</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.479ex" height="2.419ex" viewBox="0 -780.1 1067.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-33" x="867" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> S_3 </script>  。 函数参数 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-47"><span class="MJXp-msubsup" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49" style="margin-right: 0.05em;">S</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-50" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-msubsup" id="MJXp-Span-52"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53" style="margin-right: 0.05em;">S</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-54" style="vertical-align: -0.4em;">3</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.799ex" height="2.419ex" viewBox="0 -780.1 3357.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-30" x="867" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-2212" x="1289" y="0"></use><g transform="translate(2290,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-33" x="867" y="-213"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-5"> S_0-S_3 </script>  。  -再次，玩家的“相对”路径。 即，前面剩下色拉的单元格数量（相对于玩家所占据的单元格）： <br><br><img src="https://habrastorage.org/webt/91/as/ra/91asraqadihe0n0dgtruyw1efuc.png"><br><br> 曲线 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-55"><span class="MJXp-msubsup" id="MJXp-Span-56"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57" style="margin-right: 0.05em;">S</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-58" style="vertical-align: -0.4em;">0</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.479ex" height="2.419ex" viewBox="0 -780.1 1067.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-30" x="867" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> S_0 </script>  -对于手头有0张生菜卡的玩家，评估播放器前面的生菜盒数（0 ... 5）的评估功能（S）， <br> 曲线 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-59"><span class="MJXp-msubsup" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61" style="margin-right: 0.05em;">S</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-62" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.479ex" height="2.298ex" viewBox="0 -780.1 1067.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-31" x="867" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> S_1 </script>  -手上拿着一张沙拉卡等的玩家具有相同的功能。 <br><br> 因此，最终成绩（E = Ks * S + Kc * C + Kp * P）考虑到： <br><br><ul><li> 玩家在自己移动之前会立即收到的额外胡萝卜， </li><li> 玩家的路径 </li><li> 非线性影响分数的胡萝卜和生菜的量。 </li></ul><br> 这是计算机的播放方式，选择具有最大启发式得分的下一步： <br><br><img src="https://habrastorage.org/webt/nz/ze/4g/nzze4g5o3vbfug20cspijmdmnlg.gif"><br><br> 原则上，首次亮相还不错。 但是，不应期望这样的AI会带来出色的游戏：在游戏过程中，绿色的“机器人”开始重复移动，最后，它进行了多次重复移动-向后刺入刺猬，直到最终完成。 部分由于偶然的缘故，他将落后于玩家-一个人十二步之遥。 <br><br><div class="spoiler">  <b class="spoiler_title">实施说明</b> <div class="spoiler_text"> 评估的计算由一个特殊的类-EstimationCalculator管理。 用于评估相对于胡萝卜的位置的功能-色拉卡被加载到计算器类的<b>静态</b>构造函数中的数组中。 位置估算方法从“角度”接收位置对象本身和玩家的索引，并通过算法对其位置进行评估。 就是说，根据考虑虚拟点的玩家，同一游戏位置可以收到几个不同的评分。 <br></div></div><br><h2>  <font color="#3050ff">决策树和Minimax算法</font> </h2><br> 我们在对抗性Minimax游戏中使用决策算法。 在我看来，非常好， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此帖子（翻译）中</a>介绍了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该</a>算法。 <br><br> 我们教导程序“看”一些前进的步伐。 假设从当前位置开始（背景对算法并不重要-我们记得，该程序的功能就像<abbr title="该算法没有“内部状态”">一台Moore机器</abbr> ），编号为1，该程序可以执行两次移动。 我们得到两个可能的位置，2和3。接下来是玩家的回合-人（通常是敌人）。 从第二位置开始，对手有3个动作，从第三位置开始-仅有两个动作。 接下来，再次进行移动的步骤由程序决定，该程序总共可以从5个可能的位置进行10次移动： <br><br><img src="https://habrastorage.org/webt/j8/1p/yf/j81pyfcci31ot27y3xgfafiuqc4.gif"><br><br> 假设在计算机第二次移动之后，游戏结束，并且从第一和第二玩家的角度评估每个接收到的位置。 并且我们已经实现了评估算法。 让我们以向量的形式评估每个最终位置（树9 ... 18的叶子） <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-63"><span class="MJXp-mo" id="MJXp-Span-64" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-msubsup" id="MJXp-Span-65"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66" style="margin-right: 0.05em;">v</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-67" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mrow" id="MJXp-Span-68"><span class="MJXp-mo" id="MJXp-Span-69" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-msubsup" id="MJXp-Span-70"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71" style="margin-right: 0.05em;">v</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-72" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.585ex" height="2.66ex" viewBox="0 -832 3265.8 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-5B" x="0" y="0"></use><g transform="translate(278,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-76" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-30" x="686" y="-213"></use></g><g transform="translate(1217,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">，</text></g><g transform="translate(2047,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMATHI-76" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-31" x="686" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhgq1O8nLc7ceLbKKtSJHh0c1Dvh3g#MJMAIN-5D" x="2987" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> [v_0，v_1] </script>  ， <br> 在哪里 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-74"><span class="MJXp-msubsup" id="MJXp-Span-75"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76" style="margin-right: 0.05em;">v</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-77" style="vertical-align: -0.4em;">0</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> v_0 </script>  -为第一个玩家计算的分数， <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-78"><span class="MJXp-msubsup" id="MJXp-Span-79"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80" style="margin-right: 0.05em;">v</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-81" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> v_1 </script>  -第二名玩家的得分： <br><br><img src="https://habrastorage.org/webt/xk/g5/yw/xkg5ywgzotdosiz4e4soubsrava.png"><br><br> 由于计算机采取了最后一步，因此显然它将选择每个子树中的选项（[9、10]，[11]，[12、13]，[14、15、16]，[17、18]）这给了他更好的评价。 问题立即浮出水面：应根据什么原则选择“最佳”职位？ <br><br> 例如，有两个动作，之后我们得到了具有评级的位置[5;  5]和[2;  1]。 评估第一个玩家。 显然有两种选择： <br><br><ul><li> 第i个玩家的第i个得分的最大<b>绝对值的</b>位置选择。 换句话说，高贵的赛车手莱斯利（Leslie）渴望获得胜利，而不顾竞争对手。 在这种情况下，位置估计为[5;  5]。 </li><li> 狡猾的教授费斯（Faith）是选择狡猾的教授费斯（Faith） <b>来</b>选择<b>相对于竞争对手的估计</b>最高评价的职位，他不会错过对敌人施加肮脏手段的机会。 例如，故意落后于计划从第二位置开始的玩家。 评分为[2;  1]。 </li></ul><br> 在我的软件实现中，我将等级选择算法（将等级向量映射到第i个播放器的标量值的函数）作为自定义参数。 令我惊讶的是，进一步的测试表明，第一种策略的优越性-通过最大绝对值选择仓位 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-82"><span class="MJXp-msubsup" id="MJXp-Span-83"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84" style="margin-right: 0.05em;">v</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-85" style="vertical-align: -0.4em;">i</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> v_i </script>  。 <br><br><div class="spoiler">  <b class="spoiler_title">软件实施功能</b> <div class="spoiler_text"> 如果在AI的设置（TurnMaker类）中指定了选择最佳成绩的第一个选项，则相应方法的代码将采用以下形式： <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContractEstimateByAbsMax</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] estimationVector, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> estimationVector[playerIndex]; }</code> </pre><br> 第二种方法-相对于竞争对手的位置的最大值-实现起来稍微复杂一些： <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContractEstimateByRelativeNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[]eVector, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> player</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? min = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pVal = eVector[player]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; eVector.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == player) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = pVal - eVector[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!min.HasValue || min.Value &gt; val) min = val; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min.Value; }</code> </pre><br></div></div><br> 选定的估计值（图中带下划线的部分）将转移到更高的水平。 现在，敌人必须选择一个位置，知道算法将选择哪个后续位置： <br><br><img src="https://habrastorage.org/webt/hf/pr/ox/hfproxjzdo7-_7ll2f90na7p5ky.png"><br><br> 显然，对手会选择对自己评分最高的位置（向量<b>第二个坐标</b>取最大值的位置）。 这些估计在图中再次强调。 <br><br> 最后，我们回到第一步。 计算机进行选择，并且他更喜欢使用向量的第一坐标最大的移动： <br><br><img src="https://habrastorage.org/webt/dr/f1/y-/drf1y-8s_h-orz173pj8fx2tam0.png"><br><br> 因此，解决了该问题-找到了一个最佳运动。 假设树上叶子位置的启发式得分为100％，则表示未来的获胜者。 然后，我们的算法将明确选择最佳移动方式。 <br><br> 但是，仅当评估游戏的<b>最终</b>位置时，启发式分数才是100％准确的-一个（或几个）玩家已经完成，才确定获胜者。 因此，有机会展望N个动作-赢得同等实力的对手所需的一切，您可以选择最佳动作。 <br><br> 但是典型的2人游戏平均持续30-40步（三人-60步，依此类推）。 从每个位置，玩家通常可以进行约8步。 因此，完整的30步可能位置树将由大约 <br><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-86"><span class="MJXp-msubsup" id="MJXp-Span-87"><span class="MJXp-mn" id="MJXp-Span-88" style="margin-right: 0.05em;">8</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-89" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-90">30</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> 8 ^ {30} </script>  = 1237940039285380274899124224峰！ <br><br> 实际上，在我的PC上构建和“解析”约100,000个位置的树大约需要300毫秒。 如果我们希望计算机的响应时间不超过一秒钟，则可以将树的深度限制为7-8级（移动）。 <br><br><div class="spoiler">  <b class="spoiler_title">软件实施功能</b> <div class="spoiler_text"> 显然，需要一种递归方法来建立位置树并找到最佳移动。 在该方法的输入处-当前位置（我们记得，玩家已经在其中移动）和当前树级别（移动编号）。 一旦我们下降到算法设置允许的最大水平，该函数就会从每个玩家的“观点”返回启发式位置估计向量。 <br><br>  <b><font color="#ff0000">重要的补充</font></b> ：当当前玩家结束比赛时，还必须停止在树下的下降。 否则（如果选择了用于选择相对于其他玩家的位置的最佳位置的算法），则程序可以长时间在终点“踩”，“模拟”对手。 另外，通过这种方式，我们将在最终游戏中稍微减小树的大小。 <br><br> 如果我们还没有达到最终的递归级别，则选择可能的移动，为每个移动创建一个新位置，并将其传递给当前方法的递归调用。 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">为什么是Minimax？</b> <div class="spoiler_text"> 在最初的解释中，球员总是两个。 该程序仅根据第一个玩家的位置计算分数。 因此，当选择“最佳”位置时，索引为0的玩家搜索评分最高的位置，索引为1的玩家搜索最小值。 <br><br> 在我们的例子中，评分应该是一个矢量，以便当评分上升到树上时，N个参与者中的每一个都可以从其“角度”对其进行评估。 <br></div></div><br><h2>  <font color="#3050ff">调整AI</font> </h2><br> 我与计算机对战的实践表明，该算法虽然还不错，但仍然不如人类。 我决定通过两种方式改善AI： <br><br><ul><li> 优化决策树的构造/遍历， </li><li> 改善启发式。 </li></ul><br><h3>  Minimax算法优化 </h3><br> 在上面的示例中，我们可以拒绝考虑位置8并“保存”树的2-3个顶点： <br><br><img src="https://habrastorage.org/webt/-h/ce/hb/-hcehbcs1t-bcynqfe7j_cmnjp4.png"><br><br> 我们从上到下，从左到右，绕着树走。 绕过从位置2开始的子树，我们得出了移动1-&gt; 2的最佳估计：[3，2]。 绕过根在位置7的子树，我们确定了当前（最佳移动3-&gt; 7）等级：[2，4]。 从计算机（第一玩家）的角度来看，分数[2，4]比分数[3，2]差。 并且由于计算机的对手从位置3选择移动，所以无论位置8的得分如何，位置3的最终得分都将比第三位置的得分先验地差。 因此，不能建立和评估根在位置8的子树。 <br><br>  Minimax算法的优化版本允许您截断多余的子树，称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">alpha-beta裁剪算法</a> 。 实现此算法将需要对源代码进行少量修改。 <br><br><div class="spoiler">  <b class="spoiler_title">软件实施功能</b> <div class="spoiler_text"> 另外，将两个整数参数传递给TurnMaker类的CalcEstimate方法-alpha（初始等于int.MinValue和beta，等于int.MaxValue）。 此外，在接收到正在考虑的当前移动的估计值之后，将执行以下形式的伪代码： <br><br><pre> <code class="1c hljs"> e = _[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">//        (  )  (e &gt; alpha) alpha = e   (e &lt; beta) beta = e  (beta &lt;= alpha)    </span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">软件实施的重要特征</b> <div class="spoiler_text"> 根据定义，alpha-beta裁剪方法可产生与“纯净” Minimax算法相同的解决方案。 为了检查决策的逻辑是否发生了变化（或者说结果是移动），我编写了一个单元测试，其中机器人为2个对手中的每一个做出8步动作（总共16步动作），并保存了得到的一系列动作- <b>禁用</b>剪辑选项。 <br><br> 然后，在同一测试中，在<b>打开</b>裁剪选项的情况下重复该过程。 之后，比较了移动顺序。 动作中的差异表示在执行alpha-beta裁剪算法时发生了错误（测试失败）。 <br></div></div><br><h3> 较小的alpha-beta裁剪优化 </h3><br> 在AI设置中启用了裁剪选项后，位置树中的顶点数平均减少了3倍。 该结果可以有所改善。 <br><br> 在上面的示例中： <br><br><img src="https://habrastorage.org/webt/-h/ce/hb/-hcehbcs1t-bcynqfe7j_cmnjp4.png"><br><br> 如此成功地“巧合”，以至于在顶点位于位置3的子树之前，我们检查了顶点在位置2的子树。如果顺序不同，我们可以从“最差”子树开始，而不能得出结论，没有必要考虑下一个位置。 <br><br> 通常，修剪一棵树变得更加“经济”，在同一个级别（即，从i位置开始的所有可能移动）的后代顶点已经按当前（而不是深入研究）位置估计进行了排序。 换句话说，我们假设最好的方法（从启发式的角度来看）更有可能获得更好的最终成绩。 因此，我们很有可能对树进行排序，以便在“最差”子树之前考虑“最佳”子树，这将使我们减少更多选择。 <br><br> 评估当前职位是一个昂贵的过程。 如果以前只需要我们评估末端位置（叶）就足够了，那么现在就对树的所有顶点进行评估。 但是，如测试所示，在没有对可能的动作进行初步排序的情况下，所做的估计总数仍略少于变体。 <br><br><div class="spoiler">  <b class="spoiler_title">软件实施功能</b> <div class="spoiler_text">  alpha-beta裁剪算法返回与原始Minimax算法相同的动作。 这将检查我们编写的单元测试，比较两个移动序列（对于带有剪切和不带有剪切的算法）。 在一般情况下， <b>按排序进行的</b> Alpha-Beta裁剪可能表示<b>与</b>准最佳操作<b>不同的操作</b> 。 <br><br> 要测试修改后算法的正确操作，您需要进行新测试。 尽管进行了修改，但已排序的算法应产生与未排序的算法和原始Minimax算法完全相同的<b>最终估计向量</b> （在本示例中为[3，2]）。 <br><br> 在测试中，我创建了一系列测试位置，并根据“最佳”举动从每个位置中进行选择，打开和关闭排序选项。 然后，他比较了通过两种方式获得的评估向量。 <br></div></div><br> 此外，由于通过启发式评估对树的当前顶点中每个可能移动的位置进行了排序，因此请您立即丢弃一些最差的选择。 例如，国际象棋棋手可能会考虑用棋子代替典当机的举动。 但是，通过向前，向后移动3、4 ...个深度来展开情况，例如，当对手将其女王的主教袭击时，他将立即注意到这些选择。 <br><br> 在AI设置中，我设置了“削除最差的选项”向量。 例如，格式为[0，0，8，8，4]的向量表示： <br><br><ul><li> 向前看[0]和两个[0]步骤，程序将考虑所有可能的移动，因为 0   , </li><li>    [8]   [8]  ,    8 “” ,    , , </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 展望未来五个或更多步骤[4]，程序将评估不超过4个“最佳”动作。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 启用了alpha-beta裁剪算法的排序功能并在裁剪设置中使用了类似的向量后，程序开始花费大约300毫秒来选择准最佳移动，“进一步”前进了8个步骤。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 启发式优化 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管在树上遍历了大量的顶点位置并且“深”向前看以寻找准最佳移动，但AI仍然存在一些缺点。</font><font style="vertical-align: inherit;">我将其中一个定义为“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">兔子陷阱</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">野兔陷阱</font></font></b> <div class="spoiler_text">       .   ( 8 — 10   15),     .     “”          (   !): <br><br><ul><li>           7, </li><li>    ,    ,  .   ,  ,    ,      . </li></ul><br>        .  : <br><br><img src="https://habrastorage.org/webt/qn/y-/wr/qny-wrq0dgtlr16wwj1ibekhk5g.png"><br><br>     54   (43),      —   10     55 .  AI,   ,      (61),  28 .       ,   6          9 (      10 ). <br><br>   ,       ( ),         ,        4 — 6 .   , ,          , AI     ? <br><br>   ,     <b> </b> ,   . AI      .            ,      ,    .      “ ”  : <br><br>                  65 —    “”  , ,      .         ,            ,  ,    ()    . <br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 校正因素 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之前，我引用了用于评估当前位置的启发式公式</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E = Ks * S + Kc * C + Kp * P </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但我并未提及校正因子。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实是公式本身和函数集</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-91"><span class="MJXp-msubsup" id="MJXp-Span-92"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-94" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-95" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></span><span class="MJXp-mo" id="MJXp-Span-96" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></span><span class="MJXp-msubsup" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-99" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-msubsup" id="MJXp-Span-101"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-103" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></span><span class="MJXp-mo" id="MJXp-Span-105" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></span><span class="MJXp-msubsup" id="MJXp-Span-106"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-108" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，是我根据所谓的 </font><font style="vertical-align: inherit;">“常识。” </font><font style="vertical-align: inherit;">至少，我想选择这样的系数Ks，Kc和Kp，以便估算值尽可能地合适。</font><font style="vertical-align: inherit;">如何评估评估的“充分性”？</font><font style="vertical-align: inherit;">评估是一个无量纲的数量，只能与另一个评估进行比较。</font><font style="vertical-align: inherit;">我能够提出修正校正系数的唯一方法：我</font><font style="vertical-align: inherit;">在程序中放入了一系列“研究”，这些研究存储在CSV文件中，格式为</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13">C_0 .. C_2, S_0 .. S_5</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cs hljs"> <span class="hljs-number"><span class="hljs-number">45</span></span>;<span class="hljs-number"><span class="hljs-number">26</span></span>;<span class="hljs-number"><span class="hljs-number">2</span></span>;f;<span class="hljs-number"><span class="hljs-number">29</span></span>;<span class="hljs-number"><span class="hljs-number">19</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>;f;<span class="hljs-number"><span class="hljs-number">2</span></span> ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该行的字面意思是： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个玩家在第45方块上，他手中有26张胡萝卜卡和2张沙拉卡，该玩家不会错过任何招（f =假）。</font><font style="vertical-align: inherit;">迁徙权始终是第一位。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第二个单元格上有19张胡萝卜并且没有沙拉卡的第二名玩家不会错过任何移动。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 图二的意思是，“决定”研究，我假设第二名选手处于获胜状态。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将20个草图放入程序后，我将它们“下载”到游戏网络客户端中，然后对每个草图进行排序。</font><font style="vertical-align: inherit;">在分析草图时，我轮流为每个玩家做出了动作，直到我确定“获胜者”为止。</font><font style="vertical-align: inherit;">完成评估后，我将一个特别小组将其发送到服务器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在评估了20个练习曲之后（当然，值得分析更多练习曲），我通过程序对每个练习曲进行了评估。</font><font style="vertical-align: inherit;">在评估中，每个校正因子的值从0.5到2，以0.1为增量-合计</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-msubsup" id="MJXp-Span-110"><span class="MJXp-mn" id="MJXp-Span-111" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16 </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-112" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 4096个系数三元组的变体。</font><font style="vertical-align: inherit;">如果发现第一个玩家的分数高于第二个玩家的分数，并且在练习曲记录的行中存储了类似的指令（该行的最后值为1），则对“命中”计数。</font><font style="vertical-align: inherit;">对于镜像情况也是如此。</font><font style="vertical-align: inherit;">否则，计算为单据。</font><font style="vertical-align: inherit;">结果，我选择了那些“命中”百分比最大的三元组（20个中的16个）。</font><font style="vertical-align: inherit;">在4096个向量中大约有250个出来了，我再次选择了“最佳”，“肉眼”，并将其安装在AI设置中。</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14">16^3</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 总结 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，我得到了一个可以正常运行的程序，该程序通常在与计算机的一对一版本中击败我。尚未积累有关该程序当前版本的重大胜利和失败的统计数据。随后进行的简单AI调整可能会使我无法取得胜利。或几乎不可能，因为野兔细胞因子仍然存在。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，按照选择评分的逻辑（绝对最高或相对于其他玩家的最高金额），我肯定会尝试一种中间选择。至少，如果第i个玩家的得分的绝对值相等，则选择一个举动来获得得分的相对值更高的位置是合理的（高贵的莱斯利和奸诈的费思混合而成）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该程序对于具有3个播放器的版本是完全可用的。</font><font style="vertical-align: inherit;">但是，有人怀疑与3个玩家玩游戏时AI动作的“质量”低于2个玩家玩游戏时的质量。</font><font style="vertical-align: inherit;">但是，在最后一次测试中，我输给了计算机-可能是由于过失，随便评估了我手上的胡萝卜量，并以过量的“燃料”到达终点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，人工智能的进一步发展由于缺少人-“测试者”（即计算机“天才”的活着的对手）而受到阻碍。</font><font style="vertical-align: inherit;">我本人在野兔和刺猬身上玩了很多恶心，因此在现阶段不得不中断比赛。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→链接到</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">带有源</font></a><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源库</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN432382/">https://habr.com/ru/post/zh-CN432382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN432370/index.html">AlphaZero在一场1,000场比赛中击败了Stockfish</a></li>
<li><a href="../zh-CN432372/index.html">微软已经正式确认Edge会切换到Chromium引擎</a></li>
<li><a href="../zh-CN432374/index.html">Kubernetes中高度可访问且可扩展的Elasticsearch</a></li>
<li><a href="../zh-CN432378/index.html">西伯利亚的一名10年级生希望成为一名处理器设计师。 为什么不制作FPGA神经加速器？</a></li>
<li><a href="../zh-CN432380/index.html">一部iPhone使用寿命长达六年，不会让我分心</a></li>
<li><a href="../zh-CN432384/index.html">研究：22％的Tumblr用户访问了色情网站，尤其是年轻女孩</a></li>
<li><a href="../zh-CN432386/index.html">圆桌会议“ IT项目建筑师”，2018年9月</a></li>
<li><a href="../zh-CN432392/index.html">我们玩了老式游戏和蘑菇：任务完成</a></li>
<li><a href="../zh-CN432394/index.html">9个Lamoda仓库自动化圈</a></li>
<li><a href="../zh-CN432398/index.html">使用CubeMX的STM32引导加载程序DFU模式。 分步说明</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>