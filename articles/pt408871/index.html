<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🏭 👩🏾‍🤝‍👩🏻 👨🏿‍🔬 Sessão de transmissão de vídeo de som através da água com exposição 💵 ♋️ 😆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Senhor Todo-Poderoso! Parece que acabei de matar o Sr. May! ... Mas, seja como for, continuamos ”(C) J. Clarkson 
 Neste artigo, mostrarei como tran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sessão de transmissão de vídeo de som através da água com exposição</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408871/"><blockquote>  O Senhor Todo-Poderoso!  Parece que acabei de matar o Sr. May! ... Mas, seja como for, continuamos ”(C) J. Clarkson </blockquote><br>  Neste artigo, mostrarei como transferir vídeo (bem, quase vídeo) usando o som através da água, usando um laptop comum, um pedaço de fio, duas tomadas de 3,5 mm e dois piezo-tweeter.  Também vou explicar por que e como funciona, contar uma história engraçada sobre como chegamos a isso.  E como uma cereja no bolo, um artigo em C # com códigos-fonte é anexado ao artigo, para que todos os interessados ​​possam experimentá-lo, porque o conhecimento científico é verificável, não é? <br><a name="habracut"></a><br>  Se de repente o leitor quiser se aprofundar um pouco nos tópicos hidroacústicos, sugiro que você se familiarize com nossas publicações anteriores, nas quais falamos sobre nossos projetos de uma maneira que revela as dificuldades de transmitir informações pela água: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GPS subaquático do zero por ano</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GPS subaquático: continuação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Navegação debaixo d'água: descoberta de direção - não descoberta de direção, você está fadado ao sucesso</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sobre o efeito das cianobactérias nas funções de fala do presidente</a> <br><br>  Em geral, uma simples verdade deve ser aprendida: o vídeo através da água a uma distância significativa (bem, pelo menos centenas de metros) não pode ser transmitido usando acústica.  O ponto é a banda de frequência disponível extremamente estreita e a forte irregularidade da atenuação de diferentes frequências com a distância.  As vantagens são ruído, propagação de caminhos múltiplos, reverberação, mudança na velocidade do som no meio em relação à densidade (ou seja, pressão, temperatura e salinidade), o efeito Doppler, que aliás não funciona exatamente como nas radiocomunicações. <br><br>  Os limites de velocidade para os modems de sonar mais avançados estão muito longe de poder transmitir vídeo.  Até onde eu sei, o registro pertence ao EvoLogics e atinge 62,5 kbps com uma distância máxima declarada de 300 metros.  Além disso, as palavras sobre a impossibilidade de transmitir som de vídeo através da água (a distâncias razoáveis) pertencem apenas a Konstantin Georgievich, fundador e diretor da EvoLogics. <br><br>  Quando eu era pesquisador no Instituto de Pesquisa Hydrosvyaz, então completamente inconsciente, queria grandes realizações, <s>vitórias no norte e sul, grande afrouxamento de solos</s> (não, eu ainda os quero, mas não fiquei sobrecarregado com experiência e conhecimento e tudo parecia quase mágico e fabuloso).  Em nossa equipe da época (parte da qual é real), muitas vezes fantasiamos sobre alguns projetos de sonares irreais, vasculhávamos um <s>aterro</s> e tentamos usar todo tipo de artefato de uma grande civilização antiga consecutiva, da qual esse instituto de pesquisa está parcialmente tentando compreender o tao da comunicação do sonar. . <br><br>  A imersão nessas memórias evoca sentimentos conflitantes em mim.  Então nada pareceu e ninguém poderia nos parar: derrubamos uma fresadora chinesa do diretor de prototipagem de produtos, montamos corpos normobáricos de tubulações de água holandesas Van De Lande, cujo fabricante até escreveu uma carta sobre o assunto: “Você checou acidentalmente quais seus tubos suportam pressão externa? ”  Eles coletaram modelos de tábua de pão para o seu próprio dinheiro em recipientes de café da manhã e foram secretamente ao teste para testá-los secretamente, coletando brocas e trenós para colegas e parentes e até compraram um barco chinês de PVC em Auchan.  Olhando para trás, sinto como meu coração está cheio de horror, nostalgia e ansiedade. <br><br>  Para ser honesto, vale a pena notar que, durante todo esse tempo, recebemos grande apoio de alguns de nossos líderes - em palavras e ações, e, como resultado, todos os nossos ofícios foram legalizados no TOC (que significa trabalho experimental de design e não transtorno obsessivo-compulsivo), que foi ainda apresentado no salão naval internacional em 2013.  Sim, sim, nós dirigimos para o salão nossos canos de água, pintamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">StDmitirev</a> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">nossas</a> próprias mãos em laranja brilhante!  Aqui estão eles, em malas: <br><br><img src="https://habrastorage.org/webt/-7/jk/ii/-7jkii7tkq9yhpbwuvb1dw6ah2g.jpeg"><br><br>  Um dia, meu amigo e colega <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">StDmitirev,</a> no meio de uma conversa sobre espectros e espectrogramas, pronunciou a seguinte frase: <br><br><blockquote>  "Mas, seria divertido criar um sistema desse tipo: o submarino fica no submarino e olha para o monitor, no qual o espectrograma se move suavemente, no qual letras e números são escritos como o dedo de <s>outro submarino</s> na janela de <s>outro submarino</s> ". <br></blockquote><br>  Todo mundo riu, desenvolveu esse tópico, parece que, mesmo no mesmo dia, desenhou um smiley no espectrograma e ouviu como ele soa.  Eu realmente queria trazer isso para uma aparência prática. <br><br>  Agora é difícil lembrar (foi em 2012).  Eu tinha um computador em funcionamento com uma webcam, várias antenas de artefatos e um “sonar de balde” (VG-1-P) especial com água.  Eles o chamaram de intensificador devido ao fato de eu ter mostrado a todos os seus chefes o trabalho de diferentes modelos de equipamento, o que levou a minha promoção a um pesquisador sênior. <br><br>  Não sou limitado por nenhuma obrigação, o método em si já foi publicado em domínio público e os resultados foram relatados repetidamente em conferências. <br><br>  Estou lhe dizendo como, em espírito, como transmitir um vídeo pela água: <br><br><h3>  Como gerar um sinal? </h3><br>  Lembramos que a idéia é baseada no “desenho de um espectrograma”, ou seja, a imagem transmitida é o espectrograma do sinal.  Para converter um sinal do domínio do tempo no domínio da frequência e vice-versa, é conveniente usar (bem, por exemplo) a transformada de Fourier, ou melhor, a transformada rápida de Fourier, por uma questão de brevidade, chamada FFT ou, mais comumente, FFT (Fast Fourier Transform). <br><br>  Como precisamos transformar uma imagem (quadro de vídeo) em um sinal de áudio que possa ser emitido pela placa de som de qualquer computador, obviamente usaremos a transformação inversa, IFFT, para formar a imagem.  Emitiremos uma imagem em colunas e um sinal para uma coluna será formado como no diagrama a seguir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/wi/3t/l4wi3t5t4mk3vq5zo_-bmau-dne.png"></div><br>  = <br>  Suponha que o tamanho da janela da FFT seja N e tenhamos uma matriz de tamanho N. Se o considerarmos como o espectro do sinal, seu elemento zero corresponderá à frequência zero (constante) e a contagem com o índice N-1 corresponderá à frequência de amostragem da taxa de amostragem.  É necessário escolher esses tamanhos de quadro de imagem e tamanho da janela FFT para que, por um lado, tudo se assemelhe ao vídeo (transferir um quadro levaria um tempo razoável) e, por outro lado, a faixa de frequência usada era adequada em princípio e adequada ao equipamento disponível .  Agora, se inserirmos os valores de brilho da coluna da imagem (quantidade de quadros) de alguma contagem favorita (de baixo para cima no diagrama) e executar a FFT inversa, a saída receberá um sinal codificando uma coluna da imagem.  Agora cabe a nós formar os sinais da mesma maneira para as colunas restantes da imagem e emiti-los alternadamente usando uma placa de som. <br><br>  Vale notar que a FFT na saída fornece uma matriz de valores complexos, portanto nosso sinal é a parte real.  Obviamente, o sinal resultante nas colunas é reduzido para números inteiros assinados de 16 bits (nesta forma, um sinal de áudio digital é geralmente armazenado) e normalizado. <br><br>  De fato, no início da imagem, também insiro algumas colunas de brilho máximo; mais tarde, no lado do receptor, isso determinará a resposta de freqüência do caminho do transceptor (e canal de transmissão), que, quando invertido e suavizado, nos ajudará a melhorar o quadro recebido. <br><br>  Na minha opinião, a maneira mais fácil de demonstrar o dispositivo do transmissor é com um pedaço de código, aqui está (método Encode da classe Encoder): <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap source</span></span></span><span class="hljs-function">)</span></span> { Bitmap frame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.PixelFormat != System.Drawing.Imaging.PixelFormat.Format8bppIndexed) frame = Grayscale.CommonAlgorithms.RMY.Apply(source); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> frame = source; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frame.Size.Equals(frameSize)) frame = resizer.Apply(frame); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[fftSize * frameSize.Width]; alglib.complex[] slice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> alglib.complex[fftSize]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxSlice; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sampleIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> colsCount = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startRow = startLine; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endRow = startRow + frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; colsCount; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = startRow; y &lt; endRow; y++) slice[y].x = (frame.GetPixel(x, frameSize.Height - (y - startRow) - <span class="hljs-number"><span class="hljs-number">1</span></span>).R / <span class="hljs-number"><span class="hljs-number">255.0</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; fftSize; y++) slice[y].x *= randomizerMask[y]; alglib.fftc1dinv(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> slice); maxSlice = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.MinValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; slice.Length; y++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(slice[y].x) &gt; maxSlice) maxSlice = Math.Abs(slice[y].x); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slice.Length; i++) { samples[sampleIndex] = (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>)Math.Round(slice[i].x * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue / maxSlice); sampleIndex++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samples; }</code> </pre> <br>  O código, naturalmente, não finge nada e foi escrito com pressa puramente para demonstração. <br><br><h3>  E quanto à velocidade de transmissão? </h3><br>  E como avaliá-lo?  Conseguimos ( <s>do mal,</s> não do mal) manter a intriga por cerca de dois meses, e alguns de nossos camaradas e líderes seniores em seu tempo livre conseguiram escrever um monte de papel, imaginando como seria uma velocidade de transferência tão louca. <br><br>  Por exemplo, se a frequência de amostragem for 96 kHz e levarmos o tamanho da janela da FFT para 512, enviaremos 120 x 120 pixels (8 bits por pixel) para a entrada do transmissor, e o tempo necessário para transmitir um quadro de imagem é: <br><br>  <i>120 * 512/96000 = 0,64 segundos</i> <br><br>  A taxa de bits deve parecer: <br><br>  <i>120x120 * 8 / 0,64 = 180.000 bits por segundo!</i> <br><br>  <s>O filho do diretor ficou encantado na época - sim, você já pode usar protocolos da Internet!</s>  <s>Esta é uma inovação!</s> <br><br>  Como mostrarei abaixo, é muito fácil cair em um conceito tão errado.  O que há de errado aqui?  Afinal, tudo é tão simples e elegante! <br><br>  De fato, esse cálculo de velocidade não é aplicável a esse método, assim como, por exemplo, não é aplicável a um sinal de televisão analógica, quantos bits por pixel existem?  =) E o receptor detector mais simples?  =)) <br><br>  O método de transmissão descrito é essencialmente <i>ANALOGUE</i> e os conceitos de "bit" e "pixel" não são aplicáveis ​​a ele - na mesma imagem, teoricamente, você não pode receber 8 bits por brilho de pixel, mas 16 e "velocidade" dobram automaticamente. <br><br>  É hora de mostrar os primeiros resultados de nossa "inovação": <br><br><img src="https://habrastorage.org/webt/a5/ji/pv/a5jipvfgywxfxpy7p9jwl34v-ze.gif"><br><br>  A foto acima foi tirada por nós no inverno de 2012, no rio Pichuga.  A distância de transmissão foi de 700 metros.  Sim, infelizmente, meu caro leitor, isso não é nada de HD e nem se baseia no CamRip mais vergonhoso.  Ainda não lembro quem, mas alguém notou com precisão que todos os nossos "vídeos" são como enviar sinais de ajuda de um planeta moribundo. <br><br>  O que é digno de nota, com um alongamento, isso pode ser caracterizado como uma espécie de OFDM - os dados são transmitidos em subportadoras ortogonais, o que significa boa resistência a interferências tonais e outras faixas estreitas - nesse caso, "linhas" individuais da imagem são distorcidas.  O ruído de impulso, pelo contrário, distorce uma ou um grupo de colunas.  A característica "formação de faixas" das imagens é causada pelo chamado  desbotamento seletivo da frequência devido à propagação de caminhos múltiplos, mas falarei sobre isso em outro momento. <br><br><h3>  Como é organizado o receptor? </h3><br>  Farei uma reserva imediatamente de que, para tentar esse método em um balde ou mesmo em uma pequena piscina, serão suficientes peças de duas horas (como as redondas) com um conector para uma placa de som soldada a elas.  Para o transmissor, você pode usar um cabo bastante longo (2-3-4-5 metros) e não blindado, selando o elemento piezoelétrico com zapon-verniz ou uma pequena camada de selante - o suficiente por várias vezes.  A antena do sonar resultante (não, bem, o que?) É inserida no fone de ouvido. <br><br>  A foto abaixo mostra várias peças que estavam à mão no momento da escrita.  Todos os elementos piezoelétricos mostrados são bastante adequados para "tentar" e geralmente há uma loja de rádio em qualquer <s>depósito de lixo</s> .  Pyatak não tem um efeito piezoelétrico e está presente na imagem para escala. <br><br><img src="https://habrastorage.org/webt/5v/r6/xq/5vr6xqryjht0yd5tqz7sdvmbd3a.jpeg"><br><br>  Para o receptor, é melhor usar um cabo de microfone blindado com o mesmo conector e um piezo manchado com selante ou verniz no final.  Nós inserimos esta antena na tomada do microfone. <br><br>  Para experimentos em uma lagoa, é melhor pegar algum tipo de anel piezo como transmissor e alimentá-lo com um amplificado (um amplificador em um TDA2030 com um transformador enrolado corretamente vai durar várias centenas de metros em uma boa lagoa <s>ou outras 5 voltas podem ser</s> enroladas).  Para o receptor, neste caso, também é necessário um pré-amplificador e, de preferência, um filtro passa-banda.  Se os leitores estiverem interessados ​​em aprender mais sobre isso em detalhes, conte-nos nos comentários e tentaremos criar um artigo sobre a criação de amplificadores de potência, pré-amplificadores e antenas para comunicação por sonar. <br><br><h3>  Então, voltando ao receptor, mais precisamente à parte do software </h3><br>  O mais importante na comunicação é a sincronização e a determinação da presença de um sinal útil.  No nosso exemplo, a detecção é realizada pela energia na banda: são determinados locais onde aumenta acentuadamente (o início do quadro) e onde cai acentuadamente (o final do quadro), com a condição de que da frente para a queda deva haver pelo menos a duração do quadro. <br><br>  Por toda a sua simplicidade, funciona surpreendentemente bem. <br><br>  Os dados da placa de som são coletados de acordo com as amostras do FFTSize, a FFT é executada imediatamente sobre elas e são armazenadas como “fatias” separadas, aguardando o momento em que serão processadas pelo procedimento de busca, e aqui está o código (método de busca na classe Receiver): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sliceIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frameWidth = encoder.FrameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minSlicesToSearch = Convert.ToInt32((frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sliceSize = encoder.FFTSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> weight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prevRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((slices.Count &gt; minSlicesToSearch) &amp;&amp; (sliceIndex &lt; slices.Count)) { weight = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sliceSize; i++) weight += Math.Abs(slices[sliceIndex][i]); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ratio = weight / previousWeight; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ratio &gt;= risePeekRatio) &amp;&amp; (sliceIndex - prevRisePosition &gt; frameWidth)) { prevRisePosition = lastRisePosition; lastRisePosition = sliceIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastRisePosition + (frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>) &lt; slices.Count) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { samples[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[sliceSize]; Array.Copy(slices[lastRisePosition + i], samples[i], sliceSize); } slices.RemoveRange(<span class="hljs-number"><span class="hljs-number">0</span></span>, sliceIndex); lastRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FrameReceived != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) FrameReceived(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameReceivedEventArgs(encoder.DecodeEx(samples, <span class="hljs-number"><span class="hljs-number">5</span></span>))); lastRisePosition = sliceIndex; } } sliceIndex++; previousWeight = weight; } Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> isSearching); }</code> </pre> <br>  E aqui está um pedaço de código responsável pela decodificação da imagem (Encoder.DecodeEx): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] samples, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measureCols</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> colCount = samples.Length / fftSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colCount == frameSize.Width + measureCols) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowCount = frameSize.Height; Bitmap temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(colCount, rowCount); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] slice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[fftSize]; alglib.complex[] sliceC = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> alglib.complex[fftSize]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> samplesCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> component; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> decodeStart = startLine; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> decodeEnd = startLine + rowCount; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxSlice; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; colCount; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; fftSize; y++) { slice[y] = samples[samplesCount]; samplesCount++; } alglib.fftr1d(slice, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> sliceC); maxSlice = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.MinValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = decodeStart; y &lt; decodeEnd; y++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alglib.math.abscomplex(sliceC[y].x) &gt; maxSlice) maxSlice = alglib.math.abscomplex(sliceC[y].x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = temp.Height + decodeStart - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = decodeStart; y &lt; decodeEnd; y++) { component = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(<span class="hljs-number"><span class="hljs-number">255.0</span></span> * alglib.math.abscomplex(sliceC[y].x) / maxSlice); temp.SetPixel(x, offset - y, Color.FromArgb(component, component, component)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(<span class="hljs-string"><span class="hljs-string">"Specified array length error"</span></span>); } }</code> </pre><br>  E agora proponho olhar os resultados de experimentos sobre a transmissão de "vídeo", realizados em diferentes momentos em diferentes reservatórios. <br><br>  Ambas as fotos (abaixo) foram gravadas no salão naval internacional de São Petersburgo em 2013 em nosso (então) stand através de dois laptops e um aquário. <br><br>  Não é possível distinguir o que está escrito no crachá <br><br><img src="https://habrastorage.org/webt/xp/wx/sq/xpwxsqvxyyqwrzrjh0n5wr0tm-q.gif"><br><br><img src="https://habrastorage.org/webt/w7/9y/zb/w79yzbz7caic4fre7xftuh_tq00.gif"><br><br>  E aqui estão dois "vídeos" gravados por nós em uma das baías do Lago Ladoga, na Carélia, eles são um tipo de registro para esse método (nunca mais tentamos e é improvável que seja) - o primeiro foi recebido a uma distância de 500 e o segundo a 1.000 metros : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transmissão de vídeo pela água, distância de 500 m (arquivo 8,7 mb)</a> <br><br><img src="https://habrastorage.org/webt/ek/c_/sv/ekc_svi18z7oupqlmckhziofpy8.gif"><br><br>  Como o "vídeo" foi gravado em tempo real usando uma webcam, várias coisas estranhas caíram no quadro.  Será muito interessante se alguém adivinhar e escrever em um comentário o que está em segundo plano no último “vídeo”). <br><br>  Em apoio ao fato de o método ter sido publicado há muito tempo - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nosso artigo</a> já para 2013 <br><br>  Usei a maravilhosa biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AForge</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">capturar imagens da webcam</a> . <br><br>  Funções complexas de número e FFT são usadas na excelente biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AlgLib</a> . <br><br>  E, como prometi, todo o projeto em C # (VS2012) é anexado ao artigo como material para o trabalho "doméstico".  Por conveniência, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto</a> e os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivos binários são</a> separados. <br>  A demonstração oferece a capacidade de alterar (mover) a banda de frequência ocupada, bem como a correção de gama do quadro de saída (tudo pode ser alterado em tempo real). <br><br><h3>  PS </h3><br>  Não uso C # há muito tempo e é muito difícil encontrar tempo no horário de trabalho, então peço desculpas antecipadamente pela confusão e rapidez do código. <br><br><h3>  PPS </h3><br>  Não prendo um pedaço de arame, dois macacos e dois pedaços ao artigo - não é suficiente para todos. <br><br><h3>  Erratas e Apêndice </h3><br>  - Em algumas placas de som na entrada, existe um filtro passa-baixo que corta tragicamente tudo acima de ~ 15 kHz (por que ???). <br><br>  - Por padrão, o projeto demo funciona com uma frequência de amostragem de 96 kHz, mas nem todas as placas de som modernas são compatíveis (Por que ???).  Se o equipamento não puder 96 kHz, você precisará definir 48 kHz nas configurações; caso contrário, o 44100 certamente será suportado em todos os lugares; no entanto, a duração da transmissão de um quadro será correspondentemente mais longa. <br><br>  Aqui está uma lista de laptops e placas de som que podem ser considerados equipamentos de sonar jovem: <br><br><ul><li>  Lenovo ideapad Y510P com som JBL </li><li>  Asus n55s </li><li>  Asus K501U </li><li>  placa de som externa Sound Blaster X-Fi Surround 5.1 (modelo no. SB 1095) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt408871/">https://habr.com/ru/post/pt408871/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt408857/index.html">Revisão de Imprensa da Océ Technology</a></li>
<li><a href="../pt408859/index.html">KidPRO - A história de um esquilo ajudando crianças</a></li>
<li><a href="../pt408861/index.html">Novo bioprinter ajuda a tratar diabetes tipo 1</a></li>
<li><a href="../pt408863/index.html">Digitalização 3D de carros em ajuste e reparo</a></li>
<li><a href="../pt408865/index.html">Removemos o russo do nosso inglês</a></li>
<li><a href="../pt408873/index.html">Revisão do vídeo da máquina de trituração do CNC de 3Dtool AMAN</a></li>
<li><a href="../pt408875/index.html">Rolo para as costas</a></li>
<li><a href="../pt408879/index.html">Objetivo intrigante de trabalhar muito menos</a></li>
<li><a href="../pt408881/index.html">Mas e se vivermos no futuro e no passado ao mesmo tempo? E qual é o nosso universo?</a></li>
<li><a href="../pt408883/index.html">Video 3Dtool Hercules Strong 2017 Revisão da impressora 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>