<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏽 🐶 👋 Automatización para los más pequeños. Notas API RESTful 🌅 🧔🏻 🍻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artículo es una de las notas cortas prometidas durante la serie de artículos Automation For The Smallest . 
 Dado que la forma principal de inter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatización para los más pequeños. Notas API RESTful</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485618/">  Este artículo es una de las notas cortas prometidas durante la serie de artículos <a href="https://habr.com/ru/search/%3Fq%3D%255B%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F%2520%25D0%25B4%25D0%25BB%25D1%258F%2520%25D1%2581%25D0%25B0%25D0%25BC%25D1%258B%25D1%2585%2520%25D0%25BC%25D0%25B0%25D0%25BB%25D0%25B5%25D0%25BD%25D1%258C%25D0%25BA%25D0%25B8%25D1%2585%255D%26target_type%3Dposts">Automation For The Smallest</a> . <br>  Dado que la forma principal de interactuar con el sistema IPAM es la API RESTful, decidí hablar de ello por separado. <br><br><hr><br>  Elogio a los arquitectos del mundo moderno: tenemos interfaces estandarizadas.  Sí, hay muchos de ellos, esto es un inconveniente, pero lo son, es un plus. <br><br>  Estas interfaces se han ganado el nombre de API - Interfaz de programación de aplicaciones. <br><br>  Una de estas interfaces es la API RESTful, que se utiliza para trabajar con NetBox. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/639/c1e/e86/639c1ee8692aed286b99deeb01796e89.svg" width="800"><br><br>  Si es muy simple, entonces la API le brinda al cliente un conjunto de herramientas a través de las cuales puede administrar el servidor.  Y el cliente puede ser esencialmente cualquier cosa: un navegador web, una consola de comandos, una aplicación desarrollada por el fabricante o cualquier otra aplicación que tenga acceso a la API. <br><br>  Por ejemplo, en el caso de NetBox, puede agregarle un nuevo dispositivo de las siguientes maneras: a través de un navegador web, enviando curl'om una solicitud en la consola, use Postman, acceda a la biblioteca de solicitudes en python, use el SDK de pynetbox o vaya a Swagger. <br><br>  Por lo tanto, una vez que ha escrito una única interfaz, el fabricante se libera para siempre de la necesidad de acordar con cada nuevo cliente cómo conectarla (aunque esto es solo un poco astuto). <br><a name="habracut"></a><br><h1>  Contenido </h1><br><ul><li>  REST, RESTful, API </li><li>  Estructura de mensajes HTTP <br><ul><li>  Línea de inicio </li><li>  Encabezados </li><li>  El cuerpo del mensaje HTTP </li></ul><br></li><li>  Métodos <br><ul><li>  HTTP GET </li><li>  HTTP POST </li><li>  HTTP PUT </li><li>  PARCHE HTTP </li><li>  HTTP DELETE </li></ul><br></li><li>  Formas de trabajar con la API RESTful <br><ul><li>  Rizo </li><li>  Cartero </li><li>  Python + Solicitudes </li><li>  Pynebtbox SDK </li><li>  Swagger </li></ul><br></li><li>  Críticas a REST y alternativas </li><li>  Enlaces utiles </li></ul><br><h1>  REST, RESTful, API </h1><br>  A continuación daré una descripción muy simplificada de lo que es REST. <br><br>  Para empezar, la <b>API RESTful</b> es exactamente la <b>interfaz de</b> interacción basada en REST, mientras que <b>REST</b> ( <b>REpresentational State Transfer</b> ) es un conjunto de restricciones utilizadas para crear servicios WEB. <br><br>  Es posible leer exactamente qué limitaciones se pueden encontrar en el <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" rel="nofollow">Capítulo 5 de la disertación de Roy Fielding, los estilos arquitectónicos y el diseño de arquitecturas de software basadas en red</a> .  Déjame darte solo los tres más significativos (desde mi punto de vista): <br><br><ol><li>  La arquitectura REST utiliza el modelo de interacción Cliente-Servidor. </li><li>  Cada solicitud REST contiene toda la información necesaria para su ejecución.  Es decir, el servidor no debe recordar nada sobre solicitudes de clientes anteriores, que, como usted sabe, se caracteriza por la palabra Sin estado: no almacene información de estado. </li><li>  Interfaz unificada  La implementación de la aplicación es independiente del servicio que proporciona.  Es decir, el usuario sabe lo que hace y cómo interactuar con él, pero no importa cómo lo hace.  Cuando cambia la aplicación, la interfaz permanece igual y los clientes no necesitan ajustarse. </li></ol><br>  Los servicios WEB que satisfacen todos los principios de REST se denominan <b>servicios RESTful WEB</b> . <br><br>  Y la API que proporciona servicios RESTful WEB se llama RESTful API. <br><br>  REST no es un protocolo, sino el llamado estilo de arquitectura (uno de).  Desarrollado con HTTP por Roy Fielding, REST estaba destinado a utilizar <b>HTTP 1.1</b> como transporte. <br><br>  Dirección de destino (o en otras palabras, un objeto, o de otra manera, un punto final): este es nuestro <a href="https://ru.wikipedia.org/wiki/URI" rel="nofollow"><b>URI</b></a> habitual. <br><br>  El formato de los datos transmitidos es <b>XML</b> o <b>JSON</b> . <br><blockquote>  Para esta serie de artículos sobre linkmeup, se implementó una implementación de solo lectura (para ustedes, queridos lectores). Instalación de NetBox: <a href="http://netbox.linkmeup.ru/" rel="nofollow">netbox.linkmeup.ru</a> : 45127. <br><br>  No se requieren derechos de lectura, pero si desea intentar leer con un token, puede usar esto: <i>API de token: 90a22967d0bc4bdcd8ca47ec490bbf0b0cb2d9c8</i> . <br></blockquote>  Hagamos una solicitud de diversión: <br><br><pre><code class="bash hljs">curl -X GET -H <span class="hljs-string"><span class="hljs-string">"Authorization: TOKEN 90a22967d0bc4bdcd8ca47ec490bbf0b0cb2d9c8"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Accept: application/json; indent=4"</span></span> \ http://netbox.linkmeup.ru:45127/api/dcim/devices/1/</code> </pre> <br>  Es decir, con la utilidad <b>curl</b> , creamos un objeto <b>GET</b> en <b><a href="http://netbox.linkmeup.ru/" rel="nofollow">netbox.linkmeup.ru</a> : 45127 / api / dcim / devices / 1 /</b> con una respuesta <b>JSON</b> y una sangría de <b>4</b> espacios. <br><br>  O un poco más académicamente: GET devuelve el objeto de <b>dispositivos</b> escritos, que es un parámetro del objeto <b>DCIM</b> . <br><br>  También puede cumplir con esta solicitud, simplemente cópiela en su terminal. <br><blockquote>  La URL a la que nos referimos en la solicitud se llama <b>Endpoint</b> .  En cierto sentido, este es el objeto final con el que interactuaremos. <br>  Por ejemplo, en el caso de netbox, <a href="http://netbox.linkmeup.ru:45127/api/docs/" rel="nofollow">aquí</a> se puede obtener una lista de todos los puntos finales. <br></blockquote><blockquote>  Y preste atención al signo <b>/</b> al final de la URL: es <b>obligatorio</b> . <br></blockquote>  Esto es lo que obtenemos en respuesta: <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 1, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"mlg-host-0"</span></span>, <span class="hljs-string"><span class="hljs-string">"display_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"mlg-host-0"</span></span>, <span class="hljs-string"><span class="hljs-string">"device_type"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 4, <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru/api/dcim/device-types/4/"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 4, <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru/api/dcim/manufacturers/4/"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hypermacro"</span></span>, <span class="hljs-string"><span class="hljs-string">"slug"</span></span>: <span class="hljs-string"><span class="hljs-string">"hypermacro"</span></span> }, <span class="hljs-string"><span class="hljs-string">"model"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server"</span></span>, <span class="hljs-string"><span class="hljs-string">"slug"</span></span>: <span class="hljs-string"><span class="hljs-string">"server"</span></span>, <span class="hljs-string"><span class="hljs-string">"display_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hypermacro Server"</span></span> }, <span class="hljs-string"><span class="hljs-string">"device_role"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 1, <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru/api/dcim/device-roles/1/"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server"</span></span>, <span class="hljs-string"><span class="hljs-string">"slug"</span></span>: <span class="hljs-string"><span class="hljs-string">"server"</span></span> }, <span class="hljs-string"><span class="hljs-string">"tenant"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"platform"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"serial"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"asset_tag"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"site"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 6, <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru/api/dcim/sites/6/"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"slug"</span></span>: <span class="hljs-string"><span class="hljs-string">"mlg"</span></span> }, <span class="hljs-string"><span class="hljs-string">"rack"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 1, <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru/api/dcim/racks/1/"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"display_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"A"</span></span> }, <span class="hljs-string"><span class="hljs-string">"position"</span></span>: 41, <span class="hljs-string"><span class="hljs-string">"face"</span></span>: { <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"front"</span></span>, <span class="hljs-string"><span class="hljs-string">"label"</span></span>: <span class="hljs-string"><span class="hljs-string">"Front"</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 0 }, <span class="hljs-string"><span class="hljs-string">"parent_device"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"status"</span></span>: { <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"active"</span></span>, <span class="hljs-string"><span class="hljs-string">"label"</span></span>: <span class="hljs-string"><span class="hljs-string">"Active"</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 1 }, <span class="hljs-string"><span class="hljs-string">"primary_ip"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"primary_ip4"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"primary_ip6"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"cluster"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"virtual_chassis"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"vc_position"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"vc_priority"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"comments"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"local_context_data"</span></span>: null, <span class="hljs-string"><span class="hljs-string">"tags"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"custom_fields"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"config_context"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"created"</span></span>: <span class="hljs-string"><span class="hljs-string">"2020-01-14"</span></span>, <span class="hljs-string"><span class="hljs-string">"last_updated"</span></span>: <span class="hljs-string"><span class="hljs-string">"2020-01-14T18:39:01.288081Z"</span></span> }</code> </pre><br>  Este es JSON (como solicitamos), que describe el dispositivo con ID 1: cómo se llama, con qué rol, qué modelo, dónde se encuentra, etc. <br><br>  Esto se verá como una solicitud HTTP: <br><br><pre> <code class="bash hljs"> GET /api/dcim/devices/1/ HTTP/1.1 Host: netbox.linkmeup.ru:45127 User-Agent: curl/7.54.0 Accept: application/json; indent=4</code> </pre> <br><br>  Entonces la respuesta se verá: <br><pre> <code class="bash hljs"> HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Tue, 21 Jan 2020 15:14:22 GMT Content-Type: application/json Content-Length: 1638 Connection: keep-alive Data</code> </pre> <br>  <a href="http_get_devices.pcapng" rel="nofollow">Volcar la transacción</a> . <br><br>  Ahora descubramos lo que hemos hecho. <br><br><hr><br><h1>  Estructura de mensajes HTTP </h1><br>  Un mensaje HTTP consta de tres partes, de las cuales solo se requiere la primera. <br><br><ul><li>  Línea de inicio </li><li>  Encabezados </li><li>  Cuerpo del mensaje </li></ul><br><h2>  Línea de inicio </h2><br>  Las líneas de inicio de la solicitud y respuesta HTTP se ven diferentes. <br><br><h4>  Solicitud HTTP </h4><br><pre> <code class="bash hljs">METHOD URI HTTP_VERSION</code> </pre> <br><blockquote>  <b>El método</b> determina qué acción quiere realizar el cliente: recibir datos, crear un objeto, actualizarlo, eliminarlo. <br>  <b>URI</b> : el identificador del recurso donde el cliente accede, o en otras palabras, la ruta al recurso / documento. <br>  <b>HTTP_VERSION</b> es la versión HTTP, respectivamente.  Hoy, para REST, siempre es 1.1. <br></blockquote>  Un ejemplo: <br><br><pre> <code class="bash hljs">GET /api/dcim/devices/1/ HTTP/1.1</code> </pre> <br><br><h4>  Respuesta HTTP </h4><br><pre> <code class="bash hljs">HTTP_VERSION STATUS_CODE REASON_PHRASE</code> </pre> <br><blockquote>  <b>HTTP_VERSION</b> : versión HTTP (1.1). <br>  <b>STATUS_CODE</b> : tres dígitos del código de estado (200, 404, 502, etc.) <br>  <b>REASON_PHRASE</b> - Explicación (OK, NO ENCONTRADO, MALA PUERTA DE ENLACE, etc.) <br></blockquote><br>  Un ejemplo: <br><br><pre> <code class="bash hljs">HTTP/1.1 200 OK</code> </pre> <br><h2>  Encabezados </h2><br>  Los encabezados pasan los parámetros para esta transacción HTTP. <br><br>  Por ejemplo, en el ejemplo anterior en la solicitud HTTP, estos fueron: <br><br><pre> <code class="bash hljs"> Host: netbox.linkmeup.ru:45127 User-Agent: curl/7.54.0 Accept: application/json; indent=4</code> </pre> <br>  Indican que <br><br><ol><li>  Pasamos al host <b>netbox.linkmeup.ru:45127</b> , </li><li>  La solicitud se generó en <b>curl</b> , </li><li>  Y aceptamos datos en <b>formato JSON</b> con sangría de <b>4</b> . </li></ol><br>  Y aquí están los encabezados en la respuesta HTTP: <br><br><pre> <code class="bash hljs"> Server: nginx/1.14.0 (Ubuntu) Date: Tue, 21 Jan 2020 15:14:22 GMT Content-Type: application/json Content-Length: 1638 Connection: keep-alive</code> </pre> <br>  Indican que <br><br><ol><li>  Tipo de servidor: <b>nginx en Ubuntu</b> , </li><li>  Tiempo de respuesta </li><li>  Formato de datos de respuesta: <b>JSON</b> </li><li>  Longitud de datos de respuesta: <b>1638 bytes</b> </li><li>  No es necesario cerrar la conexión; todavía habrá datos. </li></ol><br>  Los encabezados, como ya ha notado, se ven como pares nombre: valor, separados por un signo ":". <br><br>  <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" rel="nofollow">Una lista completa de posibles encabezados</a> . <br><br><h2>  El cuerpo del mensaje HTTP </h2><br>  El cuerpo se utiliza para transferir los datos reales. <br><br>  En la respuesta HTTP, puede ser una página HTML o, en nuestro caso, un objeto JSON. <br><br>  Debe haber al menos una línea en blanco entre los encabezados y el cuerpo. <br><br>  Cuando se utiliza el método GET en una solicitud HTTP, generalmente no hay cuerpo porque no hay nada que transmitir.  Pero el cuerpo está en la respuesta HTTP. <br><br>  Pero, por ejemplo, con POST, el cuerpo ya estará en la solicitud.  Hablemos de los métodos y hablemos ahora. <br><br><hr><br><h1>  Métodos </h1><br>  Como ya entendió, HTTP utiliza métodos para trabajar con servicios WEB.  Lo mismo ocurre con la API RESTful. <br><br>  Los posibles escenarios de la vida real se describen con el término <b>CRUD: Crear, Leer, Actualizar, Eliminar</b> . <br>  Aquí hay una lista de los métodos HTTP más populares que implementan CRUD: <br><br><ul><li>  HTTP GET </li><li>  HTTP POST </li><li>  HTTP PUT </li><li>  HTTP DELETE </li><li>  PARCHE HTTP </li></ul><br>  Los métodos también se llaman <b>verbos</b> , porque indican qué acción se realiza. <br><br>  <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" rel="nofollow">Lista completa de métodos</a> . <br><br>  Veamos cada uno de ellos usando el ejemplo de NetBox. <br><br><h2>  HTTP GET </h2><br>  Este es un método para obtener información. <br><br>  Entonces, por ejemplo, quitamos la lista de dispositivos: <br><br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">"Accept: application/json; indent=4"</span></span> \ http://netbox.linkmeup.ru:45127/api/dcim/devices/</code> </pre> <br>  El método GET es <b>seguro</b> porque no cambia los datos, solo pregunta. <br><br>  Es <b>idempotente</b> desde el punto de vista que la misma consulta siempre devuelve el mismo resultado (hasta que los datos en sí mismos hayan cambiado). <br><br>  En GET, el servidor devuelve un mensaje con el código HTTP y el cuerpo de <b>respuesta</b> ( <b>código de</b> <b>respuesta</b> y <b>cuerpo de respuesta</b> ). <br><br>  Es decir, si todo está bien, entonces el código de respuesta es 200 (OK). <br>  Si no se encuentra la URL, 404 (NO ENCONTRADO). <br>  Si algo está mal con el servidor o los componentes, puede ser 500 (ERROR DEL SERVIDOR) o 502 (MALA PUERTA DE ENLACE). <br>  <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" rel="nofollow">Todos los posibles códigos de respuesta</a> . <br><br>  El cuerpo se devuelve en formato JSON o XML. <br><br>  <a href="http_get_all_devices.pcapng" rel="nofollow">Volcar la transacción</a> . <br><br>  Demos un par de ejemplos más.  Ahora solicitaremos información sobre un dispositivo específico por su nombre. <br><br><pre> <code class="bash hljs">curl -X GET -H <span class="hljs-string"><span class="hljs-string">"Accept: application/json; indent=4"</span></span> \ <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127/api/dcim/devices/?name=mlg-leaf-0"</span></span></code> </pre> <br>  Aquí, para establecer las condiciones de búsqueda en el URI, también especifiqué el atributo del objeto (el parámetro de <b>nombre</b> y su valor <b>mlg-leaf-0</b> ).  Como puede ver, antes de la condición y después de la barra hay un <b>"?"</b>  , y el nombre y el valor están separados por un signo <b>"="</b> . <br><br>  Así es como se ve la solicitud. <br><br><pre> <code class="bash hljs"> GET /api/dcim/devices/?name=mlg-leaf-0 HTTP/1.1 Host: netbox.linkmeup.ru:45127 User-Agent: curl/7.54.0 Accept: application/json; indent=4</code> </pre> <br>  <a href="http_get_device_by_name.pcapng" rel="nofollow">Volcar la transacción</a> . <br><br>  Si necesita especificar un par de condiciones, la consulta se verá así: <br><br><pre> <code class="bash hljs">curl -X GET -H <span class="hljs-string"><span class="hljs-string">"Accept: application/json; indent=4"</span></span> \ <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127/api/dcim/devices/?role=leaf&amp;site=mlg"</span></span></code> </pre> <br>  Aquí solicitamos todos <b>los</b> dispositivos de <b>hoja</b> ubicados en el <b>sitio</b> web <b>mlg</b> . <br>  Es decir, las dos condiciones están separadas entre sí por el signo <b>"&amp;"</b> . <br><br>  <a href="http_get_device_with_double_conditions.pcapng" rel="nofollow">Volcar la transacción</a> . <br><br>  Desde lo curioso y agradable: si a través de "&amp;" establece dos condiciones con el mismo nombre, entonces entre ellas no habrá un "Y" lógico, sino un "OR" lógico. <br><br>  Es decir, tal consulta en realidad devolverá dos objetos: mlg-leaf-0 y mlg-spine-0 <br><br><pre> <code class="bash hljs">curl -X GET -H <span class="hljs-string"><span class="hljs-string">"Accept: application/json; indent=4"</span></span> \ <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127/api/dcim/devices/?name=mlg-leaf-0&amp;name=mlg-spine-0"</span></span></code> </pre> <br>  <a href="http_get_device_with_or_operand.pcapng" rel="nofollow">Volcar la transacción</a> . <br><br>  Intentemos acceder a una URL inexistente. <br><br><pre> <code class="bash hljs">curl -X GET -H <span class="hljs-string"><span class="hljs-string">"Accept: application/json; indent=4"</span></span> \ <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127/api/dcim/IDGAF/"</span></span></code> </pre> <br>  <a href="http_get_not_found.pcapng" rel="nofollow">Volcar la transacción</a> . <br><br><hr><br><h2>  HTTP POST </h2><br>  POST se utiliza para crear un nuevo objeto en una colección de objetos.  O en un lenguaje más complejo: crear un nuevo recurso subordinado. <br><br><blockquote>  Aclaración de <a href="https://habr.com/ru/users/arthuriantech/" class="user_link">arthuriantech</a> : <br>  Incluyendo, pero no limitado a.  El método POST está diseñado para transferir datos al servidor para su posterior procesamiento; se utiliza para cualquier acción que no necesite ser estandarizada dentro de HTTP.  Antes de <a href="https://tools.ietf.org/html/rfc5789" rel="nofollow">RFC 5789,</a> era la única forma legal de hacer cambios parciales. <br>  <a href="https://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post" rel="nofollow">roy.gbiv.com/untangled/2009/it-is-okay-to-use-post</a> <br>  <a href="https://tools.ietf.org/html/rfc7231" rel="nofollow">tools.ietf.org/html/rfc7231#section-4.3.3</a> </blockquote><br><br>  Es decir, si hay un conjunto de dispositivos, POST le permite crear un nuevo objeto de dispositivo dentro de los dispositivos. <br><br>  Seleccione el mismo Endpoint y use POST para crear un nuevo dispositivo. <br><br><pre> <code class="bash hljs">curl -X POST <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127/api/dcim/devices/"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"accept: application/json"</span></span>\ -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Authorization: TOKEN a9aae70d65c928a554f9a038b9d4703a1583594f"</span></span> \ -d <span class="hljs-string"><span class="hljs-string">"{ \"name\": \"just a simple russian girl\", \"device_type\": 1, \"device_role\": 1, \"site\": 3, \"rack\": 3, \"position\": 5, \"face\": \"front\"}"</span></span></code> </pre> <br>  Aquí aparece <b>un</b> encabezado de <b>Autorización</b> , que contiene un token que autoriza la solicitud de escritura, y después de la directiva <b>-d</b> hay JSON con los parámetros del dispositivo creado: <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"just a simple russian girl"</span></span>, <span class="hljs-string"><span class="hljs-string">"device_type"</span></span>: 1, <span class="hljs-string"><span class="hljs-string">"device_role"</span></span>: 1, <span class="hljs-string"><span class="hljs-string">"site"</span></span>: 3, <span class="hljs-string"><span class="hljs-string">"rack"</span></span>: 3, <span class="hljs-string"><span class="hljs-string">"position"</span></span>: 5, <span class="hljs-string"><span class="hljs-string">"face"</span></span>: <span class="hljs-string"><span class="hljs-string">"front"</span></span>}</code> </pre> <br><blockquote>  Su solicitud no funcionará porque el token ya no es válido; no intente escribir en NetBox. <br></blockquote>  La respuesta viene con una respuesta HTTP con el código 201 (CREADO) y JSON en el cuerpo del mensaje, donde el servidor devuelve todos los parámetros sobre el dispositivo creado. <br><br><pre> <code class="bash hljs"> HTTP/1.1 201 Created Server: nginx/1.14.0 (Ubuntu) Date: Sat, 18 Jan 2020 11:00:22 GMT Content-Type: application/json Content-Length: 1123 Connection: keep-alive JSON</code> </pre> <br>  <a href="http_post_new_device.pcapng" rel="nofollow">Volcar la transacción</a> . <br><br>  Ahora, con una nueva solicitud con el método GET, puede verla en la salida: <br><br><pre> <code class="bash hljs">curl -X GET -H <span class="hljs-string"><span class="hljs-string">"Accept: application/json; indent=4"</span></span> \ <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127/api/dcim/devices/?q=russian"</span></span></code> </pre> <br><blockquote>  "Q" en NetBox le permite encontrar todos los objetos que contienen en su nombre una línea que va más allá. <br></blockquote>  POST, obviamente, <b>no</b> es <b>seguro ni idempotente</b> : probablemente cambia los datos, y una solicitud ejecutada dos veces conducirá a la creación del segundo mismo objeto o a un error. <br><br><hr><br><h2>  HTTP PUT </h2><br>  Este es un método para modificar un objeto existente.  El punto final para PUT se ve diferente que para POST: ahora contiene un objeto específico. <br><br>  PUT puede devolver los códigos 201 o 200. <br><br>  Un punto importante con este método: debe pasar todos los atributos requeridos, ya que PUT reemplaza el objeto antiguo. <br><br>  Por lo tanto, si, por ejemplo, solo intentamos agregar el atributo asset_tag a nuestro nuevo dispositivo, obtenemos un error: <br><br><pre> <code class="bash hljs">curl -X PUT <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127/api/dcim/devices/18/"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"accept: application/json"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Authorization: TOKEN a9aae70d65c928a554f9a038b9d4703a1583594f"</span></span> \ -d <span class="hljs-string"><span class="hljs-string">"{ \"asset_tag\": \"12345678\"}"</span></span></code> </pre> <br><pre> <code class="bash hljs">{<span class="hljs-string"><span class="hljs-string">"device_type"</span></span>:[<span class="hljs-string"><span class="hljs-string">"This field is required."</span></span>],<span class="hljs-string"><span class="hljs-string">"device_role"</span></span>:[<span class="hljs-string"><span class="hljs-string">"This field is required."</span></span>],<span class="hljs-string"><span class="hljs-string">"site"</span></span>:[<span class="hljs-string"><span class="hljs-string">"This field is required."</span></span>]}</code> </pre> <br>  Pero si agrega los campos faltantes, entonces todo funcionará: <br><br><pre> <code class="bash hljs">curl -X PUT <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127/api/dcim/devices/18/"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"accept: application/json"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Authorization: TOKEN a9aae70d65c928a554f9a038b9d4703a1583594f"</span></span> \ -d <span class="hljs-string"><span class="hljs-string">"{ \"name\": \"just a simple russian girl\", \"device_type\": 1, \"device_role\": 1, \"site\": 3, \"rack\": 3, \"position\": 5, \"face\": \"front\", \"asset_tag\": \"12345678\"}"</span></span></code> </pre> <br>  <a href="http_put_asset_tag.pcapng" rel="nofollow">Volcar la transacción</a> . <br><blockquote>  Preste atención a la URL aquí: ahora incluye la ID del dispositivo que queremos cambiar ( <b>18</b> ). <br></blockquote><br><hr><br><h2>  PARCHE HTTP </h2><br>  Este método se utiliza para modificar parcialmente el recurso. <br>  Wat?  Usted pregunta, pero ¿qué pasa con PUT? <br><br>  PUT es un método que originalmente existía en el estándar, que implica el reemplazo completo de un objeto mutable.  En consecuencia, en el método PUT, como escribí anteriormente, tendrá que especificar incluso aquellos atributos del objeto que no cambian. <br><br>  Y PATCH se agregó más tarde y le permite especificar solo aquellos atributos que realmente cambian. <br><br>  Por ejemplo: <br><br><pre> <code class="bash hljs">curl -X PATCH <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127/api/dcim/devices/18/"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"accept: application/json"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Authorization: TOKEN a9aae70d65c928a554f9a038b9d4703a1583594f"</span></span> \ -d <span class="hljs-string"><span class="hljs-string">"{ \"serial\": \"BREAKINGBAD\"}"</span></span></code> </pre> <br>  Aquí, la ID del dispositivo también se especifica en la URL, pero solo hay un atributo en <b>serie</b> para cambiar. <br><br>  <a href="http_patch_serial.pcapng" rel="nofollow">Volcar la transacción</a> . <br><br><hr><br><h2>  HTTP DELETE </h2><br>  Obviamente elimina el objeto. <br><br>  Un ejemplo <br><br><pre> <code class="bash hljs">curl -X DELETE <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127/api/dcim/devices/21/"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"accept: application/json"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Authorization: TOKEN a9aae70d65c928a554f9a038b9d4703a1583594f"</span></span></code> </pre> <br>  El método DELETE es idempotente desde el punto de vista de que una consulta repetida ya no cambia nada en la lista de recursos (pero devolverá el código 404 (NO ENCONTRADO). <br><br><pre> <code class="bash hljs">curl -X DELETE <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127/api/dcim/devices/21/"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"accept: application/json"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> \ -H <span class="hljs-string"><span class="hljs-string">"Authorization: TOKEN a9aae70d65c928a554f9a038b9d4703a1583594f"</span></span></code> </pre> <br><pre> <code class="bash hljs">{<span class="hljs-string"><span class="hljs-string">"detail"</span></span>:<span class="hljs-string"><span class="hljs-string">"Not found."</span></span>}</code> </pre> <br><hr><br><h1>  Formas de trabajar con la API RESTful </h1><br>  Curl es, por supuesto, muy conveniente para los valientes guerreros de CLI, pero hay mejores herramientas. <br><br><h2>  Cartero </h2><br>  Postman le permite realizar consultas en la interfaz gráfica seleccionando métodos, encabezados, cuerpo y muestra el resultado en una forma legible para humanos. <br><br>  Además, las consultas y los URI pueden guardarse y devolverse más tarde. <br><br>  <a href="https://www.getpostman.com/downloads/" rel="nofollow">Descargar Postman en el sitio web oficial</a> . <br><br>  Entonces podemos hacer un GET: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b00/869/169/b00869169e3e64b427e224587da49e12.png" width="800"><br>  <i>Aquí el token se indica en el GET solo como un ejemplo.</i> <br><br>  Y entonces POST: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1b/91f/655/f1b91f655182e7780ee62d44e8e25ae9.png" width="800"><br><br>  Postman es para usar solo con la API RESTful. <br><blockquote>  Por ejemplo, no intente enviar NETCONF XML a través de él, como lo hice al comienzo de mi carrera de automatización. <br></blockquote>  Una de las bonificaciones de la API especificada es que puede importar todos los puntos finales y sus métodos en Postman como una colección. <br><br>  Para hacer esto, en la ventana <b>Importar</b> (Archivo-&gt; Importar), seleccione <b>Importar desde enlace</b> y pegue en la ventana <a href="http://netbox.linkmeup.ru/" rel="nofollow">netbox.linkmeup.ru</a> URL: 45127 / api / docs /? Format = openapi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9f/48e/2d1/f9f48e2d1923e88995301379e4888b6c.png" width="400"><br><br>  Además, todo lo que puedes encontrar se puede encontrar en las colecciones. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eaa/616/c1a/eaa616c1adfcfacbaf164ea95531fd4e.png" width="200"><br><br><hr><br><br><h2>  Python + solicitudes </h2><br>  Pero incluso a través de Postman, lo más probable es que no gestiones tus sistemas de producción.  Seguramente, tendrá aplicaciones externas que deseen interactuar con ellas sin su participación. <br><br>  Por ejemplo, un sistema de generación de configuración quiere recoger una lista de interfaces IP de NetBox. <br>  Python tiene una maravillosa biblioteca de <b>solicitudes</b> que implementa el trabajo a través de HTTP. <br>  Un ejemplo de solicitud de una lista de todos los dispositivos: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests HEADERS = {<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'Accept'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>} NB_URL = <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127"</span></span> request_url = <span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{NB_URL}</span></span></span><span class="hljs-string">/api/dcim/devices/"</span></span> devices = requests.get(request_url, headers = HEADERS) print(devices.json())</code> </pre> <br>  Agregue un nuevo dispositivo nuevamente: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests API_TOKEN = <span class="hljs-string"><span class="hljs-string">"a9aae70d65c928a554f9a038b9d4703a1583594f"</span></span> HEADERS = {<span class="hljs-string"><span class="hljs-string">'Authorization'</span></span>: <span class="hljs-string"><span class="hljs-string">f'Token </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{API_TOKEN}</span></span></span><span class="hljs-string">'</span></span>, <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'Accept'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>} NB_URL = <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127"</span></span> request_url = <span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{NB_URL}</span></span></span><span class="hljs-string">/api/dcim/devices/"</span></span> device_parameters = { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"just a simple REQUESTS girl"</span></span>, <span class="hljs-string"><span class="hljs-string">"device_type"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"device_role"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"site"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, } new_device = requests.post(request_url, headers = HEADERS, json=device_parameters) print(new_device.json())</code> </pre> <br><hr><br><h3>  Python + NetBox SDK </h3><br>  En el caso de NetBox, también está el Python SDK - <a href="https://github.com/digitalocean/pynetbox" rel="nofollow">Pynetbox</a> , que representa todos los <a href="https://github.com/digitalocean/pynetbox" rel="nofollow">puntos finales de</a> NetBox como un objeto y sus atributos, haciendo todo el trabajo sucio para generar URI y analizar la respuesta, aunque no de forma gratuita, por supuesto. <br><br>  Por ejemplo, hagamos lo mismo que arriba, usando pynetbox. <br>  Lista de todos los dispositivos: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pynetbox NB_URL = <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127"</span></span> nb = pynetbox.api(NB_URL) devices = nb.dcim.devices.all() print(devices)</code> </pre> <br>  Añadir nuevo dispositivo: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pynetbox API_TOKEN = <span class="hljs-string"><span class="hljs-string">"a9aae70d65c928a554f9a038b9d4703a1583594f"</span></span> NB_URL = <span class="hljs-string"><span class="hljs-string">"http://netbox.linkmeup.ru:45127"</span></span> nb = pynetbox.api(NB_URL, token = API_TOKEN) device_parameters = { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"just a simple PYNETBOX girl"</span></span>, <span class="hljs-string"><span class="hljs-string">"device_type"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"device_role"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"site"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, } new_device = nb.dcim.devices.create(**device_parameters) print(new_device)</code> </pre> <br>  <a href="https://pynetbox.readthedocs.io/en/latest/" rel="nofollow">Documentación de Pynetbox</a> <br><br><hr><br><h2>  Swagger </h2><br>  Lo que vale más gracias a la última década son las especificaciones API.  Si sigue <a href="http://netbox.linkmeup.ru:45127/api/docs/" rel="nofollow">esta ruta</a> , accederá a la interfaz de usuario de Swagger - Documentación de la API de Netbox. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c5c/ec6/1db/c5cec61db67db108cc2fce2ba0492d3b.png" width="800"><br><br>  Esta página enumera todos los puntos finales, métodos para trabajar con ellos, posibles parámetros y atributos e indica cuáles de ellos son necesarios.  Además, se describen las respuestas esperadas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4bc/886/8e6/4bc8868e6cfae94427e648abd0a1cd7b.png" width="800"><br><br>  En la misma página, puede realizar consultas interactivas haciendo clic en <b>Pruébelo</b> . <br><blockquote>  Por alguna razón, swagger toma el nombre del servidor sin puerto como URL base, por lo que la función Probar no funciona en mis ejemplos de Swagger.  Pero puedes probarlo en tu propia instalación. <br></blockquote>  Cuando hace clic en <b>Ejecutar</b> Swagger, la IU generará una cadena de rizo que se puede usar para hacer una solicitud similar desde la línea de comandos. <br><br>  En Swagger UI, incluso puedes crear un objeto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/47b/311/74f/47b31174f7b1b8564b2aadea91db89bb.png" width="800"><br><br>  Para hacer esto, es suficiente ser un usuario autorizado con los derechos necesarios. <br><br>  Lo que vemos en esta página es la interfaz de usuario de Swagger, una documentación generada en base a la especificación API. <br><br>  Con las tendencias en la arquitectura de microservicios, es cada vez más importante contar con una API estandarizada para la interacción entre componentes, cuyos puntos finales y métodos son fáciles de determinar tanto para la persona como para la aplicación sin hurgar en el código fuente o la documentación en PDF. <br><br>  Por lo tanto, los desarrolladores de hoy siguen cada vez más el paradigma <a href="https://medium.com/adobetech/three-principles-of-api-first-design-fa6666d9f694" rel="nofollow">API First</a> cuando piensan por primera vez en la API, y solo entonces en la implementación. <br>  La API se especifica primero en este diseño, y luego la documentación, la aplicación del cliente, la parte del servidor se <b>generan a</b> partir de ella y se necesitan pruebas. <br><br>  Swagger es un marco y lenguaje de especificación (que ahora ha sido renombrado OpenAPI 2.0), lo que le permite implementar esta tarea. <br>  No voy a profundizar en eso. <br><br>  Para más detalles aquí: <br><br><ul><li>  <a href="https://swagger.io/docs/specification/" rel="nofollow">Sitio web de Swagger</a> </li><li>  <a href="https://justcodeit.ru/swagger-docs-dlya-api-na-laravel/" rel="nofollow">Ejemplo de uso</a> </li><li>  <a href="https://en.wikipedia.org/wiki/OpenAPI_Specification" rel="nofollow">Wiki sobre Open API</a> </li></ul><br><hr><br><h1>  Críticas a REST y alternativas </h1><br>  Hay uno, si.  No todo en ese mundo del año 2000 ya es tan color de rosa. <br><br>  Al no ser un experto, no pretendo revelar sustancialmente el tema, pero daré un enlace a un <a href="https://habr.com/ru/post/265845/">artículo</a> indiscutible <a href="https://habr.com/ru/post/265845/">sobre Habré</a> . <br><br>  Una interfaz alternativa para la interacción de los componentes del sistema hoy es gRPC.  También profetizó un gran futuro en el campo de los nuevos enfoques para trabajar con equipos de red.  Pero hablaremos de él en algún momento en el futuro, cuando llegue su turno. <br><br>  También puede echar un vistazo a la prometedora <a href="https://habr.com/ru/post/326986/">GraphQL</a> , pero de nuevo no necesitamos trabajar con ella por ahora, por lo que queda para estudio independiente. <br><br><hr><br><blockquote>  <b>Es importante</b> <br>  El token a9aae70d65c928a554f9a038b9d4703a1583594f se usó solo con fines de demostración y ya no funciona. <br><br>  La indicación directa de tokens en el código del programa es inaceptable y lo he hecho aquí solo para simplificar los ejemplos. <br></blockquote><br><hr><br><h1>  Enlaces utiles </h1><br><ul><li>  <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" rel="nofollow">Informe original de Roy Fielding</a> </li><li>  <a href="https://medium.com/adobetech/three-principles-of-api-first-design-fa6666d9f694" rel="nofollow">API primero</a> </li><li>  <a href="http-methods/" rel="nofollow">Métodos HTTP</a> </li><li>  <a href="https://restfulapi.net/rest-architectural-constraints/" rel="nofollow">Principios REST</a> </li><li>  <a href="https://swagger.io/docs/specification/" rel="nofollow">Sitio web de Swagger</a> </li><li>  <a href="https://justcodeit.ru/swagger-docs-dlya-api-na-laravel/" rel="nofollow">Ejemplo de arrogancia</a> </li><li>  <a href="https://en.wikipedia.org/wiki/OpenAPI_Specification" rel="nofollow">Wiki sobre OpenAPI</a> </li><li>  <a href="https://habr.com/ru/post/265845/">Crítica de REST</a> </li></ul><br><h1>  Gracias </h1><br><ul><li>  Andrei Panfilov para revisión y edición </li><li>  Alexander Fatin para revisión y edición </li></ul></div></div><p>Source: <a href="https://habr.com/ru/post/485618/">https://habr.com/ru/post/485618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485606/index.html">Operaciones de filtro de controladores en el registro. Practica</a></li>
<li><a href="../485608/index.html">Microservicios con Spring Boot. Parte 4. Uso de la cinta para equilibrar la carga</a></li>
<li><a href="../485610/index.html">Cree una aplicación Qt en WebAssembly en Windows</a></li>
<li><a href="../485612/index.html">¿Qué me enseñó un accidente espacial como desarrollador?</a></li>
<li><a href="../485614/index.html">La cultura corporativa roja es el principal problema de los negocios rusos (Parte 3)</a></li>
<li><a href="../485620/index.html">¿Yoshkar-Ola, en general, una ciudad de TI?</a></li>
<li><a href="../485622/index.html">Herramientas de respaldo de PostgreSQL. Andrey Salnikov (Garceta de datos)</a></li>
<li><a href="../485624/index.html">Servidor Minecraft: Windows vs Linux</a></li>
<li><a href="../485630/index.html">Cosmonáutica de África: de la basura a la realidad</a></li>
<li><a href="../485632/index.html">Monitoreo de la calificación crediticia en Power BI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>