<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏼 🧒🏽 👷🏼 古巴7：有什么新变化？ 🍏 🙏🏾 👧🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="三年前，我们宣布发布CUBA 6 。 该版本成为革命性的：我们不再使用封闭的专有许可证，而是开始根据Apache 2.0许可证自由分发框架。 那时，我们甚至还无法从长远角度了解这将如何影响框架的开发。 CUBA社区开始呈指数增长，我们面临着使用该框架的所有可能（有时是不可能）的方式。 现在，我们介​...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>古巴7：有什么新变化？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/447538/"><p><img src="https://habrastorage.org/webt/f8/-f/_k/f8-f_kslug-6yzi1yx-ui1e51gy.png"></p><br><p> 三年前，我们宣布发布<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CUBA 6</a> 。 该版本成为革命性的：我们不再使用封闭的专有许可证，而是开始根据Apache 2.0许可证自由分发框架。 那时，我们甚至还无法从长远角度了解这将如何影响框架的开发。  CUBA社区开始呈指数增长，我们面临着使用该框架的所有可能（有时是不可能）的方式。 现在，我们介​​绍<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CUBA 7</a> 。 我们希望此版本将使社区的所有成员更加轻松愉快地进行开发：从刚熟悉CUBA和Java的初学者到在大型公司级别拥有多个完成项目的经验丰富的开发人员。 </p><a name="habracut"></a><br><h2 id="instrumenty-razrabotki"> 开发工具 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CUBA Studio</a>是CUBA成功的重要部分。 这种开发环境大大简化了每个Java项目中完成的典型任务的实现，从而将它们简化为在可视设计器中创建简单的配置。 您不需要了解所有Persistence API注释属性，Gradle语法或Spring配置的精妙之处，就可以开发出功能齐全的完整CRUD应用程序-CUBA Studio负责创建典型的代码。 </p><br><p><img src="https://habrastorage.org/webt/lr/5f/8g/lr5f8gtzh5ls_zvskmqccmrccpc.png"></p><br><p>  Studio是一个单独的Web应用程序，它引起了许多重大限制： </p><br><ul><li> 首先，Studio并不是完整的IDE，因此开发人员必须在Studio和IntelliJ IDEA或Eclipse之间切换才能开发业务逻辑，同时使用便捷的导航，代码完成和其他必要的操作，这有些令人讨厌。 </li><li> 其次，所有这些神奇的简单性都建立在我们花费大量工作来编写用于解析和生成源代码的算法上。 实现更高级的功能将意味着转向成熟的IDE的开发-这对我们来说是一项雄心勃勃的任务。 </li></ul><br><p> 我们决定依靠另一个巨头来克服这些限制，并基于IntelliJ IDEA构建了Studio。 现在，您既可以将Studio安装为独立应用程序（IntelliJ IDEA捆绑包），也可以安装为IDEA的插件。 </p><br><p><img src="https://habrastorage.org/webt/bh/qk/kg/bhqkkgmeebyr6fjyecadq1ln_cm.png"></p><br><p> 这给我们带来了新的机会： </p><br><ul><li> 支持其他JVM语言（尤其是Kotlin） </li><li> 出色的热部署 </li><li> 直观的项目范围导航 </li><li> 更智能的提示和代码生成器 </li></ul><br><p>当前，我们正在积极开发Studio的新版本-我们从旧版本转移功能，并使用IntelliJ平台的功能添加新功能。 在不久的将来-将CUBA特定的编辑器转换为IntelliJ组件，并改善在项目代码中的导航。 </p><br><h2 id="obnovlenie-tehnologicheskogo-steka"> 技术堆栈更新 </h2><br><p> 按照传统，CUBA核心技术栈已更新为新版本：Java 8/11，Vaadin 8，Spring 5。 </p><br><p> 默认情况下，新项目使用Java 8，但是您可以通过将以下代码添加到build.gradle文件中来指定Java版本： </p><br><pre><code class="plaintext hljs">subprojects { sourceCompatibility = JavaVersion.VERSION_11 targetCompatibility = JavaVersion.VERSION_11 }</code> </pre> <br><p> 一个特别大的问题是对Vaadin 8的升级，其中数据绑定API发生了很大变化。 幸运的是，CUBA使开发人员免受Vaadin的内部组件的影响，并将其包装在自己的API中。  CUBA团队在不更改CUBA API的情况下完成了内部组件的更新工作。 这意味着完全保留了兼容性，并且可以在将项目迁移到CUBA 7之后立即利用Vaadin 8的所有新功能。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更改列表中</a>提供了更新的依赖关系的完整<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">列表</a> 。 </p><br><h2 id="novyy-api-ekranov"> 新屏幕API </h2><br><p> 由于CUBA从未在Web客户端模块中正式发布过屏幕API，所以本节可能称为“第一屏幕API”。 这是历史上发生的，包括由于在初始阶段出现了一些假设： </p><br><ul><li> 面向声明的方法-可以声明方式描述的所有内容都必须在屏幕描述符中声明，而不是在控制器代码中声明。 </li><li> 标准屏幕（浏览器和编辑器）提供了某些常规功能，因此无需更改它。 </li></ul><br><p><img src="https://habrastorage.org/webt/vd/ym/le/vdymlejgwnh3eco6adm3ly5smmi.png"></p><br><p> 当第一千名成员加入我们的社区时，我们意识到“标准” CRUD屏幕上有多少不同的要求。 所有这些要求都远远超出了最初的功能。 但是，很长一段时间以来，由于在初始阶段提出了另一种架构原则：开放继承，我们就可以在不更改API的情况下满足实现非典型屏幕行为的要求。 实际上，Open Inheritance意味着您可以重写主类的任何公共或受保护的方法，以根据需要自定义其行为。 这看似神奇的灵丹妙药，但实际上，即使在短期内，您也不能依靠它。 如果重写的方法被重命名，删除或在框架的未来版本中根本不使用怎么办？ </p><br><p> 因此，为了响应社区不断增长的需求，我们决定引入新的屏幕API。 该API提供了清晰的（没有任何隐藏的魔术），灵活且易于使用的扩展点，这些扩展点保证不会长时间更改。 </p><br><h3 id="deklaraciya-ekranov"> 屏幕声明 </h3><br><p> 在CUBA 7中，声明屏幕非常简单： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@UiController</span></span>(<span class="hljs-string"><span class="hljs-string">"new-screen"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// screen id public class NewScreen extends Screen { }</span></span></code> </pre> <br><p> 上面的示例显示屏幕标识符直接在控制器类声明的上方明确定义。 换句话说，屏幕ID和控制器类现在以独特的方式相互匹配。 因此，我们有一个好消息：现在您可以直接通过控制器类型安全地访问屏幕： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ScreenBuilders screenBuilders; <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBeforeClose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BeforeCloseEvent event)</span></span></span><span class="hljs-function"> </span></span>{ screenBuilders.screen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .withScreenClass(SomeConfirmationScreen.class) .build() .show(); }</code> </pre> <br><p> 屏幕描述符成为屏幕的可选部分。 可以通过编程方式创建UI或将其声明为xml屏幕描述符，该描述符由控制器类上的<code>@UiDescriptor</code>批注定义。 这使控制器和标记更易于阅读和理解-这种方法与Android开发中使用的方法非常相似。 </p><br><p> 以前，还需要在web-screens.xml文件中注册屏幕句柄并为其分配标识符。 在CUBA 7中，出于兼容性目的而保存了该文件，但是创建屏幕的新方法不需要进行此类注册。 </p><br><h3 id="zhiznennyy-cikl-ekrana"> 屏幕生命周期 </h3><br><p> 新的API引入了简单且不言自明的屏幕生命周期事件： </p><br><ul><li> 初始化 </li><li> 后初始化 </li><li> 放映前 </li><li> 放映后 </li><li> 收盘前 </li><li> 收盘后 </li></ul><br><p> 您可以按以下方式订阅CUBA 7中的所有事件： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@UiController</span></span>(<span class="hljs-string"><span class="hljs-string">"new-screen"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewScreen</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InitEvent event)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBeforeShow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BeforeShowEvent event)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br><p> 与旧方法相比，新API显示出我们不会重叠在初始化时隐式调用的钩子方法，而是显式定义用于处理特定的特定屏幕生命周期事件的逻辑。 </p><br><h3 id="obrabotka-sobytiy-i-funkcionalnye-delegaty"> 事件处理和功能代表 </h3><br><p> 在上一节中，我们学习了如何订阅生命周期事件，但是其他组件又如何呢？ 像在6.x版本中一样，使用init（）方法初始化屏幕时，是否仍需要将所有必需的侦听器倒入同一堆中？ 新的API非常一致，因此您可以按照与屏幕生命事件相同的方式订阅其他事件。 </p><br><p> 考虑一个具有两个UI元素的简单示例：一个按钮和一个用于显示某种货币金额的字段；  XML描述符将如下所示： </p><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">window</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.haulmont.com/cuba/screen/window.xsd"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">caption</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"msg://caption"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">messagesPack</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.company.demo.web"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hbox</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">spacing</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">currencyField</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"currencyField"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">currency</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">currencyLabelPosition</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"LEFT"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"calcPriceBtn"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">caption</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Calculate Price"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hbox</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">window</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 当您单击按钮时，我们从后端调用服务，该服务返回一个数字，我们将其写入金额字段。 该字段应根据价格值更改样式。 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@UiController</span></span>(<span class="hljs-string"><span class="hljs-string">"demo_MyFirstScreen"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@UiDescriptor</span></span>(<span class="hljs-string"><span class="hljs-string">"my-first-screen.xml"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFirstScreen</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PricingService pricingService; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CurrencyField&lt;BigDecimal&gt; currencyField; <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span>(<span class="hljs-string"><span class="hljs-string">"calcPriceBtn"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCalcPriceBtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Button.ClickEvent event)</span></span></span><span class="hljs-function"> </span></span>{ currencyField.setValue(pricingService.calculatePrice()); } <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span>(<span class="hljs-string"><span class="hljs-string">"currencyField"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPriceChange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HasValue.ValueChangeEvent&lt;BigDecimal&gt; event)</span></span></span><span class="hljs-function"> </span></span>{ currencyField.setStyleName(getStyleNameByPrice(event.getValue())); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStyleNameByPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal price)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p> 在上面的示例中，我们看到两个事件处理程序：一个事件处理程序在按下按钮时调用，另一个事件处理程序在货币字段更改其值时启动-一切都很简单。 </p><br><p> 现在假设我们需要检查价格并确保其价值为正。 这可以“先行”完成-在屏幕初始化期间添加验证器： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@UiController</span></span>(<span class="hljs-string"><span class="hljs-string">"demo_MyFirstScreen"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@UiDescriptor</span></span>(<span class="hljs-string"><span class="hljs-string">"my-first-screen.xml"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFirstScreen</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CurrencyField&lt;BigDecimal&gt; currencyField; <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InitEvent event)</span></span></span><span class="hljs-function"> </span></span>{ currencyField.addValidator(value -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.compareTo(BigDecimal.ZERO) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValidationException(<span class="hljs-string"><span class="hljs-string">"Price should be greater than zero"</span></span>); }); } }</code> </pre> <br><p> 在实际的应用程序中，一段时间后，初始化方法将是一堆混乱的初始化器，验证器，侦听器等。 为了解决此问题，CUBA具有有用的<code>@Install</code>注释。 让我们看看它对我们的案例有何帮助： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@UiController</span></span>(<span class="hljs-string"><span class="hljs-string">"demo_MyFirstScreen"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@UiDescriptor</span></span>(<span class="hljs-string"><span class="hljs-string">"my-first-screen.xml"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFirstScreen</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CurrencyField&lt;BigDecimal&gt; currencyField; <span class="hljs-meta"><span class="hljs-meta">@Install</span></span>(to = <span class="hljs-string"><span class="hljs-string">"currencyField"</span></span>, subject = <span class="hljs-string"><span class="hljs-string">"validator"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">currencyFieldValidator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.compareTo(BigDecimal.ZERO) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValidationException(<span class="hljs-string"><span class="hljs-string">"Price should be greater than zero"</span></span>); } }</code> </pre> <br><p> 实际上，我们将货币字段验证逻辑委托给屏幕中的currencyFieldValidator方法。 乍一看似乎有些复杂，但是开发人员出乎意料的是很快就习惯了这种添加功能的方法，并立即开始使用它。 </p><br><h3 id="postroiteli-ekranov-notifikacii-dialogi"> 屏幕构建器，通知，对话框 </h3><br><p><img src="https://habrastorage.org/webt/mo/ni/n-/monin-pixoctyntukkkflsdgvc4.png"></p><br><p>  CUBA 7具有一组有用的组件以及一个便捷的API： </p><br><ul><li>  <strong>ScreenBuilders</strong>结合了流畅的工厂，以创建用于查看和编辑实体的标准屏幕以及自定义屏幕。 以下示例显示了如何从另一个屏幕打开一个屏幕。 请注意，build（）方法无需返回强制转换即可立即返回所需类型的屏幕： <br><pre> <code class="java hljs">CurrencyConversions currencyConversions = screenBuilders.screen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .withScreenClass(CurrencyConversions.class) .withLaunchMode(OpenMode.DIALOG) .build(); currencyConversions.setBaseCurrency(Currency.EUR); currencyConversions.show();</code> </pre> </li><li> 与<em>ScreenBuilders API相比</em> ， <strong>Screens</strong>组件为创建和显示屏幕提供了较低的抽象层次。 如果您突然需要在一个周期中浏览所有这些屏幕，它还提供对CUBA应用程序中所有打开的屏幕（ <em>Screens＃getOpenedScreens</em> ）的信息的访问。 </li><li>  <strong>Notifications</strong>和<strong>Dialogs组件</strong>提供了一个方便且字面意义上的自我文档化API。 以下是创建和显示对话框和通知的示例： <br><pre> <code class="java hljs">dialogs.createOptionDialog() .withCaption(<span class="hljs-string"><span class="hljs-string">"My first dialog"</span></span>) .withMessage(<span class="hljs-string"><span class="hljs-string">"Would you like to thank CUBA team?"</span></span>) .withActions( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DialogAction(DialogAction.Type.YES).withHandler(e -&gt; notifications.create() .withCaption(<span class="hljs-string"><span class="hljs-string">"Thank you!"</span></span>) .withDescription(<span class="hljs-string"><span class="hljs-string">"We appreciate all community members"</span></span>) .withPosition(Notifications.Position.MIDDLE_CENTER) .withHideDelayMs(<span class="hljs-number"><span class="hljs-number">3000</span></span>) .show()), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DialogAction(DialogAction.Type.CANCEL) ) .show();</code> </pre> </li></ul><br><h3 id="privyazka-dannyh"> 资料绑定 </h3><br><p>  CUBA不仅使用先进的可视化开发工具和强大的代码生成系统，还为后台部门提供了极其快速的用户界面开发，而且还提供了一系列现成的丰富组件。 这些组件只需要知道它们正在使用什么数据，其余的将自动完成。 例如，下拉列表，日历，具有内置CRUD操作的表等。 </p><br><p> 在版本7之前，数据绑定是通过所谓的数据源进行的-数据对象包装了一个或多个实体，以便它们对组件进行反应性绑定。 这种方法效果很好，但是就实现而言，这是一个整体。 整体架构通常在配置时会遇到问题，因此在CUBA 7中，这个巨大的鹅卵石被分为三个部分来处理数据： </p><br><ul><li> 数据加载器是数据容器的数据提供者。 加载器不存储数据，它只是将所有必要的查询参数传递给数据仓库，并将结果数据放入数据容器中。 </li><li> 数据容器保存加载的数据（一个或几个实体）并将其提供给数据组件：这些实体中的所有更改都将转移到相应的组件中，反之亦然，组件中的所有更改都将导致数据容器中实体的相应更改。 </li><li>  Datacontext（数据上下文）是一个跟踪更改并存储所有更改的实体的类。 只要受监视的实体的属性发生变化，它们就会被标记为脏实体，并且当调用DataContext的commit（）方法时，DataContext会将脏实例保存在中间件上。 </li></ul><br><p> 因此，在处理数据方面具有灵活性。 一个人工的例子：加载器可以从RDBMS中选择UI中的数据，上下文可以将更改保存到REST服务。 </p><br><p> 在CUBA 6.x中，您将需要为此编写自己的数据源，该数据源可以与RDBMS和REST一起使用。 在CUBA 7中，您可以使用可以与数据库一起使用的标准加载器，并仅编写其上下文实现以用于REST。 </p><br><p> 可以在屏幕描述符中声明用于处理数据的组件，也可以使用专门的工厂DataComponents以编程方式创建它们。 </p><br><h3 id="prochee"> 其他 </h3><br><p>  Uff ...描述了新的屏幕API的最重要部分，因此让我们简要列出Web客户端级别的其他重要功能： </p><br><ul><li>  <strong>URL历史记录和导航</strong> 。 此功能解决了一个非常常见的SPA问题-Web浏览器中后退按钮的行为并不总是正确的。 现在，它提供了一种将路由分配给应用程序屏幕的简便方法，并允许API在URL中显示屏幕的当前状态。 </li><li>  <strong>用Form代替FieldGroup</strong> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FieldGroup</a>是用于显示和更改一个实体的字段的组件。 它在运行时显示字段的UI。 换句话说，如果实体具有Date字段，它将显示为<em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DateField</a></em> 。 但是，如果要以编程方式使用此字段，则需要将其输入到屏幕控制器中，然后手动将其<em>强制</em>转换为正确的类型（ <em>在我们的示例中为DateField</em> ）。 如果稍后我们将字段的类型更改为其他类型，则我们的应用程序将在运行时崩溃。 表单通过显式声明字段类型来解决此问题。 有关该组件的更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 </li><li>  <strong>第三方JavaScript组件的集成已</strong>大大简化；请阅读有关在CUBA应用程序中嵌入自定义JavaScript组件的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> 。 </li><li>  <strong>HTML / CSS</strong>属性现在可以直接从xml屏幕描述符中轻松定义，也可以通过编程设置。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>可以找到更多信息。 </li></ul><br><h2 id="novye-vozmozhnosti-bekend-modulya"> 后端模块的新功能 </h2><br><p> 上一节关于新的屏幕API的内容比我预期的要多，因此在本节中，我将做简短介绍。 </p><br><h3 id="sobytie-entity-changed"> 实体变更事件 </h3><br><p>  Entity Changed事件是Spring应用程序中的一个事件，当实体进入数据存储，被物理放置且距提交仅一步之遥时就会触发该事件。 处理此事件时，您可以配置其他检查（例如，在确认订单之前检查仓库中的货物可用性）并更改数据（例如，重新计算结果），使其在其他事务（当然，如果您具有级别）可见读取已提交的隔离）。 此事件也可能是通过引发异常来中止事务的最后机会，这在某些棘手的情况下可能很有用。 </p><br><p> 还有一种在提交后立即处理Entity Changed事件的方法。 </p><br><p> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档的本章中</a>查看示例。 </p><br><h3 id="tranzakcionnyy-menedzher-dannyh"> 交易数据管理器 </h3><br><p> 开发应用程序时，我们通常使用分离的实体-不在任何事务上下文中的实体。 但是，并非总是可以使用分离的实体，尤其是当您需要完全遵守ACID要求时-可以使用事务数据管理器时就是这种情况。 他与常规经理非常相似，但在以下方面有所不同： </p><br><ul><li> 他可以加入现有交易（在此交易的上下文中称为）或创建自己的交易。 </li><li> 它没有提交方法，但是有一个保存方法不会立即提交，而是等待当前事务提交。 </li></ul><br><p> 这是其用法的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个例子</a> 。 </p><br><h3 id="obratnye-vyzovy-jpa">  JPA回调 </h3><br><p> 最后，CUBA 7支持JPA回调。 为了不重复使用这些回调的已知材料，我只在此处保留一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a> 。 在此材料中，回调的主题已完全公开。 </p><br><h2 id="kak-naschet-sovmestimosti"> 兼容性如何？ </h2><br><p><img src="https://habrastorage.org/webt/tk/fu/lb/tkfulbguaccnmhsisnhgsgepteg.png"></p><br><p> 对于任何主要发行版，这都是一个公平的问题，尤其是在存在许多重要更改时！ 我们开发了所有这些向后兼容的新功能和API： </p><br><ul><li>  CUBA 7支持旧的API，并通过幕后的新API实现：) </li><li> 我们还提供了用于通过旧API进行数据绑定的适配器。 这些适配器将完全适合根据旧方案创建的屏幕。 </li></ul><br><p> 好消息是，从版本6到版本7的迁移过程应该非常简单。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 在结束技术审查时，我要指出，还有其他重要的创新，尤其是在许可领域： </p><br><ul><li>  Studio的10个实体限制现已删除 </li><li>  “报告”，“ BPM”，“图表和地图”以及“全文本搜索”的附件现已免费提供并且是开源的。 </li><li>  Studio的商业版本在实体，屏幕，菜单和其他平台元素的可视化设计人员的帮助下增加了便利性，而免费版本则侧重于处理代码。 </li><li> 请注意，对于6.x版和更早版本，Platform和Studio的许可条件保持不变！ </li></ul><br><p> 最后，让我再次感谢社区的支持和反馈。 希望您喜欢版本7！ 传统上，完整信息可在官方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">变更日志中获得</a> 。 <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447538/">https://habr.com/ru/post/zh-CN447538/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447528/index.html">谁负责质量？</a></li>
<li><a href="../zh-CN447530/index.html">OceanLotus：macOS的Malvari更新</a></li>
<li><a href="../zh-CN447532/index.html">Docker中的Splunk Universal Forwarder作为系统日志收集器</a></li>
<li><a href="../zh-CN447534/index.html">宇航员亚历山大·拉维金（Aleksandr Laveykin）讲述了最佳太空电影，20克重力和软着陆</a></li>
<li><a href="../zh-CN447536/index.html">实施IdM。 准备由客户实施</a></li>
<li><a href="../zh-CN447540/index.html">RHEL 8 Beta研讨会：构建实时Web应用程序</a></li>
<li><a href="../zh-CN447542/index.html">哈萨克斯坦公司股价的VaR和ConVaR估计</a></li>
<li><a href="../zh-CN447546/index.html">Bowers＆Wilkins PX。 迟来的新评论</a></li>
<li><a href="../zh-CN447548/index.html">在中小企业中引入VDI的合理性如何？</a></li>
<li><a href="../zh-CN447552/index.html">如何优化在线商店中的目录部分：分步说明</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>