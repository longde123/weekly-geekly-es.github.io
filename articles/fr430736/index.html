<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚èπÔ∏è ü§∑üèª üîù D√©veloppez votre navigateur √† partir de z√©ro. Premi√®re partie: HTML üõ´ üë®‚Äçüë®‚Äçüëß‚Äçüë¶ ‚òùüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! 


 Nous continuons la s√©rie d'articles sur le d√©veloppement du moteur de navigation. 


 Dans cet article, je vais vous expliquer com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©veloppez votre navigateur √† partir de z√©ro. Premi√®re partie: HTML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430736/"><p><img src="https://habrastorage.org/webt/qu/3l/02/qu3l02mug029as5w74y2zznn0yc.jpeg"></p><br><p>  Bonjour √† tous! </p><br><p>  Nous continuons la s√©rie d'articles sur le d√©veloppement du moteur de navigation. </p><br><p>  Dans cet article, je vais vous expliquer comment cr√©er l'analyseur HTML le plus rapide avec DOM.  Nous allons examiner la sp√©cification HTML et pourquoi elle est mauvaise en termes de performances et de consommation de ressources lors de l'analyse HTML. </p><br><p>  Avec ce sujet, j'ai rendu compte du pass√© HighLoad ++.  Tout le monde ne peut pas assister √† la conf√©rence, et l'article contient plus de d√©tails. </p><br><p>  Je suppose que le lecteur a des connaissances de base en HTML: balises, n≈ìuds, √©l√©ments, espace de noms. </p><a name="habracut"></a><br><h2 id="specifikaciya-html">  Sp√©cification HTML </h2><br><p>  Avant de commencer √† aborder la mise en ≈ìuvre de l'analyseur HTML, vous devez comprendre quelles sp√©cifications HTML croire. </p><br><p>  Il existe deux sp√©cifications HTML: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WHATWG</a> <br><ul><li> Apple, Mozilla, Google, Microsoft </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">W3c</a> <br><ul><li>  Grande liste d'entreprises </li></ul></li></ol><br><p> Naturellement, le choix s'est port√© sur les leaders de l'industrie - <strong><code>WHATWG</code></strong> .  Niveau de vie, les grandes entreprises ont chacune leur propre navigateur / moteur de navigateur. </p><br><p>  MISE √Ä JOUR: Malheureusement, les liens donn√©s vers les sp√©cifications ne s'ouvrent pas depuis la Russie.  Apparemment, "l'√©cho de la guerre" avec les t√©l√©grammes. </p><br><h2 id="process-parsinga-html">  Processus d'analyse HTML </h2><br><p>  Le processus de construction d'une arborescence HTML peut √™tre divis√© en quatre parties: </p><br><ol><li>  D√©codeur </li><li>  Pr√©traitement </li><li>  Tokenizer </li><li>  Construire un arbre </li></ol><br><p>  Nous consid√©rons chaque √©tape s√©par√©ment. </p><br><h3 id="dekoder">  D√©codeur </h3><br><p>  Le tokenizer accepte les caract√®res Unicode (points de code) en entr√©e.  Par cons√©quent, nous devons convertir le flux d'octets actuel en caract√®res Unicode.  Pour ce faire, utilisez la sp√©cification d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">encodage</a> . </p><br><p>  Si nous avons du HTML avec un encodage inconnu (pas d'en-t√™te HTTP), nous devons le d√©terminer avant le d√©but du d√©codage.  Pour ce faire, nous utiliserons l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">algorithme de reniflage d'encodage</a> . </p><br><p>  Si tr√®s bri√®vement, l'essence de l'algorithme est que nous attendons <strong><code>500</code></strong> ou les <strong><code>1024 </code></strong> premiers <strong><code>1024 </code></strong> du flux d'octets et <strong><code>500</code></strong> le <strong><code>500</code></strong> - <strong><code>500</code></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un</a> algorithme de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flux d'octets pour d√©terminer son encodage</a> qui essaie de trouver la <strong><code>&lt;meta&gt;</code></strong> avec les attributs <strong><code>http-equiv</code></strong> , <strong><code>content</code></strong> ou <strong><code>charset</code></strong> et essaie comprendre le codage indiqu√© par le d√©veloppeur HTML. </p><br><p>  La sp√©cification d' <strong><code>Encoding</code></strong> stipule l'ensemble minimal d'encodages pris en charge par le moteur de navigateur (21 au total): UTF-8, ISO-8859-2, ISO-8859-7, ISO-8859-8, windows-874, windows-1250, windows-1251, windows -1252, windows-1254, windows-1255, windows-1256, windows-1257, windows-1258, gb18030, Big5, ISO-2022-JP, Shift_JIS, EUC-KR, UTF-16BE, UTF-16LE et x-user -d√©fini. </p><br><h3 id="predvaritelnaya-obrabotka">  Pr√©traitement </h3><br><p>  Apr√®s avoir d√©cod√© les octets en caract√®res Unicode, nous devons "nettoyer".  A savoir, remplacer tous les caract√®res de retour chariot ( <strong><code>\r</code></strong> ) suivis d'un caract√®re de saut de ligne ( <strong><code>\n</code></strong> ) par un caract√®re retour chariot ( <strong><code>\r</code></strong> ).  Ensuite, remplacez tous les caract√®res de retour chariot par un caract√®re de nouvelle ligne ( <strong><code>\n</code></strong> ). </p><br><p>  Ainsi d√©crit dans la sp√©cification.  Autrement dit, <strong><code>\r\n</code></strong> =&gt; <strong><code>\r</code></strong> , <strong><code>\r</code></strong> =&gt; <strong><code>\n</code></strong> . </p><br><p>  Mais, en fait, personne ne le fait.  Rendez-le plus facile: </p><br><p>  Si vous obtenez un caract√®re de retour chariot ( <strong><code>\r</code></strong> ), recherchez s'il existe un caract√®re de saut de ligne ( <strong><code>\n</code></strong> ).  Si tel est le cas, nous changeons les deux caract√®res en un caract√®re de nouvelle ligne ( <strong><code>\n</code></strong> ), sinon, nous ne changeons que le premier caract√®re ( <strong><code>\r</code></strong> ) en caract√®res de nouvelle ligne ( <strong><code>\n</code></strong> ). </p><br><p>  Ceci termine le traitement pr√©liminaire des donn√©es.  Oui, il vous suffit de vous d√©barrasser des symboles de retour chariot pour qu'ils ne tombent pas dans le tokenizer.  Le tokenizer ne s'attend pas et ne sait pas quoi faire avec le symbole de retour chariot. </p><br><h3 id="oshibki-parsinga">  Erreurs d'analyse </h3><br><p>  Pour qu'√† l'avenir il n'y ait plus de questions, vous devez imm√©diatement dire ce qu'est une <code> </code> ( <strong><code>parse error</code></strong> ). </p><br><p>  Rien de mal.  Cela semble mena√ßant, mais en fait, ce n'est qu'un avertissement que nous nous attendions √† un, mais nous en avons un autre. </p><br><p>  Une erreur d'analyse n'interrompt pas le traitement des donn√©es ou la construction de l'arborescence.  Il s'agit d'un message qui signale que nous n'avons pas de code HTML valide. </p><br><p>  Une erreur de parsig peut √™tre obtenue pour les paires de substitution, <code>\0</code> , un emplacement de balise incorrect, un <strong><code>&lt;!DOCTYPE&gt;</code></strong> incorrect et toutes sortes d'autres choses. </p><br><p>  Soit dit en passant, certaines erreurs d'analyse entra√Ænent des cons√©quences.  Par exemple, si vous sp√©cifiez "mauvais" <strong><code>&lt;!DOCTYPE&gt;</code></strong> l'arborescence HTML sera marqu√©e comme <strong><code>QUIRKS</code></strong> et la logique de certaines fonctions DOM changera. </p><br><h3 id="tokenizator">  Tokenizer </h3><br><p>  Comme mentionn√© pr√©c√©demment, le tokenizer accepte les caract√®res Unicode en entr√©e.  Il s'agit d'une machine d'√©tat qui a <strong><code>80</code></strong> √©tats.  Dans chaque √©tat, conditions pour les caract√®res Unicode.  Selon le personnage re√ßu, le tokenizer peut: </p><br><ol><li>  Changez votre √©tat </li><li>  G√©n√©rer un jeton et changer d'√©tat </li><li>  Ne faites rien, attendez le prochain personnage </li></ol><br><p>  Le tokenizer cr√©e six types de jetons: DOCTYPE, balise de d√©but, balise de fin, commentaire, caract√®re, fin de fichier.  Qui entrent dans la phase de construction d'un arbre. </p><br><p>  Il est √† noter que le tokenizer ne conna√Æt pas tous ses √©tats, mais o√π environ 40% (pris au plafond, par exemple).  "Pourquoi le reste?"  - demandez-vous.  Environ les 60% restants connaissent le stade de construction d'un arbre. </p><br><p>  Ceci est effectu√© afin d'analyser correctement les balises telles que <strong><code>&lt;textarea&gt;</code></strong> , <strong><code>&lt;style&gt;</code></strong> , <strong><code>&lt;script&gt;</code></strong> , <strong><code>&lt;title&gt;</code></strong> et ainsi de suite.  Autrement dit, g√©n√©ralement les balises dans lesquelles nous n'attendons pas d'autres balises, mais seulement en nous fermant. </p><br><p>  Par exemple, la <strong><code>&lt;title&gt;</code></strong> ne peut pas contenir d'autres balises.  Toutes les balises de <strong><code>&lt;title&gt;</code></strong> seront per√ßues comme du texte jusqu'√† ce qu'elles rencontrent une balise de fermeture <strong><code>&lt;/title&gt;</code></strong> . </p><br><p>  Pourquoi est-ce fait?  Apr√®s tout, vous pourriez simplement dire au tokenizer que si nous rencontrons la <strong><code>&lt;title&gt;</code></strong> nous suivons le "chemin dont nous avons besoin".  Et ce serait vrai sinon des espaces de noms!  Oui, l'espace de noms affecte le comportement de l'√©tape de cr√©ation d'arborescence, qui √† son tour modifie le comportement du tokenizer. </p><br><p>  Par exemple, consid√©rons le comportement de la <strong><code>&lt;title&gt;</code></strong> dans les espaces de noms HTML et SVG: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Le r√©sultat de la construction d'un arbre: </p><br><pre> <code class="plaintext hljs">&lt;title&gt; "&lt;span&gt;&lt;/span&gt;"</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Le r√©sultat de la construction d'un arbre: </p><br><pre> <code class="plaintext hljs">&lt;svg&gt; &lt;title&gt; &lt;span&gt; ""</code> </pre> <br><p>  Nous voyons que dans le premier cas (espace de noms HTML) la <strong><code>&lt;span&gt;</code></strong> est du texte, l'√©l√©ment <strong><code>span</code></strong> n'a pas √©t√© cr√©√©.  Dans le deuxi√®me cas (espace de noms SVG), un √©l√©ment a √©t√© cr√©√© sur la base de la <strong><code>&lt;span&gt;</code></strong> .  Autrement dit, selon l'espace de noms, les balises se comportent diff√©remment. </p><br><p>  Mais ce n'est pas tout.  Le g√¢teau de cette "c√©l√©bration de la vie" est le fait que le tokenizer lui-m√™me doit savoir dans quel espace de noms se situe le stade de construction de l'arbre.  Et cela est n√©cessaire uniquement pour g√©rer correctement <strong><code>CDATA</code></strong> . </p><br><p>  Prenons deux exemples avec <strong><code>CDATA</code></strong> , deux espaces de noms: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Le r√©sultat de la construction d'un arbre: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;!--[CDATA[  ]]--&gt;</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Le r√©sultat de la construction d'un arbre: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;svg&gt; "  "</code> </pre> <br><p>  Dans le premier cas (espace de noms HTML), le tokenizer a pris <strong><code>CDATA</code></strong> pour commentaire.  Dans le deuxi√®me cas, le tokenizer a d√©mont√© la structure <strong><code>CDATA</code></strong> et a re√ßu des donn√©es de celle-ci.  En g√©n√©ral, la r√®gle est la suivante: si nous rencontrons <strong><code>CDATA</code></strong> pas dans l'espace de noms HTML, alors nous l'analysons, sinon nous le consid√©rons comme un commentaire. </p><br><p>  C'est le lien √©troit entre le tokenizer et la construction de l'arbre.  Le tokenizer doit savoir dans quel espace de noms se trouve actuellement l'√©tape de construction de l'arborescence, et l'√©tape de la construction de l'arborescence peut changer l'√©tat du tokenizer. </p><br><h3 id="tokeny">  Jetons </h3><br><p>  Ci-dessous, nous consid√©rerons les six types de jetons cr√©√©s par le tokenizer.  Il convient de noter que tous les jetons ont pr√©par√© des donn√©es, c'est-√†-dire d√©j√† trait√©es et ¬´pr√™tes √† l'emploi¬ª.  Cela signifie que toutes les r√©f√©rences de caract√®res nomm√©es, comme <strong><code>&amp;copy</code></strong> , seront converties en caract√®res unicode. </p><br><h3 id="doctype-token">  Jeton DOCTYPE </h3><br><p>  Le jeton DOCTYPE a sa propre structure qui n'est pas similaire aux autres balises.  Le jeton contient: </p><br><ol><li>  Pr√©nom </li><li>  Identifiant public </li><li>  Identifiant syst√®me </li></ol><br><p>  En HTML moderne, le seul DOCTYPE valide / valide devrait ressembler √† ceci: </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span></code> </pre> <br><p>  Tous les autres <strong><code>&lt;!DOCTYPE&gt;</code></strong> seront consid√©r√©s comme une erreur d'analyse. </p><br><h3 id="start-tag-token">  Jeton de balise de d√©but </h3><br><p>  La balise d'ouverture peut contenir: </p><br><ol><li>  Nom du tag </li><li>  Attributs </li><li>  Drapeaux </li></ol><br><p>  Par exemple, </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  La balise d'ouverture peut contenir un drapeau √† <strong><code>self-closing</code></strong> .  Cet indicateur n'affecte pas la fermeture de la balise, mais peut provoquer une erreur d'analyse pour les √©l√©ments non <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vides</a> . </p><br><h3 id="end-tag-token">  Jeton de fin de balise </h3><br><p>  Balise de fermeture.  Il a toutes les propri√©t√©s du jeton de la balise d'ouverture, mais a une barre oblique <strong><code>/</code></strong> devant le nom de la balise. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  La balise de fermeture peut contenir un drapeau √† <strong><code>self-closing</code></strong> qui provoquera une erreur d'analyse.  De plus, l'erreur d'analyse sera caus√©e par les attributs de la balise de fermeture.  Ils seront correctement analys√©s, mais jet√©s au stade de la construction des arbres. </p><br><h3 id="comment-token">  Jeton de commentaire </h3><br><p>  Le jeton de commentaire contient l'int√©gralit√© du texte du commentaire.  Autrement dit, il est enti√®rement copi√© du flux vers le jeton. </p><br><p>  Exemple </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  --&gt;</span></span></code> </pre> <br><h3 id="character-token">  Jeton de personnage </h3><br><p>  Peut-√™tre le jeton le plus int√©ressant.  Symbole de jeton Unicode.  Peut contenir un (un seul) caract√®re. </p><br><p>  Un jeton sera cr√©√© pour chaque caract√®re en HTML et envoy√© au stade de la construction de l'arborescence.  C'est tr√®s cher. <br>  Voyons comment cela fonctionne. </p><br><p>  Prenez les donn√©es HTML: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> ! &amp;reg;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Selon vous, combien de jetons seront cr√©√©s pour cet exemple?  R√©ponse: 22. </p><br><p>  Consid√©rez la liste des jetons cr√©√©s: </p><br><pre> <code class="plaintext hljs">Start tag token: &lt;span&gt; Character token:  Character token:  Character token:  Character token:  Character token:  Character token: Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token: ! Character token: Character token: End tag token: &lt;/span&gt; End-of-file token</code> </pre> <br><p>  Pas r√©confortant, non?  Mais, bien s√ªr, de nombreux cr√©ateurs d'analyseurs HTML n'ont en fait qu'un seul jeton lors du traitement.  L'ex√©cuter en cercle et l'√©craser √† chaque fois avec de nouvelles donn√©es. </p><br><p>  Avan√ßons et r√©pondons √† la question: pourquoi est-ce fait?  Pourquoi ne pas prendre ce texte en un seul morceau?  La r√©ponse r√©side dans la phase de construction de l'arbre. </p><br><p>  Un tokenizer est inutile sans l'√©tape de construction d'une arborescence HTML.  C'est au stade de la construction d'un arbre que le texte est coll√© avec diff√©rentes conditions. </p><br><p>  Les conditions sont approximativement les suivantes: </p><br><ol><li>  Si un jeton de caract√®re avec <strong><code>U+0000</code></strong> ( <strong><code>NULL</code></strong> ) arrive, nous provoquons une erreur d'analyse et ignorons le jeton. </li><li>  Si l'un des <strong><code>CHARACTER TABULATION</code></strong> de caract√®res <strong><code>U+0009</code></strong> ( <strong><code>CHARACTER TABULATION</code></strong> ), <strong><code>U+000A</code></strong> ( <strong><code>LINE FEED (LF)</code></strong> ), <strong><code>U+000C</code></strong> ( <strong><code>FORM FEED (FF)</code></strong> <strong><code>U+000C</code></strong> <strong><code>FORM FEED (FF)</code></strong> ) ou <strong><code>U+0020</code></strong> ( <strong><code>SPACE</code></strong> ) est venu, appelez l'algorithme pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">restaurer les √©l√©ments de formatage actifs</a> et ins√©rez le jeton dans l'arbre. </li></ol><br><p>  Le jeton de symbole est ajout√© √† l'arbre selon l'algorithme: </p><br><ol><li>  Si la position d'insertion actuelle n'est pas un n≈ìud de texte, cr√©ez un n≈ìud de texte, ins√©rez-le dans l'arborescence et ajoutez-y les donn√©es du jeton. </li><li>  Sinon, ajoutez des donn√©es du jeton √† un n≈ìud de texte existant. </li></ol><br><p>  Ce comportement cr√©e beaucoup de probl√®mes.  La n√©cessit√© pour chaque symbole de cr√©er un jeton et d'envoyer pour analyse au stade de la construction d'un arbre.  Nous ne connaissons pas la taille du n≈ìud de texte et nous devons soit allouer beaucoup de m√©moire √† l'avance ou faire des realoks.  Tout cela est extr√™mement co√ªteux en m√©moire ou en temps. </p><br><h3 id="end-of-file-token">  Jeton de fin de fichier </h3><br><p>  Jeton simple et clair.  Les donn√©es sont d√©pass√©es - laissez-nous vous informer sur cette √©tape de la construction des arbres. </p><br><h3 id="postroenie-dereva">  Construire un arbre </h3><br><p>  La construction d'arbres est une machine d'√©tat avec <strong><code>23</code></strong> √©tats avec de nombreuses conditions pour les jetons (balises, texte).  Le stade de construction d'un arbre est le plus grand, occupe une partie importante de la sp√©cification et est √©galement capable de provoquer un sommeil l√©thargique et une irritation. </p><br><p>  Tout est arrang√© tr√®s simplement.  Les jetons sont re√ßus √† l'entr√©e et, selon le jeton, l'√©tat de la structure arborescente est commut√©.  En sortie, nous avons un vrai DOM. </p><br><h2 id="problemy">  Des probl√®mes? </h2><br><p>  Les probl√®mes suivants semblent assez √©vidents: </p><br><p>  <strong>Copie caract√®re par caract√®re</strong> </p><br><p>  Chaque √©tat du tokenizer re√ßoit un caract√®re en entr√©e, qu'il copie / convertit si n√©cessaire: noms de balises, attributs, commentaires, symboles. </p><br><p>  C'est un gaspillage de m√©moire et de temps.  Nous sommes oblig√©s de pr√©allouer une quantit√© de m√©moire inconnue pour chaque attribut, nom de balise, commentaire, etc.  Et cela, en cons√©quence, conduit √† des realoks, et des realoks entra√Ænent une perte de temps. </p><br><p>  Et si vous imaginez que HTML contient 1000 balises et que chaque balise a au moins un attribut, alors nous obtenons un analyseur incroyablement lent. </p><br><p>  <strong>Jeton de personnage</strong> </p><br><p>  Le deuxi√®me probl√®me est le jeton de personnage.  Il s'av√®re que nous cr√©ons un jeton pour chaque symbole et le donnons pour construire un arbre.  La construction d'un arbre ne sait pas combien de ces jetons nous aurons et ne peut pas allouer imm√©diatement de la m√©moire pour le nombre de caract√®res requis.  En cons√©quence, ici tout de m√™me realoks + constant v√©rifie la pr√©sence d'un n≈ìud de texte dans l'√©tat actuel de l'arbre. </p><br><p>  <strong>Syst√®me monolithique</strong> </p><br><p>  Le gros probl√®me est la d√©pendance de tout √† tout.  Autrement dit, le tokenizer d√©pend de l'√©tat de construction de l'arborescence, et la construction de l'arbre peut contr√¥ler le tokenizer.  Et tout est √† bl√¢mer pour l'espace de noms (espaces de noms). </p><br><h2 id="kak-budem-reshat-problemy">  Comment allons-nous r√©soudre les probl√®mes? </h2><br><p>  Ensuite, je d√©crirai l'impl√©mentation de l'analyseur HTML dans mon projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lexbor</a> , ainsi que la solution √† tous les probl√®mes exprim√©s. </p><br><h3 id="predvaritelnaya-obrabotka-1">  Pr√©traitement </h3><br><p>  Nous supprimons le traitement pr√©liminaire des donn√©es.  Nous allons entra√Æner le tokenizer √† comprendre le retour chariot ( <strong><code>\r</code></strong> ) comme un espace.  Ainsi, il sera jet√© au stade de la construction d'un arbre o√π nous le d√©couvrirons. </p><br><h3 id="tokeny-1">  Jetons </h3><br><p>  D'un coup de poignet, nous unifions tous les jetons.  Nous aurons un jeton pour tout.  En g√©n√©ral, il n'y aura qu'un seul jeton dans l'ensemble du processus d'analyse. </p><br><p>  Notre jeton unifi√© contiendra les champs suivants: </p><br><ol><li>  Identifiant du tag </li><li>  Commencer </li><li>  Fin </li><li>  Attributs </li><li>  Drapeaux </li></ol><br><h4 id="tag-id">  Identifiant du tag </h4><br><p>  Nous ne travaillerons pas avec la repr√©sentation textuelle du nom de la balise.  Nous traduisons tout en chiffres.  Les chiffres sont faciles √† comparer, plus faciles √† utiliser. </p><br><p>  Nous cr√©ons une table de hachage statique √† partir de toutes les balises connues.  Nous cr√©ons une √©num√©ration √† partir de toutes les balises connues.  Autrement dit, nous devons attribuer de mani√®re rigide un identifiant √† chaque balise.  Par cons√©quent, dans la table de hachage, la cl√© est le nom de la balise et la valeur est √©crite √† partir de l'√©num√©ration. </p><br><p>  Pour un exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_TAG__UNDEF = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_TAG__END_OF_FILE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_TAG__TEXT = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_TAG__DOCUMENT = <span class="hljs-number"><span class="hljs-number">0x0003</span></span>, LXB_TAG__EM_COMMENT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_TAG__EM_DOCTYPE = <span class="hljs-number"><span class="hljs-number">0x0005</span></span>, LXB_TAG_A = <span class="hljs-number"><span class="hljs-number">0x0006</span></span>, LXB_TAG_ABBR = <span class="hljs-number"><span class="hljs-number">0x0007</span></span>, LXB_TAG_ACRONYM = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_TAG_ADDRESS = <span class="hljs-number"><span class="hljs-number">0x0009</span></span>, LXB_TAG_ALTGLYPH = <span class="hljs-number"><span class="hljs-number">0x000a</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Comme vous pouvez le voir dans l'exemple, nous avons cr√©√© des balises pour le jeton <strong>END-OF-FILE</strong> , pour le texte, pour un document.  Tout cela pour plus de commodit√©.  En ouvrant le rideau, je dirai que dans le n≈ìud ( <strong><code>DOM Node Interface</code></strong> ), nous aurons un <strong><code>Tag ID</code></strong> .  Ceci est fait afin de ne pas faire deux comparaisons: sur le type de n≈ìud et sur l'√©l√©ment.  Autrement dit, si nous avons besoin d'un √©l√©ment <strong><code>DIV</code></strong> , nous effectuons une v√©rification dans le n≈ìud: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Best code */</span></span> }</code> </pre> <br><p>  Mais, bien s√ªr, vous pouvez le faire: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == LXB_DOM_NODE_TYPE_ELEMENT &amp;&amp; node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Oh, code */</span></span> }</code> </pre> <br><p>  Deux <strong><code>LXB_TAG__</code></strong> soulignement dans <strong><code>LXB_TAG__</code></strong> sont n√©cessaires pour s√©parer les balises communes de celles du syst√®me.  En d'autres termes, l'utilisateur peut cr√©er une balise avec le nom du <strong><code>text</code></strong> ou la <strong><code>end-of-file</code></strong> et si nous recherchons ensuite par nom de balise, aucune erreur ne se produira.  Toutes les balises syst√®me commencent par un <strong><code>#</code></strong> . </p><br><p>  Mais encore, un n≈ìud peut stocker une repr√©sentation textuelle du nom de la balise.  Pour les n≈ìuds √† 98,99999%, ce param√®tre sera <strong><code>NULL</code></strong> .  Dans certains espaces de noms, nous devons sp√©cifier un pr√©fixe ou un nom de balise avec un registre fixe.  Par exemple, <strong><code>baseProfile</code></strong> dans l'espace de noms SVG. </p><br><p>  La logique du travail est simple.  Si nous avons une balise avec un registre clairement d√©fini, alors: </p><br><ol><li>  Ajoutez-le √† la base g√©n√©rale des balises en minuscules.  Obtenez l'identifiant du tag. </li><li>  Ajoutez l'identifiant de balise et le nom de balise d'origine dans la repr√©sentation textuelle au n≈ìud. </li></ol><br><p>  <strong>Balises personnalis√©es</strong> </p><br><p>  Un d√©veloppeur peut cr√©er n'importe quelle balise en HTML.  Comme nous n'avons que les balises que nous connaissons dans une table de hachage statique et que l'utilisateur peut en cr√©er, nous avons besoin d'une table de hachage dynamique. </p><br><p>  Tout a l'air tr√®s simple.  Lorsque la balise nous parviendra, nous verrons si elle se trouve dans la table de hachage statique.  S'il n'y a pas de balise, regardons la dynamique, s'il n'y en a pas, augmentons le compteur d'identifiants de un et ajoutons la balise √† la table dynamique. </p><br><p>  Tout ce qui est d√©crit se produit au stade du tokenizer.  √Ä l'int√©rieur du tokenizer et apr√®s toutes les comparaisons, passez par <strong><code>Tag ID</code></strong> (√† de rares exceptions pr√®s). </p><br><h4 id="begin-and-end">  D√©but et fin </h4><br><p>  Maintenant, dans le tokenizer, nous n'aurons pas de traitement de donn√©es.  Nous ne copierons et ne convertirons rien.  Nous prenons simplement des pointeurs vers le d√©but et la fin des donn√©es. </p><br><p>  Tous les traitements de donn√©es, tels que les liens symboliques, auront lieu au stade de la construction des arbres. <br>  Ainsi, nous conna√Ætrons la taille des donn√©es pour l'allocation ult√©rieure de m√©moire. </p><br><h4 id="attributes">  Attributs </h4><br><p>  Ici, tout est aussi simple.  Nous ne copions rien, mais enregistrons simplement des pointeurs au d√©but / √† la fin du nom et des valeurs d'attribut.  Toutes les transformations se produisent au moment de la cr√©ation de l'arborescence. </p><br><h4 id="flags">  Drapeaux </h4><br><p>  √âtant donn√© que nous avons des jetons unifi√©s, nous devons en quelque sorte informer l'arborescence du type de jeton.  Pour ce faire, utilisez le champ bitmap Flags. </p><br><p>  Le champ peut contenir les valeurs suivantes: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_HTML_TOKEN_TYPE_OPEN = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE_SELF = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_HTML_TOKEN_TYPE_TEXT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_HTML_TOKEN_TYPE_DATA = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_HTML_TOKEN_TYPE_RCDATA = <span class="hljs-number"><span class="hljs-number">0x0010</span></span>, LXB_HTML_TOKEN_TYPE_CDATA = <span class="hljs-number"><span class="hljs-number">0x0020</span></span>, LXB_HTML_TOKEN_TYPE_NULL = <span class="hljs-number"><span class="hljs-number">0x0040</span></span>, LXB_HTML_TOKEN_TYPE_FORCE_QUIRKS = <span class="hljs-number"><span class="hljs-number">0x0080</span></span>, LXB_HTML_TOKEN_TYPE_DONE = <span class="hljs-number"><span class="hljs-number">0x0100</span></span> };</code> </pre> <br><p>  En plus du type de jeton qui s'ouvre ou se ferme, il existe des valeurs pour le convertisseur de donn√©es.  Seul le tokenizer sait comment convertir correctement les donn√©es.  En cons√©quence, le tokenizer marque dans le token comment les donn√©es doivent √™tre trait√©es. </p><br><h4 id="character-token-1">  Jeton de personnage </h4><br><p>  D'apr√®s ce qui a √©t√© d√©crit pr√©c√©demment, nous pouvons conclure que le jeton de symbole a disparu de nous.  Oui, nous avons maintenant un nouveau type de jeton: <strong><code>LXB_HTML_TOKEN_TYPE_TEXT</code></strong> .  Maintenant, nous cr√©ons un jeton pour le texte entier entre les balises, indiquant comment il devrait √™tre trait√© √† l'avenir. </p><br><p>  Pour cette raison, nous devrons changer les conditions de construction de l'arbre.  Nous devons le former √† travailler non pas avec des jetons symboliques, mais avec des jetons de texte: convertir, supprimer des caract√®res inutiles, sauter des espaces, etc. </p><br><p>  Mais, il n'y a rien de compliqu√©.  Au stade de la construction d'un arbre, les changements seront minimes.  Mais le tokenizer ne correspond plus du tout √† la sp√©cification du mot.  Mais on n'a pas besoin de lui, c'est normal.  Notre t√¢che consiste √† obtenir une arborescence HTML / DOM enti√®rement conforme aux sp√©cifications. </p><br><h3 id="stadii-tokenizatora">  √âtapes de Tokenizer </h3><br><p>  Pour assurer un traitement rapide des donn√©es dans le tokenizer, nous ajouterons notre it√©rateur √† chaque √©tape.  Selon le cahier des charges, chaque √©tape accepte un symbole pour nous et, selon le symbole arriv√©, prend des d√©cisions.  Mais, la v√©rit√© est que c'est tr√®s cher. </p><br><p>  Par exemple, pour passer de l'√©tape <strong><code>ATTRIBUTE_NAME</code></strong> √† l'√©tape <strong><code>ATTRIBUTE_VALUE</code></strong> nous devons trouver un espace blanc dans le nom de l'attribut, qui indiquera sa fin.  Selon la sp√©cification, nous devons alimenter par caract√®re √† l'√©tape <strong><code>ATTRIBUTE_NAME</code></strong> jusqu'√† ce qu'un caract√®re d'espace <strong><code>ATTRIBUTE_NAME</code></strong> , et cette √©tape ne passe pas √† une autre.  C'est tr√®s cher, g√©n√©ralement il est impl√©ment√© via un appel de fonction pour chaque caract√®re ou un rappel comme "tkz-&gt; next_code_point ()". </p><br><p>  Nous ajoutons une boucle √† l'√©tape <strong><code>ATTRIBUTE_NAME</code></strong> et passons la totalit√© du tampon entrant.  Dans la boucle, nous recherchons les symboles dont nous avons besoin pour changer et continuer √† travailler sur la prochaine √©tape.  Ici, nous obtenons beaucoup de gains, m√™me des optimisations de compilateur. </p><br><p>  Mais!  Le pire, c'est que nous avons ainsi rompu le support des morceaux (morceaux) hors de la bo√Æte.  Gr√¢ce au traitement caract√®re par symbole √† chaque √©tape du g√©n√©rateur de jetons, nous avons pris en charge les morceaux, et nous l'avons maintenant cass√©. </p><br><p>  Comment y rem√©dier?  Comment impl√©menter le support des morceaux?!  C'est simple, nous introduisons le concept de tampons entrants (Tampon entrant). </p><br><h3 id="incoming-buffer">  Tampon entrant </h3><br><p>  Souvent, HTML analyse en morceaux.  Par exemple, si nous recevons des donn√©es sur le r√©seau.  Afin de ne pas rester inactif en attendant les donn√©es restantes, nous pouvons envoyer des donn√©es d√©j√† re√ßues pour traitement / analyse.  Naturellement, les donn√©es peuvent √™tre d√©chir√©es n'importe o√π.  Par exemple, nous avons deux tampons: </p><br><p>  <strong>D'abord</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">clas</span></span></span></span></code> </pre> <br><p>  <strong>Deuxi√®me</strong> </p><br><pre> <code class="html hljs xml">s="oh-no-oh-no"&gt;</code> </pre> <br><p>  Comme nous ne copions rien au stade de la tokenisation, mais ne prenons que des pointeurs vers le d√©but et la fin des donn√©es, nous avons un probl√®me.  Pointeurs vers diff√©rents tampons utilisateur.  Et √©tant donn√© que les d√©veloppeurs utilisent souvent le m√™me tampon pour les donn√©es, nous avons affaire √† un pointeur vers le d√©but de donn√©es inexistantes. </p><br><p>               . <br>   : </p><br><ol><li>              (Incoming Buffer). </li><li>     ( )  ,        ?  ,          .       ,           .  99%        . </li></ol><br><p>  "  "  .      . </p><br><p> ,      .      ,       ( )          .     . ,  ,   ,  .         . </p><br><h3 id="problema-dannye-v-tokene"> :    </h3><br><p>      ,  . ,        :          .     .             (    ),      .              . </p><br><p>    :      .  ,                . </p><br><h2 id="stadiya-postroeniya-dereva">    </h2><br><p>   . </p><br><p>      ,    . ,         . </p><br><p>    : </p><br><p> <strong> </strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error, ignore token */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == whitespaces) { <span class="hljs-comment"><span class="hljs-comment">/* Insert element */</span></span><span class="hljs-string"><span class="hljs-string">' } /* ... */ }</span></span></code> </pre> <br><p> <strong> Lexbor HTML</strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">lexbor_str_t</span></span> str = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">lxb_html_parser_char_t</span></span> pc = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; pc.drop_null = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; tree-&gt;status = lxb_html_token_parse_data(token, &amp;pc, &amp;str, tree-&gt;document-&gt;mem-&gt;text); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token-&gt;type &amp; LXB_HTML_TOKEN_TYPE_NULL) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* Insert element if not empty */</span></span> }</code> </pre> <br><p>   ,               .           : </p><br><pre> <code class="cpp hljs">pc.replace_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0'    (REPLACEMENT CHARACTER (U+FFFD)) */</span></span> pc.drop_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0' */</span></span> pc.is_attribute <span class="hljs-comment"><span class="hljs-comment">/*          " " */</span></span> pc.state <span class="hljs-comment"><span class="hljs-comment">/*  .        . */</span></span></code> </pre> <br><p>           . -   <strong><code>\0</code></strong> ,  -    <strong><code>REPLACEMENT CHARACTER</code></strong> . -    ,  - .        . </p><br><p>  ,     .      .  ,       <strong><code>&lt;head&gt;</code></strong>   .  ,           ,   : "    ".              ,           . </p><br><div class="spoiler"> <b class="spoiler_title">  &lt;sarcasm&gt;</b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La sp√©cification HTML (dans la section de construction de l'arborescence) parle de la balise </font></font><strong><code>sarcasm</code></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">J'ai vu plus d'une fois comment les d√©veloppeurs d'analyseurs ont aveugl√©ment activ√© le traitement de cette balise.</font></font></p><br><pre> <code class="plaintext hljs">An end tag whose tag name is "sarcasm" Take a deep breath, then act as described in the "any other end tag" entry below.</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les r√©dacteurs de sp√©cifications plaisantent. </font></font></p></div></div><br><h2 id="itog">  </h2><br><p>            HTML    DOM/HTML Interfaces   HTML/DOM    HTML . </p><br><p>    ,   : </p><br><ol><li>    (  ) </li><li>  <br><ul><li>  Incoming Buffer </li><li>   </li><li>   Tag ID </li><li> ÃÜ :  ,  N+  </li><li> ÃÜ     </li><li>      </li><li>    Ãà </li></ul></li><li>   <br><ul><li>      </li></ul></li></ol><br><p>  i7 2012 ,   ,      235MB   (Amazon-). </p><br><p>  ,        1.5/2 ,     . ,    . ,    CSS     (Grammar,  ,       Grammar).     HTML,  CSS  ,    "". </p><br><h2 id="ishodniki">  Code source </h2><br><p>      HTML    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lexbor HTML</a> . </p><br><h2 id="ps">  PS </h2><br><p>      CSS  Grammar.  ,     .  - 6-8 . </p><br><div class="spoiler"> <b class="spoiler_title"> ,    </b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N'h√©sitez pas √† aider le projet. </font><font style="vertical-align: inherit;">Par exemple, si vous aimez √©crire de la documentation pendant votre temps libre. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N'h√©sitez pas √† soutenir le projet en roubles (je ne serai pas offens√© par les autres devises non plus). </font><font style="vertical-align: inherit;">√Ä ce sujet dans PM.</font></font></p></div></div><br><p>  Merci de votre attention! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430736/">https://habr.com/ru/post/fr430736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430724/index.html">DEFCON 21. La conf√©rence DNS peut √™tre dangereuse pour votre sant√©. Partie 1</a></li>
<li><a href="../fr430728/index.html">Apprenez-moi √† donner mon avis</a></li>
<li><a href="../fr430730/index.html">Que fait R&D ABBYY: NLP Advanced Research Group</a></li>
<li><a href="../fr430732/index.html">√Ä la question de la division et de TI</a></li>
<li><a href="../fr430734/index.html">Mises √† jour intelligentes vs contrats intelligents</a></li>
<li><a href="../fr430738/index.html">Soyez un ninja de la s√©curit√©: niveau secret</a></li>
<li><a href="../fr430740/index.html">Comment traire des vaches avec des robots et faire une startup industrielle dessus. Historique de d√©veloppement de R-SEPT</a></li>
<li><a href="../fr430742/index.html">Olympiade √©tudiante "Je suis un professionnel": direction "Programmation et technologies de l'information"</a></li>
<li><a href="../fr430746/index.html">Pourquoi les batteries Tesla ne fonctionneront pas dans un taxi a√©rien</a></li>
<li><a href="../fr430748/index.html">La lutte pour les ressources, partie 6: cpuset ou partage n'est pas toujours juste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>