<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò¥ üßöüèª üåõ Blockchain sin intermediarios: c√≥mo enviamos valores a un registro distribuido üçä üë®üèª‚Äçüîß üë®‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Toda la actividad econ√≥mica se basa hist√≥ricamente en intermediarios. Cualquier transacci√≥n, incluso simple entre las dos partes, va acompa√±ada de la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain sin intermediarios: c√≥mo enviamos valores a un registro distribuido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/442692/">  Toda la actividad econ√≥mica se basa hist√≥ricamente en intermediarios.  Cualquier transacci√≥n, incluso simple entre las dos partes, va acompa√±ada de la participaci√≥n de varios intermediarios: bancos, casas de cambio, c√°maras de compensaci√≥n, etc.  La exclusi√≥n de intermediarios probablemente har√≠a que la interacci√≥n sea m√°s eficiente.  Entonces, ¬øpor qu√© no intentar construir una nueva infraestructura descentralizada sobre la base de blockchain, donde los participantes en la transacci√≥n pueden trabajar directamente?  En esta publicaci√≥n, hablaremos sobre c√≥mo comenzamos nuestro viaje hacia dicha infraestructura: desarrollamos transacciones de blockchain y, como resultado, realizamos repos - pr√©stamos de dinero contra valores. <br><br><img src="https://habrastorage.org/webt/5y/08/en/5y08enodezvkfd1qngslkh-pl4y.png"><br><a name="habracut"></a><br><h2>  Bonos a corto plazo </h2><br>  Nuestra primera transacci√≥n financiera OTC en blockchain fue la emisi√≥n de un bono a corto plazo del operador m√≥vil MTS con la participaci√≥n del Dep√≥sito Nacional de Liquidaci√≥n (NSD).  Este es un tipo de "banco central" de todos los depositarios.  Los depositarios son intermediarios de infraestructura que mantienen registros de los propietarios de valores y los emiten. <br><br>  En esa transacci√≥n, MTS, al llamar a la funci√≥n del contrato inteligente, registr√≥ en la cadena de bloques una expresi√≥n de voluntad de vender valores a Sberbank, y confirm√≥ en la cadena de bloques su acuerdo con los t√©rminos de la transacci√≥n.  Las √≥rdenes contrarias firmadas por ambas partes fueron recibidas por NSD, que las ejecut√≥ en sus sistemas contables.  Adem√°s, la cadena de bloques mostraba las cuentas de los participantes de la transacci√≥n en valores y dinero. <br><br>  En ese proyecto, seleccionamos la plataforma <i>Hyperledger Fabric 1.1 de</i> c√≥digo abierto, dise√±ada para crear soluciones de blockchain empresariales cerradas.  Las cadenas de bloques p√∫blicas no son adecuadas aqu√≠, porque debemos garantizar la privacidad de los datos.  Enfrentamos tales limitaciones en el piloto de factoring de Sberbank con M. Video, que se implement√≥ en la cadena de bloques Ethereum.  Por el contrario, Hyperledger Fabric le permite colocar a todos los participantes en una transacci√≥n en un canal dedicado, donde pueden intercambiar cualquier informaci√≥n necesaria y procesarla con contratos inteligentes con todas las funciones. <br><br>  El c√≥digo fuente del proyecto de emisi√≥n de bonos MTS se subi√≥ p√∫blicamente a GitHub.  Sin siquiera entrar en el algoritmo de trabajo, puede comprender que en el ciclo de vida de una transacci√≥n, la cadena de bloques recibi√≥ un papel bastante modesto como transporte de √≥rdenes de compensaci√≥n.  Por otro lado, sobre la base de estas instrucciones, los saldos de las cuentas cambiaron, por lo que desde el punto de vista de la l√≥gica empresarial, esto fue m√°s interesante que un simple servicio de gesti√≥n de documentos electr√≥nicos. <br><br>  La principal ventaja de la soluci√≥n era la versatilidad.  El esquema de ‚Äúdos contrapartes y un registrador‚Äù cubre casi cualquier transacci√≥n en el mercado OTC, y con cambios menores, la mayor√≠a de las transacciones comerciales en general. <br><br><h2>  REPO 1.0 </h2><br>  En un nuevo proyecto en la cadena de bloques, decidimos mostrar c√≥mo implementar un acuerdo de recompra en un sistema descentralizado: un pr√©stamo de dinero contra valores.  Por lo general, estas y otras transacciones OTC pasan por intermediarios: depositarios, c√°maras de compensaci√≥n, corredores. <br><br>  En este proyecto, celebramos un acuerdo de recompra entre Sberbank y un socio extranjero.  Ya utilizaba Hyperledger Fabric versi√≥n 1.2.  En comparaci√≥n con los bonos MTS, tuvimos dos diferencias: <br><br><ul><li>  Solo dos participantes en la transacci√≥n se conectaron a la cadena de bloques, cuyos depositarios, Euroclear y Clearstream, recibieron todos los pedidos a trav√©s de los canales tradicionales de transmisi√≥n de datos desde las oficinas administrativas de Sberbank y su contraparte. <br></li><li>  En el contrato inteligente, implementamos una l√≥gica comercial compleja: las cotizaciones diarias de la seguridad que sirvieron como garant√≠a para el pr√©stamo se descargaron a la cadena de bloques, y el contrato inteligente calcul√≥ la necesidad y el monto del reembolso anticipado, teniendo en cuenta el costo modificado de la garant√≠a, el descuento, el calendario de los intercambios de salida y otros par√°metros.  Tal sincronizaci√≥n P2P de algoritmos de c√°lculo entre participantes no se puede obtener sin un registro distribuido.  Esto es mucho m√°s conveniente que un c√°lculo independiente de obligaciones y montos por cada lado: sin reconciliaciones que requieren mucho tiempo, sin confirmaciones. <br></li></ul><br>  Entre contrapartes organiz√≥ un chat y flujo de trabajo dentro del canal.  Los datos sobre ellos se almacenaron en la cadena de bloques.  Despu√©s de cada cambio en el registro distribuido, los miembros del canal recibieron una alerta por correo electr√≥nico. <br><br>  "REPO 1.0" trabajamos desde el lado legal.  Con la ayuda de una gran firma de abogados, se realiz√≥ un an√°lisis de los casos del Tribunal Superior de Londres.  Adem√°s, el EDS del banco y su contraparte utilizaron diferentes algoritmos criptogr√°ficos. <br><br><h3>  ¬øC√≥mo funciona REPO 1.0? </h3><br>  Cada parte de la transacci√≥n tiene su propio nodo blockchain.  Todos los nodos est√°n conectados entre s√≠ en una red P2P.  Supongamos que necesita hacer un trato.  Implementamos un contrato inteligente entre las partes de la transacci√≥n, donde se describe completamente el instrumento financiero. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f42/e38/b7e/f42e38b7e23eac1217952790f217a4e9.png"><br><br>  Despu√©s de la creaci√≥n del contrato de nuestra parte, el comerciante lo firma.  El cliente tambi√©n revisa y firma el contrato.  Luego se revisan y verifican las firmas.  En este caso, la transacci√≥n se realiz√≥ bajo la ley inglesa, los datos de la firma digital electr√≥nica se ingresaron en el documento GMRA.  Para la firma del cliente, se requiere verificaci√≥n de que una persona autorizada est√© presente en el certificado de firma.  Finalmente, el cliente acepta el contrato y acepta todas las condiciones.  Puede adjuntar cualquier n√∫mero de documentos a un contrato firmado. <br><br>  Despu√©s de eso, el contrato recibe el estado de "en el trabajo".  El contrato "en curso" se recalcula autom√°ticamente al cargar nuevos precios de mercado.  Si hay un valor en el contrato, se toma el precio de mercado, se recalcula el Pr√©stamo a Valor (LTV): la relaci√≥n entre el monto del pr√©stamo y el valor del valor en valores.  LTV es uno de los t√©rminos clave en una transacci√≥n de repos, su significado se prescribe en el contrato.  El precio de las acciones ha aumentado considerablemente, y el LTV se est√° volviendo menor que el indicado en GMRA (en lo que respecta a la ley inglesa).  En consecuencia, el banco devuelve valores al cliente (como una de las opciones), ya que teniendo en cuenta los nuevos precios, resulta que el banco tiene una mayor seguridad. <br><br>  Pero si LTV se hace m√°s grande, entonces el programa le permite imprimir un aviso colateral, una notificaci√≥n al cliente sobre la necesidad de hacer seguridad adicional (acciones o dinero) para que el valor de LTV vuelva al valor inicial.  Anteriormente, la notificaci√≥n colateral solo pod√≠a enviarse por correo, se creaban documentos separados para esto y durante la creaci√≥n de estos documentos, LTV pod√≠a cambiar nuevamente.  Ahora que vemos los mismos c√°lculos con el cliente en l√≠nea, podemos interactuar f√°cilmente. <br><br>  Adem√°s, el programa todos los d√≠as fija el precio de la recompra de valores, teniendo en cuenta los intereses.  Si el cliente no est√° de acuerdo con √©l al cargar el precio de mercado, mira el registro de rec√°lculo completo: qu√© fue, qu√© se convirti√≥, qu√© precio se carg√≥, de d√≥nde vino.  Y luego comienza la discusi√≥n del chat. <br><br><h2>  REPO 2.0 </h2><br>  Quer√≠amos que nuestro REPO en la cadena de bloques pudiera iniciar el movimiento de activos reales en funci√≥n de nuestra l√≥gica interna.  Pero en REPO 1.0, debido a las dificultades organizativas para conectar los dep√≥sitos occidentales, a√∫n no hemos podido lograrlo.  Entonces comenzamos el nuevo piloto Repo 2.0.  Ten√≠a dos objetivos: <br><br><ul><li>  La transacci√≥n debe realizarse con la participaci√≥n de dos partes y el depositario, para aprovechar al m√°ximo la infraestructura del proyecto de bonos MTS. <br></li><li>  La cadena de bloques debe estar facultada para volver a evaluar la garant√≠a y configurar una llamada de margen que podr√≠a ser ejecutada autom√°ticamente por un dep√≥sito conectado a una red distribuida. <br></li></ul><br>  NSD inmediatamente quiso conectarse al proyecto.  Para aterrizar una transacci√≥n iniciada en blockchain en el campo conservador de las leyes federales que rigen el mercado financiero nacional, trabajamos con abogados para un acuerdo complementario de cinco p√°ginas para el acuerdo de gesti√≥n de documentos electr√≥nicos.  Fue firmado por todas las partes de la transacci√≥n y NSD. <br><br>  NSD actu√≥ como c√°mara de compensaci√≥n en esta transacci√≥n.  Realiz√≥ todas las instrucciones sobre el movimiento de fondos y valores.  Esta transacci√≥n se concluy√≥ bajo la ley rusa. <br><br>  El cliente acept√≥ el contrato con una firma electr√≥nica.  Luego, el acuerdo fue aceptado por Sberbank con su firma: verific√≥ el cumplimiento de todos los par√°metros con los valores necesarios y la autoridad de la persona que acept√≥ del cliente.  Despu√©s de eso, el contrato entr√≥ en funcionamiento.  NSD subi√≥ datos de mercado, rec√°lculo de contrato inteligente. <br><br><h3>  ¬øC√≥mo funciona REPO 2.0? </h3><br>  Para implementar la red e interactuar con la interfaz del cliente con el c√≥digo de cadena, utilizamos la soluci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fabric Starter</a> .  En lugar de la interfaz grpc est√°ndar para HLF, proporciona una API REST, que en nuestro caso redujo significativamente la complejidad de la integraci√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07a/86a/997/07a86a997c7017a122b03aad7995f6ad.png"><br><br>  La red subi√≥ de la siguiente manera.  Cada uno de los tres lados despu√©s de la preinstalaci√≥n en el servidor Docker lanz√≥ Fabric Starter, que cre√≥ contenedores con los componentes del nodo.  Estos componentes inclu√≠an un par externo para interactuar con otras organizaciones y un servicio API REST a trav√©s del cual el nodo interactuaba con la aplicaci√≥n cliente.  En el lanzamiento de Starter, la red blockchain tambi√©n se configur√≥ y se cre√≥ un canal privado en el que se instal√≥ el c√≥digo de la cadena con la pol√≠tica de respaldo.  En nuestro caso, cada transacci√≥n debe tener las firmas de los tres participantes. <br><br>  Durante la fase de prueba, Docker Swarm se utiliz√≥ para organizar la conexi√≥n de los servidores de los participantes, sin embargo, con el fin de hacer un trato real, cambiaron a DNS.  La plataforma en s√≠ es responsable del transporte de mensajes; los datos se transmiten a trav√©s de Internet con cifrado TLS. <br><br><h2>  El aspecto t√©cnico del problema. </h2><br>  El proceso de desarrollo de una aplicaci√≥n distribuida en HLF comienza de manera bastante tradicional, con estructuras de datos y un c√≥digo de cadena (de hecho, un conjunto de procedimientos almacenados), cuya llamada conduce al almacenamiento, modificaci√≥n o lectura de estas estructuras desde el libro mayor.  La plataforma permite el uso de varios lenguajes de programaci√≥n para el desarrollo de c√≥digos de cadena y DBMS para almacenamiento local.  Preferimos Go y CouchDB, respectivamente. <br><br>  La esencia central de los proyectos de repos en nuestro modelo de datos es el contrato en s√≠ y sus obligaciones subsidiarias.  Fueron creados para cada uno de los dos pilotos, as√≠ como para llamadas de margen.  Esta arquitectura fue un paso adelante en comparaci√≥n con el modelo de enlace MTS, que se bas√≥ en la esencia de la "Orden".  Tambi√©n se crearon objetos independientes para valores, que por lo tanto se tokenizaron parcialmente.  Pero al desarrollar el experimento con la administraci√≥n de cuentas y la tokenizaci√≥n virtual de dinero, decidimos posponer una de las pr√≥ximas versiones de la soluci√≥n. <br><br>  Las principales funciones de nuestra soluci√≥n: <br><br><ul><li>  Crea un contrato. <br></li><li>  Firme un contrato con su EDS confirmando la aceptaci√≥n de los t√©rminos del contrato. <br></li><li>  Descargue los precios de mercado y comience a recalcular el valor colateral.  Su desviaci√≥n del umbral establecido provoc√≥ la creaci√≥n de una nueva obligaci√≥n de llamada de margen. <br></li><li>  Reflejar el estado de la obligaci√≥n. <br></li></ul><br>  En el aspecto t√©cnico, el procedimiento de reevaluaci√≥n es m√°s interesante aqu√≠.  Analic√©moslo con m√°s detalle. <br><br>  En el proceso comercial, el procedimiento debe iniciarse una vez al d√≠a, despu√©s de que Oracle (en la prueba piloto de "REPO 2.0" realizada por NSD) carg√≥ las cotizaciones actualizadas de valores en el sistema. <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *CIBContract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recalculationData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface, loadData *loadDataType, curDay </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> {...}</code> </pre> <br>  El ciclo principal del procedimiento pasa por todos los valores para los que se han actualizado las cotizaciones. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, securities := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Securities {...}</code> </pre> <br>  A continuaci√≥n, se realizan varios controles.  Por ejemplo, si el intercambio con el que se recibieron los datos del mercado es hoy un d√≠a libre, entonces el recuento no deber√≠a ocurrir. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t.checkHoliday(stub, contract.Settings.Calendars) == <span class="hljs-string"><span class="hljs-string">"yes"</span></span> { hisYes := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"LoadData. Calendar"</span></span>, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Today is holiday ! No load market data to contract !"</span></span>} ... contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, hisYes) ‚Ä¶ err = stub.PutState(contrID, contractJSONasBytes) }</code> </pre><br>  Para calcular el precio del bono actualizado, el rendimiento del cup√≥n acumulado (NDC) se agrega al precio neto cargado.  El piloto implement√≥ el soporte para el esquema 30/360 para calcular NKD. <br><br><pre> <code class="go hljs">priceIzm = <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.Price + <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.CouponRate)*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Year()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Year()))*<span class="hljs-number"><span class="hljs-number">360</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Month()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Month()))*<span class="hljs-number"><span class="hljs-number">30</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Day()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Day())))*<span class="hljs-number"><span class="hljs-number">100</span></span>/<span class="hljs-number"><span class="hljs-number">360</span></span>/<span class="hljs-number"><span class="hljs-number">100</span></span>) curCurrVal = priceIzm</code> </pre><br>  Si la moneda de la transacci√≥n es diferente de la moneda en la que se cotiza el valor, se realiza una conversi√≥n de cambio. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> contract.GeneralTerms.PurchasePrice.Currency != securities.Currency { curCurrName = securities.Currency + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + contract.GeneralTerms.PurchasePrice.Currency               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, currency := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Currencies {              <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currency.Name == curCurrName {                           curCurrVal = priceIzm * currency.Value } } }</code> </pre><br>  Ahora necesitamos calcular LTV.  Mantenga el antiguo valor del coeficiente para la historia. <br><br><pre> <code class="go hljs">oldCurLTV := contract.MarginingTerms.CurrentLTV</code> </pre> <br>  Es necesario tener en cuenta las llamadas de margen ejecutadas durante la vida de la transacci√≥n.  Los requisitos pueden provenir de ambos lados y en dos formas: <br><br><ul><li>  Valores  El prestatario otorga seguridad adicional en caso de una ca√≠da en el precio de mercado de la seguridad.  El acreedor devuelve parte de la garant√≠a en caso de aumento de precios. <br></li><li>  Dinero  El prestatario antes de lo programado paga la parte del pr√©stamo que ha dejado de estar cubierta por una garant√≠a m√°s barata.  El prestamista aumenta el monto del pr√©stamo en respuesta a un aumento en el valor de la garant√≠a. <br></li></ul><br>  En el primer caso, la cantidad de valores en la garant√≠a simplemente se actualiza.  Y en caso de ganar dinero con ellos, tambi√©n es necesario acumular la rentabilidad especificada en los t√©rminos adicionales de la transacci√≥n. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, addCollateral := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> contract.MarginingTerms.AddCollateral { currSumCollateral := addCollateral.Sum + (addCollateral.Sum*contract.MarginingTerms.RateOnCashMargin*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaColDate) / <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span> ... allSumCollateral = allSumCollateral + currSumCollateral ... ht := historyType{curDay, System<span class="hljs-string"><span class="hljs-string">", "</span></span>LoadData. Recalculation data(addCollateral) Contract <span class="hljs-string"><span class="hljs-string">" + contrID + "</span></span> - currSumCollateral: <span class="hljs-string"><span class="hljs-string">" + strconv.FormatFloat(float64(currSumCollateral), 'f', 2, 64) ... }        ... contract.History = append(contract.History, ht) }</span></span></code> </pre> <br>  Calculamos el monto total de la recompra; de hecho, este es el monto del pr√©stamo con intereses, que debemos pagar. <br><br><pre> <code class="go hljs">rePurchasePriceCur := contract.GeneralTerms.PurchasePrice.Sum + (contract.GeneralTerms.PurchasePrice.Sum*contract.GeneralTerms.RepoRate*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaSigningDate)/<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre><br>  Ahora calculamos el coeficiente LTV.  Para hacer esto, reste el valor en efectivo del precio de recompra y divida el valor resultante por el valor total de los valores en el valor.  Los montos acreditados por el acreedor est√°n marcados con un "-" y se agregar√°n al precio de recompra. <br><br><pre> <code class="go hljs">contract.MarginingTerms.CurrentLTV = (rePurchasePriceCur - allSumCollateral) * <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) / (<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.GeneralTerms.PurchasedSecurities.Quantity) * curCurrVal)</code> </pre><br>  Finalmente, calculamos los desencadenantes en el contrato.  El mismo procedimiento crear√° objetos de orden de llamada de margen si el valor de LTV se desv√≠a del corredor especificado. <br><br><pre> <code class="go hljs">contract = t.checkTriggerEvents(stub, <span class="hljs-string"><span class="hljs-string">"LoadData"</span></span>, contract, curDay, securities)</code> </pre><br>  Y escriba informaci√≥n en el historial para mostrarla en la interfaz de usuario. <br><br><pre> <code class="go hljs">ht := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Recalculation data(change curLTV, ADTV) Contract "</span></span> + contrID + <span class="hljs-string"><span class="hljs-string">" - oldCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(oldCurLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>) + <span class="hljs-string"><span class="hljs-string">", newCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.CurrentLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>)...} contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, ht)</code> </pre> <br><h2>  Para resumir </h2><br>  Tal esquema puede funcionar no solo con valores y contratos, sino tambi√©n en otros escenarios.  Por ejemplo, con los suministros de electricidad, donde hay diferentes tarifas, diferentes conexiones en diferentes momentos.  O con la factorizaci√≥n: pr√©stamos a proveedores por se√±ales de env√≠o de mercanc√≠as.  Hay muchos casos de usuarios en econom√≠a, cuando todos usan sus propias fuentes de datos que deben verificarse. <br><br>  Nuestro objetivo es crear una red que conecte a los bancos entre s√≠ y a sus clientes en todo el pa√≠s, y que use contratos inteligentes para describir en √©l contratos no de criptograf√≠a, sino de la econom√≠a tradicional: instrumentos financieros.  Dicha red ser√° estable, abierta y, como deber√≠a estar en una red P2P, aqu√≠ nadie tendr√° un estado especial. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442692/">https://habr.com/ru/post/442692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442682/index.html">Qu√© escribir y c√≥mo ensamblar un proyecto C ++</a></li>
<li><a href="../442684/index.html">Rendimiento equilibrado del sitio. Parte 3: contenido</a></li>
<li><a href="../442686/index.html">Tutorial de DataPower</a></li>
<li><a href="../442688/index.html">An√°lisis de datos Scala: ¬øuna necesidad urgente o una oportunidad agradable?</a></li>
<li><a href="../442690/index.html">Misi√≥n lunar "Bereshit" - selfie en el fondo de la Tierra</a></li>
<li><a href="../442694/index.html">Uno de los gigantes del streaming lanzado en India y atrajo a un mill√≥n de usuarios en una semana.</a></li>
<li><a href="../442696/index.html">S for Security: Internet Security of Things e informes en InoThings ++ 2019</a></li>
<li><a href="../442698/index.html">Aplicaci√≥n del metro de Mosc√∫ para la Tienda Windows</a></li>
<li><a href="../442700/index.html">¬øVale la pena tratar con plantas m√≥viles de energ√≠a solar?</a></li>
<li><a href="../442702/index.html">Acerca de la magistratura de Tinkoff.ru en MIPT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>