<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèº ‚ûó üë©üèæ‚Äçü§ù‚Äçüë©üèª Desempenho da anima√ß√£o do site üë∂üèª üèáüèº üî¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao desenvolver sites que v√£o al√©m da estrutura de uma inicializa√ß√£o condicional, mais cedo ou mais tarde surgem perguntas sobre o desempenho das anima...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desempenho da anima√ß√£o do site</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450484/"><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="imagem"></p><br><p> Ao desenvolver sites que v√£o al√©m da estrutura de uma inicializa√ß√£o condicional, mais cedo ou mais tarde surgem perguntas sobre o desempenho das anima√ß√µes.  Eles s√£o especialmente importantes em sites de design, como os que se enquadram nos cat√°logos Awwwards, FWA, CSS Design Awards, etc.  Nesse caso, geralmente a tarefa de criar anima√ß√µes e subsequente otimiza√ß√£o, se necess√°rio, recai sobre os ombros de desenvolvedores pouco experientes que nem sabem por onde come√ßar.  Geralmente, tudo isso se traduz em locais inibit√≥rios que n√£o podem ser usados ‚Äã‚Äãe na subsequente atitude negativa em rela√ß√£o a toda a classe de tais projetos.  Neste artigo, tentaremos descobrir onde est√° o limite do desempenho aceit√°vel da anima√ß√£o, quais gargalos s√£o comuns e onde procurar nas ferramentas do desenvolvedor em primeiro lugar. </p><a name="habracut"></a><br><p>  <em>Uma pequena observa√ß√£o: como este artigo se destina mais a desenvolvedores iniciantes e seu objetivo √© mostrar abordagens gerais para otimizar anima√ß√µes, muitas coisas ser√£o dadas de forma simplificada, n√£o muito acad√™mica.</em> </p><br><h2 id="kak-brauzer-otobrazhaet-stranicu">  Como o navegador exibe a p√°gina </h2><br><p>  Antes de tudo, √© √∫til entender o que acontece quando o navegador nos exibe o estado atual da p√°gina.  Existem quatro etapas principais: </p><br><ol><li>  C√°lculo de estilo (o navegador analisa seletores CSS, determina quais estilos devem ser aplicados a quais) </li><li>  Cria√ß√£o de layout (o layout da p√°gina √© realmente formado) </li><li>  Pintura (cria representa√ß√µes em pixel de elementos para renderiza√ß√£o subsequente) </li><li>  Composi√ß√£o da camada (o navegador re√∫ne tudo e √© exibido na tela) </li></ol><br><p>  Al√©m disso, o navegador sempre atua nessa sequ√™ncia e vai at√© o fim.  Quando a p√°gina √© exibida inicialmente ap√≥s carreg√°-la, todas as quatro etapas passam.  No futuro, nossas a√ß√µes poder√£o causar a execu√ß√£o de uma delas, mas ao mesmo tempo todas as a√ß√µes subsequentes ser√£o executadas.  Mas n√£o os anteriores. </p><br><p>  Consideraremos mais os gargalos de cada uma dessas etapas e agora faremos uma pergunta boba √† primeira vista, a partir da qual, em teoria, voc√™ precisa come√ßar ... </p><br><h2 id="tormozit-ili-ne-tormozit-vot-v-chem-vopros">  Se diminui ou n√£o, essa √© a quest√£o ... </h2><br><p>  Muitas vezes, voc√™ pode conhecer pessoas que n√£o est√£o fazendo nada com um site claramente lento e dizer "mas a velocidade da minha p√°gina d√° 100 pontos, est√° tudo bem".  Ou vice-versa, em um site que funcione bem, as pessoas est√£o envolvidas em algum tipo de otimiza√ß√£o h√° muito tempo, porque algum algoritmo funciona ineficientemente com base em algumas m√©tricas misteriosas.  Mas entre esses extremos deve estar o meio do senso comum, ent√£o onde est√°? </p><br><p><img src="https://habrastorage.org/webt/zv/su/nv/zvsunvxfwjqvs98q0_yhc9s5jry.jpeg" alt="imagem"></p><br><p>  Para <del>  conhe√ßa zen </del>  para entender se voc√™ precisa otimizar suas anima√ß√µes, √© necess√°rio realizar um pensamento filos√≥fico profundo: </p><br><blockquote>  Se voc√™ vir que o site est√° lento, significa que est√° lento.  Se voc√™ n√£o perceber que o site est√° diminuindo a velocidade, n√£o est√° diminuindo. </blockquote><p>  Por alguma raz√£o, muitas pessoas acham essa afirma√ß√£o muito est√∫pida, mas √© isso?  Para o usu√°rio final, o desempenho n√£o √© um tipo de m√©trica ou algoritmo ideal com justificativa matem√°tica rigorosa.  Para ele, o desempenho √© uma das duas coisas: diminui a velocidade ou n√£o diminui. </p><br><p>  Como ele determina isso?  O olho de uma pessoa que passa muito tempo atr√°s do monitor come√ßa a reagir bruscamente a uma queda nos fps.  Isso causa uma estranha sensa√ß√£o de desconforto.  Consequentemente, nossa tarefa, como desenvolvedores, √© impedir o subsid√™ncia.  O usu√°rio est√° acostumado a ver o navegador funcionando a 60fps?  Bem, ent√£o estamos fazendo tudo para que tudo continue assim.  Pegamos um laptop com ferro m√©dio e olhamos.  Vemos muito menos do que 60fps - otimizamos.  Vemos cerca de 60 - n√£o toque em nada.  O usu√°rio n√£o perceber√° a diferen√ßa de qualquer maneira, e dedicaremos muito tempo √† otimiza√ß√£o por causa das otimiza√ß√µes. </p><br><blockquote>  N√£o fa√ßa otimiza√ß√µes para otimiza√ß√µes. </blockquote><br><h2 id="165ms">  16.5ms </h2><br><p>  Expressar-se em termos de fps n√£o √© conveniente, ent√£o vamos para milissegundos.  Com uma divis√£o simples de 1000ms / 60fps, obtemos cerca de 16,5ms de tempo por quadro. </p><br><p>  O que isso significa?  Por 16,5ms, o navegador deve nos mostrar o estado atual da p√°gina com a anima√ß√£o, seguindo as etapas que vimos acima e, ao mesmo tempo, os recursos devem permanecer para o trabalho de outros scripts, comunica√ß√£o com o servidor etc.  Se mais tempo for gasto na exibi√ß√£o do estado atual da p√°gina, veremos atrav√©s de nossos olhos o atraso.  Se cerca de 16ms, n√£o haver√° subsid√™ncia, mas √© prov√°vel que a carga de ferro seja muito alta, os refrigeradores vibrem e os telefones aque√ßam.  Portanto, precisamos garantir que a renderiza√ß√£o de um quadro n√£o chegue perto desse valor no tempo e, melhor ainda, n√£o seja superior a 10ms, para que haja uma margem no desempenho.  N√£o esque√ßa que os testes s√£o sempre realizados no hardware intermedi√°rio - por exemplo, nos exemplos a seguir, capturas de tela ser√£o feitas no Pentium Silver com gr√°ficos integrados. </p><br><blockquote>  Teste no hardware que seus usu√°rios t√™m mais probabilidade de ter.  Se voc√™ possui um processador de ponta e um farm de minera√ß√£o embaixo da mesa em seu local de trabalho, tudo funcionar√° bem para voc√™, enquanto seus usu√°rios com laptops econ√¥micos podem ficar muito tristes. </blockquote><p>  Para n√£o confiar apenas nos seus bons olhos e intui√ß√£o, √© √∫til dominar as ferramentas do desenvolvedor, pelo menos em um n√≠vel b√°sico.  Eles n√£o apenas fornecem dados de desempenho precisos, mas tamb√©m informam onde procurar o problema, se tudo n√£o funcionar muito bem. </p><br><h2 id="instrumenty-razrabotchika-v-google-chrome">  Ferramentas de desenvolvedor no Google Chrome </h2><br><p>  Muitos codificadores s√£o freq√ºentemente atingidos por ferramentas de desenvolvedor no navegador, mais do que no console linux.  Mas, de fato, n√£o h√° nada a temer.  Sim, existem muitos bot√µes, mas eles s√£o redundantes para resolver nossos problemas.  Agora veremos onde vale a pena prestar aten√ß√£o, antes de tudo, para entender o que fazer com a anima√ß√£o e se √© necess√°rio fazer alguma coisa. </p><br><p>  Quando se trata de desempenho, passaremos a maior parte do tempo na guia desempenho e pressionaremos o mesmo bot√£o. </p><br><p><img src="https://habrastorage.org/webt/a_/wd/vn/a_wdvnjnvppuvnrzp_f4sxp4gb0.png" alt="imagem"></p><br><p>  O atalho Ctrl-E ou o bot√£o redondo √† esquerda inicia e para de gravar o que est√° acontecendo.  Os resultados s√£o exibidos aqui.  O navegador escreve muitas coisas, mas √© melhor v√™-lo uma vez do que l√™-lo muitas vezes, ent√£o vamos pegar algum tipo de anima√ß√£o e dar uma olhada.  Que seja uma anima√ß√£o CSS simples para iniciantes.  Se voc√™ o abrir em tela cheia, poder√° ver que ele funciona com atolamentos percept√≠veis: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/Xwrqpw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Vamos gravar alguns segundos no modo de tela cheia e ver o que acontece l√°: </p><br><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="imagem"></p><br><p>  O navegador registra tudo o que faz.  Na parte superior da janela, vemos um gr√°fico de fps.  Ele pode ser facilmente usado para detectar uma anomalia se, no processo de trabalhar com a p√°gina, ela come√ßar a ficar muito lenta.  Se voc√™ clicar no gr√°fico com o mouse e pux√°-lo para o lado ou girar a roda, poder√° selecionar esse intervalo de tempo e as informa√ß√µes detalhadas ser√£o exibidas abaixo.  Em nosso exemplo simples, n√£o h√° anomalias, mas √© claramente visto que tudo n√£o funciona de maneira muito uniforme. </p><br><p>  Preste aten√ß√£o imediatamente √† linha <em>Quadros</em> , que cont√©m informa√ß√µes sobre o tempo gasto em cada quadro.  Voc√™ pode notar que esse tempo constantemente salta e excede significativamente 16ms (abaixo, em exemplos pr√°ticos, melhoraremos levemente essa anima√ß√£o). </p><br><p>  A seguir, vemos v√°rias linhas nas quais a carga √© exibida em cores diferentes - voc√™ pode ver quanto tempo o navegador passou em diferentes tipos de atividades.  Nossa anima√ß√£o √© uniforme e as mesmas opera√ß√µes s√£o realizadas para cada quadro, indicado por roxo e verde.  Se voc√™ mover o mouse sobre os blocos coloridos, ficar√° claro que estamos lidando com os itens mencionados no in√≠cio - o <em>estilo de rec√°lculo</em> e a <em>atualiza√ß√£o da √°rvore de camadas</em> s√£o roxos e as <em>camadas de</em> <em>pintura</em> e <em>composta</em> s√£o verdes. </p><br><p>  Considere outra anima√ß√£o.  Desta vez com scripts - um simples gerador de ru√≠do.  Este √© um exemplo bastante ilustrativo, embora n√£o seja de interesse do ponto de vista do design: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/QRLrBJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Voc√™ pode perceber que foram adicionados blocos amarelos que exibem a execu√ß√£o de scripts.  Se houver muitas chamadas de fun√ß√£o, para cada chamada mais um bloco ser√° adicionado - pelo seu tamanho, √© f√°cil encontrar a fun√ß√£o "mais pesada", com a qual, provavelmente, a otimiza√ß√£o deve come√ßar. </p><br><p><img src="https://habrastorage.org/webt/er/j_/cb/erj_cbmcg89tvzk-dco35nqcmia.jpeg" alt="imagem"></p><br><p>  No exemplo, o tempo gasto em um quadro varia em torno de 80ms.  Mas o que existe, mesmo a olho nu, voc√™ pode ver claramente como tudo falha.  Observando a se√ß√£o de <em>resumo</em> abaixo, vemos que os scripts levam mais tempo.  Comparado a eles, <em>renderiza√ß√£o</em> e <em>pintura</em> parecem erros que podem ser negligenciados.  Nem sempre, √© claro, acontece, mas com bastante frequ√™ncia. </p><br><p>  Se voc√™ clicar no bloco marcado como <em>chamada de fun√ß√£o</em> , abaixo est√° um link para a fun√ß√£o no c√≥digo do script.  Se voc√™ passar por isso, poder√° ver que neste exemplo h√° um ciclo atrav√©s de todos os pixels na tela.  Seria mais l√≥gico executar essa tarefa em shaders, pois o desempenho seria muitas vezes melhor.  Mas veremos isso em exemplos pr√°ticos. </p><br><h2 id="chto-delat-esli">  O que fazer se ... </h2><br><p>  Aprendemos quais etapas existem ao exibir o estado atual de uma p√°gina em um navegador e onde ver qual delas leva mais tempo.  √â hora de se familiarizar com os motivos mais comuns pelos quais essa ou aquela etapa come√ßa a exigir muitos recursos e dar algumas dicas sobre o que fazer neste ou naquele caso. </p><br><h2 id="style-calculation">  C√°lculo de estilo </h2><br><p>  Se voc√™ perceber que j√° nesta etapa os problemas come√ßam - provavelmente o ponto nem est√° na anima√ß√£o, mas no fato de haver muitos elementos na p√°gina.  Nos sites de design, isso √© bastante raro, geralmente esse problema √© um sat√©lite de grandes tabelas com milhares de elementos, mas se voc√™ ainda se deparar com isso: </p><br><blockquote>  Reduza o n√∫mero de elementos na p√°gina, simplifique o layout.  Preste aten√ß√£o especial √† repeti√ß√£o de trechos de c√≥digo com wrappers, √© prov√°vel que eles possam ser removidos. </blockquote><p>  O segundo motivo associado ao primeiro s√£o seletores de CSS complexos.  Se em p√°ginas pequenas for poss√≠vel usar aninhamento profundo, hacks complicados com elementos vizinhos etc., em uma p√°gina muito grande, tudo isso pode levar a um desempenho ruim. </p><br><blockquote>  Simplifique os seletores de CSS, use o BEM. </blockquote><br><h2 id="layout-creation">  Cria√ß√£o de layout </h2><br><p>  Este item j√° est√° mais perto de design e anima√ß√µes, coisas interessantes come√ßam aqui.  A primeira coisa que √© importante entender √© que todo o layout √© formado.  Se mudarmos algo, ele ser√° formado novamente.  Por esse motivo, mesmo pequenas altera√ß√µes na p√°gina grande podem causar atrasos vis√≠veis nesta etapa. </p><br><p>  A principal regra que nos guia ao criar anima√ß√µes √© n√£o permitir a reestrutura√ß√£o do layout a qualquer custo.  Portanto, geralmente n√£o tentamos otimiz√°-lo (e n√£o h√° oportunidades espec√≠ficas), ou seja, tentamos evit√°-lo. </p><br><p>  Existem muitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">propriedades</a> que podem causar a reconstru√ß√£o do layout. Voc√™ pode encontrar listas na Internet, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">csstriggers.com</a> n√£o √© ruim.  Mais frequentemente do que outros nas anima√ß√µes, voc√™ pode encontrar propriedades: </p><br><pre><code class="plaintext hljs">display position / top / left / right / bottom width / height padding / margin border font-size / font-weight / line-height ...</code> </pre> <br><p>  Voc√™ pode perceber que todas essas propriedades est√£o unidas por uma coisa - elas descrevem as caracter√≠sticas geom√©tricas dos elementos - exibem par√¢metros, tamanho e localiza√ß√£o f√≠sica.  Ent√£o, em vez de memorizar todos eles, lembre-se do que eles se referem. </p><br><blockquote>  N√£o altere as propriedades geom√©tricas dos elementos, √© melhor usar a transforma√ß√£o e a opacidade. </blockquote><p>  Separadamente, √© importante notar que a altera√ß√£o do plano de fundo do elemento tamb√©m nos retornar√° a esta etapa.  Eles est√£o constantemente esquecendo disso, ent√£o destacamos em uma recomenda√ß√£o separada: </p><br><blockquote>  N√£o altere os elementos de segundo plano. </blockquote><p>  Em alguns navegadores ( <del>  Eu n√£o vou cutucar um dedo no Firefox </del>  ), um atraso t√≠pico de anima√ß√µes CSS com transforma√ß√µes pode aparecer, especialmente se mais de uma anima√ß√£o for executada por unidade de tempo.  Externamente, isso pode parecer n√£o apenas uma pausa em seu trabalho, mas tamb√©m como "avarias" da anima√ß√£o desde o in√≠cio.  Parece que o navegador est√° constantemente recalculando alguma coisa.  Esse comportamento quase sempre √© corrigido usando a propriedade <em>backface-visible</em> . </p><br><blockquote>  Se poss√≠vel, adicione backface-visible: oculto aos elementos animados. </blockquote><p>  Al√©m disso, a reconstru√ß√£o do layout √© causada por nossas chamadas para elementos de scripts.  Al√©m disso, isso n√£o precisa ser uma altera√ß√£o direta no CSS; tamb√©m pode ser um apelo a algumas propriedades e m√©todos de elementos.  Os mais comuns s√£o: </p><br><pre> <code class="plaintext hljs">offset*** client*** inner*** scroll***</code> </pre> <br><p>  Nas anima√ß√µes, voc√™ deve ter cuidado com elas, porque  se come√ßarmos a nos referir a essas propriedades e m√©todos para um grande n√∫mero de elementos, sempre que isso causar uma reestrutura√ß√£o do layout. </p><br><blockquote>  Evite consultar as propriedades e m√©todos mencionados para elementos individuais em loops. </blockquote><br><h2 id="painting-i-layer-composition">  Pintura e composi√ß√£o de camadas </h2><br><p>  Vamos considerar esses dois passos juntos, como  eles est√£o um pouco relacionados e, geralmente, se houver problemas com um, estar√£o com o outro.  Ignorar essas etapas, evit√°-las, n√£o funcionar√°, portanto, estamos tentando otimiz√°-las de alguma forma. </p><br><p>  O navegador n√£o prepara a imagem de pixel da p√°gina, mas em partes - as camadas.  Pode haver muitos.  Cada camada existe como se por si s√≥ e n√£o afeta o restante, o que cria a base para alguns hacks CSS.  Mas falaremos sobre eles outra vez.  Em seguida, a imagem final √© coletada dessas camadas.  No contexto das anima√ß√µes, √© muito √∫til colocar elementos animados em uma camada separada para que suas altera√ß√µes n√£o afetem tudo ao seu redor.  √â desej√°vel que o conte√∫do dos elementos seja pequeno.  Podemos fazer isso usando a propriedade <em>will-change</em> ou, como fizemos antes, <em>transformar: translateZ (0)</em> .  A √∫nica coisa a lembrar √© que voc√™ n√£o pode aumentar o n√∫mero de camadas indefinidamente.  Em algum momento, isso ser√° um truque e o desempenho oposto cair√°.  Portanto, haver√° duas dicas: </p><br><blockquote>  Use will-change ou transform: translateZ (0) para mover os elementos animados para uma camada separada. </blockquote><p>  mas ao mesmo tempo </p><br><blockquote>  N√£o exagere neste neg√≥cio.  Verifique nas ferramentas do desenvolvedor que n√£o √© pior. </blockquote><p>  Muitas vezes, problemas s√©rios s√£o causados ‚Äã‚Äãpor filtros que, de alguma forma, transformam a imagem dos elementos.  Pode ser simples filtros CSS com op√ß√µes de <em>desfoque</em> ou confusas com SVG, mas o efeito ser√° o mesmo - uma diminui√ß√£o percept√≠vel no desempenho. </p><br><blockquote>  N√£o use filtros complexos.  Se voc√™ ainda precisar do efeito pretendido, considere implement√°-lo no WebGL. </blockquote><br><h2 id="naskolko-eti-sovety-rabotayut">  Como essas dicas funcionam? </h2><br><p>  Eles funcionam, mas voc√™ n√£o precisa esperar um milagre deles.  Na rede, os novatos √†s vezes dizem: "Adicionei uma mudan√ßa de vontade, mas nada mudou".  Normalmente, isso significa que o principal problema estava em outro lugar, e essa t√©cnica proporcionou um aumento t√£o pequeno na produtividade que passou despercebida.  √â por isso que √© importante usar as ferramentas do desenvolvedor para entender claramente exatamente onde est√° o gargalo e n√£o gastar tempo e esfor√ßo tentando otimizar o que est√° funcionando bem. </p><br><p>  De tudo isso, podemos concluir que n√£o h√° muitas maneiras de influenciar a renderiza√ß√£o de uma p√°gina, e o efeito delas nem sempre ser√° significativo.  Esses truques n√£o s√£o balas de prata, s√£o necess√°rios para polir a anima√ß√£o.  Se olharmos para sites com desempenho realmente ruim, perceberemos que, na grande maioria dos casos, nossos pr√≥prios scripts s√£o os culpados, e n√£o problemas misteriosos com a an√°lise de CSS em algum lugar nas entranhas do navegador. </p><br><h2 id="skripty">  Scripts ... </h2><br><p>  Voc√™ sabe onde os problemas com anima√ß√µes inibit√≥rias crescem com mais frequ√™ncia (de acordo com minhas observa√ß√µes)?  Aqui a partir desta abordagem de desenvolvimento: </p><br><p><img src="https://habrastorage.org/webt/31/ov/_a/31ov_auhpakgnb4tu2mtfapgi7w.jpeg" alt="imagem"></p><br><p>  Parece bobagem, mas √©.  Constantemente existem solu√ß√µes, obviamente copiadas de algum lugar completamente sem entender o que estava acontecendo.  At√© acontece que voc√™ pode remover metade do c√≥digo e tudo continuar√° funcionando.  Geralmente, o c√≥digo nas respostas para SO ou Toaster n√£o se destina √† sua produ√ß√£o.  Isso deveria ser √≥bvio.  Ele mostra a id√©ia, responde √† pergunta, mas n√£o √© a melhor op√ß√£o final para sua tarefa espec√≠fica. </p><br><blockquote>  Se voc√™ j√° estiver copiando, pelo menos procure no c√≥digo a√ß√µes desnecess√°rias. </blockquote><br><h2 id="requestanimationframe">  RequestAnimationFrame </h2><br><p>  Eles costumam falar sobre esse m√©todo e recomendam us√°-lo em vez de <em>setTimeout / setInterval</em> nas anima√ß√µes.  Isso faz sentido, pois esses m√©todos t√™m a propriedade de estar fora de sincronia com os quadros que o navegador redesenha, resultando em pequenos atrasos.  Mas existem dois pontos. </p><br><p>  Primeiramente, se mais de um elemento for animado na p√°gina e chamarmos requestAnimationFrame muitas vezes, isso levar√° a um subsid√™ncia acentuado de fps.  Em teoria, isso n√£o deveria acontecer, mas, na pr√°tica, tudo acontece exatamente assim.  Voc√™ pode se familiarizar com os testes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><blockquote>  Combine todos os retornos de chamada de anima√ß√£o em um requestAnimationFrame. </blockquote><p>  O segundo ponto provavelmente est√° relacionado √† situa√ß√£o em que j√° temos anima√ß√£o pesada, talvez com o uso de tela, da qual n√£o podemos nos livrar ou n√£o temos tempo para refazer, e acontece o seguinte: digamos que a anima√ß√£o deve ser conclu√≠da em N segundos e j√° usamos <em>requestAnimationFrame</em> .  Mas s√£o necess√°rios muitos recursos para calcular o estado atual e vemos esta imagem: a anima√ß√£o funciona sem problemas, lindamente, mas em 2N ou 3N segundos.  Como resultado, tudo √© percebido muuuitoooooooo.  Para corrigir esse comportamento, voc√™ pode contrariar todas as recomenda√ß√µes, usando <em>setInterval / setTimeout</em> e vincular os estados dos elementos animados ao tempo f√≠sico, e n√£o aos quadros abstratos.  Como resultado, obtemos uma diminui√ß√£o formal em fps, mas com o efeito psicol√≥gico dos ganhos de produtividade. </p><br><blockquote>  No caso de anima√ß√µes extremamente lentas, pode fazer sentido recusar requestAnimationFrame em favor de setInterval / setTimeout. </blockquote><br><h2 id="canvas-i-sheydery">  Telas e Shaders </h2><br><p>  Uma parte significativa das anima√ß√µes em sites n√£o padr√£o est√° relacionada √† tela.  Isso √© compreens√≠vel, CSS √© uma coisa limitada, mas aqui podemos realizar as fantasias de qualquer designer.  Mas voc√™ precisa ter em mente que a tela 2D comum est√° longe de ser a tecnologia mais produtiva.  Se voc√™ come√ßar a desenhar v√°rios elementos ou trabalhar com pixels diretamente, encontrar√° rapidamente o fato de que o fps est√° afundando ou, de repente, a <em>pintura</em> e a <em>composi√ß√£o da camada</em> come√ßam a demorar indecentemente muito tempo.  Este problema pode ser visto claramente no exemplo: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/vdYRoj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Vejamos o que o navegador faz (o mais recente Google Chrome no Linux): </p><br><p><img src="https://habrastorage.org/webt/na/ox/5k/naox5kmmcqfuosbsfhgozpq91zw.jpeg" alt="imagem"></p><br><p>  Observe quanto a etapa de <em>composi√ß√£o</em> da <em>camada</em> foi expandida.  Parece um pouco il√≥gico, porque existe apenas um elemento, o que pode ser montado l√° por tanto tempo?  Mas, ao usar a tela 2D, esse comportamento n√£o √© incomum, e algo a ver com isso √© muito problem√°tico.  Essa √© uma das raz√µes pelas quais geralmente tendemos a usar o WebGL; n√£o existem perguntas desse tipo. </p><br><blockquote>  Se houver uma escolha entre a tela 2D e o WebGL, escolha a segunda.  Isso dar√° um b√¥nus de desempenho inicial nas mesmas tarefas. </blockquote><p>  O que geralmente est√° associado ao WebGL?  Com shaders.  E depurar shaders √© uma dor de cabe√ßa para quem trabalha com eles.  E as ferramentas de desenvolvedor aqui s√£o praticamente impotentes.  Geralmente, se houver muitos c√°lculos nos sombreadores, veremos no resumo abaixo que a maior parte do tempo √© "simples", que na verdade √© a execu√ß√£o de nossos sombreadores, independentemente do navegador, e n√£o podemos obter detalhes √∫teis. </p><br><p>  Existem recomenda√ß√µes diferentes sobre quais fun√ß√µes preferir sobre os shaders, porque elas s√£o supostamente melhor otimizadas.  Ou que as opera√ß√µes de bloqueio devem ser evitadas.  Isso tudo √© verdade, mas, de acordo com minhas observa√ß√µes, na maioria dos casos, os shaders que tornam o site lento demais s√£o simplesmente shaders muito grandes.  Se voc√™ escreveu 100 linhas GLSL em um s√≥ lugar, √© quase garantido que funcione mal.  E se tamb√©m existem diferentes constru√ß√µes aninhadas, loops, tudo - a grava√ß√£o se foi.  √â dif√≠cil fazer recomenda√ß√µes aqui, a menos que: </p><br><blockquote>  Se voc√™ percebeu durante o trabalho que tudo √© mais complicado do que parecia inicialmente, e que haver√° muito c√≥digo e isso diminuir√° a velocidade - √© melhor discutir isso com o designer e o cliente o mais r√°pido poss√≠vel e pensar no que pode ser alterado. </blockquote><p>  Muitas vezes, voc√™ pode concluir que um v√≠deo pr√©-preparado funcionar√° muito melhor do que tentar render algum tipo de coisa confusa em tempo real.  Lembre-se disso.  Sim, todo mundo quer se mostrar, quer se exibir "mas eu posso fazer assim", mas n√£o se esque√ßa dos usu√°rios finais. </p><br><p>  Em conex√£o com esse pensamento, recordo a ‚Äúdoen√ßa‚Äù √† qual a antiga Olimp√≠ada √© especialmente suscet√≠vel.  Por alguma raz√£o, ele se manifesta fortemente ao trabalhar com telas.  Por esse motivo, voc√™ sempre deve copiar cuidadosamente o c√≥digo dessas pessoas.  Eles tentam usar os algoritmos matem√°ticos ‚Äúcorretos‚Äù, f√≥rmulas f√≠sicas complexas, para calcular todos os movimentos dos elementos com grande precis√£o, mesmo onde s√£o completamente in√∫teis.  Isso leva a um aumento da carga no processador e ao fato de que, por nossos 10ms condicionais, n√£o h√° tempo para contar nada.  Na pr√°tica, muitas vezes voc√™ pode conviver com f√≥rmulas aproximadas e conhecimento escolar de f√≠sica.  N√£o √© necess√°rio complicar as coisas, criamos sites, n√£o software para m√≠sseis bal√≠sticos. </p><br><blockquote>  Use algoritmos simples. </blockquote><p>  H√° outro truque chamado <em>RayMarching</em> .  Algumas pessoas consideram a cria√ß√£o de efeitos diferentes um desafio, um aquecimento para a mente e, √†s vezes, os resultados s√£o impressionantes.  Por exemplo, um mundo subaqu√°tico inteiro √© gerado aqui (inseri um v√≠deo, porque, a partir de c√°lculos disso em tempo real, o telefone / laptop pode se desligar): </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mQXUHTTq4E8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  O shader em si pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Na pr√°tica, tudo isso requer recursos incr√≠veis para funcionar.  No modo de tela cheia, temos 400-800ms por quadro (em geral, neste exemplo, pode ir at√© 1500ms): </p><br><p><img src="https://habrastorage.org/webt/pj/jj/pj/pjjjpj9fu4fcqkvtqg2bggwhqhc.jpeg" alt="imagem"></p><br><p>  Portanto, se voc√™ se pegou pensando em fazer algo assim em um site de combate, d√™ um teclado na cabe√ßa, beba ch√° e pense em op√ß√µes alternativas para implementar efeitos. </p><br><blockquote>  N√£o use RayMarching, esta √© uma maneira de diminuir o desempenho. </blockquote><br><h2 id="prakticheskiy-primer">  Exemplo pr√°tico </h2><br><p>  Geralmente, n√£o h√° exemplos suficientes em artigos sobre produtividade, mas pode ser dif√≠cil dizer uma palavra.  Ent√£o considere um casal.  Lembra do primeiro exemplo de t√∫nel girat√≥rio CSS?  O navegador fez v√°rias coisas: </p><br><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="imagem"></p><br><p>  Queremos acelerar um pouco as coisas.  Por onde come√ßar?  Vemos blocos roxos, o que significa que o navegador est√° constantemente reconstruindo o layout.  N√£o h√° scripts l√°, mas existem anima√ß√µes CSS nas quais algo muda.  Vejamos o c√≥digo deles: </p><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> rotate { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotate</span></span>(0); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotate</span></span>(360deg); } } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> move-block { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(0); <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: @color1; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(-@block-size * 6); <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: @color2; } }</code> </pre> <br><p>  As transforma√ß√µes n√£o nos assustam, mas vemos uma mudan√ßa no fundo dos elementos.  Lembramos que isso pode causar uma reestrutura√ß√£o do layout e pensamos o que pode ser feito nessa situa√ß√£o ... </p><br><p>  A altera√ß√£o do plano de fundo precisa ser removida a todo custo; portanto, com base na id√©ia geral de anima√ß√£o, decidimos que voc√™ pode colocar um gradiente radial no topo, o que criar√° quase o mesmo efeito de volume.  Algu√©m dir√° que os gradientes t√™m um efeito ruim no desempenho, mas n√£o vamos mudar isso.  Que seja melhor uma vez que afeta mal do que teremos uma montanha inteira de elementos que afetam constantemente.  O resultado √©: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/OYLZpx" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Vamos ver o que o navegador faz: </p><br><p><img src="https://habrastorage.org/webt/0i/hc/oh/0ihcohn8cxnwbrq78qgmo8b0-w4.jpeg" alt="imagem"></p><br><p>  Uau ... Em vez de v√°rias a√ß√µes, vemos chamadas raras para a GPU e nada mais, enquanto a anima√ß√£o em si come√ßou a funcionar visivelmente mais suave. </p><br><h2 id="esche-primer">  Outro exemplo </h2><br><p>  Lembre-se da apar√™ncia do navegador no gerador de ru√≠do: </p><br><p><img src="https://habrastorage.org/webt/er/j_/cb/erj_cbmcg89tvzk-dco35nqcmia.jpeg" alt="imagem"></p><br><p>  O problema est√° definitivamente nos scripts.  Pode-se ver que o bloco "render" √© o maior.  Esta √© a nossa principal fun√ß√£o para renderizar a imagem.  Vamos olhar para ela: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageData = CTX.createImageData(CTX.canvas.width, CTX.canvas.height); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; imageData.data.length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = getRandom(); imageData.data[i] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">2</span></span>] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">255</span></span>; } CTX.putImageData(imageData, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); requestAnimationFrame(render); }</code> </pre> <br><p>  Definitivamente, h√° trabalhos em andamento com pixels individuais.  Isso n√£o √© muito saud√°vel.  Dissemos que, se poss√≠vel, √© melhor usar n√£o o 2d-canvas, mas o WebGL, e essa tarefa s√≥ quer ser paralelizada usando um shader.  Vamos fazer isso: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/VOZxGp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Qual ser√° o resultado?  Veja voc√™ mesmo: </p><br><p><img src="https://habrastorage.org/webt/3m/td/vh/3mtdvhlrjo4-cjuqmzieis4tr7w.jpeg" alt="imagem"></p><br><p>  O tempo para um quadro diminuiu para quase 16ms.  Claro que isso n√£o √© ideal, mas ainda melhor que 80ms.  Em anima√ß√µes complexas e bonitas, esse ganho de desempenho pode ser muito percept√≠vel.  Aproveito a oportunidade para recomendar que os iniciantes se familiarizem com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">introdu√ß√£o de shaders na programa√ß√£o</a> e com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">continua√ß√£o de exemplos</a> . </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  Neste artigo, descobrimos quando se trata de otimizar o desempenho das anima√ß√µes, como usar as ferramentas de desenvolvedor no Chrome nesse contexto e o que procurar primeiro.  Espero que essas informa√ß√µes sejam √∫teis para desenvolvedores que enfrentam essas tarefas pela primeira vez e n√£o sabem por onde come√ßar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt450484/">https://habr.com/ru/post/pt450484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt450472/index.html">Como fazer um roteiro perfeito?</a></li>
<li><a href="../pt450474/index.html">Introdu√ß√£o ao Python</a></li>
<li><a href="../pt450476/index.html">Como registramos uma empresa na UE</a></li>
<li><a href="../pt450478/index.html">Hoje, muitos complementos populares do Firefox pararam de funcionar devido a problemas de certificado.</a></li>
<li><a href="../pt450480/index.html">Como a computa√ß√£o qu√¢ntica pode afetar o desenvolvimento de software</a></li>
<li><a href="../pt450486/index.html">9. Introdu√ß√£o ao Ponto de Verifica√ß√£o R80.20. Controle de aplicativos e filtragem de URL</a></li>
<li><a href="../pt450488/index.html">Chock Norris Facts Android App no ‚Äã‚ÄãKotlin</a></li>
<li><a href="../pt450490/index.html">Acordo de US $ 6,9 bilh√µes: por que um desenvolvedor de GPU compra um fabricante de equipamentos de rede</a></li>
<li><a href="../pt450492/index.html">Servi√ßo social e design aberto. 1. Introdu√ß√£o</a></li>
<li><a href="../pt450494/index.html">Como a tradu√ß√£o do termo tronco depende do fornecedor do switch?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>