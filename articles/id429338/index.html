<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔊 🕋 🖐🏿 Penyimpanan Android: Internal, Eksternal, Dapat Dilepas. Bagian 1/3 🌆 😁 👲🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk semua orang yang, terlepas dari segalanya, berhasil membuat pilihan yang tepat. 

 Ini adalah terjemahan dari serangkaian artikel dari Mark Murp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penyimpanan Android: Internal, Eksternal, Dapat Dilepas. Bagian 1/3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429338/"><blockquote>  Untuk semua orang yang, terlepas dari segalanya, berhasil membuat pilihan yang tepat. </blockquote><p>  Ini adalah terjemahan dari serangkaian artikel dari Mark Murphy dari CommonsWare, yang dikenal luas di stackoverflow, serta penulis buku "Panduan Sibuk untuk Pengembangan Android", "Komponen Arsitektur Android".  Beberapa istilah tidak diterjemahkan secara khusus. </p><br><h1 id="internal-storage">  Penyimpanan internal </h1><br><p>  Ada banyak kebingungan mengenai model penyimpanan Android.  Kebingungan telah tumbuh secara signifikan dengan perubahan Android 4.4 di Storage Model, dan sejak itu situasinya belum membaik.  Ada banyak pertanyaan tentang Stack Overflow dan sumber daya serupa, di mana orang jelas tidak sepenuhnya berpengalaman dalam berbagai model penyimpanan Android. </p><a name="habracut"></a><br><h1 id="to-chto-polzovateli-schitayut-internal-storage">  Apa yang pengguna anggap sebagai Penyimpanan Internal </h1><br><p>  Tergantung pada model perangkat Anda, pengguna pada akhirnya akan datang ke Pengaturan -&gt; Penyimpanan di perangkat mereka atau lokasi yang setara, dan dapat melihat layar yang menggambarkan "Penyimpanan internal" . </p><br><p>  Pengguna berpikir bahwa seluruh flash drive internal adalah "Penyimpanan Internal".  Untungnya, Google mulai mengubah istilah ini dengan Android 8.0, pindah ke "penyimpanan umum" alih-alih "penyimpanan internal". </p><br><p> Namun, pengguna masih dapat melihat "penyimpanan internal" di tempat-tempat seperti jendela Windows Explorer ketika perangkat mereka terhubung melalui USB. </p><br><h1 id="chto-google-schitaet-internal-storage">  Apa Google Mempertimbangkan Penyimpanan Internal </h1><br><p>  Sayangnya, apa yang dilihat pengguna tidak sama dengan apa yang dianggap Android SDK sebagai "penyimpanan internal", yang menyebabkan beberapa kebingungan.  Jika Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membaca dokumentasi Android pada repositori internal</a> , maka deskripsi ini ... setidaknya berkabut (teks telah berubah sejak saat penulisan): </p><br><blockquote>  Anda dapat menyimpan file secara langsung ke memori internal perangkat.  Secara default, file yang disimpan dalam penyimpanan internal bersifat pribadi untuk aplikasi Anda, dan aplikasi lain tidak dapat mengaksesnya (serta pengguna).  Saat pengguna mencopot pemasangan aplikasi, file-file ini dihapus. </blockquote><p>  Sebenarnya, Android SDK mendefinisikan "penyimpanan internal" sebagai direktori khusus untuk aplikasi Anda, tempat aplikasi Anda dapat meng-host file.  Seperti yang disarankan dalam dokumentasi, file-file ini dimaksudkan untuk membaca dan menulis ke aplikasi Anda secara default dan dilarang untuk aplikasi lain (pengecualian: pengguna yang bekerja dengan manajer file dengan hak pengguna super pada perangkat yang di-root dapat mengakses semuanya). </p><br><p>  Konteks memiliki beberapa metode dasar yang memberi Anda akses ke penyimpanan internal, termasuk: </p><br><ul><li><code>getCacheDir()</code> </li> <li> <code>getDir()</code> </li> <li> <code>getDatabasePath()</code> </li> <li> <code>getFilesDir()</code> </li> <li> <code>openFileInput()</code> </li> <li> <code>openFileOutput()</code> </li> </ul><br><p>  Metode lain akan bergantung pada mereka, seperti <code>openOrCreateDatabase()</code> .  Kelas-kelas lain juga akan bergantung pada mereka, seperti <code>SQLiteOpenHelper</code> dan <code>SharedPreferences</code> . </p><br><h1 id="gde-hranitsya-internal-storage--inogda">  Di mana Penyimpanan Internal disimpan ... Terkadang </h1><br><p>  Jika Anda melihat berbagai posting blog, respons StackOverflow, dan buku-buku yang dirilis pada 2012 atau sebelumnya, Anda diberitahu bahwa "penyimpanan internal" aplikasi Anda berada di / <code>/data/data/your.application.package.name</code> . <code>/data/data/your.application.package.name</code> . <code>/data/data/your.application.package.name</code> . <code>/data/data/your.application.package.name</code> . </p><br><p>  Di dalamnya akan ada beberapa direktori yang secara otomatis dibuat oleh Android, saat Anda menggunakan beberapa metode Konteks.  Sebagai contoh, <code>getFilesDir()</code> mengembalikan objek <code>File</code> menunjuk ke <code>files/</code> direktori di penyimpanan internal aplikasi Anda. </p><br><h1 id="gde-hranitsya-internal-storage--ostalnoe-vremya">  Di mana Penyimpanan Internal disimpan ... Sisa waktu </h1><br><p>  Namun, penyimpanan internal aplikasi Anda tidak selalu di lokasi yang ditentukan.  Untuk pengembang, ada satu aturan yang harus Anda pelajari dari serangkaian posting blog ini: </p><br><p>  <strong>JANGAN PERNAH HARDCODE PATHS</strong> . </p><br><p>  Dari waktu ke waktu, saya melihat pengembang melakukan hal seperti ini: </p><br><p> <code>File f=new File("/data/data/their.app.package.name/files/foo.txt");</code> </p> <br><p>  Ini bukan kejahatan, ini lebih buruk, ini adalah kesalahan. </p><br><p>  Langkah yang benar, dan kurang menulis: </p><br><p> <code>File f=new File(getFilesDir(), "foo.txt");</code> </p> <br><p>  Lebih penting lagi, <em>penyimpanan internal tidak selalu di tempat yang sama</em> .  Perlu dicatat bahwa kami memiliki konsep profil pengguna yang terpisah (profil pengguna terpisah), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dimulai dengan Android 4.2</a> untuk tablet dan Android 5.0 untuk ponsel.  Setiap pengguna mendapatkan "penyimpanan internal" mereka sendiri.  Meskipun direktori di atas masih digunakan untuk pengguna utama, itu tidak dijamin bahwa itu akan digunakan untuk akun sekunder. </p><br><h1 id="issleduem-internal-storage">  Menjelajahi Penyimpanan Internal </h1><br><p>  Alat Device File Explorer di Android Studio 3.0+ dapat melihat semua penyimpanan internal pada emulator, serta penyimpanan internal aplikasi yang di-debug pada perangkat produksi. </p><br><p>  Di baris perintah, Anda dapat menggunakan <code>adb</code> dengan opsi <code>run-as</code> . </p><br><p>  Misalnya, untuk mengunggah database dari penyimpanan internal pengguna utama ke mesin pengembangan Anda, Anda dapat menggunakan: </p><br><p> <code>adb shell 'run-as your.application.package.name cp /data/data/your.application.package.name/databases/dbname.db /sdcard'</code> </p> <br><p>  Harap dicatat bahwa: </p><br><ul><li>  Anda perlu mengubah tujuan ke tempat penyimpanan eksternal dipasang pada perangkat Anda (ditampilkan di sini sebagai <code>/sdcard/</code> , yang tidak akan sama pada semua perangkat) </li><li>  Anda mungkin perlu menggunakan <code>cat</code> alih-alih <code>cp</code> pada perangkat yang lebih lama </li><li>  Setelah file terletak di penyimpanan eksternal, Anda dapat menggunakan <code>adb pull</code> untuk mengunduhnya ke komputer Anda, atau mengaksesnya dengan cara biasa lainnya (misalnya, dengan memasang perangkat sebagai disk). </li></ul><br><h1 id="ogranicheniya-vnutrennego-hranilischa">  Keterbatasan Penyimpanan Internal </h1><br><p>  Pada perangkat Android 1.x dan 2.x yang lebih lama, penyimpanan internal biasanya terletak di bagian khusus dari sistem file, dan bagian ini biasanya sangat kecil.  HTC Dream (alias, T-Mobile G1), perangkat Android asli, memiliki memori internal 70 MB yang sangat besar untuk digunakan oleh semua aplikasi (ini bukan salah ketik, saat itu kami mengukur memori dalam megabyte). </p><br><p>  Pada saat 2.3 perangkat keluar, penyimpanan internal bisa berukuran 1 GB. </p><br><p>  Android 3.0 telah mengubah model penyimpanan, karena penyimpanan internal menjadi lebih bervolume.  Untuk perangkat yang beriklan memiliki 4 GB, 8 GB, 16 GB, dll.  ruang penyimpanan, biasanya semua ini (dikurangi konten yang ada) tersedia untuk penyimpanan internal.  Kami akan melihat apa yang telah berubah di Android 3.0 dan dampaknya pada model penyimpanan di posting berikut tentang penyimpanan eksternal. </p><br><p>  Untuk Android 1.x dan 2.x, penyimpanan internal hanya valid untuk file kecil, dan Anda harus menggunakan penyimpanan eksternal untuk yang lainnya.  Android 3.0+ berarti bahwa untuk sebagian besar perangkat dan sebagian besar pengguna, penyimpanan internal sangat bagus untuk file yang tidak dimaksudkan untuk penggunaan normal oleh aplikasi lain atau yang dapat diakses oleh pengguna terlepas dari aplikasi Anda.  Namun, beberapa pengguna berpengalaman menemukan bahwa bahkan flash on-board tidak cukup untuk apa yang ingin mereka simpan, sehingga mereka beralih ke penyimpanan yang dapat dilepas ... yang merupakan <em>kaleng cacing (perhatikan λμινς)</em> - sumber dari banyak masalah yang tidak dapat diprediksi dan kompleks. </p><br><h1 id="faq-po-internal-storage">  FAQ Penyimpanan Internal </h1><br><h2 id="dolzhen-li-ya-delat-fayly-vo-vnutrennem-hranilische-world-readable-ili-world-writeable">  Haruskah saya membuat file di penyimpanan internal World-Readable atau World-Writeable? </h2><br><p>  Oh, $ ALLAH, tidak.  Gunakan <code>FileProvider</code> dan sajikan konten ini dengan penerapan <code>ContentProvider</code> .  Setelah itu, Anda, setidaknya, memiliki kesempatan untuk menggunakan sistem izin Android untuk mengontrol akses ke file-file ini, tidak seperti versi Anda, ketika aplikasi apa pun dalam sistem dapat merusak file-file ini. </p><br><h2 id="nu-a-kak-naschet-androidshareduserid-">  Nah, bagaimana dengan <code>android:sharedUserId</code> ? </h2><br><p>  Saya tidak menyarankan. </p><br><p>  <code>android: sharedUserId</code> adalah atribut yang dapat Anda masukkan ke manifes yang menunjukkan pengidentifikasi logis pengguna yang akan digunakan untuk aplikasi Anda.  Aplikasi lain apa pun yang diinstal yang menandatangani dengan kunci tanda tangan yang sama dan meminta <code>android:sharedUserId</code> sama <code>android:sharedUserId</code> akan menggunakan pengguna Linux yang sama dari sudut pandang keamanan.  Efeknya adalah bahwa kedua aplikasi ini dapat bekerja dengan file satu sama lain dengan impunitas, karena file-file ini milik pengguna Linux yang sama. </p><br><p>  Atribut ini benar-benar ditujukan untuk aplikasi pra-instal, seperti rangkaian perangkat lunak yang dimuat sebelumnya oleh pabrikan perangkat, operator seluler, atau pengembang firmware ROM yang dimodifikasi.  Khususnya, segera setelah Anda menginstal aplikasi Anda sekali, Anda tidak dapat mengubah nilai <code>android:sharedUserId</code> Anda tanpa rasa sakit <code>android:sharedUserId</code> tanpa memblokir akses pengguna ke file yang ada ... karena Android tidak mengubah hak pemilik untuk file yang ada saat mengubah akun pengguna Linux, yang menjalankan aplikasi. </p><br><p>  Ada berbagai risiko ketika beberapa proses mengakses file.  Beberapa subsistem, seperti SQLite, memiliki logika bawaan untuk menyelesaikan masalah ini.  Tetapi jika Anda sendiri mengatur akses Anda sendiri ke file (misalnya, melalui <code>File</code> dan Java I / O), Anda perlu melakukan sesuatu dengan akses simultan, dan ini sulit. </p><br><p>  Anda juga perlu menangani situasi di mana satu aplikasi menghapus instalan dengan menghapus file yang digunakan aplikasi lain.  Dalam model hub-and-spoke, misalnya, dengan aplikasi dan satu set plugin, mungkin ini tidak terlalu berisiko.  Dalam model lain, di mana aplikasi lebih adil, Anda tidak dapat kehilangan data aplikasi Anda hanya karena pengguna memutuskan untuk menghapus beberapa aplikasi terpisah. </p><br><p>  Akhirnya, Anda tidak tahu apa yang bisa terjadi di masa depan.  Saat ini, Anda dapat melihat suite aplikasi Anda sebagai suite yang sangat erat.  Seseorang yang membeli aplikasi ini atau mengakuisisi perusahaan Anda mungkin ingin pergi ke arah lain.  Menggunakan kemampuan berbagi data yang terhubung <code>ContentProvider</code> , seperti <code>ContentProvider</code> , memberi Anda lebih banyak fleksibilitas.  Di dunia yang ideal, aplikasi Anda harus memperlakukan aplikasi lain sebagai sumber daya yang cukup andal, tetapi tidak selalu dapat diakses, seperti halnya layanan web Anda sendiri. </p><br><h2 id="kak-zapretit-polzovatelyam-rooted-ustroystv-dostup-k-moim-faylam-vo-vnutrennem-hranilische">  Bagaimana mencegah pengguna perangkat yang di-rooting mengakses file saya di penyimpanan internal? </h2><br><p>  Hanya saja, jangan menaruh file di penyimpanan internal.  Pengguna perangkat yang di-rooting dapat mengakses apa yang mereka butuhkan di perangkat, jadi satu-satunya cara untuk mencegah mereka mengakses data Anda adalah dengan tidak memilikinya di perangkat. </p><br><p>  Beberapa pengembang akan mencoba mengenkripsi file mereka dengan kata sandi yang dikodekan keras sehingga pengguna perangkat yang di-rooting tidak dapat menggunakan file-file ini.  Ini akan membuat efek dari speed bump untuk waktu yang singkat.  Yang diperlukan hanyalah satu orang yang tertarik untuk merekayasa balik aplikasi Anda, yang menentukan cara mendekripsi file-file ini, dan kemudian menulis pesan di blog atau forum tentang cara melakukan ini. </p><br><p>  Secara umum, relatif sedikit orang dengan perangkat yang di-rooting - Saya menilainya kurang dari 1%.  IMHO, Anda akan lebih berhasil dengan memfokuskan pekerjaan teknik Anda pada penulisan aplikasi yang lebih baik, daripada menghabiskan waktu melindungi dari perangkat yang di-rooting. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429338/">https://habr.com/ru/post/id429338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429324/index.html">Unreal Engine 4.21 Release</a></li>
<li><a href="../id429326/index.html">App Store tidak akan menelepon. Atau bagaimana saya membuat aplikasi saya, tetapi itu tidak akan menjangkau pengguna</a></li>
<li><a href="../id429328/index.html">Modul perangkat lunak untuk mendigitalkan dokumen yang rusak</a></li>
<li><a href="../id429330/index.html">Mitos dan legenda Agile - dari Firaun hingga saat ini</a></li>
<li><a href="../id429336/index.html">Komunikasi antara driver dan perangkat dengan metode _HID ACPI menggunakan GPIO dari pengontrol Lynxpoint sebagai contoh</a></li>
<li><a href="../id429340/index.html">Berpikir dua kali sebelum menggunakan Helm.</a></li>
<li><a href="../id429342/index.html">Angular 6+ adalah panduan injeksi ketergantungan lengkap. penyedia yang disediakan vs vs: []</a></li>
<li><a href="../id429344/index.html">Membaca Akhir Pekan: Sumber Daya Tuning Audio dan Desain Speaker</a></li>
<li><a href="../id429346/index.html">Untuk program master tanpa ujian: arah baru "Big Data" di Olimpiade "I am a Professional"</a></li>
<li><a href="../id429348/index.html">Kenapa di masa depan Agile tidak akan dibutuhkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>