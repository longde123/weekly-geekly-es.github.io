<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèª üë©üèº‚Äçüé® üèçÔ∏è La m√°quina de eventos protege el ciclo de vida üê† üë©üèº‚Äçü§ù‚Äçüë®üèæ üßí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Descargo de responsabilidad: este art√≠culo describe una soluci√≥n no obvia a un problema no obvio. Antes de apresurarse  huevos  Para ponerlo en pr√°cti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La m√°quina de eventos protege el ciclo de vida</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431048/"><blockquote>  Descargo de responsabilidad: este art√≠culo describe una soluci√≥n no obvia a un problema no obvio.  Antes de apresurarse <del>  huevos </del>  Para ponerlo en pr√°ctica, recomiendo leer el art√≠culo hasta el final y pensarlo dos veces. </blockquote><p><img src="https://habrastorage.org/webt/sb/cj/hs/sbcjhsnrjjqhgrl0xcpicmvzn40.png" alt="pero_por que"></p><br><p>  Hola a todos!  Cuando trabajamos con c√≥digo, a menudo tenemos que lidiar con el <em>estado</em> .  Uno de esos casos es el ciclo de vida de los objetos.  Administrar un objeto con varios estados posibles puede ser una tarea muy trivial.  Agregue la ejecuci√≥n asincr√≥nica aqu√≠ y la tarea se complica por un orden de magnitud.  Existe una soluci√≥n efectiva y natural.  En este art√≠culo hablar√© sobre la m√°quina de eventos y c√≥mo implementarla en Go. </p><a name="habracut"></a><br><h2 id="zachem-upravlyat-sostoyaniem">  ¬øPor qu√© administrar el estado? </h2><br><p>  Para comenzar, definamos el concepto mismo.  El ejemplo m√°s simple de un estado: archivos y varias conexiones.  No puedes simplemente tomar y leer un archivo.  Primero debe abrirse, y al final <del>  preferiblemente </del>  aseg√∫rese de cerrar  Resulta que la acci√≥n actual depende del resultado de la acci√≥n anterior: la lectura depende de la apertura.  El resultado guardado es el estado. </p><br><p>  El principal problema con el estado es la complejidad.  Cualquier estado complica autom√°ticamente el c√≥digo.  Debe almacenar los resultados de las acciones en la memoria y agregar varias comprobaciones a la l√≥gica.  Es por eso que las arquitecturas sin estado son tan atractivas para los programadores: nadie quiere <del>  problemas </del>  dificultades  Si los resultados de sus acciones no afectan la l√≥gica de ejecuci√≥n, no necesita un estado. </p><br><p>  Sin embargo, hay una propiedad que te hace tener en cuenta las dificultades.  Un estado requiere que sigas un orden espec√≠fico de acciones.  En general, tales situaciones deben evitarse, pero esto no siempre es posible.  Un ejemplo es el ciclo de vida de los objetos del programa.  Gracias a la buena gesti√≥n del estado, se puede obtener un comportamiento predecible de los objetos con un ciclo de vida complejo. </p><br><p>  Ahora veamos c√≥mo hacerlo <em>bien</em> . </p><br><h2 id="avtomat-kak-sposob-resheniya-problem">  Autom√°tico como una forma de resolver problemas </h2><br><p><img src="https://habrastorage.org/webt/eg/qd/1o/egqd1oejaztizauope6waesapm0.jpeg" alt="AK74"></p><br><p>  Cuando la gente habla de estados, las m√°quinas de estados finitos vienen inmediatamente a la mente.  Es l√≥gico, porque un aut√≥mata es la forma m√°s natural de administrar un estado. </p><br><blockquote>  No profundizar√© en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teor√≠a de los aut√≥matas</a> ; hay informaci√≥n m√°s que suficiente en Internet. </blockquote><p>  Si busca ejemplos de m√°quinas de estado finito para Go, definitivamente se encontrar√° con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lexer de Rob Pike</a> .  Un gran ejemplo de un aut√≥mata en el que los datos procesados ‚Äã‚Äãson el alfabeto de entrada.  Esto significa que las transiciones de estado son causadas por el texto que procesa el lexer.  Soluci√≥n elegante a un problema espec√≠fico. </p><br><p>  Lo principal a entender es que un aut√≥mata es una soluci√≥n a un problema estrictamente espec√≠fico.  Por lo tanto, antes de considerarlo como un remedio para todos los problemas, debe comprender completamente la tarea.  Espec√≠ficamente, la entidad que desea controlar: </p><br><ul><li>  estados - ciclo de vida; </li><li>  eventos: qu√© causa exactamente la transici√≥n a cada estado; </li><li>  resultado del trabajo - datos de salida; </li><li>  modo de ejecuci√≥n (s√≠ncrono / as√≠ncrono); </li><li>  Principales casos de uso. </li></ul><br><p>  El lexer es hermoso, pero solo cambia de estado debido a los datos que procesa.  Pero, ¬øqu√© pasa con la situaci√≥n cuando el usuario invoca transiciones?  Aqu√≠ es donde la m√°quina de eventos puede ayudar. </p><br><h2 id="realnyy-primer">  Ejemplo real </h2><br><p> Para aclararlo, analizar√© un ejemplo de la biblioteca de <code>phono</code> . </p><br><blockquote>  Para una inmersi√≥n completa en el contexto, puede leer el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo introductorio</a> .  Esto no es necesario para este tema, pero ayudar√° a comprender mejor lo que estamos gestionando. </blockquote><br><h3 id="a-chem-upravlyaem">  ¬øY qu√© estamos gestionando? </h3><br><p>  <code>phono</code> se basa en la tuber√≠a DSP.  Consiste en tres etapas de procesamiento.  Cada etapa puede incluir de uno a varios componentes: </p><br><p><img src="https://habrastorage.org/webt/go/ym/ep/goymepjg4pds_picireejjsshnq.png" alt="pipe_diagram"></p><br><ol><li>  <code>pipe.Pump</code> (bomba inglesa) es una etapa obligatoria de <strong>recepci√≥n de</strong> sonido, siempre solo un componente. </li><li>  <code>pipe.Processor</code> (controlador en ingl√©s): una etapa opcional <strong>de procesamiento de</strong> sonido, de 0 a N componentes. </li><li>  <code>pipe.Sink</code> (sumidero ingl√©s): una etapa obligatoria <strong>de transmisi√≥n de</strong> sonido, de 1 a N componentes. </li></ol><br><p>  En realidad, gestionaremos el ciclo de vida del transportador. </p><br><h3 id="zhiznennyy-cikl">  Ciclo de vida </h3><br><p>  As√≠ es como se ve el diagrama del estado de la <code>pipe.Pipe</code> . </p><br><p><img src="https://habrastorage.org/webt/le/ni/xq/lenixqpvoh0zaq9j2aftrqprtvg.png" alt="pipe_lifecycle"></p><br><p>  <em>La cursiva</em> indica transiciones causadas por la l√≥gica de ejecuci√≥n interna.  <strong>Negrita</strong> : transiciones causadas por eventos.  El diagrama muestra que los estados se dividen en 2 tipos: </p><br><ul><li>  <strong>estados inactivos</strong> : <code>ready</code> y en <code>paused</code> , solo puede saltar de ellos por evento </li><li>  <em>estados activos</em> : <code>running</code> y <code>pausing</code> , transiciones por evento y debido a la l√≥gica de ejecuci√≥n </li></ul><br><p>  Antes de un an√°lisis detallado del c√≥digo, un claro ejemplo del uso de todos los estados: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// PlayWav  .wav    portaudio  -. func PlayWav(wavFile string) error { bufferSize := phono.BufferSize(512) //      w, err := wav.NewPump(wavFile, bufferSize) //  wav pump if err != nil { return err } pa := portaudio.NewSink( //  portaudio sink bufferSize, w.WavSampleRate(), w.WavNumChannels(), ) p := pipe.New( //  pipe.Pipe    ready w.WavSampleRate(), pipe.WithPump(w), pipe.WithSinks(pa), ) p.Run() //    running   p.Run() errc := p.Pause() //    pausing   p.Pause() err = pipe.Wait(errc) //     paused if err != nil { return err } errc = p.Resume() //    running   p.Resume() err = pipe.Wait(errc) //     ready if err != nil { return err } return pipe.Wait(p.Close()) //      }</span></span></code> </pre> <br><p>  Ahora, lo primero es lo primero. </p><br><blockquote>  Todo el c√≥digo fuente est√° disponible en el <a href="">repositorio</a> . </blockquote><br><h3 id="sostoyaniya-i-sobytiya">  Estados y eventos </h3><br><p>  Comencemos con lo m√°s importante. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// state      . type state interface { listen(*Pipe, target) (state, target) //    transition(*Pipe, eventMessage) (state, error) //   } // idleState  .        . type idleState interface { state } // activeState  .         //   . type activeState interface { state sendMessage(*Pipe) state //    } //  . type ( idleReady struct{} activeRunning struct{} activePausing struct{} idlePaused struct{} ) //  . var ( ready idleReady running activeRunning paused idlePaused pausing activePausing )</span></span></code> </pre> <br><p>  Gracias a tipos separados, las transiciones tambi√©n se declaran por separado para cada estado.  Esto evita lo enorme <del>  salchichas </del>  funciones de transici√≥n con <code>switch</code> anidadas.  Los estados en s√≠ no contienen ning√∫n dato o l√≥gica.  Para ellos, puede declarar variables a nivel de paquete para que no lo haga todo el tiempo.  La interfaz de <code>state</code> es necesaria para el polimorfismo.  <code>activeState</code> de <code>activeState</code> e <code>idleState</code> poco m√°s tarde. </p><br><p>  La segunda parte m√°s importante de nuestra m√°quina son los eventos. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// event  . type event int //  . const ( run event = iota pause resume push measure cancel ) // target      . type target struct { state idleState //   errc chan error //   ,     } // eventMessage   ,    . type eventMessage struct { event //   params params //   components []string // id  target //      }</span></span></code> </pre> <br><p>  Para comprender por qu√© se necesita el tipo de <code>target</code> , considere un ejemplo simple.  Hemos creado un nuevo transportador, est√° <code>ready</code> .  Ahora ejec√∫telo con <code>p.Run()</code> .  El evento de <code>run</code> se env√≠a a la m√°quina, la tuber√≠a pasa al estado de <code>running</code> .  ¬øC√≥mo saber cu√°ndo se termina el transportador?  Aqu√≠ es donde el tipo de <code>target</code> nos ayudar√°.  Indica qu√© estado de descanso esperar despu√©s del evento.  En nuestro ejemplo, una vez completado el trabajo, la tuber√≠a volver√° a entrar en el estado <code>ready</code> .  Lo mismo en el diagrama: </p><br><p><img src="https://habrastorage.org/webt/h8/4i/xv/h84ixvb5dd_2gdbnrcd3kggwyzg.png"></p><br><p>  Ahora m√°s sobre los tipos de estados.  M√°s precisamente, sobre las <code>activeState</code> <code>idleState</code> y <code>activeState</code> .  Veamos las funciones de <code>listen(*Pipe, target) (state, target)</code> para diferentes tipos de etapas: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// listen     ready. func (s idleReady) listen(p *Pipe, t target) (state, target) { return p.idle(s, t) } // listen     running. func (s activeRunning) listen(p *Pipe, t target) (state, target) { return p.active(s, t) }</span></span></code> </pre> <br><p>  <code>pipe.Pipe</code> tiene diferentes funciones para esperar una transici√≥n.  Que hay </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// idle     .    . func (p *Pipe) idle(s idleState, t target) (state, target) { if s == t.state || s == ready { t = t.dismiss() //  ,  target } for { var newState state var err error select { case e := &lt;-p.events: //   newState, err = s.transition(p, e) //    if err != nil { e.target.handle(err) } else if e.hasTarget() { t.dismiss() t = e.target } } if s != newState { return newState, t // ,    } } } // active     .     , //   . func (p *Pipe) active(s activeState, t target) (state, target) { for { var newState state var err error select { case e := &lt;-p.events: //   newState, err = s.transition(p, e) //    if err != nil { //  ? e.target.handle(err) // ,    } else if e.hasTarget() { // ,  target t.dismiss() //   t = e.target //   } case &lt;-p.provide: //     newState = s.sendMessage(p) //    case err, ok := &lt;-p.errc: //   if ok { //   ,  interrupt(p.cancel) //   t.handle(err) //    } //    ,  return ready, t //    ready } if s != newState { return newState, t // ,    } } }</span></span></code> </pre> <br><p>  Por lo tanto, podemos escuchar diferentes canales en diferentes estados.  Por ejemplo, esto le permite no enviar mensajes durante una pausa, simplemente no escuchamos el canal correspondiente. </p><br><h3 id="konstruktor-i-start-avtomata">  Constructor y arranque de la m√°quina. </h3><br><p><img src="https://habrastorage.org/webt/bk/h2/zn/bkh2znujbo_omto9lyhcq-ixp-e.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// New      . //      ready. func New(sampleRate phono.SampleRate, options ...Option) *Pipe { p := &amp;Pipe{ UID: phono.NewUID(), sampleRate: sampleRate, log: log.GetLogger(), processors: make([]*processRunner, 0), sinks: make([]*sinkRunner, 0), metrics: make(map[string]measurable), params: make(map[string][]phono.ParamFunc), feedback: make(map[string][]phono.ParamFunc), events: make(chan eventMessage, 1), //    cancel: make(chan struct{}), //     provide: make(chan struct{}), consume: make(chan message), } for _, option := range options { //   option(p)() } go p.loop() //    return p }</span></span></code> </pre> <br><p>  Adem√°s de la inicializaci√≥n y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las opciones funcionales</a> , existe el inicio de una rutina de rutina separada con el ciclo principal.  Bueno, m√≠ralo: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// loop ,     nil . func (p *Pipe) loop() { var s state = ready //   t := target{} for s != nil { s, t = s.listen(p, t) //      p.log.Debug(fmt.Sprintf("%v is %T", p, s)) } t.dismiss() close(p.events) //    } // listen     ready. func (s idleReady) listen(p *Pipe, t target) (state, target) { return p.idle(s, t) } // transition       . func (s idleReady) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) return nil, nil case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil case measure: for _, id := range e.components { e.params.applyTo(id) } return s, nil case run: if err := p.start(); err != nil { return s, err } return running, nil } return s, ErrInvalidState }</span></span></code> </pre> <br><p>  El transportador se crea y se congela en previsi√≥n de eventos. </p><br><h3 id="pora-rabotat">  Hora de trabajar </h3><br><p>  Llame a <code>p.Run()</code> ! </p><br><p><img src="https://habrastorage.org/webt/wv/vi/vs/wvvivsokwwjkjvvcibg-kyvi9m0.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Run   run  . //     pipe.Close  . func (p *Pipe) Run() chan error { runEvent := eventMessage{ event: run, target: target{ state: ready, //    errc: make(chan error, 1), }, } p.events &lt;- runEvent return runEvent.target.errc } // listen     running. func (s activeRunning) listen(p *Pipe, t target) (state, target) { return p.active(s, t) } // transition       . func (s activeRunning) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) err := Wait(p.errc) return nil, err case measure: e.params.applyTo(p.ID()) p.feedback = p.feedback.merge(e.params) return s, nil case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil case pause: return pausing, nil } return s, ErrInvalidState } // sendMessage   . func (s activeRunning) sendMessage(p *Pipe) state { p.consume &lt;- p.newMessage() return s }</span></span></code> </pre> <br><p>  <code>running</code> genera mensajes y se ejecuta hasta que se complete la canalizaci√≥n. </p><br><h3 id="sdelay-pauzu">  Pausa </h3><br><p>  Durante la ejecuci√≥n del transportador, podemos pausarlo.  En este estado, la canalizaci√≥n no generar√° nuevos mensajes.  Para hacer esto, llame al m√©todo <code>p.Pause()</code> . </p><br><p><img src="https://habrastorage.org/webt/-2/9k/xz/-29kxztxwy56ftsphj9-blcbkei.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Pause   pause  . //     pipe.Close  . func (p *Pipe) Pause() chan error { pauseEvent := eventMessage{ event: pause, target: target{ state: paused, //    errc: make(chan error, 1), }, } p.events &lt;- pauseEvent return pauseEvent.target.errc } // listen     pausing. func (s activePausing) listen(p *Pipe, t target) (state, target) { return p.active(s, t) } // transition       . func (s activePausing) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) err := Wait(p.errc) return nil, err case measure: e.params.applyTo(p.ID()) p.feedback = p.feedback.merge(e.params) return s, nil case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil } return s, ErrInvalidState } // sendMessage   .   -, //      .    //    ,      .  , // ,   , : // 1.     // 2.      func (s activePausing) sendMessage(p *Pipe) state { m := p.newMessage() if len(m.feedback) == 0 { m.feedback = make(map[string][]phono.ParamFunc) } var wg sync.WaitGroup //     wg.Add(len(p.sinks)) //   Sink for _, sink := range p.sinks { param := phono.ReceivedBy(&amp;wg, sink.ID()) // - m.feedback = m.feedback.add(param) } p.consume &lt;- m //   wg.Wait() // ,     return paused }</span></span></code> </pre> <br><p>  Tan pronto como todos los destinatarios reciban el mensaje, la canalizaci√≥n entrar√° <code>paused</code> estado de <code>paused</code> .  Si el mensaje es el √∫ltimo, se producir√° la transici√≥n al estado <code>ready</code> . </p><br><h3 id="snova-za-rabotu">  De vuelta al trabajo! </h3><br><p>  Para salir del estado en <code>paused</code> , llame a <code>p.Resume()</code> . </p><br><p><img src="https://habrastorage.org/webt/vq/gu/dj/vqgudjnhdlifwyb6acyrkpbmkek.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Resume   resume  . //     pipe.Close  . func (p *Pipe) Resume() chan error { resumeEvent := eventMessage{ event: resume, target: target{ state: ready, errc: make(chan error, 1), }, } p.events &lt;- resumeEvent return resumeEvent.target.errc } // listen     paused. func (s idlePaused) listen(p *Pipe, t target) (state, target) { return p.idle(s, t) } // transition       . func (s idlePaused) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) err := Wait(p.errc) return nil, err case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil case measure: for _, id := range e.components { e.params.applyTo(id) } return s, nil case resume: return running, nil } return s, ErrInvalidState }</span></span></code> </pre> <br><p>  Aqu√≠ todo es trivial, la tuber√≠a vuelve a <code>running</code> . </p><br><h3 id="svorachivaemsya">  Acurrucarse </h3><br><p>  El transportador se puede detener desde cualquier estado.  Hay <code>p.Close()</code> . </p><br><p><img src="https://habrastorage.org/webt/va/lt/tz/valttzm_l7cqsibb6mi1ntxh6vy.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Close   cancel  . //      . //    ,   . func (p *Pipe) Close() chan error { resumeEvent := eventMessage{ event: cancel, target: target{ state: nil, //   errc: make(chan error, 1), }, } p.events &lt;- resumeEvent return resumeEvent.target.errc }</span></span></code> </pre> <br><h2 id="komu-eto-nado">  ¬øQui√©n necesita esto? </h2><br><p>  No es para todos.  Para comprender exactamente c√≥mo administrar el estado, debe comprender su tarea.  Hay exactamente dos circunstancias en las que <em>puede</em> usar una m√°quina asincr√≥nica basada en eventos: </p><br><ol><li>  Ciclo de vida complejo: hay tres o m√°s estados con transiciones no lineales. </li><li>  Se utiliza la ejecuci√≥n asincr√≥nica. </li></ol><br><p>  Aunque la m√°quina de eventos resuelve el problema, es un patr√≥n bastante complicado.  Por lo tanto, debe usarse con mucho cuidado y solo despu√©s de una comprensi√≥n completa de todos los pros y los contras. </p><br><h2 id="ssylki">  Referencias </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">phono</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lexer Rob Pike</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431048/">https://habr.com/ru/post/es431048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431036/index.html">"El mundo entero - an√°lisis" o "Analizarlo"</a></li>
<li><a href="../es431040/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 340 (19 al 25 de noviembre de 2018)</a></li>
<li><a href="../es431042/index.html">PHP Digest No. 144 (12-26 de noviembre de 2018)</a></li>
<li><a href="../es431044/index.html">La fiscal√≠a pagar√° por primera vez el bloqueo ilegal del sitio.</a></li>
<li><a href="../es431046/index.html">C√≥mo funciona realmente el √≠ndice z</a></li>
<li><a href="../es431050/index.html">La ilusi√≥n de la pureza: ¬øla mineralizaci√≥n del agua afecta su calidad y c√≥mo nos ayudar√° el medidor TDS?</a></li>
<li><a href="../es431052/index.html">Frontend DevDay: mapas, equipos, dos consultas</a></li>
<li><a href="../es431056/index.html">USPACE: Drones Time</a></li>
<li><a href="../es431058/index.html">Primeros pasos con Unicorn Engine</a></li>
<li><a href="../es431060/index.html">Suplantaci√≥n de identidad alemana con autenticaci√≥n en l√≠nea y financiaci√≥n de refugiados en Alemania</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>