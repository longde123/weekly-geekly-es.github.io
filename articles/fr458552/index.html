<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµüèº ü•ô ‚õπüèø √Ä propos de la comparaison des formats de stockage dans Hadoop: commen√ßons par ORC üëáüèª üöÉ üë®üèø‚Äçü§ù‚Äçüë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hadoop comprend des produits qui peuvent fonctionner avec des fichiers de diff√©rents formats. J'ai cherch√©, lu et r√©fl√©chi √† plusieurs reprises sur le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Ä propos de la comparaison des formats de stockage dans Hadoop: commen√ßons par ORC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfastrah/blog/458552/"><p>  Hadoop comprend des produits qui peuvent fonctionner avec des fichiers de diff√©rents formats.  J'ai cherch√©, lu et r√©fl√©chi √† plusieurs reprises sur le meilleur format.  Quand je suis tomb√© sur le format ORC de mani√®re relativement al√©atoire, je me suis int√©ress√©, j'ai lu (et m√™me un peu choy√©), et c'est ce que j'ai compris - il est incorrect de comparer les formats en tant que tels.  Plus pr√©cis√©ment, ils sont g√©n√©ralement compar√©s, √† mon avis, de mani√®re incorrecte.  En fait, un article √† ce sujet, ainsi que sur le format Apache ORC (en termes techniques) et les opportunit√©s qu'il offre. </p><br><p>  Je vais commencer par la question: quelle peut √™tre la taille d'une table relationnelle (en octets et tr√®s approximativement), compos√©e de 10 000 lignes (deux champs entiers par ligne)?  Habituellement, ils mettent un kat ici, et la r√©ponse est plac√©e sous le kat - je r√©pondrai ici: 628 octets.  Et les d√©tails et l'histoire seront transf√©r√©s sous cat. </p><a name="habracut"></a><br><p>  Comment tout a commenc√©: j'ai construit une biblioth√®que pour travailler avec Apache ORC (voir la page d'accueil du projet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://orc.apache.org</a> ) et compil√© leur propre exemple d'√©criture dans ORC (pour vous casser la t√™te - nous commen√ßons par ce qui fonctionne) , il contenait 2 champs et 10 000 lignes.  Je l'ai commenc√© - j'ai re√ßu le fichier orc, parce que je l'ai fait quelque part en dehors du bureau - juste au cas o√π, j'ai r√©√©crit la biblioth√®que et le fichier sur un lecteur flash (press√© - je n'ai pas regard√© la taille, je pense que le lecteur flash peut le g√©rer). </p><br><p>  Mais en quelque sorte j'ai rapidement correspondu ... J'ai regard√© la taille - 628 octets.  J'ai pens√© que c'√©tait une erreur, je me suis assis et j'ai commenc√© √† comprendre.  J'ai lanc√© l'utilitaire pour visualiser ORC √† partir de la m√™me biblioth√®que compil√©e - le contenu du fichier montre que tout est honn√™te - 10 000 lignes.  Apr√®s cela, je me suis demand√© comment 10 000 lignes pouvaient tenir dans 628 octets (je connaissais d√©j√† un peu ORC √† ce moment-l√† et j'ai r√©alis√© qu'il y avait aussi des m√©tadonn√©es - le format √©tait autosuffisant).  Compris, partagez. </p><br><h2 id="o-formate-orc">  √Ä propos du format ORC </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/85d/d6c/e83/85dd6ce839b506e8033b3a6683c0c58c.png" alt="image"></p><br><p> Je ne r√©p√©terai pas ici des mots g√©n√©raux sur le format - voir le lien ci-dessus, il est bien √©crit l√†-bas.  Je vais me concentrer sur deux adjectifs en excellente forme de l'image ci-dessus (la photo est tir√©e de la page d'accueil du projet): essayons de comprendre pourquoi ORC est "le plus rapide" et "le plus compact". </p><br><h1 id="skorost">  La vitesse </h1><br><p>  La vitesse peut √™tre diff√©rente, en ce qui concerne les donn√©es - au moins la vitesse de lecture ou d'√©criture (vous pouvez aller plus loin, mais arr√™tons pour l'instant).  Puisque Hadoop est explicitement mentionn√© dans le slogan ci-dessus, nous consid√©rerons principalement la vitesse de lecture. </p><br><p>  Pour citer un peu plus de la documentation ORC: </p><br><blockquote>  Il est optimis√© pour les grandes lectures en continu, mais avec un support int√©gr√© pour trouver rapidement les lignes requises.  Le stockage des donn√©es dans un format en colonnes permet au lecteur de lire, d√©compresser et traiter uniquement les valeurs requises pour la requ√™te en cours. </blockquote><p>  Je vais traduire un peu: </p><br><ul><li>  format optimis√© pour la lecture en continu de gros volumes </li><li>  contient en m√™me temps un support pour la recherche rapide des lignes n√©cessaires </li><li>  vous permet de lire uniquement les donn√©es dont vous avez besoin </li></ul><br><h1 id="razmer">  La taille </h1><br><p>  Il n'y avait pas de citation, je dirai avec mes propres mots </p><br><ul><li>  format stocke de mani√®re optimale les m√©ta-informations </li><li>  trouver un √©quilibre entre la vitesse de lecture en continu et le stockage compact </li><li>  prise en charge int√©gr√©e pour le stockage le plus compact des valeurs de colonne </li></ul><br><h2 id="predostavlenie-vozmozhnostey">  Offrir des opportunit√©s </h2><br><p>  Je veux attirer votre attention sur le libell√© des citations ci-dessus: "optimis√© pour ...", "contient un support ...", "vous permet de lire ..." - le format de fichier, en tant que langage de programmation, est un moyen (dans ce cas, fournir stockage efficace et acc√®s aux donn√©es).  L'efficacit√© du stockage et de l'acc√®s aux donn√©es d√©pend non seulement de l'outil, mais aussi de qui l'utilise et comment. </p><br><p>  Voyons quel format le format offre pour la vitesse et la compacit√©. </p><br><h1 id="kolonchatoe-hranenie-i-straypy">  Rangement de colonne et bande </h1><br><p>  Les donn√©es de l'ORC sont stock√©es sous forme de colonnes, tout d'abord elles affectent la taille.  Pour assurer la vitesse de lecture en continu, le fichier est divis√© en ce que l'on appelle des "bandes", chaque bande est autosuffisante, c'est-√†-dire  peut √™tre lu s√©par√©ment (et, par cons√©quent, en parall√®le).  En raison des bandes, la taille du fichier augmentera (les valeurs de colonne non uniques seront stock√©es plusieurs fois - dans les bandes o√π ces valeurs se produisent) - le m√™me √©quilibre de "vitesse - taille" (c'est un compromis). </p><br><h1 id="indeksy">  Indices </h1><br><p>  Le format ORC implique des index qui vous permettent de d√©terminer si la bande (ou plut√¥t, les parties de bande de 10 000 lignes chacune, le soi-disant "groupe de lignes") contient les donn√©es souhait√©es ou non.  Les index sont construits sur chacune des colonnes.  Cela affecte la vitesse de lecture et augmente la taille.  Lors de la lecture en continu d'index de lecture, d'ailleurs, vous ne pouvez pas lire. </p><br><h1 id="szhatie">  La compression </h1><br><p>  Toutes les m√©tadonn√©es sont stock√©es sous forme compress√©e, et cela </p><br><ul><li>  informations statistiques et descriptives (le format vous permet de recr√©er la table qui y est stock√©e, y compris les noms et types de champs) </li><li>  indices </li><li>  informations de partitionnement (en bandes et en flux) </li></ul><br><p>  (ci-dessous, nous verrons que les m√©tadonn√©es sont une partie essentielle du fichier) </p><br><p>  Les valeurs des colonnes sont √©galement stock√©es sous forme compress√©e.  Dans le m√™me temps, il est possible de lire et de d√©compresser uniquement le bloc de donn√©es n√©cessaire (c'est-√†-dire qu'aucun fichier n'est compress√© et pas une bande enti√®re).  La compression affecte √† la fois la taille et la vitesse de lecture. </p><br><h1 id="kodirovanie">  Codage </h1><br><p>  Les valeurs des colonnes - et le fichier stocke exactement ces valeurs - sont stock√©es sous forme cod√©e.  Dans la version actuelle du format (ORC v1) pour les entiers, par exemple, 4 options d'encodage sont disponibles.  En m√™me temps, la colonne enti√®re n'est pas cod√©e, des parties de la colonne sont cod√©es, chaque partie peut √™tre cod√©e de mani√®re optimale pour cette partie (ces parties sont appel√©es "ex√©cuter" dans la sp√©cification).  Ainsi, la minimisation de la longueur totale des donn√©es stock√©es est obtenue.  Encore une fois, l'effet sur la taille et la vitesse. </p><br><h2 id="posmotrim-orc-fayl">  Voyons le fichier ORC </h2><br><p>  Regardons tr√®s bri√®vement ce qui se trouve √† l'int√©rieur du fichier ORC (celui-ci fait 628 octets).  Pour ceux qui ne sont pas tr√®s int√©ress√©s par les d√©tails techniques, faites d√©filer jusqu'√† la section suivante (sur la comparaison des formats). </p><br><p>  Voici comment notre table a √©t√© d√©finie dans l'exemple d'enregistrement dans ORC: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/af7/bb2/a01/af7bb2a019f050cbc47ec9e2c8152a2b.png" alt="image"></p><br><h1 id="metadannye">  M√©tadonn√©es </h1><br><p>  Informations sur les longueurs (je donne des captures d'√©cran du cahier jupyter, je pense que c'est assez clair) </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d3e/e1f/398/d3ee1f39809cccf7fc9523df72bb2def.png" alt="image"></p><br><p>  Ce que nous voyons ici: </p><br><ul><li>  dans la "tige" (et c'est Postscript + Footer + Metadata) seulement 1 + 23 + 115 + 50 = 189 octets </li><li>  sur une seule bande, seulement 3 + 436 = 439 octets, total 628 octets </li><li>  la bande contient un index (73 octets), des donn√©es (276 octets), un pied de page (87 octets) </li></ul><br><p>  Faisons attention ici au rapport du volume de donn√©es et des m√©tadonn√©es (276 √† 352 octets).  Mais ces 276 octets de donn√©es ne sont pas seulement des donn√©es, les donn√©es contiennent un peu de ¬´superflu¬ª (ici pour des raisons de bri√®vet√©, je ne donne pas de captures d'√©cran - c'est long avec elles, je ne g√©rerai qu'avec mes commentaires), qui est inclus dans les donn√©es: </p><br><ul><li>  PRESENT flux pour chaque colonne, il y en a trois (y compris une structure de pseudo-colonne commune) - 20 octets par chacun, total 60 octets </li><li>  flux de donn√©es (ici la pseudo-colonne n'est pas repr√©sent√©e) - 103 et 113 octets (colonnes "x" et "y", respectivement) </li></ul><br><p>  Les flux PRESENT sont des cha√Ænes de bits qui vous permettent de savoir o√π les colonnes sont NULL.  Pour notre exemple, leur pr√©sence semble √©trange (dans les statistiques de notre fichier, il est clairement √©crit qu'il n'y a pas de NULL dans les donn√©es - pourquoi alors inclure PRESENT? Cela semble √™tre un d√©faut ...) </p><br><p>  Au total, les donn√©es elles-m√™mes occupent 216 octets, les m√©tadonn√©es - 352. </p><br><p>  Il ressort √©galement des m√©tadonn√©es que les deux colonnes sont cod√©es √† l'aide de la m√©thode DIRECT_V2 (pour les entiers, elle permet 4 types de repr√©sentations, je me r√©f√®re √† la sp√©cification pour plus de d√©tails - c'est sur le site web du projet). </p><br><h1 id="dannye">  Les donn√©es </h1><br><p>  Voyons (encore une fois sans captures d'√©cran pour plus de bri√®vet√©) comment 10 000 nombres tiennent dans 103 octets (pour la colonne "x"): </p><br><ul><li>  le codage delta est utilis√©, dans lequel les param√®tres sont la valeur initiale et le pas (un peu simplifi√© par souci de concision) </li><li>  nous avons toujours 1 √©tape, la valeur initiale pour la premi√®re ex√©cution est 0, puis 511, 1022, etc. </li><li>  run (un ensemble de donn√©es cod√©es d'une seule mani√®re) contient dans notre cas 511 valeurs (la valeur maximale possible pour le codage delta) </li><li>  la longueur de chaque ex√©cution dans le fichier est de 4 √† 6 octets (la longueur de l'ex√©cution augmente du fait que la valeur initiale est repr√©sent√©e en zigzag) </li><li>  total pour la colonne "x" nous obtenons dans le fichier 20 run-s avec une longueur totale de 103 octets (j'ai v√©rifi√© - tout s'embo√Æte) </li></ul><br><p>  Pour conclure l'examen de la pr√©sentation de notre simple tableau dans un fichier, je dirai que les indices dans cet exemple sont d√©g√©n√©r√©s - ils indiquent le d√©but du flux de donn√©es.  Je traiterai les index √† l'aide d'exemples concrets; je les d√©crirai probablement dans un article s√©par√©. </p><br><p>  Pour les int√©ress√©s: sous le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> vous trouverez le cahier jupyter, dans lequel j'ai "compris" le format interne.  Vous pouvez l'utiliser et r√©p√©ter (le fichier ORC y est √©galement joint). </p><br><p>  Je suis s√ªr que de nombreux lecteurs sont "perdus" - oui, le format ORC n'est pas simple (√† la fois en termes de compr√©hension des d√©tails et en termes d'utilisation des fonctionnalit√©s fournies). </p><br><h2 id="o-sravnenii-formatov">  √Ä propos de la comparaison des formats </h2><br><p>  Passons maintenant au point principal - comparaison de format incorrecte. </p><br><p>  Fr√©quence de comparaison des formats: comparons la taille des fichiers aux formats A et B, la vitesse de lecture (diff√©rents types de lecture - al√©atoire, streaming, etc.) aux formats A et B. Compar√©, nous avons conclu que le format A est meilleur que le format B. </p><br><p>  En utilisant l'exemple du dernier des outils de compacit√© (encodage) √©num√©r√©s ci-dessus: les donn√©es peuvent-elles √™tre encod√©es de mani√®re optimale dans l'ORC?  Oui, il existe des opportunit√©s - voir ci-dessus.  Mais tout aussi bien, vous ne pouvez pas faire √ßa!  Cela d√©pend de ¬´l'√©crivain¬ª (√©crivain dans la terminologie ORC): dans l'exemple ci-dessus, l'√©crivain pourrait le faire.  Mais il pourrait simplement √©crire 2 fois en 10 000 nombres et ce serait √©galement correct en termes de format.  <strong>En comparant les formats "par taille", nous comparons non seulement et pas tant les formats que la qualit√© algorithmique des syst√®mes d'application utilisant ces formats</strong> . </p><br><p>  Qui est "l'√©crivain" dans Hadoop?  Il y en a beaucoup - par exemple, Hive, qui cr√©e une table qui stocke ses donn√©es dans des fichiers au format ORC.  En comparant, par exemple, ORC avec Parquet dans Hadoop, nous √©valuons en fait la qualit√© de mise en ≈ìuvre de l'algorithme de conversion de donn√©es impl√©ment√© dans Hive.  Nous ne comparons pas les formats (en tant que tels). </p><br><p>  <strong>Caract√©ristique importante de Hadoop</strong> </p><br><p>  Dans le monde relationnel classique, nous n'avions aucun moyen d'influencer la taille de la table dans Oracle - elle √©tait en quelque sorte stock√©e et seul Oracle savait comment.  Dans Hadoop, la situation est l√©g√®rement diff√©rente: nous pouvons voir comment telle ou telle table est stock√©e (dans quelle mesure Hive, par exemple, a r√©ussi √† la ¬´coder¬ª).  Et, si nous voyons que cela peut √™tre am√©lior√©, nous avons une r√©elle opportunit√© pour cela: cr√©er notre propre fichier ORC plus optimal et le donner √† Hive en tant que table externe. </p><br><h2 id="sravnim-orc-i-qvd">  Comparer ORC et QVD </h2><br><p>  J'ai r√©cemment d√©crit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le format QVD</a> que QlikVew / QlikSense utilise activement.  Illustrons tr√®s bri√®vement ces deux formats en termes de capacit√©s qu‚Äôils offrent pour atteindre une vitesse de lecture maximale et minimiser la taille.  Les capacit√©s d'ORC sont d√©crites ci-dessus, comme dans QVD: </p><br><h1 id="kolonchatoe-hranenie">  Stockage sur colonne </h1><br><p>  QVD peut √™tre consid√©r√© comme un format ¬´en colonnes¬ª, il n'y a pas de duplication des valeurs des colonnes - des valeurs uniques sont stock√©es une fois.  MAIS il ne permet pas le traitement parall√®le - vous devez d'abord lire enti√®rement les valeurs de toutes les colonnes, puis vous pouvez lire les lignes en parall√®le. </p><br><p>  Et il y a duplication au niveau des lignes - les lignes stockent des valeurs d'index en double dans une table de caract√®res. </p><br><h1 id="szhatie-1">  La compression </h1><br><p>  Je n'ai pas rencontr√© de fichiers QVD compress√©s - je n'ai pas r√©ussi - il y a une telle balise dans les m√©tadonn√©es, peut-√™tre que chacune des parties sur lesquelles il y a un d√©calage et une longueur dans les m√©tadonn√©es (et c'est chaque table de caract√®res et la table de cha√Ænes enti√®re) peut √™tre compress√©e.  Dans ce cas, une lecture parall√®le des lignes est "au revoir" ... </p><br><h1 id="indeksy-1">  Indices </h1><br><p>  Il n'y a aucun moyen de comprendre dans le fichier QVD quelle partie de celui-ci doit √™tre lue.  En pratique, vous devez analyser la table des caract√®res octet par octet (chacun!), Pas tr√®s efficace ... </p><br><h1 id="kodirovanie-1">  Codage </h1><br><p>  Le codage dans QVD n'est pas utilis√©, il est possible de faire une analogie de l'index binaire dans une table de cha√Ænes avec codage, mais cette analogie est "compens√©e" par la duplication des nombres par des cha√Ænes dans les tables de caract√®res (pour plus de d√©tails, consultez bri√®vement l'article - la valeur de la colonne est souvent repr√©sent√©e par le nombre ET la cha√Æne). </p><br><p>  La conclusion de cette br√®ve comparaison que j'ai personnellement formul√©e est la suivante: le format QVD ne contient pratiquement pas de capacit√©s permettant un stockage compact et une lecture rapide des donn√©es contenues dans des fichiers de ce format. </p><br><p>  (Cela semblait quelque peu offensant pour QVD, j'ajouterai un peu - le format a √©t√© cr√©√© il y a longtemps, seul QlikView / QlikSense est utilis√©, et ils "stockent" toutes les donn√©es en m√©moire. Je pense que le fichier QVD est simplement lu tout "tel quel" en m√©moire, puis ces merveilleux produits BI √† tous √©gards fonctionnent tr√®s rapidement avec cette pr√©sentation - les voil√† ma√Ætres ...) </p><br><h2 id="vmesto-zaklyucheniya">  Au lieu d'une conclusion </h2><br><p>  Il a critiqu√© et n'a encore rien offert ... - Je sugg√®re. </p><br><p>  Il me semble que les formats doivent √™tre compar√©s non pas par l'exemple de leur impl√©mentation sp√©cifique, les formats doivent √™tre compar√©s en termes des outils qui y sont inclus et de la capacit√© √† utiliser ces outils pour r√©soudre nos probl√®mes sp√©cifiques.  La vitesse des processeurs est en constante augmentation, maintenant nous pouvons nous permettre presque tous les algorithmes de conversion de donn√©es apr√®s leur lecture - de toute fa√ßon, la lecture √† partir du disque sera plus lente.  C'est pourquoi les "moyens expressifs" des formats sont importants. </p><br><p>  Ci-dessus, j'ai bri√®vement √©num√©r√©, √† mon avis, les possibilit√©s int√©ressantes du format ORC.  Je n'ai toujours pas de statistiques sur la fa√ßon dont les choses sont dans la pratique (lesquelles de ces fonctionnalit√©s et dans quelle mesure sont utilis√©es par Hive, par exemple).  Quand il appara√Æt - j'√©crirai.  Les plans imm√©diats sont de faire un examen similaire d'un autre format de stockage populaire - Parquet. </p><br><p>  Eh bien - et en conclusion - dans le monde moderne, il y a beaucoup d'informations, malheureusement, une partie de ces informations est trop superficielle.  Nous ne c√©derons pas, nous regarderons l'essence. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458552/">https://habr.com/ru/post/fr458552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458532/index.html">Pionniers des nouvelles technologies: Vadim Artsev a racont√© comment il avait cess√© d'√™tre aveugle</a></li>
<li><a href="../fr458536/index.html">Python + Pyside2 ou simplement ¬´Calculatrice¬ª</a></li>
<li><a href="../fr458546/index.html">Journ√©e de l'automatisation, ou comment nous construisons la couche d'autotests</a></li>
<li><a href="../fr458548/index.html">Cr√©ez votre propre biblioth√®que de styles Spring Data Repository avec Dynamic Proxy et Spring IoC</a></li>
<li><a href="../fr458550/index.html">Biblioth√®que de symboles GOST pour DipTrace</a></li>
<li><a href="../fr458556/index.html">D√©velopper l'extension Chrome avec Angular CLI</a></li>
<li><a href="../fr458558/index.html">Pr√©sentations avec Magento Meetup Kharkiv - Vid√©os et pr√©sentations</a></li>
<li><a href="../fr458560/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 12. VLAN avanc√©</a></li>
<li><a href="../fr458564/index.html">Pits sur le chemin de devenir programmeur</a></li>
<li><a href="../fr458566/index.html">Comment avons-nous attrap√© un concepteur UX sur des app√¢ts vivants?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>