<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏼 🥙 ⛹🏿 À propos de la comparaison des formats de stockage dans Hadoop: commençons par ORC 👇🏻 🚃 👨🏿‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hadoop comprend des produits qui peuvent fonctionner avec des fichiers de différents formats. J'ai cherché, lu et réfléchi à plusieurs reprises sur le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>À propos de la comparaison des formats de stockage dans Hadoop: commençons par ORC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfastrah/blog/458552/"><p>  Hadoop comprend des produits qui peuvent fonctionner avec des fichiers de différents formats.  J'ai cherché, lu et réfléchi à plusieurs reprises sur le meilleur format.  Quand je suis tombé sur le format ORC de manière relativement aléatoire, je me suis intéressé, j'ai lu (et même un peu choyé), et c'est ce que j'ai compris - il est incorrect de comparer les formats en tant que tels.  Plus précisément, ils sont généralement comparés, à mon avis, de manière incorrecte.  En fait, un article à ce sujet, ainsi que sur le format Apache ORC (en termes techniques) et les opportunités qu'il offre. </p><br><p>  Je vais commencer par la question: quelle peut être la taille d'une table relationnelle (en octets et très approximativement), composée de 10 000 lignes (deux champs entiers par ligne)?  Habituellement, ils mettent un kat ici, et la réponse est placée sous le kat - je répondrai ici: 628 octets.  Et les détails et l'histoire seront transférés sous cat. </p><a name="habracut"></a><br><p>  Comment tout a commencé: j'ai construit une bibliothèque pour travailler avec Apache ORC (voir la page d'accueil du projet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://orc.apache.org</a> ) et compilé leur propre exemple d'écriture dans ORC (pour vous casser la tête - nous commençons par ce qui fonctionne) , il contenait 2 champs et 10 000 lignes.  Je l'ai commencé - j'ai reçu le fichier orc, parce que je l'ai fait quelque part en dehors du bureau - juste au cas où, j'ai réécrit la bibliothèque et le fichier sur un lecteur flash (pressé - je n'ai pas regardé la taille, je pense que le lecteur flash peut le gérer). </p><br><p>  Mais en quelque sorte j'ai rapidement correspondu ... J'ai regardé la taille - 628 octets.  J'ai pensé que c'était une erreur, je me suis assis et j'ai commencé à comprendre.  J'ai lancé l'utilitaire pour visualiser ORC à partir de la même bibliothèque compilée - le contenu du fichier montre que tout est honnête - 10 000 lignes.  Après cela, je me suis demandé comment 10 000 lignes pouvaient tenir dans 628 octets (je connaissais déjà un peu ORC à ce moment-là et j'ai réalisé qu'il y avait aussi des métadonnées - le format était autosuffisant).  Compris, partagez. </p><br><h2 id="o-formate-orc">  À propos du format ORC </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/85d/d6c/e83/85dd6ce839b506e8033b3a6683c0c58c.png" alt="image"></p><br><p> Je ne répéterai pas ici des mots généraux sur le format - voir le lien ci-dessus, il est bien écrit là-bas.  Je vais me concentrer sur deux adjectifs en excellente forme de l'image ci-dessus (la photo est tirée de la page d'accueil du projet): essayons de comprendre pourquoi ORC est "le plus rapide" et "le plus compact". </p><br><h1 id="skorost">  La vitesse </h1><br><p>  La vitesse peut être différente, en ce qui concerne les données - au moins la vitesse de lecture ou d'écriture (vous pouvez aller plus loin, mais arrêtons pour l'instant).  Puisque Hadoop est explicitement mentionné dans le slogan ci-dessus, nous considérerons principalement la vitesse de lecture. </p><br><p>  Pour citer un peu plus de la documentation ORC: </p><br><blockquote>  Il est optimisé pour les grandes lectures en continu, mais avec un support intégré pour trouver rapidement les lignes requises.  Le stockage des données dans un format en colonnes permet au lecteur de lire, décompresser et traiter uniquement les valeurs requises pour la requête en cours. </blockquote><p>  Je vais traduire un peu: </p><br><ul><li>  format optimisé pour la lecture en continu de gros volumes </li><li>  contient en même temps un support pour la recherche rapide des lignes nécessaires </li><li>  vous permet de lire uniquement les données dont vous avez besoin </li></ul><br><h1 id="razmer">  La taille </h1><br><p>  Il n'y avait pas de citation, je dirai avec mes propres mots </p><br><ul><li>  format stocke de manière optimale les méta-informations </li><li>  trouver un équilibre entre la vitesse de lecture en continu et le stockage compact </li><li>  prise en charge intégrée pour le stockage le plus compact des valeurs de colonne </li></ul><br><h2 id="predostavlenie-vozmozhnostey">  Offrir des opportunités </h2><br><p>  Je veux attirer votre attention sur le libellé des citations ci-dessus: "optimisé pour ...", "contient un support ...", "vous permet de lire ..." - le format de fichier, en tant que langage de programmation, est un moyen (dans ce cas, fournir stockage efficace et accès aux données).  L'efficacité du stockage et de l'accès aux données dépend non seulement de l'outil, mais aussi de qui l'utilise et comment. </p><br><p>  Voyons quel format le format offre pour la vitesse et la compacité. </p><br><h1 id="kolonchatoe-hranenie-i-straypy">  Rangement de colonne et bande </h1><br><p>  Les données de l'ORC sont stockées sous forme de colonnes, tout d'abord elles affectent la taille.  Pour assurer la vitesse de lecture en continu, le fichier est divisé en ce que l'on appelle des "bandes", chaque bande est autosuffisante, c'est-à-dire  peut être lu séparément (et, par conséquent, en parallèle).  En raison des bandes, la taille du fichier augmentera (les valeurs de colonne non uniques seront stockées plusieurs fois - dans les bandes où ces valeurs se produisent) - le même équilibre de "vitesse - taille" (c'est un compromis). </p><br><h1 id="indeksy">  Indices </h1><br><p>  Le format ORC implique des index qui vous permettent de déterminer si la bande (ou plutôt, les parties de bande de 10 000 lignes chacune, le soi-disant "groupe de lignes") contient les données souhaitées ou non.  Les index sont construits sur chacune des colonnes.  Cela affecte la vitesse de lecture et augmente la taille.  Lors de la lecture en continu d'index de lecture, d'ailleurs, vous ne pouvez pas lire. </p><br><h1 id="szhatie">  La compression </h1><br><p>  Toutes les métadonnées sont stockées sous forme compressée, et cela </p><br><ul><li>  informations statistiques et descriptives (le format vous permet de recréer la table qui y est stockée, y compris les noms et types de champs) </li><li>  indices </li><li>  informations de partitionnement (en bandes et en flux) </li></ul><br><p>  (ci-dessous, nous verrons que les métadonnées sont une partie essentielle du fichier) </p><br><p>  Les valeurs des colonnes sont également stockées sous forme compressée.  Dans le même temps, il est possible de lire et de décompresser uniquement le bloc de données nécessaire (c'est-à-dire qu'aucun fichier n'est compressé et pas une bande entière).  La compression affecte à la fois la taille et la vitesse de lecture. </p><br><h1 id="kodirovanie">  Codage </h1><br><p>  Les valeurs des colonnes - et le fichier stocke exactement ces valeurs - sont stockées sous forme codée.  Dans la version actuelle du format (ORC v1) pour les entiers, par exemple, 4 options d'encodage sont disponibles.  En même temps, la colonne entière n'est pas codée, des parties de la colonne sont codées, chaque partie peut être codée de manière optimale pour cette partie (ces parties sont appelées "exécuter" dans la spécification).  Ainsi, la minimisation de la longueur totale des données stockées est obtenue.  Encore une fois, l'effet sur la taille et la vitesse. </p><br><h2 id="posmotrim-orc-fayl">  Voyons le fichier ORC </h2><br><p>  Regardons très brièvement ce qui se trouve à l'intérieur du fichier ORC (celui-ci fait 628 octets).  Pour ceux qui ne sont pas très intéressés par les détails techniques, faites défiler jusqu'à la section suivante (sur la comparaison des formats). </p><br><p>  Voici comment notre table a été définie dans l'exemple d'enregistrement dans ORC: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/af7/bb2/a01/af7bb2a019f050cbc47ec9e2c8152a2b.png" alt="image"></p><br><h1 id="metadannye">  Métadonnées </h1><br><p>  Informations sur les longueurs (je donne des captures d'écran du cahier jupyter, je pense que c'est assez clair) </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d3e/e1f/398/d3ee1f39809cccf7fc9523df72bb2def.png" alt="image"></p><br><p>  Ce que nous voyons ici: </p><br><ul><li>  dans la "tige" (et c'est Postscript + Footer + Metadata) seulement 1 + 23 + 115 + 50 = 189 octets </li><li>  sur une seule bande, seulement 3 + 436 = 439 octets, total 628 octets </li><li>  la bande contient un index (73 octets), des données (276 octets), un pied de page (87 octets) </li></ul><br><p>  Faisons attention ici au rapport du volume de données et des métadonnées (276 à 352 octets).  Mais ces 276 octets de données ne sont pas seulement des données, les données contiennent un peu de «superflu» (ici pour des raisons de brièveté, je ne donne pas de captures d'écran - c'est long avec elles, je ne gérerai qu'avec mes commentaires), qui est inclus dans les données: </p><br><ul><li>  PRESENT flux pour chaque colonne, il y en a trois (y compris une structure de pseudo-colonne commune) - 20 octets par chacun, total 60 octets </li><li>  flux de données (ici la pseudo-colonne n'est pas représentée) - 103 et 113 octets (colonnes "x" et "y", respectivement) </li></ul><br><p>  Les flux PRESENT sont des chaînes de bits qui vous permettent de savoir où les colonnes sont NULL.  Pour notre exemple, leur présence semble étrange (dans les statistiques de notre fichier, il est clairement écrit qu'il n'y a pas de NULL dans les données - pourquoi alors inclure PRESENT? Cela semble être un défaut ...) </p><br><p>  Au total, les données elles-mêmes occupent 216 octets, les métadonnées - 352. </p><br><p>  Il ressort également des métadonnées que les deux colonnes sont codées à l'aide de la méthode DIRECT_V2 (pour les entiers, elle permet 4 types de représentations, je me réfère à la spécification pour plus de détails - c'est sur le site web du projet). </p><br><h1 id="dannye">  Les données </h1><br><p>  Voyons (encore une fois sans captures d'écran pour plus de brièveté) comment 10 000 nombres tiennent dans 103 octets (pour la colonne "x"): </p><br><ul><li>  le codage delta est utilisé, dans lequel les paramètres sont la valeur initiale et le pas (un peu simplifié par souci de concision) </li><li>  nous avons toujours 1 étape, la valeur initiale pour la première exécution est 0, puis 511, 1022, etc. </li><li>  run (un ensemble de données codées d'une seule manière) contient dans notre cas 511 valeurs (la valeur maximale possible pour le codage delta) </li><li>  la longueur de chaque exécution dans le fichier est de 4 à 6 octets (la longueur de l'exécution augmente du fait que la valeur initiale est représentée en zigzag) </li><li>  total pour la colonne "x" nous obtenons dans le fichier 20 run-s avec une longueur totale de 103 octets (j'ai vérifié - tout s'emboîte) </li></ul><br><p>  Pour conclure l'examen de la présentation de notre simple tableau dans un fichier, je dirai que les indices dans cet exemple sont dégénérés - ils indiquent le début du flux de données.  Je traiterai les index à l'aide d'exemples concrets; je les décrirai probablement dans un article séparé. </p><br><p>  Pour les intéressés: sous le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> vous trouverez le cahier jupyter, dans lequel j'ai "compris" le format interne.  Vous pouvez l'utiliser et répéter (le fichier ORC y est également joint). </p><br><p>  Je suis sûr que de nombreux lecteurs sont "perdus" - oui, le format ORC n'est pas simple (à la fois en termes de compréhension des détails et en termes d'utilisation des fonctionnalités fournies). </p><br><h2 id="o-sravnenii-formatov">  À propos de la comparaison des formats </h2><br><p>  Passons maintenant au point principal - comparaison de format incorrecte. </p><br><p>  Fréquence de comparaison des formats: comparons la taille des fichiers aux formats A et B, la vitesse de lecture (différents types de lecture - aléatoire, streaming, etc.) aux formats A et B. Comparé, nous avons conclu que le format A est meilleur que le format B. </p><br><p>  En utilisant l'exemple du dernier des outils de compacité (encodage) énumérés ci-dessus: les données peuvent-elles être encodées de manière optimale dans l'ORC?  Oui, il existe des opportunités - voir ci-dessus.  Mais tout aussi bien, vous ne pouvez pas faire ça!  Cela dépend de «l'écrivain» (écrivain dans la terminologie ORC): dans l'exemple ci-dessus, l'écrivain pourrait le faire.  Mais il pourrait simplement écrire 2 fois en 10 000 nombres et ce serait également correct en termes de format.  <strong>En comparant les formats "par taille", nous comparons non seulement et pas tant les formats que la qualité algorithmique des systèmes d'application utilisant ces formats</strong> . </p><br><p>  Qui est "l'écrivain" dans Hadoop?  Il y en a beaucoup - par exemple, Hive, qui crée une table qui stocke ses données dans des fichiers au format ORC.  En comparant, par exemple, ORC avec Parquet dans Hadoop, nous évaluons en fait la qualité de mise en œuvre de l'algorithme de conversion de données implémenté dans Hive.  Nous ne comparons pas les formats (en tant que tels). </p><br><p>  <strong>Caractéristique importante de Hadoop</strong> </p><br><p>  Dans le monde relationnel classique, nous n'avions aucun moyen d'influencer la taille de la table dans Oracle - elle était en quelque sorte stockée et seul Oracle savait comment.  Dans Hadoop, la situation est légèrement différente: nous pouvons voir comment telle ou telle table est stockée (dans quelle mesure Hive, par exemple, a réussi à la «coder»).  Et, si nous voyons que cela peut être amélioré, nous avons une réelle opportunité pour cela: créer notre propre fichier ORC plus optimal et le donner à Hive en tant que table externe. </p><br><h2 id="sravnim-orc-i-qvd">  Comparer ORC et QVD </h2><br><p>  J'ai récemment décrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le format QVD</a> que QlikVew / QlikSense utilise activement.  Illustrons très brièvement ces deux formats en termes de capacités qu’ils offrent pour atteindre une vitesse de lecture maximale et minimiser la taille.  Les capacités d'ORC sont décrites ci-dessus, comme dans QVD: </p><br><h1 id="kolonchatoe-hranenie">  Stockage sur colonne </h1><br><p>  QVD peut être considéré comme un format «en colonnes», il n'y a pas de duplication des valeurs des colonnes - des valeurs uniques sont stockées une fois.  MAIS il ne permet pas le traitement parallèle - vous devez d'abord lire entièrement les valeurs de toutes les colonnes, puis vous pouvez lire les lignes en parallèle. </p><br><p>  Et il y a duplication au niveau des lignes - les lignes stockent des valeurs d'index en double dans une table de caractères. </p><br><h1 id="szhatie-1">  La compression </h1><br><p>  Je n'ai pas rencontré de fichiers QVD compressés - je n'ai pas réussi - il y a une telle balise dans les métadonnées, peut-être que chacune des parties sur lesquelles il y a un décalage et une longueur dans les métadonnées (et c'est chaque table de caractères et la table de chaînes entière) peut être compressée.  Dans ce cas, une lecture parallèle des lignes est "au revoir" ... </p><br><h1 id="indeksy-1">  Indices </h1><br><p>  Il n'y a aucun moyen de comprendre dans le fichier QVD quelle partie de celui-ci doit être lue.  En pratique, vous devez analyser la table des caractères octet par octet (chacun!), Pas très efficace ... </p><br><h1 id="kodirovanie-1">  Codage </h1><br><p>  Le codage dans QVD n'est pas utilisé, il est possible de faire une analogie de l'index binaire dans une table de chaînes avec codage, mais cette analogie est "compensée" par la duplication des nombres par des chaînes dans les tables de caractères (pour plus de détails, consultez brièvement l'article - la valeur de la colonne est souvent représentée par le nombre ET la chaîne). </p><br><p>  La conclusion de cette brève comparaison que j'ai personnellement formulée est la suivante: le format QVD ne contient pratiquement pas de capacités permettant un stockage compact et une lecture rapide des données contenues dans des fichiers de ce format. </p><br><p>  (Cela semblait quelque peu offensant pour QVD, j'ajouterai un peu - le format a été créé il y a longtemps, seul QlikView / QlikSense est utilisé, et ils "stockent" toutes les données en mémoire. Je pense que le fichier QVD est simplement lu tout "tel quel" en mémoire, puis ces merveilleux produits BI à tous égards fonctionnent très rapidement avec cette présentation - les voilà maîtres ...) </p><br><h2 id="vmesto-zaklyucheniya">  Au lieu d'une conclusion </h2><br><p>  Il a critiqué et n'a encore rien offert ... - Je suggère. </p><br><p>  Il me semble que les formats doivent être comparés non pas par l'exemple de leur implémentation spécifique, les formats doivent être comparés en termes des outils qui y sont inclus et de la capacité à utiliser ces outils pour résoudre nos problèmes spécifiques.  La vitesse des processeurs est en constante augmentation, maintenant nous pouvons nous permettre presque tous les algorithmes de conversion de données après leur lecture - de toute façon, la lecture à partir du disque sera plus lente.  C'est pourquoi les "moyens expressifs" des formats sont importants. </p><br><p>  Ci-dessus, j'ai brièvement énuméré, à mon avis, les possibilités intéressantes du format ORC.  Je n'ai toujours pas de statistiques sur la façon dont les choses sont dans la pratique (lesquelles de ces fonctionnalités et dans quelle mesure sont utilisées par Hive, par exemple).  Quand il apparaît - j'écrirai.  Les plans immédiats sont de faire un examen similaire d'un autre format de stockage populaire - Parquet. </p><br><p>  Eh bien - et en conclusion - dans le monde moderne, il y a beaucoup d'informations, malheureusement, une partie de ces informations est trop superficielle.  Nous ne céderons pas, nous regarderons l'essence. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458552/">https://habr.com/ru/post/fr458552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458532/index.html">Pionniers des nouvelles technologies: Vadim Artsev a raconté comment il avait cessé d'être aveugle</a></li>
<li><a href="../fr458536/index.html">Python + Pyside2 ou simplement «Calculatrice»</a></li>
<li><a href="../fr458546/index.html">Journée de l'automatisation, ou comment nous construisons la couche d'autotests</a></li>
<li><a href="../fr458548/index.html">Créez votre propre bibliothèque de styles Spring Data Repository avec Dynamic Proxy et Spring IoC</a></li>
<li><a href="../fr458550/index.html">Bibliothèque de symboles GOST pour DipTrace</a></li>
<li><a href="../fr458556/index.html">Développer l'extension Chrome avec Angular CLI</a></li>
<li><a href="../fr458558/index.html">Présentations avec Magento Meetup Kharkiv - Vidéos et présentations</a></li>
<li><a href="../fr458560/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 12. VLAN avancé</a></li>
<li><a href="../fr458564/index.html">Pits sur le chemin de devenir programmeur</a></li>
<li><a href="../fr458566/index.html">Comment avons-nous attrapé un concepteur UX sur des appâts vivants?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>