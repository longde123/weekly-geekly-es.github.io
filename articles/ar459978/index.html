<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇🏿 👊🏿 💠 أدوات مطور Node.js. استدعاء الإجراء عن بعد على مآخذ الويب 💰 🙎🏽 ♉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="غالبًا ما تخبر قصص الرعب عن تقنية websocket ، على سبيل المثال ، أنها غير مدعومة من متصفحات الويب ، أو أن مقدمي الخدمة / المشرفين يحجبون حركة مرور webs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>أدوات مطور Node.js. استدعاء الإجراء عن بعد على مآخذ الويب</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459978/" style=";text-align:right;direction:rtl"> غالبًا ما تخبر قصص الرعب عن تقنية websocket ، على سبيل المثال ، أنها غير مدعومة من متصفحات الويب ، أو أن مقدمي الخدمة / المشرفين يحجبون حركة مرور websocket - لذلك لا يمكن استخدامها في التطبيقات.  من ناحية أخرى ، لا يتوقع المطورون دائمًا المآزق التي تمتلكها تقنية طبقة الويب ، مثل أي تقنية أخرى.  بالنسبة للقيود المزعومة ، سأقول على الفور أن 96.8٪ من متصفحات الويب تدعم تقنية websocket اليوم.  يمكنك القول أن 3.2 ٪ المتبقية في البحر هو الكثير ، هؤلاء هم الملايين من المستخدمين.  أنا أتفق معك تمامًا.  فقط كل شيء معروف في المقارنة.  نفس XmlHttpRequest ، الذي يستخدمه الجميع في Ajax لسنوات عديدة ، يدعم 97.17 ٪ من متصفحات الويب (ليس أكثر بكثير ، أليس كذلك؟) ، وجلب بشكل عام ، 93.08 ٪ من متصفحات الويب.  على عكس websocket ، فإن هذه النسبة المئوية (وقبل ذلك كانت أقل) لم توقف أي شخص لفترة طويلة عند استخدام تقنية Ajax.  لذا فإن استخدام تراجع في الاقتراع الطويل ليس له أي معنى.  إذا كان ذلك فقط لأن متصفحات الويب التي لا تدعم websocket هي نفس متصفحات الويب التي لا تدعم XmlHttpRequest ، وفي الواقع لن يحدث أي تراجع. <br><br>  قصة الرعب الثانية ، حظر على websocket من موفري أو مدراء شبكات الشركات ، هي أيضا غير معقولة ، لأن الجميع يستخدم الآن بروتوكول https ، ومن المستحيل أن نفهم أن اتصال websocket مفتوح (دون كسر https). <br><br>  بالنسبة للقيود الحقيقية وطرق التغلب عليها ، سأقول في هذا المنشور ، على سبيل المثال تطوير منطقة مسؤول الويب للتطبيق. <br><a name="habracut"></a><br>  لذلك ، يحتوي كائن WebSocket في مستعرض الويب ، بصراحة ، على مجموعة موجزة للغاية من الطرق: send () و close () ، وكذلك addEventListener () و removeEventListener () و أساليب dispatchEvent () الموروثة من كائن EventTarget.  لذلك ، يجب على المطور استخدام المكتبات (عادةً) أو بشكل مستقل (يكاد يكون من المستحيل) لحل العديد من المشكلات. <br><br>  لنبدأ بالمهمة الأكثر مفهومة.  تمت مقاطعة الاتصال بالخادم بشكل دوري.  إعادة الاتصال سهلة بما فيه الكفاية.  ولكن إذا كنت تتذكر أن الرسائل من كل من العميل والخادم تستمر في العمل في هذا الوقت ، فسيصبح كل شيء على الفور وأكثر تعقيدًا.  بشكل عام ، يمكن فقد رسالة إذا لم يتم توفير آلية تأكيد للرسالة المستلمة ، أو أعيد تسليمها (حتى عدة مرات) إذا تم توفير آلية التأكيد ، ولكن حدث الفشل في اللحظة التي تعقب الاستلام وقبل تأكيد الرسالة. <br><br>  إذا كنت بحاجة إلى تسليم مضمون للرسائل و / أو تسليم الرسائل بدون إرسال ، فهناك بروتوكولات خاصة لتنفيذ ذلك ، على سبيل المثال ، AMQP و MQTT ، والتي تعمل مع النقل عبر الويب.  لكن اليوم لن نفكر فيها. <br><br>  تدعم معظم مكتبات العمل مع websocket للمبرمج إعادة الاتصال بالخادم.  يعد استخدام هذه المكتبة دائمًا أكثر موثوقية من تطوير تطبيقك. <br><br>  بعد ذلك ، تحتاج إلى تنفيذ البنية التحتية لإرسال واستقبال الرسائل غير المتزامنة.  للقيام بذلك ، استخدم معالج الأحداث onmessage "العاري" دون ربط إضافي ، وهي مهمة ناكر للجميل.  يمكن أن تكون هذه البنية التحتية ، على سبيل المثال ، استدعاء الإجراء عن بعد (RPC).  تم تقديم معرّف الهوية في مواصفات json-rpc ، خاصةً للعمل مع نقل websocket ، والذي يتيح لك تعيين مكالمة الإجراء البعيد من قبل العميل إلى رسالة الاستجابة من خادم الويب.  أفضل هذا البروتوكول على كل الاحتمالات الأخرى ، لكن حتى الآن لم أجد التنفيذ الناجح لهذا البروتوكول لجزء الخادم على node.js. <br><br>  وأخيرا ، تحتاج إلى تنفيذ التحجيم.  تذكر أن الاتصال بين العميل والخادم يحدث بشكل دوري.  إذا كانت قوة خادم واحد ليست كافية بالنسبة لنا ، فيمكننا رفع عدد آخر من الخوادم.  في هذه الحالة ، بعد قطع الاتصال ، لا يمكن ضمان الاتصال بنفس الخادم.  عادة ، يتم استخدام خادم redis أو مجموعة من خوادم redis لتنسيق خوادم websocket متعددة. <br><br>  ولسوء الحظ ، عاجلاً أم آجلاً ، سنواجه أداء النظام على أي حال ، لأن قدرات node.js في عدد اتصالات طبقة الويب المفتوحة في وقت واحد (لا تخلط بين هذا والأداء) أقل بكثير من الخوادم المتخصصة مثل قوائم انتظار الرسائل والوسطاء.  والحاجة إلى التبادل بين جميع مثيلات خوادم websocket من خلال مجموعة خوادم redis ، بعد بعض النقاط المهمة ، لن تعطي زيادة كبيرة في عدد الاتصالات المفتوحة.  تتمثل طريقة حل هذه المشكلة في استخدام خوادم متخصصة ، مثل AMQP و MQTT ، والتي تعمل ، بما في ذلك مع النقل عبر الويب.  لكن اليوم لن نفكر فيها. <br><br>  كما ترون من قائمة المهام المدرجة ، فإن ركوب الدراجات أثناء العمل باستخدام websocket يستهلك الكثير من الوقت ، وحتى مستحيل إذا كنت بحاجة إلى توسيع نطاق الحل لعدة خوادم websocket. <br><br>  لذلك ، أقترح النظر في العديد من المكتبات الشائعة التي تنفذ العمل باستخدام websocket. <br><br>  سأستبعد على الفور من المكتبات تلك التي تطبق احتياطيًا حصريًا على وسائط النقل المتقادمة ، نظرًا لأن هذه الوظيفة ليست ذات صلة اليوم ، والمكتبات التي تقوم بتنفيذ وظائف أوسع ، كقاعدة عامة ، تقوم أيضًا بتنفيذ النسخ الاحتياطي على وسائط النقل القديمة. <br><br>  سأبدأ مع مكتبة الأكثر شعبية - socket.io.  الآن يمكنك سماع الرأي ، على الأرجح عادل ، أن هذه المكتبة بطيئة ومكلفة من حيث الموارد.  على الأرجح ، وهو يعمل بشكل أبطأ من websocket الأصلي.  ومع ذلك ، فهي اليوم المكتبة الأكثر تطوراً بوسائلها.  ومرة أخرى ، عند العمل مع websocket ، فإن العامل المحدد ليس هو السرعة ، ولكن عدد الاتصالات المفتوحة في وقت واحد مع العملاء الفريدين.  ويتم حل هذا السؤال بالفعل عن طريق إجراء اتصالات مع العملاء بخوادم متخصصة. <br><br>  لذلك ، تنفذ soket.io استردادًا موثوقًا عند قطع الاتصال بالخادم والتحجيم باستخدام خادم أو مجموعة من خوادم redis.  في الواقع ، ينفذ socket.io بروتوكول الرسائل الفردية الخاص به ، والذي يسمح لك بتنفيذ المراسلة بين العميل والخادم دون ربط لغة برمجة معينة. <br><br>  ميزة مثيرة للاهتمام من socket.io هي تأكيد معالجة الأحداث ، حيث يمكن إرجاع كائن تعسفي من الخادم إلى العميل ، والذي يسمح بإجراء مكالمات من بعد (على الرغم من أنه لا يتوافق مع معيار json-rpc). <br><br>  أيضًا ، أوليًا ، درست مكتبتين أكثر إثارة للاهتمام ، والتي سأناقشها بإيجاز أدناه. <br><br>  مكتبة فاي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">faye.jcoglan.com</a> .  وهي تنفذ بروتوكول بايو ، الذي تم تطويره في مشروع CometD وتنفذ الاشتراك / توزيع الرسائل على قنوات الرسائل.  كما يدعم هذا المشروع التوسع باستخدام خادم أو مجموعة من خوادم redis.  لم تنجح محاولة العثور على طريقة لتطبيق RPC لأنها لا تتناسب مع نظام بروتوكول بايو. <br><br>  في مشروع socketcluster <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">socketcluster.io</a> ، يتم التركيز على توسيع نطاق خادم websocket.  في الوقت نفسه ، لا يتم إنشاء مجموعة خادم websocket على أساس خادم redis ، كما هو الحال في أول مكتبتين مذكورتين ، ولكن على أساس node.js.  في هذا الصدد ، عند نشر المجموعة ، كان من الضروري إطلاق بنية تحتية معقدة إلى حد ما من السماسرة والعمال. <br><br>  الآن دعنا ننتقل إلى تنفيذ RPC على socket.io.  كما قلت أعلاه ، طبقت هذه المكتبة بالفعل القدرة على تبادل الأشياء بين العميل والخادم: <br><br><pre style=";text-align:right;direction:rtl"><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'socket.io-client'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = io({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>] }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remoteCall = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { socket.emit(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, data, (response) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { reject(response); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resolve(response); } }); });</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>).createServer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> io = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'socket.io'</span></span>)(server, { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span> }); io.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, (socket) =&gt; { socket.on(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (data, callback) =&gt; { handleRemoteCall(socket, data, callback); }); }); server.listen(<span class="hljs-number"><span class="hljs-number">5000</span></span>, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'dashboard backend listening on *:5000'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleRemoteCall = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">socket, data, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response =... callback(response) }</code> </pre><br>  هذا هو المخطط العام.  الآن سننظر في كل جزء من الأجزاء فيما يتعلق بتطبيق معين.  لبناء لوحة المشرف ، استخدمت مكتبة رد الفعل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">github.com/marmelab/react-admin</a> .  يتم تنفيذ تبادل البيانات مع الخادم في هذه المكتبة باستخدام موفر بيانات ، يحتوي على نظام مناسب جدًا ، وهو نوع من المعايير تقريبًا.  على سبيل المثال ، للحصول على قائمة ، تسمى الطريقة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs">dataProvider( <span class="hljs-string"><span class="hljs-string">'GET_LIST'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, { <span class="hljs-attr"><span class="hljs-attr">pagination</span></span>: { <span class="hljs-attr"><span class="hljs-attr">page</span></span>: {int}, <span class="hljs-attr"><span class="hljs-attr">perPage</span></span>: {int} }, <span class="hljs-attr"><span class="hljs-attr">sort</span></span>: { <span class="hljs-attr"><span class="hljs-attr">field</span></span>: {string}, <span class="hljs-attr"><span class="hljs-attr">order</span></span>: {string} }, <span class="hljs-attr"><span class="hljs-attr">filter</span></span>: { <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span> } }</code> </pre><br>  هذه الطريقة في استجابة غير متزامنة بإرجاع كائن: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: [  ], <span class="hljs-attr"><span class="hljs-attr">total</span></span>:      }</code> </pre><br>  يوجد حاليًا عدد مثير للإعجاب من تطبيقات موفر بيانات رد فعل المشرف للعديد من الخوادم والأطر (مثل firebase ، والإقلاع النابض ، و graphql ، إلخ).  في حالة RPC ، تبين أن التطبيق هو الأكثر إيجازًا ، حيث يتم نقل الكائن في شكله الأصلي إلى استدعاء دالة emit: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'socket.io-client'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = io({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>] }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (action, collection, payload = {}) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { socket.emit(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, {action, collection, payload}, (response) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { reject(response); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resolve(response); } }); });</code> </pre><br>  لسوء الحظ ، كان يجب القيام بالمزيد من العمل على جانب الخادم.  لتنظيم تعيين الوظائف التي تتعامل مع المكالمة عن بُعد ، تم تطوير جهاز توجيه مشابه لـ express.js.  فقط بدلاً من توقيع الوسيطة (req ، الدقة ، التالي) ، يعتمد التنفيذ على التوقيع (مقبس ، حمولة ، رد اتصال).  نتيجة لذلك ، حصلنا جميعًا على الكود المعتاد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Router = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./router'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = Router(); router.use(<span class="hljs-string"><span class="hljs-string">'GET_LIST'</span></span>, (socket, payload, callback) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> limit = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(payload.pagination.perPage); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">(payload.pagination.page</span></span></span><span class="hljs-function">) - 1) * </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">limit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{data: users.slice(offset, offset + limit </span></span></span><span class="hljs-function">), </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">}); }); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">router</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">use</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'GET_ONE'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (socket, payload, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: users[payload.id]}); }); router.use(<span class="hljs-string"><span class="hljs-string">'UPDATE'</span></span>, (socket, payload, callback) =&gt; { users[payload.id] = payload.data <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: users[payload.id] }); }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; i++) { users.push({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: i, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`name of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string">`</span></span>}); }</code> </pre><br>  يمكن العثور <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">على</a> تفاصيل تنفيذ جهاز التوجيه <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في مستودع المشروع.</a> <br><br>  كل ما تبقى هو تعيين موفر لمكون المسؤول: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Admin, Resource, EditGuesser } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-admin'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UserList <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./UserList'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataProvider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./wsProvider'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Admin dataProvider={dataProvider}&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Resource</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"users"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">list</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{UserList}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">edit</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{EditGuesser}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Admin</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App;</code> </pre><br><br>  روابط مفيدة <br><br>  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">www.infoq.com/articles/Web-Sockets-Proxy-Servers</a> <br><br>  apapacy@gmail.com <br>  14 يوليو 2019 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar459978/">https://habr.com/ru/post/ar459978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar459964/index.html">8 حيل بسيطة من واجهة المستخدم لجعل تصميم النموذج الأولي ديناميكيًا دون اللجوء إلى الرسوم المتحركة</a></li>
<li><a href="../ar459968/index.html">ما الذي حدث حقًا لشركة Boeing الماليزية المختفية (الجزء 3/3)</a></li>
<li><a href="../ar459970/index.html">Promise.allSettled</a></li>
<li><a href="../ar459972/index.html">تطوير عامل الميناء. البيئة المحلية. الجزء 1</a></li>
<li><a href="../ar459976/index.html">جديد Nemesida WAF بناء الحرة ل NGINX</a></li>
<li><a href="../ar459980/index.html">رسائل التكنولوجيا الفائقة النيجيرية</a></li>
<li><a href="../ar459982/index.html">محللين روزلين. كيف تكتب الكود بسرعة وبدقة</a></li>
<li><a href="../ar459984/index.html">بناء البنية التحتية كرمز مع GitLab و Ansible</a></li>
<li><a href="../ar459988/index.html">الكلب أكل على الشبكات العصبية</a></li>
<li><a href="../ar459990/index.html">الانغماس في الحركة - لغة البرمجة فيبروك الميزان في فيسبوك</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>