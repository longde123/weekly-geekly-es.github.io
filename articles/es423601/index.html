<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç¢ üéûÔ∏è üìß Sistema de trabajo y ruta de b√∫squeda üë©üèæ‚Äçüç≥ üëª üßëüèΩ‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mapa 
 En un art√≠culo anterior, analic√© cu√°l es el nuevo sistema Job , c√≥mo funciona, c√≥mo crear tareas, llenarlas con datos y realizar c√°lculos de su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistema de trabajo y ruta de b√∫squeda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423601/"><h3>  Mapa </h3><br>  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior,</a> analic√© cu√°l es el nuevo <b>sistema Job</b> , c√≥mo funciona, c√≥mo crear tareas, llenarlas con datos y realizar c√°lculos de subprocesos m√∫ltiples, y solo le expliqu√© brevemente d√≥nde puede usar este sistema.  En este art√≠culo, intentar√© analizar un ejemplo espec√≠fico de d√≥nde puede usar este sistema para obtener m√°s rendimiento. <br><a name="habracut"></a><br>  Dado que el sistema se desarroll√≥ originalmente con el objetivo de trabajar con datos, es ideal para resolver tareas de b√∫squeda de rutas. <br><br>  <b>Unity</b> ya tiene un buen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">navegador NavMesh</a> , pero no funciona en proyectos 2D, aunque hay muchas soluciones listas para usar en el mismo <i>activo</i> .  Bueno, e intentaremos crear no solo un sistema que buscar√° formas en el mapa creado, sino que har√° que este mapa sea din√°mico, de modo que cada vez que algo cambie en √©l, el sistema crear√° un nuevo mapa, y todo esto, por supuesto, lo calcularemos utilizando Un nuevo sistema de tareas, para no cargar el hilo principal. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de operaci√≥n del sistema</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/527/a69/ec1/527a69ec1543218ffe1df7c4b1deddb0.gif" alt="imagen"><br></div></div><br>  En el ejemplo, se construye una cuadr√≠cula en el mapa, hay un bot y un obst√°culo.  La cuadr√≠cula se reconstruye cada vez que cambiamos cualquier propiedad del mapa, ya sea su tama√±o o posici√≥n. <br><br>  Para los aviones, utilic√© un <b>SpriteRenderer</b> simple, este componente tiene una propiedad de <b>l√≠mites</b> excelente con la que puede averiguar f√°cilmente el tama√±o del mapa. <br><br>  B√°sicamente, eso es todo para empezar, pero no nos detendremos e inmediatamente nos pondremos manos a la obra. <br><br>  Comencemos con los guiones.  Y el primero es el script de obstrucci√≥n de <b>obst√°culos</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Obst√°culo</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  Dentro de la clase <b>Obst√°culo</b> , detectaremos todos los cambios en los obst√°culos en el mapa, por ejemplo, cambiando la posici√≥n o el tama√±o de un objeto. <br>  A continuaci√≥n, puede crear la clase de mapa <b>Map</b> , en la que se construir√° la cuadr√≠cula, y heredarla de la clase <b>Obstacle</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  La clase <b>Map</b> tambi√©n rastrear√° todos los cambios en el mapa para reconstruir la cuadr√≠cula si es necesario. <br><br>  Para hacer esto, complete la clase base <b>Obst√°culo</b> con todas las variables y m√©todos necesarios para realizar un seguimiento de los cambios en los objetos. <br><br><div class="spoiler">  <b class="spoiler_title">Obst√°culo</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteRenderer renderer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempPos; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer = GetComponent&lt;SpriteRenderer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> virtual bool CheckChanges() { Vector2 newSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; float diff = (newSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = newSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } Vector2 newPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; diff = (newPos - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = newPos; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 size { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.bounds.size;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position;} } }</code> </pre> <br></div></div><br>  Aqu√≠, la variable de <b>representaci√≥n</b> tendr√° una referencia al componente <b>SpriteRenderer</b> , y las <b>variables</b> <b>tempSize</b> y <b>tempPos</b> se usar√°n para rastrear los cambios en el tama√±o y la posici√≥n del objeto. <br><br>  El m√©todo virtual <b>Awake</b> se usar√° para inicializar las variables, y el m√©todo virtual <b>CheckChanges</b> har√° un seguimiento de los cambios actuales en el tama√±o y la posici√≥n del objeto y devolver√° un resultado <b>booleano</b> . <br><br>  Por ahora, dejemos la secuencia de comandos <b>Obstacle</b> y pasemos a la secuencia de comandos <b>Map</b> map en s√≠, donde tambi√©n la completaremos con los par√°metros necesarios para el trabajo. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); }</code> </pre> <br></div></div><br>  La variable <b>nodeSize</b> indicar√° el tama√±o de las celdas en el mapa, aqu√≠ he limitado su tama√±o de 0.1 a 1 para que las celdas en la cuadr√≠cula no sean demasiado peque√±as, sino tambi√©n demasiado grandes.  La variable de <b>desplazamiento</b> se usar√° para sangrar el mapa al construir la cuadr√≠cula para que la cuadr√≠cula no se construya a lo largo de los bordes del mapa. <br><br>  Como ahora hay dos nuevas variables en el mapa, resulta que sus cambios tambi√©n deber√°n ser rastreados.  Para hacer esto, agregue un par de variables y sobrecargue el m√©todo <b>CheckChanges</b> en la clase <b>Map</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> float tempNodeSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempOffset; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { base.Awake(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } }</code> </pre> <br></div></div><br>  Listo  Ahora puede crear un sprite de mapa en el escenario y lanzar un script de <b>Mapa</b> sobre √©l. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d75/60f/db8/d7560fdb8abeb5f00a7a5e1ec5e444df.png" alt="imagen"><br><br>  Haremos lo mismo con un obst√°culo: crear un sprite simple en el escenario y lanzar el gui√≥n de <b>Obst√°culo</b> sobre √©l. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/ffa/e8d/347ffae8dd2b4cd3a3a50c881d5674df.png" alt="imagen"><br><br>  Ahora tenemos objetos de mapa y obst√°culos en el escenario. <br><br>  La secuencia de comandos del <b>Mapa</b> ser√° responsable de rastrear todos los cambios en el mapa, donde en el m√©todo de <b>Actualizaci√≥n</b> revisaremos cada cuadro para ver los cambios. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> bool requireRebuild; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { UpdateChanges(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Por lo tanto, en el m√©todo <b>UpdateChanges, el</b> mapa solo rastrear√° sus cambios hasta ahora.  Incluso puedes comenzar el juego ahora e intentar cambiar el tama√±o del mapa o <b>compensar el desplazamiento</b> para asegurarte de que todos los cambios sean rastreados. <br><br>  Ahora necesita rastrear de alguna manera los cambios de los obst√°culos en el mapa.  Para hacer esto, colocaremos cada obst√°culo en una lista en el mapa, que a su vez actualizar√° cada cuadro en el m√©todo <b>Actualizar</b> . <br><br>  En la clase <b>Mapa</b> , cree una lista de todos los obst√°culos posibles en el mapa y un par de m√©todos est√°ticos para registrarlos. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map ObjInstance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Obstacle&gt; obstacles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Obstacle&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool RegisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle == Instance) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Contains(obstacle) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { Instance.obstacles.Add(obstacle); Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool UnregisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Remove(obstacle)) { Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjInstance == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ObjInstance = FindObjectOfType&lt;Map&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjInstance; } } }</code> </pre> <br></div></div><br>  En el m√©todo est√°tico <b>RegisterObstacle</b> , registraremos un nuevo obst√°culo <b>Obst√°culo</b> en el mapa y lo agregaremos a la lista, pero primero es importante tener en cuenta que el mapa en s√≠ tambi√©n se hereda de la clase <b>Obst√°culo</b> y, por lo tanto, debemos verificar si estamos tratando de registrar la tarjeta como un obst√°culo. <br><br>  El m√©todo est√°tico <b>UnregisterObstacle</b> , por el contrario, elimina el obst√°culo del mapa y lo elimina de la lista cuando permitimos que sea destruido. <br><br>  Al mismo tiempo, cada vez que agregamos o eliminamos un obst√°culo del mapa, es necesario recrear el mapa en s√≠, por lo que despu√©s de ejecutar estos m√©todos est√°ticos, establezca la variable <b>requireRebuild</b> en <b>true</b> . <br><br>  Adem√°s, para tener f√°cil acceso al script del <b>Mapa</b> desde cualquier script, cre√© una propiedad de <b>Instancia</b> est√°tica que me devolver√° esta misma instancia del <b>Mapa</b> . <br><br>  Ahora, volvamos a la secuencia de comandos <b>Obst√°culo</b> donde registraremos un obst√°culo en el mapa. Para hacer esto, agregue un par de m√©todos <b>OnEnable</b> y <b>OnDisable</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Obst√°culo</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { Map.RegisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { Map.UnregisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br></div></div><br>  Cada vez que creamos un nuevo obst√°culo mientras jugamos en el mapa, se registrar√° autom√°ticamente en el m√©todo <b>OnEnable</b> , donde se tendr√° en cuenta al construir una nueva cuadr√≠cula y nos eliminaremos del mapa en el m√©todo <b>OnDisable</b> cuando se destruya o desactive. <br><br>  Solo queda realizar un seguimiento de los cambios de los obst√°culos en el script <b>Map</b> en el m√©todo <b>CheckChanges</b> sobrecargado. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } foreach(Obstacle obstacle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle.CheckChanges()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Ahora tenemos un mapa, obst√°culos: en general, todo lo que necesita para construir una cuadr√≠cula y ahora puede pasar a lo m√°s importante. <br><br><h4>  Malla </h4><br>  La cuadr√≠cula, en su forma m√°s simple, es una matriz bidimensional de puntos.  Para construirlo, necesita saber el tama√±o del mapa y el tama√±o de los puntos en √©l, despu√©s de algunos c√°lculos obtenemos el n√∫mero de puntos horizontal y verticalmente, esta es nuestra cuadr√≠cula. <br><br>  Hay muchas formas de encontrar una ruta en una cuadr√≠cula.  Sin embargo, en este art√≠culo, lo principal es entender c√≥mo usar correctamente las capacidades del sistema de tareas, por lo que aqu√≠ no considerar√© diferentes opciones para encontrar la ruta, sus ventajas y desventajas, pero tomar√© la opci√≥n de b√∫squeda m√°s simple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">A *</a> . <br><br>  En este caso, todos los puntos de la cuadr√≠cula deben tener, adem√°s de la posici√≥n, las coordenadas y la propiedad de permeabilidad. <br><br>  Con la permeabilidad, creo que todo est√° claro por qu√© es necesario, pero las coordenadas indicar√°n el orden del punto en la cuadr√≠cula, estas coordenadas no est√°n vinculadas espec√≠ficamente a la posici√≥n del punto en el espacio.  La imagen a continuaci√≥n muestra una cuadr√≠cula simple que muestra las diferencias de coordenadas desde una posici√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/c12/466/7c1c124662f7c41ecb2a1c55939a1a64.png" alt="imagen"><br>  <i>¬øPor qu√© las coordenadas?</i> <br>  El hecho es que, en la unidad, para indicar la posici√≥n de un objeto en el espacio, <b>se utiliza</b> un <b>flotador</b> simple que es muy inexacto y puede ser un n√∫mero fraccionario o negativo, por lo que ser√° dif√≠cil usarlo para implementar una b√∫squeda de ruta en el mapa.  Las coordenadas se hacen en forma de un <b>int</b> claro que siempre ser√° positivo y con el que es mucho m√°s f√°cil trabajar cuando se buscan puntos vecinos. <br><br>  Primero, definamos un objeto de punto, esta ser√° una estructura de <b>Nodo</b> simple. <br><br><div class="spoiler">  <b class="spoiler_title">Nodo</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; }</code> </pre> <br></div></div><br>  Esta estructura contendr√° la posici√≥n de <b>posici√≥n</b> en forma de <b>Vector2</b> , donde con esta variable dibujaremos un punto en el espacio.  La <b>variable de</b> coordenadas de los <b>coords</b> en forma de <b>Vector2Int</b> indicar√° las coordenadas de un punto en el mapa, y la variable <b>id</b> su n√∫mero de cuenta num√©rico us√°ndolo, compararemos diferentes puntos en la cuadr√≠cula y verificaremos la existencia de un punto. <br><br>  La permeabilidad del punto se indicar√° en forma de su propiedad <b>booleana</b> , pero como no podemos usar los <i>tipos de</i> datos <i>convertibles</i> en el sistema de tareas, indicaremos su permeabilidad en forma de un n√∫mero <b>int</b> , para esto utilic√© una enumeraci√≥n simple <b>NodeType</b> , donde: 0 no es un punto transitable, y 1 es pasable. <br><br><div class="spoiler">  <b class="spoiler_title">NodeType y Node</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enum NodeType { NonWalkable = <span class="hljs-number"><span class="hljs-number">0</span></span>, Walkable = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> int nodeType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool isWalkable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType == (int)NodeType.Walkable;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node(int id, Vector2 position, Vector2Int coords, NodeType type) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coords = coords; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType = (int)type; } }</code> </pre> <br></div></div><br>  Adem√°s, para la conveniencia de trabajar con un punto, sobrecargar√© el m√©todo <b>Equals</b> para facilitar la comparaci√≥n de puntos y tambi√©n complementar√© el m√©todo de verificaci√≥n para la existencia de un punto. <br><br><div class="spoiler">  <b class="spoiler_title">Nodo</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool Equals(object obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Node) { Node other = (Node)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id == other.id; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.Equals(obj); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> implicit operator bool(Node node) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br></div></div><br>  Como el n√∫mero de <b>identificaci√≥n</b> del punto en la cuadr√≠cula comenzar√° con 1 unidad, comprobar√© la existencia del punto como condici√≥n de que su <b>identificaci√≥n sea</b> mayor que 0. <br><br>  Vaya a la clase <b>Mapa</b> donde prepararemos todo para crear un mapa. <br>  Ya tenemos una verificaci√≥n para cambiar los par√°metros del mapa, ahora necesitamos determinar c√≥mo se llevar√° a cabo el proceso de construcci√≥n de la cuadr√≠cula.  Para hacer esto, cree una nueva variable y varios m√©todos. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() {} <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  La propiedad de <b>reconstrucci√≥n</b> indicar√° si el proceso de <b>mallado</b> est√° en progreso.  El m√©todo <b>Reconstruir</b> recopilar√° datos y tareas para construir la cuadr√≠cula, luego el m√©todo <b>OnRebuildStart</b> comenzar√° el proceso de construcci√≥n de la cuadr√≠cula y el m√©todo <b>OnRebuildFinish</b> recopilar√° datos de las tareas. <br><br>  Ahora <b>cambiemos</b> un <b>poco el</b> m√©todo <b>UpdateChanges</b> para que se tenga en cuenta la condici√≥n de la cuadr√≠cula. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(‚Äú  ...‚Äù); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(‚Äú !‚Äù); OnRebuildStart(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Como puede ver ahora en el m√©todo <b>UpdateChanges</b> , <b>existe la</b> condici√≥n de que, mientras que la construcci√≥n de la malla antigua no comienza a construir una nueva, y tambi√©n en el m√©todo <b>Reconstruir</b> , la primera acci√≥n verifica si el proceso de mallado ya est√° en progreso. <br><br><h4>  Resoluci√≥n de problemas </h4><br>  Ahora un poco sobre el proceso de construcci√≥n de un mapa. <br>  Como usaremos el sistema de tareas y construiremos la cuadr√≠cula en paralelo para construir el mapa, utilic√© el tipo de tarea <b>IJobParallelFor</b> , que se ejecutar√° un cierto n√∫mero de veces.  Para no cargar el proceso de construcci√≥n con ninguna tarea separada, utilizaremos el conjunto de tareas empaquetadas en un <b>JobHandle</b> . <br><br>  Muy a menudo, para construir una cuadr√≠cula, use dos ciclos anidados entre s√≠ para construir, por ejemplo, horizontal y verticalmente.  En este ejemplo, tambi√©n construiremos la cuadr√≠cula primero horizontalmente y luego verticalmente.  Para hacer esto, calculamos el n√∫mero de puntos horizontales y verticales en el m√©todo <b>Reconstruir</b> , luego en el m√©todo <b>Reconstruir</b> pasamos por el ciclo a lo largo de los puntos verticales, y construiremos los horizontales en paralelo en la tarea.  Para imaginar mejor el proceso de construcci√≥n, eche un vistazo a la animaci√≥n a continuaci√≥n. <br><br><div class="spoiler">  <b class="spoiler_title">Malla</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/101/625/183/10162518305232afb889f9d8a45b70da.gif" alt="imagen"><br></div></div><br>  El n√∫mero de puntos verticales indicar√° el n√∫mero de tareas, a su vez, cada tarea crear√° puntos solo horizontalmente, despu√©s de completar todas las tareas, los puntos se suman en una lista.  Es por eso que necesito usar una tarea como <b>IJobParallelFor</b> para pasar el √≠ndice del punto en la cuadr√≠cula horizontalmente al m√©todo <b>Execute</b> . <br><br>  Y as√≠ tenemos la estructura de puntos, ahora puede crear la estructura de la tarea <b>Trabajo</b> y heredarla de la interfaz <b>IJobParallelFor</b> , todo es simple aqu√≠. <br><br><div class="spoiler">  <b class="spoiler_title">Trabajo</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Regresamos al m√©todo de <b>Reconstrucci√≥n de</b> clase de <b>Mapa</b> , donde haremos los c√°lculos necesarios para la medici√≥n de la cuadr√≠cula. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(‚Äú !‚Äù); Vector2 mapSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset * <span class="hljs-number"><span class="hljs-number">2</span></span>f; int horizontals = Mathf.RoundToInt(mapSize.x / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); int verticals = Mathf.RoundToInt(mapSize.y / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontals &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { OnRebuildFinish(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); OnRebuildStart(); } <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  En el m√©todo <b>Reconstruir</b> , calculamos el tama√±o exacto del mapa <b>mapSize</b> , teniendo en cuenta la sangr√≠a, luego en <b>verticales</b> escribimos el n√∫mero de puntos verticalmente, y en <b>horizontales el</b> n√∫mero de puntos horizontalmente.  Si el n√∫mero de puntos verticales es 0, entonces dejamos de construir el mapa y llamamos al m√©todo <b>OnRebuildFinish</b> para completar el proceso.  La variable de <b>origen</b> indicar√° el lugar desde donde comenzaremos a construir la cuadr√≠cula; en el ejemplo, este es el punto inferior izquierdo del mapa. <br><br>  Ahora puede ir a las tareas mismas y llenarlas con datos. <br>  Durante la construcci√≥n de la cuadr√≠cula, la tarea necesitar√° una matriz <b>NativeArray</b> donde <b>colocaremos</b> los puntos, tambi√©n dado que tenemos obst√°culos en el mapa, tambi√©n tendremos que pasarlos a la tarea, para esto usaremos otra matriz <b>NativeArray</b> , luego necesitamos el tama√±o de los puntos en el problema , la posici√≥n inicial desde donde construiremos los puntos, as√≠ como las coordenadas iniciales de la serie. <br><br><div class="spoiler">  <b class="spoiler_title">Trabajo</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Node&gt; array; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 startPos; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int startCoords; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  <b>Marqu√©</b> la matriz de puntos como un atributo con <b>WriteOnly,</b> ya que en la tarea solo ser√° necesario " <i>escribir</i> " los puntos recibidos en la matriz, por el contrario, la matriz de <b>l√≠mites</b> de obst√°culos <b>est√°</b> marcada con el atributo <b>ReadOnly</b> ya que en la tarea solo " <i>leeremos</i> " datos de esta matriz. <br><br>  Bueno, por ahora, procedamos al c√°lculo de los puntos mismos m√°s adelante. <br><br>  Ahora volvamos a la clase <b>Map</b> , donde denotamos todas las variables involucradas en las tareas. <br>  Aqu√≠, en primer lugar, necesitamos un <b>manejo</b> global <b>de</b> tareas, una serie de obst√°culos en forma de <b>NativeArray</b> , una lista de tareas que contendr√° todos los puntos recibidos en la cuadr√≠cula y el <b>Diccionario</b> con todas las coordenadas y puntos en el mapa, por lo que ser√≠a m√°s conveniente buscarlos m√°s tarde. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt; jobs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;Vector2Int, Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Vector2Int, Node&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  Ahora, nuevamente, volvemos al m√©todo <b>Reconstruir</b> y continuamos construyendo la cuadr√≠cula. <br>  Primero, inicialice la matriz de <b>l√≠mites</b> de obst√°culos para pasarla a la tarea. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Aqu√≠ creamos una instancia de <b>NativeArray a</b> trav√©s de un nuevo constructor con tres par√°metros.  Examin√© los dos primeros par√°metros en un art√≠culo anterior, pero el tercer par√°metro nos ayudar√° a ahorrar un poco de tiempo creando una matriz.  El hecho es que escribiremos datos en la matriz inmediatamente despu√©s de su creaci√≥n, lo que significa que no necesitamos asegurarnos de que se borre.  Este par√°metro es √∫til para <b>NativeArray,</b> que solo se usar√° en modo de <i>lectura</i> en la tarea. <br><br>  Y as√≠, luego llenamos la matriz de <b>l√≠mites</b> con datos. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Ahora podemos pasar a crear tareas, para esto pasaremos por un ciclo a trav√©s de todas las filas verticales de la cuadr√≠cula. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Para empezar, en <b>xPos</b> e <b>yPos</b> obtenemos la posici√≥n horizontal inicial de la serie. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  A continuaci√≥n, creamos una <b>matriz nativa</b> simple donde se <b>colocar√°n</b> los puntos en la tarea, aqu√≠ para la <b>matriz</b> que necesita especificar cu√°ntos puntos se crear√°n horizontalmente y el tipo de asignaci√≥n <b>Persistente</b> , porque la tarea puede tomar m√°s de un fotograma. <br>  Despu√©s, creamos la instancia de la tarea <b>Job en</b> s√≠, <b>colocamos</b> las coordenadas iniciales de la serie <b>startCoords</b> , la posici√≥n inicial de la serie <b>startPos</b> , el tama√±o de los puntos <b>nodeSize</b> , la matriz de <b>l√≠mites</b> de obst√°culos y, al final, la matriz de puntos en s√≠. <br>  Solo queda poner la tarea en <b>control</b> y la lista de tareas global. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(horizontals, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Add(array); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Listo  Tenemos una lista de tareas y su <b>identificador</b> com√∫n, ahora podemos ejecutar este <b>identificador</b> llamando a su m√©todo <b>Completo</b> en el m√©todo <b>OnRebuildStart</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Onrebuildstart</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  Dado que la variable de <b>reconstrucci√≥n</b> indicar√° que el proceso de <b>mallado</b> est√° en marcha, el m√©todo <b>UpdateChanges</b> tambi√©n debe especificar la condici√≥n en la que este proceso terminar√° usando el <b>identificador</b> y su propiedad <b>IsCompleted</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Cambios de actualizaci√≥n</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(‚Äú  ...‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) OnRebuildFinish(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } }</code> </pre> <br></div></div><br>  Despu√©s de completar las tareas, se <b>llamar√° al</b> m√©todo <b>OnRebuildFinish</b> donde ya recopilaremos los puntos recibidos en una lista general del <b>Diccionario</b> , y lo m√°s importante, para eliminar los recursos ocupados. <br><br><div class="spoiler">  <b class="spoiler_title">OnRebuildFinish</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Clear(); foreach (NativeArray&lt;Node&gt; array <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs) { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Add(node.coords, node); array.Dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.IsCreated) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, borramos el diccionario de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de los puntos anteriores, luego usamos el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bucle foreach para</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> clasificar todos los puntos que recibimos de las tareas y ponerlos en el diccionario de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donde la clave son las coordenadas (¬° </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NO la posici√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !) Del punto, y el valor es el punto en s√≠. </font><font style="vertical-align: inherit;">Con la ayuda de este diccionario, ser√° m√°s f√°cil para nosotros buscar puntos vecinos en el mapa. </font><font style="vertical-align: inherit;">Despu√©s de llenar, borramos la matriz de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matriz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usando el m√©todo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dispose</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y al final borramos la lista de tareas de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trabajo en</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√≠ </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n deber√° despejar los </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l√≠mites</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de obst√°culos </font><font style="vertical-align: inherit;">si se cre√≥ anteriormente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de todas estas acciones, obtenemos una lista de todos los puntos en el mapa y ahora puede dibujarlos en el escenario.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo como esto</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/65f/2d0/5a8/65f2d05a86a6a508900fcf321d546089.gif" alt="imagen"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, en la clase </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">cree el m√©todo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> donde dibujaremos los puntos.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora a trav√©s del ciclo dibujamos cada punto. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); } } #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despu√©s de todas estas acciones, nuestro mapa se ve de alguna manera aburrido, para realmente obtener una cuadr√≠cula, necesita que los puntos est√©n conectados entre s√≠. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malla</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/460/01d/f10/46001df105fcb2bd9fb90ef382888f26.gif" alt="imagen"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para buscar puntos vecinos, solo necesitamos encontrar el punto deseado por sus coordenadas en 8 direcciones, por lo que en la clase </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> crearemos una matriz est√°tica simple de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direcciones</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><b><font style="vertical-align: inherit;">Direcciones</font></b><font style="vertical-align: inherit;"> y un m√©todo de b√∫squeda de celdas por sus coordenadas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly Vector2Int[] Directions = { Vector2Int.up, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), Vector2Int.right, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.down, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.left, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), }; <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node GetNode(Vector2Int coords) { Node result = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(Node); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes[coords]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√©todo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devolver√° un punto por coordenadas de la lista de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero debe hacerlo con cuidado, porque si las coordenadas de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector2Int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son incorrectas, se producir√° un error, por lo que aqu√≠ usamos el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloque de </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">omisi√≥n de</font></b><font style="vertical-align: inherit;"> la </font><font style="vertical-align: inherit;">excepci√≥n </font><b><font style="vertical-align: inherit;">try catch</font></b><font style="vertical-align: inherit;"> , que ayudar√° a evitar la excepci√≥n y no " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colgar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " toda la aplicaci√≥n con un error. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, veremos el ciclo en todas las direcciones e intentaremos encontrar puntos vecinos en el m√©todo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y, lo m√°s importante, no olvidemos considerar la permeabilidad del punto.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ondrawgizmos</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { Color c = Gizmos.color; foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Color newColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) newColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">153</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> newColor = Color.red; Gizmos.color = newColor; Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); newColor = Color.green; Gizmos.color = newColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Directions.Length; i++) { Vector2Int coords = node.coords + Directions[i]; Node connection = GetNode(coords); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection.isWalkable) Gizmos.DrawLine(node.position, connection.position); } } } } Gizmos.color = c; } #endif</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora puedes iniciar el juego de forma segura y ver qu√© sucedi√≥. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa din√°mico</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/302/3ae/4e3/3023ae4e31ba9b2f888c27c4a9144ab7.gif" alt="imagen"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este ejemplo, construimos solo el gr√°fico en s√≠ mediante tareas, pero esto es lo que sucedi√≥ despu√©s de que atornill√© en el sistema el algoritmo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que tambi√©n utiliza el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema Job</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para encontrar la ruta, la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fuente al final del art√≠culo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B√∫squeda de mapas y rutas</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/769/46c/b2a76946c68d7af5dc30d3226e27b5a1.gif" alt="imagen"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, puede utilizar el nuevo sistema de tareas para sus objetivos y crear sistemas interesantes sin mucho esfuerzo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como en el art√≠culo anterior, el sistema de tareas se usa sin </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero si usa este sistema junto con </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puede lograr resultados simplemente sorprendentes en ganancias de rendimiento. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buena suerte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buscador de ruta Fuente del proyecto</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423601/">https://habr.com/ru/post/es423601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423589/index.html">C√≥mo elegimos TTS por ejemplo suena en el Diccionario</a></li>
<li><a href="../es423591/index.html">Viejas canciones sobre lo principal. Java y solicitudes salientes</a></li>
<li><a href="../es423593/index.html">Google anuncia un concurso para ataques a algoritmos de visi√≥n artificial</a></li>
<li><a href="../es423595/index.html">Frango Anomal√≠a, Intercambio</a></li>
<li><a href="../es423597/index.html">C√≥mo y qu√© cl√∫steres se pueden asignar en la base de clientes</a></li>
<li><a href="../es423603/index.html">RxSwift parte 1</a></li>
<li><a href="../es423607/index.html">Linus Torvalds abandona el estilo duro y toma tiempo</a></li>
<li><a href="../es423609/index.html">¬øA d√≥nde van los sitios web despu√©s de la muerte? Experiencia personal</a></li>
<li><a href="../es423611/index.html">Pago con un clic: ¬øbueno o malo?</a></li>
<li><a href="../es423615/index.html">Habilidades profesionales demandadas entre especialistas en UX (segmento 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>