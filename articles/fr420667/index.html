<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☀️ 👐🏻 🤳🏿 Principes de fonctionnement du protocole EIGRP 😛 🐡 👨🏽‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article parlera d'EIGRP et expliquera comment ce protocole fonctionne. L'EIGRP est un protocole à vecteur de distance, il est parfois dit hybride,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Principes de fonctionnement du protocole EIGRP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420667/"> Cet article parlera d'EIGRP et expliquera comment ce protocole fonctionne.  L'EIGRP est un protocole à vecteur de distance, il est parfois dit hybride, mais il ne l'est pas.  Lisez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">début de l'article</a> sur OSPF et vous comprendrez pourquoi EIGRP est un protocole vectoriel à distance.  EIGRP est un protocole de routage dynamique avancé à vecteur de distance développé par Cisco.  Faisons les choses correctement.  Nous utiliserons la topologie suivante: <br><br><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/4ed/cbb/733/4edcbb7335c70442a6ad9c1e4754e851.jpg" alt="Mon image"></a> <a name="habracut"></a><br><br>  Exécutez EIGRP sur vIOS1 et vIOS2, voyez comment les informations sont transmises entre les routeurs.  Dès que EIGRP est activé sur le routeur, le routeur commence à envoyer des paquets Hello.  Nous listons également d'autres types de messages utilisés dans EIGRP. <br><br><ul><li>  Bonjour - les routeurs utilisent des paquets bonjour pour découvrir les voisins.  Les paquets de multidiffusion sont envoyés et ne nécessitent pas de confirmation de réception. </li><li>  Mise à jour - contient des informations sur la modification des itinéraires.  Ils ne sont envoyés qu'aux routeurs concernés par la mise à jour.  Ces paquets peuvent être envoyés à un routeur spécifique (unicast) ou à un groupe de routeurs (multicast).  La réception d'un package de mise à jour est confirmée par l'envoi d'un ACK. </li><li>  Requête - lorsque le routeur calcule l'itinéraire et n'a pas de successeur possible, il envoie un paquet de requête à ses voisins afin de déterminer s'ils ont un successeur possible pour cette destination.  En règle générale, les paquets de requête sont envoyés par multidiffusion, mais il peut y avoir unidiffusion.  La réception du paquet de requête est confirmée par l'envoi de l'accusé de réception par le récepteur du paquet. </li><li>  Répondre - le routeur envoie un paquet de réponse en réponse au paquet de requête.  Les paquets de réponse sont envoyés en envoi individuel à celui qui a envoyé le paquet de requête.  La réception d'un paquet de réponse est confirmée par l'envoi d'un ACK. </li><li>  ACK - un paquet qui confirme la réception des paquets de mise à jour, de requête et de réponse.  Les paquets ACK sont envoyés en envoi individuel et contiennent un numéro d'accusé de réception.  En fait, ce sont des paquets bonjour qui ne transmettent pas de données.  La livraison non garantie est utilisée. </li></ul><br>  Il existe également des packages SIA, mais nous en parlerons ci-dessous. <br>  Les paquets sont envoyés à l'adresse de multidiffusion 224.0.0.10 toutes les 5 secondes (Hello Timer), Hold Timer est de 15 secondes = 3 intervalles de bonjour, si pendant ce minuteur aucun paquet de bonjour n'a été reçu d'un voisin, alors le voisin est supprimé de la liste des voisins.  Le package ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/144/cd2/7a5/144cd27a50a78ca0aeb70c7e4b15cfae.jpg" alt="Mon image"><br><br>  Le package contient les paramètres des coefficients (K1, K2, K3, K4, K5, K6), la minuterie de maintien et le numéro du système autonome.  Les coefficients (K1, K2, K3, K4, K5, K6) sont utilisés dans le calcul de la métrique, et nous en parlerons plus tard, ainsi que les temporisateurs EIGRP.  Maintenant, il est important de parler du système autonome (AS).  Pour activer EIGRP, un processus EIGRP spécifique doit recevoir un numéro, comme dans OSPF.  Mais contrairement à OSPF, cette option ne peut pas être sélectionnée au hasard pour chaque routeur, elle doit être la même pour tous les routeurs.  Si le routeur reçoit un paquet Hello avec un AS différent de celui-ci, il n'y aura pas de relation de voisinage. <br><br>  Pour que les routeurs deviennent voisins, les conditions suivantes doivent être remplies: <br><br><ul><li>  les routeurs doivent être authentifiés, </li><li>  les routeurs doivent être dans le même AS, </li><li>  Les relations de voisinage doivent être établies sur les adresses principales (lorsqu'un paquet bonjour arrive, le routeur vérifie si l'adresse de l'expéditeur du réseau appartient à l'adresse principale de l'interface), </li><li>  les valeurs des coefficients K doivent correspondre. </li></ul><br>  Pour que les routeurs deviennent des voisins EIGRP, ils ne doivent pas nécessairement correspondre aux durées Hello et Hold.  Le routeur utilise des valeurs de temporisation reçues du voisin.  Si la minuterie Hello ou Hold est modifiée sur l'un des routeurs, les voisins de ce routeur utiliseront ces valeurs.  Pour que le routeur utilise d'autres valeurs, il est nécessaire de changer le temporisateur sur l'interface correspondante du voisin.  Après avoir échangé des paquets Hello, un paquet de mise à jour est envoyé, mais il ne contient pas encore de routes, il contient l'indicateur Init, qui informe les routeurs du début de l'échange d'informations sur les routes.  Ce paquet est envoyé directement à l'adresse du routeur.  Après avoir échangé de tels messages, chaque routeur envoie un paquet de mise à jour avec des routes à l'adresse de multidiffusion 224.0.0.10: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd9/0da/c1c/dd90dac1c80680d40681289160f1898b.jpg" alt="Mon image"><br><br>  Comme vous pouvez le voir, le package de mise à jour ne contient aucune métrique, mais uniquement des informations telles que la bande passante, le retard, le MTU, etc. Après avoir reçu ces informations, le routeur lui-même calcule la métrique à l'aide des coefficients K1-K6.  Ces paquets peuvent être envoyés à un routeur spécifique ou à la multidiffusion.  En général, il existe trois types de mises à jour: <br><br><ul><li>  Non périodique (non périodique) - les mises à jour ne sont pas envoyées à intervalles réguliers, mais lorsque la topologie ou la métrique change; </li><li>  Partiel (Partiel) - toutes les informations de la table de routage ne sont pas transmises dans les mises à jour, mais uniquement les modifications; </li><li>  Limité - Les mises à jour sont envoyées uniquement aux routeurs impliqués. </li></ul><br>  Les quartiers au niveau des paquets ressemblent à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68a/588/fe6/68a588fe6adbe793d98c2b57b7da301e.jpg" alt="Mon image"><br><br>  Vous pouvez remarquer qu'en plus du Hello et de la mise à jour répertoriés par nous, il existe également Hello (ACK) et le nombre est égal au nombre de paquets de mise à jour envoyés à l'adresse de multidiffusion.  Tout tourne autour du protocole RTP.  Le protocole RTP contrôle le processus de transmission des paquets EIGRP et fournit: <br><br><ul><li>  Livraison de colis garantie. </li><li>  Préserver l'ordre des paquets. </li></ul><br>  Ce sont les choses.  Qu'avons-nous?  Les routes ont échangé des paquets de mise à jour et il est maintenant temps de créer une table de routage.  Chaque mise à jour est traitée et substitue les données (bande passante, retard, etc.) dans une formule spéciale, la métrique est calculée: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc6/0ab/062/cc60ab0622cbe1abb96521c2520b96ee.jpg" alt="Mon image"><br><br>  Une telle formule a l'air géniale, mais la meilleure chose à ce sujet est que vous ne la connaissez peut-être pas, sachez simplement que quelque chose comme ça existe.  Et une autre astuce intéressante est que les coefficients EIGRP par défaut sont: <br><br><ul><li>  K1 = 1 </li><li>  K2 = 0 </li><li>  K3 = 1 </li><li>  K4 = 0 </li><li>  K5 = 0 </li></ul><br>  Et la formule se transforme simplement en métrique = bande passante + retard.  Par conséquent, il est si important que les coefficients sur tous les routeurs soient les mêmes, afin qu'il n'y ait pas de problèmes dus aux différentes métriques sur les routeurs.  Parlons un peu plus en détail des données dans Update. <br><br><ul><li>  Bande passante - la valeur minimale parmi les canaux de bande passante menant au réseau est sélectionnée et envoyée à Update. </li><li>  Delay - Résume le délai de tous les canaux menant à ce réseau. </li><li>  Fiabilité - la pire mesure de fiabilité tout au long, basée sur Keepalive </li><li>  Chargement - le pire indicateur de chargement de lien tout le long, basé sur le taux de paquets et la bande passante configurée sur l'interface </li><li>  MTU est le plus petit MTU de tous les temps.  Malgré le fait qu'il soit utilisé dans Update, il ne participe pas au calcul de la métrique elle-même. </li></ul><br>  Comme indiqué ci-dessus, la bande passante et le retard sont utilisés par défaut.  Les paramètres restants sont rarement nécessaires en cas de besoin, mais à l'aide d'eux, un ajustement plus fin de la métrique est possible.  Ainsi, dans le paquet de mise à jour, le routeur passe la route et les données qui lui sont associées, il ne transmet pas la métrique elle-même.  Le routeur qui a reçu la mise à jour calcule la métrique selon la formule et, selon les métriques, décide de router ou non la route vers la table de routage.  Il est également important de noter que le <b>routeur ne transmet que les routes qu'il utilise.</b>  Voyons comment construire une table de topologie. <br><br>  <b>Table de topologie</b> - Une liste des routes apprises de chaque voisin.  La table de topologie stocke également la métrique que chaque voisin rapporte pour chaque route (AD) et la métrique que le routeur local utilisera pour atteindre la route via le voisin (FD). <br><br>  Il est nécessaire d'expliquer ce que sont AD et FD.  Nous allons configurer EIGRP sur tous nos routeurs.  De plus, pour éviter les nombres complexes dans la métrique, nous changeons les coefficients de K1 = 1 K2 = 0 K3 = 1 K4 = 0 K5 = 0 à K1 = 0 K2 = 0 K3 = 1 K4 = 0 K5 = 0. Ainsi, nous aurons 256 * Formule de délai et nous obtenons également un moyen facile de manipuler les métriques en modifiant le paramètre de délai sur les interfaces.  Étant donné que sur les interfaces, délai = 1 s, chaque lien, si vous utilisez la terminologie OSPF, coûte 256. Voyons quelle est la table de topologie sur vIOS1: <br><blockquote>  Topologie vIOS1 # show ip eigrp <br>  Table de topologie EIGRP-IPv4 pour AS (1) / ID (192.168.1.1) <br>  Codes: P - Passif, A - Actif, U - Mise à jour, Q - Requête, R - Réponse, <br>  r - Statut de réponse, s - Statut de sia <br><br>  P 192.168.3.0/24, 1 successeurs, FD est 512 <br>  via 192.168.13.3 (512/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 successeurs, FD est 512 <br>  via 192.168.12.2 (512/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 successeurs, FD est 512 <br>  via 192.168.12.2 (512/256), GigabitEthernet0 / 3 <br>  P 192.168.35.0/24, 1 successeurs, FD est 512 <br>  via 192.168.13.3 (512/256), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 successeurs, FD est 256 <br>  via Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 successeurs, FD est 512 <br>  via 192.168.14.4 (512/256), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 successeurs, FD est 256 <br>  via Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 successeurs, FD est 256 <br>  via Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 successeurs, FD est 256 <br>  via Connected, GigabitEthernet0 / 2 <br>  P 192.168.5.0/24, 3 successeurs, FD est 768 <br>  via 192.168.12.2 (768/512), GigabitEthernet0 / 3 <br>  via 192.168.13.3 (768/512), GigabitEthernet0 / 0 <br>  via 192.168.14.4 (768/512), GigabitEthernet0 / 2 </blockquote><br>  Si vous regardez, par exemple, le réseau - 192.168.5.0/24, vous remarquerez trois chemins via vIOS2, vIOS3 et vIOS4 avec les mêmes métriques.  Pour 192.168.5.0/24 FD, pour tous les chemins, il est égal - 768 et AD - 512. Donnons une définition d'un autre article et essayons d'expliquer: <br><br><ul><li>  <b>La distance</b> annoncée <b>(AD)</b> , également connue sous le nom de distance rapportée (RD), est le coût de la distance entre le routeur voisin qui annonce l'itinéraire et le réseau de destination. </li><li>  <b>Distance réalisable (FD)</b> - le coût de la distance entre le routeur local et le réseau de destination = AD, qui annonce le routeur voisin + le coût de la distance entre le routeur local et le routeur voisin. </li></ul><br><blockquote>  P 192.168.5.0/24, 3 successeurs, FD est 768 via 192.168.14.4 (768/512), GigabitEthernet0 / 2 </blockquote><br>  Examinons cette ligne de la table de topologie sur vIOS1.  vIOS1 a découvert la route à partir de vIOS4 (192.168.14.4).  Étant donné que vIOS1 sépare trois liens de 192.168.5.0/24, la métrique FD avec nos paramètres sera 3 * 256 = 768.  Et AD est la métrique de l'itinéraire par rapport au routeur (vIOS4) qui a annoncé ce réseau.  AD est la métrique FD de cette route sur vIOS4.  Regardons la table de topologie sur vIOS4: <br><blockquote>  P 192.168.5.0/24, 1 successeurs, FD est 512 via 192.168.45.5 (512/256), GigabitEthernet0 / 1 </blockquote><br>  AD sur vIOS1 = FD sur vIOS4.  Confusion silencieuse, mais essayez d'expliquer la logique du travail.  Le routeur qui annonce la route envoie les paramètres (Bande passante, Délai, etc.) de la route dans le message de mise à jour sans prendre en compte le lien entre le routeur qui est annoncé.  Autrement dit, vIOS4 ne prend en compte que les paramètres de deux liaisons: vIOS4 Gi0 / 1 - vIOS5 Gi0 / 1 et vIOS5 Gi0 / 0 - VPC.  Après avoir reçu Update, vIOS1, en remplaçant les paramètres obtenus dans la formule, calcule quoi?  C'est vrai - AD = 512.  Une fois qu'il prend les paramètres de liaison d'où provient l'itinéraire, vIOS1 Gi0 / 2 - vIOS4 Gi0 / 2 et le remplace à nouveau dans la formule.  Compte, obtient le nombre 256 et l'additionne avec AD (512), nous obtenons FD-768. Ce sont les choses!  Mais pourquoi tout ce rituel? <br>  Et tout cela pour créer une règle spéciale appelée la <b>condition Faisible</b> , qui est l'un des moyens de se protéger contre la formation de boucles et la convergence rapide. <br>  Définissons les termes suivants: <br><br><ul><li>  Le successeur est un routeur adjacent avec un chemin sans boucle et le chemin le plus économique vers le réseau de destination. </li><li>  Successeur possible - routeur de sauvegarde avec chemin sans boucles (le successeur réalisable AD doit être inférieur à FD de la route du successeur actuel). </li><li>  État réalisable - Le successeur réalisable AD doit être inférieur au FD de la route successeur actuelle. </li></ul><br>  Pour expliquer comment tout cela fonctionne et afficher les subtilités, vous devez modifier certaines mesures.  Faisons ce qui suit, modifions le délai afin que nous ayons de telles mesures de lien: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/678/c11/c2b/678c11c2b0f9b1dabb87a01ac62ff9e4.jpg" alt="Mon image"><br><br>  Cela se fait à l'aide de la commande de délai sur l'interface.  Maintenant, nous avons dit - delay = 1 et la métrique est 256. Voyons quelles métriques nous obtenons pour le réseau 192.168.5.0/24 sur le routeur vIOS1: <br><br><ul><li>  Via vIOS2 - FD = 2304, AD = 1280 </li><li>  Via vIOS4 - FD = 1024, AD = 768 </li><li>  Via vIOS3 - FD = 1536, AD = 768 </li></ul><br>  Comme nous voyons que le meilleur FD sera pour la route via vIOS4, il sera ajouté à la table de routage générale, cette route est appelée <b>Successeur</b> : <br><blockquote>  vIOS1 # show ip route eigrp <br>  Codes: L - local, C - connecté, S - statique, R - RIP, M - mobile, B - BGP <br>  D - EIGRP, EX - EIGRP externe, O - OSPF, IA - OSPF inter zone <br>  N1 - OSPF NSSA externe type 1, N2 - OSPF NSSA externe type 2 <br>  E1 - OSPF externe type 1, E2 - OSPF externe type 2 <br>  i - IS-IS, su - Résumé IS-IS, L1 - IS-IS niveau 1, L2 - IS-IS niveau 2 <br>  ia - inter-zone IS-IS, * - par défaut candidat, U - route statique par utilisateur <br>  o - ODR, P - itinéraire statique téléchargé périodiquement, H - NHRP, l - LISP <br>  a - voie d'application <br>  + - route répliquée,% - remplacement du saut suivant, p - substitutions de PfR <br><br>  La passerelle de dernier recours n'est pas définie <br><br>  D 192.168.2.0/24 [90/512] via 192.168.12.2, 06:01:31, GigabitEthernet0 / 3 <br>  D 192.168.3.0/24 [90/1024] via 192.168.13.3, 06:01:28, GigabitEthernet0 / 0 <br>  D 192.168.5.0/24 [90/1024] via 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.25.0/24 [90/1024] via 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.35.0/24 [90/1024] via 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.45.0/24 [90/768] via 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 </blockquote><br>  Qu'adviendra-t-il des deux autres routes - elles seront vérifiées pour la condition FS (condition faisable).  La route via vIOS3 passe cette condition AD (via vIOS3) = 768 &lt;1024 = FD (via vIOS1).  Par conséquent, cette route, bien qu'elle ne soit pas ajoutée à la table de routage générale, elle sera stockée dans les tables de topologie: <br><blockquote>  Topologie vIOS1 # show ip eigrp <br>  Table de topologie EIGRP-IPv4 pour AS (1) / ID (192.168.1.1) <br>  Codes: P - Passif, A - Actif, U - Mise à jour, Q - Requête, R - Réponse, <br>  r - Statut de réponse, s - Statut de sia <br><br>  P 192.168.3.0/24, 1 successeurs, FD est 1024 <br>  via 192.168.13.3 (1024/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 successeurs, FD est 1024 <br>  via 192.168.12.2 (1024/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 successeurs, FD est 1024 <br>  via 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  via 192.168.13.3 (1536/768), GigabitEthernet0 / 0 <br>  P 192.168.35.0/24, 1 successeurs, FD est 1024 <br>  via 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  via 192.168.13.3 (1280/512), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 successeurs, FD est 768 <br>  via Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 successeurs, FD est 768 <br>  via 192.168.14.4 (768/512), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 successeurs, FD est 512 <br>  via Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 successeurs, FD est 768 <br>  via Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 successeurs, FD est 256 <br>  via Connected, GigabitEthernet0 / 2 <br>  <b>P 192.168.5.0/24, 1 successeurs, FD est 1024</b> <br>  via 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  <b>via 192.168.13.3 (1536/768), GigabitEthernet0 / 0</b> </blockquote><br>  Il n'a pas la métrique de la meilleure route, c'est-à-dire qu'il n'est pas un successeur, mais il joue le rôle d'une route de sauvegarde et, si le successeur est perdu, prendra immédiatement sa place.  Cela permet une convergence très rapide du protocole, mais plus à ce sujet plus tard.  Cette route est appelée <b>successeur possible</b> .  Et qu'adviendra-t-il de la troisième route?  Rien, il ne remplit pas la condition FC (1280&gt; 1024) et ne sera pas pris en compte pour le protéger du bouclage.  Toutes les routes reçues via Update mais non testées par FC peuvent être vues à l'aide de la commande show ip eigrp topology all-links.  On ne sait pas pourquoi la condition FS protège contre la formation de boucles, essayons maintenant de l'expliquer.  Il est important de savoir que lors de l'étude du protocole EIGRP, il est essentiel de comprendre le principe de la condition FC et le but pour lequel il est utilisé.  Considérez une topologie légèrement modifiée (ajout d'un lien entre vIOS2 et vIOS4), et utilisez également la métrique la plus primitive: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/734/050/472/7340504727cf56fa62300883800f363f.jpg" alt="Mon image"><br><br>  La route vers le réseau 192.168.5.0/24 sera la même avec AD et FD: <br><br><ul><li>  vIOS4 - via vIOS5, AD = 5, FD = 10. </li><li>  vIOS1 - via vIOS4, AD = 10, FD = 11. </li><li>  vIOS3 - via vIOS1, AD = 11, FD = 12. </li></ul><br>  Mais vIOS4 recevra une mise à jour de vIOS2, qui contiendra l'itinéraire vers le réseau 192.168.5.0/24 via vIOS2 avec la métrique - AD = 12, FD = 15.  Il est clair qu'il ne peut pas être un successeur, si tout à coup cette route est choisie par le successeur faisable, alors si le successeur tombe sur vIOS4 et que le successeur choisit cette route, une boucle se produit.  Mais FC ne permettra pas de définir cette route comme FS comme AD = 12&gt; 10 = FD.  La route vers vIOS2 contient le chemin d'accès via vIOS4, et dans tous les cas, son AD inclut également FD vIOS4.  Autrement dit, AD sur vIOS2 contient les liens suivants: <br><blockquote>  12 = AD sur vIOS2 = Gi0 / 3 vIOS3 + Gi0 / 2 vIOS4 + Gi0 / 1 vIOS5 + eth0 VPC5, où Gi0 / 1 vIOS5 + eth0 VPC5 = FD = 10 - il s'agit de FD vIOS4 et il est impossible pour AD &lt;FD d'être moins. </blockquote><br>  Ainsi, la condition FC vérifie la route pour la présence d'elle-même dans cette route.  Seuls les itinéraires qui remplissent cette condition peuvent garantir qu'il n'y a pas de boucles.  Il peut y avoir des cas où la route ne crée pas de boucle, mais en même temps ne satisfait pas la condition FC, nous ne l'utiliserons pas, dans de tels cas, nous choisissons la stabilité du réseau.  Si vous approfondissez, la condition est assez simple et intuitive.  L'algorithme qui sélectionne les meilleures routes dans le protocole EIGRP est appelé <b>DUAL</b> .  Considérons maintenant le protocole EIGRP à la question de la convergence dans la perte de la route principale.  Revenons à notre ancienne grande topologie et imaginons que vIOS4 a disparu.  Selon la façon dont vIOS4 a disparu, le comportement sera légèrement différent, mais il différera lorsque le déclencheur se déclenchera.  Si, par exemple, nous désactivons l'interface Gi 0/2 sur vIOS1, puis vIOS1 détecte immédiatement la perte d'un voisin et commence à agir, si le voisin disparaît sans avertissement, alors Hold Timer fonctionnera après qu'il ne reçoive pas de paquets Hello pendant 15 secondes: <br><blockquote>  D 192.168.2.0/24 [90/512] via 192.168.12.2, 06:01:31, GigabitEthernet0 / 3 <br>  D 192.168.3.0/24 [90/1024] via 192.168.13.3, 06:01:28, GigabitEthernet0 / 0 <br>  D 192.168.5.0/24 [90/1024] via 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.25.0/24 [90/1024] via 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.35.0/24 [90/1024] via 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br>  D 192.168.45.0/24 [90/768] via 192.168.14.4, 06:01:28, GigabitEthernet0 / 2 <br><br>  P 192.168.3.0/24, 1 successeurs, FD est 1024 <br>  via 192.168.13.3 (1024/256), GigabitEthernet0 / 0 <br>  P 192.168.2.0/24, 1 successeurs, FD est 1024 <br>  via 192.168.12.2 (1024/256), GigabitEthernet0 / 3 <br>  P 192.168.25.0/24, 1 successeurs, FD est 1024 <br>  via 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  via 192.168.13.3 (1536/768), GigabitEthernet0 / 0 <br>  P 192.168.35.0/24, 1 successeurs, FD est 1024 <br>  via 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  via 192.168.13.3 (1280/512), GigabitEthernet0 / 0 <br>  P 192.168.12.0/24, 1 successeurs, FD est 768 <br>  via Connected, GigabitEthernet0 / 3 <br>  P 192.168.45.0/24, 1 successeurs, FD est 768 <br>  via 192.168.14.4 (768/512), GigabitEthernet0 / 2 <br>  P 192.168.0.0/24, 1 successeurs, FD est 512 <br>  via Connected, GigabitEthernet0 / 1 <br>  P 192.168.13.0/24, 1 successeurs, FD est 768 <br>  via Connected, GigabitEthernet0 / 0 <br>  P 192.168.14.0/24, 1 successeurs, FD est 256 <br>  via Connected, GigabitEthernet0 / 2 <br>  P 192.168.5.0/24, 1 successeurs, FD est 1024 <br>  via 192.168.14.4 (1024/768), GigabitEthernet0 / 2 <br>  via 192.168.13.3 (1536/768), GigabitEthernet0 / 0 </blockquote><br>  J'ai apporté à nouveau la table de routage et de topologie pour plus de commodité, afin que pour comprendre comment le routeur agira sur chaque route, vous devez savoir dans quel état il se trouvait auparavant.  Par exemple, la route dont nous avons discuté précédemment, la route 192.168.5.0/24 sera perdue, mais elle avait FS dans la table de topologie et donc, dès que la route principale sera perdue, elle prendra sa place dans la table de routage.  Une question intéressante est de savoir ce qui arrivera aux routes sans FS.  Mais un peu de matériel: <br><br>  Les entrées dans la table de topologie peuvent être dans deux états: actif et passif.  La route est dans un état passif lorsque la route est stable et que la recherche de la meilleure route ne se produit pas.  En état actif - si vous recherchez le meilleur itinéraire.  Une recherche d'itinéraire est effectuée lorsqu'il n'y a pas de successeur possible pour le réseau de destination.  Le routeur, à la recherche d'un meilleur itinéraire, envoie une requête (envoie un paquet de requête) à chaque routeur voisin.  Si le voisin a une route vers le réseau de destination, il répond (envoie un paquet de réponse), s'il n'y a pas de route, le voisin envoie une requête à ses voisins.  Le routeur compare tous les FD pour atteindre un réseau spécifique, sélectionne l'itinéraire avec le plus petit FD et le place dans la table de routage.  La table de topologie peut stocker 6 itinéraires vers le réseau du destinataire (principal et de secours). <br><br>  Les routes qui ont été perdues et qui n'avaient pas FS passeront à Active et vIOS1 commencera à poser des questions sur leurs voisins restants.  Cela se fait à l'aide de messages de requête.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1 enverra des messages de requête aux routeurs vIOS2 et vIOS3, où il indiquera clairement les routes dont il a besoin - dans notre cas, ces routes seront 192.168.14.0/24, 192.168.45.0/24. Avec ce message, vIOS1 informe également les routeurs que les itinéraires via vIOS1 vers ces réseaux sont inutilisables. Cela se fait en spécifiant le paramètre Delay: Infifnity dans la métrique de cette route, c'est-à-dire que la métrique est infiniment grande. Dès que les routeurs reçoivent de tels messages, ils suppriment ces routes via vIOS1. Cette technologie est appelée </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poison Reverse.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Poison Reverse est également utilisé pour les messages de mise à jour, j'en parlerai un peu plus tard. Après avoir reçu une requête avec une demande de routes 192.168.14.0/24, 192.168.45.0/24, vIOS2 et vIOS3 verront s'ils ont ces routes, qu'ils utilisent, le cas échéant, ils enverront immédiatement une réponse avec de nouvelles métriques pour ces routes. vIOS2 et vIOS3, comme nous le savons, n'ont pas perdu leurs itinéraires, ils enverront donc immédiatement Répondre. Si le routeur qui est également demandé n'a pas cette route, il transmettra la requête à ses voisins et ainsi de suite. vIOS1 attendra la réponse de vIOS2, vIOS3, puis Active Timer entre en scène, qui démarre dès que la requête est envoyée: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Active Timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- l'intervalle de temps pendant lequel l'itinéraire peut rester à l'état actif. Si le temporisateur expire avant que toutes les réponses des voisins ne soient reçues (réponse), le routeur met la route dans un état bloqué-actif. De plus, les relations du quartier sont rompues avec les voisins de qui aucune réponse n'a été reçue. Par défaut, cette minuterie est de 3 minutes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autrement dit, si la réponse n'est pas reçue dans les 3 minutes, malgré les paquets Hello, le quartier sera rompu et c'est très mauvais. Malgré le fait que 3 minutes soit comme une éternité pour de tels protocoles, de telles situations sont possibles avec de grandes topologies. Pour se protéger contre la rupture erronée de la relation de voisinage, des messages spéciaux ont été inventés - SIA-Query et SIA-Reply.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour améliorer la réponse du routeur à l'état de la route active, deux types de messages sont en outre introduits: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIA-Query - Expédié après 1,5 minute (par défaut) afin de vérifier l'état d'un routeur directement connecté. </font><font style="vertical-align: inherit;">Afin que, si la route qui se trouve derrière le voisin (alors que la connexion avec le voisin est normale) soit perdue, les relations de voisinage avec le routeur directement connecté ne sont pas réinitialisées. </font><font style="vertical-align: inherit;">Ne nécessite pas de confirmation de réception. </font><font style="vertical-align: inherit;">Après avoir envoyé trois messages et ne pas avoir reçu de réponse, le voisin est considéré comme arrêté et l'itinéraire est supprimé de la table de topologie.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIA-Reply - Envoyé en réponse à SIA-Query. </font><font style="vertical-align: inherit;">Ne nécessite pas de confirmation de réception.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après 1,5 minute, si la réponse à une requête n'est pas reçue, alors la requête SIA est envoyée, ce qui ne nécessite pas de nouvelle route, mais doit uniquement envoyer la réponse SIA, pour s'assurer que le voisin est en ordre, ne peut tout simplement pas trouver la bonne route </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pense à la façon dont le routeur réagit à la perte de la route dans le cas où il y a FS ou non, nous en avons assez dit. Il suffit de modifier les éléments suivants. Nous n'avons pas donné correctement la définition de FD, la métrique que nous calculons selon la formule lorsque nous recevons un itinéraire pour la première fois ou lorsque l'état de l'itinéraire change encore, il serait correct d'appeler CD - Distance calculée.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD est le meilleur indicateur pour un itinéraire donné qui ait jamais été obtenu, et c'est lui qui participe au contrôle FC. </font><font style="vertical-align: inherit;">Le plus souvent, FD = CD est le meilleur itinéraire, mais voyons comment FD a changé après l'effondrement du quartier avec vIOS4:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 successeurs, FD est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1024</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> via 192.168.13.3 ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1536</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> /768), GigabitEthernet0 / 0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'avons plus de route avec CD = 1024, la meilleure route via vIOS3 est CD = 1536, mais comme vous pouvez le voir, FD = 1024, qui a été corrigé lorsqu'il y avait une route via vIOS4. </font><font style="vertical-align: inherit;">FD ne sera mis à jour que lorsque cette route passera à l'état Actif. </font><font style="vertical-align: inherit;">Tant que l'état ne passera pas de passif à actif, FD ne changera pas non plus. </font><font style="vertical-align: inherit;">Les mises à jour régulières ne s'y appliquent pas. </font><font style="vertical-align: inherit;">Encore une remarque. </font><font style="vertical-align: inherit;">Faisons cette expérience: renvoyons le voisinage avec vIOS4, CD via vIOS3 = 1536 et via vIOS2 = 2048. Augmentez le délai du canal entre vIOS1 et vIOS3 afin qu'il devienne plus grand que le CD vIOS2:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 successeurs, FD est 1024 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">via 192.168.14.4 (1024/768), GigabitEthernet0 / 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">via 192.168.13.3 ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2304</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> /768), GigabitEthernet0 / 0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous voyons le CD via vIOS3 = 2304, mais il est resté FS puisque AD n'a pas changé et la condition FC a été remplie, comme auparavant. </font><font style="vertical-align: inherit;">Nous nous posons une question: que se passe-t-il lorsqu'un itinéraire est perdu via vIOS2? </font><font style="vertical-align: inherit;">La réponse attendue et logique, comme on nous l'a appris, est FS à la place, mais non! </font><font style="vertical-align: inherit;">Puisqu'il existe toujours une route via vIOS2 avec CD = 2048 &lt;2304, la route passera à l'état Actif et recalculera la métrique pour elle et sélectionnera la meilleure route malgré le fait qu'elle avait une route de sauvegarde. </font><font style="vertical-align: inherit;">Nous regardons la table de topologie et obtenons:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24, 1 successeurs, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD est 2048</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> via 192.168.12.2 (2048/1280), GigabitEthernet0 / 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">via 192.168.13.3 (2304/768), GigabitEthernet0 / 0</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La route via vIOS2 sera utilisée, et comme l'a noté FD, elle a également changé en raison de la transition de la route à l'état Actif. </font><font style="vertical-align: inherit;">Et l'itinéraire via vIOS3 partage à nouveau le sort de la pièce de rechange.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fractionner les règles inverses d'horizon et de poison dans EIGRP </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans RIP, EIGRP utilise la règle Split Horizon - si une route est accessible via une interface spécifique, cette route n'est pas incluse dans la mise à jour envoyée via cette interface. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, si vIOS4 reçoit un itinéraire vers le réseau 192.168.0.0/24 de vIOS1, il n'enverra pas cet itinéraire à Update via l'interface à laquelle vIOS1 est connecté. Pour être plus précis, imaginez que vIOS1 a commencé à parler du réseau 192.168.0.0/24. J'ai envoyé Update à vIOS4, vIOS4 le recevra et, en règle générale, Split Horizon ne devrait pas envoyer sa mise à jour avec cette route à vIOS1, mais en réalité, il l'enverra avec une métrique infinie. Comme si vIOS4 disait vIOS1 - "N'osez pas utiliser la route vers le réseau 192.168.0.0/24 par moi, j'ai obtenu cette route de vous et si vous l'utilisez, il y aura une boucle."</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poison Reverse - indiquant un itinéraire inaccessible à l'aide d'une métrique lorsqu'il est perdu. </font><font style="vertical-align: inherit;">Dans EIGRP, cela se fait à l'aide du paramètre Delay. </font><font style="vertical-align: inherit;">Nous avons indiqué ci-dessus comment cette technologie est utilisée lorsque vIOS1 a perdu le contact avec vIOS4. </font><font style="vertical-align: inherit;">D'après ce qui précède sur Split Horizon, nous pouvons conclure que la technologie Poison Reverse est utilisée non seulement dans les messages de requête, mais aussi dans la mise à jour. </font><font style="vertical-align: inherit;">En outre, Poison Reverse peut violer la règle Split Horizon et envoyer Update avec des métriques infinies depuis l'interface à partir de laquelle il a reçu cette mise à jour. </font><font style="vertical-align: inherit;">Ces deux règles, ainsi que la clause FC, assurent la protection du protocole EIGRP contre les boucles.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Routeurs stub </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme optimisation, un rôle spécial pour les routeurs a été introduit dans le protocole - Stub. </font><font style="vertical-align: inherit;">Quelque chose comme la zone Stub dans OSPF, mais voici un principe de fonctionnement légèrement différent. </font><font style="vertical-align: inherit;">Lors de la configuration du routeur en mode stub, il signale immédiatement dans les paquets Hello à son voisin son état de stub et, selon le mode de stub, peut envoyer certains types de routes:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS5 # eigrp stub [connecté | </font><font style="vertical-align: inherit;">carte des fuites | </font><font style="vertical-align: inherit;">recevoir uniquement | </font><font style="vertical-align: inherit;">redistribué | </font><font style="vertical-align: inherit;">statique | </font><font style="vertical-align: inherit;">résumé]</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Options de la commande stub Eigrp: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sans options (par défaut) - connecté et résumé; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> connected - Permet au routeur de raccord d'envoyer des itinéraires connectés, mais uniquement pour les interfaces dont les adresses se trouvent sur les réseaux spécifiés par la commande network; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> leak-map - Autorise les préfixes dynamiques basés sur la fuite-map; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> recevoir uniquement - Empêche le routeur de raccord d'envoyer des itinéraires; </font></font></li><li> redistributed —  stub   redistributed ; </li><li> static —  stub   static ,  ,      ; </li><li> summary —  stub     (   ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais la principale caractéristique de ce paramètre est que si le routeur sait que son voisin est dans le rôle Stub, il ne lui enverra pas de requête pour les routes qui sont devenues actives. </font><font style="vertical-align: inherit;">Par exemple, si nous configurons vIOS5 en tant que Stub, alors vIOS2-4 le découvrira et si les routes sont perdues, elles n'empoisonneront pas Query. </font><font style="vertical-align: inherit;">Compte tenu des problèmes pouvant survenir en l'absence de réponse, il serait intéressant d'envoyer la requête uniquement là où cela a du sens. </font><font style="vertical-align: inherit;">Ceci est important dans les grandes topologies où la convergence peut être un processus complexe. </font><font style="vertical-align: inherit;">Par conséquent, s'il existe un routeur final et que seuls les réseaux d'utilisateurs y sont connectés (relativement parlant, il n'a qu'un seul voisin), il est préférable de penser à le configurer en tant que Stub.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelques mots sur les minuteries </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous avons parlé de certains d'entre eux, si vous regardez la sortie de la commande show ip eigrp voisins, nous verrons ce qui suit: </font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1 # show ip eigrp voisins </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIGRP-IPv4 voisins pour AS (1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H Address Interface Hold Uptime SRTT RTO Q Seq </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(sec) (ms) Cnt Num </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2192.168.14.4 Gi0 / 2 11 00:48:43 23138 0168 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 192.168.12.2 Gi0 / 3 12 02:31:12 6 100 0 258 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 192.168.13.3 Gi0 / 0 10 2d13h 7 100 0 291 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1 #</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici des minuteries qui nécessitent une explication. </font><font style="vertical-align: inherit;">Si, en réponse à l'envoi de tout paquet de multidiffusion qui nécessite une confirmation de réception, un accusé de réception (ACK) n'a pas été envoyé, alors le paquet de monodiffusion sera transmis au voisin qui ne répond pas. </font><font style="vertical-align: inherit;">Si la confirmation n'a pas été reçue même après l'envoi de 16 paquets de monodiffusion, le voisin est considéré comme inactif.</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temps aller-retour fluide (SRTT)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - le temps entre l'envoi d'un paquet à un voisin et la réception d'une confirmation de sa part. </font><font style="vertical-align: inherit;">Mesuré en millisecondes. </font><font style="vertical-align: inherit;">La formule de calcul est exclusive.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicast Flow Timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - la valeur maximale de l'intervalle en secondes pendant lequel le routeur attendra le paquet ACK après avoir envoyé le paquet EIGRP à l'adresse multicast avant de passer à l'envoi unicast. </font><font style="vertical-align: inherit;">Il est calculé sur la base de SRTT, la formule de calcul elle-même est propriétaire.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retransmission timeout (RTO) - l'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> intervalle entre l'envoi de paquets unicast. </font><font style="vertical-align: inherit;">Il est calculé sur la base de SRTT, la formule de calcul elle-même est propriétaire.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur ce, je pense que pour terminer l'article. </font><font style="vertical-align: inherit;">Voici un lien utile:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cisconinja.wordpress.com/2009/09/18/eigrp-sia-query-and-sia-reply </font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xgu.ru/wiki/EIGRP</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com/watch?v=FYUK7blhCZk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un webinaire sur l'EIGRP pendant environ 4 heures et demie. </font><font style="vertical-align: inherit;">Obligatoire pour voir)</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.cisco.com/c/en/us/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/16406-eigrp-toc.html#anc9</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420667/">https://habr.com/ru/post/fr420667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420657/index.html">Analyse: sur l'argent duquel Elon Musk pourra retirer Tesla de la bourse</a></li>
<li><a href="../fr420659/index.html">Campagne USB de HRF (Human Rights Foundation) «Flash Drives for Freedom»</a></li>
<li><a href="../fr420661/index.html">Infrastructure cloud continue</a></li>
<li><a href="../fr420663/index.html">Des mesures simples et un moyen de gagner du temps lors de la recherche de problèmes dans l'infrastructure</a></li>
<li><a href="../fr420665/index.html">Création d'une application sur .NET Core et Kubernetes: notre expérience</a></li>
<li><a href="../fr420669/index.html">Aperçu du marché de l'automatisation d'entreprise: solutions pour les sociétés de construction et de gestion de logements et de services publics</a></li>
<li><a href="../fr420671/index.html">[Ekaterinbourg, annonce] UralJS # 9 - trois rapports sur les microservices, les tests et la journalisation des erreurs à l'avant</a></li>
<li><a href="../fr420673/index.html">Docker pour Symfony 4 - du LAN à la production</a></li>
<li><a href="../fr420675/index.html">Les SOC sont des personnes. «Bonjour, nous recherchons des talents» ou d'où viennent les analystes du centre de surveillance et de réponse aux cyberattaques</a></li>
<li><a href="../fr420677/index.html">L'histoire de la façon dont Epson a fourni à la planète 30 millions d '"usines"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>