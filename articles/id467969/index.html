<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ“ ğŸ“Œ ğŸ’Ÿ Presentasi layar modal modal di iOS 13 ğŸ“½ï¸ ğŸ¦• ğŸ˜®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 


 Nama saya Ilya, saya dari Tinkoff.ru. Saya menerjemahkan untuk Anda sebuah artikel oleh Geoff Hackworth tentang bagaimana gaya pres...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Presentasi layar modal modal di iOS 13</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/467969/"><p>  Halo semuanya! </p><br><p>  Nama saya Ilya, saya dari Tinkoff.ru.  Saya menerjemahkan untuk Anda sebuah artikel oleh Geoff Hackworth tentang bagaimana gaya presentasi modal berubah di iOS 13, apa pengaruhnya dan bagaimana kompatibilitas dengan versi iOS dan Xcode sebelumnya. </p><br><p><img src="https://habrastorage.org/webt/7g/qg/00/7gqg003m4_2zqrwolzzdgcz9oyc.png" alt="gambar"></p><a name="habracut"></a><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Pada saat penulisan, WWDC 2019 akan segera berakhir.  Seperti banyak pengembang untuk iOS, saya perlahan memproses semua informasi baru yang telah diberikan Apple kepada kami, dan dalam beberapa minggu mendatang (dan berbulan-bulan!) Saya akan mencoba menonton sebanyak mungkin video. <br>  Saya punya tiga pertanyaan tentang aplikasi saya sendiri: </p><br><ul><li>  Aplikasi saya saat ini berfungsi tanpa masalah di iOS 13?  Apple memiliki sejarah panjang kompatibilitas ke belakang, berdasarkan versi Xcode yang digunakan untuk membuat aplikasi.  Sejarah menunjukkan bahwa aplikasi yang dibuat di Xcode 10 untuk iOS 13 akan berperilaku seolah-olah mereka berjalan di iOS 12. Tapi ini tidak selalu terjadi. </li><li>  Apakah aplikasi saya berfungsi saat membangun dengan Xcode 11 / iOS 13?  Build menggunakan alat terbaru memungkinkan aplikasi untuk bekerja dengan cara baru, melewati kompatibilitas ke belakang dengan versi iOS sebelumnya.  Apakah ada yang rusak? </li><li>  Perubahan apa yang dapat / harus dilakukan untuk membuat aplikasi saya berfungsi lebih baik atau memanfaatkan fitur iOS 13 yang baru?  Ini adalah tugas terbesar, dan akan membutuhkan lebih banyak waktu untuk belajar dan mengimplementasikan.  Penelitian ini adalah untuk artikel terpisah. </li></ul><br><p>  Saya belum menginstal iOS 13 pada perangkat nyata, tetapi saya dapat menguji item # 1 dengan menginstal aplikasi yang dibuat di Xcode-10 pada simulator iOS 13. <br>  Saya masih bekerja pada poin 2, tetapi berdasarkan pengujian awal dan membaca tweet dari pengembang lain yang membuat penemuan serupa, saya menemukan sejumlah perubahan perilaku dalam aplikasi saya ketika membangun dengan Xcode 11. Saya memiliki banyak video untuk ditonton dan informasi untuk asimilasi, tetapi dalam posting ini saya ingin fokus pada perubahan yang segera terlihat dan berpotensi merusak dalam presentasi UIViewController di iOS 13. </p><br><h2 id="izmenenie-stilya-modalnoy-prezentacii-po-umolchaniyu">  Ubah gaya presentasi modal default </h2><br><p> Secara default, presentasi modal sekarang menjadi "halaman" (Lembar Halaman asli), bukan layar penuh.  Dokumentasi untuk <code>modalPresentationStyle</code> berbunyi: </p><br><blockquote>  Standarnya adalah UIModalPresentationAutomatic untuk iOS, dimulai dengan iOS 13.0, dan UIModalPresentationFullScreen di versi sebelumnya. <br>  Secara default, UIViewController, jika <code>modalPresentationStyle</code> diatur sebagai modalPresentationStyle, menggunakan UIModalPresentationPageSheet, tetapi pengontrol sistem dapat menggunakan gaya tampilan lain untuk UIModalPresentationAutomatic. </blockquote><p>  Efek dari perubahan ini berbeda untuk iPhone dan iPad. </p><br><h2 id="modalnaya-prezentaciya-na-iphone">  Presentasi modal pada iPhone </h2><br><p>  Gaya presentasi Halaman Lembar, Lembar Bentuk, dan Popover pada iPhone diadaptasi ke layar penuh kecuali metode <code>UIAdaptivePresentationControllerDelegate</code> digunakan untuk mencegah adaptasi.  Misalnya, layar pengaturan dapat disajikan dalam gaya Lembar Formulir, sehingga ditampilkan dalam mode layar penuh pada iPhone dan dalam bentuk yang diperkecil pada iPad.  Secara teknis, penampilan / adaptasi tergantung pada lebar.  Lembar Halaman / Lembar Formulir / presentasi Popover pada perangkat Landscape iPhone Plus dan XS Max tidak mencakup seluruh layar karena mereka memiliki lebar seperti biasanya.  Penampilan iPad tergantung pada ukuran slide over dan mode multitasking. <br>  Tangkapan layar berikut menunjukkan presentasi Lembar Formulir pada iPhone XS untuk tiga kasus: build in Xcode 10 untuk iOS 12, build in Xcode 10 untuk iOS 13, build in Xcode 11 untuk iOS 13. </p><br><img src="https://habrastorage.org/webt/m1/pb/gv/m1pbgvvhyrayhizrwclj9gvyk7u.png"><br><p>  Kompatibilitas mundur dari iOS 12 dengan iOS 13 untuk membangun Xcode 10 menghasilkan tampilan layar penuh.  Gaya UITableView yang dikelompokkan telah berubah di iOS 13 untuk menyembunyikan ruang di atas bagian pertama tanpa adanya judul.  Bahkan build Xcode 10 / iOS 12 berperilaku berbeda ketika diluncurkan pada iOS 13, yang bukan itu yang saya harapkan. <br>  Perubahan terbesar di iOS 13, tentu saja, adalah tampilan kartu (asli. Penampilan seperti kartu).  Ukuran UIViewController telah dikurangi, dan bagian atasnya masih sedikit terlihat di belakang UIViewController yang baru diperkenalkan.  UIWindow di belakang root UIViewController juga sedikit terlihat.  Latar belakang hitam UIWindow tampak hebat secara default, terutama pada perangkat dengan takik.  Beberapa aplikasi saya mengatur latar belakang UIWindow ke putih (untuk alasan yang saya tidak ingat lagi), dan itu tampak sangat jelek.  Saya segera memperbaikinya! </p><br><h3 id="povedenie-uiviewcontroller-pri-novom-modalnom-stile-pokaza">  Perilaku UIViewController dalam gaya tampilan modal baru </h3><br><p>  Jika UIViewController yang disajikan menunjukkan UIViewController lain, kartu-kartu tersebut tumpang tindih dengan animasi yang bagus.  Perhatikan bahwa hanya UIViewController terakhir yang ditampilkan dan sedikit yang sebelumnya terlihat: </p><br><img src="https://habrastorage.org/webt/da/f9/c8/daf9c8oqbvdfnuiyauvxyd4105e.png"><br><p>  Perbedaan potensial penting lainnya dalam perilaku adalah apa yang terjadi pada UIViewController yang menunjukkan (presentasi asli).  Presentasi layar penuh (presentasi layar penuh) yang sepenuhnya mencakup UIViewController akan menghapus UIViewController dari hierarki.  Tetapi dalam hal presentasi kartu baru, UIViewController harus tetap berada dalam hierarki karena masih terlihat.  Namun, meskipun pengguna hanya dapat melihat dua UIViewController pada satu waktu, berulang kali menampilkan UIViewController tidak menghapus UIViewController yang lebih rendah dari hierarki. </p><br><h3 id="izmeneniya-razmerov">  Mengubah ukuran </h3><br><p>  Tampilan kartu-gaya baru berarti bahwa UIViewController yang ditampilkan tidak setinggi di iOS 13 seperti di iOS 12: </p><br><img src="https://habrastorage.org/webt/9q/tl/fj/9qtlfjout4m7qwoli2imtpl18rg.png"><br><h3 id="ya-hochu-full-screen">  Saya ingin layar penuh! </h3><br><p>  Permintaan eksplisit untuk menampilkan UIViewController dalam mode Layar Penuh akan mencegah tampilan gaya kartu.  Namun, ini dapat mengganggu perilaku aplikasi di iPad.  Tolong jangan tergoda untuk memeriksa idiom perangkat dan menggunakan gaya presentasi yang berbeda untuk iPhone dan iPad.  Jika beberapa tahun terakhir telah mengajarkan kita sesuatu, kita tidak boleh membuat asumsi berdasarkan tipe perangkat atau ukuran layar.  Jika Anda ingin iPad menampilkan Halaman / Lembar Formulir, tetapi iPhone memiliki Layar Penuh, Anda dapat menggunakan <code>UIAdaptivePresentationControllerDelegate</code> untuk beradaptasi dengan mode layar penuh dalam kondisi lebar yang ringkas. </p><br><h2 id="modalnaya-prezentaciya-na-ipad">  Presentasi modal pada iPad </h2><br><h3 id="form-sheets">  Lembar formulir </h3><br><p>  Layar yang ditunjukkan dalam gaya Lembar Formulir tetap tidak berubah di iOS 13: </p><br><img src="https://habrastorage.org/webt/xx/x9/n2/xxx9n2xkbhe_d52vk-q1zkibfry.png"><br><h3 id="page-sheets">  Lembar Halaman </h3><br><p>  Seperti disebutkan di atas, <code>modalPresentationStyle</code> default di iOS 13 sekarang menjadi Page Sheet.  Di iPad, ukuran UIViewController dengan gaya ini telah berubah dalam orientasi potret dan lanskap: </p><br><img src="https://habrastorage.org/webt/p2/4d/cv/p24dcvyhi3qgcagvkfvdxselcua.png"><br><img src="https://habrastorage.org/webt/f6/id/by/f6idbyggysgwaoybkyscpmevcki.png"><br><p>  Seperti di iOS 12, pembatasan "konten yang dapat dibaca" (ukuran konten yang dapat dibaca asli) berubah ukurannya saat mengubah kategori ukuran konten (kategori ukuran konten asli).  Ukuran sebenarnya tampak berbeda di iOS 12 dan 13 di beberapa kategori ukuran konten. <br>  UIViewController itu sendiri, disajikan dalam gaya Page Sheet, juga meningkat pada iOS 13 dengan peningkatan dalam kategori ukuran konten.  Berikut adalah kategori "Ekstra Ekstra Ekstra Besar" (ukuran maksimum tersedia tanpa termasuk ukuran aksesibilitas lebih besar): </p><br><img src="https://habrastorage.org/webt/sk/sd/mz/sksdmzhqya0grtz7jvgarxgh918.png"><br><img src="https://habrastorage.org/webt/xi/o7/2f/xio72fs-hrqb7rvheqbzbdglipa.png"><br><h3 id="ostalnye-vidy-prezentacii">  Jenis presentasi lainnya </h3><br><p>  Dokumentasi untuk <code>modalPresentationStyle</code> berbunyi: </p><br><blockquote>  Secara default, UIViewController mendefinisikan UIModalPresentationAutomatic sebagai UIModalPresentationPageSheet, tetapi pengontrol sistem lain mungkin mendefinisikan UIModalPresentationAutomatic secara berbeda. </blockquote><p>  Saya tidak 100% yakin dengan semua aturan untuk "sisa pengontrol sistem", tetapi saya menemukan bahwa memperlihatkan UIViewController dengan layar terbagi tanpa memasang <code>modalPresentationStyle</code> memberikan tampilan lebar kartu: </p><br><img src="https://habrastorage.org/webt/v6/yi/mr/v6yimru4gsjis6ses6xhvsufpoy.png"><br><h2 id="swipe-to-dismiss">  Geser untuk mengabaikan </h2><br><p>  Perubahan penting lainnya yang memengaruhi iPhone dan iPad adalah layar yang disajikan secara modern yang tidak dalam mode layar penuh (kecuali pop-up) dapat ditutup secara interaktif dengan menggesekkannya ke bawah.  Pada saat ini, layar di belakang kembali ke mode layar penuh: </p><br><img src="https://habrastorage.org/webt/ln/3j/ks/ln3jksmbip3bjpdbujmk4bqiwcq.png"><br><p>  Perhatikan bahwa dalam contoh ini, saya menempatkan layar "Tentang" di UINavigationController pada layar pengaturan.  Meskipun UINavigationController tidak menampilkan pengendali rootnya, penutupan interaktif dimungkinkan. </p><br><h3 id="ne-smahivay-menya-pozhaluysta">  Tolong jangan mengocokku! </h3><br><p>  Jika Anda bergantung pada pengguna untuk mengklik tombol Selesai (atau tombol serupa) atau melompat kembali ke atas tumpukan pengontrol navigasi untuk menutup UIViewController yang ditampilkan secara moda, perilaku gesek baru untuk menutup dapat mengganggu aplikasi Anda karena handler tutup layar tidak akan dieksekusi. <br>  Misalnya, dalam aplikasi Pommoro Timer Pommie saya, pengguna dapat pergi ke sub-layar pada layar Pengaturan dan menambahkan atau mengedit profil timer (konfigurasi untuk periode kerja / istirahat untuk jenis tugas tertentu): </p><br><img src="https://habrastorage.org/webt/zr/ge/ro/zrgeroiodzemmunuuic4p8ohtws.png"><br><p>  Dalam kasus Pommie, saya pikir itu normal (dan aman) jika pengguna menutup seluruh layar pengaturan dengan menggesek.  Pengguna mungkin akan berharap bahwa mereka dapat menutup layar dalam sekali jalan, dan saya ingin aplikasi saya bekerja dengan benar di iOS 13. Namun, saya merasa bahwa pada layar "Tambah / Ubah Profil Waktu", Anda tidak dapat membiarkan pengguna menutup layar dengan menggesekkan, karena ada risiko kehilangan perubahan.  Mungkin tidak sepenuhnya jelas bagi pengguna apa yang akan terjadi setelah penutupan seperti itu. <br>  Salah satu bagian dari memperbaiki masalah ini adalah properti UIViewController baru: <code>isModalInPresentation</code> .  Dari dokumentasi: </p><br><blockquote>  modalInPresentation diatur ketika Anda ingin membuat layar menjadi modal.  Ketika opsi ini diaktifkan, presentasi akan mencegah penutupan interaktif dan mengabaikan acara di luar batas-batas UIViewController hingga parameter ini diatur ke NO. </blockquote><p>  Untuk mendapatkan perilaku yang mirip dengan iOS 12 untuk layar Pengaturan saya di iOS 13, saya hanya bisa mengeset true ke properti <code>isModalInPresentation</code> dari UINavigationController yang ditampilkan secara <code>isModalInPresentation</code> .  Jika pengguna mencoba menggesek ke bawah untuk menutupnya, layar akan bergeser sedikit, tetapi akan menolak tindakan pengguna dan tidak akan ditutup. <br>  Properti dapat diubah kapan saja sehingga Anda dapat, misalnya, mengizinkan penutupan jika pengguna belum membuat perubahan yang akan hilang jika ia belum secara eksplisit menyimpannya.  Tetapi begitu perubahan telah dilakukan, Anda dapat mengatur <code>isModalInPresentation</code> untuk mencegah penutupan dengan menggesekkan.  Ini akan memaksa pengguna untuk mengklik tombol "Batal" atau "Simpan". </p><br><h3 id="obnaruzhenie-zakrytiya">  Tutup deteksi </h3><br><p>  Seperti disebutkan sebelumnya, beberapa aplikasi mungkin perlu menjalankan beberapa kode ketika UIViewController yang dapat dimodifikasi ditutup menggunakan tombol Cancel, Finish, atau Save (selain hanya menutupnya).  Misalnya, Anda mungkin perlu me-restart timer di dalam game atau bertindak berdasarkan beberapa informasi yang telah diubah pengguna.  Kode ini tidak akan dieksekusi jika pengguna menutup layar dengan menggesekkan.  Tombol Anda tidak ditekan, sehingga penangan tindakannya tidak akan dipanggil.  Ini dapat mengganggu perilaku aplikasi Anda. <br>  Cara termudah untuk menghindari masalah ini adalah mencegah penutupan interaktif menggunakan isModalInPresentation.  Pengguna harus menekan tombol untuk menutup pengontrol tampilan, sama seperti sebelum iOS 13. Tetapi ada cara lain ... <br>  iOS 13 menambahkan beberapa metode UIAdaptivePresentationControllerDelegate baru.  Mereka memungkinkan objek lain (biasanya layar yang menunjukkan layar lain sebagai modal) untuk mengontrol apakah penutupan interaktif diizinkan (alternatif untuk menggunakan <code>isModalInPresentation</code> ) dan untuk menerima informasi tentang kapan penutupan interaktif dimulai atau berakhir.  Metode-metode ini didokumentasikan dengan baik dan dijelaskan dengan jelas di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WWDC 2019 224: Memodernisasi UI Anda untuk iOS 13</a> , mulai dari menit ke-15.  Harap perhatikan bahwa <code>presentationControllerWillDismiss</code> dapat dipanggil beberapa kali jika pengguna mulai menggesek untuk menutup, mengubah pikirannya, dan kemudian menggesek lagi.  Dalam metode <code>presentationControllerDidDismiss</code> , Anda perlu mengeksekusi kode tambahan, yang dipanggil ketika tombol "Batal", "Selesai" atau "Simpan" ditekan (tentu saja, Anda tidak perlu menutup layar yang ditampilkan).  Metode-metode ini tidak akan dipanggil jika UIViewController ditutup secara terprogram.  Oleh karena itu, Anda masih perlu menjalankan kode Anda di penangan tombol (atau di delegasi Anda sendiri), yang menyebabkan penutupan bahkan ketika bekerja di iOS 13. <br>  Mari kita lihat metode delegasi <code>presentationControllerDidAttemptToDismiss</code> .  Ini akan dipanggil jika pengguna mencoba menggesek untuk menutup, tetapi <code>isModalInPresentation</code> telah menghasilkan kunci penguncian.  Dalam video dengan WWDC diusulkan untuk menampilkan daftar tindakan dengan pertanyaan apakah pengguna ingin membuang perubahan atau menyimpannya.  Ini sepertinya ide yang sangat bagus jika UIViewController yang ditampilkan memiliki tombol Cancel and Save / Done: buat catatan baru, edit properti objek, dll. <br>  Saya pikir untuk UIViewController yang bersarang di tumpukan navigasi dengan tombol Batal dan Simpan, ini lebih rumit.  Kode untuk melakukan save mungkin di UIViewController, yang satu tingkat lebih tinggi di stack, dan tidak di objek yang mengimplementasikan <code>UIAdaptivePresentationControllerDelegate</code> .  Mencoba mengalihkan pilihan pengguna ke objek yang dapat melakukan penyimpanan mungkin tidak sepenuhnya tepat.  Di aplikasi saya sendiri, saya pikir saya hanya akan memblokir penutupan layar yang memerlukan tindakan undo / save yang eksplisit jika tidak ada di bagian atas tumpukan navigasi. </p><br><h2 id="resursy">  Sumber daya </h2><br><p>  Video WWDC 2019 akan menjadi tempat terbaik untuk mencari tahu apa yang telah berubah di iOS 13, perubahan apa yang perlu Anda buat untuk aplikasi Anda sehingga mereka bekerja dengan benar ketika membuat Xcode 11, dan perubahan apa yang dapat Anda lakukan untuk memperbaikinya untuk memanfaatkan yang baru fungsi.  Berikut beberapa video untuk Anda mulai: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WWDC 2019 214: Menerapkan Mode Gelap di iOS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WWDC 2019 224: Memodernisasi UI Anda untuk iOS 13</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WWDC 2019 801: Apa yang Baru di iOS dan Desain macOS</a> </li></ul><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Sejauh ini, saya belum menemukan masalah dengan aplikasi saya yang dibuat di Xcode 10 di bawah iOS 13. Kompatibilitas mundur benar-benar berfungsi di sini.  Saya sedikit terkejut melihat perubahan dalam penampilan meja yang dikelompokkan. <br>  Xcode 11 build membutuhkan beberapa perbaikan kecil untuk menangani perubahan pada representasi modal yang dibahas dalam posting ini.  Mungkin akan ada perubahan yang belum saya temukan. <br>  Uji presentasi modal Anda secara menyeluruh (terutama dengan bilah pencarian)!  Putuskan apakah Anda ingin mengizinkan pengguna untuk menutup layar modal dengan menggesek, dan gunakan <code>isModalInPresentation</code> untuk mendapatkan perilaku yang diperlukan untuk mencegah kehilangan data yang tidak disengaja karena menggesek salah.  Untuk fleksibilitas dan kontrol yang lebih besar, gunakan <code>UIAdaptivePresentationControllerDelegate</code> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467969/">https://habr.com/ru/post/id467969/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467957/index.html">Apa yang ada di balik konstanta Feigenbaum</a></li>
<li><a href="../id467959/index.html">Fluktuasi kosmologi dan kuantum di browser</a></li>
<li><a href="../id467961/index.html">Masalah dan nuansa saat mengembangkan untuk SmartTV menggunakan React.js</a></li>
<li><a href="../id467965/index.html">Vivaldi 2.8 - Menu, silakan</a></li>
<li><a href="../id467967/index.html">Perendaman dalam jaringan saraf convolutional: transfer learning</a></li>
<li><a href="../id467973/index.html">Kelahiran platform</a></li>
<li><a href="../id467975/index.html">Huawei Dorado V6: Panas Sichuan</a></li>
<li><a href="../id467977/index.html">Membuat Aplikasi Menggunakan Komponen Bergaya di Vue.js</a></li>
<li><a href="../id467979/index.html">Integrasi iklan: bagaimana cara kerjanya?</a></li>
<li><a href="../id467981/index.html">Anboxing Rack Server Cisco UCS C240 â€‹â€‹M5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>