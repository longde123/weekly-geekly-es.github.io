<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚§µÔ∏è üçµ üåæ La chose la plus int√©ressante en PHP 8 üà∏ üí™ üë©üèø‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP 7.4 vient d'√™tre d√©clar√© stable, et nous avons d√©j√† soumis encore plus d'am√©liorations. Et le meilleur de tout, ce que PHP attend peut dire √† Dmit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La chose la plus int√©ressante en PHP 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/481092/">  PHP 7.4 vient d'√™tre d√©clar√© stable, et nous avons d√©j√† soumis encore plus d'am√©liorations.  Et le meilleur de tout, ce que PHP attend peut dire √† Dmitry Stogov - l'un des principaux d√©veloppeurs de PHP Open Source et, probablement, le plus ancien contributeur actif. <br><br>  Tous les rapports de Dmitry portent uniquement sur les technologies et les solutions sur lesquelles il travaille personnellement.  Dans les meilleures traditions d'Ontiko, sous la coupe, une version texte de l' <a href="https://youtu.be/7UOWus-5yxg">histoire</a> des innovations PHP 8 les plus int√©ressantes du point de vue de Dmitry, qui peut ouvrir de nouveaux cas d'utilisation.  Tout d'abord, JIT et FFI - pas dans la cl√© de ¬´perspectives incroyables¬ª, mais avec des d√©tails de mise en ≈ìuvre et des pi√®ges. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/o1/xd/h9o1xdb-wntc2xl0eipeb4bd7du.png" width="500"></div><br>  <i>Pour r√©f√©rence:</i> Dmitry Stogov s'est familiaris√© avec la programmation en 1984, lorsque tous les lecteurs ne sont pas n√©s, et a r√©ussi √† apporter une contribution significative au d√©veloppement d'outils de d√©veloppement, et de PHP en particulier (bien que Dmitry am√©liore les performances PHP non sp√©cifiquement pour les d√©veloppeurs russes, ont-ils <a href="https://habr.com/ru/company/oleg-bunin/blog/477426/">exprim√©</a> mes remerciements sous la forme du prix HighLoad ++).  Dmitry est l'auteur de Turck MMCache for PHP (eAccelerator), Zend OPcache mainteneur, leader du projet PHPNG, qui a form√© la base de PHP 7, et leader dans le d√©veloppement de JIT pour PHP. <br><a name="habracut"></a><br><h2>  D√©veloppement des performances PHP </h2><br>  J'ai commenc√© √† travailler sur les performances PHP il y a 15 ans lorsque j'ai rejoint Zend.  Ensuite, nous avons publi√© la version 5.0 - la premi√®re dans laquelle le langage est devenu vraiment orient√© objet.  Depuis lors, nous avons pu am√©liorer les performances sur les tests synth√©tiques de 40 fois et sur les applications r√©elles de 6 fois. <br><br><img src="https://habrastorage.org/webt/xp/gc/xe/xpgcxedjqqy7_ay7vzrocx2cl3y.jpeg"><br><br>  Pendant ce temps, il y a eu deux moments d√©cisifs: <br><br><ul><li>  Version 5.1, dans laquelle nous avons pu augmenter consid√©rablement la vitesse d'interpr√©tation.  Nous avons impl√©ment√© un interpr√®te sp√©cialis√©, ce qui a principalement affect√© les tests de synth√®se. </li><li> Version 7.0, dans laquelle toutes les structures de donn√©es cl√©s ont √©t√© trait√©es et ont ainsi optimis√© le travail avec la m√©moire et le cache du processeur (en savoir plus sur ces optimisations <a href="https://habr.com/ru/company/oleg-bunin/blog/444508/">ici</a> ).  Cela a conduit √† une acc√©l√©ration plus que double √† la fois dans les tests synth√©tiques et dans les applications r√©elles. </li></ul><br>  Toutes les autres versions ont progressivement augment√© la productivit√© en mettant en ≈ìuvre de nombreuses id√©es moins efficaces.  Dans la version 7.1, par exemple, une grande attention a √©t√© accord√©e √† l'optimisation du bytecode ( <a href="https://habr.com/ru/company/oleg-bunin/blog/445512/">un article</a> sur ces solutions). <br><br>  Le diagramme montre qu'√† la fin du d√©veloppement de la 5e version et √† la fin du cycle de d√©veloppement de la 7e version, nous atteignons un plateau et ralentissons.  Ainsi, au cours de la derni√®re ann√©e de travail sur la version 7.4, seule une augmentation de 2% de la productivit√© a √©t√© atteinte.  Et ce n'est pas mal, car de nouvelles fonctionnalit√©s telles que les propri√©t√©s typ√©es et les types covariants sont apparues qui ralentissent PHP (Nikita Popov a <a href="https://youtu.be/teKnckg5x7I">parl√©</a> de ces nouveaux produits en PHP Russie). <br><br>  Et maintenant tout le monde se demande √† quoi s'attendre de la 8e version, peut-elle r√©p√©ter le succ√®s de la v7? <br><br><h3>  Pour JIT ou pas pour JIT </h3><br>  Les id√©es pour am√©liorer l'interpr√®te ne sont pas encore √©puis√©es, mais toutes n√©cessitent une √©tude tr√®s approfondie.  Beaucoup d'entre eux doivent √™tre rejet√©s au stade de la preuve de concept, car le gain qui peut √™tre obtenu s'av√®re incommensurable avec la complication ou les limitations techniques impos√©es. <br><br>  Mais il reste de l'espoir pour une nouvelle technologie r√©volutionnaire - bien s√ªr, je me souviens du JIT et de la r√©ussite des moteurs JavaScript. <br><br>  En fait, les travaux sur JIT pour PHP sont en cours depuis 2012.  Il y avait 3 ou 4 impl√©mentations, nous avons travaill√© avec des coll√®gues Intel, des pirates JavaScript, mais d'une mani√®re ou d'une autre, il n'√©tait pas possible d'inclure JIT dans la branche principale.  Au final, en PHP 8, nous avons inclus JIT dans le compilateur et vu une double acc√©l√©ration, mais uniquement sur des tests synth√©tiques, mais sur des applications r√©elles, au contraire, un ralentissement. <br><br><img src="https://habrastorage.org/webt/no/ly/58/noly58x1blcmkwv80nd8n60yu3q.jpeg"><br><br>  Bien s√ªr, ce n'est pas ce que nous recherchons. <br><br>  Quelle est la question?  Peut-√™tre que nous faisons quelque chose de mal, peut-√™tre que WordPress est si mauvais, et aucun JIT ne l'aidera (oui, en fait, c'est le cas).  Peut-√™tre que nous avons d√©j√† rendu l'interpr√®te trop bon, mais en JavaScript c'est pire.  Dans les tests de calcul, c'est vrai: <strong>l'interpr√©teur PHP est l'un des meilleurs</strong> . <br><br><img src="https://habrastorage.org/webt/fi/ya/lc/fiyalccpg18n2aieqgj7bmy-nho.jpeg"><br><br>  Au test de Mandelbrot, il d√©passe m√™me des joyaux comme LuaJIT, un interpr√®te √©crit en langage assembleur.  Dans ce test, nous ne sommes que 4 fois derri√®re le compilateur d'optimisation GCC-5.3.  Avec JIT, nous avons pu obtenir de meilleurs r√©sultats dans le test de Mandelbrot.  En fait, nous le faisons d√©j√†, c'est-√†-dire que nous sommes capables de g√©n√©rer du code qui rivalise avec le compilateur C. <br><br>  Pourquoi alors ne pouvons-nous pas acc√©l√©rer les applications r√©elles?  Pour comprendre, je vais vous dire comment nous faisons JIT.  Commen√ßons par les bases. <br><br><h3>  Comment PHP fonctionne </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r3/u7/zz/r3u7zzdgmpo37fihs44l6jl29wq.jpeg" width="300"></div><br>  Le serveur accepte la demande, la compile en bytecode, qui √† son tour est envoy√© √† la machine virtuelle pour ex√©cution.  En ex√©cutant le bytecode, la machine virtuelle peut √©galement appeler d'autres fichiers PHP, qui sont √† nouveau recompil√©s en bytecode et ex√©cut√©s √† nouveau. <br><br>  Une fois la requ√™te termin√©e, toutes les informations qui s'y rapportent, y compris le code d'octet, sont supprim√©es de la m√©moire.  Autrement dit, chaque script PHP doit √™tre compil√© √† nouveau sur chaque demande.  Bien s√ªr, il est tout simplement impossible d'int√©grer la compilation JIT dans un tel sch√©ma, car le compilateur doit √™tre tr√®s rapide. <br><br>  Mais tr√®s probablement, personne n'utilise PHP dans sa forme nue, tout le monde l'utilise avec OPcache. <br><br><h3>  PHP + OPcache </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/cg/wr/w4cgwrta9e7mdka4mzsylnfzbqa.jpeg" width="484"></div><br>  L'objectif principal d'OPcache est de se d√©barrasser des scripts de recompilation √† chaque demande.  Il est int√©gr√© dans un point sp√©cialement con√ßu pour lui, intercepte toutes les demandes de compilation et met en cache le bytecode compil√© dans la m√©moire partag√©e. <br><br>  En m√™me temps, non seulement le temps de compilation est enregistr√©, mais √©galement la m√©moire, car la m√©moire de bytecode pr√©c√©dente √©tait allou√©e dans l'espace d'adressage de chaque processus, et maintenant elle existe en une seule copie. <br><br>  Vous pouvez d√©j√† int√©grer JIT dans ce circuit, ce que nous ferons.  Mais d'abord, je vais vous montrer comment fonctionne l'interpr√®te. <br><br><img src="https://habrastorage.org/webt/jt/d5/50/jtd550mfh4al9klurcdde6yfzce.jpeg"><br><br>  Un interpr√®te est d'abord une boucle qui appelle son propre gestionnaire pour chaque instruction. <br><br>  Nous utilisons deux registres: <br><br><ul><li>  execute_data - pointeur vers la trame d'activation actuelle; </li><li>  opline - pointeur vers l'instruction virtuelle ex√©cutable actuelle. </li></ul><br>  En utilisant l'extension gcc, ces deux types de registres sont mapp√©s sur des registres mat√©riels r√©els et, de ce fait, ils fonctionnent tr√®s rapidement. <br><br>  Dans la boucle, nous appelons simplement le gestionnaire pour chaque instruction, apr√®s quoi, √† la fin de chaque gestionnaire, nous d√©pla√ßons le pointeur sur l'instruction suivante. <br><br>  Il est important de noter que l'adresse du gestionnaire est √©crite directement dans le bytecode.  Il peut y avoir plusieurs gestionnaires diff√©rents pour une m√™me instruction.  Cela a √©t√© √† l'origine invent√© pour la sp√©cialisation afin que les gestionnaires puissent se sp√©cialiser dans les types d'op√©randes.  La m√™me technologie est utilis√©e pour JIT, car si vous √©crivez l'adresse dans le nouveau code g√©n√©r√© en tant que gestionnaire, les gestionnaires JIT seront lanc√©s sans aucune modification dans l'interpr√©teur. <br><br>  Dans l'exemple ci-dessus, le gestionnaire √©crit pour l'instruction d'ajout est pr√©sent√© √† droite.  Il prend des op√©randes (ici le premier et le second peuvent √™tre une variable constante, temporaire ou locale), lit les op√©randes, v√©rifie les types, produit une logique directe - addition - puis revient √† la boucle, qui transf√®re le contr√¥le au gestionnaire suivant. <br><br>  Des fonctions sp√©cialis√©es sont g√©n√©r√©es √† partir de cette description.  Puisqu'il y avait trois premiers op√©randes possibles, trois seconds possibles, nous obtenons 9 fonctions diff√©rentes. <br><br><img src="https://habrastorage.org/webt/sx/ac/ud/sxacudlzwpaetj0jdqlj-n-udqm.jpeg"><br><br>  Dans ces fonctions, au lieu de m√©thodes universelles d'obtention d'op√©randes, on utilise des m√©thodes sp√©cifiques qui n'effectuent aucune v√©rification. <br><br><h3>  Machine virtuelle hybride </h3><br>  Une autre complication que nous avons faite dans la version 7.2 est la machine virtuelle dite hybride. <br><br>  Si auparavant, nous appelions toujours le gestionnaire √† l'aide d'un appel indirect directement dans la boucle d'interpr√©teur, maintenant pour chaque gestionnaire, nous avons √©galement entr√© une √©tiquette dans le corps de la boucle, que nous sautons pour utiliser le saut indirect et o√π nous appelons le gestionnaire lui-m√™me, mais directement. <br><br><img src="https://habrastorage.org/webt/ym/ve/1r/ymve1rgaxks_48lgcgt_m2zf3xm.jpeg"><br><br>  Il semblait qu'auparavant, ils avaient pass√© un appel indirect, maintenant deux: une transition indirecte et un appel direct, et un tel syst√®me devrait fonctionner plus lentement.  Mais en fait, cela fonctionne plus rapidement, car nous aidons le processeur √† pr√©voir les transitions.  Auparavant, il y avait un point √† partir duquel la transition vers diff√©rents endroits √©tait effectu√©e.  Le processeur se trompait souvent, car il ne pouvait tout simplement pas se rappeler qu'il fallait d'abord sauter sur une instruction, puis sur une autre.  Maintenant, apr√®s chaque appel direct, il y a une transition indirecte vers l'√©tiquette suivante.  Par cons√©quent, lorsque la boucle PHP est ex√©cut√©e, les instructions PHP virtuelles sont organis√©es en s√©quences stables, qui sont ensuite ex√©cut√©es presque lin√©airement. <br><br>  La machine virtuelle hybride a permis d'augmenter la productivit√© de 5 √† 10% suppl√©mentaires. <br><br><h3>  PHP + OPcache + JIT </h3><br>  JIT est impl√©ment√© dans le cadre d'OPcache. <br><br><img src="https://habrastorage.org/webt/ye/ad/ad/yeadadf8b-tvejykkpdgpf3pacq.jpeg"><br><br>  Une fois le bytecode compil√© et optimis√©, un compilateur JIT est lanc√© pour lui, qui ne fonctionne plus avec le code source.  A partir du bytecode PHP, le compilateur JIT g√©n√®re du code natif, apr√®s quoi l'adresse de la premi√®re instruction (en fait la fonction) est modifi√©e dans le bytecode. <br><br>  Apr√®s cela, le code natif d√©j√† g√©n√©r√© commence √† √™tre appel√© √† partir de l'interpr√©teur existant sans aucune modification.  Je vais vous montrer un exemple simple. <br><br><img src="https://habrastorage.org/webt/y8/zs/jz/y8zsjz7rzbiuvct-l146whbcotw.jpeg"><br><br>  A gauche, une certaine fonction est √©crite en PHP qui compte la somme des nombres de 0 √† 100. A droite, le bytecode g√©n√©r√©.  La premi√®re instruction assigne 0 √† la somme, la seconde fait de m√™me pour i, puis un saut inconditionnel vers l'√©tiquette.  Sur l'√©tiquette L1, la condition de sortie du cycle est v√©rifi√©e: si elle est remplie, alors sortir, sinon, passer au cycle.  Ensuite, ajoutez √† la somme i, √©crivez le r√©sultat dans le montant, augmentez i de 1. <br><br>  Directement √† partir d'ici, nous g√©n√©rons du code assembleur, ce qui s'av√®re plut√¥t bien. <br><br><img src="https://habrastorage.org/webt/_g/q2/8b/_gq28bxpchqg3bc5duu7tysvpsq.jpeg"><br><br>  La premi√®re instruction <code>QM_ASSIGN</code> compil√©e en seulement deux instructions machine (2-3 lignes).  Le registre <code>%esi</code> contient un pointeur sur la trame d'activation actuelle.  Au d√©calage 30 se trouve un montant variable.  La premi√®re instruction √©crit la valeur 0, la seconde √©crit 4 - il s'agit d'un identifiant de type entier ( <code>IS_LONG</code> ).  Pour la variable <code>i</code> compilateur s'est rendu compte qu'elle est toujours longue, et pour cela il n'est pas n√©cessaire de stocker le type.  De plus, il peut √™tre stock√© dans un registre machine.  Par cons√©quent, ici simplement XOR du registre avec lui-m√™me est l'instruction de r√©initialisation la plus simple et la moins ch√®re. <br><br>  Ensuite, de la m√™me mani√®re, une transition inconditionnelle, on v√©rifie si un √©v√©nement externe s'est produit, on v√©rifie l'√©tat du cycle, on entre dans le cycle.  La boucle v√©rifie si la somme est enti√®re: si oui, alors lisez la valeur enti√®re, ajoutez-y la valeur i, v√©rifiez si un d√©passement s'est produit, r√©√©crivez le r√©sultat dans la somme et ajoutez 1 √† <code>%edx</code> . <br><br>  On peut voir que le code est presque optimal.  Il serait possible de l'optimiser encore plus, en se d√©barrassant de la v√©rification de la somme du type √† chaque it√©ration de la boucle.  Mais c'est d√©j√† une optimisation assez compliqu√©e, nous ne le faisons pas encore.  <strong>Nous d√©veloppons JIT comme une technologie assez simple</strong> , nous n'essayons pas de faire ce que Java HotSpot essaie de faire, V8 - nous avons moins de puissance. <br><br><h2>  Quel est le probl√®me avec jit </h2><br>  Pourquoi, avec un si bon code assembleur, ne pouvons-nous pas acc√©l√©rer de vraies applications? <br><br>  En fait, devraient-ils? <br><br><ul><li>  Si le goulot d'√©tranglement n'est pas dans le CPU, alors JIT n'aidera pas. </li><li>  Trop de code est g√©n√©r√© (gonflement du code). </li><li>  L'inf√©rence de type statique ne fonctionne pas toujours. </li><li>  Code honn√™te (pour les cas qui ne sont jamais ex√©cut√©s). </li><li>  Prise en charge de l'√©tat coh√©rent de la machine virtuelle (et soudain une exception). </li><li>  Les cours ne vivent que pour une seule demande. </li></ul><br>  Si l'application attend 80% du temps pour une r√©ponse de la base de donn√©es, JIT n'aidera pas.  Si nous appelons des fonctions externes gourmandes en ressources, par exemple, en les associant √† une expression r√©guli√®re, JIT appellera √©galement les m√™mes fonctions de la m√™me mani√®re.  De plus, si une application construit de grandes structures de donn√©es - arbres, graphiques, puis les lit, puis en utilisant JIT nous g√©n√©rons du code qui lira en moins d'instructions, mais pour charger les donn√©es elles-m√™mes, cela prendra le m√™me temps, mais vous devrez √©galement charger le code. <br><br>  Comme vous l'avez d√©j√† vu, JIT peut m√™me ralentir une application r√©elle, car elle g√©n√®re beaucoup de code et sa lecture devient un probl√®me - lors de la lecture de grandes quantit√©s de code, d'autres donn√©es sont forc√©es de sortir du cache, ce qui conduit √† un ralentissement. <br><br><h2>  Plans modestes pour PHP 8 </h2><br>  L'une des am√©liorations que nous voulons r√©aliser en PHP 8 est de <strong>g√©n√©rer moins de code</strong> .  Maintenant, comme je l'ai dit, nous g√©n√©rons du code natif pour l'ensemble du script, que nous chargeons √† l'√©tape de chargement.  Mais la moiti√© des fonctions ne seront certainement pas appel√©es.  Nous sommes donc all√©s un peu plus loin et avons introduit un d√©clencheur qui nous permet de configurer quand nous voulons ex√©cuter JIT.  Il peut √™tre ex√©cut√©: <br><br><ul><li>  pour toutes les fonctions; </li><li>  uniquement pour les fonctions lors de leur premier appel; </li><li>  vous pouvez accrocher un compteur sur chaque fonction et compiler uniquement les fonctions qui sont vraiment chaudes. </li></ul><br>  Un tel sch√©ma peut fonctionner un peu mieux, mais toujours pas optimal, car √† nouveau dans chaque fonction il y a des chemins qui sont ex√©cut√©s et des chemins qui ne sont jamais ex√©cut√©s.  √âtant donn√© que PHP est un langage de programmation dynamique, c'est-√†-dire que chaque variable peut avoir diff√©rents types, il s'av√®re que vous devez prendre en charge tous les types pr√©dits par l'analyseur statique.  Et il le fait souvent avec prudence lorsqu'il n'a pas √©t√© en mesure de prouver que l'autre type ne pouvait pas le faire. <br><br>  <strong>Dans ces conditions, nous allons nous √©loigner de la compilation honn√™te et commencer √† le faire de mani√®re sp√©culative.</strong> <br><br><img src="https://habrastorage.org/webt/cf/fu/2z/cffu2zfla_l00cqpouzm-ldteoi.jpeg"><br><br>  √Ä l'avenir, nous pr√©voyons d'abord d'analyser les fonctions les plus ¬´chaudes¬ª pendant un certain temps au cours du travail de l'application, d'examiner les chemins du programme, de quels types de variables il s'agit, peut-√™tre m√™me de se souvenir des conditions aux limites, et ensuite de g√©n√©rer le code de fonction optimal pour le courant mani√®re d'ex√©cution - uniquement pour les sections qui sont r√©ellement ex√©cut√©es. <br><br>  Pour tout le reste, nous mettrons des talons.  Il y aura tout de m√™me des v√©rifications et des sorties possibles o√π le processus de d√©soptimisation commencera, c'est-√†-dire que nous restaurerons l'√©tat de la machine virtuelle n√©cessaire √† l'interpr√©tation et le remettrons √† l'interpr√©teur pour ex√©cution. <br><br>  Un sch√©ma similaire est utilis√© √† la fois dans HotSpot Java VM et V8.  Mais l'adaptation de la technologie √† PHP pr√©sente un certain nombre de difficult√©s.  Tout d'abord, c'est que nous avons partag√© le bytecode et le code natif partag√© utilis√© √† partir de diff√©rents processus.  Nous ne pouvons pas les changer directement dans la m√©moire partag√©e, nous devons d'abord copier quelque part, changer, puis valider de nouveau dans la m√©moire partag√©e. <br><br><h2>  Pr√©chargement.  Le probl√®me de la liaison de classe </h2><br>  En fait, de nombreuses id√©es d'am√©liorations PHP qui ont longtemps √©t√© incluses dans PHP 7 et m√™me PHP 5 proviennent de travaux li√©s √† JIT.  Aujourd'hui, je vais parler d'une autre de ces technologies - c'est le pr√©chargement.  Cette technologie est d√©j√† incluse dans PHP 7.4 et permet de sp√©cifier un ensemble de fichiers, de les charger au d√©marrage du serveur et de rendre permanentes toutes les fonctions de ces fichiers. <br><br>  L'un des probl√®mes que la technologie de pr√©chargement r√©sout est le probl√®me de la liaison de classe.  Le fait est que lorsque nous compilons simplement des fichiers en PHP, chaque fichier est compil√© s√©par√©ment des autres.  Cela se fait car chacun d'eux peut √™tre modifi√© s√©par√©ment.  Vous ne pouvez pas associer une classe d'un script √† une classe d'un autre script, car √† la demande suivante, l'une d'entre elles peut changer et quelque chose ne va pas.  De plus, dans plusieurs fichiers, il peut y avoir une classe du m√™me nom, et avec une demande, l'un d'eux est utilis√© comme parent, et avec l'autre, une autre classe d'un autre fichier est utilis√©e (avec le m√™me nom, mais compl√®tement diff√©rent).  Il s'av√®re que lors de la g√©n√©ration de code qui sera ex√©cut√© sur plusieurs requ√™tes, vous ne pouvez pas faire r√©f√©rence √† des classes ou des m√©thodes, car elles sont recr√©√©es √† chaque fois (la dur√©e de vie du code d√©passe la dur√©e de vie de la classe). <br><br>  Le pr√©chargement vous permet de lier les classes initialement et, en cons√©quence, de g√©n√©rer le code de mani√®re plus optimale.  Au minimum, pour les frameworks qui seront charg√©s √† l'aide du pr√©chargement. <br><br>  Cette technologie aide non seulement pour la liaison de classe.  Quelque chose de similaire est impl√©ment√© en Java en tant que partage de donn√©es de classe.  L√†, cette technologie est principalement destin√©e √† acc√©l√©rer le lancement d'applications et √† r√©duire la quantit√© totale de m√©moire consomm√©e.  Les m√™mes avantages sont obtenus en PHP, car maintenant la liaison de classe ne se fait pas en runtime, mais se fait une seule fois.  De plus, les classes associ√©es sont d√©sormais stock√©es non pas dans l'espace d'adressage de chaque processus, mais dans la m√©moire partag√©e, et donc la consommation totale de m√©moire diminue. <br><br>  L'utilisation du pr√©chargement aide √©galement √† l'optimisation globale de tous les scripts PHP, supprime compl√®tement la surcharge OPcache et vous permet de g√©n√©rer du code JIT plus efficace. <br><br>  Mais il y a aussi des inconv√©nients.  <strong>Les scripts charg√©s au d√©marrage ne peuvent pas √™tre remplac√©s sans red√©marrer PHP.</strong>  Si nous avons t√©l√©charg√© quelque chose et l'avons rendu permanent, nous ne pouvons plus le d√©charger.  Par cons√©quent, la technologie peut √™tre utilis√©e avec des cadres stables, mais si vous d√©ployez l'application plusieurs fois par jour, elle ne fonctionnera probablement pas pour vous. <br><br>  La technologie a √©t√© con√ßue comme transparente, c'est-√†-dire qu'elle a permis de charger des applications existantes (ou des parties de celles-ci) sans aucun changement.  Mais apr√®s l'impl√©mentation, il s'est av√©r√© que ce n'est pas tout √† fait vrai. <strong>Toutes les applications ne fonctionnent pas comme pr√©vu si elles ont √©t√© charg√©es √† l'aide de la pr√©charge</strong> .  Par exemple, si un code est appel√© dans l'application sur la base des r√©sultats de la v√©rification de <code>function_exists</code> ou <code>class_exists</code> , et que la fonction devient constante, respectivement, <code>function_exists</code> renvoie toujours <code>true</code> , et le code qui √©tait pr√©c√©demment appel√© √©tait cens√© √™tre appel√©. <br><br>  Techniquement, le pr√©chargement est activ√© √† l'aide d'une seule directive de configuration opcache.preload, √† l'entr√©e de laquelle vous donnez un fichier de script - un fichier PHP standard qui sera lanc√© au stade du d√©marrage de l'application (non seulement charg√©, mais ex√©cut√©). <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_preload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $preload, string $pattern = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/\.php$/"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_file($path) &amp;&amp; preg_match($pattern, $path)) { opcache_compile_file($path) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"Preloading failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_dir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($dh = opendir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (($file = readdir($dh)) !== <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($file !== <span class="hljs-string"><span class="hljs-string">"."</span></span> &amp;&amp; $file !== <span class="hljs-string"><span class="hljs-string">".."</span></span>) { _preload($path . <span class="hljs-string"><span class="hljs-string">"/"</span></span> . $file, $pattern); } } closedir($dh); } } } _preload(<span class="hljs-string"><span class="hljs-string">"/usr/local/lib/ZendFramework"</span></span>);</code> </pre> <br>  C'est l'un des sc√©narios possibles qui lit r√©cursivement tous les fichiers d'un certain r√©pertoire (dans ce cas, ZendFramework).  Vous pouvez impl√©menter absolument n'importe quel script en PHP: lisez avec une liste, ajoutez des exceptions, ou m√™me croisez avec composer afin qu'il pousse les fichiers n√©cessaires au pr√©chargement.  Tout cela est une question de technologie, et le plus int√©ressant n'est pas de savoir comment exp√©dier, mais quoi exp√©dier. <br><br><h3>  Que charger en pr√©chargement </h3><br>  J'ai essay√© cette technologie sur WordPress.  Si vous venez de t√©l√©charger tous les fichiers * .php, WordPress cessera de fonctionner en raison de la fonctionnalit√© mentionn√©e pr√©c√©demment: il a un contr√¥le function_exists, qui devient toujours vrai.  Par cons√©quent, j'ai d√ª l√©g√®rement modifier le script de l'exemple pr√©c√©dent (ajouter des exceptions), puis, sans aucune modification dans WordPress lui-m√™me, cela a fonctionn√©. <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  Vitesse [req / seq] </td><td>  M√©moire [Mo] </td><td>  Nombre de scripts </td><td>  Nombre de fonctions </td><td>  Nombre de cours </td></tr><tr><td>  Rien </td><td>  378 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  Tous (presque *) </td><td>  395 </td><td>  7,5 </td><td>  254 </td><td>  1770 </td><td>  148 </td></tr><tr><td>  Seuls les scripts utilis√©s </td><td>  396 </td><td>  4,5 </td><td>  84 </td><td>  1532 </td><td>  51 </td></tr></tbody></table></div><br>  En cons√©quence, en <strong>raison du pr√©chargement, nous avons obtenu une acc√©l√©ration de ~ 5%</strong> , ce qui n'est d√©j√† pas mal. <br><br>  J'ai t√©l√©charg√© presque tous les fichiers, mais la moiti√© d'entre eux n'ont pas √©t√© utilis√©s.  Vous pouvez faire encore mieux - pilotez l'application, voyez quels fichiers ont √©t√© t√©l√©charg√©s.  Vous pouvez le faire en utilisant la fonction <code>opcache_get_status()</code> , qui renverra tous les fichiers mis en cache par OPcache et en cr√©era une liste pour le pr√©chargement.  Ainsi, vous pouvez √©conomiser 3 Mo et obtenir un peu plus d'acc√©l√©ration.  Le fait est que plus la m√©moire est requise, plus le cache du processeur devient sale et moins il est efficace.  <strong>Moins la m√©moire est utilis√©e, plus la vitesse est √©lev√©e.</strong> <br><br><h2>  FFI - Interface de fonction √©trang√®re </h2><br>  Une autre technologie li√©e √† JIT qui a √©t√© d√©velopp√©e pour PHP est FFI (Foreign Function Interface) ou, en russe, la possibilit√© d'appeler des fonctions √©crites dans d'autres langages de programmation compil√©s sans compilation.  Les impl√©mentations d'une telle technologie en Python ont impressionn√© mon patron (Zeev Surazki), et j'ai √©t√© tr√®s impressionn√© lorsque j'ai commenc√© √† l'adapter √† PHP. <br><br>  Il y a d√©j√† eu plusieurs tentatives en PHP pour cr√©er une extension pour FFI, mais ils ont tous utilis√© leur propre langage ou API pour d√©crire les interfaces.  J'ai espionn√© l'id√©e dans LuaJIT, o√π le langage C (un sous-ensemble) est utilis√© pour d√©crire les interfaces, et le r√©sultat est un jouet tr√®s cool.  Maintenant, quand j'ai besoin de v√©rifier comment quelque chose fonctionne en C, je l'√©cris en PHP - cela se produit, directement sur la ligne de commande. <br><br>  FFI vous permet de travailler avec des structures de donn√©es d√©finies en C et peut √™tre int√©gr√© √† JIT pour g√©n√©rer un code plus efficace.  Son impl√©mentation bas√©e sur libffi est d√©j√† incluse dans PHP 7.4. <br><br>  Mais: <br><br><ul><li>  Ce sont 1000 nouvelles fa√ßons de se tirer une balle dans le pied. </li><li>  N√©cessite des connaissances en C et parfois une gestion manuelle de la m√©moire. </li><li>  Ne prend pas en charge le pr√©processeur C (#include, #define, ...) et C ++. </li><li>  Les performances sans JIT sont assez faibles. </li></ul><br>  Bien que, pour certains, ce sera pratique, car le compilateur n'est pas n√©cessaire.  M√™me sous Windows, cela fonctionnera sans Visual-C de PHP. <br><br>  Je vais vous montrer comment utiliser FFI pour impl√©menter une v√©ritable application GUI pour Linux. <br><br>  Ne vous inqui√©tez pas du code C, j'ai moi-m√™me √©crit une interface graphique en C il y a environ 20 ans, mais j'ai trouv√© cet exemple sur Internet. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtk/gtk.h&gt; static void activate(GtkApplication* app, gpointer user_data) { GtkWidget *window = gtk_application_window_new(app); gtk_window_set_title(GTK_WINDOW(window), "Hello from C"); gtk_window_set_default_size(GTK_WINDOW(window), 200, 200); gtk_widget_show_all(window); } int main() { int status; GtkApplication *app; app = gtk_application_new("org.gtk.example", G_APPLICATION_FLAGS_NONE); g_signal_connect(app, "activate", G_CALLBACK(activate), NULL); status = g_application_run(G_APPLICATION(app), 0, NULL); g_object_unref(app); return status; }</span></span></span></span></code> </pre> <br>  Le programme cr√©e l'application, se bloque sur l'√©v√©nement de rappel d'activation, lance l'application.  Dans le rappel, cr√©ez une fen√™tre, affectez-lui la taille du titre et affichez-la. <br><br>  Et maintenant, la m√™me chose r√©√©crite en PHP: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" ‚Ä¶ // #include &lt;gtk/gtk.h&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $ffi; $window = $ffi-&gt;gtk_application_window_new($app); $ffi-&gt;gtk_window_set_title($window, <span class="hljs-string"><span class="hljs-string">"Hello from PHP"</span></span>); $ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); $ffi-&gt;gtk_widget_show_all($window); } $app = $ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); $ffi-&gt;g_object_unref($app);</code> </pre> <br>  Ici, l'objet FFI est cr√©√© en premier.  Une description de l'interface lui est envoy√©e en entr√©e - essentiellement un fichier h - et la biblioth√®que que nous voulons t√©l√©charger.  Apr√®s cela, toutes les fonctions d√©crites dans l'interface deviennent disponibles en tant que m√©thodes de l'objet ffi, et tous les param√®tres transf√©r√©s sont traduits automatiquement et de mani√®re absolument transparente dans la repr√©sentation machine n√©cessaire. <br><br>  On peut voir que tout est exactement le m√™me que dans l'exemple pr√©c√©dent.  La seule diff√©rence est qu'en C, nous avons envoy√© un rappel en tant qu'adresse, et en PHP, la connexion se fait par le nom donn√© par la cha√Æne. <br><br>  Voyons maintenant √† quoi ressemble l'interface.  Dans la premi√®re partie, nous d√©terminons les types et les fonctions en C, et dans la derni√®re ligne nous chargeons la biblioth√®que partag√©e: <br><br><pre> <code class="cpp hljs">&lt;?php $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" typedef struct _GtkApplication GtkApplication; typedef struct _GtkWidget GtkWidget; typedef void (*GCallback)(void*,void*); int g_application_run (GtkApplication *app, int argc, char **argv); unsigned long * g_signal_connect_data (void *ptr, const char *signal, GCallback handler, void *data, GCallback *destroy, int flags); void g_object_unref (void *ptr); GtkApplication * gtk_application_new (const char *app_id, int flags); GtkWidget * gtk_application_window_new (GtkApplication *app); void gtk_window_set_title (GtkWidget *win, const char *title); void gtk_window_set_default_size (GtkWidget *win, int width, int height); void gtk_widget_show_all (GtkWidget *win); "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); ...</code> </pre> <br>  Dans ce cas, ces d√©finitions C sont copi√©es √† partir des fichiers h de la biblioth√®que GTK, presque inchang√©es. <br><br>  Afin de ne pas interf√©rer avec C et PHP dans le m√™me fichier, vous pouvez mettre l'int√©gralit√© du code C dans un fichier s√©par√©, par exemple, avec le nom gtk-ffi.h et ajouter au d√©but un couple de define'ov sp√©ciaux qui sp√©cifient le nom de l'interface et la biblioth√®que √† charger: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_SCOPE </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GTK"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_LIB </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"libgtk-3.so.0"</span></span></span></span></code> </pre> <br>  Ainsi, nous avons s√©lectionn√© la description compl√®te de l'interface C dans un seul fichier.  Ce gtk-ffi.h est presque r√©el, mais malheureusement, nous n'avons pas encore impl√©ment√© un pr√©processeur C, ce qui signifie que les macros et les inclus ne fonctionneront pas. <br><br>  Maintenant, chargeons cette interface en PHP: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br>  √âtant donn√© que le FFI est une technologie plut√¥t dangereuse, nous ne voulons pas le donner aux mains de personne.  Cachons au moins l'objet FFI, c'est-√†-dire le rendons priv√© dans la classe.  Et nous allons cr√©er un objet FFI non pas en utilisant <code>FFI::cdef</code> , mais en utilisant <code>FFI::load</code> , qui ne lit que notre fichier h de l'exemple pr√©c√©dent. <br><br>  Le reste du code n'a pas beaucoup chang√©, seulement en tant que gestionnaire d'√©v√©nements, nous avons commenc√© √† utiliser une fonction sans nom et √† passer le titre √† l'aide d'une liaison lexicale.  Autrement dit, nous utilisons √† la fois C et les points forts de PHP, qui ne sont pas disponibles en C. <br><br>  Une biblioth√®que ainsi cr√©√©e pourrait d√©j√† √™tre utilis√©e dans votre application.  Mais c'est bien si cela <strong>ne</strong> fonctionne <strong>que sur la ligne de commande</strong> , et si vous le placez dans le serveur Web, le fichier gtk_ffi.h sera lu √† chaque demande, une biblioth√®que sera cr√©√©e et charg√©e, la liaison sera faite ... Et tout ce travail r√©p√©titif chargera votre serveur. <br><br>  Pour √©viter cela et, en fait, permettre d'√©crire des extensions PHP en PHP lui-m√™me, nous avons d√©cid√© de croiser FFI avec le pr√©chargement. <br><br><h3>  Pr√©chargement FFI + </h3><br>  Le code n'a pas beaucoup chang√©, seulement maintenant nous donnons les fichiers h au pr√©chargement, et nous ex√©cutons <code>FFI::load</code> directement au moment du pr√©chargement, et non lorsque nous cr√©ons l'objet.  Autrement dit, le chargement de la biblioth√®que, toutes les analyses et les liaisons sont effectu√©es une fois (au d√©marrage du serveur), et avec l'aide de <code>FFI::scope("GTK")</code> nous avons acc√®s √† une interface pr√©charg√©e par nom dans notre script. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::scope(<span class="hljs-string"><span class="hljs-string">"GTK"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br>  Dans ce mode de r√©alisation, FFI peut √™tre utilis√© √† partir d'un serveur Web.  Bien s√ªr, ce n'est pas pour l'interface graphique, mais de cette fa√ßon, vous pouvez √©crire, par exemple, une liaison √† la base de donn√©es. <br><br>  Une extension ainsi cr√©√©e peut √™tre utilis√©e directement depuis la ligne de commande: <br><pre> <code class="xml hljs">$ php -d opcache.preload=gtk.php -r 'GTK::create_window(" !");'</code> </pre> <br>  Un autre avantage du croisement et du pr√©chargement FFI est la possibilit√© d'interdire l'utilisation de FFI pour tous les scripts de niveau utilisateur.  Vous pouvez sp√©cifier ffi.enable = preload, ce qui signifie que nous faisons confiance aux fichiers pr√©charg√©s, mais appeler FFI √† partir de scripts PHP normaux est interdit. <br><br><h3>  Travailler avec des structures de donn√©es C </h3><br>  Une autre caract√©ristique int√©ressante de FFI est qu'il peut fonctionner avec des structures de donn√©es natives.  Vous pouvez √† tout moment cr√©er en m√©moire toute structure de donn√©es d√©crite en C. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $points = FFI::new(<span class="hljs-string"><span class="hljs-string">"struct {int x,y;} [100]"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($x = <span class="hljs-number"><span class="hljs-number">0</span></span>; $x &lt; count($points); $x++) { $points[$x]-&gt;x = $x; $points[$x]-&gt;y = $x * $x; } var_dump($points[<span class="hljs-number"><span class="hljs-number">25</span></span>]-&gt;y); <span class="hljs-comment"><span class="hljs-comment">// 625 var_dump(FFI::sizeof($points)); // 800  foreach ($points as &amp;$p) { $p-&gt;x += 10; } var_dump($points[25]-&gt;x); // 35</span></span></code> </pre> <br>    100  (  FFI::new != new FFI),     integer.       ,    C.             PHP,     .     count, /        foreach  .      800 ,      PHP      PHP'   ,       10 . <br><br>   FFI: <br><br><ul><li> <a href="https://github.com/dstogov/php-tensorflow"> </a>  PHP. </li><li> <a href="https://github.com/ircmaxell/libgccffi"></a>  PHP. </li></ul><br> Python/CFFI    :  (Cario, JpegTran),  (ffmpeg),  (LibreOfficeKit),   (SDL)    (TensorFlow). <br><br> <strong> ,   FFI    .</strong> <br><br>   -   PHP.    ,      ,      callback'        ,      .         FFI.  ,   .    FFI c JIT, ,   LuaJIT,    .      ,    ,     . <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($k=<span class="hljs-number"><span class="hljs-number">0</span></span>; $k&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>; $k++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=$n<span class="hljs-number"><span class="hljs-number">-1</span></span>; $i&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i--) { $Y[$i] += $X[$i]; } }</code> </pre> <br>      FFI   . <br><div class="scrollable-table"><table><tbody><tr><td></td><td> Native Arrays </td><td> FFI Arrays </td></tr><tr><td> PyPy </td><td> 0,010 </td><td> 0,081 </td></tr><tr><td> Python </td><td> 0,212 </td><td> 0,343 </td></tr><tr><td> LuaJIt -joff </td><td> 0,037 </td><td> 0,412 </td></tr><tr><td> LuaJit -jon </td><td> 0,003 </td><td> 0,002 </td></tr><tr><td>  Php </td><td> 0,040 </td><td> 0,093 </td></tr><tr><td> PHP + JIT </td><td> 0,016 </td><td> 0,087 </td></tr></tbody></table></div><br> <em>  : Zeev Surasky (Zend), Andi Gutmans (ex-Zend, Amazon), Xinchen Hui (ex-Weibo, ex-Zend, Lianjia), Nikita Popov (JetBrains), Anatol Belsky (Microsoft), Anthony Ferrara (ex-Google, Lingo Live), Joe Watkins, Mohammad Reza Haghighat (Intel)   Intel, Andy Wingo (JS hacker, Igalia), Mike Pall ( LuaJIT).</em> <br><br>        ,       ,    <a href="https://www.youtube.com/watch%3Fv%3D7UOWus-5yxg%26amp%3Bfeature%3Dyoutu.be%26amp%3Bt%3D1804"></a> . <br><br><blockquote> <a href="https://phprussia.ru/moscow/2020">PHP Russia 2020</a> !     <a href="http://eepurl.com/VYVaf"></a>  <a href="https://t.me/PHPRussiaConfChannel">telegram-</a> ,    2019     <a href="https://www.youtube.com/channel/UCxLQ9eT6YHnc6dMLRFzEc7Q">youtube-</a>  ,       , ‚Äî <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dpc2020"> </a>  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481092/">https://habr.com/ru/post/fr481092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481074/index.html">Calculatrice Python</a></li>
<li><a href="../fr481078/index.html">La participation a √©chou√©: nous amenons AgentTesla √† l'eau potable. 3e partie</a></li>
<li><a href="../fr481082/index.html">Mohnatiki capture le march√© de l'industrie du jeu! Peregrine Labs annonce une collaboration avec Epic Games</a></li>
<li><a href="../fr481084/index.html">Python, introduction √† la base de donn√©es</a></li>
<li><a href="../fr481086/index.html">Vivaldi 2.10 - Agent secret</a></li>
<li><a href="../fr481094/index.html">√Ä propos des √©couteurs sans fil JBL avec √©nergie solaire et leurs d√©fauts</a></li>
<li><a href="../fr481100/index.html">Angular 9, quoi de neuf?</a></li>
<li><a href="../fr481102/index.html">Bo√Æte √† outils multiplateforme .NET UI version AvaloniaUI 0.9</a></li>
<li><a href="../fr481104/index.html">M√©lange d'OpenJDK et de NodeJS: interactions inter-langages et architecture verticale</a></li>
<li><a href="../fr481106/index.html">Comment LANIT a tourn√© une sitcom DIY dans son bureau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>