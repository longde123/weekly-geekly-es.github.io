<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌼 🙆🏽 ✋🏼 SQL HowTo: membangun rantai menggunakan fungsi jendela 💖 👨🏿‍🎨 👨‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kadang-kadang, ketika menganalisis data, masalah muncul dari membedakan "rantai" dalam sampel - yaitu urutan urutan catatan, untuk masing-masing yang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL HowTo: membangun rantai menggunakan fungsi jendela</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483460/">  Kadang-kadang, ketika menganalisis data, <b>masalah</b> muncul dari <b>membedakan "rantai" dalam sampel</b> - yaitu <u>urutan urutan</u> catatan, untuk masing-masing yang <u>memenuhi kondisi tertentu</u> . <br><br>  Ini bisa berupa kondisi pada data catatan itu sendiri, atau ekspresi kompleks sehubungan dengan satu atau lebih catatan sebelumnya - misalnya, panjang interval antara sampel waktu dekat. <br><br><img src="https://habrastorage.org/webt/fx/nc/ld/fxncldmr0bpfaufpa2tosjozqy8.png"><br><br>  Solusi tradisional memberikan opsi berbeda untuk "bergabung sendiri", ketika sampel terhubung dengan dirinya sendiri, atau penggunaan fakta tertentu "di luar data" - misalnya, bahwa catatan harus memiliki langkah yang ditentukan secara ketat (N + 1, "untuk setiap hari", ... ) <br><br>  Opsi pertama sering mengarah pada <b>kompleksitas kuadratik dari</b> segi jumlah catatan, yang tidak <a href="https://habr.com/ru/post/479298/">dapat diterima dalam sampel besar</a> , dan yang kedua <b>dapat dengan mudah "berantakan"</b> jika tiba-tiba tidak ada sampel dalam data sumber. <br><br>  Tetapi tugas ini akan membantu kita untuk secara efektif menyelesaikan <a href="https://postgrespro.ru/docs/postgresql/12/functions-window" rel="nofollow">fungsi-fungsi jendela</a> di PostgreSQL. <br><a name="habracut"></a><br><h2>  Tugas: menghitung uang orang lain </h2><br>  Pertimbangkan kasus rantai paling sederhana - ketika kondisi kontinuitas ditentukan oleh data catatan itu sendiri. <br><br>  Semua operasi lebih lanjut tidak harus dilakukan secara terpisah.  Tetapi demi kejelasan algoritme, saya akan memecahnya menjadi langkah-langkah berturut-turut, dan <u>pada akhirnya saya akan menunjukkan apa dan bagaimana mengoptimalkan</u> . <br><br>  Mari kita bayangkan bahwa kita memiliki bank kecil yang mengelola saldo di rekening pelanggan dalam tabel.  Segera setelah transaksi penerimaan dan pengeluaran terjadi, tanggal ini juga menetapkan jumlah total tagihan pada akhir hari. <br><blockquote>  Setelah liburan panjang Tahun Baru, bank memutuskan untuk memberi hadiah kepada pelanggannya - dan setiap orang yang membuka akun tahun ini juga bertambah + 1% dari <u>saldo rata</u> - <u>rata harian</u> untuk <b>periode berkelanjutan terpanjang</b> ketika <u>akun tidak "disetel ulang"</u> . </blockquote>  Ini dia kriteria kita untuk kesinambungan "rantai".  Nah, pemesanan data akan ditentukan oleh tanggal saldo. <br><br>  Mereka membawa kami CSV seperti itu, dan meminta untuk dengan cepat menghitung siapa dan berapa banyak kemurahan hati dari bank harus dapatkan: <br><br><pre><code class="plaintext hljs">date;client;balance 01.01.2020;;150 01.01.2020;;100 02.01.2020;;100 02.01.2020;;150 03.01.2020;;200 05.01.2020;;0 06.01.2020;;50 08.01.2020;;0 08.01.2020;;200 09.01.2020;;0 09.01.2020;;0 10.01.2020;;5</code> </pre> <br>  Perhatikan beberapa fakta yang dapat dilihat pada data ini: <br><br><ul><li>  01.01 adalah hari libur, dan bank tidak bekerja.  Oleh karena itu, tidak ada klien yang memiliki catatan perubahan saldo pada hari itu, tetapi mereka memiliki uang di akun mereka.  Algoritma "brute force" yang diulang-ulang setiap hari tidak akan bekerja secara normal. </li><li>  04.01 Alice tidak melakukan operasi apa pun, jadi tidak ada entri.  Tetapi sebelum 05.01, jumlah dalam akunnya adalah nol - ini harus diperhitungkan dalam analisis. </li><li>  Kami melakukan analisis pada 01.01-12.01, tetapi saldo akun Alice pada akhir periode ini tidak nol.  Kami juga memperhitungkan kebutuhan untuk membatasi periode. </li></ul><br><h2>  CSV-to-table </h2><br>  Cara terbaik untuk mengimpor dari CSV adalah dengan <a href="https://www.postgresqltutorial.com/import-csv-file-into-posgresql-table/" rel="nofollow">menggunakan operator COPY</a> .  Tetapi kami akan mencoba melakukan ini melalui ekspresi reguler untuk pemanasan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TEMPORARY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span>(prt[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) dt , prt[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> , prt[<span class="hljs-number"><span class="hljs-number">3</span></span>]::<span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) balance <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> regexp_split_to_array(<span class="hljs-keyword"><span class="hljs-keyword">str</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>) prt <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> regexp_split_to_table( $$ <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>;client;balance 01.01.2020;;150 01.01.2020;;100 02.01.2020;;100 02.01.2020;;150 03.01.2020;;200 05.01.2020;;0 06.01.2020;;50 08.01.2020;;0 08.01.2020;;200 09.01.2020;;0 09.01.2020;;0 10.01.2020;;5 $$ , E'\\n') str ) T WHERE str &lt;&gt; '' OFFSET 1 ) T;</code> </pre> <br>  Ini adalah metode “tidak jujur” dalam arti tidak akan dicerna dengan benar, misalnya, melindungi pemisah dalam tubuh bidang.  Tetapi untuk sebagian besar aplikasi sederhana - cocok. <br><br><h2>  Langkah 1: Perbaiki kondisi aplikasi </h2><br>  Dalam kasus kami, kondisi kontinuitas rantai adalah keseimbangan yang tidak nol.  Kami menampilkannya sebagai bidang terpisah, untuk kejelasan, secara kronologis dipesan oleh klien: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , balance &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>, dt;</code> </pre><br><pre> <code class="plaintext hljs">dt | client | balance | cond ------------------------------------ 2020-01-01 |  | 150.00 | t 2020-01-02 |  | 100.00 | t 2020-01-03 |  | 200.00 | t 2020-01-05 |  | 0.00 | f 2020-01-06 |  | 50.00 | t 2020-01-08 |  | 0.00 | f 2020-01-09 |  | 0.00 | f 2020-01-10 |  | 5.00 | t 2020-01-01 |  | 100.00 | t 2020-01-02 |  | 150.00 | t 2020-01-08 |  | 200.00 | t 2020-01-09 |  | 0.00 | f</code> </pre><br><h2>  Langkah 2: Hitung yang Hilang </h2><br>  Perhatikan bahwa jumlah Bob tidak berubah dari 02,01 menjadi 08,01.  Dan sesuai dengan kondisi masalah, kita harus menghitung sisa <u>harian rata</u> - <u>rata</u> - yaitu, kita memerlukan informasi tentang hari-hari yang "terlewatkan" ini.  Atau setidaknya jumlah hari ketika nilainya tetap sama: <br><br><pre> <code class="sql hljs">coalesce(lead(dt) OVER(PARTITION BY client ORDER BY dt), '2020-01-12') - dt days</code> </pre> <br><pre> <code class="plaintext hljs">dt | client | balance | cond | days ------------------------------------------- 2020-01-01 |  | 150.00 | t | 1 2020-01-02 |  | 100.00 | t | 1 2020-01-03 |  | 200.00 | t | 2 2020-01-05 |  | 0.00 | f | 1 2020-01-06 |  | 50.00 | t | 2 2020-01-08 |  | 0.00 | f | 1 2020-01-09 |  | 0.00 | f | 1 2020-01-10 |  | 5.00 | t | 2 2020-01-01 |  | 100.00 | t | 1 2020-01-02 |  | 150.00 | t | 6 2020-01-08 |  | 200.00 | t | 1 2020-01-09 |  | 0.00 | f | 3</code> </pre><br>  Menggunakan <a href="https://postgrespro.ru/docs/postgresql/12/functions-window" rel="nofollow">fungsi jendela lead (),</a> kami mempelajari tanggal dari rekaman <u>berikutnya</u> secara berurutan, dan melalui <b>penggabungan kami</b> membatasi interval untuk yang terakhir.  Pada saat yang sama, mereka menggunakan properti yang berguna bahwa <b>perbedaan dua tanggal di PostgreSQL mengembalikan jumlah bilangan bulat hari di</b> antara mereka. <br><br>  Sebagai bonus hampir gratis, kami mendapat semua informasi yang sama untuk catatan dengan saldo nol.  Tetapi jika ada banyak baris dengan kondisi tidak terpenuhi yang tidak menarik bagi kami, masuk akal <a href="https://habr.com/ru/post/479508/">untuk mengarahkan perhitungan tersebut di bawah KASUS</a> untuk menghemat sumber daya server. <br><br><h2>  Langkah 3: Temukan Break Points </h2><br>  Awal dari setiap rantai yang kami minati adalah titik di mana nilai kondisi yang dihitung sebelumnya berubah relatif terhadap catatan <u>sebelumnya</u> .  Kami akan menggunakan fungsi <b>lag ()</b> untuk menemukan titik-titik tersebut: <br><br><pre> <code class="sql hljs">lag(cond) OVER(PARTITION BY client ORDER BY dt) IS DISTINCT FROM cond chain_start</code> </pre> <br><pre> <code class="plaintext hljs">dt | client | balance | cond | days | chain_start --------------------------------------------------------- 2020-01-01 |  | 150.00 | t | 1 | t 2020-01-02 |  | 100.00 | t | 1 | f 2020-01-03 |  | 200.00 | t | 2 | f 2020-01-05 |  | 0.00 | f | 1 | t 2020-01-06 |  | 50.00 | t | 2 | t 2020-01-08 |  | 0.00 | f | 1 | t 2020-01-09 |  | 0.00 | f | 1 | f 2020-01-10 |  | 5.00 | t | 2 | t 2020-01-01 |  | 100.00 | t | 1 | t 2020-01-02 |  | 150.00 | t | 6 | f 2020-01-08 |  | 200.00 | t | 1 | f 2020-01-09 |  | 0.00 | f | 3 | t</code> </pre><br>  Dengan menggunakan <b>IS DISTINCT FROM</b> operator alih-alih &lt;&gt;, kami menghindari masalah membandingkan dengan NULL untuk catatan pertama untuk setiap klien.  Dengan demikian, semua baris di mana nilai TRUE adalah awal dari rantai baru, dan FALSE adalah kelanjutannya. <br><br><h2>  Langkah 4: merangkai tautan </h2><br>  Untuk mengelompokkan data dalam setiap rantai individual, akan lebih mudah untuk menetapkan <b>pengidentifikasi yang sama</b> untuk semua catatannya.  Nomor seri rantai itu sendiri sangat cocok untuk itu.  Dan itu persis sama dengan <b>jumlah "permulaan" rantai</b> yang ditemukan lebih tinggi dalam sampel. <br><br>  Mereka dapat dihitung baik melalui "jendela" penjumlahan dari jumlah nilai bool ({boolean} :: integer), atau dengan menghitung jumlah catatan yang cocok dengan jumlah (*) FILTER (WHERE {boolean} kondisi.  Kami akan menggunakan opsi kedua: <br><br><pre> <code class="sql hljs">count(*) FILTER(WHERE chain_start) OVER(PARTITION BY client ORDER BY dt) grpid</code> </pre> <br><pre> <code class="plaintext hljs">dt | client | balance | cond | days | chain_start | grpid ----------------------------------------------------------------- 2020-01-01 |  | 150.00 | t | 1 | t | 1 2020-01-02 |  | 100.00 | t | 1 | f | 1 2020-01-03 |  | 200.00 | t | 2 | f | 1 2020-01-06 |  | 50.00 | t | 2 | t | 2 2020-01-10 |  | 5.00 | t | 2 | t | 3 2020-01-01 |  | 100.00 | t | 1 | t | 1 2020-01-02 |  | 150.00 | t | 6 | f | 1 2020-01-08 |  | 200.00 | t | 1 | f | 1</code> </pre><br>  Pada langkah ini, kita sudah mengetahui panjang semua tautan di setiap rantai, kita tidak lagi membutuhkan catatan "tidak menarik", jadi saring saja. <br><br><h2>  Langkah 5: Menempatkan Rantai </h2><br>  Untuk menghitung rata-rata semua hari dalam suatu rantai, kita membutuhkan jumlah total hari dan keseimbangan “integral”: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(dt) chain_dt , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span> * balance) balance , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, grpid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, grpid;</code> </pre> <br><pre> <code class="plaintext hljs">client | chain_dt | balance | days -------------------------------------  | 2020-01-01 | 650.00 | 4  | 2020-01-06 | 100.00 | 2  | 2020-01-10 | 10.00 | 2  | 2020-01-01 | 1200.00 | 8</code> </pre><br><h2>  Langkah 6: Mencari Nilai Terapan </h2><br>  Menggunakan <b>DISTINCT ON,</b> kami akan meninggalkan satu catatan (dengan nilai hari maksimum) untuk setiap klien: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">client | chain_dt | balance | days -------------------------------------  | 2020-01-01 | 650.00 | 4  | 2020-01-01 | 1200.00 | 8</code> </pre><br>  Sebenarnya, hanya itu, yang tersisa hanyalah ... <br><br><h2>  Kami menggabungkan dan mengoptimalkan </h2><br><div class="spoiler">  <b class="spoiler_title">Permintaan ringkasan</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> step123 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> lag(cond) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> chain_start , <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> cond <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">lead</span></span>(dt) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w), <span class="hljs-string"><span class="hljs-string">'2020-01-12'</span></span>) - dt <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl , LATERAL(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> balance &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> cond) T WINDOW w <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> dt) ) , step4 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) FILTER(<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> chain_start) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> dt) grpid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> step123 <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> cond ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">client</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) <span class="hljs-keyword"><span class="hljs-keyword">days</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(dt) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) chain_dt , <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">days</span></span> * balance) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(w) balance <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> step4 WINDOW w <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>, grpid) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre></div></div><br>  Di sini kami menggabungkan dan mengoptimalkan tiga langkah pertama: <br><br><ul><li>  <b>Subquery LATERAL</b> memungkinkan kami untuk menghitung bidang tambahan tanpa harus melewati seleksi dan segera menggunakannya dalam fungsi </li><li>  penghapusan definisi umum di bawah <b>WINDOW</b> membantu PostgreSQL tidak melakukan penyortiran ganda untuk membentuk "jendela" dan menghitung kedua fungsi dalam satu simpul WindowAgg </li><li>  <b>Perhitungan fungsi</b> "malas" di <b>bawah CASE</b> mengurangi jumlah operasi yang dilakukan </li></ul><br>  Demikian pula, kami menggabungkan dua langkah berikut.  Tetapi urutan "jendela" penghitungan agregat (klien, grpid) dan unikisasi (klien, jumlah (hari)) tidak sesuai, oleh karena itu masih ada dua Urutkan node di blok terakhir - sebelum WindowAgg dan sebelum Unik. <br><br><img src="https://habrastorage.org/webt/8h/nq/2_/8hnq2_rny7scq8l_lo0qml_oayc.png"><br>  <a href="https://explain.tensor.ru/archive/explain/33705f55485a31a59d37945d63f26696:0:2020-01-12" rel="nofollow">[lihat menjelaskan.tensor.ru]</a> <br><br>  Saya perhatikan bahwa ketika rantai penomoran <b>, kondisi WHERE pertama kali dipenuhi</b> , sehingga angka yang dihasilkan oleh <u>fungsi jendela</u> berubah menjadi berurutan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483460/">https://habr.com/ru/post/id483460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483444/index.html">Laporan DORA 2019: Cara Meningkatkan Kinerja DevOps</a></li>
<li><a href="../id483446/index.html">Para ilmuwan telah menemukan cara baru untuk menurunkan kadar zat besi dalam air minum</a></li>
<li><a href="../id483448/index.html">Disney - Dua Arah Terhebat dalam Sejarah Manusia</a></li>
<li><a href="../id483454/index.html">Beralih dari Mercurial ke GIT di Atlassian Bitbucket dengan menyimpan file dalam Cyrillic</a></li>
<li><a href="../id483458/index.html">Asisten Basis Data GreenPig</a></li>
<li><a href="../id483462/index.html">Diam dan ambil uangku</a></li>
<li><a href="../id483466/index.html">Memperkenalkan metode backpropagation</a></li>
<li><a href="../id483468/index.html">Tes Integrasi Flutter - Mudah</a></li>
<li><a href="../id483470/index.html">Lay tile secara efisien (Pro CSS, SVG, pola, dan lainnya)</a></li>
<li><a href="../id483472/index.html">Hapus semua: cara menghapus data dan mengembalikan SSD NVMe ke pengaturan pabrik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>