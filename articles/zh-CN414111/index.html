<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☑️ 👃🏼 🥔 PostgreSQL流复制中的调试和故障排除 🧐 👨🏻‍🚀 👨🏻‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="流复制出现在2010年，已经成为PostgreSQL的突破性功能之一，目前，如果不使用流复制，几乎没有安装可以完成。 它可靠，易于配置且不需要资源。 然而，尽管具有积极的品质，但在操作过程中可能会出现各种问题和不愉快的情况。 

 Highload ++ 2017上的Alexey Lesovsky ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL流复制中的调试和故障排除</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/414111/"> 流复制出现在2010年，已经成为PostgreSQL的突破性功能之一，目前，如果不使用流复制，几乎没有安装可以完成。 它可靠，易于配置且不需要资源。 然而，尽管具有积极的品质，但在操作过程中可能会出现各种问题和不愉快的情况。 <br><br>  Highload ++ 2017上的<strong>Alexey Lesovsky</strong> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@lesovsky</a> ）介绍了如何使用内置和第三方工具<strong>诊断各种类型的问题以及如何解决它们</strong> 。 在削减的基础上，本报告基于螺旋原理进行解码：首先，我们列出所有可能的诊断工具，然后继续列出常见问题并进行诊断，然后查看可以采取哪些紧急措施，最后从根本上解决该问题。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/on2yVvKejwc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>关于演讲者</strong> ：Data Egret的数据库管理员Alexei Lesovsky。  Alexey在PostgreSQL中最喜欢的主题之一是流复制和使用统计信息，因此Highload ++ 2017上的报告致力于如何使用统计信息发现问题以及使用什么方法解决问题。 <br><br><h2> 计划 <br></h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一些理论，或者说复制在PostgreSQL中是如何工作的</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">故障排除工具或PostgreSQL和社区拥有的东西</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">故障排除案例：</a> <br><ul><li> 问题：他们的症状和诊断 </li><li> 决定 </li><li> 采取措施以免出现这些问题。 </li></ul></li></ol><br>  <strong>为什么要这样？</strong> 本文将帮助您更好地理解流复制，学习如何快速查找和解决问题，以减少对不愉快事件的响应时间。 <br><a name="habracut"></a><a name="replicationSql"></a><br><h2> 一点理论 <br></h2><br>  PostgreSQL具有一个实体，例如预写日志（XLOG），事务日志。 数据库中与数据和元数据有关的<em>几乎</em>所有更改都记录在此日志中。 如果突然发生任何事故，PostgreSQL将启动，读取事务日志，并将记录的更改恢复到数据。 这样可以确保可靠性-也是所有DBMS和PostgreSQL的最重要属性之一。 <br><br> 可以通过两种方式填充事务日志： <br><br><ol><li> 默认情况下，当后端在数据库中进行某些更改（INSERT，UPDATE，DELETE等）时，所有更改都<strong>同步</strong>记录在事务日志中： <br><ul><li> 客户端发送了COMMIT命令以确认数据。 <br></li><li> 数据记录在事务日志中。 <br></li><li> 修复发生后，将控制权交给后端，并且后端可以继续从客户端接收命令。 <br></li></ul></li><li> 第二个选项是<strong>异步写入</strong>事务日志，当一个单独的专用WAL编写器进程以一定的时间间隔将更改写入事务日志时。 因此，由于不需要等待COMMIT命令完成，因此可以提高后端性能。 <br></li></ol><br> 最重要的是，流复制基于此事务日志。 我们有几个流复制成员： <br><br><ul><li> 掌握所有更改的发生位置； <br></li><li> 多个副本接受主数据库的事务日志，并在其本地数据上重现所有这些更改。 这是流复制。 <br></li></ul><br> 值得记住的是，所有这些事务日志都存储在$ DATADIR的pg_xlog目录中，该目录包含主DBMS数据文件。 在PostgreSQL的第十版中，此目录被重命名为pg_wal /，因为pg_xlog /占用大量空间并不罕见，并且开发人员或管理员在不知不觉中将其与日志混淆，不小心删除了它，一切都变得很糟。 <br><br>  PostgreSQL有一些后台服务涉及流复制。 让我们从操作系统的角度来看它们。 <br><br><ul><li> 从主服务器一侧-WAL Sender过程。 这是一个将事务日志发送到副本的过程，每个副本将有自己的WAL发送者。 <br></li><li> 副本依次运行WAL接收器进程，该进程通过WAL发送者通过网络连接接收事务日志，并将它们传递给启动进程。 <br></li><li> 启动过程将读取日志，并在数据目录上重现记录在事务日志中的所有更改。 <br></li></ul><br><img src="https://habrastorage.org/webt/ek/g2/rd/ekg2rdtwkvfjw8hlpj0rhhzhogu.jpeg"><br> 从示意图上看，它看起来像这样： <br><br><ul><li> 更改将写入WAL缓冲区，然后将其写入事务日志。 <br></li><li> 日志存储在pg_wal /目录中； <br></li><li>  WAL Sender从存储库中读取事务日志并通过网络传输它们； <br></li><li>  WAL接收器接收并存储在其存储中-本地pg_wal /; <br></li><li> 启动过程读取被接受并复制的所有内容。 <br></li></ul><br> 该方案很简单。 流复制工作非常可靠，并且已被广泛使用多年。 <br><a name="tools"></a><br><h2> 故障排除工具 <br></h2><br> 让我们看看社区和PostgreSQL提供了哪些工具和实用程序，以调查流复制遇到的问题。 <br><br><h3> 第三方工具 <br></h3><br> 让我们从第三方工具开始。 这些实用程序具有相当<strong>普遍的计划</strong> ；它们不仅可以用于调查与流复制相关的事件。 这些通常<strong>是任何系统管理员的实用程序</strong> 。 <br><br><ul><li>  procps软件包的<strong>顶部</strong> 。 作为top的替代，您可以使用任何实用程序，例如atop，htop等。 它们提供类似的功能。 </li></ul><br> 在top的帮助下，我们看一下：处理器（CPU）的利用率，平均负载（平均负载）以及内存和交换空间的使用情况。 <br><br><ul><li>  sysstat和iotop中的iostat。 这些实用程序显示磁盘设备的利用率以及操作系统中的进程创建的I / O。 </li></ul><br> 在iostat的帮助下，我们可以看到：存储利用率，当前多少iops，设备上的吞吐量，处理I / O请求的延迟时间（延迟）。 此相当详细的信息取自procfs文件系统，并以可视形式提供给用户。 <br><br><ul><li>  nicstat是iostat的类似物，仅适用于网络接口。 在此实用程序中，您可以观察接口的使用情况。 </li></ul><br> 使用nicstat，我们看起来：接口利用率，接口上发生的一些错误，吞吐量也是一个非常有用的实用程序。 <br><br><ul><li>  pgCenter是仅适用于PostgreSQL的实用程序。 它在类似顶部的界面中显示PostgreSQL统计信息，您还可以在其中查看与流复制相关的统计信息。 </li></ul><br> 在pgCenter的帮助下，我们可以看到：复制统计信息。 您可以观察复制滞后，以某种方式对其进行评估，并预测未来的工作。 <br><br><ul><li>  perf是一个实用程序，可用于更深入地调查“地下爆震”的原因，在运行时，PostgreSQL代码级会出现奇怪的问题。 </li></ul><br> 在性能帮助下，我们寻找：地下敲门声。 为了使perf能够与PostgreSQL完全兼容，后者必须使用调试字符进行编译，因此您可以查看进程中的函数堆栈，以及哪些函数占用最多的CPU时间。 <br><br> 所有这些实用程序都需要用来<strong>测试</strong>故障排除时出现的<strong>假设</strong> -放慢速度，放慢速度，需要修复和检查的地方和内容。 这些实用程序有助于确保我们走上正确的道路。 <br><br><h3> 嵌入式工具 <br></h3><br>  PostgreSQL本身提供什么？ <br><br><h4> 系统视图 <br></h4><br> 通常，有很多使用PostgreSQL的工具。 每个提供PostgreSQL支持的供应商公司都提供自己的工具。 但是，通常，这些工具是基于内部PostgreSQL统计信息的。 在这方面，PostgreSQL提供了系统视图，您可以在其中进行各种选择并获取所需的信息。 也就是说，使用常规客户端（通常为psql），我们可以进行查询并查看统计信息中发生了什么。 <br><br> 有很多系统视图。 为了处理流复制并调查问题，我们只需要：pg_stat_replication，pg_stat_wal_receiver，pg_stat_databases，pg_stat_databases_conflicts以及辅助pg_stat_activity和pg_stat_archiver。 <br><br> 它们很少，但是此设置足以检查是否有任何问题。 <br><br><h4> 辅助功能 <br></h4><br> 使用辅助功能，您可以从统计系统表示中获取数据，并将其转换为自己更方便的形式。 辅助功能也只有几部分。 <br><br><ul><li>  pg_current_wal_lsn（）（pg_current_xlog_location（）的旧版本）是最必需的功能，可让您查看事务日志中的当前位置。 事务日志是连续的数据序列。 使用此功能，您可以查看最后一点，获取现在停止事务日志的位置。 <br></li><li>  pg_last_wal_receive_lsn（），pg_last_xlog_receive_location（）与上述功能相似，仅适用于副本。 副本接收事务日志，您可以看到最后接收到的事务日志位置。 <br></li><li>  pg_wal_lsn_diff（），pg_xlog_location_diff（）是另一个有用的功能。 我们从事务日志中给她两个位置，然后显示diff-这两个点之间的距离（以字节为单位）。 此功能对于确定主副本与副本之间的延迟（以字节为单位）始终很有用。 <br></li></ul><br> 可以使用psql元命令获得完整的功能列表：\ df *（wal | xlog | lsn | location）*。 <br><br> 您可以在psql中键入它，并查看wal，xlog，Isn和location包含的所有功能。 这样的功能大约有20-30个，它们还在交易日志上提供各种信息。 我建议您熟悉一下自己。 <br><br><h4>  pg_waldump实用程序 <br></h4><br> 在10.0版之前，它称为pg_xlogdump。 当我们想查看事务日志的各个部分，找出其中有哪些资源记录，以及PostgreSQL在那里写了什么时，需要pg_waldump实用程序，这是为了进行更详细的研究。 <br><br><blockquote> 在10.0版中，所有包含单词xlog的系统视图，功能和实用程序都被重命名。 单词xlog和location的所有出现分别被单词wal和lsn代替。  pg_xlog目录也变成了pg_wal目录，做了同样的事情。 <br></blockquote><br>  pg_waldump实用程序只是将XLOG段的内容解码为人类可读的格式。 您可以看到在PostgreSQL工作期间哪些所谓的资源记录落入了段日志中，哪些索引和堆文件已被更改，哪些备用信息将到达那里。 因此，可以使用pg_waldump查看很多信息。 <br><br><blockquote> 但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档中</a>写有一个免责声明：PostgreSQL运行时pg_waldump可能显示稍微不正确的数据（服务器运行时可能给出错误的结果-意味着什么） </blockquote><br> 您可以使用以下命令： <br><br><pre><code class="sql hljs">pg_waldump -f - /wal_10 \ $(psql -qAtX - "<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_walfile_name(pg_current_wal_lsn())<span class="hljs-string"><span class="hljs-string">")</span></span></code> </pre> <br> 这是tail -f命令的类似物，仅适用于事务日志。 此命令显示当前正在发生的事务日志的尾部。 您可以运行此命令，它将找到带有最新事务日志条目的最后一个段，连接到该段并开始显示事务日志的内容。 团队有些棘手，但是仍然有效。 我经常使用它。 <br><a name="cases"></a><br><h2> 故障排除案例 <br></h2><br> 在这里，我们研究顾问的实践中出现的最常见问题，可能是什么症状以及如何诊断它们： <br><br>  <strong>复制滞后是最常见的问题</strong> 。 最近，我们与客户建立了联系： <br><br><blockquote>  - <em>我们中断了两台服务器之间的主从复制。</em> <br><br>  -检测到2小时的延迟，pg_dump开始。 <br><br>  - <em>知道了</em>  <em>我们允许的延迟是多少？</em> <br><br>  -max_standby_streaming_delay为16小时。 <br><br>  <em>-超过此延迟会发生什么？</em>  <em>警笛声？</em> <br><br>  -不，交易将被击败，WAL名单将恢复。 <br></blockquote><br> 我们一直都有复制滞后的问题，几乎每个星期我们都会解决它们。 <br><br> 存储事务日志段<strong>的pg_wal /目录的膨胀</strong>是一个不常发生的问题。 但是在这种情况下，必须立即采取措施，以使当副本掉落时问题不会变成紧急情况。 <br><br> 在副本上运行的<strong>长查询</strong>会导致<strong>恢复期间发生冲突</strong> 。 在这种情况下，当我们在副本上开始某种负载时，您可以在副本上执行读取查询，此时，这些查询会干扰事务日志的复制。 发生冲突，PostgreSQL需要决定是等待查询完成还是完成查询，然后继续播放事务日志。 这是复制冲突或恢复冲突。 <br><br>  <strong>恢复过程：100％的CPU使用率—</strong>在副本上恢复事务日志<strong>的</strong>过程花费了100％的处理器时间。 这也是一种罕见的情况，但是非常不愉快，因为 导致复制滞后的增加，并且通常难以调查。 <br><br><h3> 复制滞后 <br></h3><br> 复制滞后是指在主服务器和副本服务器上执行的同一请求返回不同的数据时。 这意味着母版和副本之间的数据不一致，并且存在一些滞后。 副本需要重现部分事务日志，以便赶上向导。 主要症状看起来完全像这样：存在一个查询，并且它们返回不同的结果。 <br><br>  <strong>如何寻找这样的问题？</strong> <br><br><ul><li> 在向导和副本<strong>pg_stat_replication</strong>上有一个基本视图。 它显示有关所有WAL Sender的信息，即有关发送事务日志的进程的信息。 每个副本都有单独的一行，显示该特定副本的统计信息。 <br></li><li> 辅助函数<strong>pg_wal_lsn_diff（）</strong>允许您比较事务日志中的不同位置并计算相同的滞后。 有了它的帮助，我们可以获得特定的数字，并确定哪里存在较大的滞后，哪里存在较小的滞后，并且已经以某种方式对问题做出了响应。 <br></li><li>  <strong>pg_last_xact_replay_timestamp（）</strong>函数仅适用于副本，并允许您查看上次丢失事务的执行时间。 有一个众所周知的now（）函数显示当前时间，我们从now（）函数中减去pg_last_xact_replay_timestamp（）函数显示给我们的时间，并获得时间滞后。 <br></li></ul><br> 在pg_stat_replication的第10版中，出现了其他字段，显示了向导中已经存在的时间滞后，因此该方法已经过时，但是仍然可以使用。 <br><br> 有一个小陷阱。 如果向导上很长时间没有事务，并且它不生成事务日志，那么最后一个函数将显示出越来越大的延迟。 实际上，该系统只是闲置的，没有任何活动，但是在监视中，我们可以看到滞后现象正在加剧。 这个陷阱值得记住。 <br><br> 视图如下。 <br><br><img src="https://habrastorage.org/webt/sb/jg/6k/sbjg6kswtdtymuecundldk180r8.jpeg"><br><br> 它包含有关每个WAL发送者的信息以及对我们很重要的几个字段。 这主要是<strong>client_addr-</strong>连接的副本的网络地址（通常是IP地址）和一组<strong>lsn</strong>字段（在旧版本中称为location），我将进一步讨论它们。 <br><br> 在第10版中，出现了<strong>滞后</strong>字段-这是一种以时间表示的滞后，即一种更易于理解的格式。 延迟可以以字节或时间表示-您可以选择最喜欢的延迟。 <br><br> 通常，我使用此请求。 <br><br><img src="https://habrastorage.org/webt/ff/8g/kv/ff8gkvz-kzdihuxabphcb0rfd4e.jpeg"><br><br> 这不是pg_stat_replication以更方便易懂的格式打印的最复杂的查询。 在这里，我使用以下功能： <br><br><ul><li>  <strong>pg_wal_lsn_diff（）</strong>读取差异。 但是我认为差异之间是什么？ 我们有几个字段-send_lsn，write_lsn，flush_lsn，replay_lsn。 通过计算当前字段与前一个字段之间的差异，我们可以准确地了解滞后的位置，确切的滞后发生的位置。 <br></li><li>  <strong>pg_current_wal_lsn（）</strong> ，它显示事务日志的当前位置。 在这里，我们查看了日志中当前位置与已发送位置之间的距离-生成但未发送多少个事务日志。 <br></li><li>  <strong>sent_lsn</strong> ， <strong>write_lsn-</strong>这是发送到副本但未记录的数量。 也就是说，它现在位于网络上的某个位置，或者已被副本接收，但尚未从网络缓冲区写入磁盘存储。 <br></li><li>  <strong>write_lsn，flush_lsn-</strong>已写入，但不是由fsync命令发出-好像已写入，但可以位于操作系统页面缓存中RAM中的某个位置。 一旦执行fsync，数据就会与磁盘同步，进入持久性存储，一切似乎都是可靠的。 <br></li><li>  <strong>replay_lsn，flush_lsn-</strong>数据已转储，已执行fsync，但未复制。 <br></li><li>  <strong>current_wal_lsn</strong>和<strong>replay_lsn</strong>是一种包括所有先前位置的总滞后。 <br></li></ul><br><h4>  <strong>一些例子</strong> <br></h4><br><img src="https://habrastorage.org/webt/7c/9n/tt/7c9nttg6yp-uyimrxa4ji3ll1ha.jpeg"><br><br> 副本10.6.6.8在上方突出显示。 她有一个<strong>待处理的滞后</strong> ，她生成了一些事务日志，但是它们仍然没有发送并且位于主数据库上。 最有可能的是，网络性能存在某种问题。 我们将使用nicstat实用程序对此进行验证。 <br><br> 如果那里有任何问题和错误，我们将启动nicstat，查看接口利用率。 因此我们可以检验这个假设。 <br><br><img src="https://habrastorage.org/webt/co/-m/fj/co-mfjznunlrsuurikvz7xy9gh0.jpeg"><br><br>  <strong>写入延迟</strong>标记在上方。 实际上，这种滞后非常罕见，我几乎看不到它会很大。 问题可能出在磁盘上，我们使用iostat或iotop实用程序-查看磁盘存储的利用率，该I / O由进程创建，然后找出原因。 <br><br><img src="https://habrastorage.org/webt/to/xw/2j/toxw2jutr7yaof38fwbohph9lva.jpeg"><br><br>  <strong>刷新并重放</strong>延迟-延迟通常发生在副本计算机上的磁盘设备没有时间简单地丢失所有来自主服务器的更改时。 <br><br> 同样，使用iostat和iotop实用程序，我们将了解磁盘利用率的变化以及刹车的原因。 <br><br> 最后的<strong>total_lag</strong>是监视系统的有用指标。 如果超过了阈值total_lag，则在监视中会出现一个复选框，我们将开始调查那里发生的情况。 <br><br><h4>  <strong>假设检验</strong> <br></h4><br> 现在，您需要弄清楚如何进一步调查特定问题。 我已经说过，如果这是网络延迟，那么我们需要检查网络是否一切正常。 <br><br> 现在，几乎所有托管服务器都提供1 Gb / s甚至10 Gb / s，因此<strong>带宽阻塞是最不可能发生的情况</strong> 。 通常，您需要查看错误。  nicstat包含有关接口错误的信息，您可以确定驱动程序存在问题，无论是网卡本身还是电缆。 <br><br> 我们使用iostat和iotop调查<strong>存储问题</strong> 。 需要iostat来查看磁盘存储的一般情况：设备回收，设备带宽，延迟。  iotop-为了进行更精确的研究，当我们需要确定哪个进程正在加载磁盘子系统时。 如果这是某种第三方过程，则只需将其检测，完成，问题可能会消失。 <br><br> 首先，我们通过top或pg_stat_activity查看<strong>恢复延迟和复制冲突</strong> ：正在运行的进程，正在运行的请求，其执行时间，运行时间。 如果这些查询很长，我们将研究为什么它们会长时间工作，进行射击，理解和<strong>优化它们</strong> -我们将自己检查查询。 <br><br> 如果这是向导生成的<strong>大量事务日志</strong> ，我们可以通过<strong>pg_stat_activity</strong>来检测到它。 可能在那里开始了一些备份过程，已经开始进行某种清理（pg_stat_progress_vacuum），或者正在执行检查点。 也就是说，如果生成了太多的事务日志，而副本没有时间来处理它，则在某些时候它可能会掉下来，这对我们来说是个问题。 <br><br> 当然还有<strong>pg_wal_lsn_diff（）</strong>来确定延迟，并具体确定滞后在哪里-在网络，磁盘还是处理器上。 <br><br><h4>  <strong>解决方案选项</strong> <br></h4><br>  <strong>网络/存储问题</strong> <br><br> 这里的一切都非常简单，但是从配置的角度来看，这通常无法解决。 您可以拧紧一些螺母，但通常有两种选择： <br><br><ul><li> 检查工作量 </li></ul><br> 检查正在运行的请求。 也许启动了一些迁移，这些迁移会生成大量事务日志，或者它可以是数据传输，删除或插入。  <strong>任何生成事务日志的过程都可能导致事务滞后</strong> 。 向导中的所有数据都将尽快生成，我们对数据进行了更改，然后将其发送到副本，副本可以应付或失败-这与向导无关。 此处可能会出现滞后，您需要对此进行一些处理。 <br><br><ul><li> 升级硬件 <br></li></ul><br> 最愚蠢的选择-也许我们碰到了铁的性能，您只需要更改它。 它可以是旧磁盘或劣质SSD，也可以是RAID控制器性能的插件。 在这里，我们不再探索基础本身，而是检查腺体的性能。 <br><br>  <strong>恢复延迟</strong> <br><br> 如果由于长请求而导致任何类型的复制冲突，从而导致重放延迟增加，那么我们要做的<strong>第一件事</strong>就是<strong>拍摄</strong>在副本上运行的<strong>长请求</strong> ，因为它们会延迟事务日志的重放。 <br><br> 如果长查询与SQL查询本身的非最佳性有关（我们使用EXPLAIN ANALYZE可以找到此查询），则只需要以其他方式处理此查询并重写它即可。 或者，可以选择配置<strong>单独的副本以报告查询</strong> 。 如果我们制作的报告可以长期使用，则需要将它们提交到单独的副本中。 <br><br> 仍然可以选择<strong>等待</strong> 。 如果我们在几千字节甚至几十兆字节的水平上存在某种滞后，但是我们认为这是可以接受的，我们只是等待请求完成，并且滞后将自行解决。 这也是一种选择，它经常会被接受。 <br><br>  <strong>高音量WAL</strong> <br><br> 如果我们生成大量事务日志，则需要减少<strong>每单位时间</strong>的事务日志<strong>量</strong> ，以使副本副本需要消耗更少的事务日志。 <br><br> 这通常是<strong>通过配置</strong>完成的。 设置full_page_writes = off参数的部分解决方案。 此选项打开/关闭在事务日志中记录更改页面的完整图像。 这意味着，当我们执行写入检查点（CHECKPOINT）的服务操作时，下次我们更改共享缓冲区区域中的某些数据块时，此页面的完整映像将转到事务日志，而不仅仅是更改本身。 在同一页面上进行所有后续更改时，只有更改将记录在事务日志中。 依此类推，到达下一个检查点。 <br><br> 在检查点之后，我们记录页面的完整图像，这会影响记录的事务日志的数量。 如果每单位时间有很多检查点，那么说每小时要完成4个检查点，并且会有很多全页图像，这将是一个问题。 您可以禁用完整图像的录制，这将影响WAL的音量。 但这又是一半的措施。 <br><br>  <i>注意：应该仔细考虑禁用full_page_writes的建议，因为作者在报告中忘记澄清说，在某些情况下，禁用参数可能在紧急情况下发生（损坏文件系统或其日志，部分写入块等）。可能损坏的数据库文件。</i>  <i>因此，请小心，禁用该参数可能会增加紧急情况下数据损坏的风险。</i> <br><br> 另一半措施是<strong>增加检查点之间的间隔</strong> 。 默认情况下，检查点每5分钟执行一次，这很常见。 通常，此间隔增加到30-60分钟-这是所有脏页都设法与磁盘同步的可接受时间。 <br><br> 但是，主要的解决方案当然是<strong>查看我们的工作量</strong> -正在进行什么样的繁重操作，这些操作与更改数据有关，并且也许尝试分批进行这些更改。 <br><br> 假设我们有一个表，我们想从中删除几百万条记录。 最好的选择不是一次请求就删除数百万个，而是将它们分成100-200,000个数据包，这样，首先，会生成少量的WAL；其次，真空有时间传递删除的数据，因此，延迟不是这样大而关键。 <br><br><h3> 膨胀pg_wal / <br></h3><br> 现在，让我们谈谈如何发现pg_wal /目录已膨胀。 <br><br> 从理论上讲，PostgreSQL始终在某些配置文件级别上将其自身保持在最佳状态，通常，它不应超过某些限制。 <br><br> 有一个参数max_wal_size，它确定最大值。 另外还有wal_keep_segments参数-如果副本很长一段时间不可用，则主数据库为副本存储的额外段数。 <br><br> 计算了max_wal_size和wal_keep_segments的总和后，我们可以粗略估计pg_wal /目录将占用多少空间。 如果它迅速增长并且占用的空间比计算值大得多，这意味着存在一些问题，您需要对此进行一些处理。 <br><br><h4> 如何发现此类问题？ <br></h4><br> 在Linux操作系统上，有<strong>du -csh命令</strong> 。 我们可以简单地监视值并监视那里有多少事务日志； 保持计算得出的标签，他欠多少钱，他实际赚多少钱，以及以某种方式应对数字变化。 <br><br> 我们要看的另一个地方是<strong>pg_replication_slots</strong>和<strong>pg_stat_archiver视图</strong> 。  pg_wal /占用大量空间的最常见原因是忘记了复制槽或损坏的归档。 其他原因也有待解决的地方，但在我的实践中，它们很少见。 <br><br> 而且，当然，与归档命令关联的PostgreSQL日志中总是存在错误。 不幸的是，没有其他原因与pg_wal /溢出有关。 我们只能在那里捕获存档错误。 <br><br><h4> 问题选项： <br></h4><br>  <strong>重载CRUD-</strong>重载数据刷新操作-重载INSERT，DELETE，UPDATE，与更改几百万行相关。 如果PostgreSQL需要执行这样的操作，很明显将产生大量的事务日志。 它将存储在pg_wal /中，这将增加占用的空间。 就是说，再次如我之前所说，优良作法是将它们分成多个包，而不是更新整个数组，而是每个更新100、200、30万。 <br><br>  <strong>遗忘或未使用的复制插槽</strong>是另一个常见问题。 人们通常将逻辑复制用于某些任务：他们配置将数据发送到Kafka的总线，将数据发送到将逻辑复制解码为另一种格式并以某种方式处理它们的第三方应用程序。  <strong>逻辑复制通常通过插槽进行</strong> 。 碰巧我们设置了一个复制槽，与该应用程序一起使用，意识到该应用程序不适合我们，关闭了该应用程序，将其删除， <strong>并且复制槽继续存在</strong> 。 <br><br> 每个复制插槽的PostgreSQL都会保存事务日志的段，以防远程应用程序或副本再次连接到该插槽，然后向导可以将这些事务日志发送给它们。 <br><br> 但是随着时间的流逝，没有人连接到插槽，事务日志被累积，并且在某些时候它们占据了90％的空间。 我们需要找出它是什么，为什么要占用这么多空间。 通常，只需删除此已遗忘和未使用的插槽，即可解决问题。 但是稍后会更多。 <br><br> 另一个选项可能是<strong>损坏的archive_command</strong> 。 当我们为灾难恢复任务保留某种外部事务日志存储库时，通常会设置一个归档命令，而很少会设置pg_receivexlog。 在archive_command中注册的命令通常是单独的命令或某些脚本，这些脚本从pg_wal /中获取事务日志的各个部分并将其复制到归档存储中。 <br><br> 碰巧我们对系统软件包进行了某种升级，例如，在rsync中，版本已更改，标志已更新或已更改，或者在archive命令中使用的其他某些命令中，格式也已更改-以及在中指定的脚本或程序本身archive_command中断。 因此，归档文件不再被复制。 <br><br> 如果archive命令的输出不为0，则有关此消息的消息将被写入日志，该段将保留在pg_wal /目录中。  <strong>直到我们发现归档团队已经破产，分段才会累积起来</strong> ，并且该地点也将在某个时刻结束。 <br><br>  <strong>一套应急措施（100％已用空间）：</strong> <br><br> 1. <strong>   CRUD </strong> ,        — pg_terminate_backend(). <br>    -  ,  , ,      ..       ,      pg_wal/,     . <br><br> 2. <strong>    </strong>    root — reserved space ratio (ext filesystems). <br>       ext      ext     5%.  ,         ,  5% —  . ,   ,     1%  ,     tune2fs -m 1.       PostgreSQL     ,    .      100%     . <br><br> 3. <strong>  </strong> (LVM, ZFS,...). <br>    LVM  ZFS,        LVM  ZFS,            ,   ,           .       ,   . <br><br> 4.    — <strong>, , HE    pg_wal/</strong> . <br>          ,     ,   ,   .     ! PostgreSQL     ,   .     ,  ,   ,    . <br><br> , pg_xlog/   pg_wal/     —  log    ,   , , ,  -   —  ! <br><br><h4>    <br></h4><br>  ,         100%  CPU,      . <br><br>   <strong> workload  </strong> .    ,       ?  ,     - ,      -.         :   ,   tablespace,    tablespace. <br><br>   <strong> </strong> .       ,  ,    ,    , ,  ,            . <strong>   —      .</strong> <br><br>   <strong>  checkpoints_segments/max_wal_size, wal_keep_segments</strong> .  ,    ,      — 10-20   wal_keep_segments,     max_wal_size.  ,        .  PostgreSQL       pg_wal/  . <br><br>  <strong>  </strong>   pg_replication_slots —     .   ,   <strong> </strong> ,        —      .   ,    ,    .    . <br><br>      WAL,       ,  <strong>    pg_stat_archiver</strong> ,    . ,  <strong>  </strong> , ,    ,    . <br><br>    <strong>   checkpoint</strong> .       ,        ,      . , PostgreSQL        . <strong>   ,    checkpoint</strong> . <br><br><h3>       <br></h3><br>    ,   ,   —        .   -             ,       .      ,         . <br><br> <strong> </strong> —    PostgreSQL  : <br><br><ul><li> User was holding shared bufer pin for too long. <br></li><li> User query might have needed to see row versions that must be removed. <br></li><li> User was holding a relation lock for too long. <br></li><li> User was or might have been using table space that must be dropped. <br></li><li> User transaction caused bufer deadlock with recovery. <br></li><li> User was connected to a database that must be dropped. <br></li></ul><br>  2  —    ,       ,      .   :  ,   ,      .        (  30 ),  <strong>PostgreSQL       </strong> —  . <br><br>    .  ,    ,             .    -    ,     timeout     .     —    ALTER,    ,    . <br><br>     .     ,  tablespace     ,            tablespace.   ,    ,  -   —   . <br><br><h4> <strong> ?</strong> <br></h4><br>       <strong>pg_stat_databases, pg_stat_databases_conflicts</strong> .         ,    .     ,    . <br><br>  <strong>  </strong> ,       <strong> </strong> .  ,      .   ,    . ,       ,    ,    . <br><br><h4> <strong> ?</strong> <br></h4><br>   ,    —    : <br><br><ol><li> <strong> max_standby_streaming_delay</strong> (  ).     ,       .    <strong>   </strong> . <br></li><li> <strong> hot_stadby_feedback</strong> (  /).  ,  vacuum   - ,       .     <strong> bloat  </strong> .     ,    ,  ,   hot_stadby_feedback  . <br></li><li>     DBA     —  <strong>  </strong> .   <strong> </strong> ,    .  ,    ,     ,   -    ,  . <br></li><li>  , ,  ,   ,  DBA —  <strong>     </strong> , ,  .    max_standby_streaming_delay  .       ,   .      ,  ,    ,  .  <strong>   </strong> —    ,     . <br></li></ol><br><h2> Recovery process: 100% CPU usage <br></h2><br>  ,  ,    , <strong> 100%   </strong> .  ,      ,      100%.  ,    pg_stat_replication,  ,     replay,       ,    . <br><br> <strong></strong>  : <br><br><ul><li> <strong>top</strong> —       —    100% CPU usage  recovery process; <br></li><li> <strong>pg_stat_replication</strong> —  ,   ,     . <br></li></ul><br><h4> <strong>   </strong> <br></h4><br>      ,    .  ,     : <br><br><ul><li> perf top/record/report ( debug—); <br></li><li> GDB; <br></li><li>  pg_waldump. <br></li></ul><br>  ,   ,       .     workload,   <strong>        </strong> .  ,    , PostgreSQL     shared buffers       ( ).        . <br><br><h4> <strong></strong> <br></h4><br>    ,      <strong>   </strong> . -   workload, - , -    : «      ,  -  ». <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pgsql-hackers</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pgsql-bugs</a> ,   ,   .  ,    . <br><br>     — <strong>-   ,  , </strong> . <br><br><h2>  <br></h2><br> <strong>      </strong> .  ,             ,    ,      . <br><br> <strong>     </strong> .    , ,  ,    ,   ,   — . <br><br>  , <strong>  </strong> ,   — .   ,   ,  ,         . <br><br>  ,    ,  <strong>  </strong> —  ,      ,   . <br><br><h3> 有用的链接 <br></h3><br><ul><li> PostgreSQL official documentation — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">The Statistics Collector</a> </li><li> PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mailing Lists</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">general</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">performance</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hackers</a> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PostgreSQL-Consulting company blog</a> </li></ul><br><blockquote>             , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Highload++ Siberia</a> ,   <strong>25  26   </strong> .   ,     ,  . <br><br><ul><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>     MySQL  ClickHouse. </li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,            Oracle. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尼古拉·戈洛夫（Nikolay Golov）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会告诉您</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果一项服务中有钱，另一项服务中有钱，并且每种服务都有自己独立的基础，则如何实施交易。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尤里Nasretdinov详细的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解释</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，需要VK ClickHouse什么，有多少数据存储，等等。</font></font></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414111/">https://habr.com/ru/post/zh-CN414111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414095/index.html">[翻译] Elasticsearch 6.3.0发布</a></li>
<li><a href="../zh-CN414097/index.html">Apple计算机关闭了积极技术专家发现的固件漏洞</a></li>
<li><a href="../zh-CN414103/index.html">公开网络研讨会：“制药任务的神经网络”</a></li>
<li><a href="../zh-CN414105/index.html">使用随机森林算法预测2018年世界杯足球赛结果</a></li>
<li><a href="../zh-CN414109/index.html">使用Docker构建和运行C ++项目</a></li>
<li><a href="../zh-CN414115/index.html">什么是惰性FP状态还原：英特尔处理器中发现的新漏洞</a></li>
<li><a href="../zh-CN414119/index.html">由于火星上的沙尘暴，机会入睡了。 目前尚不清楚流动站能否再次工作</a></li>
<li><a href="../zh-CN414121/index.html">DIY独立无人机与互联网控制</a></li>
<li><a href="../zh-CN414123/index.html">我们将文本协议升级为二进制文件，并在C ++用户组会议上与旧代码作斗争</a></li>
<li><a href="../zh-CN414125/index.html">我们如何测试VMware vSAN™：为何在实践中起作用</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>