<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòâ üêª üë®üèæ‚Äçüéì Android Surface üí® üëª üë©üèª‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Clause de non-responsabilit√© 


 Cet article est destin√© aux d√©veloppeurs Android d√©butants ayant peu d'exp√©rience avec la vid√©o et / ou la cam√©ra, en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android Surface</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480878/"><h2 id="diskleymer">  Clause de non-responsabilit√© </h2><br><p>  Cet article est destin√© aux d√©veloppeurs Android d√©butants ayant peu d'exp√©rience avec la vid√©o et / ou la cam√©ra, en particulier ceux qui ont commenc√© √† analyser des exemples de <a href="https://github.com/google/grafika" rel="nofollow">grafika</a> et qui les ont trouv√©s difficiles, ici nous examinerons un code similaire avec une description simplifi√©e des √©tapes de base illustr√©es par des diagrammes d'√©tat. </p><br><p>  Pourquoi la classe Surface est-elle rendue dans l'en-t√™te?  Dans Android, de nombreuses classes ont le mot <em>Surface</em> dans leur nom (Surface, SurfaceHolder, SurfaceTexture, SurfaceView, GLSurfaceView), elles ne sont pas connect√©es par une hi√©rarchie commune, cependant, elles sont combin√©es par une logique de bas niveau pour travailler avec la sortie d'image.  Il m'a sembl√© raisonnable de l'utiliser dans le titre pour souligner une tentative de divulgation de travaux avec cette partie particuli√®re du SDK. </p><a name="habracut"></a><br><h2 id="primer-ispolzovaniya-s-raznym-api">  Exemple d'utilisation avec diff√©rentes API </h2><br><p>  Essayons d'√©crire l'exemple suivant: <strong>nous allons prendre un aper√ßu de la cam√©ra, superposer un dessin anim√© sur celle-ci, tout afficher √† l'√©cran et, si n√©cessaire, √©crire dans un fichier.</strong>  Le code complet se trouvera <a href="https://github.com/tttzof351/AndroidSurfaceExample/" rel="nofollow">https://github.com/tttzof351/AndroidSurfaceExample/</a> </p><br><p>  Pour la sortie vers les √©crans, nous utiliserons <a href="https://developer.android.com/reference/android/opengl/GLSurfaceView" rel="nofollow">GLSurfaceView</a> , pour l'enregistrement avec les classes <a href="https://developer.android.com/reference/android/media/MediaCodec" rel="nofollow">MediaCodec</a> et <a href="https://developer.android.com/reference/android/opengl/EGLSurface" rel="nofollow">EGLSurface</a> , et communiquerons avec la cam√©ra via l' <a href="https://developer.android.com/reference/android/hardware/camera2/package-summary" rel="nofollow">API V2</a> .  Le sch√©ma g√©n√©ral est approximativement le suivant: </p><br><p><img src="https://habrastorage.org/webt/9o/rc/o5/9orco54m0chpg_og4db_qppsrjm.png"></p><br><h2 id="nalozhenie-neskolkih-surface">  Superpositions de surfaces multiples </h2><br><p>  La surface est en fait une poign√©e pour la zone en m√©moire qui doit √™tre remplie avec l'image.  Tr√®s probablement, nous obtenons qu'il essaie d'afficher quelque chose √† l'√©cran ou dans un fichier, donc cela fonctionne comme un tampon pour certains ¬´processus¬ª qui produisent des donn√©es. </p><br><p>  Pour cr√©er une superposition √† partir de plusieurs surfaces, nous utiliserons OpenGL. <br>  Pour ce faire, nous allons cr√©er deux textures externes carr√©es et en extraire Surface </p><br><p>  Dans le code, cela ressemblera √† ceci: </p><br><p>  <a href="" rel="nofollow">OpenGLExtarnalTexture.kt</a> </p><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> textures = IntArray(<span class="hljs-number"><span class="hljs-number">1</span></span>) GLES20.glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, textures, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> textureId = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">//    val textureWidth = ... val textureHeight = ... //  val surfaceTexture = SurfaceTexture(textureId) surfaceTexture.setDefaultBufferSize(textureWidth, textureHeight) //, surface  ""    val surface = Surface(surfaceTexture)</span></span></code> </pre> <br><p>  <strong>Coordonn√©es XYZ</strong> </p><br><p>  Maintenant, nous devons comprendre comment cr√©er et organiser des textures, et pour cela, nous devrons nous rappeler comment la grille de coordonn√©es est structur√©e dans OpenGL: son centre co√Øncide avec le centre de la sc√®ne (fen√™tre), et les bordures sont normalis√©es, c'est-√†-dire de -1 √† 1. </p><br><p>  Dans cette sc√®ne, nous voulons d√©finir deux rectangles (le travail est dans le plan, donc toutes les coordonn√©es z sont logiquement d√©finies √† 0f) - en rouge, nous d√©signons celui o√π nous placerons l'aper√ßu pour la cam√©ra, et en bleu pour le dessin anim√©: </p><br><p>  Nous notons explicitement nos coordonn√©es: </p><br><p><img src="https://habrastorage.org/webt/mu/fj/kr/mufjkrznafatofs4lsn-ywm_h7i.png"></p><br><pre> <code class="kotlin hljs">fullscreenTexture = floatArrayOf( <span class="hljs-comment"><span class="hljs-comment">// X, Y, Z -1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, -1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, ) smallTexture = floatArrayOf( // X, Y, Z 0.3f, 0.3f, 0.0f, 0.8f, 0.3f, 0.0f, 0.3f, 0.8f, 0.0f, 0.8f, 0.8f, 0.0f )</span></span></code> </pre> <br><p>  <strong>Coordonn√©es UV</strong> </p><br><p>  Est-ce suffisant?  Il s'av√®re que non :( </p><br><p>  Une texture est un mappage d'une image √† une zone de sc√®ne et pour la rendre correctement, vous devez sp√©cifier exactement o√π les points de l'image se situent dans cette zone - pour cela, OpenGL utilise <strong>les</strong> coordonn√©es <strong>UV</strong> - ils sortent du coin inf√©rieur gauche et ont des bordures de 0 √† 1 pour chaque axes. </p><br><p>  Cela fonctionne comme suit - nous <strong>d√©finirons les</strong> coordonn√©es <strong>UV</strong> pour chaque sommet de notre zone et rechercherons les points correspondants dans l'image, en supposant que la largeur et la hauteur sont √©gales √† 1. </p><br><p>  Prenons un exemple - nous supposerons que la cam√©ra nous donne l'image dans un √©tat invers√© et r√©fl√©chi, et en m√™me temps, nous voulons montrer uniquement la partie sup√©rieure droite, c'est-√†-dire prendre 0,8 en latitude et en hauteur de l'image. </p><br><p>  Le point subtil - √† ce stade, nous ne connaissons pas le rapport d'aspect de la zone √† l'√©cran - nous n'avons qu'un carr√© en coordonn√©es relatives, qui remplira toute la sc√®ne et s'√©tirera en cons√©quence.  Si nous devions cr√©er une cam√©ra plein √©cran, nos tailles relatives (2 de chaque c√¥t√©) s'√©tireraient jusqu'au 1080x1920 conventionnel.  Nous supposons que nous d√©finissons les dimensions de la sc√®ne de telle sorte que leur rapport soit √©gal au rapport de la cam√©ra. <br>  Voyons o√π vont les coordonn√©es - le point sup√©rieur droit de notre zone (1, 1, 0) devrait aller aux coordonn√©es UV (0, 0), le coin inf√©rieur gauche dans (0.8f, 0.8f), etc. </p><br><p><img src="https://habrastorage.org/webt/fk/ur/ig/fkurigpfo4l_hnl1fonbgj1dao0.png"></p><br><p>  Ainsi, nous obtenons la correspondance de XYZ et UV: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// X, Y, Z, U, V -1.0f, -1.0f, 0.0f, 0.8f, 0.8f, 1.0f, -1.0f, 0.0f, 0.8f, 0.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.8f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f</span></span></code> </pre> <br><p>  Si le rapport d'aspect entre l'aper√ßu de la cam√©ra et la zone sur l'√©cran co√Øncidait initialement, il continuera √©videmment √† √™tre enregistr√©, car dans notre cas, nous venons de multiplier par 0,8f. <br>  Et que mangerons-nous, nous fixerons des valeurs sup√©rieures √† 1?  Selon les param√®tres que nous avons pass√©s √† OpenGL, nous obtiendrons des points d'une partie de l'image.  Dans notre exemple, la derni√®re ligne sera r√©p√©t√©e le long de l'axe correspondant et nous verrons des artefacts sous forme de ¬´rayures¬ª </p><br><p>  <strong>Conclusion: si nous voulons compresser / couper l'image tout en conservant la position de la zone sur l'√©cran, alors les coordonn√©es UV sont notre choix!</strong> </p><br><p>  <strong>D√©finissez les coordonn√©es de nos textures.</strong> </p><br><p><img src="https://habrastorage.org/webt/au/wp/zx/auwpzx9wgczhb79_4bbfu9nyk_a.png"></p><br><pre> <code class="kotlin hljs">fullscreenTexture = floatArrayOf( <span class="hljs-comment"><span class="hljs-comment">// X, Y, Z, U, V -1.0f, -1.0f, 0.0f, 1f, 0f, 1.0f, -1.0f, 0.0f, 0f, 0f, -1.0f, 1.0f, 0.0f, 1f, 1f, 1.0f, 1.0f, 0.0f, 0f, 1f ) smallTexture = floatArrayOf( // X, Y, Z, U, V 0.3f, 0.3f, 0.0f, 0f, 0f, 0.8f, 0.3f, 0.0f, 1f, 0f, 0.3f, 0.8f, 0.0f, 0f, 1f, 0.8f, 0.8f, 0.0f, 1f, 1f )</span></span></code> </pre> <br><p>  <strong>Shaders</strong> </p><br><p>  Avoir des coordonn√©es statiques XYZ et UV n'est pas tr√®s pratique - par exemple, nous pourrions vouloir d√©placer et mettre √† l'√©chelle nos textures avec des gestes.  Pour les transformer, nous allons cr√©er deux matrices pour chaque texture: <strong>MVPMatrix</strong> et <strong>TexMatrix</strong> pour respectivement les coordonn√©es XYZ et UV. </p><br><p>  Chaque OpenGL2 doit contenir des shaders afin d'afficher quelque chose √† l'√©cran.  Bien s√ªr, ce n'est pas un sujet qui peut √™tre divulgu√© dans un paragraphe, cependant, dans notre cas, ils seront triviaux, et donc vous pouvez rapidement comprendre ce qu'ils font, sans trop conna√Ætre le mat√©riel. </p><br><p>  Tout d'abord, il y a deux shaders - vertex et fragment. </p><br><p>  Le premier (sommet) traitera nos sommets, √† savoir, simplement multiplier nos coordonn√©es XYZ / UV avec leurs matrices correspondantes et remplir la variable OpenGL <strong>gl_Position</strong> qui est exactement responsable de la position finale de notre texture √† l'√©cran. </p><br><p>  Le second (fragment) devrait remplir <strong>gl_FragColor avec</strong> des pixels d'image. </p><br><p>  Total nous avons: les variables √† l'int√©rieur du vertex shader nous devons remplir les champs avec nos donn√©es, √† savoir: </p><br><ul><li>  MVPMatrix -&gt; <strong>uMVPMatrix</strong> </li><li>  <strong>TexMatrix -&gt; uTexMatrix</strong> </li><li>  nos coordonn√©es de sommet XYZ -&gt; <strong>aPosition</strong> </li><li>  Coordonn√©es UV -&gt; <strong>aTextureCoord</strong> </li></ul><br><p>  <strong>vTextureCoord</strong> - n√©cessaire pour transmettre les donn√©es du vertex shader au fragment shader <br>  Dans le fragment shader, nous prenons les coordonn√©es UV converties et les utilisons pour afficher les pixels de l'image dans la zone de texture. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vertexShader = <span class="hljs-string"><span class="hljs-string">""" uniform mat4 uMVPMatrix; uniform mat4 uTexMatrix; attribute vec4 aPosition; attribute vec4 aTextureCoord; varying vec2 vTextureCoord; void main() { gl_Position = uMVPMatrix * aPosition; vTextureCoord = (uTexMatrix * aTextureCoord).xy; } """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fragmentShader = <span class="hljs-string"><span class="hljs-string">""" #extension GL_OES_EGL_image_external : require precision mediump float; varying vec2 vTextureCoord; uniform samplerExternalOES sTexture; void main() { gl_FragColor = texture2D(sTexture, vTextureCoord); } """</span></span></code> </pre> <br><p>  Pour r√©f√©rence, nous indiquons la diff√©rence entre les types: </p><br><ul><li>  uniforme - une variable de ce type conservera des valeurs lors d'appels r√©p√©t√©s, nous utilisons un shader qui est appel√© s√©quentiellement pour deux textures, nous allons donc toujours l'√©craser √† chaque rendu </li><li>  attribut - les donn√©es de ce type sont lues √† partir du tampon de vertex, elles doivent √™tre charg√©es √† chaque rendu </li><li>  variable - n√©cessaire pour transf√©rer des donn√©es du vertex shader vers un fragment </li></ul><br><p>  Comment passer des param√®tres √† un shader?  Pour ce faire, vous devez d'abord obtenir l'id (pointeur) de la variable: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aPositionHandle = GLES20.glGetAttribLocation(programId, <span class="hljs-string"><span class="hljs-string">"aPosition"</span></span>)</code> </pre> <br><p>  Maintenant, pour cet identifiant, vous devez charger les donn√©es: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//      floatbuffer val verticesBuffer = ByteBuffer.allocateDirect( fullscreenTexture.size * FLOAT_SIZE_BYTES ).order( ByteOrder.nativeOrder() ).asFloatBuffer() verticesBuffer.put(fullscreenTexture).position(0) /*    -  XYZ   0 .       id      ,     ,               - 5  - XYZUV,  4 - -   float */ verticesBuffer.position(0) GLES20.glVertexAttribPointer( aPositionHandle, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer )</span></span></code> </pre> <br><p>  <strong>Dessin direct</strong> </p><br><p>  Apr√®s avoir rempli nos shaders avec toutes les donn√©es, nous devons demander √† la texture de mettre √† jour l'image et √† OpenGL de dessiner nos sommets: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { ... surfaceTexture.updateTexImage() GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) }</code> </pre> <br><p>  Dans notre exemple, nous allons diviser le travail avec la sc√®ne OpenGL en deux classes - directement les sc√®nes et les textures: </p><br><p>  <a href="https://github.com/tttzof351/AndroidSurfaceExample/blob/master/app/src/main/java/com/example/surfaces/helpers/OpenGLExternalTexture.kt/" rel="nofollow">OpenGLExternalTexture.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenGLExternalTexture</span></span></span></span>(verticesData: FloatArray, ...) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surfaceTexture: SurfaceTexture <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surface: Surface <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,    . } ... fun updateFrame(aPositionHandle: Int, ...) {...} // ,   fun release() {...} //   }</span></span></code> </pre> <br><p>  <a href="" rel="nofollow">OpenGLScene.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenGLScene</span></span></span></span>( sceneWidth: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, sceneHeight: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, ... ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullscreenTexture = OpenGLExternalTexture(...) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> smallTexture = OpenGLExternalTexture(..) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aPositionHandle: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,        . } fun updateFrame() { ... fullscreenTexture.updateFrame(aPositionHandle, ...) smallTexture.updateFrame(aPositionHandle, ...) } fun release() { fullscreenTexture.release() smallTexture.release() } }</span></span></code> </pre> <br><h2 id="statemachine--mashina-sostoyaniy--konechnyy-avtomat">  StateMachine / State Machine / State Machine </h2><br><p>  Toutes les API que nous avons l'intention d'utiliser dans notre exemple sont fondamentalement asynchrones (enfin, peut-√™tre √† l'exception du Drawable anim√©).  Nous encapsulerons ces appels dans des StateMachines s√©par√©s, une approche o√π l'√©tat du syst√®me est explicitement √©crit, et les transitions entre elles se produisent par l'envoi d'√©v√©nements. </p><br><p>  Regardons un exemple simple de ce √† quoi cela ressemblera, supposons que nous ayons ce code: </p><br><pre> <code class="kotlin hljs">imageView.setOnClickListener { loadImage { bitmap -&gt; imageView.setBitmap(bitmap) } }</code> </pre> <br><p>  En g√©n√©ral, tout va bien - beau et compact, mais nous allons essayer de le r√©√©crire de la mani√®re suivante: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiMachine = UIMachine() imageView.setOnClickListener { uiMachine.send(Click(imageView)) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIMachine</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: State = WaitClick() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Action</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = transition(action) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Action</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitingClick &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Click -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitBitmap(imageView = action.imageView) loadImage { send(BitmapIsReady(bitmap = it)) } } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitingBitmap &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> BitmapIsReady -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitClick state.imageView.setImageBitmap(action.bitmap) } } } } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> WaitingClick : State() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaitingBitmap</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> imageView: ImageView): State() } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Click</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> imageView: ImageView): Action() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BitmapIsReady</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bitmap: Bitmap): Action() }</code> </pre> <br><p>  D'une part, il s'est av√©r√© <strong><em>beaucoup</em></strong> plus, n√©anmoins, plusieurs propri√©t√©s implicites mais utiles sont apparues: un appui r√©p√©t√© maintenant ne conduit pas √† un <strong>d√©marrage</strong> inutile de <strong>loadImage,</strong> bien que ce ne soit pas √©vident avec un tel volume, mais nous nous sommes d√©barrass√©s de l'appel de rappel imbriqu√©, que nous utiliserons plus tard , et le style d'√©criture de la m√©thode de transition vous permet de construire un diagramme de transition qui r√©p√®te le code un par un, c'est-√†-dire dans notre cas: </p><br><p><img src="https://habrastorage.org/webt/-n/2p/mq/-n2pmqdwfsps932me0wfsrvyj_q.png"><br>  Le gris indique des transitions qui ne sont pas explicitement √©crites.  Souvent, ils sont enregistr√©s ou lev√©s une exception, le consid√©rant comme un signe d'erreur.  Pour l'instant, nous r√©ussirons √† simplement l'ignorer et √† l'avenir nous ne pointerons pas vers les diagrammes. </p><br><p>  Cr√©ez les interfaces de base pour StateMachine: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateMachine</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S : State, A : Action</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: S <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><h2 id="glsurfaceview">  GLSurfaceView </h2><br><p>  La fa√ßon la plus simple d'afficher quelque chose √† l'aide d'OpenGL dans Android est la classe GLSurfaceView - elle cr√©e automatiquement un nouveau flux pour le dessin, qui d√©marre / s'arr√™te en utilisant les m√©thodes GLSurfaceView :: onResume / onPause. </p><br><p>  Pour simplifier, nous allons d√©finir notre point de vue sur un rapport 16: 9. </p><br><p>  Le processus de rendu lui-m√™me est d√©plac√© vers un rappel distinct - GLSurfaceView.Renderer. <br>  En l'enveloppant dans StateMachine, nous obtenons quelque chose comme ceci: </p><br><p>  <a href="" rel="nofollow">GLSurfaceMachine.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLSurfaceMachine</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateMachine</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLSurfaceState, GLSurfaceAction</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: GLSurfaceState = WaitCreate() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLSurfaceAction</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = transition(action) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLSurfaceAction</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitCreate &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Create -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitSurfaceReady(...) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.glSurfaceView?.setRenderer(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> :Renderer { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, width: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, height: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> send(SurfaceReady(width, height, gl)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, config: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EGLConfig</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDrawFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { send(Draw) } }) } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitSurfaceReady &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SurfaceReady -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openGLScene = OpenGLScene(width, height) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = DrawingAvailable(openGLScene, ...) } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DrawingAvailable &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Draw -&gt; { state.openGLScene.updateFrame() } state !<span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitCreate &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Stop -&gt; { state.uiHolder.glSurfaceView?.onPause() state.uiHolder.openGLScene?.release() <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitSurfaceReady() } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitSurfaceReady &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Start -&gt; { state.uiHolder.glSurfaceView?.onResume() } } } } ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> glSurfaceMachine = GLSurfaceMachine() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> glSurfaceView = findViewById(R.id.gl_view) glSurfaceView.layoutParams.width = width glSurfaceView.layoutParams.height = ((<span class="hljs-number"><span class="hljs-number">16f</span></span>/<span class="hljs-number"><span class="hljs-number">9f</span></span>) * width).toInt() glSurfaceMachine.send(GLSurfaceAction.Create(glSurfaceView, ...))</code> </pre> <br><p>  Dessinons un diagramme de transition: </p><br><p><img src="https://habrastorage.org/webt/mx/5i/xb/mx5ixbssfaqci1ktsmumu94jbz0.png"></p><br><p>  Maintenant, notre code essaie d'afficher quelque chose √† l'√©cran, bien que pour l'instant il le fasse mal - nous ne verrons rien d'autre qu'un √©cran noir.  Il n'est pas difficile de deviner le fait que rien n'entre dans notre Surface maintenant parce que nous n'avons pas encore impl√©ment√© de sources d'images.  Corrigeons cela - tout d'abord, cr√©ez un CanvasDrawable: </p><br><p>  <a href="" rel="nofollow">CanvasDrawable.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanvasDrawable</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Drawable</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundPaint = Paint().apply { ... } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> circlePaint = Paint().apply { ... } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Canvas</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { canvas.drawRect(bounds, backgroundPaint) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> width = bounds.width() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> height = bounds.height() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> posX = ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> posY = ... canvas.drawCircle(posX, posY, <span class="hljs-number"><span class="hljs-number">0.1f</span></span> * width, circlePaint) } ... }</code> </pre> <br><p>  Maintenant, nous pouvons compl√©ter la section dans GLSurfaceMachine en rendant canvasDrawable sur canvas qui fournit la surface de la texture correspondante: </p><br><pre> <code class="kotlin hljs">state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DrawingAvailable &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Draw -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> canvasDrawable = state.canvasDrawable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> smallTexture = state.openGLScene.smallTexture <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bounds = canvasDrawable.bounds <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> canvas = smallSurface.lockCanvas(bounds) canvasDrawable.draw(canvas) smallSurface.unlockCanvasAndPost(canvas) state.openGLScene.updateFrame() }</code> </pre> <br><p>  Apr√®s quoi, nous verrons quelque chose comme: </p><br><p><img src="https://habrastorage.org/webt/vo/4r/-d/vo4r-dgpynjvynvxdomy2fezp9y.png"></p><br><h2 id="camera-api-v2">  Camera API V2 </h2><br><p>  Le rectangle vert est certainement amusant et intriguant, mais il est temps d'essayer de faire passer l'aper√ßu de l'appareil photo sur la surface restante. </p><br><p>  √âcrivons les √©tapes pour travailler avec la cam√©ra: </p><br><ul><li>  Nous attendons la permission.  Nous aurons cet √©tat <strong>WaitingStart</strong> </li><li>  Nous obtenons l'instance de gestionnaire de cam√©ra, nous trouvons l'ID logique (g√©n√©ralement il y en a deux - pour l'arri√®re et l'avant, et la logique est parce que la cam√©ra peut se composer de nombreux capteurs sur les appareils modernes) de la cam√©ra souhait√©e, s√©lectionnez la taille appropri√©e, ouvrez la cam√©ra, nous obtenons CameraDevice.  Statut en <strong>attente Ouvert</strong> </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> manager = getSystemService(Context.CAMERA_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CameraManager <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultCameraId: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultSize: Size? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cameraId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> manager.cameraIdList) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> chars = manager.getCameraCharacteristics(cameraId) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> facing = chars.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(CameraCharacteristics.LENS_FACING) ?: -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (facing == LENS_FACING_BACK) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> confMap = chars.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>( CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sizes = confMap?.getOutputSizes(SurfaceTexture::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resultSize</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">findSize</span></span></span></span>(sizes) resultCameraId = cameraId <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } resultCameraId?.let { cameraId -&gt; manager.openCamera(cameraId, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraDevice.StateCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOpened</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(camera: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CameraDevice</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//Success open camera ... } }) }</span></span></code> </pre> <br><ul><li>  Ayant une cam√©ra ouverte, nous nous tournons pour demander une surface pour afficher l'image.  √âtat <strong>WaitingSurface</strong> </li><li>  Maintenant que nous avons cameraDevice, Surface, nous devons ouvrir une session pour que la cam√©ra commence enfin √† transmettre des donn√©es.  Statut <strong>WaitingSession</strong> </li></ul><br><pre> <code class="kotlin hljs">cameraDevice.createCaptureSession( arrayListOf(surface), <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraCaptureSession.StateCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(session: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CameraCaptureSession</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { send(CameraAction.SessionReady(session)) } }, handler )</code> </pre> <br><ul><li>  Nous pouvons maintenant capturer l'aper√ßu.  √âtat <strong>StartingPreview</strong> </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> request = cameraDevice.createCaptureRequest( CameraDevice.TEMPLATE_PREVIEW ).apply { addTarget(surface) } session.setRepeatingRequest( request.build(), <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraCaptureSession.CaptureCallback() {...} handler )</code> </pre> <br><p>  Nous illustrons notre sch√©ma actuel: </p><br><p>  <a href="" rel="nofollow">CameraMachine.kt</a> </p><br><p><img src="https://habrastorage.org/webt/i6/tj/q1/i6tjq12xls77hudocvpnt0m6qy0.png"></p><br><p><img src="https://habrastorage.org/webt/6w/ad/fp/6wadfpayduldvtqwcrjggkoce6y.png"></p><br><h2 id="mediacodec">  Mediacodec </h2><br><p>  MediaCodec est une classe pour le travail de bas niveau avec les codecs syst√®me, en g√©n√©ral, son API est un ensemble de tampons d'entr√©e / sortie (cela semble, malheureusement, plus facile que de travailler avec lui) dans lequel les donn√©es (brutes ou encod√©es d√©pendent du mode de fonctionnement de l'encodeur / d√©codeur) sont plac√©es, et en sortie on obtient le r√©sultat. </p><br><p>  Malgr√© le fait que ByteBuffer agit g√©n√©ralement comme des tampons, vous pouvez utiliser Surface pour travailler avec la vid√©o, ce qui nous renverra MediaCodec :: createInputSurface, nous devons y dessiner les images que nous voulons enregistrer (avec cette approche, la documentation nous promet un encodage plus rapide gr√¢ce √† l'utilisation de gpu ) </p><br><p>  Eh bien, nous devons maintenant apprendre √† dessiner la surface existante que nous avons cr√©√©e dans GLSurfaceMachine sur Surface √† partir de MediaCodec.  Il est important de se rappeler: Surface est un objet qui cr√©e un consommateur, et en g√©n√©ral, il est impossible de lire quelque chose, c'est-√†-dire qu'il n'y a pas de m√©thode conditionnelle getBitmap / readImage / ... </p><br><p>  Nous proc√©derons comme suit: sur la base du contexte GL existant, nous en cr√©erons un nouveau qui aura une m√©moire commune avec lui, et donc nous pouvons l'utiliser pour r√©utiliser les id-shniks des textures que nous avons cr√©√©es pr√©c√©demment.  Ensuite, en utilisant le nouveau contexte GL et la surface de MediaCodec, nous allons cr√©er une EGLSurface - un tampon hors √©cran sur lequel nous pouvons √©galement cr√©er notre classe OpenGLScene.  Ensuite, √† chaque rendu d'image, nous essaierons d'√©crire l'image en parall√®le dans le fichier. </p><br><p>  EGL signifie l'interface d'interaction de l'API OpenGL avec le sous-syst√®me de fen√™tre de la plate-forme, nous allons voler le travail avec elle de grafika.  Je ne d√©crirai pas non plus directement le convoyeur (EncoderHelper) avec MediaCodec, je ne donnerai que le sch√©ma final d'interaction entre nos composants: </p><br><p>  <a href="" rel="nofollow">EncoderMachine.kt</a> <br>  <a href="" rel="nofollow">EncoderHelper.kt</a> </p><br><p><img src="https://habrastorage.org/webt/d1/gc/kf/d1gckfqligsrwynmmkq_bb2yzoy.png"></p><br><h2 id="itog">  Le r√©sultat: </h2><br><ul><li>  Travailler avec la vid√©o n√©cessite au moins des comp√©tences de base en OpenGL </li><li>  L'API Android Media est assez bas niveau, ce qui donne de la flexibilit√©, mais parfois elle vous oblige √† √©crire un peu plus de code que vous ne le souhaiteriez </li><li>  Les API asynchrones peuvent √™tre encapsul√©es dans StateMachines </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480878/">https://habr.com/ru/post/fr480878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480866/index.html">Une nouvelle √®re de d√©veloppement web ou ¬´tout est d√©j√† l√†¬ª</a></li>
<li><a href="../fr480870/index.html">R√©sultats de la d√©cennie</a></li>
<li><a href="../fr480872/index.html">Intel a ferm√© une faille de s√©curit√© signal√©e il y a six mois</a></li>
<li><a href="../fr480874/index.html">L'√©tude des neutrinos a conduit √† une d√©couverte inattendue en math√©matiques</a></li>
<li><a href="../fr480876/index.html">Nous nettoyons le Dock et faisons l'application sans xCode</a></li>
<li><a href="../fr480884/index.html">Interface graphique Python en 5 minutes</a></li>
<li><a href="../fr480886/index.html">R√©seaux de neurones et nombre d'or: deuxi√®me s√©rie</a></li>
<li><a href="../fr480888/index.html">Coroutines de bricolage. Partie 1. G√©n√©rateurs paresseux</a></li>
<li><a href="../fr480890/index.html">R√©sultats de l'enqu√™te sur l'utilisation du panneau Express</a></li>
<li><a href="../fr480892/index.html">Internet en montgolfi√®re</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>