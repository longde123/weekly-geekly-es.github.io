<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèø üö∂üèø ‚úäüèª Arc ist ein Versionskontrollsystem f√ºr ein Monorepository. Yandex-Bericht ‚ÑπÔ∏è üåø üíà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Versionskontrollsysteme sind f√ºr Entwickler seit langem ein t√§gliches Werkzeug. In gro√üen Monorepositories sind die Anforderungen sehr spezifisch. Aus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arc ist ein Versionskontrollsystem f√ºr ein Monorepository. Yandex-Bericht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/482926/"> Versionskontrollsysteme sind f√ºr Entwickler seit langem ein t√§gliches Werkzeug.  In gro√üen Monorepositories sind die Anforderungen sehr spezifisch.  Aus diesem Grund passen Unternehmen entweder vorhandene L√∂sungen an, wie es Facebook mit Mercurial und Microsoft mit Git tut, oder entwickeln ihre eigenen Systeme: Piper und CitC bei Google und Arc VCS bei Yandex. <br><br>  In dem Bericht erkl√§rt der Entwickler Vladimir Kikhtenko <a href="https://habr.com/ru/users/kikht/" class="user_link">kikht</a> , warum Yandex ein eigenes Versionskontrollsystem ben√∂tigte und wie es funktioniert.  Betrachten Sie es von der Seite eines gew√∂hnlichen Entwicklers: wie Sie auf den Quellcode zugreifen, einen Zweig f√ºr die Entwicklung beiseite legen und die √Ñnderungen in eine gemeinsame Codebasis integrieren.  Wir schauen unter die Haube - wir lernen die interne Darstellung der Daten und deren Anzeige in einem virtuellen Dateisystem mit einer Arbeitskopie.  Wir werden die Schwierigkeiten bei der Implementierung von VCS-Funktionen in einem virtuellen Dateisystem und beim langsamen Laden von Daten diskutieren.  Lassen Sie uns dar√ºber sprechen, wie die Zuverl√§ssigkeit der Serverinfrastruktur des Repositorys sichergestellt werden kann.  <a href="https://habr.com/ru/company/yandex/blog/482926">Am Ende sehen</a> Sie eine inoffizielle Aufzeichnung des Berichts. <br><br>  - Guten Tag allerseits, mein Name ist Vladimir.  Sie alle haben Reden dar√ºber geh√∂rt, keine Fahrr√§der zu schreiben.  Mein Bericht wird auf der anderen Seite der Barrikade sein. <br><a name="habracut"></a><br>  In der Tat hat Yandex ein Monorepository, in dem sich viel Code befindet.  Und wir sind zu dem Schluss gekommen, dass wir ein eigenes Versionskontrollsystem entwickeln. <br><br><img src="https://habrastorage.org/webt/l3/y8/lq/l3y8lqxua4etd-ukds2vvc5kxkg.jpeg"><br><br>  Wie sind wir zu so einem Leben gekommen?  Historisch gesehen lebte dieses Monorepository bei uns im SVN.  Es √ºbt die stammbasierte Entwicklung aus.  Es gibt keine Niederlassungen mit sehr wenigen Ausnahmen.  Der gesamte Code muss zuerst in den Kofferraum gelangen und dann voll werden. <br><br>  Mit dem Wachstum des Repositorys war die einzige M√∂glichkeit, damit zu arbeiten, das selektive Auschecken, da es in SVN unterst√ºtzt wird.  Es ist nicht ganz unm√∂glich, das gesamte Repository auf sich selbst hochzuladen, aber es ist sehr schwierig, damit zu arbeiten. <br><br><img src="https://habrastorage.org/webt/rw/i0/wa/rwi0wambw-yjb_ahmiwoytmvytk.jpeg"><br><br>  Wie gro√ü ist unser Problem?  Hier einige Zahlen: 6 Millionen Commits, fast 2 Millionen Einzeldateien.  Die Gesamtgr√∂√üe mit dem gesamten Verlauf des Repository betr√§gt 2 TB.  Um zu verdeutlichen, was diese Zahlen im Vergleich zu anderen typischen Repositorys bedeuten, sehen Sie hier ein Diagramm.  GitHub-Median ist die Median-Repository-Gr√∂√üe von GitHub, 1 MB.  Das 90. Perzentil bei GitHub wurde von meinen Kollegen als "Aufbewahrungsort des Sohnes meiner Mutter" bezeichnet.  Und alles andere sind die ber√ºhmten gro√üen Aufbewahrungsorte. <br><br><img src="https://habrastorage.org/webt/sb/dd/ek/sbddeks2vvyhyzwwmwsotp-etne.jpeg"><br><br>  Soweit ich wei√ü, befindet sich das gr√∂√üte Repository der Welt bei Google.  Eine Sch√§tzung der Gr√∂√üe geht aus einem Artikel aus dem Jahr 2015 hervor - wahrscheinlich sind sie seitdem gewachsen.  Wie Sie sehen, ist die Skala logarithmisch.  Es ist zu sehen, dass wir auch ziemlich gro√ü sind. <br><br>  Wie funktionieren verschiedene Versionskontrollsysteme, wenn versucht wird, das gesamte Repository herunterzuladen?  Nat√ºrlich haben wir nicht sofort mit der Entwicklung unseres Versionskontrollsystems begonnen.  Wir haben versucht, unser Repository auf verschiedene Systeme umzustellen.  Der schwerste Versuch wurde mit Mercurial gemacht.  Und die Ergebnisse der Zeit von typischen Operationen passen noch nicht zu uns. <br><br><img src="https://habrastorage.org/webt/xu/ww/bz/xuwwbztsv7_qyoptjukm2pu3nay.jpeg"><br><br>  W√§hrend der Erstellung des Berichts konnte git-svn leider nicht unser gesamtes Repository konvertieren.  Einige Teile einer kleinen Anzahl von Commits wurden konvertiert, sodass ich nicht absch√§tzen kann, wie viele Operationen im Zusammenhang mit der Historie funktionieren.  In einem Segment sind sie schnell und wie es f√ºr 6 Millionen Commits sein wird, ist nicht sehr klar. <br><br>  Am Ende stehen die Nummern f√ºr unser Versionskontrollsystem.  Sie k√∂nnen sich sofort eine Arbeitskopie besorgen.  Beim ersten Start werden die Protokolloperationen etwas verlangsamt, beim zweiten Start funktioniert alles schnell. <br><br>  Und die letzte Ziffer.  Da unser Versionskontrollsystem alle Daten tr√§ge l√§dt, befinden sich nur die Quellcodes auf der Festplatte, die wir wirklich ausgearbeitet haben und die wir wirklich verwendet haben.  Dies ist bedeutend weniger als das Herunterladen des Ganzen. <br><br><img src="https://habrastorage.org/webt/ig/8e/oh/ig8eohthc8a_mfyfyiaxjslhrka.jpeg"><br><br>  Wie haben wir das erreicht?  Das Hauptmerkmal: Die von uns erstellte Arbeitskopie ist keine echte Datei auf der Festplatte.  Dies ist ein virtuelles Dateisystem.  Unter Linux und Mac erfolgt dies mit fuse, unter Windows mit ProjFS.  Wir laden alle Daten tr√§ge, damit so viel Speicherplatz verbraucht wird, wie wir wirklich brauchen. Wir versuchen nicht, alles im Voraus zu laden.  Und wir f√ºhren alle Arten von schweren Operationen auf dem Server aus.  Insbesondere - der Betrieb des Protokolls und einige mehr. <br><br><img src="https://habrastorage.org/webt/ig/jg/jw/igjgjww9nzy70irbsg-svup6_vi.jpeg"><br><br>  Die Oberfl√§che unseres Versionskontrollsystems wiederholt im Gro√üen und Ganzen Git, sodass ich nicht zeigen kann, wie ein typischer Workflow aussieht.  Stell dir Git vor.  Alles ist gleich: Checkout, um die gew√ºnschte Revision zu erhalten, Branch, um Branches zu erstellen, Commit f√ºr Commits, Stash wird auf die gleiche Weise unterst√ºtzt.  Was gibt dieser Ansatz?  Wir senken die Eintrittsschwelle deutlich.  Die meisten Entwickler innerhalb und au√üerhalb von Yandex k√∂nnen mit Git arbeiten.  Sie m√ºssen nichts Neues lernen. <br><br>  Auf der anderen Seite haben wir kein Ziel, Git zu ersetzen.  Ich werde sp√§ter genauer darauf eingehen.  Die ganze Vielfalt der Git-Teams zu unterst√ºtzen, scheint verr√ºckt, wir brauchen sie kaum alle. <br><br><img src="https://habrastorage.org/webt/u2/fh/ke/u2fhkejztyav2rfuwrcsvmwmzv4.jpeg"><br><br>  Ich erz√§hle Ihnen ein wenig √ºber das Innere, dar√ºber, wie alles funktioniert.  Beginnen wir mit dem Datenmodell.  Unser Datenmodell ist dem geografischen mit einigen Unterschieden sehr √§hnlich.  Ebenso sind alle Objekte, die wir in uns erstellen, unver√§nderlich, werden durch einen Hash ihres Inhalts angesprochen und in flachen Puffern gespeichert. <br><br><img src="https://habrastorage.org/webt/0y/xn/5f/0yxn5fgiyjkgkuatsacat0igx44.jpeg"><br><br>  Wie sieht die Struktur aus?  Es gibt Festschreibungsobjekte. Jede Festschreibung hat einen eigenen oder mehrere Vorfahren.  Und auf diese Weise bauen sie einige DAG-Geschichten (Directed Acyclic Graph) auf. <br><br><img src="https://habrastorage.org/webt/vj/gq/ai/vjgqaiudbezdynjexr6ys2qnh30.jpeg"><br><br>  Was wir haben und was nicht sofort in Git auftauchte, sind die Generationsnummern.  Mit einem einfachen Algorithmus betrachten wir einen bestimmten Abstand von der Wurzel des Baumes.  Warum brauchen wir das?  Dies ist alles in die Struktur von Objekten eingen√§ht, einmal fixiert und √§ndert sich nie wieder. <br><br>  Eine ziemlich wichtige Operation f√ºr ein Versionskontrollsystem ist das Finden des kleinsten gemeinsamen Vorfahren f√ºr die beiden Festschreibungen.  In der Basisversion kann es einfach implementiert werden, indem man von zwei Punkten ausgehend in der Breite herumgeht und alle dort erreichten Commits mit dem einen oder anderen Zeichen markiert. Sobald ein Commit gefunden wird, das beide Zeichen enth√§lt, gibt es den am wenigsten verbreiteten Vorfahren. <br><br>  Wie wird dies in einer naiven Implementierung funktionieren?  Etwas in der Art: Gehen Sie herum und finden Sie unser gew√ºnschtes Commit. <br><br><img src="https://habrastorage.org/webt/_k/ua/ra/_kuarauekfozlpunbtufesyaxem.gif"><br><br>  Das Problem ist mit B, was √ºberfl√ºssig ist.  Es scheint, dass wir nicht darauf eingehen konnten, aber wir haben es uns angesehen.  Und je mehr wir den Unterschied zwischen einem Zweig und einem Stamm anhand eines Beispiels feststellen, desto mehr solcher zus√§tzlichen Commits werden wir finden.  Bei einem Monorepository kann dieser Abstand sehr gro√ü sein, wenn die Anzahl der Festschreibungen f√ºr einen Trunk hoch genug ist.  Und es wird Zehntausende solcher zus√§tzlichen Verpflichtungen geben. <br><br><img src="https://habrastorage.org/webt/ls/qe/ko/lsqekoyn9trz8dxsqejf8tfkvdy.jpeg"><br><br><img src="https://habrastorage.org/webt/b2/_i/ld/b2_ild3rkleepwd-w2gwvnoegak.gif"><br><br>  Wenn es Generationsnummern gibt, k√∂nnen wir die Priorit√§tswarteschlange beim Crawlen verwenden, und das Crawlen sieht ungef√§hr so ‚Äã‚Äãaus: einmal - und findet sofort, was Sie brauchen. <br><br><img src="https://habrastorage.org/webt/xq/dy/hx/xqdyhxj1w29lm5r0j_xdftsmg8y.jpeg"><br><br>  Dies ist ein Beispiel f√ºr den Unterschied zwischen unserem Modell.  In Git wurde dieses Ding zuvor unterst√ºtzt. Sie verwendeten Zeitstempel f√ºr die Generierungsnummern. Dies funktioniert jedoch nur, wenn die Zeiten f√ºr das Erstellen von Commits mit dem Commit-Diagramm √ºbereinstimmen. <br><br><img src="https://habrastorage.org/webt/l2/nz/ob/l2nzobltj8dcwjfefjrp_dpea68.jpeg"><br><br>  Leider ist dies in unserer Repository-Historie nicht der Fall.  Es gibt Commits, die aus der Migration eines anderen Repositorys resultieren, und die Zeit beginnt, in ihnen r√ºckw√§rts zu vergehen.  In Git wurde dieses Ding irgendwann unterst√ºtzt, aber es ist dort nicht immer anwendbar, weil Sie in Git das Festschreibungsobjekt lokal durch ein anderes ersetzen k√∂nnen.  Die Immunit√§t des Modells leidet darunter, daher sind diejenigen Generationsnummern, die nicht aufzeichnen, manchmal nicht auf das anwendbar, was in ihnen geschrieben steht, dies ist nicht wahr.  Wir haben kein solches Problem. <br><br>  Ein weiteres Plus dieser Optimierung ist, dass sie vollst√§ndig lokal ist.  Um diese Zahlen zu verwenden, muss nicht das gesamte Festschreibungsdiagramm vorhanden sein.  Und normalerweise haben wir es √ºberhaupt nicht, bei uns wird es faul geladen.  Je weniger wir faul laden, desto besser leben wir. <br><br>  Abgesehen von Commits ist das Modell Git sehr √§hnlich.  Jedes Commit verweist auf ein bestimmtes Baumobjekt, der Baum besteht aus Datens√§tzen, jeder Datensatz ist entweder ein anderer Baum, und so wird die Verzeichnishierarchie in uns angezeigt, oder dies ist ein Blob, eine Datei.  Au√üerdem haben wir so etwas wie BlobRef. Wenn die Datei sehr gro√ü ist, teilen wir sie in St√ºcke und pr√§sentieren sie in einem speziellen Objekt.  Das ist alles, wie in Git. <br><br><img src="https://habrastorage.org/webt/zx/ma/yb/zxmaybpia7hh2rnjgzledt6ikg8.jpeg"><br><br>  Was wir in Git nicht m√∂gen  Wir nennen dieses Ding copy-info.  Wenn die Datei in einer Art Commit kopiert wurde, speichert Git diese Informationen in keiner Weise und versucht, sie mit Heuristiken wiederherzustellen, wenn Unterschiede und Status angezeigt werden.  Wir speichern diese Informationen in der Grafik.  Datens√§tze verf√ºgen m√∂glicherweise √ºber einen Link mit Kopierinformationen zu einem anderen Commit, zu dem Pfad im Repository in diesem Commit, √ºber den bekannt ist, dass diese Datei in diesem Commit kopiert wurde. <br><br>  Es gibt auch eine Deduplizierung, da dieser Blob nebenbei einmal gespeichert wird.  Die Deduplizierung ist jedoch gleich, da sich der Inhalt der Datei nicht ge√§ndert hat und die Deduplizierung durch Hash erfolgt w√§re. <br><br>  Wie sind die Backends angeordnet?  Wenn Git √ºber ein verteiltes Versionskontrollsystem verf√ºgt, werden keine Backends ben√∂tigt.  Wir sp√ºren das besonders deutlich, wenn GitHub nicht verf√ºgbar ist.  Wir verstehen klar, dass Git keine Backends ben√∂tigt.  Unser System ist Client-Server, es speichert alle Daten auf dem Server, und die Serververf√ºgbarkeit ist erforderlich, um die Objekte herunterzuladen, die noch nicht auf dem Client vorhanden sind. <br><br><img src="https://habrastorage.org/webt/tn/ra/uz/tnrauzebvya5hi9zuvdjsorttxe.jpeg"><br><br>  Alle Daten, die wir in der Yandex-Datenbank speichern.  Dies ist eine sehr coole Datenbank, die der Transaktion das notwendige Ma√ü an Zuverl√§ssigkeit bietet.  Es hat alles, was wir brauchen, und dieses Ding hat uns vor vielen Problemen bewahrt. <br><br>  Dank dessen sind die Backends selbst v√∂llig zustandslos, der gesamte Status befindet sich in der Datenbank, und die Backends k√∂nnen sehr einfach beliebig skaliert werden. <br><br>  Und f√ºr die Interaktion mit Kunden, die von interserver verwendet werden, gab es heute einen detaillierten Bericht dar√ºber. <br><br><img src="https://habrastorage.org/webt/ce/xh/at/cexhatxlfxthnfdofvi1wedwexq.jpeg"><br><br>  Wie ist unser System in SVN integriert?  Das SVN-Repository lebt weiter.  Dar√ºber hinaus ist unser Versionskontrollsystem noch nicht autark.  Wie arbeitet sie in diesem Teil?  Zun√§chst gibt es eine Converter-Komponente, die den Status des SVN-Repositorys √ºberwacht und SVN-Commits in Arc-Commits umwandelt - unser Versionskontrollsystem. <br><br>  Als N√§chstes gibt es einen Client, der eine Arbeitskopie bereitstellt und Daten vom Server abruft.  Wenn ein Entwickler etwas festschreibt, wird es zuerst an den Arc-Server gesendet. Damit diese √Ñnderungen jedoch in den Trunk, unseren Hauptzweig, gelangen, m√ºssen sie das Pool-Anforderungs- und das Code-√úberpr√ºfungssystem durchlaufen.  Hier kommt ein weiterer Dienst, der die Verzweigungen von Arc √ºberwacht und bei Aktualisierung eine Poolanforderung an unsere Systemcode√ºberpr√ºfung sendet.  Als n√§chstes wird das Code√ºberpr√ºfungssystem, wenn entschieden wird, dass dieser Patch zusammengef√ºhrt werden muss, an SVN √ºbergeben.  Nicht ganz einfach: Es f√ºgt dort eine bestimmte Menge von Metadaten hinzu, dass es sich bei diesem Commit tats√§chlich um eine Zusammenf√ºhrung eines solchen und eines solchen Zweigs von Arc handelt.  Und dann sieht dieses Commit den Konverter bereits, findet diese Metadaten darin und erstellt ein Commit auf dem Arc-Server.  Dies ist der Zyklus von Commits.  Daher k√∂nnen wir zwar nicht ohne SVN leben, weil wir Trunk in SVN haben. <br><br>  Der Hauptzweig wird st√§ndig mit unserem Server synchronisiert, es ist jedoch nicht zul√§ssig, eine direkte Bindung zu ihm herzustellen. <br><br><img src="https://habrastorage.org/webt/gi/a0/-1/gia0-1aqpsq2bt3xsikjhilcr2g.jpeg"><br><br>  √úber die Zuverl√§ssigkeit von Backends.  Nat√ºrlich planen wir, dass alle Yandex-Entwickler dieses Ding verwenden, deshalb ist es f√ºr uns wichtig, dass es nicht kaputt geht.  Dies ist ein solcher Intra-Index-Standard: Unsere Services m√ºssen den Ausfall eines Rechenzentrums √ºberstehen.  Versionskontrollsystem ist keine Ausnahme.  Hier spart uns die Tatsache sehr, dass YDB dies unterst√ºtzt.  Und unsere Backends sind zustandslos, da verschiedene Teile leicht unterschiedlich implementiert sind.  Server, die auf Arc-Objekten ausgef√ºhrt werden, werden auf Zweigen ausgef√ºhrt. Sie sind zustandslos und werden repliziert.  Konverter, die st√§ndig von SVN konvertieren, werden nach dem Aktiv-Aktiv-Schema repliziert.  Es arbeiten mehrere Konverter gleichzeitig, sie konvertieren zur gleichen Zeit, und sobald sie versuchen, den Arc-Zweig zu aktualisieren, l√∂sen sie Konflikte.  Einer war erfolgreich, der andere scheiterte.  Er versucht etwas weiter zu konvertieren. <br><br>  Der Poolanforderungsdienst wird von Master-Slave repliziert.  Es gibt eine Hauptfunktion.  Wenn dies fehlschl√§gt, wird √ºber YDB ein neuer ausgew√§hlt.  Es gibt so wunderbare Dinge wie Semaphore, die ernsthafte Garantien f√ºr Zug√§nglichkeit und Zuverl√§ssigkeit bieten.  Zugriffe auf Semaphore werden vollst√§ndig serialisiert.  Wir verwenden Semaphore sowohl f√ºr den Pool Request Discovery Service als auch f√ºr die Auswahl von Leadern. <br><br>  Ein wenig dar√ºber, wie der Kunde arbeitet.  Dies ist der schwierigste Teil unseres Versionskontrollsystems, da es ein virtuelles Dateisystem gibt.  Tats√§chlich sind wir gezwungen, alle Operationen an Dateien selbst durchzuf√ºhren.  Ich gehe einige grundlegende Operationen durch und beschreibe grob an den Fingern, was in ihnen passiert, wenn wir sie ausf√ºhren. <br><br><img src="https://habrastorage.org/webt/is/sg/5l/issg5lt5g8ozy9hfmjalxuhhbig.jpeg"><br><br>  Zum Beispiel haben wir eine Datei zur Aufnahme ge√∂ffnet.  Wenn wir die Datei zum Schreiben √∂ffnen, finden wir den entsprechenden Blob unseres Objektmodells.  Laden Sie bei Bedarf etwas vom Server hoch.  Wenn wir eine Datei physisch in einem speziellen Speicher erstellen, werden alle weiteren Anforderungen, die an diese Datei gesendet werden, dort weitergeleitet.  Bis die lokalisierten √Ñnderungen festgeschrieben sind (in Git wird dies als nicht bereit gestellt bezeichnet), gelangen sie in den tempor√§ren Speicher.  Wir nennen solche Dateien materialisiert. <br><br><img src="https://habrastorage.org/webt/wi/ig/ar/wiigarboe1byzw6g2dm1tpj3mda.jpeg"><br><br>  Wenn wir die Datei zum Lesen √∂ffnen, k√∂nnen wir nichts materialisieren, sondern einfach Daten direkt aus unserem Blob geben. <br><br><img src="https://habrastorage.org/webt/kt/4w/qg/kt4wqgxgb6p155jfrcsmej5kxek.jpeg"><br><br>  In diesem Moment f√ºgen wir die Datei dem Index hinzu.  An diesem Punkt m√ºssen Sie sehen, ob wir etwas materialisiert haben.  Gibt es eine Datei, die ge√§ndert wurde.  Wenn dies der Fall ist, erstellen Sie einen Blob und speichern Sie ihn im Index. <br><br><img src="https://habrastorage.org/webt/-d/qj/lx/-dqjlxli2tamjacrjl2aus-iinu.jpeg"><br><br>  Die n√§chste Operation ist der Lichtbogenstatus.  Es ist interessant, weil es in herk√∂mmlichen Versionskontrollsystemen bei solchen Gr√∂√üen langsam ist, weil es den gesamten Dateibaum durchlaufen muss.  Wir m√ºssen nicht den gesamten Dateibaum durchsuchen, da alle Anfragen zum √Ñndern von Dateien √ºber unseren Sicherungstreiber erfolgen und wir sofort wissen, welche Dateien es wert sind, auf √Ñnderungen √ºberpr√ºft zu werden.  Wir √ºberpr√ºfen, was wir in den Index geschrieben haben, und drucken die Antwort aus. <br><br><img src="https://habrastorage.org/webt/wa/7f/0e/wa7f0emrhfllexxyj8asf0kplso.jpeg"><br><br>  Zeit festschreiben.  Alles scheint klar zu sein.  Es gibt einen Index, f√ºr diese Objekte haben wir bereits Blobs erstellt, Baumobjekte, die diesem Status entsprechen, erstellen ein neues Festschreibungsobjekt und schreiben es in den Objektspeicher. <br><br><img src="https://habrastorage.org/webt/eb/p4/uj/ebp4ujcdu2jg9vk18vnsgg9by9o.jpeg"><br><br>  Als n√§chstes wechseln wir die Arbeitskopie zum neuen Commit.  Dies ist eine knifflige Operation, die mit dem Befehl checkout ausgef√ºhrt werden kann.  Und hier k√∂nnte man meinen, dass all unsere lokalen √Ñnderungen bereits eingetreten zu sein scheinen. Wir k√∂nnen davon ausgehen, dass wir dann Dateien zur√ºckgeben sollten, die nicht durch neue Commits zustande gekommen sind.  Und alle.  Alle nachfolgenden Operationen werden einfach an einen anderen Baum und Blobs gesendet. <br><br><img src="https://habrastorage.org/webt/ne/qa/cu/neqacudmw91qauhiaoonre_49zm.jpeg"><br><br>  Warum k√∂nnte das nicht funktionieren?  Die erste Version war dar√ºber.  Das Problem liegt in allerlei kniffligen Vorg√§ngen wie Arc Reset - Soft.  Sie schalten uns einen Baumschalter, materialisieren aber keine Dateien.  Sie existieren weiterhin an einem heiligen Ort.  Wir haben auch nicht verfolgte und ignorierte Dateien, die ebenfalls auf besondere Weise verarbeitet werden m√ºssen.  An dieser Stelle haben wir eine Menge Rakes gesammelt und sind schlie√ülich zu dem Schluss gekommen, dass wir beim Auschecken noch einen Baum (jetzt eine Arbeitskopie) nehmen m√ºssen, den Baum des Commits, zu dem wir wechseln, nehmen den Index und ordentlich abschneiden m√ºssen Warte einen Moment. <br><br>  In Bezug auf die Komplexit√§t der Algorithmen haben wir hier nichts verloren: Alle diese B√§ume lokaler √Ñnderungen sind proportional zu den √Ñnderungen, die wir vorgenommen haben.  Daher sollten wir mit diesen Vorg√§ngen nicht das gesamte Repository durchgehen, sie funktionieren immer noch ziemlich schnell. <br><br>  Gleichzeitig machen wir etwas Magie, damit die Zeitstempel, die wir Dateien geben, mehr oder weniger korrekt sind.  Wenn wir nur Dateien im Dateisystem speichern, wird dies √ºberwacht und die Zeit l√§uft immer weiter.  Hier m√ºssen wir uns irgendwie merken, welche Datei der Benutzer zu welchem ‚Äã‚ÄãZeitpunkt gesehen hat.  Und wenn er zu einem fr√ºheren Commit gewechselt ist, geben Sie ihm keine fr√ºhere Zeit.  Da Assembly-Systeme, f√ºr die nicht alle IDEs bereit sind, eine Menge Dinge wegnehmen. <br><br><img src="https://habrastorage.org/webt/r7/h7/fd/r7h7fdedl8-aip9z49ovoeb3zci.jpeg"><br><br>  In unserem Versionskontrollsystem ist die Unterst√ºtzung f√ºr die stammbasierte Entwicklung auf den Punkt gebracht.  Erstens, was ich bereits gesagt habe: Alle √Ñnderungen durchlaufen die Poolanforderungen und den Trunk.  Es gibt noch ein paar Punkte.  Wir haben keine Unterst√ºtzung f√ºr Gruppenzweige.  In Arc erstellte Verzweigungen sind an einen bestimmten Benutzer gebunden, und nur dieser kann sie festschreiben.  Dies erm√∂glicht es uns, langlebige Zweige zu vermeiden.  In SVN war dies nicht besonders, da es dort unpraktisch ist, Zweige zu machen.  Und es ist bequem, sie in Arc zu erstellen. Wenn dies nicht kontrolliert wird, haben wir Angst, dass einige Teile unseres Mono-Repositorys in ihre Filialen abwandern und dort ihre Entwicklung durchf√ºhren.  Dies widerspricht dem Modell, das wir machen wollen. <br><br><img src="https://habrastorage.org/webt/uq/9a/bv/uq9abvkh2dunwxijq1vpuqefh7a.jpeg"><br><br>  Zweitens haben wir keinen Befehl zum Zusammenf√ºhren.  Alle Zusammenschl√ºsse von Zweigniederlassungen erfolgen unter unserer strengen Kontrolle.  Wir entwickeln jetzt Filialen f√ºr Releases, in denen es auch m√∂glich sein wird, zu fusionieren.  Dies wird h√∂chstwahrscheinlich auch nicht von einem Benutzerteam, sondern von einer Servermaschine durchgef√ºhrt. <br><br><img src="https://habrastorage.org/webt/qa/dk/yl/qadkylvgcbgyx8lwuvc3n93ix7e.jpeg"><br><br>  Was haben wir vor?  20% der Monorepository-Entwickler verwenden bereits unser Versionskontrollsystem.  Wir sind bereits aus einem infantilen Zustand hervorgegangen, dies ist ein ernsthaft genutztes System, es ist einfach unm√∂glich, es einfach so hinauszuwerfen.  Das ultimative Ziel ist es, das Hauptversionskontrollsystem in Yandex zu werden.  Wir m√ºssen die verbleibenden 80% der Entwickler irgendwie davon √ºberzeugen, dass wir ziemlich stabil, zuverl√§ssig und brauchbar sind.  Es ist klar, dass Sie daf√ºr alle Fehler beheben und die Funktionen in Git beenden m√ºssen. <br><br>  In gewisser Hinsicht planen wir nat√ºrlich, autark zu werden, den Konverter aufzugeben oder in die entgegengesetzte Richtung zu implementieren, sodass zun√§chst alle √Ñnderungen an Arc und dann an SVN f√ºr die best√§ndigsten Programmierer vorgenommen werden. <br><br>  Jetzt haben wir eine gro√üe Herausforderung - die Integration des Versionskontrollsystems in unsere Auto-Assemblierung, in unser CI und in andere Pipelines.  Die Herausforderung besteht darin, dass die Leute einen schwachen Geist haben, langsam Code tippen und langsam Commit ausf√ºhren.  Und sie laden sich den Code zu langsam herunter.  Und Robotern wird dieser Nachteil vorenthalten. <br><br>    ‚Äî    ,   CI        Arc, - .         ,       .     .      ,      ++-  ,  ,      .     . <br><br>   .      ¬´  Git¬ª.       :   Git.      ,   ,     . <br><br>   .  Git  .      ,       .     -  .       ,        checkout  reset,       .   ,     ,       .   :    Git. ¬´    ,   ¬ª.  Git   . <br><br>        .       Git,  git begin-wave-stash? <br><br>  : <br> ‚Äî  . <br><br> ‚Äî   ,  Git    ?     ‚Äî         ,   ,      ,   .  ,     .  Git   .         ,      .  Vielen Dank. <br><br><a name="video"></a><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/PQWdvuo6Gzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482926/">https://habr.com/ru/post/de482926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482908/index.html">Der zweite Teil der √úbersetzung von David Kouchners Buch Masters of Doom. Kapitel 6-12</a></li>
<li><a href="../de482912/index.html">Die Idee eines dezentralen sozialen Netzwerks der n√§chsten Generation</a></li>
<li><a href="../de482918/index.html">Speichern von Daten in einem EEPROM auf einem Arduino transaktional</a></li>
<li><a href="../de482920/index.html">Wie der Autopilot in unser Leben gefahren ist, haben wir aber nicht bemerkt</a></li>
<li><a href="../de482922/index.html">Drupal Digest - 2019 / Dezember</a></li>
<li><a href="../de482928/index.html">Predator Vision: W√§rmebildeffekt</a></li>
<li><a href="../de482930/index.html">Genealogische Forschung - metrische B√ºcher, Volksz√§hlungen, Archive, offene Datenbanken</a></li>
<li><a href="../de482934/index.html">Scheitern des ERP-Projekts (Liqui Moly, Otto und andere wie er)</a></li>
<li><a href="../de482936/index.html">Einf√ºhrung in ASGI: Aufbau eines asynchronen Python-Web-√ñkosystems</a></li>
<li><a href="../de482938/index.html">Anwendung der Prinzipien der funktionalen Programmierung bei der Gestaltung von ERP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>