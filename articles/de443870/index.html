<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèΩ üë®üèæ‚Äçüöí üì∞ Einheit: Prozedurale Netzbearbeitung üéπ ‚úâÔ∏è üë®‚Äçüë©‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Konvertieren von Modellen im laufenden Betrieb ist eine g√§ngige Praxis bei der Simulation der Physik von Deformationen sowie bei Spielen mit dynam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einheit: Prozedurale Netzbearbeitung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/443870/"> Das Konvertieren von Modellen im laufenden Betrieb ist eine g√§ngige Praxis bei der Simulation der Physik von Deformationen sowie bei Spielen mit dynamisch generierten und modifizierbaren Inhalten.  In solchen F√§llen ist es zweckm√§√üig, Methoden zum prozeduralen Bearbeiten und Erstellen von Geometrie anzuwenden.  Letztere erm√∂glichen h√§ufig das Speichern wertvoller Bytes beim √úbertragen von aus dem Netzwerk heruntergeladenen Daten.  Au√üerdem macht es Spa√ü! <br><br>  Der Artikel zielt darauf ab, die F√§higkeiten der prozeduralen Verarbeitung von Netzen in Unity zu verbessern.  Wir werden √ºber die Operationen zum Transformieren und Generieren von Teilen eines Netzes sprechen. <br><br><img src="https://habrastorage.org/webt/if/ur/hv/ifurhvuqkiyhlqceodrpurzxjre.jpeg"><a name="habracut"></a><br><br>  Unser Gentleman-Kit f√ºr die prozedurale Bearbeitung von 3D-Modellen umfasst drei grundlegende Operationen: Triangulation, Bewegung von Punkten, Extrusion.  Wir werden ausf√ºhrlich √ºber die letzten beiden sprechen.  Betrachten Sie zun√§chst die einfachsten Bewegungsoperationen - Verschieben von Scheitelpunkten, Drehen und Skalieren von Kanten und Dreiecken.  Dann werden wir uns mit einer der Methoden zum Erzeugen neuer Geometrie befassen - der Extrudieroperation. <br><br>  <i>In einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Ver√∂ffentlichung haben</a> wir unsere Struktur f√ºr die bequeme Arbeit mit Daten aus 3D-Modellen beschrieben.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Strukturcode</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMeshPool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;CustomMesh&gt; Pool; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CustomMesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Pool[id]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CustomMesh customMesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Pool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CustomMesh&gt;(); pointer = GetAvailableIndex(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pointer &lt; Pool.Count) Pool[pointer] = customMesh; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Pool.Add(customMesh); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pointer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = Pool[index] == <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Pool[index] = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAvailableIndex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> availableIndex = Pool.FindIndex(mesh =&gt; mesh == <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> availableIndex != <span class="hljs-number"><span class="hljs-number">-1</span></span> ? availableIndex : Pool.Count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flush</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Pool.Clear(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Triangle[] Triangles; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3[] vertices; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3[] normals; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2[] uv0, uv2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3[] vertices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triangles, Vector3[] normals, Vector2[] uv0, Vector2[] uv2, Color[] colors</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vertices = vertices; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals = normals; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals[i] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals[i].normalized; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uv0 = uv0; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uv2 = uv2; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.colors = colors; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = CustomMeshPool.GetAvailableIndex(); CustomMeshPool.Push(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Id = ptr; Triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle[triangles.Length / <span class="hljs-number"><span class="hljs-number">3</span></span>]; Triangles = Triangles .AsParallel() .Select((t, i) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle(ptr, i, triangles[i * <span class="hljs-number"><span class="hljs-number">3</span></span>], triangles[i * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>], triangles[i * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>])) .ToArray(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Triangle { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _index; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _index; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _index = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_edges != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].TriangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; _edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].TriangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; _edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].TriangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _meshId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MeshId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _meshId; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _meshId = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Edge[] _edges; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Edge[] Edges { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _edges; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Length == <span class="hljs-number"><span class="hljs-number">3</span></span>) { _edges = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { _edges[i].TriangleIndex = _index; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IndexOutOfRangeException(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex V0 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.MeshId != MeshId) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Not the same mesh"</span></span>); Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex V1 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.MeshId != MeshId) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Not the same mesh"</span></span>); Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex V2 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.MeshId != MeshId) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Not the same mesh"</span></span>); Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meshId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2</span></span></span><span class="hljs-function">)</span></span> { _index = index; _meshId = meshId; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edges = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge[<span class="hljs-number"><span class="hljs-number">3</span></span>]; edges[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge(meshId, index, v0, v1); edges[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge(meshId, index, v1, v2); edges[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge(meshId, index, v2, v0); _edges = edges; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex v0; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex v1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _meshId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MeshId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _meshId; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _meshId = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _triangleIndex; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TriangleIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _triangleIndex; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _triangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Edge</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meshId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> triangleIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v0Index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1Index</span></span></span><span class="hljs-function">)</span></span> { _meshId = meshId; _triangleIndex = triangleIndex; v0 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vertex() { MeshId = meshId, Index = v0Index }; v1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vertex() { MeshId = meshId, Index = v1Index }; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Vertex { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _meshId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MeshId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _meshId; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _meshId = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).vertices[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).vertices[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 normal { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).normals[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).normals[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 uv0 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).uv0[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).uv0[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 uv2 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).uv2[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).uv2[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).colors[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).colors[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre> <br></div></div><br>  <i>Wie Sie sehen k√∂nnen, wird hier PLINQ verwendet.</i>  <i>Dies liegt daran, dass Algorithmen f√ºr die rechnerische Geometrie h√§ufig durch Multithreading optimiert werden k√∂nnen.</i> <i><br></i>  <i>Nat√ºrlich werden w√§hrend der Ausf√ºhrung von LINQ-Konstrukten mehr LINQ-Konstrukte erstellt als bei der Ausf√ºhrung des ‚Äûmanuellen‚Äú Codes.</i>  <i>Dieser Nachteil wird jedoch weitgehend durch die K√ºrze solcher Entw√ºrfe sowie das Vorhandensein integrierter Ressourcenmanagement-Tools in PLINQ ausgeglichen.</i>  <i>Dar√ºber hinaus wird der √úbergang zwischen Single-Threaded- und Multi-Threaded-Implementierungen mit nur einem Befehl ausgef√ºhrt, was den Debugging-Prozess erheblich erleichtert.</i> <br><br><h3>  Ich verdrehe, verdrehe, ich m√∂chte verwirren </h3><br>  Wir fahren mit den Operationen der Bewegung fort.  Das Verschieben von Scheitelpunkten ist nicht kompliziert.  Vergessen Sie nur nicht die zusammenfallenden Spitzen: Bei Bedarf sollte sich auch ihre Position √§ndern. <br><br>  Der Algorithmus wird implementiert, indem der Scheitelpunktposition ein Bewegungsvektor hinzugef√ºgt wird.  Die Verschiebung erfolgt relativ zum Ursprung des Modells ( <b>Pivot</b> ).  Es ist erw√§hnenswert, dass sich die Position von Polygonen w√§hrend solcher Transformationen √§ndern kann, die Normalen ihrer Eckpunkte jedoch nicht.  Um die Darstellung zu vereinfachen, werden wir diese Nuance jedoch nicht ber√ºcksichtigen. <br><br>  <i><b>CAD-Werkzeuge</b> verf√ºgen √ºber eine Funktion zur Neuberechnung von Normalen, die normalerweise nach dem Anwenden der erforderlichen Transformationen aufgerufen wird.</i>  <i>Es gibt verschiedene M√∂glichkeiten, diese Zuordnung vorzunehmen.</i>  <i>Am h√§ufigsten wird die Normale zur Ebene jedes Dreiecks berechnet und dann jedem Scheitelpunkt eine Normale als Durchschnitt der Normalen der Dreiecke zugewiesen, zu denen dieser Scheitelpunkt geh√∂rt.</i> <br><br>  Im Allgemeinen gibt es keinen guten Grund, den Code zu komplizieren und die Transformationsmatrix anzuwenden.  Das Ergebnis des Hinzuf√ºgens eines Bewegungsvektors zur Scheitelpunktposition entspricht einer intuitiven Vorstellung seiner Bewegung. <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/cu/hn/l9/cuhnl9znzfmayguevbhrwr8c2lo.gif"><br></td><td><img src="https://habrastorage.org/webt/o0/st/e0/o0ste0gv_uhldid9h7jgca7a6ua.gif"><br></td></tr></tbody></table><br><div class="spoiler">  <b class="spoiler_title">Auflistungsmethoden zum Verschieben eines Scheitelpunkts</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Vertex { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Translate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 movement, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newPosition = position + movement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask[i]) vertices[i] = newPosition; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position = newPosition; } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVerticesInPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[vertices.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; buffer.Length; i++) { buffer[i] = Mathf.Abs(position.x - vertices[i].x) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.y - vertices[i].y) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.z - vertices[i].z) &lt; Mathf.Epsilon; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer; } }</code> </pre><br></div></div><br>  Die Bewegung von Kanten und Dreiecken wird auf die gleiche Weise implementiert - durch Hinzuf√ºgen eines Verschiebungsvektors. <br><br><div class="spoiler">  <b class="spoiler_title">Es gibt noch Gifs</b> <div class="spoiler_text"><table><tbody><tr><td><img src="https://habrastorage.org/webt/mr/bo/wu/mrbowu8z94mgyhmjop8fawq1nu8.gif"><br></td><td><img src="https://habrastorage.org/webt/2x/6u/cn/2x6ucnuhg9jwftw9lbcc3vbk_ss.gif"><br></td></tr><tr><td><img src="https://habrastorage.org/webt/mf/cx/k5/mfcxk5fm7xq0ifpm03ofn4izurg.gif"><br></td><td><img src="https://habrastorage.org/webt/p8/ot/f-/p8otf-gbjezo3rtn57tf-yvvh9c.gif"><br></td></tr></tbody></table><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Auflistungsmethoden zum Verschieben von Dreiecken und Kanten</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Translate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 movement, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(MeshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = v0.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = v1.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v1.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v0.Translate(movement); v1.Translate(movement); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Triangle { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Translate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 movement, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = V0.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = V1.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV2Position = V2.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V1.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV2 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V2.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV2[i]) vertices[i] = newV2Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { V0.Translate(movement); V1.Translate(movement); V2.Translate(movement); } } }</code> </pre><br></div></div><br>  Es ist jedoch bequemer, mithilfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Transformationsmatrix</a> zu drehen und zu skalieren.  Das Ergebnis der Ausf√ºhrung dieser Operationen in Bezug auf den Ursprung der Modellkoordinaten entspricht h√∂chstwahrscheinlich nicht Ihren Erwartungen oder W√ºnschen.  Der Referenzpunkt f√ºr Rotation und Skalierung wird normalerweise als die Mitte des Objekts verwendet - als der f√ºr den Menschen verst√§ndlichste. <br><br><div class="spoiler">  <b class="spoiler_title">Viele GIFs</b> <div class="spoiler_text"><table><tbody><tr><td><img src="https://habrastorage.org/webt/ct/mo/26/ctmo26dwz_yjk7fshly8l-4q4v4.gif"><br></td><td><img src="https://habrastorage.org/webt/4w/by/ou/4wbyoul70b8-c9_yasiyxxgupqu.gif"><br></td><td><img src="https://habrastorage.org/webt/c_/pl/iy/c_pliy99pbhj8tjbgcdo0vi95i4.gif"><br></td><td><img src="https://habrastorage.org/webt/7g/eb/qa/7gebqanr-htgbvpjo4g1jza9yns.gif"><br></td></tr><tr><td><img src="https://habrastorage.org/webt/mm/fw/0g/mmfw0gazms88c0mslnsah4lynhk.gif"><br></td><td><img src="https://habrastorage.org/webt/nd/cl/a9/ndcla9f1f-lwdd69i-fxndyspg0.gif"><br></td><td><img src="https://habrastorage.org/webt/2c/on/sb/2consbni6vccpanjp80oya-ccow.gif"><br></td><td><img src="https://habrastorage.org/webt/ji/2b/rh/ji2brhm7pb7nrzuqva691l6c7rm.gif"><br></td></tr></tbody></table><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Auflistungsmethoden zum Drehen und Skalieren von Dreiecken und Kanten</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rotate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (v0.position + v1.position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(pivot, rotation, Vector3.one); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(v0.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(v1.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(MeshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v1.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v0.position = newV0Position; v1.position = newV1Position; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (v0.position + v1.position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(pivot, Quaternion.identity, scale); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(v0.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(v1.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(MeshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v1.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v0.position = newV0Position; v1.position = newV1Position; } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Triangle { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rotate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (V0.position + V1.position + V2.position) / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(Vector3.zero, rotation, Vector3.one); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(V0.position - pivot) + pivot; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(V1.position - pivot) + pivot; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV2Position = matrix.MultiplyPoint(V2.position - pivot) + pivot; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V1.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV2 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V2.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV2[i]) vertices[i] = newV2Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.position = newV0Position; Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.position = newV1Position; Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.position = newV2Position; } Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.normal = matrix.MultiplyPoint(V0.normal); Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.normal = matrix.MultiplyPoint(V1.normal); Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.normal = matrix.MultiplyPoint(V2.normal); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (V0.position + V1.position + V2.position) / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(pivot, Quaternion.identity, scale); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(V0.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(V1.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV2Position = matrix.MultiplyPoint(V2.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V1.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV2 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V2.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV2[i]) vertices[i] = newV2Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.position = newV0Position; Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.position = newV1Position; Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.position = newV2Position; } } }</code> </pre><br></div></div><br><h3>  Schw√§rme ein ordentliches Loch f√ºr uns </h3><br>  Bei der 3D-Modellierung wird h√§ufig eine Extrudieroperation verwendet.  F√ºr seine Implementierung m√ºssen der Bewegungsvektor (Verschiebung) und die Menge der Polygone bekannt sein.  Der Extrusionsprozess kann in zwei Schritte zerlegt werden: <br><br>  1. Der Versatz der Polygone um einen bestimmten Bewegungsvektor ( <b>Versatz</b> ).  In diesem Fall m√ºssen die durch Grenzpolygone getrennten Scheitelpunkte dupliziert werden, um die Position der Elemente, die nicht zum verschobenen Teil geh√∂ren, nicht zu st√∂ren.  Mit anderen Worten, Sie m√ºssen das ausgew√§hlte St√ºck zerrei√üen und bewegen.  Wenn dieser Schritt zuerst abgeschlossen ist, wird das Modell wahrscheinlich in Teile zerfallen, die in Zukunft zusammengef√ºgt werden m√ºssen. <br><br><img src="https://habrastorage.org/webt/bb/cn/on/bbcnon5sqdhusvi-qqhqhk05vlu.jpeg"><br><br>  2. Hinzuf√ºgen einer neuen Geometrie zwischen der Grenze des versetzten Teils und der Grenze, die w√§hrend der Extrusion gebildet wurde.  Die L√ºcke zwischen dem Hauptteil und dem verschobenen Teil des Modells ist mit Polygonen gef√ºllt, die eine Wand bilden. <br><br><img src="https://habrastorage.org/webt/rv/nx/ts/rvnxts5zhi2y05xd8ykqftgtniw.png"><br><br>  In der Implementierung ist es bequemer, zuerst die Wand zu bauen, da wir vor der Verschiebung die Anfangsposition der Kanten am Rand haben und diese Daten sofort verwenden k√∂nnen.  Andernfalls m√ºssten Sie entweder die Richtung des Schervektors invertieren oder einige Informationen √ºber den Anfangszustand des Netzes speichern. <br><br>  Das Modell und seine Teile, mit denen wir arbeiten, bestehen aus paarweise benachbarten Polygonen (Dreiecken).  Wir nennen jede solche Menge einen <b>Cluster</b> . <br><br><img src="https://habrastorage.org/webt/7q/y7/6h/7qy76hwucntbje_fcnbw8nznapc.png"><br>  <i>Zwei dedizierte Cluster in <b>Blender</b></i> <i><br></i> <br>  Zuerst m√ºssen wir alle Kanten der Konturen erhalten, die die ausgew√§hlten Cluster begrenzt haben.  F√ºgen Sie dazu einfach die Kanten nacheinander zur Liste hinzu.  Wenn eine passende Kante gefunden wird, muss diese entfernt werden, ohne die aktuelle hinzuzuf√ºgen.  F√ºr den korrekten Betrieb eines solchen Algorithmus muss eine Einschr√§nkung eingef√ºhrt werden: Auf dem ausgew√§hlten Satz von Dreiecken existieren nicht mehr als zwei zusammenfallende Kanten.  In F√§llen, in denen <b>Extrude</b> verwendet wird, erf√ºllen Modelle h√§ufig diese Bedingung, und ein komplexerer Algorithmus erfordert gro√üe Rechenressourcen. <br><br><div class="spoiler">  <b class="spoiler_title">Auflistungsmethoden zum Abrufen von Kanten, die zu Konturen geh√∂ren</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LinkedListExtension</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IEnumerable&lt;LinkedListNode&lt;T&gt;&gt; Nodes&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> LinkedList&lt;T&gt; list) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = list.First; node != <span class="hljs-literal"><span class="hljs-literal">null</span></span>; node = node.Next) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Vertex { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsInPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mathf.Abs(position.x - other.x) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.y - other.y) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.z - other.z) &lt; Mathf.Epsilon; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Coincides</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Edge other, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> includeDirection = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v0.IsInPosition(other.v0.position) &amp;&amp; v1.IsInPosition(other.v1.position) || !includeDirection &amp;&amp; v1.IsInPosition(other.v0.position) &amp;&amp; v0.IsInPosition(other.v1.position); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> LinkedList&lt;Edge&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObtainHullEdges</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triIndices</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edges = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;Edge&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triIndices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edge = edges.Nodes().FirstOrDefault(e =&gt; e.Value.Coincides(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) edges.Remove(edge); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> edges.AddFirst(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>]); edge = edges.Nodes().FirstOrDefault(e =&gt; e.Value.Coincides(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) edges.Remove(edge); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> edges.AddFirst(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>]); edge = edges.Nodes().FirstOrDefault(e =&gt; e.Value.Coincides(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) edges.Remove(edge); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> edges.AddFirst(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> edges; } }</code> </pre><br></div></div><br>  Nachdem Sie alle Kanten der Kontur erhalten haben, m√ºssen Sie die entsprechenden W√§nde erstellen.  Es gibt viele Optionen f√ºr die Implementierung, aber wir haben uns f√ºr den Weg des geringsten Widerstands entschieden - Parallelogramme in Richtung des Bewegungsvektors basierend auf den Kanten separat zu erstellen.  Da wir alle aufgrund dieser Aktion eine Verschiebung haben, bilden die Parallelogramme f√ºr jeden Cluster eine feste und geschlossene Wand.  Es bleibt die Ausrichtung der Wandelemente zu bestimmen. <br><br>  Die Wand besteht wie das gesamte Netz aus Dreiecken.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gem√§√ü der <b>OpenGL-</b> Konvention wird ein</a> abgetrenntes Dreieck auf dem Bildschirm gerendert, wenn beim Projizieren seiner Punkte auf die Bildschirmebene die Umgehung dieser Punkte dem Gehen im Uhrzeigersinn entspricht: <br><br><img src="https://habrastorage.org/webt/5l/a1/um/5la1umkwunfu0krizz83sz40nvs.jpeg"><br><br>  Ein Dreieck entspricht also einem bestimmten Normalenvektor, der die Vorderseite definiert.  Jedes Dreieck wird von einer konvexen Kontur begrenzt, die aus drei Kanten besteht.  Jede Kante hat zwei Eckpunkte, die in unserer Struktur als <b>v0</b> und <b>v1 dargestellt sind</b> .  Wir definieren die Richtung der Kante so, dass <b>v0</b> der Anfang ist, <b>v1</b> das Ende.  Wenn nun die Richtung der Kanten des Dreiecks in √úbereinstimmung mit der Umgehung seiner Eckpunkte festgelegt wird, muss jede Au√üenkontur des Clusters eine Umgehung entweder im oder gegen den Uhrzeigersinn und eine interne Umkehrung haben - umgekehrt.  Wir haben <b>CustomMesh-</b> und <b>Triangle-</b> Konstruktoren implementiert, sodass die Durchquerung der Eckpunkte aller Dreiecke der Richtung im Uhrzeigersinn entspricht. <br><br><img src="https://habrastorage.org/webt/4a/ty/j_/4atyj_c-9-_bpgu3xphnvhgx690.jpeg"><br><br><img src="https://habrastorage.org/webt/6c/yw/so/6cywsooz53z8ytpuyb6y8t1rh7m.jpeg"><br><br>  Mit der Richtung, die Kontur zu umgehen, k√∂nnen wir mit Sicherheit sagen, welche Seite der Rippe der innere Teil der Kontur und welche die √§u√üere ist.  Basierend auf diesen Informationen w√§hlen wir die Ausrichtung der Wand.  Sei ( <b>v0, v1</b> ) die Kante, auf deren Grundlage das gew√ºnschte Parallelogramm erzeugt werden soll.  Wir nehmen die beiden Punkte <b>v2</b> und <b>v3</b> als Versatzpositionen <b>v0</b> und <b>v1</b> .  Dann konstruieren wir zwei Dreiecke nach folgendem Schema: <br><br><img src="https://habrastorage.org/webt/vv/ox/zl/vvoxzlj-mc7mu50fdolvczhdbf0.jpeg"><br><br>  Und so f√ºr jede Kante der Kontur. <br><br><div class="spoiler">  <b class="spoiler_title">Auflisten einer Methode zum Erstellen von W√§nden mithilfe einer Liste von Kanten</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtrudeEdgesSet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Edge[] edges, Vector3 offset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset == Vector3.zero || edges == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || edges.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initVerticesLength = vertices.Length; Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> vertices, initVerticesLength + edges.Length * <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; normals.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> normals, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv0 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv0.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv0, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv2.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv2, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colors != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; colors.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> colors, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initTrianglesLength = Triangles.Length; Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Triangles, initTrianglesLength + edges.Length * <span class="hljs-number"><span class="hljs-number">2</span></span>); edges .AsParallel() .Select((edge, i) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = initVerticesLength + i * <span class="hljs-number"><span class="hljs-number">4</span></span>; vertices[j] = edge.v0.position; vertices[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = edge.v1.position; vertices[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.position + offset; vertices[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.position + offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; normals.Length == vertices.Length) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normal = Vector3.Cross(vertices[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] - vertices[j], offset); normals[j] = normals[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = normals[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = normals[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = normal; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv0 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv0.Length == vertices.Length) { uv0[j] = uv0[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.uv0; uv0[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = uv0[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.uv0; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv2.Length == vertices.Length) { uv2[j] = uv2[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.uv2; uv2[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = uv2[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.uv2; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colors != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; colors.Length == vertices.Length) { colors[j] = colors[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.color; colors[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = colors[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.color; } Triangles[initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle( initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span>, Id, j, j + <span class="hljs-number"><span class="hljs-number">1</span></span>, j + <span class="hljs-number"><span class="hljs-number">2</span></span> ); Triangles[initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle( initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, Id, j + <span class="hljs-number"><span class="hljs-number">3</span></span>, j + <span class="hljs-number"><span class="hljs-number">2</span></span>, j + <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }).ToArray(); } }</code> </pre><br></div></div><br>  Bei diesem Ansatz ist die Vorderseite der erzeugten W√§nde f√ºr die Objekttr√§ger und f√ºr die Gruben korrekt.  Es gibt nur eine wesentliche Einschr√§nkung: Der Satz von Dreiecken, √ºber den die <b>Extrudieroperation ausgef√ºhrt</b> wird, sollte in Bezug auf den Bewegungsvektor nicht um sich selbst gewickelt werden. <br><br><img src="https://habrastorage.org/webt/4w/8v/te/4w8vtezc5p0mprdnzsmcgxk8htq.jpeg"><br>  <i>Eine Teilmenge von Polygonen, die in Bezug auf den Versatz ung√ºltig ist.</i>  <i>Selbst in <b>Blender</b> mit einem solchen Extrudieren k√∂nnen Sie der Geometriekurve nicht entkommen.</i> <br><br><img src="https://habrastorage.org/webt/ki/yh/5q/kiyh5qy9-uz1sqf27f_zls89f00.jpeg"><br>  <i>G√ºltige Teilmengen von Polygonen</i> <br><br>  Die Wand ist fertig, es bleibt, um die Dreiecke zu verschieben.  Dieser Schritt des Algorithmus ist leicht zu verstehen, obwohl sich die Implementierung als umst√§ndlich herausstellte. <br><br>  In unserem Fall m√ºssen wir sicherstellen, dass jeder Scheitelpunkt des Clusters nur zu seinen Dreiecken geh√∂rt.  Wenn die Bedingung nicht erf√ºllt ist, k√∂nnen einige benachbarte Polygone nach dem Cluster greifen.  Die L√∂sung f√ºr diese Situation besteht darin, jeden Scheitelpunkt zu duplizieren, der sowohl zum Cluster als auch zum Rest des Modells geh√∂rt.  Ersetzen Sie dann f√ºr alle Polygone im Cluster den Index dieses Scheitelpunkts durch den doppelten Index.  Wenn die Bedingung erf√ºllt ist, verschieben wir alle Eckpunkte des Clusters zum Bewegungsvektor. <br><br><div class="spoiler">  <b class="spoiler_title">Auflisten einer Methode zum Verschieben eines Polygonclusters</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TranslateTrianglesHard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triIndices, Vector3 offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] hullVerts</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newVertexIndices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initVerticesCount = vertices.Length; Triangles.Where((t, i) =&gt; !triIndices.Contains(i)).Select(t =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hullVerts.Contains(t.V0.Index) &amp;&amp; !newVertexIndices.ContainsKey(t.V0.Index)) newVertexIndices.Add(t.V0.Index, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hullVerts.Contains(t.V1.Index) &amp;&amp; !newVertexIndices.ContainsKey(t.V1.Index)) newVertexIndices.Add(t.V1.Index, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hullVerts.Contains(t.V2.Index) &amp;&amp; !newVertexIndices.ContainsKey(t.V2.Index)) newVertexIndices.Add(t.V2.Index, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }).ToArray(); Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> vertices, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) vertices[pair.Value] = vertices[pair.Key] + offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; normals.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> normals, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) normals[pair.Value] = normals[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv0 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv0.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv0, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) uv0[pair.Value] = uv0[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv2.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv2, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) uv2[pair.Value] = uv2[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colors != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; colors.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> colors, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) colors[pair.Value] = colors[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> alreadyMoved = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triIndices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertexIndices.ContainsKey(Triangles[triIndices[i]].V0.Index)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = newVertexIndices[Triangles[triIndices[i]].V0.Index]; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.Index = index; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v1.Index = index; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!alreadyMoved.Contains(Triangles[triIndices[i]].V0.Index)) { vertices[Triangles[triIndices[i]].V0.Index] += offset; alreadyMoved.Add(Triangles[triIndices[i]].V0.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertexIndices.ContainsKey(Triangles[triIndices[i]].V1.Index)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = newVertexIndices[Triangles[triIndices[i]].V1.Index]; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v1.Index = index; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.Index = index; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!alreadyMoved.Contains(Triangles[triIndices[i]].V1.Index)) { vertices[Triangles[triIndices[i]].V1.Index] += offset; alreadyMoved.Add(Triangles[triIndices[i]].V1.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertexIndices.ContainsKey(Triangles[triIndices[i]].V2.Index)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = newVertexIndices[Triangles[triIndices[i]].V2.Index]; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v1.Index = index; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.Index = index; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!alreadyMoved.Contains(Triangles[triIndices[i]].V2.Index)) { vertices[Triangles[triIndices[i]].V2.Index] += offset; alreadyMoved.Add(Triangles[triIndices[i]].V2.Index); } } } }</code> </pre><br></div></div><br>  Fertig.  Wenn wir nun die Ergebnisse aller Schritte addieren, erhalten wir ein Loch oder einen H√ºgel. <br><br><div class="spoiler">  <b class="spoiler_title">Auflisten der endg√ºltigen Methode f√ºr die Extrudieroperation</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtrudeTriangles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triIndices, Vector3 offset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edges = ObtainHullEdges(triIndices); ExtrudeEdgesSet(edges.ToArray(), offset); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hullVertices = edges.Select(edge =&gt; edge.v0.Index).ToArray(); TranslateTrianglesHard(triIndices, offset, hullVertices); } }</code> </pre><br></div></div><br>  Wenn Sie mit den Koordinaten des Textur-Scans und der Verschiebung der Konturpunkte gespielt haben, k√∂nnen Sie eine solche Aussparung erhalten: <br><br><img src="https://habrastorage.org/webt/bw/at/oe/bwatoexbyvwkfjrztopbegi8uwi.png"><br><br><h3>  Und das ist noch nicht alles </h3><br>  Zus√§tzlich zu den oben beschriebenen Bearbeitungsvorg√§ngen verwenden wir auch andere bequeme Methoden zum Arbeiten mit Modellen. <br><br>  Zum Beispiel haben wir zus√§tzlich die <b>Combine ()</b> -Methode geschrieben, um zwei <b>CustomMesh</b> zu kombinieren.  Der Hauptunterschied zwischen unserer Implementierung und <b>UnityEngine.Mesh.CombineMeshes ()</b> besteht darin, dass, wenn einige Scheitelpunkte beim Kombinieren der Netze vollst√§ndig gleichwertig sind, nur einer davon <b>√ºbrig</b> bleibt, wodurch unn√∂tige Geometrie vermieden wird. <br><br>  Im selben Modul haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Delaunay-Ebenentriangulationsalgorithmus</a> implementiert.  Mit ihm k√∂nnen Sie beispielsweise ein gro√ües Loch, das mit <b>Extrude</b> erstellt wurde, mit einem flachen Deckel mit Wassertextur schlie√üen und einen See erhalten: <br><br><img src="https://habrastorage.org/webt/zx/d_/7a/zxd_7akztomgl6ccvb0nfofnha8.png"><br><br>  Nun, habe es gekl√§rt!  Im n√§chsten Artikel werden die Funktionen zum Importieren von <b>.fbx</b> in <b>Unity</b> und die Methoden zur Modellvalidierung in einem Projekt behandelt. <br><br><div class="spoiler">  <b class="spoiler_title">F√ºr einen Snack (nur f√ºr Lulz)</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/x8/mk/wu/x8mkwuv2ose4mtecuzy3ph0m2bg.png"><br><img src="https://habrastorage.org/webt/cc/bu/lr/ccbulroovvqlk-jgmedg99jehfc.png"><br><img src="https://habrastorage.org/webt/ut/lr/2-/utlr2-kfdve0lkp6j97xcvaz6aa.png"><br><img src="https://habrastorage.org/webt/jk/km/pn/jkkmpnrhfhxdvxqxsp6sajwbxri.jpeg"><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443870/">https://habr.com/ru/post/de443870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443854/index.html">Vierachsiges RPG-Design</a></li>
<li><a href="../de443856/index.html">Metallbearbeitung auf CNC-Maschinen: Wie fange ich an, erstklassige Produkte herzustellen?</a></li>
<li><a href="../de443860/index.html">Programmierer als Service f√ºr kleine Unternehmen. Wird es fliegen oder nicht?</a></li>
<li><a href="../de443862/index.html">Das Auto des Staatsanwalts schlie√üt. Bestchange ist wieder gesperrt</a></li>
<li><a href="../de443868/index.html">Als Programmierer ging ich ins Fitnessstudio und was daraus wurde</a></li>
<li><a href="../de443872/index.html">√úbersicht √ºber die neuen Funktionen von nanoCAD SPDS Steelwork Version 1.2</a></li>
<li><a href="../de443874/index.html">Vergleich von Deep-Learning-Frameworks: TensorFlow, PyTorch, Keras, MXNet, Microsoft Cognitive Toolkit, Caffe usw.</a></li>
<li><a href="../de443876/index.html">Wir entwickeln einen Telegramm-Bot zum Verfolgen von Filmen auf NodeJS und TypeScript</a></li>
<li><a href="../de443878/index.html">DEV Labs 2019. Python zur L√∂sung nicht trivialer Aufgaben. Online Mitap</a></li>
<li><a href="../de443882/index.html">MOSDROID # 15 Phosphor: Leistungsvideo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>