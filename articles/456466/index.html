<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏾 🌰 💇🏻 Genéricos PHP hoy (bueno, casi) 📭 🧑🏿‍🤝‍🧑🏽 🧗🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si le preguntas a los desarrolladores de PHP qué tipo de oportunidad quieren ver en PHP, la mayoría llamará genéricos. 


 El soporte genérico a nivel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Genéricos PHP hoy (bueno, casi)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456466/"><p>  Si le preguntas a los desarrolladores de PHP qué tipo de oportunidad quieren ver en PHP, la mayoría llamará genéricos. </p><br><p>  El soporte genérico a nivel de idioma sería la mejor solución.  Pero, realizarlos es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">difícil</a> .  Esperamos que algún día el soporte nativo se convierta en parte del idioma, pero probablemente llevará varios años esperar. </p><br><p>  Este artículo mostrará cómo, utilizando herramientas existentes, en algunos casos con modificaciones mínimas, podemos obtener el poder de los genéricos en PHP en este momento. </p><a name="habracut"></a><br><blockquote>  De un traductor: deliberadamente uso papel de rastreo de los "genéricos" en inglés, porque  Nunca escuché en comunicación que alguien lo llamara "programación generalizada". </blockquote><br><h2 id="soderzhanie">  Contenido: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué son los genéricos?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo implementar genéricos sin soporte de idiomas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estandarización</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Herramienta de apoyo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte de código de terceros</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pasos adicionales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Limitaciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Por qué no solo agregas genéricos a la lengua?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué pasa si no necesito genéricos?</a> </li></ul><br><h2 id="anchorwhat-are-genericsanchorchto-takoe-dzheneriki"><a name="what-are-generics"></a>  ¿Qué son los genéricos? </h2><br><p>  Esta sección cubre una breve introducción a los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">genéricos</a> . </p><br><p>  Enlaces de lectura: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">RFC</a> para agregar genéricos PHP </li><li>  Soporte genérico en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Phan</a> </li><li>  Genéricos y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">plantillas de</a> salmo </li></ul><br><h3 id="prosteyshiy-primer">  Ejemplo más simple </h3><br><p>  Dado que actualmente no es posible definir genéricos a nivel de idioma, tendremos que usar otra gran oportunidad: definirlos en los bloques del muelle. </p><br><p>  Ya estamos usando esta opción en muchos proyectos.  Echa un vistazo a este ejemplo: </p><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string[] $names * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(iterable $names)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  En el código anterior, hacemos lo que es posible a nivel de idioma.  Definimos el parámetro <code>$names</code> como algo que podría enumerarse.  También indicamos que la función devolverá una matriz.  PHP arrojará un <code>TypeError</code> si los tipos de parámetros y el valor de retorno no coinciden. </p><br><p>  Docblock mejora la comprensión del código.  <code>$names</code> deben ser cadenas y la función debe devolver una matriz de objetos de <code>User</code> .  PHP en sí mismo no hace tales controles.  Pero los IDE como PhpStorm entienden esta notación y advierten al desarrollador que no se ha respetado el contrato adicional.  Además de esto, las herramientas de análisis estático como Psalm, PHPStan y Phan pueden validar la exactitud de los datos transferidos hacia y desde la función. </p><br><h3 id="dzheneriki-dlya-opredeleniya-klyuchey-i-znacheniy-perechislyaemyh-tipov">  Genéricos para determinar claves y valores de tipos enumerados </h3><br><p>  Arriba está el ejemplo más simple de un genérico.  Los métodos más complejos incluyen la capacidad de especificar el tipo de sus claves, junto con el tipo de valores.  A continuación hay una forma de describir esto: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Aquí dice que la matriz devuelta por <code>getUsers</code> tiene claves de cadena y valores de tipo <code>User</code> . </p><br><p>  Los analizadores estáticos como Psalm, PHPStan y Phan entienden esta anotación y la tienen en cuenta al verificar. </p><br><p>  Considere el siguiente código: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $age)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(getUsers() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $user) { showAge($name); }</code> </pre> <br><p>  Los analizadores estáticos lanzarán una advertencia en la llamada a <code>showAge</code> con un error, como este: El <code>Argument 1 of showAge expects int, string provided</code> . </p><br><p>  Desafortunadamente, al momento de escribir, PhpStorm no sabe cómo. </p><br><h3 id="bolee-slozhnye-dzheneriki">  Genéricos más sofisticados </h3><br><p>  Seguimos profundizando en el tema de los genéricos.  Considere un objeto que es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">pila</a> : </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  La pila puede aceptar cualquier tipo de objeto.  Pero, ¿qué sucede si queremos restringir la pila a solo objetos de tipo <code>User</code> ? </p><br><p>  Salmo y Phan apoyan las siguientes anotaciones: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> T $item */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  El docblock se usa para transmitir información de tipo adicional, por ejemplo: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Stack&lt;User&gt; $userStack */</span></span> $stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack(); Means that $userStack must only contain Users.</code> </pre> <br><p>  Salmo, al analizar el siguiente código: </p><br><pre> <code class="php hljs">$userStack-&gt;push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User()); $userStack-&gt;push(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>);</code> </pre> <br><p>  Se quejará de la línea 2 con el error <code>Argument 1 of Stack::push expects User, string(hello) provided.</code> </p><br><p>  PhpStorm no admite actualmente esta anotación. </p><br><p>  De hecho, hemos cubierto solo una parte de la información sobre genéricos, pero en este momento es suficiente. </p><br><h2 id="anchorhow-to-implement-generics-without-language-level-supportanchorkak-vnedrit-dzheneriki-bez-podderzhki-yazyka"><a name="how-to-implement-generics-without-language-level-support"></a>  Cómo implementar genéricos sin soporte de idiomas </h2><br><p>  Debe completar los siguientes pasos: </p><br><ul><li>  A nivel de la comunidad, defina estándares genéricos en bloques de acoplamiento (por ejemplo, un nuevo PSR o vuelva a PSR-5) </li><li>  Agregue anotaciones de Dockblock a su código </li><li>  Utilice IDE que entiendan estas convenciones para realizar análisis estáticos en tiempo real para encontrar inconsistencias. </li><li>  Utilice herramientas de análisis estático (como Psalm) como uno de los pasos de CI para detectar errores. </li><li>  Defina un método para pasar información de tipo a bibliotecas de terceros. </li></ul><br><h2 id="anchoragreeing-on-a-standardanchorstandartizaciya"><a name="agreeing-on-a-standard"></a>  Estandarización </h2><br><p>  Por el momento, la comunidad PHP ha adoptado de forma no oficial este formato genérico (la mayoría de las herramientas las admiten y su significado es claro para la mayoría): </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Sin embargo, tenemos problemas con ejemplos simples como este: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Psalm lo entiende y sabe qué tipo de clave tiene y los valores de la matriz devuelta. </p><br><p>  Al momento de escribir, PhpStorm no entiende esto.  Al usar esta entrada, extraño el poder del análisis estático en tiempo real que ofrece PhpStorm. </p><br><p>  Considera el siguiente código.  PhpStorm no entiende que <code>$user</code> es de tipo <code>User</code> y <code>$name</code> es de tipo string: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(getUsers() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $user) { ... }</code> </pre> <br><p>  Si elijo Salmo como herramienta de análisis estático, podría escribir lo siguiente: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-return array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Salmo entiende todo esto. </p><br><p>  PhpStorm sabe que la variable <code>$user</code> es de tipo <code>User</code> .  Pero aún no comprende que la clave de matriz se refiere a una cadena.  Phan y PHPStan no entienden las anotaciones específicas del salmo.  El máximo que entienden en este código es el mismo que en PhpStorm: el tipo de <code>$user</code> </p><br><p>  Se podría argumentar que PhpStorm debería aceptar la <code>array&lt;keyType, valueType&gt;</code> acuerdo <code>array&lt;keyType, valueType&gt;</code> .  No estoy de acuerdo contigo, porque  Creo que este dictado de estándares es tarea del idioma y la comunidad, y las herramientas solo deberían seguirlos. </p><br><p>  Supongo que la mayoría de la comunidad PHP recibirá calurosamente el acuerdo descrito anteriormente.  Uno que esté interesado en los genéricos.  Sin embargo, las cosas se vuelven mucho más complicadas cuando se trata de patrones.  Ni PHPStan ni PhpStorm actualmente admiten plantillas.  A diferencia de Salmo y Phan.  Su propósito es similar, pero si profundizas más, te darás cuenta de que las implementaciones son ligeramente diferentes. </p><br><p>  Cada una de las opciones presentadas es una especie de compromiso. </p><br><p>  En pocas palabras, es necesario un acuerdo sobre el formato de registro genérico: </p><br><ul><li>  Mejoran la vida de los desarrolladores.  Los desarrolladores pueden agregar genéricos a su código y beneficiarse de él. </li><li>  Los desarrolladores pueden usar las herramientas que más les gusten y cambiar entre ellas (herramientas) según sea necesario. </li><li>  Los creadores de herramientas pueden crear estas herramientas, entendiendo los beneficios para la comunidad y sin temer que algo cambie, o que sean acusados ​​de un "enfoque equivocado". </li></ul><br><h2 id="anchortool-supportanchorpodderzhka-instrumentami"><a name="tool-support"></a>  Herramienta de apoyo </h2><br><p>  Psalm tiene toda la funcionalidad necesaria para verificar genéricos.  Phan también es así. </p><br><p>  Estoy seguro de que PhpStorm introducirá genéricos tan pronto como la comunidad presente un acuerdo de formato único. </p><br><h2 id="anchorthird-party-code-supportanchorpodderzhka-storonnego-koda"><a name="third-party-code-support"></a>  Soporte de código de terceros </h2><br><p>  La parte final del rompecabezas genérico es agregar soporte para bibliotecas de terceros. </p><br><p>  Con suerte, tan pronto como aparezca el estándar de definición genérica, la mayoría de las bibliotecas lo implementarán.  Sin embargo, esto no sucederá de inmediato.  Se usan algunas bibliotecas, pero no tienen soporte activo.  Cuando se utilizan analizadores estáticos para validar tipos en genéricos, es importante que se definan todas las funciones que estos genéricos aceptan o devuelven. </p><br><p>  ¿Qué sucede si su proyecto se basa en bibliotecas de terceros que no tienen soporte genérico? </p><br><p>  Afortunadamente, este problema ya se ha resuelto y las funciones de código auxiliar son la solución.  Los talones de soporte de Psalm, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Phan</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">PhpStorm</a> . </p><br><p>  Los apéndices son archivos normales que contienen firmas de funciones y métodos, pero no los implementan.  Al agregar bloques de acoplamiento a los apéndices, las herramientas de análisis estático obtienen la información adicional que necesitan.  Por ejemplo, si tiene una clase de pila sin sugerencias de tipo y genéricos como este. </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* some implementation */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* some implementation */</span></span> } }</code> </pre> <br><p>  Puede crear un archivo apéndice que tenga métodos idénticos, pero con la adición de bloques de acoplamiento y sin la implementación de funciones. </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> T $item * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> void */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Cuando el analizador estático ve la clase de pila, toma información de tipo del código auxiliar, no del código real. </p><br><p>  La capacidad de compartir simplemente el código de stubs (por ejemplo, a través del compositor) sería extremadamente útil, porque  permitiría compartir el trabajo realizado. </p><br><h2 id="anchornext-stepsanchordalneyshie-shagi"><a name="next-steps"></a>  Pasos adicionales </h2><br><p>  La comunidad necesita alejarse de los acuerdos y establecer estándares. </p><br><p>  ¿Quizás la mejor opción sería un PSR genérico? </p><br><p>  O tal vez los creadores de los principales analizadores estáticos, PhpStorm, otros IDEs y cualquiera de las personas involucradas en el desarrollo de PHP (para control) podrían desarrollar un estándar que todos usarían. </p><br><p>  Tan pronto como aparezca el estándar, todos podrán ayudar con la adición de genéricos a las bibliotecas y proyectos existentes, creando solicitudes de extracción.  Y donde esto no es posible, los desarrolladores pueden escribir y compartir apéndices. </p><br><p>  Cuando todo esté listo, podemos usar herramientas como PhpStorm para verificar los genéricos en tiempo real mientras escribimos el código.  Podemos utilizar herramientas de análisis estático como parte de nuestro CI como garantía de seguridad. </p><br><p>  Los genéricos también se pueden implementar en PHP (bueno, casi). </p><br><h2 id="anchorlimitationsanchorogranicheniya"><a name="limitations"></a>  Limitaciones </h2><br><p>  Hay una serie de limitaciones.  PHP es un lenguaje dinámico que le permite hacer muchas cosas "mágicas", como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">estas</a> .  Si usa demasiada magia PHP, puede suceder que los analizadores estáticos no puedan extraer con precisión todos los tipos en el sistema.  Si se desconoce algún tipo, las herramientas no podrán utilizar genéricos correctamente en todos los casos. </p><br><p>  Sin embargo, la aplicación principal de este análisis es validar su lógica empresarial.  Si escribes código limpio, no debes usar demasiada magia. </p><br><h2 id="anchorwhy-dont-you-just-add-generics-to-the-languageanchorpochemu-by-vam-prosto-ne-dobavit-dzheneriki-v-yazyk"><a name="why-dont-you-just-add-generics-to-the-language"></a>  ¿Por qué no solo agregas genéricos a la lengua? </h2><br><p>  Esa sería la mejor opción.  PHP tiene código fuente abierto, ¡y nadie te molesta para clonar las fuentes e implementar genéricos! </p><br><h2 id="anchorwhat-if-i-dont-want-genericsanchorchto-esli-mne-ne-nuzhny-dzheneriki"><a name="what-if-i-dont-want-generics"></a>  ¿Qué pasa si no necesito genéricos? </h2><br><p>  Solo ignora todo lo anterior.  Una de las principales ventajas de PHP es que es flexible para elegir el nivel apropiado de complejidad de implementación dependiendo de lo que cree.  Con un código único, no necesita pensar en cosas como escribir sugerencias.  Pero en proyectos grandes vale la pena aprovechar esas oportunidades. </p><br><blockquote>  Gracias a todos los que leyeron a este lugar.  Estaré encantado de sus comentarios en el primer ministro. <br><br>  <strong>UPD</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">ghost404</a> en los comentarios señaló que <em>PHPStan de la versión 0.12.x entiende las anotaciones de salmo y admite genéricos</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456466/">https://habr.com/ru/post/456466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456446/index.html">Ceph - de "en la rodilla" a "producción"</a></li>
<li><a href="../456448/index.html">Reglas para elegir un marco JS</a></li>
<li><a href="../456450/index.html">DO-RA. Avia para monitorear la radiación cósmica en la aviación</a></li>
<li><a href="../456452/index.html">Ejemplos de código C ++ antes y después de Rangos</a></li>
<li><a href="../456462/index.html">Ensamblar una biblioteca de componentes angulares como componentes web</a></li>
<li><a href="../456470/index.html">Errores del editor de paquetes WSUS</a></li>
<li><a href="../456474/index.html">Tic Tac Toe Parte 0: Comparar Svelte y React</a></li>
<li><a href="../456476/index.html">Modificaciones de pila Bluetooth para mejorar la calidad de audio en auriculares sin códecs AAC, aptX o LDAC</a></li>
<li><a href="../456482/index.html">Atrápame si puedes. King Version</a></li>
<li><a href="../456486/index.html">Interfaz y elección (2014)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>