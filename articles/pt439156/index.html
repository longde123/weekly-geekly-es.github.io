<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó®Ô∏è üï∫üèΩ üÜí t1ha = Hash positivo r√°pido üëáüèª üò¢ ü§úüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Praticamente a fun√ß√£o hash port√°til de 64 bits mais r√°pida e com qualidade decente. 


 Esta √© uma tradu√ß√£o do artigo original de Leonid Yuriev . 
 Em...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>t1ha = Hash positivo r√°pido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439156/"><p>  Praticamente a fun√ß√£o hash port√°til de 64 bits mais r√°pida e com qualidade decente. </p><br><p> Esta √© uma tradu√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> original de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Leonid Yuriev</a> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Em vez de um aviso</b> <div class="spoiler_text"><p>  Omitirei a defini√ß√£o de fun√ß√µes de hash, juntamente com a lista detalhada das propriedades e requisitos para sua aplica√ß√£o criptogr√°fica, e assumirei que o leitor tenha o conhecimento m√≠nimo necess√°rio ou o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ler√°</a> .  Tamb√©m deve ser observado que daqui em diante irei falar sobre fun√ß√µes de hash n√£o criptogr√°ficas (n√£o adequadas para criptografia), a menos que seja explicitamente indicado o contr√°rio. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Banalidades</b> <div class="spoiler_text"><p>  O hash √© usado em muitos algoritmos e quase sempre √© necess√°rio o processamento de dados mais r√°pido (eficiente), juntamente com um certo n√≠vel m√≠nimo de qualidade de hash.  Aqui, o termo "qualidade" significa, antes de tudo, uma esp√©cie de "aleatoriedade" (estoc√°stica) em rela√ß√£o aos dados iniciais.  Um pouco menos frequentemente, requisitos adicionais s√£o impostos, como resist√™ncia √† gera√ß√£o deliberada de colis√µes ou irreversibilidade. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Para ser um pouco mais tedioso</b> <div class="spoiler_text"><p>  Para maior clareza, √© necess√°rio definir o conceito de "qualidade" da fun√ß√£o hash e o restante dos requisitos em um pouco mais detalhadamente: <br>  Qualidade da linha de base e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">efeito avalanche</a> : alterar um ou mais bits arbitr√°rios em um conjunto arbitr√°rio de dados de origem faz com que cada bit do resultado mude com uma probabilidade de ¬Ω. </p><br><ul><li>  Irreversibilidade ou resist√™ncia √† primeira pr√©-imagem: a impossibilidade de obter os dados originais ou bits individuais a partir do resultado do hash. </li><li>  Resist√™ncia a colis√µes de primeira ordem e / ou segunda resist√™ncia √† pr√©-imagem: a dificuldade de encontrar / ajustar o conjunto de dados original para obter um resultado especificado ou parte dele, inclusive quando o conjunto de dados inicial √© conhecido. </li><li>  Resist√™ncia a colis√µes de segunda ordem: a dificuldade de encontrar / ajustar dois conjuntos de dados diferentes que dariam o mesmo resultado ou uma correspond√™ncia de uma parte significativa. </li></ul></div></div><br><p>  Omitindo longas cita√ß√µes da matem√°tica subjacente, pode-se resumir: </p><br><ul><li>  Satisfazer todos os requisitos acima e garantir alto desempenho √© um problema bastante dif√≠cil, resolver o que nos daria uma boa fun√ß√£o de hash criptogr√°fico.  Mas n√£o vamos fazer isso ainda. </li><li>  O fornecimento de qualidade b√°sica requer um n√∫mero suficientemente grande de opera√ß√µes da ALU.  Simplificando, a qualidade sempre compromete a velocidade. </li><li>  A obten√ß√£o de um resultado de alta qualidade com uma largura de bit maior que a largura de bit das opera√ß√µes da ALU requer mais do que um aumento de v√°rias vezes no n√∫mero de misturas e, portanto, opera√ß√µes b√°sicas da ALU. </li><li>  Em geral, a <em>cria√ß√£o de uma fun√ß√£o r√°pida de hash envolve a obten√ß√£o de um compromisso ponderado entre velocidade, qualidade e resultado do resultado</em> . </li></ul><br><p>  Portanto, posso dizer que <strong>t1ha</strong> surgiu como resultado da busca de um compromisso entre qualidade e velocidade, levando em considera√ß√£o as capacidades dos processadores modernos e os m√©todos j√° encontrados (combina√ß√µes aritm√©tico-l√≥gicas) de misturar e espalhar depend√™ncias ( efeito avalanche). </p><br><p>  A vers√£o b√°sica do <strong>t1ha</strong> √© uma das fun√ß√µes de hash port√°teis mais r√°pidas para a constru√ß√£o de tabelas de hash e outros aplicativos relacionados.  A vers√£o b√°sica do <strong>t1ha</strong> √© focada em arquiteturas little-endian de 64 bits, <strong>utiliza</strong> um valor de sal de 64 bits (semente) e produz um resultado de 64 bits, que inclui o fortalecimento do tamanho da chave e da semente.  Vale a pena notar que <strong>t1ha</strong> foi projetado intencionalmente para retornar 0 para zero dados de entrada (uma chave de tamanho zero e zero semente). </p><br><div class="spoiler">  <b class="spoiler_title">Respondendo √†s perguntas mais populares</b> <div class="spoiler_text"><p>  <strong>Opera√ß√µes de 64 bits</strong> : Talvez se deva notar que s√£o as opera√ß√µes de 64 bits que fornecem velocidade e qualidade sem prejudicar a portabilidade.  De fato, quanto maior a capacidade de d√≠gitos das opera√ß√µes aritm√©ticas, mais efeito avalanche elas produzem e melhor eles misturam os dados.  Al√©m disso, o processamento de dados, todas as outras coisas iguais, certamente √© mais r√°pido em 8 bytes do que em 4. Por outro lado, exatamente as opera√ß√µes de 64 bits est√£o dispon√≠veis nativamente em muitos processadores modernos e podem ser traduzidas de forma mais ou menos adequada em 32 bits. pouco.  Todas as outras op√ß√µes, incluindo opera√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SIMD</a> , nos obrigam a sacrificar bastante a portabilidade e / ou a velocidade em plataformas n√£o nativas. </p><br><p>  <strong>Resultado de 64 bits</strong> : para construir tabelas de hash, em muitos casos, um resultado menor de largura de bit √© suficiente.  At√© 32 bits podem ser mais que suficientes.  No entanto, ao usar opera√ß√µes de 64 bits, o resultado de 64 bits ocorre naturalmente.  Ao mesmo tempo, um resultado de hash de 64 bits de alta qualidade o suficiente permite que voc√™ execute rapidamente uma compara√ß√£o para n√£o-igualdade e com boa precis√£o para comparar para igualdade. </p><br><p>  A "m√°gica" acima de substituir compara√ß√µes pode parecer pouco clara e desnecess√°ria ou pode <strong>aumentar a velocidade do hash em uma ordem de magnitude</strong> apenas por meio da localiza√ß√£o dos dados, ou seja, menos polui√ß√£o do cache da CPU.  Simplificando, √© poss√≠vel construir uma estrutura de tabela de hash de tal maneira que os valores calculados do hash fiquem lado a lado (agrupados em linhas de cache).  A CPU s√≥ pegaria os dados reais se os valores de hash correspondessem.  E, neste caso, os <em>64 bits de t1ha permitem obter o melhor resultado poss√≠vel</em> .  Dito isto, 128 bits n√£o fornecer√£o mais uma vantagem, enquanto tirar menos de 64 bits √© sempre poss√≠vel. </p><br><p>  <strong>Compara√ß√£o com HighwayHash</strong> : Eu tenho sentimentos contradit√≥rios sobre esse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto n√£o oficial por funcion√°rios do Google</a> . </p><br><ol><li>  Por um lado, possui um bom c√≥digo e excelente implementa√ß√£o t√©cnica.  Por outro lado, o <em>HighwayHash</em> est√° posicionado como <em>possivelmente</em> criptograficamente forte (pelo menos igual ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SipHash</a> ).  Dentro do HighwayHash, existem algumas manipula√ß√µes que nos permitem esperar que o resultado n√£o seja ruim.  No entanto, n√£o existem provas que nos permitam dizer isso com seguran√ßa.  A prova de "for√ßa" fornecida se resume aos resultados dos testes estat√≠sticos, mas sem capacidade de reproduzi-los (a certa altura, at√© me permiti um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coment√°rio</a> um tanto sup√©rfluo). </li><li>  O HighwayHash √© realmente r√°pido apenas em x86_64 com AVX2 ou SSE41.  N√£o √© mais f√°cil usar apenas a acelera√ß√£o AES-NI ou SHA? </li></ol><br><p>  Se tudo correr bem, op√ß√µes adicionais ser√£o adicionadas ao pacote t1ha (principalmente para o resultado obtido) e otimizadas para o E2K.  Com isso, gostaria de encerrar o t√≥pico de compara√ß√µes com o HighwayHash. </p></div></div><br><hr><br><h2 id="quality">  Qualidade </h2><br><p>  Avaliar a qualidade de uma fun√ß√£o de hash em todos os aspectos pode ser bastante dif√≠cil.  Isso pode ser feito analiticamente ou implementando v√°rios testes estat√≠sticos.  Infelizmente, a abordagem anal√≠tica n√£o √© muito eficaz para avaliar as fun√ß√µes de hash com um compromisso entre qualidade e velocidade.  Al√©m disso, uma avalia√ß√£o anal√≠tica comparativa de tais fun√ß√µes tende a ser subjetiva. </p><br><p>  Por outro lado, testes estat√≠sticos podem fornecer estimativas quantitativas claras.  Para tais fins, existem pacotes de teste comprovados, como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SMHasher</a> .  Para <em>t1ha</em> , os resultados s√£o simples - todas <strong>as op√ß√µes de t1ha</strong> passam em todos os testes sem coment√°rios.  Por outro lado, n√£o se deve presumir que t1ha possua propriedades que excedam as necess√°rias para o aplicativo de destino (constru√ß√£o de tabelas de hash). </p><br><p>  O n√∫mero de colis√µes em todos os n√≠veis (variantes) de <strong>t1ha</strong> corresponde ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">paradoxo</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anivers√°rio</a> .  Para formul√°-lo estritamente - a probabilidade de colis√£o em <strong>t1ha</strong> corresponde √† probabilidade de coincid√™ncia de valores discretos aleat√≥rios com o n√∫mero de bits correspondente. <br>  Uma probabilidade similar de colis√µes √© observada em todas as fun√ß√µes de hash de alta qualidade.  No entanto, isso √© apenas probabilidade, portanto, o n√∫mero real de colis√µes pode variar para cada conjunto de dados espec√≠fico. </p><br><p> Ap√≥s a publica√ß√£o deste artigo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Yves Orton descobriu</a> que o primeiro <code>t1ha1()</code> nem sempre atende ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rigoroso crit√©rio de avalanche</a> .  Essa desvantagem √© insignificante para aplica√ß√µes direcionadas de <code>t1ha1()</code> e impercept√≠vel do ponto de vista pr√°tico.  No entanto, essa desvantagem √© eliminada no pr√≥ximo n√≠vel / variante <code>t1ha2()</code> , que foi originalmente planejado para fornecer uma qualidade um pouco mais alta.  Nos novos processadores, que usam vers√µes atuais dos compiladores, <code>t1ha2()</code> √©, em m√©dia, um ciclo mais r√°pido que <code>t1ha1()</code> e, nos demais casos, pode ser um ciclo mais lento.  Vale ressaltar que <code>t1ha2()</code> oferece adicionalmente o modo de hash de fluxo e um resultado de 128 bits. </p><br><p>  Os leitores certamente apreciariam uma an√°lise completa e aprofundada da qualidade e / ou for√ßa do <strong>t1ha</strong> .  No entanto, com base nas √°reas de aplica√ß√£o <strong>t1ha de</strong> destino, isso parece redundante.  Simplificando, a velocidade era mais importante para n√≥s, mesmo para teclas curtas.  Portanto, a mistura multi-rodada n√£o foi considerada.  A atual vers√£o <em>t1ha</em> economiza ciclos e fornece um resultado de 64 bits - √© praticamente in√∫til medir o comprometimento encontrado de qualquer maneira que n√£o seja estatisticamente, e seus resultados s√£o simplesmente bons. </p><br><div class="spoiler">  <b class="spoiler_title">De fato</b> <div class="spoiler_text"><p>  Eu apenas segui meus colegas do Google em como eles fornecem sua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">prova estat√≠stica</a> </p></div></div><br><hr><br><h2 id="benchmarks">  Benchmarks </h2><br><p>  Quanto √† alega√ß√£o de ser " <em>o mais r√°pido</em> ".  √© importante observar que obviamente n√£o √© prov√°vel que exista uma fun√ß√£o de hash que seja ao mesmo tempo √∫til e a mais r√°pida em todas as plataformas / arquiteturas.  Processadores diferentes t√™m conjuntos de instru√ß√µes diferentes dispon√≠veis e executam instru√ß√µes semelhantes com diferentes efici√™ncias.  Obviamente, a fun√ß√£o " <em>universalmente mais r√°pida</em> " provavelmente n√£o pode ser criada.  No entanto, parece aceit√°vel usar o termo "o <br>  mais r√°pido ¬ªpara uma fun√ß√£o que √© port√°til e ao mesmo tempo a mais r√°pida, pelo menos na plataforma mais comum (x86_64), embora tenha poucas chances de perder em qualquer processador moderno com um compilador de otimiza√ß√£o decente. </p><br><p>  O c√≥digo-fonte do projeto inclui um teste que verifica a corre√ß√£o do resultado e mede a velocidade de cada variante implementada.  Ao mesmo tempo, no x86, dependendo dos recursos do processador (e do compilador), variantes adicionais de fun√ß√µes podem ser verificadas e medidas s√£o feitas nos ciclos do processador. </p><br><p>  Al√©m disso, o site do projeto cont√©m tabelas com os resultados das medi√ß√µes de desempenho por meio de uma vers√£o modificada do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SMHasher da Reini Urban</a> .  Pode-se verificar duas vezes todas as figuras e / ou obter resultados em um processador espec√≠fico usando um compilador espec√≠fico. </p><br><p>  Aqui voc√™ pode comparar t1ha com alguns de seus concorrentes mais pr√≥ximos. </p><br><p>  <strong>Teclas curtas de hash</strong> (m√©dia de 1 a 31 bytes). <br>  <em>Veja a coluna da direita "Ciclos / Hash" (quanto menor, melhor)</em> : </p><br><table><thead><tr><th>  Fun√ß√£o </th><th>  MiB / Segundo </th><th>  Ciclos / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Fasthash64 </td><td>  5578.06 </td><td>  43,42 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Metrohash </td><td>  11808.92 </td><td>  46,33 </td></tr></tbody></table><br><p>  <strong>Hashing chaves longas</strong> (256 Kb). <br>  <em>Veja a coluna do meio ‚ÄúMiB / Second‚Äù (quanto maior, melhor)</em> : </p><br><table><thead><tr><th>  Fun√ß√£o </th><th>  MiB / Segundo </th><th>  Ciclos / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35,55 </td></tr><tr><td>  Farmhash64 </td><td>  12145.36 </td><td>  60.12 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51,77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56,17 </td></tr><tr><td>  Spooky64 </td><td>  11820.20 </td><td>  60,39 </td></tr></tbody></table><br><hr><br><h2 id="variants-of-t1ha">  Variantes de t1ha </h2><br><p>  Desenvolvimento de <strong>t1ha</strong> O primeiro desses objetivos foi obter uma fun√ß√£o port√°til r√°pida de qualidade suficientemente alta para a constru√ß√£o de tabelas de hash. </p><br><p>  Em seguida, quer√≠amos ter a vers√£o mais r√°pida da fun√ß√£o hash que resultasse em qualidade compar√°vel, mas que fosse adaptada √† plataforma de destino o m√°ximo poss√≠vel.  Por exemplo, a vers√£o <strong>t1ha</strong> b√°sica funciona com ordem de bytes little-endian, devido √† qual √© necess√°ria uma convers√£o para arquiteturas big-endian com inevit√°vel perda de desempenho.  Ent√£o, por que n√£o se livrar de opera√ß√µes desnecess√°rias em uma plataforma de destino espec√≠fica?  Dessa forma, v√°rias outras op√ß√µes foram adicionadas: </p><br><ul><li>  Vers√£o simplificada para plataformas de 32 bits, pequena e big endian. </li><li>  Variante usando as instru√ß√µes da AES-NI, mas sem o AVX. </li><li>  Duas variantes usando as instru√ß√µes AES-NI e AVX. </li></ul><br><p>  Mais tarde, ficou claro que seriam necess√°rias mais op√ß√µes projetadas para v√°rias aplica√ß√µes, incluindo diferentes resultados de largura de bits, requisitos de qualidade e durabilidade.  Essa diversidade exigiu sistematiza√ß√£o adequada.  Isso foi alcan√ßado alterando o esquema de nomenclatura, no qual o sufixo num√©rico indica o "n√≠vel" da fun√ß√£o: </p><br><ul><li>  <code>t1ha0()</code> - √© a op√ß√£o mais r√°pida para o processador atual. </li><li>  <code>t1ha1()</code> - √© a vers√£o b√°sica port√°til de 64 bits do t1ha. </li><li>  <code>t1ha2()</code> - √© uma vers√£o port√°til de 64 bits com um pouco mais de preocupa√ß√£o com a qualidade. </li><li>  <code>t1ha3()</code> - √© uma vers√£o r√°pida e port√°til de 128 bits para impress√µes digitais. </li><li>  etc. </li></ul><br><p>  Nesse esquema, sup√µe-se que <code>t1ha0()</code> seja um despachante que implemente o redirecionamento, dependendo da plataforma e dos recursos do processador atual.  Al√©m disso, o uso dos sufixos "_le" e "_be" para uma escolha expl√≠cita entre as variantes little-endian e big-endian pode ser introduzido.  Assim, sob a placa ‚Äút1ha‚Äù agora existem v√°rias fun√ß√µes de hash, e essa fam√≠lia crescer√° no futuro, incluindo uma vers√£o otimizada para o russo E2K ‚ÄúElbrus‚Äù. </p><br><p>  Uma id√©ia geral do conjunto atual de fun√ß√µes e suas propriedades pode ser entendida observando a sa√≠da de teste interna ( <code>make check</code> ).  Vale ressaltar que todas as fun√ß√µes s√£o aprovadas em todos os testes do SM Hasher, e o desempenho das variantes do AES-NI varia muito, dependendo do modelo do processador: </p><br><pre> <code class="diff hljs">Intel(R) Core(TM) i7-6700K CPU @ 3.00GHz Build by GNU C/C++ compiler 8.2 [...] - use RDPMC_40000001 as clock source - measure granularity and overhead: 53 cycles, 0.0188679 iteration/cycle Bench for tiny keys (7 bytes): t1ha0 : 13.14 cycle/hash, 1.877 cycle/byte, 1.598 Gb/s @3GHz t1ha1_64le : 15.14 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha2_atonce : 15.50 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha1_64be : 16.78 cycle/hash, 2.397 cycle/byte, 1.251 Gb/s @3GHz xxhash32 : 17.17 cycle/hash, 2.453 cycle/byte, 1.223 Gb/s @3GHz StadtX : 17.59 cycle/hash, 2.513 cycle/byte, 1.194 Gb/s @3GHz t1ha0_32le : 18.28 cycle/hash, 2.612 cycle/byte, 1.149 Gb/s @3GHz t1ha0_32be : 20.24 cycle/hash, 2.892 cycle/byte, 1.037 Gb/s @3GHz xxhash64 : 22.17 cycle/hash, 3.167 cycle/byte, 0.947 Gb/s @3GHz t1ha2_atonce128* : 29.93 cycle/hash, 4.277 cycle/byte, 0.701 Gb/s @3GHz t1ha2_stream* : 79.81 cycle/hash, 11.402 cycle/byte, 0.263 Gb/s @3GHz HighwayHash64_avx2 : 83.75 cycle/hash, 11.964 cycle/byte, 0.251 Gb/s @3GHz HighwayHash64_sse41 : 85.25 cycle/hash, 12.179 cycle/byte, 0.246 Gb/s @3GHz t1ha2_stream128* : 99.06 cycle/hash, 14.152 cycle/byte, 0.212 Gb/s @3GHz HighwayHash64_portable: 480.75 cycle/hash, 68.679 cycle/byte, 0.044 Gb/s @3GHz HighwayHash64_pure_c : 652.58 cycle/hash, 93.226 cycle/byte, 0.032 Gb/s @3GHz Bench for large keys (16384 bytes): t1ha0 : 1185.00 cycle/hash, 0.072 cycle/byte, 41.478 Gb/s @3GHz t1ha2_atonce : 3436.00 cycle/hash, 0.210 cycle/byte, 14.305 Gb/s @3GHz t1ha2_atonce128* : 3440.00 cycle/hash, 0.210 cycle/byte, 14.288 Gb/s @3GHz t1ha1_64le : 3449.00 cycle/hash, 0.211 cycle/byte, 14.251 Gb/s @3GHz t1ha2_stream* : 3479.00 cycle/hash, 0.212 cycle/byte, 14.128 Gb/s @3GHz t1ha2_stream128* : 3508.00 cycle/hash, 0.214 cycle/byte, 14.011 Gb/s @3GHz StadtX : 3550.00 cycle/hash, 0.217 cycle/byte, 13.846 Gb/s @3GHz xxhash64 : 4121.00 cycle/hash, 0.252 cycle/byte, 11.927 Gb/s @3GHz t1ha1_64be : 4567.00 cycle/hash, 0.279 cycle/byte, 10.762 Gb/s @3GHz HighwayHash64_avx2 : 4580.00 cycle/hash, 0.280 cycle/byte, 10.732 Gb/s @3GHz HighwayHash64_sse41 : 6412.00 cycle/hash, 0.391 cycle/byte, 7.666 Gb/s @3GHz t1ha0_32le : 7191.00 cycle/hash, 0.439 cycle/byte, 6.835 Gb/s @3GHz t1ha0_32be : 7928.00 cycle/hash, 0.484 cycle/byte, 6.200 Gb/s @3GHz xxhash32 : 8197.00 cycle/hash, 0.500 cycle/byte, 5.996 Gb/s @3GHz HighwayHash64_portable: 41895.27 cycle/hash, 2.557 cycle/byte, 1.173 Gb/s @3GHz HighwayHash64_pure_c : 53296.11 cycle/hash, 3.253 cycle/byte, 0.922 Gb/s @3GHz</code> </pre><br><hr><br><div class="spoiler">  <b class="spoiler_title">Um pouco sobre a estrutura interna</b> <div class="spoiler_text"><p>  Para aprofundar um pouco mais detalhadamente, o <strong>t1ha</strong> √© constru√≠do de acordo com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esquema Merkle-Damg√•rd</a> (vers√£o ‚Äúwipe-pipe‚Äù) com refor√ßo do tamanho dos dados e do valor da semente.  Dentro do loop de compacta√ß√£o principal, √© utilizado um estado de 256 bits, com o mesmo tamanho do bloco de entrada.  Al√©m disso, para cada operando de dados existem dois pontos de inje√ß√£o com poliniza√ß√£o cruzada.  Ap√≥s a conclus√£o do ciclo de compacta√ß√£o, o estado de 256 bits √© compactado para 128 bits. </p><br><p>  Ao executar as a√ß√µes acima, s√£o utilizadas opera√ß√µes de 64 bits, combinadas nos mixers ARX (Add-Rotate-Xor) e MUX / MRX (Mul-Rotate-Xor).  √â importante que todos esses c√°lculos sejam constru√≠dos de forma a garantir a possibilidade de execu√ß√£o paralela da maioria das opera√ß√µes e compacta√ß√£o apertada de opera√ß√µes opcionais, tanto no pipeline quanto nas unidades de execu√ß√£o x86_64.  Devido a isso, √© alcan√ßada uma qualidade suficientemente boa, com taxa de hash quase m√°xima para chaves longas. </p><br><p>  Vale ressaltar que o loop de compress√£o √© executado apenas para blocos de tamanho suficiente.  Se houver menos dados, o estado intermedi√°rio de 128 bits consistir√° apenas no tamanho da chave e no valor do sal. </p><br><p>  Em seguida, a cauda restante dos dados √© misturada em partes de 64 bits alternadamente √†s metades do estado de 128 bits.  Finalmente, o estado √© misto e compactado simultaneamente para um resultado de 64 bits.  Uma caracter√≠stica importante de t1ha aqui √© o uso de um misturador baseado em ampla multiplica√ß√£o (produto de 128 bits de dois multiplicadores de 64 bits).  Isso permite uma mistura de boa qualidade com um bom efeito de avalanche e menos opera√ß√µes.  Embora a multiplica√ß√£o ampla seja uma opera√ß√£o relativamente cara, poucas opera√ß√µes permitem que t1ha processe teclas curtas em um n√∫mero recorde de ciclos do processador. </p><br><p>  Note-se que o misturador baseado em ampla multiplica√ß√£o e OR exclusivo n√£o √© perfeito.  Embora <em>t1ha</em> passe em todos os testes <em>SMHasher</em> , o autor entende as consequ√™ncias da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o-injetividade</a> ).  No entanto, a qualidade resultante parece ser racionalmente suficiente, e os planos de desenvolvimento para a linha t1ha j√° refletem a inten√ß√£o de fornecer op√ß√µes de qualidade um pouco mais altas. </p></div></div><br><p>  Voc√™ pode encontrar mais informa√ß√µes e c√≥digo fonte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  <em>Obrigado pela leitura!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439156/">https://habr.com/ru/post/pt439156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439142/index.html">Modelos de maturidade do projeto</a></li>
<li><a href="../pt439148/index.html">Trabalhe com nRF51822 usando ST-Link e Clion + OpenOCD</a></li>
<li><a href="../pt439150/index.html">Quem deve pagar os custos de transa√ß√£o</a></li>
<li><a href="../pt439152/index.html">Sal√°rios em TI no segundo semestre de 2018: de acordo com a calculadora de sal√°rios "Meu c√≠rculo"</a></li>
<li><a href="../pt439154/index.html">Como os freelancers vivem: Design de capa de livro, produ√ß√£o pr√≥pria de mochila e viagens</a></li>
<li><a href="../pt439158/index.html">DataArt lan√ßa servi√ßo gratuito de aprimoramento de curr√≠culo CV Duck</a></li>
<li><a href="../pt439160/index.html">Estado do algoritmo: o que acontece com os desenvolvedores independentes no Steam?</a></li>
<li><a href="../pt439162/index.html">Como depurar front-end e back-end: instru√ß√µes passo a passo</a></li>
<li><a href="../pt439166/index.html">mmWave a caminho da comercializa√ß√£o no formato de smartphone</a></li>
<li><a href="../pt439168/index.html">Sistemas de an√°lise de clientes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>