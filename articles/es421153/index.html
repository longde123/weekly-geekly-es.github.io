<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèª üõèÔ∏è üë®‚Äçüë®‚Äçüëß‚Äçüë¶ CPU de 24 n√∫cleos, pero no puedo escribir un correo electr√≥nico (parte 2) üë©üèæ üë®‚Äç‚öñÔ∏è üö∂üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un art√≠culo anterior, promet√≠ revelar con m√°s detalle algunos detalles que omit√≠ durante la investigaci√≥n [Gmail se cuelga en Chrome en Windows - a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CPU de 24 n√∫cleos, pero no puedo escribir un correo electr√≥nico (parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421153/"> En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior,</a> promet√≠ revelar con m√°s detalle algunos detalles que omit√≠ durante la investigaci√≥n [Gmail se cuelga en Chrome en Windows - aprox.  Per.], Incluidas las tablas de p√°ginas, bloqueos, WMI y el error vmmap.  Ahora relleno estos huecos junto con ejemplos de c√≥digo actualizados.  Pero primero, describa brevemente la esencia. <br><br>  El punto era que un proceso que admite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Control Flow Guard</a> (CFG) asigna memoria ejecutable, al tiempo que asigna memoria CFG que Windows nunca libera.  Por lo tanto, si contin√∫a asignando y liberando memoria ejecutable <i>en diferentes direcciones</i> , el proceso acumula una cantidad arbitraria de memoria CFG.  El navegador Chrome hace esto, lo que conduce a una p√©rdida de memoria casi ilimitada y se congela en algunas m√°quinas. <br><br>  Cabe se√±alar que las congelaciones son dif√≠ciles de evitar si VirtualAlloc comienza a ejecutarse m√°s de un mill√≥n de veces m√°s lento de lo habitual. <br><a name="habracut"></a><br>  Adem√°s de CFG, hay otra memoria desperdiciada, aunque no es tanto como afirma vmmap. <br><br><h1>  CFG y p√°ginas </h1><br>  Tanto la memoria del programa como la memoria CFG se asignan en √∫ltima instancia con p√°ginas de 4 kilobytes (m√°s sobre esto m√°s adelante).  Dado que 4 KB de memoria CFG pueden describir 256 KB de memoria de programa (m√°s sobre eso m√°s adelante), esto significa que si selecciona un bloque de memoria de 256 KB alineado con 256 KB, obtendr√° una p√°gina CFG de 4 KB.  Y si asigna un bloque ejecutable de 4 KB, a√∫n obtendr√° una p√°gina CFG de 4 KB, pero la mayor parte no se utilizar√°. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/0c2/e19/f100c2e19331ea5b1e313961be362c80.png" align="right">  Todo es m√°s complicado si se libera la memoria ejecutable.  Si usa la funci√≥n VirtualFree en un bloque de memoria ejecutable que no es un m√∫ltiplo de 256 KB o no est√° alineado a 256 KB, el sistema operativo debe realizar un an√°lisis y verificar que alguna otra memoria ejecutable no use una p√°gina CFG.  Los autores de CFG decidieron no molestarse, y simplemente dejar para siempre la memoria CFG asignada.  Es muy desafortunado.  Esto significa que cuando mi programa de prueba asigna y luego libera 1 gigabyte de memoria ejecutable alineada, deja 16 MB de memoria CFG. <br><br>  En la pr√°ctica, resulta que cuando el motor JavaScript de Chrome asigna y luego libera 128 MB de memoria ejecutable alineada (no se us√≥ todo, pero se asign√≥ todo el rango y se liber√≥ de inmediato), entonces permanecer√°n asignados hasta 2 MB de memoria CFG, aunque es trivial liberarlo por completo .  Dado que Chrome asigna y libera memoria repetidamente en direcciones aleatorias, esto lleva al problema descrito anteriormente. <br><br><h1>  Memoria perdida adicional </h1><br>  En cualquier sistema operativo moderno, cada proceso obtiene su propio espacio de direcciones de memoria virtual, de modo que el sistema operativo a√≠sla los procesos y protege la memoria.  Esto se hace usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una unidad de administraci√≥n de memoria</a> (MMU) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tablas de p√°ginas</a> .  La memoria est√° dividida en p√°ginas de 4 KB.  Esta es la cantidad m√≠nima de memoria que le proporciona el sistema operativo.  Cada p√°gina se indica mediante un registro de ocho bytes en la tabla de p√°ginas, y los registros mismos se almacenan en p√°ginas de 4 KB.  Cada uno de ellos apunta a un m√°ximo de 512 p√°ginas diferentes de memoria, por lo que necesitamos una jerarqu√≠a de tablas de p√°ginas.  Para un espacio de direcciones de 48 bits en un sistema operativo de 64 bits, el sistema es el siguiente: <br><br><ul><li>  Una tabla de Nivel 1 cubre 256 TB (48 bits), apuntando a 512 tablas de nivel 2 de p√°gina diferentes </li><li>  Cada tabla de nivel 2 cubre 512 GB, apuntando a 512 tablas de nivel 3 </li><li>  Cada tabla de nivel 3 cubre 1 GB, apuntando a 512 tablas de nivel 4 </li><li>  Cada tabla de nivel 4 abarca 2 MB, apuntando a 512 p√°ginas f√≠sicas </li></ul><br>  MMU indexa la tabla del primer nivel en los primeros 9 (de 48) bits de la direcci√≥n, las tablas del segundo nivel en los siguientes 9 bits, y los niveles restantes reciben 9 bits, es decir, solo 36 bits.  Los 12 bits restantes se usan para indexar p√°ginas de 4 kilobytes de una tabla de 4to nivel.  Bien bien <br><br>  Si llena inmediatamente todos los niveles de las tablas, necesitar√° m√°s de 512 GB de RAM, de modo que se llenen seg√∫n sea necesario.  Esto significa que al asignar una p√°gina de memoria, el sistema operativo selecciona algunas tablas de p√°ginas, de cero a tres, dependiendo de si las direcciones asignadas est√°n en un √°rea no utilizada anteriormente de 2 MB, un √°rea no utilizada previamente de 1 GB o un √°rea previamente no utilizada de 512 GB (tabla de p√°ginas de nivel 1 siempre se destaca). <br><br>  En resumen, la asignaci√≥n a direcciones aleatorias es mucho m√°s costosa que la asignaci√≥n a direcciones cercanas, ya que en el primer caso las tablas de p√°ginas no se pueden compartir.  Las fugas de CFG son raras, por lo que cuando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vmmap</a> mostr√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">412,480</a> KB de tablas de p√°ginas usadas en Chrome, supuse que los n√∫meros eran correctos.  Aqu√≠ hay una captura de pantalla de vmmap con el dise√±o de memoria chrome.exe del art√≠culo anterior, pero con la l√≠nea de tabla de p√°ginas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08b/7b7/b4d/08b7b7b4dda4d0b54b3017b5eb80c7ab.png"><br><br>  Pero algo parec√≠a mal.  Decid√≠ agregar un simulador de tabla de p√°ginas a mi herramienta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VirtualScan</a> .  Calcula cu√°ntas p√°ginas de tablas de p√°ginas se necesitan para toda la memoria asignada durante el proceso de escaneo.  Solo necesita escanear la memoria asignada, agregando al contador uno cada n√∫mero m√∫ltiple de 2 MB, 1 GB o 512 GB. <br><br>  Se descubri√≥ r√°pidamente que los resultados del simulador corresponden a vmmap en procesos normales, pero no en procesos con una gran cantidad de memoria CFG.  La diferencia corresponde aproximadamente a la memoria CFG asignada.  Para el proceso anterior, donde vmmap habla de 402.8 MB (412,480 KB) de tablas de p√°ginas, mi herramienta muestra 67.7 MB. <br><br><pre>  Tiempo de escaneo, comprometido, tablas de p√°ginas, bloques comprometidos
 Total: 41.763s, 1457.7 MiB, 67.7 MiB, 32112, 98 bloques de c√≥digo
 CFG: 41.759s, 353.3 MiB, 59.2 MiB, 24866 </pre><br><br>  Me asegur√© del error vmmap ejecutando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VAllocStress</a> , que en la configuraci√≥n predeterminada hace que Windows asigne 2 gigabytes de memoria CFG.  vmmap afirm√≥ haber asignado 2 gigabytes de tablas de p√°ginas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89c/e6e/33f/89ce6e33f668a6de32abc6a0231bd3e1.png"><br><br>  Y cuando complet√© el proceso a trav√©s del Administrador de tareas, vmmap mostr√≥ que la cantidad de memoria asignada disminuy√≥ en solo 2 gigabytes.  Entonces, vmmap est√° mal, mis c√°lculos con las tablas de p√°ginas son correctos, y despu√©s de una fruct√≠fera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discusi√≥n en Twitter,</a> envi√© un informe sobre el error de vmmap, que deber√≠a corregirse.  La memoria CFG todav√≠a consume muchas entradas de la tabla de p√°ginas (59.2 MB en el ejemplo anterior), pero no tanto como dice vmmap, y despu√©s de solucionarlo no consumir√° nada. <br><br><h1>  ¬øQu√© es CFG y CFG? </h1><br>  Quiero dar un paso atr√°s y decir con m√°s detalle qu√© es CFG. <br><br>  CFG significa Control Flow Guard.  Este es un m√©todo de protecci√≥n contra exploits reescribiendo punteros de funci√≥n.  Con CFG habilitado, el compilador y el sistema operativo juntos comprueban la validez del objetivo de la rama.  Primero, el byte de control CFG correspondiente se carga desde el √°rea CFG reservada de 2 TB.  El proceso de 64 bits en Windows administra el espacio de direcciones de 128 TB, por lo que dividir la direcci√≥n por 64 le permite encontrar el byte CFG correspondiente para este objeto. <br><br> <code>uint8_t cfg_byte = cfg_base[size_t(target_addr) / 64];</code> <br> <br>  Ahora tenemos un byte que debe describir qu√© direcciones en el rango de 64 bytes son destinos de rama v√°lidos.  Para hacer esto, el CFG trata el byte como cuatro valores de dos bits, cada uno de los cuales corresponde a un rango de 16 bytes.  Este n√∫mero de dos bits (cuyo valor es de cero a tres) se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interpreta de la siguiente manera</a> : <br><br><ul><li>  0: todos los objetivos en este bloque de 16 bytes son objetivos no v√°lidos de ramas indirectas </li><li>  1 - la direcci√≥n de inicio en este bloque de 16 bytes es el objetivo v√°lido de la rama indirecta </li><li>  2 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">asociado con llamadas CFG "suprimidas"</a> ;  la direcci√≥n es potencialmente inv√°lida </li><li>  3 - las direcciones no alineadas en este bloque de 16 bytes son objetivos v√°lidos de una rama indirecta, sin embargo, una direcci√≥n alineada de 16 bytes es potencialmente inv√°lida </li></ul><br>  Si el objetivo de la rama indirecta no es v√°lido, el proceso finaliza y se evita la explotaci√≥n.  ¬°Hurra! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/1af/827/a081af827b3df7b40e8b8530b7cbd1a4.png"><br><br>  De esto podemos concluir que para una seguridad m√°xima, los objetivos indirectos de la rama deben estar alineados en 16 bytes, y podemos entender por qu√© la memoria CFG para el proceso es aproximadamente 1/64 de la memoria del programa. <br><br><blockquote>  En realidad, CFG carga 32 bits a la vez, pero estos son detalles de implementaci√≥n.  Muchas fuentes describen la memoria CFG como un bit de 8 bytes en lugar de doble bit de 16 bytes.  Mi explicaci√≥n es mejor. </blockquote><br><h1>  Por eso todo es malo </h1><br>  Gmail se cuelga por dos razones.  Primero, escanear la memoria CFG en Windows 10 16299 o anterior es extremadamente lento.  Vi c√≥mo escanear el espacio de direcciones de un proceso lleva 40 segundos o m√°s, y literalmente el 99,99% de este tiempo se escanea la memoria CFG reservada, aunque solo representa aproximadamente el 75% de los bloques de memoria fijos.  No s√© por qu√© el escaneo fue tan lento, pero lo arreglaron en Windows 10 17134, por lo que no tiene sentido estudiar el problema con m√°s detalle. <br><br>  El escaneo lento provoc√≥ una desaceleraci√≥n porque Gmail quer√≠a redundancia CFG, y WMI mantuvo el bloqueo mientras dur√≥ el escaneo.  Pero el bloqueo de reserva de memoria no se mantuvo durante todo el escaneo.  En mi ejemplo, hay aproximadamente 49,000 bloques en el √°rea de CFG, y la funci√≥n <i>NtQueryVirtualMemory</i> , que recibe y libera el bloqueo, se llam√≥ una vez para cada uno de ellos.  Por lo tanto, el bloqueo se obtuvo y liber√≥ ~ 49,000 veces y cada vez se mantuvo durante menos de 1 milisegundo. <br><br>  Pero aunque el bloqueo se liber√≥ 49,000 veces, el proceso de Chrome por alguna raz√≥n no pudo obtenerlo.  Esto es injusto! <br><br>  Esa es la esencia del problema.  Como escrib√≠ la √∫ltima vez: <br><br><blockquote>  Esto se debe a que los bloqueos de Windows son inherentemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">injustos</a> , y si el subproceso libera el bloqueo y luego lo solicita de inmediato, puede obtenerlo para siempre. </blockquote><br>  El bloqueo equitativo significa que dos hilos competidores lo recibir√°n a su vez.  Pero esto significa muchos cambios de contexto caros, por lo que durante mucho tiempo no se usar√° el bloqueo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/713/348/9de/7133489de2c1eca7dc2b2c91b08e1871.png"><br><br>  Los bloqueos injustos son m√°s baratos y no hacen que los hilos esperen en l√≠nea.  Simplemente capturan la cerradura, como se menciona en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el art√≠culo de Joe Duffy</a> .  √âl tambi√©n escribe: <br><br><blockquote>  La introducci√≥n de cerraduras injustas puede indudablemente provocar hambre.  Pero estad√≠sticamente, el tiempo en sistemas paralelos tiende a ser tan variable que cada hilo recibir√° un turno para su ejecuci√≥n, desde un punto de vista probabil√≠stico. </blockquote><br>  ¬øC√≥mo correlacionar la declaraci√≥n de Joe de 2006 sobre la rareza del hambre con mi experiencia en un problema 100% repetible y duradero?  Creo que la raz√≥n principal es lo que sucedi√≥ en 2006.  Intel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lanz√≥ Core Duo</a> , y las computadoras multin√∫cleo son ubicuas. <br><br>  Despu√©s de todo, ¬°resulta que este problema de hambre ocurre solo en un sistema de m√∫ltiples n√∫cleos!  En dicho sistema, el hilo WMI liberar√° el bloqueo, le indicar√° al hilo Chrome que se active y contin√∫e.  Dado que la transmisi√≥n WMI ya se est√° ejecutando, tiene una "desventaja" frente a la transmisi√≥n de Chrome, por lo que puede llamar f√°cilmente a <i>NtQueryVirtualMemory</i> nuevamente y recuperar el bloqueo nuevamente antes de que Chrome tenga la oportunidad de hacerlo. <br><br>  Obviamente, en un sistema de un solo n√∫cleo, solo un hilo puede funcionar a la vez.  Como regla general, Windows aumenta la prioridad de un nuevo subproceso, y aumentar la prioridad significa que cuando se libere el bloqueo, el nuevo subproceso de Chrome estar√° listo e inmediatamente <i>antes del</i> subproceso de WMI.  Esto le da al hilo de Chrome mucho tiempo para despertarse y obtener un bloqueo, y el hambre nunca llega. <br><br>  ¬øEntiendes?  En un sistema multin√∫cleo, un aumento de prioridad en la mayor√≠a de los casos no afecta la transmisi√≥n WMI, ya que se ejecutar√° en un n√∫cleo diferente. <br><br>  Esto significa que un sistema con n√∫cleos adicionales puede <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">responder m√°s lentamente</a></i> que un sistema con la misma carga de trabajo y menos n√∫cleos.  Otra conclusi√≥n es curiosa: si mi computadora tuviera una carga pesada (hilos de la prioridad correspondiente, trabajando en todos los n√∫cleos del procesador), entonces podr√≠an evitarse los bloqueos (no intente repetir esto en casa). <br><br>  Por lo tanto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las cerraduras injustas</a> aumentan la productividad, pero pueden provocar hambre.  Sospecho que la soluci√≥n puede ser lo que yo llamo cerraduras "a veces justas".  Digamos, el 99% de las veces ser√°n injustas, pero en el 1% dar√° el bloqueo a otro proceso.  Esto preservar√° los beneficios de la productividad con m√°s, evitando el problema del hambre.  Anteriormente, los bloqueos en Windows se distribu√≠an de manera justa y probablemente puede volver parcialmente a esto, encontrando el equilibrio perfecto.  Descargo de responsabilidad: no soy un experto en bloqueos o un ingeniero de sistemas operativos, pero estoy interesado en escuchar ideas al respecto, y al menos no soy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el primero en ofrecer algo as√≠</a> . <br><br>  Linus Torvalds recientemente apreci√≥ la importancia de las cerraduras justas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Tal vez es hora de un cambio en Windows tambi√©n. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Para resumir</a> : bloquear durante unos segundos no es bueno, limita la concurrencia.  Pero en los sistemas multin√∫cleo con bloqueos injustos, la eliminaci√≥n y la recepci√≥n inmediata del bloqueo nuevamente se comporta <i>exactamente as√≠</i> : otros hilos no tienen forma de funcionar. <br><br><h1>  Casi un fracaso con ETW </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/d69/a68/740/d69a68740eb8df0f6962d53db91190b7.png" align="right">  Para toda esta investigaci√≥n, confi√© en el rastreo de ETW, por lo que me asust√© un poco cuando, al comienzo de la investigaci√≥n, result√≥ que Windows Performance Analyzer (WPA) no pod√≠a cargar los caracteres de Chrome.  Estoy seguro de que, literalmente, la semana pasada todo funcion√≥.  Que paso ... <br><br>  Sucedi√≥ que Chrome M68 sali√≥, y se vincul√≥ usando lld-link en lugar del enlazador VC ++.  Si ejecuta <i>dumpbin</i> y mira la informaci√≥n de depuraci√≥n, ver√°: <br><br> <code>C:\b\c\b\win64_clang\src\out\Release_x64\./initialexe/chrome.exe.pdb</code> <br> <br>  Bueno, probablemente a WPA no le gusten estas barras.  Pero todav√≠a no tiene sentido, porque cambi√© el enlazador a lld-link, y recuerdo que prob√© WPA antes de eso, entonces, ¬øqu√© pas√≥ ... <br><br>  Result√≥ que la raz√≥n estaba en la nueva versi√≥n WPA 17134. Prob√© el dise√±o de lld-Link, y funcion√≥ bien en WPA 16299. ¬°Qu√© coincidencia!  El nuevo vinculador y el nuevo WPA no eran compatibles. <br><br>  Instal√© la versi√≥n anterior de WPA para continuar con la investigaci√≥n (xcopy desde una m√°quina con la versi√≥n anterior) e inform√© de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">error de lld-link</a> , que los desarrolladores solucionaron r√°pidamente.  Ahora puede volver a WPA 17134 cuando el M69 se ensambla con un enlazador fijo. <br><br><h1>  Wmi </h1><br>  El activador de congelaci√≥n de WMI es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complemento de Instrumental de administraci√≥n de Windows</a> , y no soy bueno en eso.  Descubr√≠ que en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2014 o antes,</a> alguien se encontr√≥ con el problema del uso significativo de la CPU en <i>WmiPrvSE.exe</i> dentro de <i>perfproc! GetProcessVaData</i> , pero no proporcionaron suficiente informaci√≥n para comprender las causas del error.  En alg√∫n momento, comet√≠ un error y trat√© de averiguar qu√© una loca solicitud de WMI podr√≠a colgar a Gmail durante unos segundos.  Conect√© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algunos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">expertos</a> con la investigaci√≥n y pas√© mucho tiempo tratando de encontrar esta consulta m√°gica.  Grab√© la actividad de <i>Microsoft-Windows-WMI-Activity</i> en trazas ETW, experiment√© con PowerShell para encontrar todas las consultas Win32_Perf, y me perd√≠ en algunas formas m√°s indirectas que son demasiado aburridas para discutir.  Al final, descubr√≠ que un bloqueo de Gmail caus√≥ este contador, <i>Win32_PerfRawData_PerfProc_ProcessAddressSpace_Costly</i> , desencadenado por un PowerShell de una sola l√≠nea: <br><br><pre> <code class="hljs pgsql">measure-command {<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>-WmiObject -Query ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Win32_PerfFormattedData_PerfProc_ProcessAddressSpace_Costly‚Äù}</code> </pre> <br>  Luego me confund√≠ <i>a√∫n m√°s</i> por el nombre del contador (¬ø"querido"? ¬øEn serio?) Y porque este contador aparece y desaparece en funci√≥n de factores que no entiendo. <br><br>  Pero los detalles de WMI no importan.  WMI no hizo nada malo, no realmente, simplemente escane√≥ la memoria.  Escribir su propio c√≥digo de escaneo result√≥ ser mucho m√°s √∫til para investigar el problema. <br><br><h1>  Problemas para Microsoft </h1><br>  Chrome ha lanzado un parche, el resto es para Microsoft. <br><br><ol><li>  <s>Acelere el escaneo de la regi√≥n CFG</s> - OK, ya est√° </li><li>  Libere memoria CFG cuando se libere memoria ejecutable; al menos en el caso de una alineaci√≥n de 256K, es <i>f√°cil</i> </li><li>  Considere una marca que permita asignar memoria ejecutable sin memoria CFG, o use PAGE_TARGETS_INVALID para este prop√≥sito.  Tenga en cuenta que el manual de <i>Windows Internals Part 1 7th Edition</i> dice que "debe seleccionar p√°ginas [CFG] con al menos un conjunto de bits {1, X}" - si Windows 10 implementa esto, entonces el indicador PAGE_TARGETS_INVALID (que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">actualmente utiliza el motor v8</a> ) evitar√° la asignaci√≥n de memoria </li><li>  Se corrigi√≥ el c√°lculo de las tablas de p√°ginas en vmmap para procesos con una gran cantidad de asignaciones de CFG </li></ol><br><h1>  Actualizaciones de c√≥digo </h1><br>  Actualic√© los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplos de c√≥digo</a> , especialmente VAllocStress.  Se incluyen 20 l√≠neas para demostrar c√≥mo encontrar una reserva de CFG para un proceso.  Tambi√©n agregu√© un c√≥digo de prueba que usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>SetProcessValidCallTargets</i></a> para verificar el valor de los bits CFG y demostrar los trucos necesarios para llamarlos con √©xito (sugerencia: ¬°llamar a trav√©s de GetProcAddress es probable que viole los CFG!) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421153/">https://habr.com/ru/post/es421153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421139/index.html">Frontend Conf - cuidando al usuario</a></li>
<li><a href="../es421141/index.html">An√°lisis de mutaciones o c√≥mo evaluar las pruebas.</a></li>
<li><a href="../es421143/index.html">Aurora Labs S-Titanium Pro Mini impresora 3D de metal</a></li>
<li><a href="../es421147/index.html">Monstruos despu√©s de las vacaciones: AMD Threadripper 2990WX 32-Core y 2950X 16-Core</a></li>
<li><a href="../es421149/index.html">Algunas palabras sobre gradientes</a></li>
<li><a href="../es421155/index.html">Impresi√≥n 3D en 2018: lo m√°s interesante de la industria</a></li>
<li><a href="../es421157/index.html">Facebook investigar√° sobre IRM con IA</a></li>
<li><a href="../es421159/index.html">¬øC√≥mo encontrar un mentor / mentor de negocios?</a></li>
<li><a href="../es421161/index.html">Seguridad de la informaci√≥n de los pagos bancarios sin efectivo. Parte 7 - Modelo b√°sico de amenazas</a></li>
<li><a href="../es421163/index.html">¬øExiste una alternativa de Excel a la presupuestaci√≥n y la inteligencia empresarial?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>