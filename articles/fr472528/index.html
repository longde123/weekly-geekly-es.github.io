<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👬 🚼 👩🏼‍🎨 Essayer la précharge (PHP 7.4) et RoadRunner 😜 🤪 ✌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Nous écrivons et parlons souvent des performances PHP: comment nous les traitons en général, comment nous avons économisé 1 million ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Essayer la précharge (PHP 7.4) et RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/472528/"><img src="https://habrastorage.org/webt/mu/-7/aw/mu-7awhkx6dstts3atuaodnhsm4.jpeg"><br><br>  Bonjour, Habr! <br><br>  Nous écrivons et parlons souvent des performances PHP: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment nous les traitons</a> en général, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment nous avons économisé</a> 1 million de dollars lors du passage à PHP 7.0, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduisons</a> également divers documents sur ce sujet.  Cela est dû au fait que l'audience de nos produits augmente, et la mise à l'échelle du backend PHP avec du fer est lourde de coûts importants - nous avons 600 serveurs avec PHP-FPM.  Par conséquent, investir du temps dans l'optimisation est bénéfique pour nous. <br><br>  Avant, nous parlions principalement des façons habituelles et déjà établies de travailler avec la productivité.  Mais la communauté PHP est en alerte!  JIT apparaîtra en PHP 8, la précharge apparaîtra en PHP 7.4 et des frameworks en dehors du framework de développement PHP de base seront développés, qui supposent que PHP fonctionne comme un démon.  Il est temps d'expérimenter quelque chose de nouveau et de voir ce que cela peut nous apporter. <br><br>  Étant donné que la sortie de PHP 8 est encore loin et que les cadres asynchrones sont mal adaptés à nos tâches (pourquoi - je le dirai ci-dessous), nous nous concentrerons aujourd'hui sur la précharge, qui apparaîtra dans PHP 7.4, et le cadre pour diaboliser PHP, RoadRunner. <br><br>  Ceci est la version texte de mon rapport avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Badoo PHP Meetup # 3</a> .  Vidéo de tous les discours que nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avons recueillis dans ce post</a> . <a name="habracut"></a><br><br>  PHP-FPM, Apache mod_php, et des méthodes similaires pour exécuter des scripts PHP et traiter des demandes (qui sont exécutées par la grande majorité des sites et des services; pour plus de simplicité, je les appellerai PHP «classiques») fonctionnent sur la base de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rien-partagé</a> au sens large du terme: <br><br><ul><li>  l'état n'est pas fouillé entre les travailleurs PHP; <br></li><li>  l'état n'est pas fouillé entre les différentes requêtes. <br></li></ul><br>  Considérez ceci avec un exemple de script simple: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); //   $name = $storage-&gt;getById($_COOKIE['city_id']); echo " : {$name}";</span></span></code> </pre> <br>  Pour chaque demande, le script est exécuté de la première à la dernière ligne: malgré le fait que l'initialisation, très probablement, ne différera pas de la demande à la demande et qu'elle peut potentiellement être effectuée une fois (économie de ressources), vous devez toujours la répéter pour chaque demande.  Nous ne pouvons pas simplement prendre et enregistrer des variables (par exemple, <code>$app</code> ) entre les requêtes en raison des particularités du fonctionnement du PHP «classique». <br><br>  À quoi cela ressemblerait-il si nous sortions du cadre du PHP «classique»?  Par exemple, notre script pourrait s'exécuter indépendamment de la demande, initialiser et avoir une boucle de requête à l'intérieur, dans laquelle il attendrait la suivante, la traiterait et répéterait la boucle sans nettoyer l'environnement (ci-après j'appellerai cette solution «PHP comme un démon "). <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); $cities = $storage-&gt;getAll(); //    while ($req = getNextRequest()) {    $name = $cities[$req-&gt;getCookie('city_id')];    echo " : {$name}"; }</span></span></code> </pre> <br>  Nous pouvions non seulement nous débarrasser de l'initialisation répétée pour chaque demande, mais aussi enregistrer une fois la liste des villes dans la variable <code>$cities</code> et l'utiliser à partir de diverses demandes sans accéder à n'importe où sauf à la mémoire (c'est le moyen le plus rapide pour obtenir des données). <br><br>  Les performances d'une telle solution sont potentiellement significativement supérieures à celles du PHP "classique".  Mais généralement, l'augmentation de la productivité n'est pas gratuite - vous devez en payer le prix.  Voyons ce que cela peut être dans notre cas. <br><br>  Pour ce faire, compliquons un peu notre script et au lieu d'afficher la variable <code>$name</code> , nous remplirons le tableau: <br><br><pre> <code class="php hljs">-  $name = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)]; +  $names[] = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)];</code> </pre><br>  Dans le cas de PHP «classique», aucun problème ne se posera - à la fin de la requête, la variable <code>$name</code> sera détruite et chaque requête suivante fonctionnera comme prévu.  Dans le cas du démarrage de PHP en tant que démon, chaque requête ajoutera une autre ville à cette variable, ce qui entraînera une croissance incontrôlée du tableau jusqu'à ce que la mémoire soit épuisée sur la machine. <br><br>  En général, non seulement la mémoire peut se terminer, mais d'autres erreurs peuvent survenir et entraîner la mort du processus.  Avec de tels problèmes, PHP "classique" gère automatiquement.  Dans le cas du démarrage de PHP en tant que démon, nous devons en quelque sorte surveiller ce démon, le redémarrer s'il se bloque. <br><br>  Les erreurs de ce type sont désagréables, mais il existe des solutions efficaces pour les résoudre.  C'est bien pire si, en raison d'une erreur, le script ne tombe pas, mais modifie de façon imprévisible les valeurs de certaines variables (par exemple, il efface le tableau <code>$cities</code> ).  Dans ce cas, toutes les demandes ultérieures fonctionneront avec des données incorrectes. <br><br><blockquote>  Pour résumer, il est plus facile d'écrire du code pour PHP «classique» (PHP-FPM, Apache mod_php et similaires) - cela nous libère d'un certain nombre de problèmes et d'erreurs.  Mais pour cela, nous payons avec des performances. </blockquote><br>  D'après les exemples ci-dessus, nous voyons que dans certaines parties du code, PHP dépense des ressources qui n'auraient pas pu être dépensées (ou gaspillées une fois) pour traiter chaque demande de la «classique».  Ce sont les domaines suivants: <br><br><ul><li>  connexion de fichiers (inclure, exiger, etc.); <br></li><li>  initialisation (framework, bibliothèques, conteneur DI, etc.); <br></li><li>  demander des données à un stockage externe (au lieu de les stocker en mémoire). <br></li></ul><br>  PHP existe depuis de nombreuses années et peut même être devenu populaire grâce à ce modèle de travail.  Pendant ce temps, de nombreuses méthodes de divers degrés de succès ont été développées pour résoudre le problème décrit.  J'en ai mentionné quelques-uns dans mon précédent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> .  Aujourd'hui, nous allons nous attarder sur deux solutions assez nouvelles pour la communauté: la précharge et RoadRunner. <br><br><h2>  Précharge </h2><br>  Parmi les trois points énumérés ci-dessus, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">précharge est</a> conçue pour gérer la première surcharge lors de la connexion de fichiers.  À première vue, cela peut sembler étrange et dénué de sens, car PHP a déjà OPcache, qui a été créé juste à cet effet.  Pour comprendre l'essence, profilons le réel à l'aide de <code>perf</code> , sur lequel OPcache est activé, avec un taux de réussite égal à 100%. <br><br><img src="https://habrastorage.org/webt/rb/y-/jo/rby-jo2hcsjsu3ncjnjxjmbggny.png"><br><br>  Malgré OPcache, nous voyons que <code>persistent_compile_file</code> prend 5,84% du temps d'exécution de la requête. <br><br>  Afin de comprendre pourquoi cela se produit, nous pouvons regarder les sources de <a href="">zend_accel_load_script</a> .  On peut voir d'eux que, malgré la présence d'OPcache, à chaque appel à <code>include/require</code> signatures des classes et des fonctions sont copiées de la mémoire partagée vers la mémoire du processus de travail, et divers travaux auxiliaires sont effectués.  Et ce travail doit être fait pour chaque demande, car à la fin de celle-ci la mémoire du processus de travail est effacée. <br><br><img src="https://habrastorage.org/webt/6j/nj/zl/6jnjzlelhihw5j5fsgo5bmlluxw.png"><br><br>  Ceci est aggravé par le grand nombre d'appels inclus / requis que nous faisons habituellement en une seule demande.  Par exemple, Symfony 4 comprend environ 310 fichiers avant d'exécuter la première ligne de code utile.  Parfois, cela se produit implicitement: pour créer une instance de classe A, illustrée ci-dessous, PHP chargera automatiquement toutes les autres classes (B, C, D, E, F, G).  Et surtout à cet égard, les dépendances de Composer qui déclarent des fonctions se démarquent: pour garantir que ces fonctions seront disponibles pendant l'exécution du code utilisateur, Composer est toujours obligé de les connecter indépendamment de leur utilisation, car PHP n'a pas de fonctions de chargement automatique et elles ne peuvent pas être chargé au moment de l'appel. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1; }</code> </pre> <br><br><h3>  Fonctionnement de la précharge </h3><br>  Le préchargement a un seul paramètre principal, opcache.preload, dans lequel le chemin d'accès au script PHP est transmis.  Ce script sera exécuté une fois lors du démarrage de PHP-FPM / Apache /, etc., et toutes les signatures des classes, méthodes et fonctions qui seront déclarées dans ce fichier seront disponibles pour tous les scripts qui traitent les requêtes depuis la première ligne de leur exécution (important note: ceci ne s'applique pas aux variables et constantes globales - leurs valeurs seront remises à zéro après la fin de la phase de précharge).  Vous n'avez plus besoin de faire des appels include / require et de copier les signatures de fonction / classe de la mémoire partagée vers la mémoire de processus: tous sont déclarés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">immuables</a> et de ce fait, tous les processus peuvent se référer au même emplacement de mémoire qui les contient. <br><br>  Habituellement, les classes et les fonctions dont nous avons besoin se trouvent dans des fichiers différents et il n'est pas pratique de les combiner en un seul script de préchargement.  Mais cela n'a pas besoin d'être fait: comme le préchargement est un script PHP normal, nous pouvons simplement utiliser include / require ou opcache_compile_file () du script de préchargement pour tous les fichiers dont nous avons besoin.  De plus, étant donné que tous ces fichiers seront chargés une seule fois, PHP pourra effectuer des optimisations supplémentaires qui ne pourraient pas être effectuées pendant que nous connections séparément ces fichiers au moment de la requête.  PHP n'effectue des optimisations que dans le cadre de chaque fichier séparé, mais dans le cas du préchargement, pour tout le code chargé dans la phase de préchargement. <br><br><h3>  Précharge des références </h3><br>  Afin de démontrer en pratique les avantages de la précharge, j'ai pris un point de terminaison lié au processeur Badoo.  Notre backend est généralement caractérisé par une charge liée au CPU.  Ce fait est la réponse à la question de savoir pourquoi nous n'avons pas considéré les frameworks asynchrones: ils ne donnent aucun avantage dans le cas d'une charge liée au CPU et en même temps compliquent encore plus le code (il doit être écrit différemment), ainsi que pour travailler avec un réseau, un disque, etc. des pilotes asynchrones spéciaux sont requis. <br><br>  Afin d'apprécier pleinement les avantages de la précharge, pour l'expérience, j'ai téléchargé avec elle tous les fichiers nécessaires au script testé au travail, et je l'ai chargé avec un semblant de charge de production normale en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wrk2</a> - un analogue plus avancé d'Apache Benchmark, mais tout aussi simple . <br><br>  Pour essayer le préchargement, vous devez d'abord mettre à niveau vers PHP 7.4 (nous avons maintenant PHP 7.2).  J'ai mesuré les performances de PHP 7.2, PHP 7.4 sans précharge et PHP 7.4 avec précharge.  Le résultat est une telle image: <br><br><img src="https://habrastorage.org/webt/sm/ea/5_/smea5_e3kck5zwyk44afzp8ut9u.png"><br><br>  Ainsi, la transition de PHP 7.2 à PHP 7.4 donne + 10% aux performances de notre point de terminaison, et la précharge donne encore 10% d'en haut. <br><br>  Dans le cas de la précharge, les résultats dépendront grandement du nombre de fichiers connectés et de la complexité de la logique exécutable: si de nombreux fichiers sont connectés et que la logique est simple, la précharge donnera plus que s'il y a peu de fichiers et que la logique est complexe. <br><br><h3>  Les nuances de la précharge </h3><br>  Ce qui augmente la productivité a généralement un inconvénient.  La précharge a beaucoup de nuances, que je donnerai ci-dessous.  Ils doivent tous être pris en compte, mais un seul (premier) peut être fondamental. <br><br><h4>  Changer - redémarrer </h4><br>  Étant donné que tous les fichiers de préchargement sont compilés uniquement au démarrage, marqués comme immuables et non recompilés à l'avenir, la seule façon d'appliquer des modifications à ces fichiers est de redémarrer (recharger ou redémarrer) PHP-FPM / Apache /, etc. <br><br>  Dans le cas du rechargement, PHP essaie de redémarrer le plus précisément possible: les requêtes des utilisateurs ne seront pas interrompues, mais néanmoins, pendant la phase de préchargement, toutes les nouvelles requêtes attendront qu'elle se termine.  S'il n'y a pas beaucoup de code en préchargement, cela ne peut pas poser de problèmes, mais si vous essayez de télécharger l'application entière, cela entraîne une augmentation significative du temps de réponse lors du redémarrage. <br><br>  En outre, un redémarrage (qu'il s'agisse de recharger ou de redémarrer) a une fonctionnalité importante - à la suite de cette action, OPcache est effacé.  Autrement dit, toutes les demandes après cela fonctionneront avec un cache d'opcode froid, ce qui peut augmenter encore plus le temps de réponse. <br><br><h4>  Caractères indéfinis </h4><br>  Pour que la précharge charge une classe, tout ce dont elle dépend doit être défini jusqu'à ce point.  Pour la classe ci-dessous, cela signifie que toutes les autres classes (B, C, D, E, F, G), la variable <code>$someGlobalVar</code> et la constante SOME_CONST doivent être disponibles avant de compiler cette classe.  Comme le script de préchargement n'est que du code PHP normal, nous pouvons définir un chargeur automatique.  Dans ce cas, tout ce qui est connecté avec d'autres classes sera automatiquement chargé par lui.  Mais cela ne fonctionne pas avec des variables et des constantes: nous devons nous-mêmes nous assurer qu'elles sont définies au moment où cette classe est déclarée. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $varLink = $someGlobalVar;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $constLink = SOME_CONST; }</code> </pre> <br>  Heureusement, la précharge contient suffisamment d'outils pour comprendre si vous obtenez quelque chose ou non.  Tout d'abord, ce sont des messages d'avertissement contenant des informations sur ce qui n'a pas pu être chargé et pourquoi: <br><br><pre> <code class="plaintext hljs">PHP Warning: Can't preload class MyTestClass with unresolved initializer for constant RAND in /local/preload-internal.php on line 6 PHP Warning: Can't preload unlinked class MyTestClass: Unknown parent AnotherClass in /local/preload-internal.php on line 5</code> </pre> <br>  Deuxièmement, le préchargement ajoute une section distincte au résultat de la fonction opcache_get_status (), qui montre ce qui a été chargé avec succès dans la phase de préchargement: <br><br><img src="https://habrastorage.org/webt/j7/fh/6u/j7fh6u0ww7plxxrx_x8fguxcazu.png"><br><br><h4>  Champ de classe / optimisation constante </h4><br>  Comme je l'ai écrit ci-dessus, la précharge résout les valeurs des champs / constantes de la classe et les enregistre.  Cela vous permet d'optimiser le code: lors du traitement de la demande, les données sont prêtes et n'ont pas besoin d'être dérivées d'autres données.  Mais cela peut conduire à des résultats non évidents, comme le montre l'exemple suivant: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span>.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> define(<span class="hljs-string"><span class="hljs-string">'MYTESTCONST'</span></span>, mt_rand(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>));</code> </pre> <br><pre> <code class="php hljs">preload.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestClass</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RAND = MYTESTCONST; }</code> </pre> <br><pre> <code class="php hljs">script.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> MYTESTCONST, <span class="hljs-string"><span class="hljs-string">', '</span></span>, MyTestClass::RAND; <span class="hljs-comment"><span class="hljs-comment">// 32, 154</span></span></code> </pre> <br>  Le résultat est une situation contre-intuitive: il semblerait que les constantes devraient être égales, puisque l'une d'elles a été affectée à la valeur de l'autre, mais en réalité ce n'est pas le cas.  Cela est dû au fait que les constantes globales, contrairement aux constantes / champs de classe, sont effacées de force après la fin de la phase de préchargement, tandis que les constantes / champs de classe sont résolus et enregistrés.  Cela conduit au fait que lors de l'exécution de la demande, nous devons redéfinir la constante globale, ce qui permet d'obtenir une valeur différente. <br><br><h4>  Impossible de redéclarer someFunc () </h4><br>  Dans le cas des classes, la situation est simple: généralement nous ne les connectons pas explicitement, mais utilisons un chargeur automatique.  Cela signifie que si une classe est définie dans la phase de préchargement, l'autochargeur ne s'exécutera tout simplement pas pendant la demande et nous n'essaierons pas de connecter cette classe une deuxième fois. <br><br>  La situation est différente avec les fonctions: nous devons les connecter explicitement.  Cela peut conduire à une situation où, dans le script de préchargement, nous connecterons tous les fichiers nécessaires avec des fonctions, et pendant la demande, nous essaierons de le faire à nouveau (un exemple typique est le chargeur de démarrage Composer: il essaiera toujours de connecter tous les fichiers avec des fonctions).  Dans ce cas, nous obtenons une erreur: la fonction a déjà été définie et ne peut pas être redéfinie. <br><br>  Ce problème peut être résolu de différentes manières.  Dans le cas de Composer, vous pouvez, par exemple, tout connecter dans la phase de préchargement, et pendant les requêtes ne connectez rien du tout lié à Composer.  Une autre solution n'est pas de connecter directement des fichiers avec des fonctions, mais de le faire via un fichier proxy avec une vérification de function_exists (), comme, par exemple, Guzzle HTTP le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fait</a> . <br><br><img src="https://habrastorage.org/webt/8h/4f/bd/8h4fbddjiu5zbd3xycfnwrdxrmi.png"><br><br><h4>  PHP 7.4 n'a pas encore officiellement publié (encore) </h4><br>  Cette nuance deviendra inutile après un certain temps, mais jusqu'à ce que la version PHP 7.4 ne soit pas encore officiellement publiée et que l'équipe PHP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrive</a> explicitement dans les notes de publication: "Veuillez NE PAS utiliser cette version en production, c'est une version de test précoce."  Au cours de nos expériences avec la précharge, nous avons rencontré plusieurs bugs, nous les avons corrigés nous-mêmes et avons même <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">envoyé</a> quelque chose en amont.  Pour éviter les surprises, il vaut mieux attendre la sortie officielle. <br><br><h2>  Roadrunner </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RoadRunner</a> est un démon écrit en Go, qui, d'une part, crée des travailleurs PHP et les surveille (démarre / finit / redémarre si nécessaire), et d'autre part, accepte les demandes et les transmet à ces travailleurs.  En ce sens, son travail n'est pas différent de celui de PHP-FPM (où il existe également un processus maître qui surveille les travailleurs).  Mais il y a encore des différences.  La clé est que RoadRunner ne réinitialise pas l'état du script après la fin de la requête. <br><br>  Ainsi, si nous rappelons notre liste des ressources dépensées dans le cas du PHP «classique», RoadRunner vous permet de traiter tous les points (la précharge, comme nous le rappelons, ne concerne que le premier): <br><br><ul><li>  connexion de fichiers (inclure, exiger, etc.); <br></li><li>  initialisation (framework, bibliothèques, conteneur DI, etc.); <br></li><li>  demander des données à un stockage externe (au lieu de les stocker en mémoire). <br></li></ul><br>  L'exemple Hello World RoadRunner ressemble à ceci: <br><br><pre> <code class="php hljs">$relay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\Goridge\StreamRelay(STDIN, STDOUT); $psr7 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\PSR7Client(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\Worker($relay)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {        $resp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>);        $psr7-&gt;respond($resp); }</code> </pre> <br>  Nous allons essayer notre point de terminaison actuel, que nous avons testé avec précharge, pour fonctionner sur RoadRunner sans modifications, le charger et mesurer les performances.  Aucune modification - car sinon, la référence ne sera pas complètement honnête. <br><br>  Essayons d'adapter l'exemple Hello World pour cela. <br><br>  Premièrement, comme je l'ai écrit plus haut, nous ne voulons pas que le travailleur tombe en cas d'erreur.  Pour ce faire, nous devons tout emballer dans un try..catch global.  Deuxièmement, puisque notre script ne sait rien de Zend Diactoros, pour la réponse, nous aurons besoin de convertir ses résultats.  Pour cela, nous utilisons des fonctions ob_.  Troisièmement, notre script ne sait rien de la nature de la demande PSR-7.  La solution consiste à remplir l'environnement PHP standard à partir de ces entités.  Et quatrièmement, notre script s'attend à ce que la demande meure et l'état entier sera effacé.  Par conséquent, avec RoadRunner, nous devrons effectuer ce nettoyage nous-mêmes. <br><br>  Ainsi, la version initiale de Hello World se transforme en quelque chose comme ceci: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {    <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {        $uri = $req-&gt;getUri();        $_COOKIE = $req-&gt;getCookieParams();        $_POST = $req-&gt;getParsedBody();        $_SERVER = [            <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; $req-&gt;getMethod(),            <span class="hljs-string"><span class="hljs-string">'HTTP_HOST'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'DOCUMENT_URI'</span></span> =&gt; $uri-&gt;getPath(),            <span class="hljs-string"><span class="hljs-string">'SERVER_NAME'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'QUERY_STRING'</span></span> =&gt; $uri-&gt;getQuery(),            <span class="hljs-comment"><span class="hljs-comment">// ...        ];        ob_start();        // our logic here        $output = ob_get_contents();        ob_clean();               $resp = new \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write($output, 200);        $psr7-&gt;respond($resp);    } catch (\Throwable $Throwable) {        // some error handling logic here    }    \UDS\Event::flush();    \PinbaClient::sendAll();    \PinbaClient::flushAll();    \HTTP::clear();    \ViewFactory::clear();    \Logger::clearCaches();       // ... }</span></span></code> </pre> <br><br><h3>  Benchmarks RoadRunner </h3><br>  Eh bien, il est temps de lancer des benchmarks. <br><br><img src="https://habrastorage.org/webt/qs/6b/89/qs6b89wrabygtu6ea6d-8i9rk4m.png"><br><br>  Les résultats ne répondent pas aux attentes: RoadRunner vous permet de niveler plus de facteurs causant des pertes de performances que la précharge, mais les résultats sont pires.  Voyons pourquoi cela se produit, comme toujours, en exécutant perf pour cela. <br><br><img src="https://habrastorage.org/webt/1w/v9/ft/1wv9ftxnmcdxiu48rrkftw1phic.png"><br><br>  Dans les résultats de perf, nous voyons phar_compile_file.  En effet, nous incluons certains fichiers lors de l'exécution du script, et comme OPcache n'est pas activé (RoadRunner exécute les scripts en tant que CLI, où OPcache est désactivé par défaut), ces fichiers sont à nouveau compilés avec chaque demande. <br><br>  Modifiez la configuration de RoadRunner - activez OPcache: <br><br><img src="https://habrastorage.org/webt/-d/zq/wn/-dzqwnysszz3zcpek82a2wtr9wy.png"><br><br><img src="https://habrastorage.org/webt/zt/tp/1w/zttp1w-bl-5xkho85gi1-7d5pek.png"><br><br>  Ces résultats ressemblent déjà davantage à ce que nous attendions: RoadRunner a commencé à montrer plus de performances que la précharge.  Mais peut-être pourrons-nous en obtenir encore plus! <br><br>  Il ne semble rien de plus inhabituel avec perf - regardons le code PHP.  La façon la plus simple de le profiler est d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">phpspy</a> : il ne nécessite aucune modification du code PHP - il suffit de l'exécuter dans la console.  Faisons cela et construisons un graphique de flamme: <br><br><img src="https://habrastorage.org/webt/60/2k/yk/602kykwmxdw1nxaudop0omr98bi.png"><br><br>  Puisque nous avons accepté de ne pas modifier la logique de notre application pour la pureté de l'expérience, nous nous intéressons à la branche stack associée aux travaux de RoadRunner: <br><br><img src="https://habrastorage.org/webt/ta/ag/yz/taagyz-8en1khhrka80i_al2dry.png"><br><br>  La partie principale de cela se résume à appeler fread (), presque rien ne peut être fait avec cela.  Mais nous voyons d'autres branches dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">\ Spiral \ RoadRunner \ PSR7Client :: acceptRequest ()</a> , à l'exception de fread lui-même.  Vous pouvez comprendre leur signification en regardant le code source: <br><br><pre> <code class="php hljs">   <span class="hljs-comment"><span class="hljs-comment">/**     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ServerRequestInterface|null     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">    </span></span>{        $rawRequest = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;httpClient-&gt;acceptRequest();        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rawRequest === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;        }        $_SERVER = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;configureServer($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>]);        $request = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;requestFactory-&gt;createServerRequest(            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'method'</span></span>],            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uri'</span></span>],            $_SERVER        );        parse_str($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'rawQuery'</span></span>], $query);        $request = $request            -&gt;withProtocolVersion(<span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::fetchProtocolVersion($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'protocol'</span></span>]))            -&gt;withCookieParams($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'cookies'</span></span>])            -&gt;withQueryParams($query)            -&gt;withUploadedFiles(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;wrapUploads($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uploads'</span></span>]));</code> </pre> <br>  Il devient clair que RoadRunner essaie de créer un objet de requête compatible PSR-7 à l'aide d'un tableau sérialisé.  Si votre framework fonctionne directement avec les objets de requête PSR-7 (par exemple, Symfony <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne fonctionne pas</a> ), cela est parfaitement justifié.  Dans d'autres cas, le PSR-7 devient un lien supplémentaire avant que la demande ne soit convertie en ce avec quoi votre application peut fonctionner.  Supprimons ce lien intermédiaire et examinons à nouveau les résultats: <br><br><img src="https://habrastorage.org/webt/jv/mr/p5/jvmrp567zwsjhft2ocuimx8jk1q.png"><br><br>  Le script de test était assez facile, j'ai donc réussi à dégager une part significative des performances - + 17% par rapport au PHP pur (je me souviens que la précharge donne + 10% sur le même script). <br><br><h3>  Nuances de RoadRunner </h3><br>  En général, l'utilisation de RoadRunner est un changement plus sérieux que la simple inclusion de la précharge, donc les nuances ici sont encore plus importantes. <br><br> -, RoadRunner,  ,  PHP-   ,   ,     ,       :    ,   ,      . <br><br> -,      RoadRunner ,     «»    —      .         /   RoadRunner  ; ,      ,        ,            ,  -   . <br><br> -,        endpoint', , ,       RoadRunner.       . <br><br><h2>  Conclusion </h2><br> ,    «» PHP,   ,     preload       RoadRunner. <br><br> PHP  «»   (PHP-FPM, Apache mod_php  )       .       -    ,       .  ,         ,     preload    JIT. <br><br>   ,    , ,       RoadRunner,         . <br><br>    ,      (:           ): <br><br><ul><li> PHP 7.2 — 845 RPS; <br></li><li> PHP 7.4 — 931 RPS; <br></li><li> RoadRunner   — 987 RPS; <br></li><li> PHP 7.4 + preload — 1030 RPS; <br></li><li> RoadRunner   — 1089 RPS. <br></li></ul><br>   Badoo      PHP 7.4       ,         (    ). <br><br> RoadRunner      ,   ,         ,      ,   . <br><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472528/">https://habr.com/ru/post/fr472528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472516/index.html">Yandex.Translator pour Linux sur Python + GTK3</a></li>
<li><a href="../fr472520/index.html">Kits de formation de la vidéo - rapidement et efficacement</a></li>
<li><a href="../fr472522/index.html">Le livre "Développement continu de l'API. Les bonnes décisions dans un paysage technologique en évolution »</a></li>
<li><a href="../fr472524/index.html">Espace, grilles et dispositions</a></li>
<li><a href="../fr472526/index.html">La 3D s'envole: un nouveau composite pour l'aéronautique a été créé, qui a permis de réduire la masse des pièces de 20%</a></li>
<li><a href="../fr472530/index.html">Vidéosurveillance à Moscou: réalités et perspectives actuelles</a></li>
<li><a href="../fr472532/index.html">Lien d'aide utile pour les spécialistes du marketing</a></li>
<li><a href="../fr472534/index.html">Ils se réveillent! (Roman N.-F., partie 1 de 2)</a></li>
<li><a href="../fr472536/index.html">SDK Smart IdReader - intégrer la reconnaissance dans les projets en Python et PHP</a></li>
<li><a href="../fr472540/index.html">Ils se réveillent! (n.-f. histoire, partie 2 et dernière)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>