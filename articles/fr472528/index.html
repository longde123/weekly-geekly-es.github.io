<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¨ üöº üë©üèº‚Äçüé® Essayer la pr√©charge (PHP 7.4) et RoadRunner üòú ü§™ ‚úåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Nous √©crivons et parlons souvent des performances PHP: comment nous les traitons en g√©n√©ral, comment nous avons √©conomis√© 1 million ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Essayer la pr√©charge (PHP 7.4) et RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/472528/"><img src="https://habrastorage.org/webt/mu/-7/aw/mu-7awhkx6dstts3atuaodnhsm4.jpeg"><br><br>  Bonjour, Habr! <br><br>  Nous √©crivons et parlons souvent des performances PHP: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment nous les traitons</a> en g√©n√©ral, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment nous avons √©conomis√©</a> 1 million de dollars lors du passage √† PHP 7.0, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduisons</a> √©galement divers documents sur ce sujet.  Cela est d√ª au fait que l'audience de nos produits augmente, et la mise √† l'√©chelle du backend PHP avec du fer est lourde de co√ªts importants - nous avons 600 serveurs avec PHP-FPM.  Par cons√©quent, investir du temps dans l'optimisation est b√©n√©fique pour nous. <br><br>  Avant, nous parlions principalement des fa√ßons habituelles et d√©j√† √©tablies de travailler avec la productivit√©.  Mais la communaut√© PHP est en alerte!  JIT appara√Ætra en PHP 8, la pr√©charge appara√Ætra en PHP 7.4 et des frameworks en dehors du framework de d√©veloppement PHP de base seront d√©velopp√©s, qui supposent que PHP fonctionne comme un d√©mon.  Il est temps d'exp√©rimenter quelque chose de nouveau et de voir ce que cela peut nous apporter. <br><br>  √âtant donn√© que la sortie de PHP 8 est encore loin et que les cadres asynchrones sont mal adapt√©s √† nos t√¢ches (pourquoi - je le dirai ci-dessous), nous nous concentrerons aujourd'hui sur la pr√©charge, qui appara√Ætra dans PHP 7.4, et le cadre pour diaboliser PHP, RoadRunner. <br><br>  Ceci est la version texte de mon rapport avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Badoo PHP Meetup # 3</a> .  Vid√©o de tous les discours que nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avons recueillis dans ce post</a> . <a name="habracut"></a><br><br>  PHP-FPM, Apache mod_php, et des m√©thodes similaires pour ex√©cuter des scripts PHP et traiter des demandes (qui sont ex√©cut√©es par la grande majorit√© des sites et des services; pour plus de simplicit√©, je les appellerai PHP ¬´classiques¬ª) fonctionnent sur la base de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rien-partag√©</a> au sens large du terme: <br><br><ul><li>  l'√©tat n'est pas fouill√© entre les travailleurs PHP; <br></li><li>  l'√©tat n'est pas fouill√© entre les diff√©rentes requ√™tes. <br></li></ul><br>  Consid√©rez ceci avec un exemple de script simple: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); //   $name = $storage-&gt;getById($_COOKIE['city_id']); echo " : {$name}";</span></span></code> </pre> <br>  Pour chaque demande, le script est ex√©cut√© de la premi√®re √† la derni√®re ligne: malgr√© le fait que l'initialisation, tr√®s probablement, ne diff√©rera pas de la demande √† la demande et qu'elle peut potentiellement √™tre effectu√©e une fois (√©conomie de ressources), vous devez toujours la r√©p√©ter pour chaque demande.  Nous ne pouvons pas simplement prendre et enregistrer des variables (par exemple, <code>$app</code> ) entre les requ√™tes en raison des particularit√©s du fonctionnement du PHP ¬´classique¬ª. <br><br>  √Ä quoi cela ressemblerait-il si nous sortions du cadre du PHP ¬´classique¬ª?  Par exemple, notre script pourrait s'ex√©cuter ind√©pendamment de la demande, initialiser et avoir une boucle de requ√™te √† l'int√©rieur, dans laquelle il attendrait la suivante, la traiterait et r√©p√©terait la boucle sans nettoyer l'environnement (ci-apr√®s j'appellerai cette solution ¬´PHP comme un d√©mon "). <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); $cities = $storage-&gt;getAll(); //    while ($req = getNextRequest()) {    $name = $cities[$req-&gt;getCookie('city_id')];    echo " : {$name}"; }</span></span></code> </pre> <br>  Nous pouvions non seulement nous d√©barrasser de l'initialisation r√©p√©t√©e pour chaque demande, mais aussi enregistrer une fois la liste des villes dans la variable <code>$cities</code> et l'utiliser √† partir de diverses demandes sans acc√©der √† n'importe o√π sauf √† la m√©moire (c'est le moyen le plus rapide pour obtenir des donn√©es). <br><br>  Les performances d'une telle solution sont potentiellement significativement sup√©rieures √† celles du PHP "classique".  Mais g√©n√©ralement, l'augmentation de la productivit√© n'est pas gratuite - vous devez en payer le prix.  Voyons ce que cela peut √™tre dans notre cas. <br><br>  Pour ce faire, compliquons un peu notre script et au lieu d'afficher la variable <code>$name</code> , nous remplirons le tableau: <br><br><pre> <code class="php hljs">-  $name = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)]; +  $names[] = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)];</code> </pre><br>  Dans le cas de PHP ¬´classique¬ª, aucun probl√®me ne se posera - √† la fin de la requ√™te, la variable <code>$name</code> sera d√©truite et chaque requ√™te suivante fonctionnera comme pr√©vu.  Dans le cas du d√©marrage de PHP en tant que d√©mon, chaque requ√™te ajoutera une autre ville √† cette variable, ce qui entra√Ænera une croissance incontr√¥l√©e du tableau jusqu'√† ce que la m√©moire soit √©puis√©e sur la machine. <br><br>  En g√©n√©ral, non seulement la m√©moire peut se terminer, mais d'autres erreurs peuvent survenir et entra√Æner la mort du processus.  Avec de tels probl√®mes, PHP "classique" g√®re automatiquement.  Dans le cas du d√©marrage de PHP en tant que d√©mon, nous devons en quelque sorte surveiller ce d√©mon, le red√©marrer s'il se bloque. <br><br>  Les erreurs de ce type sont d√©sagr√©ables, mais il existe des solutions efficaces pour les r√©soudre.  C'est bien pire si, en raison d'une erreur, le script ne tombe pas, mais modifie de fa√ßon impr√©visible les valeurs de certaines variables (par exemple, il efface le tableau <code>$cities</code> ).  Dans ce cas, toutes les demandes ult√©rieures fonctionneront avec des donn√©es incorrectes. <br><br><blockquote>  Pour r√©sumer, il est plus facile d'√©crire du code pour PHP ¬´classique¬ª (PHP-FPM, Apache mod_php et similaires) - cela nous lib√®re d'un certain nombre de probl√®mes et d'erreurs.  Mais pour cela, nous payons avec des performances. </blockquote><br>  D'apr√®s les exemples ci-dessus, nous voyons que dans certaines parties du code, PHP d√©pense des ressources qui n'auraient pas pu √™tre d√©pens√©es (ou gaspill√©es une fois) pour traiter chaque demande de la ¬´classique¬ª.  Ce sont les domaines suivants: <br><br><ul><li>  connexion de fichiers (inclure, exiger, etc.); <br></li><li>  initialisation (framework, biblioth√®ques, conteneur DI, etc.); <br></li><li>  demander des donn√©es √† un stockage externe (au lieu de les stocker en m√©moire). <br></li></ul><br>  PHP existe depuis de nombreuses ann√©es et peut m√™me √™tre devenu populaire gr√¢ce √† ce mod√®le de travail.  Pendant ce temps, de nombreuses m√©thodes de divers degr√©s de succ√®s ont √©t√© d√©velopp√©es pour r√©soudre le probl√®me d√©crit.  J'en ai mentionn√© quelques-uns dans mon pr√©c√©dent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> .  Aujourd'hui, nous allons nous attarder sur deux solutions assez nouvelles pour la communaut√©: la pr√©charge et RoadRunner. <br><br><h2>  Pr√©charge </h2><br>  Parmi les trois points √©num√©r√©s ci-dessus, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©charge est</a> con√ßue pour g√©rer la premi√®re surcharge lors de la connexion de fichiers.  √Ä premi√®re vue, cela peut sembler √©trange et d√©nu√© de sens, car PHP a d√©j√† OPcache, qui a √©t√© cr√©√© juste √† cet effet.  Pour comprendre l'essence, profilons le r√©el √† l'aide de <code>perf</code> , sur lequel OPcache est activ√©, avec un taux de r√©ussite √©gal √† 100%. <br><br><img src="https://habrastorage.org/webt/rb/y-/jo/rby-jo2hcsjsu3ncjnjxjmbggny.png"><br><br>  Malgr√© OPcache, nous voyons que <code>persistent_compile_file</code> prend 5,84% du temps d'ex√©cution de la requ√™te. <br><br>  Afin de comprendre pourquoi cela se produit, nous pouvons regarder les sources de <a href="">zend_accel_load_script</a> .  On peut voir d'eux que, malgr√© la pr√©sence d'OPcache, √† chaque appel √† <code>include/require</code> signatures des classes et des fonctions sont copi√©es de la m√©moire partag√©e vers la m√©moire du processus de travail, et divers travaux auxiliaires sont effectu√©s.  Et ce travail doit √™tre fait pour chaque demande, car √† la fin de celle-ci la m√©moire du processus de travail est effac√©e. <br><br><img src="https://habrastorage.org/webt/6j/nj/zl/6jnjzlelhihw5j5fsgo5bmlluxw.png"><br><br>  Ceci est aggrav√© par le grand nombre d'appels inclus / requis que nous faisons habituellement en une seule demande.  Par exemple, Symfony 4 comprend environ 310 fichiers avant d'ex√©cuter la premi√®re ligne de code utile.  Parfois, cela se produit implicitement: pour cr√©er une instance de classe A, illustr√©e ci-dessous, PHP chargera automatiquement toutes les autres classes (B, C, D, E, F, G).  Et surtout √† cet √©gard, les d√©pendances de Composer qui d√©clarent des fonctions se d√©marquent: pour garantir que ces fonctions seront disponibles pendant l'ex√©cution du code utilisateur, Composer est toujours oblig√© de les connecter ind√©pendamment de leur utilisation, car PHP n'a pas de fonctions de chargement automatique et elles ne peuvent pas √™tre charg√© au moment de l'appel. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1; }</code> </pre> <br><br><h3>  Fonctionnement de la pr√©charge </h3><br>  Le pr√©chargement a un seul param√®tre principal, opcache.preload, dans lequel le chemin d'acc√®s au script PHP est transmis.  Ce script sera ex√©cut√© une fois lors du d√©marrage de PHP-FPM / Apache /, etc., et toutes les signatures des classes, m√©thodes et fonctions qui seront d√©clar√©es dans ce fichier seront disponibles pour tous les scripts qui traitent les requ√™tes depuis la premi√®re ligne de leur ex√©cution (important note: ceci ne s'applique pas aux variables et constantes globales - leurs valeurs seront remises √† z√©ro apr√®s la fin de la phase de pr√©charge).  Vous n'avez plus besoin de faire des appels include / require et de copier les signatures de fonction / classe de la m√©moire partag√©e vers la m√©moire de processus: tous sont d√©clar√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">immuables</a> et de ce fait, tous les processus peuvent se r√©f√©rer au m√™me emplacement de m√©moire qui les contient. <br><br>  Habituellement, les classes et les fonctions dont nous avons besoin se trouvent dans des fichiers diff√©rents et il n'est pas pratique de les combiner en un seul script de pr√©chargement.  Mais cela n'a pas besoin d'√™tre fait: comme le pr√©chargement est un script PHP normal, nous pouvons simplement utiliser include / require ou opcache_compile_file () du script de pr√©chargement pour tous les fichiers dont nous avons besoin.  De plus, √©tant donn√© que tous ces fichiers seront charg√©s une seule fois, PHP pourra effectuer des optimisations suppl√©mentaires qui ne pourraient pas √™tre effectu√©es pendant que nous connections s√©par√©ment ces fichiers au moment de la requ√™te.  PHP n'effectue des optimisations que dans le cadre de chaque fichier s√©par√©, mais dans le cas du pr√©chargement, pour tout le code charg√© dans la phase de pr√©chargement. <br><br><h3>  Pr√©charge des r√©f√©rences </h3><br>  Afin de d√©montrer en pratique les avantages de la pr√©charge, j'ai pris un point de terminaison li√© au processeur Badoo.  Notre backend est g√©n√©ralement caract√©ris√© par une charge li√©e au CPU.  Ce fait est la r√©ponse √† la question de savoir pourquoi nous n'avons pas consid√©r√© les frameworks asynchrones: ils ne donnent aucun avantage dans le cas d'une charge li√©e au CPU et en m√™me temps compliquent encore plus le code (il doit √™tre √©crit diff√©remment), ainsi que pour travailler avec un r√©seau, un disque, etc. des pilotes asynchrones sp√©ciaux sont requis. <br><br>  Afin d'appr√©cier pleinement les avantages de la pr√©charge, pour l'exp√©rience, j'ai t√©l√©charg√© avec elle tous les fichiers n√©cessaires au script test√© au travail, et je l'ai charg√© avec un semblant de charge de production normale en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wrk2</a> - un analogue plus avanc√© d'Apache Benchmark, mais tout aussi simple . <br><br>  Pour essayer le pr√©chargement, vous devez d'abord mettre √† niveau vers PHP 7.4 (nous avons maintenant PHP 7.2).  J'ai mesur√© les performances de PHP 7.2, PHP 7.4 sans pr√©charge et PHP 7.4 avec pr√©charge.  Le r√©sultat est une telle image: <br><br><img src="https://habrastorage.org/webt/sm/ea/5_/smea5_e3kck5zwyk44afzp8ut9u.png"><br><br>  Ainsi, la transition de PHP 7.2 √† PHP 7.4 donne + 10% aux performances de notre point de terminaison, et la pr√©charge donne encore 10% d'en haut. <br><br>  Dans le cas de la pr√©charge, les r√©sultats d√©pendront grandement du nombre de fichiers connect√©s et de la complexit√© de la logique ex√©cutable: si de nombreux fichiers sont connect√©s et que la logique est simple, la pr√©charge donnera plus que s'il y a peu de fichiers et que la logique est complexe. <br><br><h3>  Les nuances de la pr√©charge </h3><br>  Ce qui augmente la productivit√© a g√©n√©ralement un inconv√©nient.  La pr√©charge a beaucoup de nuances, que je donnerai ci-dessous.  Ils doivent tous √™tre pris en compte, mais un seul (premier) peut √™tre fondamental. <br><br><h4>  Changer - red√©marrer </h4><br>  √âtant donn√© que tous les fichiers de pr√©chargement sont compil√©s uniquement au d√©marrage, marqu√©s comme immuables et non recompil√©s √† l'avenir, la seule fa√ßon d'appliquer des modifications √† ces fichiers est de red√©marrer (recharger ou red√©marrer) PHP-FPM / Apache /, etc. <br><br>  Dans le cas du rechargement, PHP essaie de red√©marrer le plus pr√©cis√©ment possible: les requ√™tes des utilisateurs ne seront pas interrompues, mais n√©anmoins, pendant la phase de pr√©chargement, toutes les nouvelles requ√™tes attendront qu'elle se termine.  S'il n'y a pas beaucoup de code en pr√©chargement, cela ne peut pas poser de probl√®mes, mais si vous essayez de t√©l√©charger l'application enti√®re, cela entra√Æne une augmentation significative du temps de r√©ponse lors du red√©marrage. <br><br>  En outre, un red√©marrage (qu'il s'agisse de recharger ou de red√©marrer) a une fonctionnalit√© importante - √† la suite de cette action, OPcache est effac√©.  Autrement dit, toutes les demandes apr√®s cela fonctionneront avec un cache d'opcode froid, ce qui peut augmenter encore plus le temps de r√©ponse. <br><br><h4>  Caract√®res ind√©finis </h4><br>  Pour que la pr√©charge charge une classe, tout ce dont elle d√©pend doit √™tre d√©fini jusqu'√† ce point.  Pour la classe ci-dessous, cela signifie que toutes les autres classes (B, C, D, E, F, G), la variable <code>$someGlobalVar</code> et la constante SOME_CONST doivent √™tre disponibles avant de compiler cette classe.  Comme le script de pr√©chargement n'est que du code PHP normal, nous pouvons d√©finir un chargeur automatique.  Dans ce cas, tout ce qui est connect√© avec d'autres classes sera automatiquement charg√© par lui.  Mais cela ne fonctionne pas avec des variables et des constantes: nous devons nous-m√™mes nous assurer qu'elles sont d√©finies au moment o√π cette classe est d√©clar√©e. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $varLink = $someGlobalVar;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $constLink = SOME_CONST; }</code> </pre> <br>  Heureusement, la pr√©charge contient suffisamment d'outils pour comprendre si vous obtenez quelque chose ou non.  Tout d'abord, ce sont des messages d'avertissement contenant des informations sur ce qui n'a pas pu √™tre charg√© et pourquoi: <br><br><pre> <code class="plaintext hljs">PHP Warning: Can't preload class MyTestClass with unresolved initializer for constant RAND in /local/preload-internal.php on line 6 PHP Warning: Can't preload unlinked class MyTestClass: Unknown parent AnotherClass in /local/preload-internal.php on line 5</code> </pre> <br>  Deuxi√®mement, le pr√©chargement ajoute une section distincte au r√©sultat de la fonction opcache_get_status (), qui montre ce qui a √©t√© charg√© avec succ√®s dans la phase de pr√©chargement: <br><br><img src="https://habrastorage.org/webt/j7/fh/6u/j7fh6u0ww7plxxrx_x8fguxcazu.png"><br><br><h4>  Champ de classe / optimisation constante </h4><br>  Comme je l'ai √©crit ci-dessus, la pr√©charge r√©sout les valeurs des champs / constantes de la classe et les enregistre.  Cela vous permet d'optimiser le code: lors du traitement de la demande, les donn√©es sont pr√™tes et n'ont pas besoin d'√™tre d√©riv√©es d'autres donn√©es.  Mais cela peut conduire √† des r√©sultats non √©vidents, comme le montre l'exemple suivant: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span>.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> define(<span class="hljs-string"><span class="hljs-string">'MYTESTCONST'</span></span>, mt_rand(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>));</code> </pre> <br><pre> <code class="php hljs">preload.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestClass</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RAND = MYTESTCONST; }</code> </pre> <br><pre> <code class="php hljs">script.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> MYTESTCONST, <span class="hljs-string"><span class="hljs-string">', '</span></span>, MyTestClass::RAND; <span class="hljs-comment"><span class="hljs-comment">// 32, 154</span></span></code> </pre> <br>  Le r√©sultat est une situation contre-intuitive: il semblerait que les constantes devraient √™tre √©gales, puisque l'une d'elles a √©t√© affect√©e √† la valeur de l'autre, mais en r√©alit√© ce n'est pas le cas.  Cela est d√ª au fait que les constantes globales, contrairement aux constantes / champs de classe, sont effac√©es de force apr√®s la fin de la phase de pr√©chargement, tandis que les constantes / champs de classe sont r√©solus et enregistr√©s.  Cela conduit au fait que lors de l'ex√©cution de la demande, nous devons red√©finir la constante globale, ce qui permet d'obtenir une valeur diff√©rente. <br><br><h4>  Impossible de red√©clarer someFunc () </h4><br>  Dans le cas des classes, la situation est simple: g√©n√©ralement nous ne les connectons pas explicitement, mais utilisons un chargeur automatique.  Cela signifie que si une classe est d√©finie dans la phase de pr√©chargement, l'autochargeur ne s'ex√©cutera tout simplement pas pendant la demande et nous n'essaierons pas de connecter cette classe une deuxi√®me fois. <br><br>  La situation est diff√©rente avec les fonctions: nous devons les connecter explicitement.  Cela peut conduire √† une situation o√π, dans le script de pr√©chargement, nous connecterons tous les fichiers n√©cessaires avec des fonctions, et pendant la demande, nous essaierons de le faire √† nouveau (un exemple typique est le chargeur de d√©marrage Composer: il essaiera toujours de connecter tous les fichiers avec des fonctions).  Dans ce cas, nous obtenons une erreur: la fonction a d√©j√† √©t√© d√©finie et ne peut pas √™tre red√©finie. <br><br>  Ce probl√®me peut √™tre r√©solu de diff√©rentes mani√®res.  Dans le cas de Composer, vous pouvez, par exemple, tout connecter dans la phase de pr√©chargement, et pendant les requ√™tes ne connectez rien du tout li√© √† Composer.  Une autre solution n'est pas de connecter directement des fichiers avec des fonctions, mais de le faire via un fichier proxy avec une v√©rification de function_exists (), comme, par exemple, Guzzle HTTP le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fait</a> . <br><br><img src="https://habrastorage.org/webt/8h/4f/bd/8h4fbddjiu5zbd3xycfnwrdxrmi.png"><br><br><h4>  PHP 7.4 n'a pas encore officiellement publi√© (encore) </h4><br>  Cette nuance deviendra inutile apr√®s un certain temps, mais jusqu'√† ce que la version PHP 7.4 ne soit pas encore officiellement publi√©e et que l'√©quipe PHP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©crive</a> explicitement dans les notes de publication: "Veuillez NE PAS utiliser cette version en production, c'est une version de test pr√©coce."  Au cours de nos exp√©riences avec la pr√©charge, nous avons rencontr√© plusieurs bugs, nous les avons corrig√©s nous-m√™mes et avons m√™me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">envoy√©</a> quelque chose en amont.  Pour √©viter les surprises, il vaut mieux attendre la sortie officielle. <br><br><h2>  Roadrunner </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RoadRunner</a> est un d√©mon √©crit en Go, qui, d'une part, cr√©e des travailleurs PHP et les surveille (d√©marre / finit / red√©marre si n√©cessaire), et d'autre part, accepte les demandes et les transmet √† ces travailleurs.  En ce sens, son travail n'est pas diff√©rent de celui de PHP-FPM (o√π il existe √©galement un processus ma√Ætre qui surveille les travailleurs).  Mais il y a encore des diff√©rences.  La cl√© est que RoadRunner ne r√©initialise pas l'√©tat du script apr√®s la fin de la requ√™te. <br><br>  Ainsi, si nous rappelons notre liste des ressources d√©pens√©es dans le cas du PHP ¬´classique¬ª, RoadRunner vous permet de traiter tous les points (la pr√©charge, comme nous le rappelons, ne concerne que le premier): <br><br><ul><li>  connexion de fichiers (inclure, exiger, etc.); <br></li><li>  initialisation (framework, biblioth√®ques, conteneur DI, etc.); <br></li><li>  demander des donn√©es √† un stockage externe (au lieu de les stocker en m√©moire). <br></li></ul><br>  L'exemple Hello World RoadRunner ressemble √† ceci: <br><br><pre> <code class="php hljs">$relay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\Goridge\StreamRelay(STDIN, STDOUT); $psr7 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\PSR7Client(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\Worker($relay)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {        $resp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>);        $psr7-&gt;respond($resp); }</code> </pre> <br>  Nous allons essayer notre point de terminaison actuel, que nous avons test√© avec pr√©charge, pour fonctionner sur RoadRunner sans modifications, le charger et mesurer les performances.  Aucune modification - car sinon, la r√©f√©rence ne sera pas compl√®tement honn√™te. <br><br>  Essayons d'adapter l'exemple Hello World pour cela. <br><br>  Premi√®rement, comme je l'ai √©crit plus haut, nous ne voulons pas que le travailleur tombe en cas d'erreur.  Pour ce faire, nous devons tout emballer dans un try..catch global.  Deuxi√®mement, puisque notre script ne sait rien de Zend Diactoros, pour la r√©ponse, nous aurons besoin de convertir ses r√©sultats.  Pour cela, nous utilisons des fonctions ob_.  Troisi√®mement, notre script ne sait rien de la nature de la demande PSR-7.  La solution consiste √† remplir l'environnement PHP standard √† partir de ces entit√©s.  Et quatri√®mement, notre script s'attend √† ce que la demande meure et l'√©tat entier sera effac√©.  Par cons√©quent, avec RoadRunner, nous devrons effectuer ce nettoyage nous-m√™mes. <br><br>  Ainsi, la version initiale de Hello World se transforme en quelque chose comme ceci: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {    <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {        $uri = $req-&gt;getUri();        $_COOKIE = $req-&gt;getCookieParams();        $_POST = $req-&gt;getParsedBody();        $_SERVER = [            <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; $req-&gt;getMethod(),            <span class="hljs-string"><span class="hljs-string">'HTTP_HOST'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'DOCUMENT_URI'</span></span> =&gt; $uri-&gt;getPath(),            <span class="hljs-string"><span class="hljs-string">'SERVER_NAME'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'QUERY_STRING'</span></span> =&gt; $uri-&gt;getQuery(),            <span class="hljs-comment"><span class="hljs-comment">// ...        ];        ob_start();        // our logic here        $output = ob_get_contents();        ob_clean();               $resp = new \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write($output, 200);        $psr7-&gt;respond($resp);    } catch (\Throwable $Throwable) {        // some error handling logic here    }    \UDS\Event::flush();    \PinbaClient::sendAll();    \PinbaClient::flushAll();    \HTTP::clear();    \ViewFactory::clear();    \Logger::clearCaches();       // ... }</span></span></code> </pre> <br><br><h3>  Benchmarks RoadRunner </h3><br>  Eh bien, il est temps de lancer des benchmarks. <br><br><img src="https://habrastorage.org/webt/qs/6b/89/qs6b89wrabygtu6ea6d-8i9rk4m.png"><br><br>  Les r√©sultats ne r√©pondent pas aux attentes: RoadRunner vous permet de niveler plus de facteurs causant des pertes de performances que la pr√©charge, mais les r√©sultats sont pires.  Voyons pourquoi cela se produit, comme toujours, en ex√©cutant perf pour cela. <br><br><img src="https://habrastorage.org/webt/1w/v9/ft/1wv9ftxnmcdxiu48rrkftw1phic.png"><br><br>  Dans les r√©sultats de perf, nous voyons phar_compile_file.  En effet, nous incluons certains fichiers lors de l'ex√©cution du script, et comme OPcache n'est pas activ√© (RoadRunner ex√©cute les scripts en tant que CLI, o√π OPcache est d√©sactiv√© par d√©faut), ces fichiers sont √† nouveau compil√©s avec chaque demande. <br><br>  Modifiez la configuration de RoadRunner - activez OPcache: <br><br><img src="https://habrastorage.org/webt/-d/zq/wn/-dzqwnysszz3zcpek82a2wtr9wy.png"><br><br><img src="https://habrastorage.org/webt/zt/tp/1w/zttp1w-bl-5xkho85gi1-7d5pek.png"><br><br>  Ces r√©sultats ressemblent d√©j√† davantage √† ce que nous attendions: RoadRunner a commenc√© √† montrer plus de performances que la pr√©charge.  Mais peut-√™tre pourrons-nous en obtenir encore plus! <br><br>  Il ne semble rien de plus inhabituel avec perf - regardons le code PHP.  La fa√ßon la plus simple de le profiler est d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">phpspy</a> : il ne n√©cessite aucune modification du code PHP - il suffit de l'ex√©cuter dans la console.  Faisons cela et construisons un graphique de flamme: <br><br><img src="https://habrastorage.org/webt/60/2k/yk/602kykwmxdw1nxaudop0omr98bi.png"><br><br>  Puisque nous avons accept√© de ne pas modifier la logique de notre application pour la puret√© de l'exp√©rience, nous nous int√©ressons √† la branche stack associ√©e aux travaux de RoadRunner: <br><br><img src="https://habrastorage.org/webt/ta/ag/yz/taagyz-8en1khhrka80i_al2dry.png"><br><br>  La partie principale de cela se r√©sume √† appeler fread (), presque rien ne peut √™tre fait avec cela.  Mais nous voyons d'autres branches dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">\ Spiral \ RoadRunner \ PSR7Client :: acceptRequest ()</a> , √† l'exception de fread lui-m√™me.  Vous pouvez comprendre leur signification en regardant le code source: <br><br><pre> <code class="php hljs">   <span class="hljs-comment"><span class="hljs-comment">/**     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ServerRequestInterface|null     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">    </span></span>{        $rawRequest = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;httpClient-&gt;acceptRequest();        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rawRequest === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;        }        $_SERVER = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;configureServer($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>]);        $request = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;requestFactory-&gt;createServerRequest(            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'method'</span></span>],            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uri'</span></span>],            $_SERVER        );        parse_str($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'rawQuery'</span></span>], $query);        $request = $request            -&gt;withProtocolVersion(<span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::fetchProtocolVersion($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'protocol'</span></span>]))            -&gt;withCookieParams($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'cookies'</span></span>])            -&gt;withQueryParams($query)            -&gt;withUploadedFiles(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;wrapUploads($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uploads'</span></span>]));</code> </pre> <br>  Il devient clair que RoadRunner essaie de cr√©er un objet de requ√™te compatible PSR-7 √† l'aide d'un tableau s√©rialis√©.  Si votre framework fonctionne directement avec les objets de requ√™te PSR-7 (par exemple, Symfony <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne fonctionne pas</a> ), cela est parfaitement justifi√©.  Dans d'autres cas, le PSR-7 devient un lien suppl√©mentaire avant que la demande ne soit convertie en ce avec quoi votre application peut fonctionner.  Supprimons ce lien interm√©diaire et examinons √† nouveau les r√©sultats: <br><br><img src="https://habrastorage.org/webt/jv/mr/p5/jvmrp567zwsjhft2ocuimx8jk1q.png"><br><br>  Le script de test √©tait assez facile, j'ai donc r√©ussi √† d√©gager une part significative des performances - + 17% par rapport au PHP pur (je me souviens que la pr√©charge donne + 10% sur le m√™me script). <br><br><h3>  Nuances de RoadRunner </h3><br>  En g√©n√©ral, l'utilisation de RoadRunner est un changement plus s√©rieux que la simple inclusion de la pr√©charge, donc les nuances ici sont encore plus importantes. <br><br> -, RoadRunner,  ,  PHP-   ,   ,     ,       :    ,   ,      . <br><br> -,      RoadRunner ,     ¬´¬ª    ‚Äî      .         /   RoadRunner  ; ,      ,        ,            ,  -   . <br><br> -,        endpoint', , ,       RoadRunner.       . <br><br><h2>  Conclusion </h2><br> ,    ¬´¬ª PHP,   ,     preload       RoadRunner. <br><br> PHP  ¬´¬ª   (PHP-FPM, Apache mod_php  )       .       -    ,       .  ,         ,     preload    JIT. <br><br>   ,    , ,       RoadRunner,         . <br><br>    ,      (:           ): <br><br><ul><li> PHP 7.2 ‚Äî 845 RPS; <br></li><li> PHP 7.4 ‚Äî 931 RPS; <br></li><li> RoadRunner   ‚Äî 987 RPS; <br></li><li> PHP 7.4 + preload ‚Äî 1030 RPS; <br></li><li> RoadRunner   ‚Äî 1089 RPS. <br></li></ul><br>   Badoo      PHP 7.4       ,         (    ). <br><br> RoadRunner      ,   ,         ,      ,   . <br><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472528/">https://habr.com/ru/post/fr472528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472516/index.html">Yandex.Translator pour Linux sur Python + GTK3</a></li>
<li><a href="../fr472520/index.html">Kits de formation de la vid√©o - rapidement et efficacement</a></li>
<li><a href="../fr472522/index.html">Le livre "D√©veloppement continu de l'API. Les bonnes d√©cisions dans un paysage technologique en √©volution ¬ª</a></li>
<li><a href="../fr472524/index.html">Espace, grilles et dispositions</a></li>
<li><a href="../fr472526/index.html">La 3D s'envole: un nouveau composite pour l'a√©ronautique a √©t√© cr√©√©, qui a permis de r√©duire la masse des pi√®ces de 20%</a></li>
<li><a href="../fr472530/index.html">Vid√©osurveillance √† Moscou: r√©alit√©s et perspectives actuelles</a></li>
<li><a href="../fr472532/index.html">Lien d'aide utile pour les sp√©cialistes du marketing</a></li>
<li><a href="../fr472534/index.html">Ils se r√©veillent! (Roman N.-F., partie 1 de 2)</a></li>
<li><a href="../fr472536/index.html">SDK Smart IdReader - int√©grer la reconnaissance dans les projets en Python et PHP</a></li>
<li><a href="../fr472540/index.html">Ils se r√©veillent! (n.-f. histoire, partie 2 et derni√®re)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>