<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèª üßïüèº üèΩ MVCC en PostgreSQL-7. Autovacuum üòï üë• üëâüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para recordarle, comenzamos con problemas relacionados con el aislamiento , hicimos una digresi√≥n sobre la estructura de datos de bajo nivel , discuti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC en PostgreSQL-7. Autovacuum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/486104/">  Para recordarle, comenzamos con problemas relacionados con el <a href="https://habr.com/ru/company/postgrespro/blog/467437/">aislamiento</a> , hicimos una digresi√≥n sobre <a href="https://habr.com/ru/company/postgrespro/blog/469087/">la estructura de datos de bajo nivel</a> , discutimos las <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versiones de fila</a> en detalle y observamos c√≥mo se obtienen las <a href="https://habr.com/ru/company/postgrespro/blog/479512/">instant√°neas de datos</a> de las versiones de fila. <br><br>  Luego exploramos el <a href="https://habr.com/ru/company/postgrespro/blog/483768/">vac√≠o en la p√°gina (y las actualizaciones HOT)</a> y el <a href="https://habr.com/ru/company/postgrespro/blog/484106/">vac√≠o</a> .  Ahora analizaremos el vac√≠o autom√°tico. <br><br><h1>  Autovacuum </h1><br>  Ya hemos mencionado que normalmente (es decir, cuando nada retiene el horizonte de transacciones durante mucho tiempo) VACUUM generalmente hace su trabajo.  El problema es con qu√© frecuencia llamarlo. <br><br>  Si aspiramos una mesa para cambiar pa√±ales muy raramente, su tama√±o crecer√° m√°s de lo deseado.  Adem√°s, una pr√≥xima operaci√≥n de vac√≠o puede requerir varios pases a trav√©s de √≠ndices si se realizaron demasiados cambios. <br><br>  Si aspiramos la mesa con demasiada frecuencia, el servidor realizar√° constantemente tareas de mantenimiento en lugar de trabajo √∫til, y esto tampoco es bueno. <br><br>  Tenga en cuenta que el lanzamiento de VACUUM en el horario de ninguna manera resuelve el problema porque la carga de trabajo puede cambiar con el tiempo.  Si la tabla comienza a cambiar m√°s intensamente, debe aspirarse con m√°s frecuencia. <br><br>  Autovacuum es exactamente la t√©cnica que nos permite lanzar la aspiradora dependiendo de cu√°n intensivos sean los cambios en la tabla. <br><a name="habracut"></a><br>  Cuando autovacuum est√° activado (el conjunto de par√°metros de configuraci√≥n de <em>autovacuum</em> ), se <strong>inicia el</strong> proceso del demonio del iniciador de <strong>autovacuum</strong> , que planifica el trabajo.  La aspiraci√≥n en s√≠ se realiza mediante procesos de <strong>trabajo de aspiraci√≥n autom√°tica</strong> , varios de los cuales pueden ejecutarse en paralelo. <br><br>  El proceso del <strong>iniciador de autovacuum</strong> compone una lista de bases de datos donde se realiza cualquier actividad.  La actividad se determina a partir de estad√≠sticas y, para recopilarla, se debe establecer el par√°metro <em>track_counts</em> .  Nunca apague <em>autovacuum</em> y <em>track_counts</em> , de lo contrario, la funci√≥n autovacuum no funcionar√°. <br><br>  Una vez cada segundo de <em>autovacuum_naptime</em> segundos, el <strong>iniciador de autovacuum</strong> inicia (utilizando el proceso <strong>postmaster</strong> ) un proceso de trabajo para cada base de datos en la lista.  En otras palabras, si hay alguna actividad en una base de datos, los procesos de trabajo se enviar√°n a ella en un intervalo de <em>autovacuum_naptime</em> segundos.  Con este fin, si hay algunas (N) bases de datos activas disponibles, los procesos de trabajo se <em>inician</em> N veces m√°s que cada segundo de <em>autovacuum_naptime</em> segundos.  Pero el n√∫mero total de procesos de trabajo que se ejecutan simult√°neamente est√° limitado por el par√°metro <em>autovacuum_max_workers</em> . <br><br>  Cuando se inicia, un proceso de trabajo se conecta a la base de datos asignada y comienza con la composici√≥n de una lista de: <br><br><ul><li>  Todas las tablas, vistas materializadas y tablas TOAST que requieren pasar la aspiradora. </li><li>  Todas las tablas y vistas materializadas que requieren an√°lisis (las tablas TOAST no se analizan ya que siempre se alcanzan con acceso al √≠ndice). </li></ul><br>  Luego, el proceso de trabajo pasa la aspiradora y / o analiza los objetos de la lista uno a la vez y se completa cuando finaliza la aspiraci√≥n. <br><br>  Si el proceso no pudo hacer todo el trabajo planificado en segundos de <em>autovacuum_naptime</em> , el proceso de <strong>inicio de autovacuum</strong> enviar√° un proceso de trabajo m√°s a esta base de datos, y trabajar√°n juntos.  ‚ÄúJuntos‚Äù solo significa que el segundo proceso crear√° su propia lista y la superar√°.  Por lo tanto, solo se procesar√°n tablas diferentes en paralelo, pero no hay paralelismo a nivel de una tabla: si uno de los procesos de trabajo ya est√° manejando una tabla, otro proceso lo omitir√° y continuar√°. <br><br>  Ahora aclaremos con m√°s detalle qu√© se entiende por "requiere aspiraci√≥n" y "requiere an√°lisis". <br><br><blockquote>  Recientemente se comprometi√≥ el <a href="https://commitfest.postgresql.org/23/1774/">parche</a> que permite que el vac√≠o procese √≠ndices en paralelo con los trabajadores en segundo plano. <br></blockquote><br><h1>  ¬øQu√© mesas requieren pasar la aspiradora? </h1><br>  Se considera que se requiere aspirar si el n√∫mero de tuplas muertas (es decir, desactualizadas) excede el umbral especificado.  El recopilador de estad√≠sticas realiza un seguimiento permanente del n√∫mero de tuplas muertas, que se almacena en la tabla <code>pg_stat_all_tables</code> .  Y dos par√°metros especifican el umbral: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> define un valor absoluto (el n√∫mero de tuplas). </li><li>  <em>autovacuum_vacuum_scale_factor</em> define el reparto de filas en la tabla. </li></ul><br>  En resumen: se requiere pasar la aspiradora si <code>pg_stat_all_tables.n_dead_tup</code> &gt; = <em>autovacuum_vacuum_threshold</em> + <em>autovacuum_vacuum_scale_factor</em> * <code>pg_class.reltupes</code> . <br><br>  Con la configuraci√≥n predeterminada, <em>autovacuum_vacuum_threshold</em> = 50 y <em>autovacuum_vacuum_scale_factor</em> = 0.2.  <em>autovacuum_vacuum_scale_factor</em> es, sin duda, lo m√°s importante aqu√≠: es este par√°metro el que es cr√≠tico para las tablas grandes (y es a ellas a las que se asocian posibles problemas).  El valor del 20% parece excesivamente alto, y lo m√°s probable es que deba reducirse considerablemente. <br><br>  Los valores √≥ptimos de los par√°metros pueden variar para diferentes tablas y dependen de los tama√±os de tabla y los detalles de los cambios.  Tiene sentido establecer valores generalmente adecuados y, si surge la necesidad, hacer ajustes especiales de los par√°metros a nivel de ciertas tablas mediante par√°metros de almacenamiento: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> y <em>toast.autovacuum_vacuum_threshold</em> . </li><li>  <em>autovacuum_vacuum_scale_factor</em> y <em>toast.autovacuum_vacuum_scale_factor</em> . </li></ul><br>  Para evitar confundirse, es razonable hacerlo solo para unas pocas tablas que se distinguen entre el resto por la cantidad e intensidad de los cambios y solo cuando los valores establecidos globalmente no funcionan bien. <br><br>  Adem√°s, puede desactivar el vac√≠o autom√°tico en el nivel de la mesa (aunque dif√≠cilmente podemos pensar en una raz√≥n por la que podr√≠a ser necesario): <br><br><ul><li>  <em>autovacuum_enabled</em> y <em>toast.autovacuum_enabled</em> . </li></ul><br>  Por ejemplo, la √∫ltima vez que creamos la mesa de aspiraci√≥n con autovac√≠o desactivado para controlar manualmente la aspiraci√≥n con fines de demostraci√≥n.  El par√°metro de almacenamiento se puede cambiar de la siguiente manera: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre><br>  Para formalizar todo lo anterior, creemos una vista que muestre qu√© tablas necesitan pasar la aspiradora en este momento.  Utilizar√° la funci√≥n que devuelve el valor actual del par√°metro y tiene en cuenta que el valor se puede redefinir a nivel de tabla: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_value(param <span class="hljs-type"><span class="hljs-type">text</span></span>, reloptions <span class="hljs-type"><span class="hljs-type">text</span></span>[], relkind "char") <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> SELECT coalesce( -- </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">if</span></span></span><span class="ruby"> the storage parameter is set, we take its value (SELECT option_value FROM pg_options_to_table(reloptions) WHERE option_name = CASE -- </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">for</span></span></span><span class="ruby"> TOAST tables, the parameter name differs WHEN relkind = </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'t'</span></span></span><span class="ruby"> THEN </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'toast.'</span></span></span><span class="ruby"> ELSE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">''</span></span></span><span class="ruby"> </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> param ), -- otherwise, we take the value of the configuration parameter current_setting(param) )</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:</span></span></span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:float</span></span></span><span class="ruby">; $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Y esta es la vista: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_dead_tup dead_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_dead_tup, st.last_autovacuum <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>);</code> </pre><br><h1>  ¬øQu√© tablas requieren an√°lisis? </h1><br>  La situaci√≥n con el an√°lisis autom√°tico es similar.  Se considera que esas tablas requieren un an√°lisis cuyo n√∫mero de tuplas actualizadas (desde el √∫ltimo an√°lisis) excede el umbral especificado por dos par√°metros similares: <code>pg_stat_all_tables.n_mod_since_analyze</code> &gt; = <em>autovacuum_analyze_threshold</em> + <em>autovacuum_analyze_scale_factor</em> * <code>pg_class.reltupes</code> . <br><br>  La configuraci√≥n predeterminada del an√°lisis autom√°tico es algo diferente: <em>autovacuum_analyze_threshold</em> = 50 y <em>autovacuum_analyze_scale_factor</em> = 0.1.  Tambi√©n se pueden definir a nivel de par√°metros de almacenamiento de tablas separadas: <br><br><ul><li>  <em>autovacuum_analyze_threshold</em> </li><li>  <em>autovacuum_analyze_scale_factor</em> </li></ul><br>  Como las tablas TOAST no se analizan, no tienen tales par√°metros. <br><br>  Tambi√©n creemos una vista para el an√°lisis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_mod_since_analyze mod_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_mod_tup, st.last_autoanalyze <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>);</code> </pre><br><h1>  Ejemplo </h1><br>  Establezcamos los siguientes valores de par√°metros para experimentos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> autovacuum_naptime = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- to aviod waiting long =&gt; ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.03; -- 3% =&gt; ALTER SYSTEM SET autovacuum_vacuum_threshold = 0; =&gt; ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02; -- 2% =&gt; ALTER SYSTEM SET autovacuum_analyze_threshold = 0;</span></span></code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br>  Ahora creemos una tabla similar a la utilizada la √∫ltima vez e inserte mil filas en ella.  Autovacuum est√° desactivado en el nivel de la mesa, y lo activaremos nosotros mismos.  Sin esto, los ejemplos no ser√°n reproducibles ya que el autovacuuming puede activarse en un mal momento. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id,<span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>) g(id);</code> </pre><br>  Esto es lo que nuestra visi√≥n para aspirar mostrar√°: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 0 | (1 row)</code> </pre><br>  Aqu√≠ se debe prestar atenci√≥n a dos cosas.  Primero, <code>max_dead_tup</code> = 0, aunque el 3% de 1000 filas forman 30 filas.  Lo que pasa es que todav√≠a no tenemos estad√≠sticas sobre la mesa ya que INSERT no la actualiza por s√≠ sola.  Hasta que se analice la tabla, los ceros permanecer√°n desde <code>pg_class.reltuples</code> = 0. Pero veamos la segunda vista para el an√°lisis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------ public.autovac | 1000 | 0 | (1 row)</code> </pre><br>  Como se han cambiado (agregado) 1000 filas en la tabla, que es mayor que cero, se debe activar el an√°lisis autom√°tico.  Vamos a ver esto: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>);</code> </pre><br>  Despu√©s de una breve pausa, podemos ver que la tabla ha sido analizada y se muestran 20 filas correctas en <code>max_dead_tup</code> en lugar de ceros: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------------------- public.autovac | 0 | 20 | 2019-05-21 11:59:48.465987+03 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltuples, relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> reltuples | relpages -----------+---------- 1000 | 17 (1 row)</code> </pre><br>  Volvamos al autovacuuming: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 30 | (1 row)</code> </pre><br>  Como podemos ver, <code>max_dead_tup</code> ya se ha solucionado.  Otra cosa a la que debe prestar atenci√≥n es que <code>dead_tup</code> = 0. Las estad√≠sticas muestran que la tabla no tiene tuplas muertas ..., y esto es cierto.  Todav√≠a no hay nada que aspirar en la mesa.  Cualquier tabla utilizada exclusivamente en el modo de solo agregar no se pasar√° al vac√≠o y, por lo tanto, el mapa de visibilidad no se actualizar√°.  Pero esto hace que el uso de escaneo de solo √≠ndice sea imposible. <br><br>  (La pr√≥xima vez veremos que pasar la aspiradora tarde o temprano alcanzar√° una tabla de solo agregar, pero esto suceder√° muy raramente). <br><br>  Una lecci√≥n aprendida: si el escaneo de solo √≠ndice es cr√≠tico, puede ser necesario llamar manualmente a un proceso de vac√≠o. <br><br>  Ahora apaguemos el vac√≠o autom√°tico nuevamente y actualicemos 31 l√≠neas, que es una l√≠nea mayor que el umbral. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 31 | 30 | (1 row)</code> </pre><br>  Ahora se cumple la condici√≥n de activaci√≥n por vac√≠o.  Activemos el vac√≠o autom√°tico y despu√©s de una breve pausa veremos que la tabla ha sido procesada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+------------------------------- public.autovac | 0 | 30 | 2019-05-21 11:59:52.554571+03 (1 row)</code> </pre><br><h1>  Estrangulamiento de carga </h1><br>  VACUUM no bloquea otros procesos ya que funciona p√°gina por p√°gina, pero produce una carga adicional en el sistema y puede afectar significativamente el rendimiento. <br><br><h2>  Estrangulamiento por vac√≠o </h2><br>  Para poder controlar la intensidad del vac√≠o y, por lo tanto, su efecto en el sistema, el proceso alterna el trabajo y la espera.  El proceso har√° alrededor de <em>vacuum_cost_limit</em> unidades convencionales de trabajo y luego dormir√° por <em>vacuum_cost_delay</em> ms. <br><br>  Las configuraciones predeterminadas son <em>vacuum_cost_limit</em> = 200 y <em>vacuum_cost_delay</em> = 0. El √∫ltimo cero en realidad significa que VACUUM no duerme, por lo que un valor espec√≠fico de <em>vacuum_cost_limit</em> no importa en absoluto.  El razonamiento detr√°s de esto es que si un administrador tuvo que iniciar VACUUM manualmente, es probable que desee que la aspiradora se realice lo m√°s r√°pido posible. <br><br>  Sin embargo, si establecemos el tiempo de sue√±o, la cantidad de trabajo especificada en <em>vacuum_cost_limit</em> estar√° compuesta por los costos de trabajo con p√°ginas en la memoria cach√© del b√∫fer.  Cada acceso a la p√°gina se estima de la siguiente manera: <br><br><ul><li>  Si la p√°gina se encuentra en la memoria cach√© del b√∫fer, <em>vacuum_cost_page_hit</em> = 1. </li><li>  Si no se encontr√≥, <em>vacuum_cost_page_miss</em> = 10. </li><li>  Si no se encontr√≥ y una p√°gina sucia tuvo que ser desalojada adicionalmente de la memoria cach√© del b√∫fer, <em>vacuum_cost_page_dirty</em> = 20. </li></ul><br>  Es decir, con la configuraci√≥n predeterminada de <em>vacuum_cost_limit</em> , se pueden procesar de una sola vez 200 p√°ginas de cach√© o 20 p√°ginas de disco o 10 p√°ginas con desalojo.  Est√° claro que estas cifras son bastante provisionales, pero no tiene sentido seleccionar las m√°s precisas. <br><br><h2>  Estrangulamiento para autovacuuming </h2><br>  Para procesos de vac√≠o, el estrangulador de carga funciona de la misma manera que para VACUUM.  Pero para los procesos de autovacuum y VACUUM lanzado manualmente para trabajar con diferente intensidad, autovacuum tiene sus propios par√°metros: <em>autovacuum_vacuum_cost_limit</em> y <em>autovacuum_vacuum_cost_delay</em> .  Si estos par√°metros tienen el valor de -1, se utiliza el valor de <em>vacuum_cost_limit</em> y / o <em>vacuum_cost_delay</em> . <br><br>  Por defecto, <em>autovacuum_vacuum_cost_limit</em> = -1 ( <em>es decir</em> , se utiliza el valor de <em>vacuum_cost_limit</em> = 200) y <em>autovacuum_vacuum_cost_delay</em> = 20 ms.  En hardware moderno, el vac√≠o autom√°tico ser√° realmente lento. <br><br>  En la versi√≥n 12, el valor de <em>autovacuum_vacuum_cost_delay</em> se reduce a 2 ms, lo que se puede tomar para una primera aproximaci√≥n m√°s apropiada. <br><br>  Adem√°s, debemos tener en cuenta que el l√≠mite especificado por esta configuraci√≥n es com√∫n para todos los procesos de trabajo.  En otras palabras, cuando se cambia el n√∫mero de procesos de trabajo simult√°neos, la carga general permanece sin cambios.  Por lo tanto, para aumentar el rendimiento de autovacuum, al agregar procesos de trabajo, tiene sentido aumentar tambi√©n <em>autovacuum_vacuum_cost_limit</em> . <br><br><h2>  Uso de memoria y monitoreo. </h2><br>  <a href="https://habr.com/ru/company/postgrespro/blog/484106/">La √∫ltima vez</a> observamos c√≥mo VACUUM usaba RAM de tama√±o <em>maintenance_work_mem</em> para almacenar los <code>tid</code> que se aspirar√≠an. <br><br>  Autovacuum hace absolutamente lo mismo.  Pero puede haber muchos procesos de trabajo simult√°neos si <em>autovacuum_max_workers</em> se establece en un valor grande.  Adem√°s, toda la memoria se asigna a la vez en lugar de cuando surja la necesidad.  Por lo tanto, para un proceso de trabajo, su propia limitaci√≥n se puede establecer mediante el par√°metro <em>autovacuum_work_mem</em> .  El valor predeterminado de este par√°metro es -1, es decir, no se usa. <br><br>  Como ya se mencion√≥, VACUUM tambi√©n puede funcionar con un tama√±o m√≠nimo de memoria.  Pero si se crean √≠ndices en la tabla, un peque√±o valor de <em>maintenance_work_mem</em> puede implicar escaneos de √≠ndice repetidos.  Lo mismo es cierto para autovacuum.  Idealmente, <em>autovacuum_work_mem</em> deber√≠a tener un valor m√≠nimo tal que no ocurran escaneos repetidos. <br><br>  Hemos visto que para monitorear VACUUM, se puede usar la opci√≥n VERBOSE (que no se puede especificar para autovacuum) o la vista <code>pg_stat_progress_vacuum</code> (que, sin embargo, solo muestra la informaci√≥n actual).  Por lo tanto, el principal medio para monitorear el autovacuuming es usar el par√°metro <em>log_autovacuum_min_duration</em> , que env√≠a la informaci√≥n al registro de mensajes del servidor.  Est√° desactivado de forma predeterminada (establecido en -1).  Es razonable activar este par√°metro (con el valor de 0, se generar√° informaci√≥n sobre todas las ejecuciones de vac√≠o autom√°tico) y ver las cifras. <br><br>  As√≠ es como se ve la informaci√≥n de salida: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_autovacuum_min_duration = <span class="hljs-number"><span class="hljs-number">0</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-05-21 11:59:55.675 MSK [9737] LOG: automatic vacuum of table "test.public.autovac": index scans: 0 pages: 0 removed, 18 remain, 0 skipped due to pins, 0 skipped frozen tuples: 31 removed, 1000 remain, 0 are dead but not yet removable, oldest xmin: 4040 buffer usage: 78 hits, 0 misses, 0 dirtied avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s 2019-05-21 11:59:55.676 MSK [9737] LOG: automatic analyze of table "test.public.autovac" system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</code> </pre><br>  Toda la informaci√≥n necesaria est√° disponible aqu√≠. <br><br>  Para recordarle, a menudo tiene sentido reducir el umbral de activaci√≥n por vac√≠o para procesar menos datos a la vez en lugar de aumentar el tama√±o de la memoria. <br><br>  Tambi√©n puede ser razonable usar las vistas anteriores para controlar la longitud de la lista de tablas que requieren pasar la aspiradora.  El aumento de la longitud de la lista indicar√° que los procesos de vac√≠o autom√°tico carecen de tiempo para hacer su trabajo y la configuraci√≥n debe cambiarse. <br><br>  Continuar√° </div></div><p>Source: <a href="https://habr.com/ru/post/486104/">https://habr.com/ru/post/486104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../486070/index.html">ACL cambia en detalle</a></li>
<li><a href="../486080/index.html">Perm√≠tanme presentarles: Veeam Availability Suite v10</a></li>
<li><a href="../486084/index.html">Reemplazar discos m√°s peque√±os con discos m√°s grandes en Linux</a></li>
<li><a href="../486094/index.html">Casa dem√≥crata lucha en Silicon Valley</a></li>
<li><a href="../486100/index.html">¬øC√≥mo crear una aplicaci√≥n descentralizada que escala? Usa menos blockchain</a></li>
<li><a href="../486106/index.html">Luz de fondo adaptable para TV Raspberry Pi - Ambilight Analog</a></li>
<li><a href="../486114/index.html">Cient√≠ficos l√≠deres en el campo de la neurociencia se reunir√°n en el congreso anual del sindicato de la industria neuronet</a></li>
<li><a href="../486116/index.html">Pruebas de simplicidad de Fermat y Miller-Rabin</a></li>
<li><a href="../486120/index.html">Normalizaci√≥n de la desviaci√≥n. C√≥mo las pr√°cticas incorrectas se est√°n convirtiendo en la norma en nuestra industria</a></li>
<li><a href="../486122/index.html">Child ReactJS con 135 l√≠neas de c√≥digo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>