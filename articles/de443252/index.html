<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏼 🎯 🐌 Modulare Ant Bots mit Speicher 👩‍👧 ✔️ 👩🏻‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eines der Projekte, von deren Implementierung ich lange geträumt hatte, waren modulare Task-Bots mit Speicher. Das ultimative Ziel des Projekts war es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modulare Ant Bots mit Speicher</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443252/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/nt/w1/te/ntw1telvkd_gywv-7drpcook6ua.gif"></div><br>  Eines der Projekte, von deren Implementierung ich lange geträumt hatte, waren modulare Task-Bots mit Speicher.  Das ultimative Ziel des Projekts war es, eine Welt mit Kreaturen zu schaffen, die in der Lage sind, unabhängig und gemeinsam zu handeln. <br><br>  Früher habe ich Weltgeneratoren programmiert, deshalb wollte ich die Welt mit einfachen Bots bevölkern, die mithilfe von KI ihr Verhalten und ihre Interaktionen bestimmen.  Dank des Einflusses der Akteure auf die Welt war es somit möglich, ihre Details zu erweitern. <br><br>  Ich habe bereits das grundlegende Javascript-Task-Pipeline-System implementiert (weil es mein Leben vereinfacht hat), aber ich wollte etwas zuverlässigeres und skalierbareres, also habe ich dieses Projekt in C ++ geschrieben.  Der Wettbewerb um die Implementierung des Verfahrensgartens in der Subreddit / r / Verfahrensgeneration hat mich dazu geführt (daher das entsprechende Thema). <br><br>  In meinem System besteht die Simulation aus drei Komponenten: der Welt, der Bevölkerung und einer Reihe von Aktionen, die sie verbinden.  Daher musste ich drei Modelle erstellen, die ich in diesem Artikel diskutieren werde. <br><br>  Um die Schwierigkeit zu erhöhen, wollte ich, dass die Schauspieler Informationen über frühere Erfahrungen mit der Welt behalten und das Wissen über diese Interaktionen in zukünftigen Aktionen nutzen. <br><a name="habracut"></a><br>  Bei der Erstellung eines Weltmodells habe ich einen einfachen Pfad gewählt und Perlin-Rauschen verwendet, um ihn auf der Wasseroberfläche zu platzieren.  Alle anderen Objekte auf der Welt wurden absolut zufällig lokalisiert. <br><br>  Für das Populationsmodell (und sein „Gedächtnis“) habe ich einfach eine Klasse mit mehreren Merkmalen und Koordinaten erstellt.  Dies sollte eine Simulation mit niedriger Auflösung sein.  Speicher ist eine Warteschlange, Bots werden umgesehen, speichern Informationen über ihre Umgebung, schreiben in die Warteschlange und verwalten diese Warteschlange als Interpretation ihres Speichers. <br><br>  Um diese beiden Aktionssysteme miteinander zu verbinden, wollte ich ein Framework primitiver Aufgaben in einem hierarchischen System von Aufgabenwarteschlangen erstellen, damit einzelne Entitäten komplexes Verhalten in der Welt implementieren können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/571/a8c/77b/571a8c77bb291d6802fe9c87b8aa8986.png"></div><br>  <i>Beispielkarte.</i>  <i>Wasser nahm völlig ungewollt die Form eines Flusses an.</i>  <i>Alle anderen Elemente sind zufällig angeordnet, einschließlich des Ameisenhügels, der in diesem Samen zu weit zum Rand verschoben ist (aber der Fluss sieht wunderschön aus).</i> <br><br>  Ich entschied, dass ein Haufen Ameisen im Gras, die Blätter sammeln, ein gutes Testmodell sein wird, das die Zuverlässigkeit der Implementierung der Grundfunktionen (und des gesamten Task-Queue-Systems) garantiert und Speicherlecks verhindert (es gab viele). <br><br>  Ich möchte die Struktur von Aufgabensystemen und Speicher genauer beschreiben und auch zeigen, wie Komplexität aus (meistens) primitiven Grundfunktionen erzeugt wurde.  Ich möchte auch einige lustige „Gedächtnislecks von Ameisen“ zeigen, die auftreten können, wenn die Ameisen auf der Suche nach Gras im Kreis herumlaufen oder still stehen und das Programm verlangsamen. <br><br><h3>  Allgemeine Struktur </h3><br>  Ich habe diese Simulation in C ++ geschrieben und SDL2 zum Rendern verwendet (ich habe bereits zuvor eine kleine Präsentationsklasse für SLD2 geschrieben).  Ich habe auch die A * -Implementierung (leicht modifiziert) verwendet, die ich auf github gefunden habe, weil <em>meine Implementierung</em> hoffnungslos langsam war und ich nicht verstehen konnte, warum. <br><br>  Eine Karte ist nur ein 100 × 100-Raster mit zwei Ebenen - einer Bodenebene (zur Suche nach Pfaden) und einer Füllschicht (zur Vervollständigung von Interaktions- und Suchpfaden).  Die Weltklasse übernimmt auch verschiedene kosmetische Funktionen wie das Wachstum von Gras und Vegetation.  Ich spreche jetzt darüber, weil dies die einzigen Teile sind, die im Artikel nicht beschrieben werden. <br><br><h2>  Die Bevölkerung </h2><br>  Bots waren in einer Klasse mit Eigenschaften, die eine einzelne Kreatur beschreiben.  Einige von ihnen waren kosmetisch, andere beeinflussten die Ausführung von Aktionen (zum Beispiel die Fähigkeit zu fliegen, die Sichtweite, was es isst und was die Kreatur tragen kann). <br><br>  Am wichtigsten waren hier die Hilfswerte, die das Verhalten bestimmen.  Nämlich: ein Vektor, der ihren aktuellen Pfad A * enthält, damit er nicht in jedem Taktzyklus gezählt werden muss (dies spart Rechenzeit und ermöglicht es Ihnen, mehr Bots zu simulieren), und eine Speicherwarteschlange, die die Interpretation ihrer Umgebung durch die Kreaturen definiert. <br><br><h3>  Speicherwarteschlange </h3><br>  Eine Speicherwarteschlange ist eine einfache Warteschlange, die eine Reihe von Speicherobjekten enthält, deren Größe durch eine Bot-Eigenschaft begrenzt ist.  Jedes Mal, wenn neue Erinnerungen hinzugefügt wurden, wurden sie vorangebracht und alles, was über die Grenzen hinausging, wurde abgeschnitten.  Dank dessen könnten einige Erinnerungen „frischer“ sein als andere. <br><br>  Wenn der Bot Informationen aus dem Speicher abrufen wollte, erstellte er ein Speicherobjekt (Anfrage) und verglich es mit dem, was sich im Speicher befand.  Dann gab die Rückruffunktion einen Speichervektor zurück, der einem oder allen in der Abfrage angegebenen Kriterien entspricht. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Memory</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Recall Score int recallScore = 1; //Memory Queryable? Array bool queryable[4] = {false, false, false, false}; //Memory Attributes std::string object; std::string task; Point location; bool reachable;</span></span></code> </pre> <br>  Erinnerungen bestehen aus einem einfachen Objekt, das mehrere Eigenschaften enthält.  Diese Speichereigenschaften werden als "miteinander verbunden" betrachtet.  Jeder Speicher erhält außerdem einen "RecallScore" -Wert, der jedes Mal wiederholt wird, wenn die Erinnerungsfunktion an die Speicher erinnert.  Jedes Mal, wenn sich der Bot an die Speicher erinnert, führt er nacheinander eine Sortierung in einem Durchgang durch, beginnend von hinten, wobei die Reihenfolge der Speicher geändert wird, wenn der Rückrufwert eines älteren Speichers höher ist als der eines neuen Speichers.  Aus diesem Grund sind einige Speicher möglicherweise „wichtiger“ (bei großen Speichergrößen) und werden länger in der Warteschlange gespeichert.  Im Laufe der Zeit werden sie durch neue ersetzt. <br><br><h3>  Speicherwarteschlangen </h3><br>  Ich habe dieser Klasse auch mehrere überladene Operatoren hinzugefügt, damit direkte Vergleiche zwischen der Speicherwarteschlange und der Abfrage durchgeführt werden können, wobei "beliebige" oder "alle" Eigenschaften verglichen werden, sodass beim Überschreiben des Speichers nur die angegebenen Eigenschaften überschrieben werden.  Aus diesem Grund kann der Speicher des Objekts einem bestimmten Ort zugeordnet werden. Wenn wir diesen Ort jedoch erneut betrachten und das Objekt nicht vorhanden ist, können wir den Speicher aktualisieren, indem wir ihn mit dem Speicher überschreiben, der eine neue Füllkachel enthält, wobei die Abfrage verwendet wird, die diesem Ort entspricht . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Bot::updateMemory(Memory &amp;query, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> all, Memory &amp;memory){ <span class="hljs-comment"><span class="hljs-comment">//Loop through all existing Memories //"memories" queue is a member of Bot for(unsigned int i = 0; i &lt; memories.size(); i++){ //If all matches are required and we have all matches if(all &amp;&amp; (memories[i] == query)){ //We have a memory that needs to be updated memories[i] = memory; continue; } //If not all matches are required and any query elements are contained else if(!all &amp;&amp; (memories[i] || query)){ //When overwriting, only overwrite specified quantities memories[i] = memory; continue; } } }</span></span></code> </pre> <br>  Bei der Erstellung des Codes für dieses System habe ich viel gelernt. <br><br><h2>  Aufgabensystem </h2><br>  Die Art der Spielschleife oder des Renderns ist, dass die gleichen Funktionen in jedem Takt wiederholt werden. Ich wollte jedoch nicht zyklisches Verhalten in meinen Bots implementieren. <br><br>  In diesem Abschnitt werde ich zwei Ansichten zur Struktur des Task-Systems erläutern, um diesem Effekt entgegenzuwirken. <br><br><h3>  Bottom-up-Struktur </h3><br>  Ich beschloss, von unten nach oben zu gehen und eine Reihe von „primitiven Aktionen“ zu erstellen, die Bots ausführen sollten.  Jede dieser Aktionen dauert nur einen Schlag.  Mit einer guten Bibliothek primitiver Funktionen können wir sie zu komplexen Aktionen kombinieren, die aus mehreren primitiven Funktionen bestehen. <br><br>  Beispiele für solche primitiven Handlungen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Primitives bool wait(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool look(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool step(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool swap(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool store(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool consume(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool move(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Continue with secondaries here...</span></span></code> </pre> <br>  Beachten Sie, dass diese Aktionen Verweise sowohl auf die Welt als auch auf die Bevölkerung enthalten, sodass Sie sie ändern können. <br><br><ul><li>  Warten bewirkt, dass die Kreatur in dieser Schleife nichts tut. </li><li>  Look analysiert die Umgebung und stellt neue Erinnerungen in die Warteschlange. </li><li>  Swap nimmt einen Gegenstand in die Hand der Kreatur und ersetzt ihn durch einen auf dem Boden liegenden. </li><li>  Verbrauchen zerstört den Gegenstand in der Hand der Kreatur. </li><li>  Schritt nimmt den aktuell berechneten Pfad zum Ziel und führt einen Schritt aus (mit einer Reihe von Fehlerprüfungen). </li><li>  … usw. </li></ul><br>  Alle Aufgabenfunktionen sind Mitglieder meiner Aufgabenklasse.  Nach strengen Tests haben sie ihre Zuverlässigkeit und Fähigkeit bewiesen, sich zu komplexeren Aufgaben zu kombinieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Secondaries bool walk(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool idle(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool search(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool forage(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool take(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Species Masters bool Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool Bee(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); };</span></span></code> </pre> <br>  In diesen sekundären Funktionen konstruieren wir Funktionen, indem wir einfach andere Aufgaben verketten: <br><br><ul><li>  Die Gehaufgabe ist nur ein paar Schritte (mit Fehlerbehandlung) </li><li>  Die Take-Aufgabe ist die Look-and-Swap-Aufgabe (sie wird aufgrund der Ant-Memory-Verarbeitung benötigt, die ich später erläutern werde). </li><li>  Die Leerlaufaufgabe besteht darin, einen zufälligen Ort auszuwählen und sich dorthin zu bewegen (zu Fuß), mehrere Zyklen zu warten (zu warten) und diesen Zyklus eine bestimmte Anzahl von Malen zu wiederholen </li><li>  … usw </li></ul><br>  Andere Aufgaben sind komplizierter.  Die Suchaufgabe führt eine Speicherabfrage aus, um nach Erinnerungen an Orte zu suchen, die das Objekt "food" enthalten (essbar für diesen Bot-Typ).  Sie lädt diese Erinnerungen herunter und geht sie alle um, „sucht“ nach Nahrung (bei Ameisen ist dies Gras).  Wenn es keine Essenserinnerungen gibt, lässt die Aufgabe die Kreatur zufällig die Welt durchstreifen und sich umschauen.  Durch Beobachten und Studieren (durch einen „Blick“ mit viewRadius = 1, dh nur auf die darunter liegende Kachel) kann die Kreatur ihr Gedächtnis mit Informationen über ihre Umgebung aktualisieren und intelligent und gezielt nach Nahrung suchen. <br><br>  Eine allgemeinere Futteraufgabe besteht darin, Lebensmittel zu finden, Lebensmittel aufzunehmen, zu inspizieren (um das Gedächtnis zu aktualisieren und Lebensmittel in der Nachbarschaft zu finden), nach Hause zurückzukehren und Lebensmittel zu lagern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c90/df8/2d8/c90df82d8de8bcf8a9d0de594d2c2e89.gif"></div><br>  <i>Möglicherweise stellen Sie fest, dass die Ameisen aus dem Ameisenhaufen herauskommen und gezielt nach Nahrung suchen.</i>  <i>Aufgrund der Initialisierung wird der Anfangspfad der Ameisen zu einem zufälligen Punkt geleitet, da ihr Speicher bei t = 0 leer ist.</i>  <i>Dann erhalten sie den Befehl, Lebensmittel in der Futteraufgabe aufzunehmen, und sie sehen sich auch um, um sicherzustellen, dass keine Lebensmittel mehr vorhanden sind.</i>  <i>Von Zeit zu Zeit beginnen sie zu wandern, weil ihnen die Orte ausgehen, an denen sie Nahrung sahen (bedrohliche Kurzsichtigkeit).</i> <br><br>  Und schließlich hat der Bot eine „Ansicht“, die die Art der ihm zugewiesenen KI bestimmt.  Jede Ansicht ist einer Steuerungsaufgabe zugeordnet, die ihr gesamtes Verhalten definiert: Sie besteht aus einer Kaskade von immer kleineren Aufgaben, die leicht durch eine Reihe von Speicherwarteschlangen und primitiven Aufgaben bestimmt werden können.  Dies sind Aufgaben wie Ant und Bee. <br><br><h3>  Top-Down-Struktur </h3><br>  Wenn Sie von oben nach unten schauen, besteht das System aus einer Task-Master-Klasse, die Kontrollaufgaben und deren Ausführung für jeden einzelnen Bot auf der Karte koordiniert. <br><br>  Der Taskmaster verfügt über einen Vektor von Steuerungsaufgaben, von denen jede einem Bot zugeordnet ist.  Jede Steuerungsaufgabe verfügt wiederum über eine Warteschlange mit Unteraufgaben, die während der ersten Initialisierung des Aufgabenobjekts mit der zugehörigen Aufgabenfunktion geladen werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Members std::stack&lt;Task&gt; queue; bool initFlag = true; int args[10]; bool (Task::*handle)(Garden&amp;, Population&amp;, int (&amp;)[10]); int botID; std::string name; //Constructor Task(std::string taskName, int taskBotID, bool (Task::*taskHandle)(Garden&amp;, Population&amp;, int (&amp;)[10])){ name = taskName; botID = taskBotID; handle = taskHandle; } //Launch a Task bool perform(Garden &amp;garden, Population &amp;population); //Continue with primitives here...</span></span></code> </pre> <br>  Jedes Task-Objekt in der Warteschlange speichert ein Array von Argumenten, das an den zugehörigen Funktionshandler übergeben wird.  Diese Argumente bestimmen das Verhalten dieser primitiven Aufgaben, die so allgemein wie möglich erstellt werden.  Argumente werden als Referenz übergeben, sodass das Task-Objekt in der Warteschlange seine Argumente speichern und seine Unterfunktionen ändern kann, sodass Sie beispielsweise Iterationen implementieren können, um auf eine bestimmte Anzahl von Ticks zu warten, oder Anforderungen zum Sammeln einer bestimmten Anzahl von Elementen usw.  Unterfunktionen ändern den Wert des Iterators (Argument [n]) der übergeordneten Funktion als Referenz und machen seine Erfolgsbedingung von seinem Wert abhängig. <br><br>  In jeder Kennzahl geht der Taskmaster die Liste der Steuerungsaufgaben durch und führt sie durch Aufrufen ihrer Perform-Methode aus.  Die perform-Methode betrachtet wiederum das oberste Element der Warteschlange innerhalb der Task und führt es mit den Argumenten aus der Task aus.  Auf diese Weise können Sie die Warteschlange der Aufgaben kaskadieren und immer die höchste Aufgabe ausführen.  Dann bestimmt der Rückgabewert der Aufgabe den Abschluss der Aufgabe. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Execute Task Function bool Task::perform(Garden &amp;garden, Population &amp;population){ //Debug Message if(debug){std::cout&lt;&lt;"Bot with ID: "&lt;&lt;botID&lt;&lt;" performing task: "&lt;&lt;name&lt;&lt;std::endl;} //Change the Name and Execute the Task population.bots[botID].task = name; return (*this.*handle)(garden, population, args); }</span></span></code> </pre> <br>  Wenn eine primitive Aufgabe true zurückgibt, hat sie ihren stabilen Punkt erreicht oder sollte zumindest nicht wiederholt werden (z. B. gibt step true zurück, wenn die Kreatur den Endpunkt erreicht hat).  Das heißt, seine Rückgabebedingung ist erfüllt und es wird aus der Warteschlange entfernt, damit die nächste Aufgabe in der nächsten Maßnahme abgeschlossen werden kann. <br><br>  Eine Aufgabe, die eine Aufgabenwarteschlange enthält, gibt true zurück, nachdem die Warteschlange leer ist.  Dank dessen ist es möglich, komplexe Aufgaben mit der Struktur von Warteschlangen und Unterwarteschlangen zu erstellen, in denen ständig dieselben Funktionen aufgerufen werden, aber jeder Aufruf den Spielstatus und den Aufgabenstatus einen Schritt wiederholt. <br><br>  Schließlich verwenden die Steuerungsaufgaben eine einfache Struktur: Sie werden in jedem Zyklus aufgerufen, laden die Aufgabe nur, wenn sie leer sind, und führen ansonsten Aufgaben aus, die in ihre Warteschlange geladen wurden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Species Functions bool Task::Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]){ //Initial Condition if(initFlag){ Task forage("Search for Food", botID, &amp;Task::forage); forage.args[0] = population.bots[botID].forage; //What are we looking for? queue.push(forage); initFlag = false; } //Queue Loop if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ queue.push(newtask); return false; } //If it was successful, we leave it off return false; } //Return Case for Mastertask initFlag = true; return false; }</span></span></code> </pre> <br>  Mit Hilfe meiner Warteschlangenschleife (siehe Code) kann ich wiederholt eine Funktion ausführen und jedes Mal das oberste Element in der Warteschlange ausführen, wobei Elemente aus der Warteschlange herausgeschoben werden, wenn der Aufruf ihrer perform-Methode true zurückgibt. <br><br><h2>  Ergebnisse </h2><br>  All dies ist in libconfig verpackt, sodass die Simulationsparameter sehr einfach geändert werden können.  Sie können viele Kontrollaufgaben problemlos codieren (ich habe Ameisen und Bienen erstellt), und das Definieren und Laden neuer Arten mit libconfig ist überraschend einfach. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Anthill General Configuration File debug = true; //World Generation Parameters seed = 15; water = true; //Species that the simulation recognizes Species: { //Ant Species Ant: { masterTask = "Ant"; color = (0, 0, 0); viewDistance = 2; memorySize = 5; forage = 2; trail = true; fly = false; } Bee: { masterTask = "Bee"; color = (240, 210, 30); viewDistance = 4; memorySize = 30; forage = 4; trail = false; fly = true; } Worm: { masterTask = "Bee"; color = (255, 154, 171); viewDistance = 1; memorySize = 5; forage = 3; trail = true; fly = false; } } Population: ( {species = "Ant"; number = 40;}//, //{species = "Bee"; number = 12;}, //{species = "Worm"; number = 5;} )</span></span></code> </pre> <br>  Sie wurden elegant in die Simulation geladen.  Dank einer neuen, verbesserten Suche nach Pfaden kann ich eine große Anzahl einzelner aktiver Bots simulieren, die Lebensmittel auf einer zweidimensionalen Ebene sammeln. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c30/991/682/c309916821a8538a0dd92db88caf6b6b.gif"></div><br>  <i>Simulation von 40 Ameisen, die gleichzeitig Gras sammeln.</i>  <i>Die Wege, die sie im Sand schaffen, sind auf das erhöhte Gewicht zurückzuführen, das dem „unberührten“ Land zugewiesen wird.</i>  <i>Dies führt zur Schaffung charakteristischer "Ameisenautobahnen".</i>  <i>Sie können auch als Pheromone interpretiert werden, aber es wäre eher die Wahrheit, wenn die Ameisen tatsächlich Erinnerungen austauschen würden.</i> <br><br>  Die Modularität dieses Systems gewährleistet die schnelle Schaffung neuer Arten, deren Verhalten durch eine einfache Kontrollaufgabe bestimmt wird.  Im obigen Code können Sie sehen, dass ich Würmer und KI-Bienen erstellt habe, indem ich einfach ihre Farbe, Pfadsuchbeschränkungen (sie können nicht fliegen), Sichtbarkeitsbereich und Speichergröße geändert habe.  Gleichzeitig habe ich ihr allgemeines Verhalten geändert, da alle diese Parameter von Funktionen primitiver Aufgaben verwendet werden. <br><br><h3>  Debuggen von Ant Memories </h3><br>  Die Struktur komplexer Aufgaben und des Gedächtnisses hat zu unvorhergesehenen Schwierigkeiten und der Notwendigkeit geführt, Ausnahmen zu behandeln. <br><br>  Hier sind drei besonders komplexe Speicherfehler, die mich dazu gebracht haben, die Subsysteme zu wiederholen: <br><br><h4>  Ameisen laufen im Kreis </h4><br>  Einer der ersten Käfer, denen ich begegnen musste: Ameisen rannten wie verrückt auf dem nackten Boden entlang des Musters auf dem Platz.  Dieses Problem trat auf, weil ich zu diesem Zeitpunkt noch keine Speicheraktualisierung implementiert hatte.  Die Ameisen hatten Erinnerungen an den Ort des Essens, und sobald sie das Gras aufnahmen und sich wieder umsahen, bildeten sich neue Erinnerungen. <br><br>  Das Problem war, dass sich der neue Speicher am selben Punkt befand, der alte jedoch erhalten blieb.  Dies bedeutete, dass sich Ameisen bei der Suche nach Nahrung an den Ort der Nahrung erinnerten und diesen behielten, der nicht mehr gültig war, aber diese alten Erinnerungen blieben erhalten und ersetzten neue (sie erinnerten sich an dieses köstliche Kraut). <br><br>  Ich habe es wie folgt behoben: Die Daten des Objekts werden in alten Erinnerungen einfach überschrieben, wenn wir denselben Ort sehen und sich das Objekt geändert hat (zum Beispiel sieht die Kreatur, dass dort kein Gras mehr ist, erinnert sich aber nicht daran, dass es früher Gras gab).  Vielleicht füge ich in Zukunft einfach die Eigenschaft "ungültig" zu den Erinnerungen hinzu, damit sich die Bots an alte Informationen erinnern können, die möglicherweise wichtig sind, aber die Informationen, die nicht mehr gültig sind, "aufgetaucht" sind ("Ich habe hier einen Bären gesehen, aber jetzt ist er weg"). <br><br><h4>  Ameisen nehmen Gegenstände unter anderen Ameisen auf </h4><br>  Von Zeit zu Zeit (insbesondere bei einer großen Anzahl von Ameisen und einer hohen Grasdichte) können zwei Ameisen in einem Takt auf eine Grasfliese gelangen und versuchen, sie aufzunehmen.  Dies bedeutete, dass die erste Ameise die Kachel betrat, sich umsah und den Gegenstand in 3 Schritten nahm.  Die zweite Ameise tat dasselbe, nur kurz bevor sie das Objekt anhob. Eine andere Ameise riss es unter seiner Nase hervor.  Er setzte seine Aufgaben ruhig fort, untersuchte dieselbe Umgebung wie die andere Ameise im vorherigen Takt und verarbeitete seine Speicherzeile auf dieselbe Weise (weil zu diesem Zeitpunkt ihre Erinnerungen identisch sind).  Dies führte dazu, dass die zweite Ameise die erste kopierte, niemals Gegenstände aufnahm und der ersten folgte, was tatsächlich die ganze Arbeit erledigte.  Ich bemerkte dies, weil in der Simulation der fünf Ameisen nur drei sichtbar waren.  Es dauerte lange, bis die Ursache gefunden war. <br><br>  Ich habe dieses Problem gelöst, indem ich die Swap-Aufgabe primitiv gemacht und die Take-Aufgabe erstellt habe, die zuerst auf den Boden schaut, um festzustellen, ob sich dort ein Objekt befindet.  Wenn dies der Fall ist, „tauscht“ es und wenn nicht, „wartet“ es auf zwei Züge, sodass die andere Ameise definitiv geht.  In einem Fall gilt diese Aktion für zwei Maßnahmen, im anderen für eine Maßnahme. <br><br><h4>  Nicht erreichbare Standorte </h4><br>  Ein weiterer unangenehmer Fehler, der mich zwang, die Verarbeitung des Gedächtnisses zu wiederholen, war, dass einige Orte, die die Ameise sehen konnte, für ihn unerreichbar waren.  Sie entstanden aufgrund meiner faulen Platzierung von „Graskreuzen“ an Land, die manchmal über dem Wasser hingen.  Dies brachte mich dazu, die Schrittaufgabe zu verallgemeinern. <br><br>  Bei der Übermittlung einer Anfrage zur Nahrungssuche hatten Ameisen oft Erinnerungen an Orte, die sie wirklich nicht erreichen konnten (sie sahen Gras über dem Wasser und wollten es <em>wahnsinnig</em> sammeln).  Wenn es nicht in ihrem Speicher markiert war (zum Beispiel die boolesche Variable „erreichbar“), erinnerten sie sich weiterhin daran und schrieben in die Warteschlange, bis diese Aktion die einzige war.  Dies verursachte eine starke Hemmung, da sie <em>bei jeder Maßnahme ständig Pfadfindungsoperationen durchführten, versuchten, dorthin zu gelangen, und scheiterten</em> . <br><br>  Die Lösung bestand darin, den Speicher in der Schrittaufgabe zu aktualisieren, wenn der Pfad zum Ort nicht gefunden werden kann, und ihn im Speicher als nicht erreichbar zu markieren.  Darüber hinaus fragt die Suchaufgabe nur Orte mit Lebensmitteln nach erreichbaren Erinnerungen ab. <br><br><h2>  System im Allgemeinen </h2><br>  Im Allgemeinen möchte ich sagen - ja, ich bedauere, dass ich eine Woche meines Lebens mit einem Programmiermarathon verbracht habe, weil ich inspiriert wurde, Bots zu erstellen, die das tun, was ich ihnen sage (und auch, was sie tun wollen!).  Ich musste ein paar Tricks machen und habe viel gelernt. <br><br>  Das von mir erstellte System ist nicht 100% zuverlässig und ich bemerke immer noch einige Artefakte.  Als Richtung für das Parsen des Looks wird die Aktion beispielsweise von oben nach unten und von links nach rechts verwendet, dh der letzte Speicher befindet sich in der unteren rechten Ecke.  Wenn Sie Informationen abrufen, um nach Gegenständen zu suchen, bedeutet dies, dass sich Kreaturen nach Südosten bewegen.  Dies macht sich insbesondere bei großen Simulationen bemerkbar, wenn das Gras unabhängig vom Samen schnell wächst und sich leicht nach Südosten biegt. <br><br><h3>  Verbesserungen </h3><br>  Ich denke, dass signifikante Verbesserungen erforderlich sind, um komplexere Erinnerungen an komplexere Kreaturen zu simulieren. <br><br>  Dies umfasst das Erhöhen der Zuverlässigkeit von Speicherverarbeitungsfunktionen sowie das Hinzufügen neuer Grundelemente wie „Denken“ und Ableitungen von Aufgaben auf hoher Ebene wie „Entscheiden“ oder „Träumen“.  "Denken" kann eine primitive Aktion einer Speicheranforderung sein.  Ein „Traum“ kann wiederum aus mehreren „Denk“ -Aufrufen bestehen: Auswählen eines zufälligen Speichers, Erhalten einer zufälligen Eigenschaft und wiederholtes Wiederholen, um gemeinsame Themen oder wichtige Assoziationen zu verstärken. <br><br>  Für die Zukunft plane ich drei spezifische Ergänzungen: <br><br><ul><li>  Interrupt-Behandlung und Aufgabenpriorisierung hinzufügen </li><li>  Fügen Sie die Kommunikation zwischen Entitäten hinzu </li><li>  Fügen Sie eine Gruppenstruktur hinzu, damit sich Entitäten formal identifizieren können </li></ul><br>  Die Unterbrechung der Verarbeitung und Priorisierung von Aufgaben kann für die Interaktion zwischen Entitäten erforderlich sein, da der Bot seine Aktivitäten nicht blind fortsetzen kann, wenn sie mit ihm kommunizieren (er muss irgendwie „zuhören“) oder angegriffen wird („weglaufen“ oder „kämpfen“). ) <br><br>  Die Kommunikation zwischen Entitäten besteht wahrscheinlich aus einer oder zwei primitiven Aufgaben zum Austauschen von Erinnerungen oder zum Anfordern von Erinnerungen an andere Bots (z. B. "Sagen" oder "Fragen").  Auf diese Weise können Informationen wie der Standort von Lebensmitteln oder andere Ressourcen übertragen werden. <br><br>  Ich hoffe, diese Aufgaben umzusetzen und ein Diagramm der Ressourcenakkumulationsrate einer großen Gruppe mit und ohne Kommunikation zu erstellen.  Die Bevölkerung verfolgt bereits die Menge der in jeder Maßnahme gesammelten Lebensmittel.  Es wäre interessant zu zeigen, dass das Teilen von Erinnerungen die Effizienz beeinträchtigen kann. <br><br><h3>  Die Zukunft </h3><br>  Die wichtigste Funktion zur Simulation von Communities besteht darin, Gruppenstrukturen hinzuzufügen und diese Gruppen mit Eigenschaften auf Makroebene auszustatten, beispielsweise ihren gemeinsamen „Zielen und Verantwortlichkeiten“.  Dies gibt uns eine Art „Keim“, aus dem wir Aufgaben auf hoher Ebene erhalten können, die in der Hierarchie der Gruppenstrukturen an Aufgaben auf niedrigerer Ebene delegiert werden, die sich direkt auf die Welt auswirken.  Es ermöglicht Ihnen auch, eine Form der politischen Struktur zu schaffen. <br><br>  Ein solches System ist völlig autark, und die Visualisierung wird einfach darüber gelegt.  Es wird sehr einfach sein, Insekten durch Humanoide zu ersetzen, Ressourcen zu sammeln und an einem Ort zu lagern, damit sie größer werden.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Art des Wachstums ihres Hauses kann zum Beispiel sehr abhängig oder völlig unabhängig von den Aktionen von Bots sein. </font><font style="vertical-align: inherit;">Verschiedene Arten können unterschiedliche Stämme mit unterschiedlichen Merkmalen und Trends haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Außerdem kann ich dieses System mit zuvor erstellten Kartengeneratoren kombinieren (Erweiterung der Weltklasse), um die Welt realer zu machen.</font></font><br><br><h2>  Abschließend </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In naher Zukunft plane ich, die Kreaturen durch Menschen zu ersetzen und einige der letzten Funktionen zu implementieren. </font><font style="vertical-align: inherit;">Vielleicht werde ich den </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vollständigen Quellcode veröffentlichen,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn ich die Qualität des Systems verbessere (an einigen Stellen ist der Code ziemlich chaotisch). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten Sie auf den nächsten Artikel. </font><font style="vertical-align: inherit;">In der Zwischenzeit ist hier ein Video mit Bienen, die nach Pollen in Blumen suchen. </font><font style="vertical-align: inherit;">Sie werden mit demselben Framework codiert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/b31/7d5/332b317d547edc53f2b2ffee6c3d4861.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe diesen Samen gewählt, weil der Ausgangspunkt auf einer kleinen Insel liegt. </font><font style="vertical-align: inherit;">Die Bienen sind jedoch nicht so programmiert, dass sie in den Bienenstock zurückkehren, sondern sammeln ständig Pollen. </font><font style="vertical-align: inherit;">Möglicherweise stellen Sie fest, dass ihre Sichtweite höher ist und sie sich manchmal sehr absichtlich zu der Blume bewegen, die sie gerade gesehen haben. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... und hier ist die Bee Task-Mitgliedsfunktion:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Task::Bee(Garden &amp;garden, Population &amp;population, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (&amp;arguments)[<span class="hljs-number"><span class="hljs-number">10</span></span>]){ <span class="hljs-comment"><span class="hljs-comment">//Just Search for Flowers if(initFlag){ //Define our Tasks Task take("Take Food", botID, &amp;Task::take); Task eat("Eat Food", botID, &amp;Task::consume); Task search("Locate Food", botID, &amp;Task::search); search.args[0] = population.bots[botID].forage; queue.push(eat); queue.push(take); queue.push(search); initFlag = false; } //Work off our allocated queue. if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ //Put the Task back on queue.push(newtask); } //If it was successful, we leave it off return false; } initFlag = true; return true; }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443252/">https://habr.com/ru/post/de443252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443240/index.html">Q-Learning verstehen, das Problem „Auf einem Felsen gehen“</a></li>
<li><a href="../de443242/index.html">Quarkus ist ein subatomares Überschall-Java. Ein kurzer Überblick über das Framework</a></li>
<li><a href="../de443244/index.html">Nachbesprechungsaufgaben. Beanpoisk_1</a></li>
<li><a href="../de443246/index.html">Wie wir Askozia IP PBX neu erfunden haben, nachdem das Projekt vom Entwickler verkauft und geschlossen wurde</a></li>
<li><a href="../de443248/index.html">Protokolle zur nahtlosen Reservierung von PRP und HSR</a></li>
<li><a href="../de443254/index.html">Triton ist das tödlichste Virus</a></li>
<li><a href="../de443256/index.html">PowerShell, Dump meiner Erfahrung</a></li>
<li><a href="../de443258/index.html">Gotify - ein Open Source-Projekt zum Übermitteln von Benachrichtigungen und zum Senden von Nachrichten an den Server</a></li>
<li><a href="../de443260/index.html">Migrieren Sie nach Zimbra, ohne das Geschäft mit einer gemeinsamen Domain zu riskieren</a></li>
<li><a href="../de443262/index.html">Schlechter Rat: Wie schreibe ich technische Dokumentation? Teil drei und zuletzt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>