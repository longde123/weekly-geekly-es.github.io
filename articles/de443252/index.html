<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèº üéØ üêå Modulare Ant Bots mit Speicher üë©‚Äçüëß ‚úîÔ∏è üë©üèª‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eines der Projekte, von deren Implementierung ich lange getr√§umt hatte, waren modulare Task-Bots mit Speicher. Das ultimative Ziel des Projekts war es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modulare Ant Bots mit Speicher</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443252/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/nt/w1/te/ntw1telvkd_gywv-7drpcook6ua.gif"></div><br>  Eines der Projekte, von deren Implementierung ich lange getr√§umt hatte, waren modulare Task-Bots mit Speicher.  Das ultimative Ziel des Projekts war es, eine Welt mit Kreaturen zu schaffen, die in der Lage sind, unabh√§ngig und gemeinsam zu handeln. <br><br>  Fr√ºher habe ich Weltgeneratoren programmiert, deshalb wollte ich die Welt mit einfachen Bots bev√∂lkern, die mithilfe von KI ihr Verhalten und ihre Interaktionen bestimmen.  Dank des Einflusses der Akteure auf die Welt war es somit m√∂glich, ihre Details zu erweitern. <br><br>  Ich habe bereits das grundlegende Javascript-Task-Pipeline-System implementiert (weil es mein Leben vereinfacht hat), aber ich wollte etwas zuverl√§ssigeres und skalierbareres, also habe ich dieses Projekt in C ++ geschrieben.  Der Wettbewerb um die Implementierung des Verfahrensgartens in der Subreddit / r / Verfahrensgeneration hat mich dazu gef√ºhrt (daher das entsprechende Thema). <br><br>  In meinem System besteht die Simulation aus drei Komponenten: der Welt, der Bev√∂lkerung und einer Reihe von Aktionen, die sie verbinden.  Daher musste ich drei Modelle erstellen, die ich in diesem Artikel diskutieren werde. <br><br>  Um die Schwierigkeit zu erh√∂hen, wollte ich, dass die Schauspieler Informationen √ºber fr√ºhere Erfahrungen mit der Welt behalten und das Wissen √ºber diese Interaktionen in zuk√ºnftigen Aktionen nutzen. <br><a name="habracut"></a><br>  Bei der Erstellung eines Weltmodells habe ich einen einfachen Pfad gew√§hlt und Perlin-Rauschen verwendet, um ihn auf der Wasseroberfl√§che zu platzieren.  Alle anderen Objekte auf der Welt wurden absolut zuf√§llig lokalisiert. <br><br>  F√ºr das Populationsmodell (und sein ‚ÄûGed√§chtnis‚Äú) habe ich einfach eine Klasse mit mehreren Merkmalen und Koordinaten erstellt.  Dies sollte eine Simulation mit niedriger Aufl√∂sung sein.  Speicher ist eine Warteschlange, Bots werden umgesehen, speichern Informationen √ºber ihre Umgebung, schreiben in die Warteschlange und verwalten diese Warteschlange als Interpretation ihres Speichers. <br><br>  Um diese beiden Aktionssysteme miteinander zu verbinden, wollte ich ein Framework primitiver Aufgaben in einem hierarchischen System von Aufgabenwarteschlangen erstellen, damit einzelne Entit√§ten komplexes Verhalten in der Welt implementieren k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/571/a8c/77b/571a8c77bb291d6802fe9c87b8aa8986.png"></div><br>  <i>Beispielkarte.</i>  <i>Wasser nahm v√∂llig ungewollt die Form eines Flusses an.</i>  <i>Alle anderen Elemente sind zuf√§llig angeordnet, einschlie√ülich des Ameisenh√ºgels, der in diesem Samen zu weit zum Rand verschoben ist (aber der Fluss sieht wundersch√∂n aus).</i> <br><br>  Ich entschied, dass ein Haufen Ameisen im Gras, die Bl√§tter sammeln, ein gutes Testmodell sein wird, das die Zuverl√§ssigkeit der Implementierung der Grundfunktionen (und des gesamten Task-Queue-Systems) garantiert und Speicherlecks verhindert (es gab viele). <br><br>  Ich m√∂chte die Struktur von Aufgabensystemen und Speicher genauer beschreiben und auch zeigen, wie Komplexit√§t aus (meistens) primitiven Grundfunktionen erzeugt wurde.  Ich m√∂chte auch einige lustige ‚ÄûGed√§chtnislecks von Ameisen‚Äú zeigen, die auftreten k√∂nnen, wenn die Ameisen auf der Suche nach Gras im Kreis herumlaufen oder still stehen und das Programm verlangsamen. <br><br><h3>  Allgemeine Struktur </h3><br>  Ich habe diese Simulation in C ++ geschrieben und SDL2 zum Rendern verwendet (ich habe bereits zuvor eine kleine Pr√§sentationsklasse f√ºr SLD2 geschrieben).  Ich habe auch die A * -Implementierung (leicht modifiziert) verwendet, die ich auf github gefunden habe, weil <em>meine Implementierung</em> hoffnungslos langsam war und ich nicht verstehen konnte, warum. <br><br>  Eine Karte ist nur ein 100 √ó 100-Raster mit zwei Ebenen - einer Bodenebene (zur Suche nach Pfaden) und einer F√ºllschicht (zur Vervollst√§ndigung von Interaktions- und Suchpfaden).  Die Weltklasse √ºbernimmt auch verschiedene kosmetische Funktionen wie das Wachstum von Gras und Vegetation.  Ich spreche jetzt dar√ºber, weil dies die einzigen Teile sind, die im Artikel nicht beschrieben werden. <br><br><h2>  Die Bev√∂lkerung </h2><br>  Bots waren in einer Klasse mit Eigenschaften, die eine einzelne Kreatur beschreiben.  Einige von ihnen waren kosmetisch, andere beeinflussten die Ausf√ºhrung von Aktionen (zum Beispiel die F√§higkeit zu fliegen, die Sichtweite, was es isst und was die Kreatur tragen kann). <br><br>  Am wichtigsten waren hier die Hilfswerte, die das Verhalten bestimmen.  N√§mlich: ein Vektor, der ihren aktuellen Pfad A * enth√§lt, damit er nicht in jedem Taktzyklus gez√§hlt werden muss (dies spart Rechenzeit und erm√∂glicht es Ihnen, mehr Bots zu simulieren), und eine Speicherwarteschlange, die die Interpretation ihrer Umgebung durch die Kreaturen definiert. <br><br><h3>  Speicherwarteschlange </h3><br>  Eine Speicherwarteschlange ist eine einfache Warteschlange, die eine Reihe von Speicherobjekten enth√§lt, deren Gr√∂√üe durch eine Bot-Eigenschaft begrenzt ist.  Jedes Mal, wenn neue Erinnerungen hinzugef√ºgt wurden, wurden sie vorangebracht und alles, was √ºber die Grenzen hinausging, wurde abgeschnitten.  Dank dessen k√∂nnten einige Erinnerungen ‚Äûfrischer‚Äú sein als andere. <br><br>  Wenn der Bot Informationen aus dem Speicher abrufen wollte, erstellte er ein Speicherobjekt (Anfrage) und verglich es mit dem, was sich im Speicher befand.  Dann gab die R√ºckruffunktion einen Speichervektor zur√ºck, der einem oder allen in der Abfrage angegebenen Kriterien entspricht. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Memory</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Recall Score int recallScore = 1; //Memory Queryable? Array bool queryable[4] = {false, false, false, false}; //Memory Attributes std::string object; std::string task; Point location; bool reachable;</span></span></code> </pre> <br>  Erinnerungen bestehen aus einem einfachen Objekt, das mehrere Eigenschaften enth√§lt.  Diese Speichereigenschaften werden als "miteinander verbunden" betrachtet.  Jeder Speicher erh√§lt au√üerdem einen "RecallScore" -Wert, der jedes Mal wiederholt wird, wenn die Erinnerungsfunktion an die Speicher erinnert.  Jedes Mal, wenn sich der Bot an die Speicher erinnert, f√ºhrt er nacheinander eine Sortierung in einem Durchgang durch, beginnend von hinten, wobei die Reihenfolge der Speicher ge√§ndert wird, wenn der R√ºckrufwert eines √§lteren Speichers h√∂her ist als der eines neuen Speichers.  Aus diesem Grund sind einige Speicher m√∂glicherweise ‚Äûwichtiger‚Äú (bei gro√üen Speichergr√∂√üen) und werden l√§nger in der Warteschlange gespeichert.  Im Laufe der Zeit werden sie durch neue ersetzt. <br><br><h3>  Speicherwarteschlangen </h3><br>  Ich habe dieser Klasse auch mehrere √ºberladene Operatoren hinzugef√ºgt, damit direkte Vergleiche zwischen der Speicherwarteschlange und der Abfrage durchgef√ºhrt werden k√∂nnen, wobei "beliebige" oder "alle" Eigenschaften verglichen werden, sodass beim √úberschreiben des Speichers nur die angegebenen Eigenschaften √ºberschrieben werden.  Aus diesem Grund kann der Speicher des Objekts einem bestimmten Ort zugeordnet werden. Wenn wir diesen Ort jedoch erneut betrachten und das Objekt nicht vorhanden ist, k√∂nnen wir den Speicher aktualisieren, indem wir ihn mit dem Speicher √ºberschreiben, der eine neue F√ºllkachel enth√§lt, wobei die Abfrage verwendet wird, die diesem Ort entspricht . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Bot::updateMemory(Memory &amp;query, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> all, Memory &amp;memory){ <span class="hljs-comment"><span class="hljs-comment">//Loop through all existing Memories //"memories" queue is a member of Bot for(unsigned int i = 0; i &lt; memories.size(); i++){ //If all matches are required and we have all matches if(all &amp;&amp; (memories[i] == query)){ //We have a memory that needs to be updated memories[i] = memory; continue; } //If not all matches are required and any query elements are contained else if(!all &amp;&amp; (memories[i] || query)){ //When overwriting, only overwrite specified quantities memories[i] = memory; continue; } } }</span></span></code> </pre> <br>  Bei der Erstellung des Codes f√ºr dieses System habe ich viel gelernt. <br><br><h2>  Aufgabensystem </h2><br>  Die Art der Spielschleife oder des Renderns ist, dass die gleichen Funktionen in jedem Takt wiederholt werden. Ich wollte jedoch nicht zyklisches Verhalten in meinen Bots implementieren. <br><br>  In diesem Abschnitt werde ich zwei Ansichten zur Struktur des Task-Systems erl√§utern, um diesem Effekt entgegenzuwirken. <br><br><h3>  Bottom-up-Struktur </h3><br>  Ich beschloss, von unten nach oben zu gehen und eine Reihe von ‚Äûprimitiven Aktionen‚Äú zu erstellen, die Bots ausf√ºhren sollten.  Jede dieser Aktionen dauert nur einen Schlag.  Mit einer guten Bibliothek primitiver Funktionen k√∂nnen wir sie zu komplexen Aktionen kombinieren, die aus mehreren primitiven Funktionen bestehen. <br><br>  Beispiele f√ºr solche primitiven Handlungen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Primitives bool wait(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool look(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool step(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool swap(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool store(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool consume(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool move(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Continue with secondaries here...</span></span></code> </pre> <br>  Beachten Sie, dass diese Aktionen Verweise sowohl auf die Welt als auch auf die Bev√∂lkerung enthalten, sodass Sie sie √§ndern k√∂nnen. <br><br><ul><li>  Warten bewirkt, dass die Kreatur in dieser Schleife nichts tut. </li><li>  Look analysiert die Umgebung und stellt neue Erinnerungen in die Warteschlange. </li><li>  Swap nimmt einen Gegenstand in die Hand der Kreatur und ersetzt ihn durch einen auf dem Boden liegenden. </li><li>  Verbrauchen zerst√∂rt den Gegenstand in der Hand der Kreatur. </li><li>  Schritt nimmt den aktuell berechneten Pfad zum Ziel und f√ºhrt einen Schritt aus (mit einer Reihe von Fehlerpr√ºfungen). </li><li>  ‚Ä¶ usw. </li></ul><br>  Alle Aufgabenfunktionen sind Mitglieder meiner Aufgabenklasse.  Nach strengen Tests haben sie ihre Zuverl√§ssigkeit und F√§higkeit bewiesen, sich zu komplexeren Aufgaben zu kombinieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Secondaries bool walk(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool idle(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool search(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool forage(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool take(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Species Masters bool Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool Bee(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); };</span></span></code> </pre> <br>  In diesen sekund√§ren Funktionen konstruieren wir Funktionen, indem wir einfach andere Aufgaben verketten: <br><br><ul><li>  Die Gehaufgabe ist nur ein paar Schritte (mit Fehlerbehandlung) </li><li>  Die Take-Aufgabe ist die Look-and-Swap-Aufgabe (sie wird aufgrund der Ant-Memory-Verarbeitung ben√∂tigt, die ich sp√§ter erl√§utern werde). </li><li>  Die Leerlaufaufgabe besteht darin, einen zuf√§lligen Ort auszuw√§hlen und sich dorthin zu bewegen (zu Fu√ü), mehrere Zyklen zu warten (zu warten) und diesen Zyklus eine bestimmte Anzahl von Malen zu wiederholen </li><li>  ‚Ä¶ usw </li></ul><br>  Andere Aufgaben sind komplizierter.  Die Suchaufgabe f√ºhrt eine Speicherabfrage aus, um nach Erinnerungen an Orte zu suchen, die das Objekt "food" enthalten (essbar f√ºr diesen Bot-Typ).  Sie l√§dt diese Erinnerungen herunter und geht sie alle um, ‚Äûsucht‚Äú nach Nahrung (bei Ameisen ist dies Gras).  Wenn es keine Essenserinnerungen gibt, l√§sst die Aufgabe die Kreatur zuf√§llig die Welt durchstreifen und sich umschauen.  Durch Beobachten und Studieren (durch einen ‚ÄûBlick‚Äú mit viewRadius = 1, dh nur auf die darunter liegende Kachel) kann die Kreatur ihr Ged√§chtnis mit Informationen √ºber ihre Umgebung aktualisieren und intelligent und gezielt nach Nahrung suchen. <br><br>  Eine allgemeinere Futteraufgabe besteht darin, Lebensmittel zu finden, Lebensmittel aufzunehmen, zu inspizieren (um das Ged√§chtnis zu aktualisieren und Lebensmittel in der Nachbarschaft zu finden), nach Hause zur√ºckzukehren und Lebensmittel zu lagern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c90/df8/2d8/c90df82d8de8bcf8a9d0de594d2c2e89.gif"></div><br>  <i>M√∂glicherweise stellen Sie fest, dass die Ameisen aus dem Ameisenhaufen herauskommen und gezielt nach Nahrung suchen.</i>  <i>Aufgrund der Initialisierung wird der Anfangspfad der Ameisen zu einem zuf√§lligen Punkt geleitet, da ihr Speicher bei t = 0 leer ist.</i>  <i>Dann erhalten sie den Befehl, Lebensmittel in der Futteraufgabe aufzunehmen, und sie sehen sich auch um, um sicherzustellen, dass keine Lebensmittel mehr vorhanden sind.</i>  <i>Von Zeit zu Zeit beginnen sie zu wandern, weil ihnen die Orte ausgehen, an denen sie Nahrung sahen (bedrohliche Kurzsichtigkeit).</i> <br><br>  Und schlie√ülich hat der Bot eine ‚ÄûAnsicht‚Äú, die die Art der ihm zugewiesenen KI bestimmt.  Jede Ansicht ist einer Steuerungsaufgabe zugeordnet, die ihr gesamtes Verhalten definiert: Sie besteht aus einer Kaskade von immer kleineren Aufgaben, die leicht durch eine Reihe von Speicherwarteschlangen und primitiven Aufgaben bestimmt werden k√∂nnen.  Dies sind Aufgaben wie Ant und Bee. <br><br><h3>  Top-Down-Struktur </h3><br>  Wenn Sie von oben nach unten schauen, besteht das System aus einer Task-Master-Klasse, die Kontrollaufgaben und deren Ausf√ºhrung f√ºr jeden einzelnen Bot auf der Karte koordiniert. <br><br>  Der Taskmaster verf√ºgt √ºber einen Vektor von Steuerungsaufgaben, von denen jede einem Bot zugeordnet ist.  Jede Steuerungsaufgabe verf√ºgt wiederum √ºber eine Warteschlange mit Unteraufgaben, die w√§hrend der ersten Initialisierung des Aufgabenobjekts mit der zugeh√∂rigen Aufgabenfunktion geladen werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Members std::stack&lt;Task&gt; queue; bool initFlag = true; int args[10]; bool (Task::*handle)(Garden&amp;, Population&amp;, int (&amp;)[10]); int botID; std::string name; //Constructor Task(std::string taskName, int taskBotID, bool (Task::*taskHandle)(Garden&amp;, Population&amp;, int (&amp;)[10])){ name = taskName; botID = taskBotID; handle = taskHandle; } //Launch a Task bool perform(Garden &amp;garden, Population &amp;population); //Continue with primitives here...</span></span></code> </pre> <br>  Jedes Task-Objekt in der Warteschlange speichert ein Array von Argumenten, das an den zugeh√∂rigen Funktionshandler √ºbergeben wird.  Diese Argumente bestimmen das Verhalten dieser primitiven Aufgaben, die so allgemein wie m√∂glich erstellt werden.  Argumente werden als Referenz √ºbergeben, sodass das Task-Objekt in der Warteschlange seine Argumente speichern und seine Unterfunktionen √§ndern kann, sodass Sie beispielsweise Iterationen implementieren k√∂nnen, um auf eine bestimmte Anzahl von Ticks zu warten, oder Anforderungen zum Sammeln einer bestimmten Anzahl von Elementen usw.  Unterfunktionen √§ndern den Wert des Iterators (Argument [n]) der √ºbergeordneten Funktion als Referenz und machen seine Erfolgsbedingung von seinem Wert abh√§ngig. <br><br>  In jeder Kennzahl geht der Taskmaster die Liste der Steuerungsaufgaben durch und f√ºhrt sie durch Aufrufen ihrer Perform-Methode aus.  Die perform-Methode betrachtet wiederum das oberste Element der Warteschlange innerhalb der Task und f√ºhrt es mit den Argumenten aus der Task aus.  Auf diese Weise k√∂nnen Sie die Warteschlange der Aufgaben kaskadieren und immer die h√∂chste Aufgabe ausf√ºhren.  Dann bestimmt der R√ºckgabewert der Aufgabe den Abschluss der Aufgabe. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Execute Task Function bool Task::perform(Garden &amp;garden, Population &amp;population){ //Debug Message if(debug){std::cout&lt;&lt;"Bot with ID: "&lt;&lt;botID&lt;&lt;" performing task: "&lt;&lt;name&lt;&lt;std::endl;} //Change the Name and Execute the Task population.bots[botID].task = name; return (*this.*handle)(garden, population, args); }</span></span></code> </pre> <br>  Wenn eine primitive Aufgabe true zur√ºckgibt, hat sie ihren stabilen Punkt erreicht oder sollte zumindest nicht wiederholt werden (z. B. gibt step true zur√ºck, wenn die Kreatur den Endpunkt erreicht hat).  Das hei√üt, seine R√ºckgabebedingung ist erf√ºllt und es wird aus der Warteschlange entfernt, damit die n√§chste Aufgabe in der n√§chsten Ma√ünahme abgeschlossen werden kann. <br><br>  Eine Aufgabe, die eine Aufgabenwarteschlange enth√§lt, gibt true zur√ºck, nachdem die Warteschlange leer ist.  Dank dessen ist es m√∂glich, komplexe Aufgaben mit der Struktur von Warteschlangen und Unterwarteschlangen zu erstellen, in denen st√§ndig dieselben Funktionen aufgerufen werden, aber jeder Aufruf den Spielstatus und den Aufgabenstatus einen Schritt wiederholt. <br><br>  Schlie√ülich verwenden die Steuerungsaufgaben eine einfache Struktur: Sie werden in jedem Zyklus aufgerufen, laden die Aufgabe nur, wenn sie leer sind, und f√ºhren ansonsten Aufgaben aus, die in ihre Warteschlange geladen wurden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Species Functions bool Task::Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]){ //Initial Condition if(initFlag){ Task forage("Search for Food", botID, &amp;Task::forage); forage.args[0] = population.bots[botID].forage; //What are we looking for? queue.push(forage); initFlag = false; } //Queue Loop if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ queue.push(newtask); return false; } //If it was successful, we leave it off return false; } //Return Case for Mastertask initFlag = true; return false; }</span></span></code> </pre> <br>  Mit Hilfe meiner Warteschlangenschleife (siehe Code) kann ich wiederholt eine Funktion ausf√ºhren und jedes Mal das oberste Element in der Warteschlange ausf√ºhren, wobei Elemente aus der Warteschlange herausgeschoben werden, wenn der Aufruf ihrer perform-Methode true zur√ºckgibt. <br><br><h2>  Ergebnisse </h2><br>  All dies ist in libconfig verpackt, sodass die Simulationsparameter sehr einfach ge√§ndert werden k√∂nnen.  Sie k√∂nnen viele Kontrollaufgaben problemlos codieren (ich habe Ameisen und Bienen erstellt), und das Definieren und Laden neuer Arten mit libconfig ist √ºberraschend einfach. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Anthill General Configuration File debug = true; //World Generation Parameters seed = 15; water = true; //Species that the simulation recognizes Species: { //Ant Species Ant: { masterTask = "Ant"; color = (0, 0, 0); viewDistance = 2; memorySize = 5; forage = 2; trail = true; fly = false; } Bee: { masterTask = "Bee"; color = (240, 210, 30); viewDistance = 4; memorySize = 30; forage = 4; trail = false; fly = true; } Worm: { masterTask = "Bee"; color = (255, 154, 171); viewDistance = 1; memorySize = 5; forage = 3; trail = true; fly = false; } } Population: ( {species = "Ant"; number = 40;}//, //{species = "Bee"; number = 12;}, //{species = "Worm"; number = 5;} )</span></span></code> </pre> <br>  Sie wurden elegant in die Simulation geladen.  Dank einer neuen, verbesserten Suche nach Pfaden kann ich eine gro√üe Anzahl einzelner aktiver Bots simulieren, die Lebensmittel auf einer zweidimensionalen Ebene sammeln. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c30/991/682/c309916821a8538a0dd92db88caf6b6b.gif"></div><br>  <i>Simulation von 40 Ameisen, die gleichzeitig Gras sammeln.</i>  <i>Die Wege, die sie im Sand schaffen, sind auf das erh√∂hte Gewicht zur√ºckzuf√ºhren, das dem ‚Äûunber√ºhrten‚Äú Land zugewiesen wird.</i>  <i>Dies f√ºhrt zur Schaffung charakteristischer "Ameisenautobahnen".</i>  <i>Sie k√∂nnen auch als Pheromone interpretiert werden, aber es w√§re eher die Wahrheit, wenn die Ameisen tats√§chlich Erinnerungen austauschen w√ºrden.</i> <br><br>  Die Modularit√§t dieses Systems gew√§hrleistet die schnelle Schaffung neuer Arten, deren Verhalten durch eine einfache Kontrollaufgabe bestimmt wird.  Im obigen Code k√∂nnen Sie sehen, dass ich W√ºrmer und KI-Bienen erstellt habe, indem ich einfach ihre Farbe, Pfadsuchbeschr√§nkungen (sie k√∂nnen nicht fliegen), Sichtbarkeitsbereich und Speichergr√∂√üe ge√§ndert habe.  Gleichzeitig habe ich ihr allgemeines Verhalten ge√§ndert, da alle diese Parameter von Funktionen primitiver Aufgaben verwendet werden. <br><br><h3>  Debuggen von Ant Memories </h3><br>  Die Struktur komplexer Aufgaben und des Ged√§chtnisses hat zu unvorhergesehenen Schwierigkeiten und der Notwendigkeit gef√ºhrt, Ausnahmen zu behandeln. <br><br>  Hier sind drei besonders komplexe Speicherfehler, die mich dazu gebracht haben, die Subsysteme zu wiederholen: <br><br><h4>  Ameisen laufen im Kreis </h4><br>  Einer der ersten K√§fer, denen ich begegnen musste: Ameisen rannten wie verr√ºckt auf dem nackten Boden entlang des Musters auf dem Platz.  Dieses Problem trat auf, weil ich zu diesem Zeitpunkt noch keine Speicheraktualisierung implementiert hatte.  Die Ameisen hatten Erinnerungen an den Ort des Essens, und sobald sie das Gras aufnahmen und sich wieder umsahen, bildeten sich neue Erinnerungen. <br><br>  Das Problem war, dass sich der neue Speicher am selben Punkt befand, der alte jedoch erhalten blieb.  Dies bedeutete, dass sich Ameisen bei der Suche nach Nahrung an den Ort der Nahrung erinnerten und diesen behielten, der nicht mehr g√ºltig war, aber diese alten Erinnerungen blieben erhalten und ersetzten neue (sie erinnerten sich an dieses k√∂stliche Kraut). <br><br>  Ich habe es wie folgt behoben: Die Daten des Objekts werden in alten Erinnerungen einfach √ºberschrieben, wenn wir denselben Ort sehen und sich das Objekt ge√§ndert hat (zum Beispiel sieht die Kreatur, dass dort kein Gras mehr ist, erinnert sich aber nicht daran, dass es fr√ºher Gras gab).  Vielleicht f√ºge ich in Zukunft einfach die Eigenschaft "ung√ºltig" zu den Erinnerungen hinzu, damit sich die Bots an alte Informationen erinnern k√∂nnen, die m√∂glicherweise wichtig sind, aber die Informationen, die nicht mehr g√ºltig sind, "aufgetaucht" sind ("Ich habe hier einen B√§ren gesehen, aber jetzt ist er weg"). <br><br><h4>  Ameisen nehmen Gegenst√§nde unter anderen Ameisen auf </h4><br>  Von Zeit zu Zeit (insbesondere bei einer gro√üen Anzahl von Ameisen und einer hohen Grasdichte) k√∂nnen zwei Ameisen in einem Takt auf eine Grasfliese gelangen und versuchen, sie aufzunehmen.  Dies bedeutete, dass die erste Ameise die Kachel betrat, sich umsah und den Gegenstand in 3 Schritten nahm.  Die zweite Ameise tat dasselbe, nur kurz bevor sie das Objekt anhob. Eine andere Ameise riss es unter seiner Nase hervor.  Er setzte seine Aufgaben ruhig fort, untersuchte dieselbe Umgebung wie die andere Ameise im vorherigen Takt und verarbeitete seine Speicherzeile auf dieselbe Weise (weil zu diesem Zeitpunkt ihre Erinnerungen identisch sind).  Dies f√ºhrte dazu, dass die zweite Ameise die erste kopierte, niemals Gegenst√§nde aufnahm und der ersten folgte, was tats√§chlich die ganze Arbeit erledigte.  Ich bemerkte dies, weil in der Simulation der f√ºnf Ameisen nur drei sichtbar waren.  Es dauerte lange, bis die Ursache gefunden war. <br><br>  Ich habe dieses Problem gel√∂st, indem ich die Swap-Aufgabe primitiv gemacht und die Take-Aufgabe erstellt habe, die zuerst auf den Boden schaut, um festzustellen, ob sich dort ein Objekt befindet.  Wenn dies der Fall ist, ‚Äûtauscht‚Äú es und wenn nicht, ‚Äûwartet‚Äú es auf zwei Z√ºge, sodass die andere Ameise definitiv geht.  In einem Fall gilt diese Aktion f√ºr zwei Ma√ünahmen, im anderen f√ºr eine Ma√ünahme. <br><br><h4>  Nicht erreichbare Standorte </h4><br>  Ein weiterer unangenehmer Fehler, der mich zwang, die Verarbeitung des Ged√§chtnisses zu wiederholen, war, dass einige Orte, die die Ameise sehen konnte, f√ºr ihn unerreichbar waren.  Sie entstanden aufgrund meiner faulen Platzierung von ‚ÄûGraskreuzen‚Äú an Land, die manchmal √ºber dem Wasser hingen.  Dies brachte mich dazu, die Schrittaufgabe zu verallgemeinern. <br><br>  Bei der √úbermittlung einer Anfrage zur Nahrungssuche hatten Ameisen oft Erinnerungen an Orte, die sie wirklich nicht erreichen konnten (sie sahen Gras √ºber dem Wasser und wollten es <em>wahnsinnig</em> sammeln).  Wenn es nicht in ihrem Speicher markiert war (zum Beispiel die boolesche Variable ‚Äûerreichbar‚Äú), erinnerten sie sich weiterhin daran und schrieben in die Warteschlange, bis diese Aktion die einzige war.  Dies verursachte eine starke Hemmung, da sie <em>bei jeder Ma√ünahme st√§ndig Pfadfindungsoperationen durchf√ºhrten, versuchten, dorthin zu gelangen, und scheiterten</em> . <br><br>  Die L√∂sung bestand darin, den Speicher in der Schrittaufgabe zu aktualisieren, wenn der Pfad zum Ort nicht gefunden werden kann, und ihn im Speicher als nicht erreichbar zu markieren.  Dar√ºber hinaus fragt die Suchaufgabe nur Orte mit Lebensmitteln nach erreichbaren Erinnerungen ab. <br><br><h2>  System im Allgemeinen </h2><br>  Im Allgemeinen m√∂chte ich sagen - ja, ich bedauere, dass ich eine Woche meines Lebens mit einem Programmiermarathon verbracht habe, weil ich inspiriert wurde, Bots zu erstellen, die das tun, was ich ihnen sage (und auch, was sie tun wollen!).  Ich musste ein paar Tricks machen und habe viel gelernt. <br><br>  Das von mir erstellte System ist nicht 100% zuverl√§ssig und ich bemerke immer noch einige Artefakte.  Als Richtung f√ºr das Parsen des Looks wird die Aktion beispielsweise von oben nach unten und von links nach rechts verwendet, dh der letzte Speicher befindet sich in der unteren rechten Ecke.  Wenn Sie Informationen abrufen, um nach Gegenst√§nden zu suchen, bedeutet dies, dass sich Kreaturen nach S√ºdosten bewegen.  Dies macht sich insbesondere bei gro√üen Simulationen bemerkbar, wenn das Gras unabh√§ngig vom Samen schnell w√§chst und sich leicht nach S√ºdosten biegt. <br><br><h3>  Verbesserungen </h3><br>  Ich denke, dass signifikante Verbesserungen erforderlich sind, um komplexere Erinnerungen an komplexere Kreaturen zu simulieren. <br><br>  Dies umfasst das Erh√∂hen der Zuverl√§ssigkeit von Speicherverarbeitungsfunktionen sowie das Hinzuf√ºgen neuer Grundelemente wie ‚ÄûDenken‚Äú und Ableitungen von Aufgaben auf hoher Ebene wie ‚ÄûEntscheiden‚Äú oder ‚ÄûTr√§umen‚Äú.  "Denken" kann eine primitive Aktion einer Speicheranforderung sein.  Ein ‚ÄûTraum‚Äú kann wiederum aus mehreren ‚ÄûDenk‚Äú -Aufrufen bestehen: Ausw√§hlen eines zuf√§lligen Speichers, Erhalten einer zuf√§lligen Eigenschaft und wiederholtes Wiederholen, um gemeinsame Themen oder wichtige Assoziationen zu verst√§rken. <br><br>  F√ºr die Zukunft plane ich drei spezifische Erg√§nzungen: <br><br><ul><li>  Interrupt-Behandlung und Aufgabenpriorisierung hinzuf√ºgen </li><li>  F√ºgen Sie die Kommunikation zwischen Entit√§ten hinzu </li><li>  F√ºgen Sie eine Gruppenstruktur hinzu, damit sich Entit√§ten formal identifizieren k√∂nnen </li></ul><br>  Die Unterbrechung der Verarbeitung und Priorisierung von Aufgaben kann f√ºr die Interaktion zwischen Entit√§ten erforderlich sein, da der Bot seine Aktivit√§ten nicht blind fortsetzen kann, wenn sie mit ihm kommunizieren (er muss irgendwie ‚Äûzuh√∂ren‚Äú) oder angegriffen wird (‚Äûweglaufen‚Äú oder ‚Äûk√§mpfen‚Äú). ) <br><br>  Die Kommunikation zwischen Entit√§ten besteht wahrscheinlich aus einer oder zwei primitiven Aufgaben zum Austauschen von Erinnerungen oder zum Anfordern von Erinnerungen an andere Bots (z. B. "Sagen" oder "Fragen").  Auf diese Weise k√∂nnen Informationen wie der Standort von Lebensmitteln oder andere Ressourcen √ºbertragen werden. <br><br>  Ich hoffe, diese Aufgaben umzusetzen und ein Diagramm der Ressourcenakkumulationsrate einer gro√üen Gruppe mit und ohne Kommunikation zu erstellen.  Die Bev√∂lkerung verfolgt bereits die Menge der in jeder Ma√ünahme gesammelten Lebensmittel.  Es w√§re interessant zu zeigen, dass das Teilen von Erinnerungen die Effizienz beeintr√§chtigen kann. <br><br><h3>  Die Zukunft </h3><br>  Die wichtigste Funktion zur Simulation von Communities besteht darin, Gruppenstrukturen hinzuzuf√ºgen und diese Gruppen mit Eigenschaften auf Makroebene auszustatten, beispielsweise ihren gemeinsamen ‚ÄûZielen und Verantwortlichkeiten‚Äú.  Dies gibt uns eine Art ‚ÄûKeim‚Äú, aus dem wir Aufgaben auf hoher Ebene erhalten k√∂nnen, die in der Hierarchie der Gruppenstrukturen an Aufgaben auf niedrigerer Ebene delegiert werden, die sich direkt auf die Welt auswirken.  Es erm√∂glicht Ihnen auch, eine Form der politischen Struktur zu schaffen. <br><br>  Ein solches System ist v√∂llig autark, und die Visualisierung wird einfach dar√ºber gelegt.  Es wird sehr einfach sein, Insekten durch Humanoide zu ersetzen, Ressourcen zu sammeln und an einem Ort zu lagern, damit sie gr√∂√üer werden.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Art des Wachstums ihres Hauses kann zum Beispiel sehr abh√§ngig oder v√∂llig unabh√§ngig von den Aktionen von Bots sein. </font><font style="vertical-align: inherit;">Verschiedene Arten k√∂nnen unterschiedliche St√§mme mit unterschiedlichen Merkmalen und Trends haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem kann ich dieses System mit zuvor erstellten Kartengeneratoren kombinieren (Erweiterung der Weltklasse), um die Welt realer zu machen.</font></font><br><br><h2>  Abschlie√üend </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In naher Zukunft plane ich, die Kreaturen durch Menschen zu ersetzen und einige der letzten Funktionen zu implementieren. </font><font style="vertical-align: inherit;">Vielleicht werde ich den </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vollst√§ndigen Quellcode ver√∂ffentlichen,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn ich die Qualit√§t des Systems verbessere (an einigen Stellen ist der Code ziemlich chaotisch). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten Sie auf den n√§chsten Artikel. </font><font style="vertical-align: inherit;">In der Zwischenzeit ist hier ein Video mit Bienen, die nach Pollen in Blumen suchen. </font><font style="vertical-align: inherit;">Sie werden mit demselben Framework codiert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/b31/7d5/332b317d547edc53f2b2ffee6c3d4861.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe diesen Samen gew√§hlt, weil der Ausgangspunkt auf einer kleinen Insel liegt. </font><font style="vertical-align: inherit;">Die Bienen sind jedoch nicht so programmiert, dass sie in den Bienenstock zur√ºckkehren, sondern sammeln st√§ndig Pollen. </font><font style="vertical-align: inherit;">M√∂glicherweise stellen Sie fest, dass ihre Sichtweite h√∂her ist und sie sich manchmal sehr absichtlich zu der Blume bewegen, die sie gerade gesehen haben. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... und hier ist die Bee Task-Mitgliedsfunktion:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Task::Bee(Garden &amp;garden, Population &amp;population, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (&amp;arguments)[<span class="hljs-number"><span class="hljs-number">10</span></span>]){ <span class="hljs-comment"><span class="hljs-comment">//Just Search for Flowers if(initFlag){ //Define our Tasks Task take("Take Food", botID, &amp;Task::take); Task eat("Eat Food", botID, &amp;Task::consume); Task search("Locate Food", botID, &amp;Task::search); search.args[0] = population.bots[botID].forage; queue.push(eat); queue.push(take); queue.push(search); initFlag = false; } //Work off our allocated queue. if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ //Put the Task back on queue.push(newtask); } //If it was successful, we leave it off return false; } initFlag = true; return true; }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443252/">https://habr.com/ru/post/de443252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443240/index.html">Q-Learning verstehen, das Problem ‚ÄûAuf einem Felsen gehen‚Äú</a></li>
<li><a href="../de443242/index.html">Quarkus ist ein subatomares √úberschall-Java. Ein kurzer √úberblick √ºber das Framework</a></li>
<li><a href="../de443244/index.html">Nachbesprechungsaufgaben. Beanpoisk_1</a></li>
<li><a href="../de443246/index.html">Wie wir Askozia IP PBX neu erfunden haben, nachdem das Projekt vom Entwickler verkauft und geschlossen wurde</a></li>
<li><a href="../de443248/index.html">Protokolle zur nahtlosen Reservierung von PRP und HSR</a></li>
<li><a href="../de443254/index.html">Triton ist das t√∂dlichste Virus</a></li>
<li><a href="../de443256/index.html">PowerShell, Dump meiner Erfahrung</a></li>
<li><a href="../de443258/index.html">Gotify - ein Open Source-Projekt zum √úbermitteln von Benachrichtigungen und zum Senden von Nachrichten an den Server</a></li>
<li><a href="../de443260/index.html">Migrieren Sie nach Zimbra, ohne das Gesch√§ft mit einer gemeinsamen Domain zu riskieren</a></li>
<li><a href="../de443262/index.html">Schlechter Rat: Wie schreibe ich technische Dokumentation? Teil drei und zuletzt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>