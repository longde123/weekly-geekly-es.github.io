<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🚒 💪🏻 🤲 Die Geschichte der Tetris-Randomisierungsalgorithmen 🥪 👩🏿‍⚕️ 🥓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1985 veröffentlichten Alexey Pajitnov und Vadim Gerasimov Tetris. Bei diesem faszinierenden und süchtig machenden Spiel mussten die Spieler zufällig e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Geschichte der Tetris-Randomisierungsalgorithmen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466579/"><img src="https://habrastorage.org/getpro/habr/post_images/98b/032/444/98b032444bc6166195004d46d9b4ee2c.jpg" alt="Bild"><br>  1985 veröffentlichten Alexey Pajitnov und Vadim Gerasimov Tetris.  Bei diesem faszinierenden und süchtig machenden Spiel mussten die Spieler <em>zufällig</em> erscheinende Teile miteinander verbinden.  Seitdem wurden mehr als 150 lizenzierte Versionen von Tetris veröffentlicht.  Sie unterschieden sich in Spielmodi, Regeln und Implementierung und spielten alle leicht (oder sehr) unterschiedlich.  Der Tetris-Zufallsgenerator ist eine Funktion, die eine zufällig ausgewählte Form zurückgibt.  Im Laufe der Jahre haben sich die Regeln für die Auswahl von Formen weiterentwickelt und das Gameplay und die Zufälligkeit selbst beeinflusst.  Einige dieser Algorithmen wurden rückentwickelt und dokumentiert.  Ich habe eine Liste von Randomisierern zusammengestellt, die ich für wichtig halte, und ich werde im Artikel zeigen, wie sich die interne Struktur von Tetris im Laufe der Jahre verändert hat. <br><a name="habracut"></a><br><h2>  <em>Tetris</em> (um 1985) </h2><br>  Die erste und ursprüngliche Version von Tetris hatte einen Randomizer ohne Vorurteile.  Nichts beeinflusste die Wahl der nächsten Figur, sie wurde einfach ausgewählt und dem Spieler gezeigt. <br><br>  Bei Verwendung eines Zufallsgenerators ohne Verschiebung treten Situationen auf, in denen der Spieler eine Folge von einer Figur (als „Flut“, Flut) oder eine Folge von einer bestimmten Figur (als „Dürre“, Dürre bezeichnet) empfängt.  Wir werden sehen, wie Designer verschiedener Versionen von Tetris versucht haben, dieses Problem leicht zu beheben. <br><br>  Obwohl ein Randomizer ohne Verzerrung die größte Rätselkomplexität für die Spieler erzeugt, ist er instabil und kann zu einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unbesiegbaren Sequenz (PDF) führen</a> .  Dies ist jedoch in einem echten Spiel nicht der Fall, da Computer keine echten Zufallszahlengeneratoren haben.  Pseudozufallszahlengeneratoren (PRNGs) versuchen, echte Zufälligkeit zu simulieren, haben jedoch nicht die Eigenschaften, die in einer Reihe 70.000 Zahlen Z erzeugen können. <br><br><h3>  Wahre Pseudozufälligkeit </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pieces = [<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'J'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'T'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { yield pieces[Math.<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(Math.random() * pieces.length)]; } }</code> </pre> <br>  Puzzle-Schwierigkeit: 4/5 <br><br>  Hochwasserschutz: 0/5 <br><br>  Dürreprävention: 0/5 <br><br><h2>  <em>Tetris</em> , Nintendo (1989) </h2><br>  Vier Jahre später wurde die ungewöhnlich beliebte Version von Tetris für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NES veröffentlicht</a> . <br><br>  Um die Anzahl der Überschwemmungen (Wiederholungen) von Zahlen zu verringern, wurde dem Randomizer eine Verlaufsprüfung hinzugefügt.  Diese einfache Überprüfung hat Folgendes bewirkt: <br><br><ol><li>  Wähle eine Figur </li><li>  überprüft, ob die Zahl mit der vorherigen übereinstimmt, </li><li>  Wenn ja, dann hat der Algorithmus eine neue Form ausgewählt, aber nur einmal. </li><li>  und was auch immer das Ergebnis war, die Figur wurde dem Spieler gegeben. </li></ol><br>  Obwohl die Wahrscheinlichkeit, ein Stück hintereinander zu bekommen, abnahm, hinderte nichts das Spiel daran, zwei abwechselnde Stücke herauszugeben.  Darüber hinaus war in dieser Version Dürre über mehr als 30 Zahlen eine häufige Situation.  Eine Dürre kann für jede Art von Tetramino auftreten, aber Abbildung I ist wichtig für die Wertung in diesem Spiel, und die große Dürre kann das Endergebnis erheblich beeinflussen. <br><br><h3>  Auswendiglernen einer Geschichte 1 Figur in der Tiefe und mit 1 Wurf </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">historyRandomizer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pieces = [<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'J'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'T'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>]; let history; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// First "roll" piece = pieces[Math.floor(Math.random() * pieces.length)]; // Roll is checked against the history if (piece === history) { piece = pieces[Math.floor(Math.random() * pieces.length)]; } history = piece; yield piece; } }</span></span></code> </pre> <br>  Puzzle-Schwierigkeitsgrad: 5/5 <br><br>  Hochwasserschutz: 2/5 <br><br>  Dürreprävention: 0/5 <br><br><h2>  <em>Tetris: Der Großmeister</em> (1998) </h2><br>  Obwohl <em>Tetris für NES</em> den Algorithmus im Vergleich zur Randomisierung ohne Verzerrung verbesserte, kam es immer noch häufig zu Dürren.  <em>Tetris: Der Großmeister</em> ( <em>TGM</em> ) verwendete im Wesentlichen dasselbe System, jedoch mit einer längeren Geschichte und mehr Würfen. <br><br>  Aufgrund des Anstiegs dieser Werte nahm nicht nur die Anzahl der Überschwemmungen ab, sondern auch die Situation mit Dürren verbesserte sich.  In der Geschichte sind vier Figuren erhalten geblieben, und dies bedeutete, dass die Wahrscheinlichkeit, eine Figur zu erhalten, die lange Zeit nicht existiert hatte, zunahm.  Trotzdem fehlte dem Spiel immer noch eine strenge Regel, um Dürren zu verhindern, und sie traten immer noch auf, wenn auch viel seltener als in <em>Tetris für NES</em> . <br><br><h3>  Eine Geschichte mit 4 Stücken und 4 Würfen auswendig lernen </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">historyRandomizer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pieces = [<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'J'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'T'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// First piece special conditions let piece = ['I', 'J', 'L', 'T'][Math.floor(Math.random() * 4)]; yield piece; let history = ['S', 'Z', 'S', piece]; while (true) { for (let roll = 0; roll &lt; 4; ++roll) { piece = pieces[Math.floor(Math.random() * 7)]; if (history.includes(piece) === false) break; } history.shift(); history.push(piece); yield piece; } }</span></span></code> </pre> <br>  Puzzle-Schwierigkeit: 4/5 <br><br>  Hochwasserschutz: 4/5 <br><br>  Dürreprävention: 2/5 <br><br><h2>  <em>Tetris Worlds</em> et <em>al.</em> (2001) </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4b/59a/4a8/b4b59a4a8eb64c5edb6a280a72d38a8a.jpg"></div><br>  <em>Tetris Worlds</em> führte die Massen in den Zufallsgenerator ein.  Er ist jetzt der offizielle Randomizer in den meisten offiziellen Versionen des Spiels nach <em>Tetris Worlds</em> und wird bis heute verwendet. <br><br>  Geschichtsbasierte Randomisierer halfen, die Überschwemmungen zu beseitigen (oder zumindest zu minimieren), stoppten jedoch nicht die Dürre.  Unter bestimmten Umständen bestand immer noch die Möglichkeit, eine tödliche Zahlenfolge zu erhalten. <br><br>  Der Zufallsgenerator (Zufallsgenerator) löst diese Probleme durch die Verwendung eines neuen Systems von "Beuteln" (Beuteln).  In diesem System wird die Liste der Figuren in einen "Beutel" gelegt, wonach die Figuren nacheinander zufällig daraus extrahiert werden, bis der "Beutel" leer ist.  Wenn es leer ist, kehren die Teile dorthin zurück und der Vorgang wird wiederholt.  Random Generator hat einen "Beutel" der Größe 7 (7 Beutel), dh einen "Beutel", der mit jeweils 7 Tetraminos gefüllt ist.  Andere Arten von "Beuteln" sind möglich, beispielsweise ein 14-Beutel, in den zwei Stücke jeder Art von Tetramino gelegt werden. <br><br>  Aufgrund der fehlenden Geschichte der "Taschen" können an ihren Kreuzungen Überschwemmungen von 2 Figuren und "Schlangen" von 4 Figuren auftreten ( <img src="https://habrastorage.org/webt/pc/ws/v4/pcwsv4sjt7ofqojutpk2f8auhxo.png">  , <img src="https://habrastorage.org/webt/qp/ua/pn/qpuapnx-u3qicgxo1-nwppigh70.png">  usw.).  Dies ist in <em>gewissem</em> Sinne ein Rückschritt im Vergleich zu herkömmlichem <em>Tetris für NES</em> . <br><br>  Die Teile fallen stabil aus dem 7-Beutel heraus, was es vorhersehbarer macht.  Es ist leicht zu verstehen, in welchem ​​Teil der „Tasche“ Sie sich befinden und wann die benötigte Figur kommen kann.  Aufgrund der Vorhersagbarkeit dieses Zufallsgenerators kann das Spiel tatsächlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">endlos gespielt werden</a> .  Im Allgemeinen ist dies ein sehr dummes System, und es ist unklar, wie es im Allgemeinen zu einem offiziellen Randomizer wurde. <br><br><h3>  7 Beutel </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomGenerator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ let bag = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bag.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { bag = [<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'J'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'T'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>]; bag = shuffle(bag); } yield bag.pop(); } }</code> </pre> <br>  Puzzle-Schwierigkeitsgrad: 3/5 <br><br>  Hochwasserschutz: 3/5 <br><br>  Dürreprävention: 4/5 <br><br><h2>  <em>Tetris: Der Großmeister 3 - Terror-Instinkt</em> (2005) </h2><br>  TGM3 hat die Idee der Erzeugung von Zufälligkeit stark vorangetrieben.  Dies ist ein einzigartiges System, das in keiner anderen Version zu finden ist. <br><br>  Anstelle einer Tasche oder Geschichte verwendet der TGM3 einen Pool von Formen.  Anfangs hat es 5 Figuren von jedem Typ, dh insgesamt 35 Figuren.  Wenn eine Figur gezogen wird, wird sie nicht aus dem Pool entfernt, sondern durch die Figur mit der größten Dürre ersetzt (eine, die seit langem nicht mehr entfernt wurde).  Allmählich wird der Pool zunehmend mit dieser Figur gefüllt, bis er schließlich herausgezogen wird.  Dies löst die Probleme von "Beutel" -Systemen sowie von Systemen mit einer Geschichte;  Sie holt das Beste aus beiden Arten der Randomisierung heraus. <br><br><h3>  Pool von 35 Figuren mit 6 Würfen </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tgm3Randomizer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ let pieces = [<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'J'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'S'</span></span>, <span class="hljs-string"><span class="hljs-string">'T'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>]; let order = []; <span class="hljs-comment"><span class="hljs-comment">// Create 35 pool. let pool = pieces.concat(pieces, pieces, pieces, pieces); // First piece special conditions const firstPiece = ['I', 'J', 'L', 'T'][Math.floor(Math.random() * 4)]; yield firstPiece; let history = ['S', 'Z', 'S', firstPiece]; while (true) { let roll; let i; let piece; // Roll For piece for (roll = 0; roll &lt; 6; ++roll) { i = Math.floor(Math.random() * 35); piece = pool[i]; if (history.includes(piece) === false || roll === 5) { break; } if (order.length) pool[i] = order[0]; } // Update piece order if (order.includes(piece)) { order.splice(order.indexOf(piece), 1); } order.push(piece); pool[i] = order[0]; // Update history history.shift(); history[3] = piece; yield piece; } }</span></span></code> </pre> <br>  Puzzle-Schwierigkeit: 4/5 <br><br>  Hochwasserschutz: 4/5 <br><br>  Dürreprävention: 4/5 <br><br><h2>  Schlussfolgerungen </h2><br>  Es ist schwierig, ein bestimmtes Ergebnis zu erzielen.  Der TGM3-Randomizer scheint für den Spieler vorhersehbarer und weniger komplex zu sein.  Der ungeschickte 7-Beutel fühlt sich unnatürlich an, ermöglicht es Ihnen jedoch, viele tragfähige Gebäudestrategien zu entwickeln.  Ein unfreundlicher Zufallsgenerator wie in Tetris für NES kann Ihr Spiel oder eher Ihre Spielstimmung ruinieren. <br><br>  Können wir diese Systeme verbessern, indem wir sie zufälliger erscheinen lassen und Dürren und Überschwemmungen stark einschränken?  Oder machen solch strenge Einschränkungen das Spiel nur vorhersehbarer? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466579/">https://habr.com/ru/post/de466579/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466567/index.html">Toolkit für den Anbieter: thematische Webinare zu Systemen für die Arbeit mit Datenverkehr und deren Konfiguration</a></li>
<li><a href="../de466569/index.html">Börsengang an der Moskauer Börse: Warum es gebraucht wird, wer es durchführt und wie man Aktien kauft</a></li>
<li><a href="../de466573/index.html">Fragen an den zukünftigen Arbeitgeber</a></li>
<li><a href="../de466575/index.html">Übergabe zweidimensionaler Listen von Python an DLL</a></li>
<li><a href="../de466577/index.html">Wie zwei Schüler das Spiel unter iOS gemacht haben und wie viel sie damit verdient haben</a></li>
<li><a href="../de466581/index.html">Quantendarwinismus: Eine Idee, die die objektive Realität erklärt, besteht den ersten Test</a></li>
<li><a href="../de466583/index.html">Eine kurze Geschichte des Lügendetektors</a></li>
<li><a href="../de466585/index.html">Nachrichtenbroker verstehen. Erlernen der Mechanismen des Messaging über ActiveMQ und Kafka. Kapitel 3. Kafka</a></li>
<li><a href="../de466589/index.html">So empfangen Sie Daten von Google Analytics mit R in Microsoft SQL Server</a></li>
<li><a href="../de466591/index.html">MVC ohne C: Was ändert SwiftUI in der Anwendungsarchitektur?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>