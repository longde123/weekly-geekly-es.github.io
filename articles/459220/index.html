<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌲 🥙 👰🏽 Pruebas de integración para verificar pérdidas de memoria 🐘 👲🏻 🎽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Escribimos muchas pruebas unitarias, desarrollando la aplicación SoundCloud para iOS. Las pruebas unitarias se ven bastante hermosas. Son cortos, (con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas de integración para verificar pérdidas de memoria</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459220/">  Escribimos muchas pruebas unitarias, desarrollando la aplicación <b>SoundCloud</b> para iOS.  Las pruebas unitarias se ven bastante hermosas.  Son cortos, (con suerte) legibles, y nos dan la confianza de que el código que escribimos funciona como se esperaba.  Pero las pruebas unitarias, como su nombre lo indica, cubren solo un bloque de código, la mayoría de las veces una función o clase.  Entonces, ¿cómo detecta los errores que existen en las interacciones entre clases, errores como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pérdidas de memoria</a> ? <br><a name="habracut"></a><br><br><h3>  Fugas de memoria </h3><br>  A veces es bastante difícil detectar un error de pérdida de memoria.  Existe la posibilidad de una fuerte referencia al delegado, pero también hay errores que son mucho más difíciles de detectar.  Por ejemplo, ¿es obvio que el siguiente código puede contener una pérdida de memoria? <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UseCase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delegate: <span class="hljs-type"><span class="hljs-type">UseCaseDelegate?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> service: <span class="hljs-type"><span class="hljs-type">Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(service: <span class="hljs-type"><span class="hljs-type">Service</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.service = service } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service.makeRequest(handleResponse) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: ServiceResponse)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// some business logic and then... delegate.operationDidComplete() } }</span></span></code> </pre> <br><br>  Dado que el <i>Servicio</i> ya se está implementando, no hay garantías con respecto a su comportamiento.  Al pasar la función <i>handleResponse</i> a una función privada, que se captura a <b>sí misma</b> , proporcionamos al <i>Servicio una</i> fuerte referencia a <i>UseCase</i> .  Si el <i>Servicio</i> decide mantener este enlace, y no tenemos garantía de que esto no suceda, se produce una pérdida de memoria.  Pero con un estudio superficial del código, no es obvio que esto realmente pueda suceder. <br><br>  También hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicación</a> maravillosa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de John Sandell</a> sobre el uso de pruebas unitarias para detectar pérdidas de memoria para las clases.  Pero con el ejemplo anterior, donde es muy fácil omitir una pérdida de memoria, no siempre está claro cómo escribir una prueba unitaria de este tipo.  (Por supuesto, no estamos hablando aquí en términos de experiencia). <br><br>  Como escribió Guilherme en una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicación reciente</a> , las nuevas características de la aplicación SoundCloud para iOS están escritas de acuerdo con "patrones arquitectónicos limpios"; con frecuencia, este es un tipo de <b>VIPER</b> .  La mayoría de estos módulos <b>VIPER</b> se crean utilizando lo que llamamos <b>ModuleFactory</b> .  Tal <b>ModuleFactory</b> toma algunas entradas, dependencias y configuración, y crea un <b>UIViewController</b> que ya está conectado al resto del módulo y se puede <b>insertar en</b> la pila de navegación. <br><br>  Este módulo <b>VIPER</b> puede tener varios delegados, observadores y fallas fuera de control, cada una de las cuales puede hacer que el controlador permanezca en la memoria después de que se retira de la pila de navegación.  Cuando esto sucede, la cantidad de memoria aumentará y el sistema operativo puede decidir detener la aplicación. <br><br>  Entonces, ¿es posible cubrir tantas fugas potenciales escribiendo tan pocas pruebas unitarias como sea posible?  Si no, entonces todo esto fue una gran pérdida de tiempo. <br><br><h3>  Pruebas de integración </h3><br>  La respuesta, como habrás adivinado por el título de esta publicación, es sí.  Y lo hacemos a través de pruebas de integración.  El propósito de la prueba de integración es probar cómo los objetos interactúan entre sí.  Por supuesto, los módulos <b>VIPER</b> son grupos de objetos, las pérdidas de memoria son una forma de interacción que definitivamente queremos evitar. <br><br>  Nuestro plan es simple: vamos a utilizar nuestro <i>ModuleFactory</i> para crear una instancia de un módulo <b>VIPER</b> .  Luego, eliminaremos el enlace al <i>UIViewController</i> y nos aseguraremos de que todas las partes importantes del módulo se destruyan junto con él. <br><br>  El primer problema que enfrentamos es que, por naturaleza, no podemos acceder fácilmente a ninguna parte del módulo <b>VIPER</b> que no sea <i>UIViewController</i> .  La única función <i>pública</i> en nuestro <b>ModuleFactory</b> es <i>func make () -&gt; UIViewController</i> .  Pero, ¿qué pasa si agregamos otro punto de entrada solo para nuestras pruebas?  Este nuevo método se declarará a través de <b>interno</b> , por lo que solo podemos acceder a él a través de la <i>importación @testable</i> , el framework <i>ModuleFactory</i> .  Devolverá enlaces a todas las partes más importantes del módulo, que luego podríamos mantener para que los enlaces débiles ingresen en nuestra prueba.  En última instancia, se ve así: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,   ... public func make() -&gt; UIViewController { makeAndExpose().view } typealias ModuleComponents = ( view: UIViewController, presenter: Presenter, Interactor: Interactor ) func makeAndExpose() -&gt; ModuleComponents { // Set up code, and then... return ( view: viewController, presenter: presenter, interactor: interactor ) } }</span></span></code> </pre><br><br>  Esto resuelve el problema de la falta de acceso directo a los datos del objeto.  Obviamente, esto no es ideal, pero satisface nuestras necesidades, así que pasemos a escribir la prueba.  Se verá así: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleMemoryLeakTests</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XCTestCase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      .     //    . private var view: UIViewController? //        //   ,    // UIKit,   UIViewController  . private weak var presenter: Presenter? private weak var interactor: Interactor? //   setUp    ModuleFactory  //   makeAndExpose.     ,   //     ModuleComponents // ,          . //     . func setUp() { super.setUp() let moduleFactory = ModuleFactory(/* mocked dependencies &amp; config */) let components = moduleFactory.makeAndExpose() view = components.view presenter = components.presenter interactor = components.interactor } //   ,   tearDown   , //        ,     ,   //     . func tearDown() { view = nil presenter = nil interactor = nil super.tearDown() } func test_module_doesNotLeakMemory() { //   ,      . //      ,  //          setUp. XCTAssertNotNil(presenter) XCTAssertNotNil(interactor) //        . //    ,   //     ,    //      . view = nil // ,  ,    //  Presenter  Interactor   . //  ,       //  ,    . XCTAssertNil(presenter) XCTAssertNil(interactor) } }</span></span></code> </pre><br><br>  Entonces, tenemos una manera fácil de detectar pérdidas de memoria en el módulo <b>VIPER</b> .  De ninguna manera es ideal y requiere un cierto trabajo del usuario para cada módulo nuevo que queremos probar, pero esto es ciertamente mucho menos trabajo que escribir pruebas unitarias separadas para cada posible pérdida de memoria.  También ayuda a identificar pérdidas de memoria que ni siquiera sospechamos.  De hecho, después de escribir varias de estas pruebas, se reveló que tenemos una prueba que no pasa, y después de algunas investigaciones, encontramos una pérdida de memoria en el módulo.  Después de la corrección, la prueba debe repetirse. <br><br>  También nos da un punto de partida para escribir un conjunto más general de pruebas de integración para módulos.  Al final, si solo mantenemos un vínculo fuerte con el <b>Presentador</b> y reemplazamos el <b>UIViewController</b> con <b>simulacro</b> , podemos falsificar la entrada del usuario, luego invocar los métodos del presentador y verificar la visualización ficticia de los datos en la <b>Vista</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459220/">https://habr.com/ru/post/459220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459206/index.html">9 años en un monolito en Node.JS</a></li>
<li><a href="../459208/index.html">Correr con prótesis: simulación de Nekstgen del movimiento humano usando músculos, huesos y una red neuronal</a></li>
<li><a href="../459212/index.html">Implementación de propiedad en C ++</a></li>
<li><a href="../459214/index.html">Tolerancia a fallos en el almacenamiento de Qsan</a></li>
<li><a href="../459216/index.html">Estructura de datos del árbol B</a></li>
<li><a href="../459224/index.html">De agente inmobiliario a desarrollador de juegos 2. "Operación: Android"</a></li>
<li><a href="../459226/index.html">"Fast-PoE y Perpetual-PoE: ¿son estos nuevos estándares o no?"</a></li>
<li><a href="../459230/index.html">Un viaje al centro de llamadas y a la cartera de productos a través de los ojos del desarrollador</a></li>
<li><a href="../459232/index.html">Rodea, muerde, corta: la nueva competencia Mini AI Cup # 4</a></li>
<li><a href="../459234/index.html">Smem: informes sobre la asignación de memoria entre procesos y usuarios en Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>