<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏨 🤘🏾 👨🏽‍🚀 Wie lade ich OpenStreetMap in Hive? 💳 📻 🤴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem früheren Artikel habe ich die umgekehrte Geokodierung mit Spark untersucht. Stellen Sie sich nun vor, wir stünden vor der Herausforderung der...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie lade ich OpenStreetMap in Hive?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438374/">  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel habe</a> ich die umgekehrte Geokodierung mit Spark untersucht.  Stellen Sie sich nun vor, wir stünden vor der Herausforderung der direkten Geokodierung von E-Mail-Adressen.  Das heißt, Empfangen für die Adresse, die durch den Text einiger geografischer Koordinaten aufgezeichnet wurde. <br><br>  Die Adressen für die Bestimmtheit sind russisch und vor allem - sie sind oft schief geschrieben, dh mit Fehlern, Unklarheiten und anderen Freuden.  Diese Adressen befinden sich in der Hive-Datenbank im Hadoop-Cluster. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/8n/_s/vc8n_sp2pkut9qvilbnt6u2whqs.png"></div><br>  Nun, es scheint, wir verwenden die Google Maps-Geokodierungs-API (oder, wenn Sie die Importsubstitution unterstützen, die Yandex Maps-API) und arbeiten.  Aber hier warten wir ebenso wie bei der umgekehrten Geokodierung auf einen kleinen Hinterhalt. <br><a name="habracut"></a><br>  Oder groß, es ist wie ein Blick.  Tatsache ist, dass wir diesmal ungefähr 5 Millionen Adressen verarbeiten müssen.  Und vielleicht 50 - es war nicht sofort klar.  Wie Sie wissen, wird Google Ihre IP-Adresse nach etwa 10.000 Adressen sperren. Yandex wird dasselbe mit Ihnen tun, obwohl dies etwas später möglich ist (z. B. 25.000 Anfragen pro Tag).  Außerdem sind beide APIs REST, was bedeutet, dass es relativ langsam ist.  Und selbst wenn Sie ein kostenpflichtiges Abonnement kaufen, erhöht sich die Geschwindigkeit nicht um einen Cent. <br><br>  Und doch - wir haben keine Munitionsanekdote mehr. <br><br>  Ich habe das Wichtigste vergessen: Unser Hadoop-Cluster befindet sich im Intranet, und Google Maps für das Unternehmen mit Yandex Maps und alle anderen sind für uns vom Cluster aus im Allgemeinen nicht zugänglich.  Das heißt, wir brauchten eine autonome Lösung. <br><br>  Ich werde gleich sagen - hier finden Sie keine fertige Lösung.  Ich werde nur den Ansatz beschreiben, den wir anwenden möchten, und zwar etwas detaillierter - einer der Schritte auf dem langen Weg zu einer Lösung. <br><br>  Natürlich hatten wir etwas in Reserve.  Es gab einen internen ArcGIS-Server, den ich bereits erwähnt habe.  Wir durften sie nicht steuern, aber wir durften ihre REST-Services nutzen. <br><br>  Das erste, was wir gemacht haben, war es an die Aufgabe zu schrauben.  Er hat uns nicht verboten, sondern manchmal nur wegen Wartungsarbeiten ausgeschaltet.  Und was ist schön - es gab einen Batch-Modus der Geokodierung, wenn Sie ein Adresspaket an die Eingabe senden (nach der Konfiguration des Servers hatten wir eine Paketgröße von 1000 Stück, standardmäßig scheint etwas um eine Größenordnung oder zwei kleiner zu sein).  All dies war auch nicht einfach, und wir und der ArcGIS-Support waren lange Zeit mit dem Server im Sumo-Wrestling beschäftigt, aber das ist eine andere Geschichte. <br><br>  Nach all den Tricks und Wendungen konnten wir unsere fünf Millionen in ungefähr einem Tag verarbeiten.  Es war notwendig, weiterzumachen und noch zu beschleunigen. <br><br>  Gleichzeitig wurde klar, dass ein Geocoder mit REST höchstwahrscheinlich nicht für uns geeignet ist.  Außerdem haben wir uns Nominatim, Pelias, Photon und Gisgraphie angesehen und waren im Allgemeinen mit keiner zufrieden.  Qualität und Leistung (oder beides) waren alles andere als ideal. <br><br>  Zum Beispiel weiß niemand, wie man Pakete geocodiert (und dies hat die Arbeit mit ArcGIS erheblich beschleunigt). <br><br>  Oder Qualität - gehen Sie zum Demo-Server von gisgraphy.com und versuchen Sie, Moskau zu finden.  Sie erhalten ein paar Dutzend Antworten, darunter: Moskau (eine Stadt in der Russischen Föderation), Kansas City (eine Stadt in den USA), Khimki, Kaluga, Vykhino-Zhulebino und viele andere Objekte, die ich in der Antwort des Geocoders nicht sehen möchte, wenn Suche nach Moskau. <br><br>  Nun, das letzte (aber für uns nicht wichtige) Problem ist, dass die API weit entfernt von allen Geocodierern so gut durchdacht ist wie beispielsweise Google Maps.  Nehmen wir an, die ArcGIS-API ist bereits viel unpraktischer und der Rest ist größtenteils noch schlimmer.  Wenn Sie Adressen für die Benutzeroberfläche geocodieren, wählt in der Regel eine Person die beste Option aus.  Und er macht es besser als das Programm.  Und im Fall der Massengeokodierung ist, wie wir es getan haben, die Bewertung der Qualität des Ergebnisses für eine bestimmte Adresse eine der wichtigen Komponenten des Erfolgs. <br><br>  Infolgedessen sind auch Optionen wie „Erweitern Sie Ihre eigenen Nominatim“ verschwunden. <br><br><h2>  Was tun? </h2><br>  Eine ziemlich offensichtliche Lösung war folgende: Da die Adressen nicht von irgendwoher stammen und nicht verschwinden, die Häuser nicht jeden Tag gebaut werden und die Straßen nicht gebaut werden, müssen Sie unserem Prozess lediglich eine Datenbank mit offiziell vorhandenen Adressen hinzufügen.  Besser sofort mit den Koordinaten, und wenn dies nicht passiert, dann geocodieren Sie es einmal.  In diesem Fall reicht es aus, wenn wir unsere Basis mit der gleichen Häufigkeit aktualisieren, mit der neue Häuser oder Straßen erscheinen, dh nicht oft. <br><br>  Der erste und Hauptkandidat für die Basis bestehender Adressen ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FIAS</a> .  Warten Sie eine Minute, sagen Sie, aber FIAS hat nur wenige Millionen Adressen - und Sie haben bis zu 50 Millionen?  Ja, es gibt wirklich nur ein paar Millionen <b>Häuser</b> .  Und unsere 50 sind 50 Millionen Adressen unserer Benutzer, das heißt, dies sind die Adressen von Menschen, und sie haben plötzlich eine Wohnung in der Adresse.  Fünf Millionen Häuser mit 1-100 Wohnungen, in jeder Wohnung leben mehrere Personen ... Sie verstehen alles.  Und die zweite Option sind die Adressen von Büros, in denen auch ein Bürozentrum bis zu Hunderte von Räumlichkeiten hat, die manchmal vermietet werden. <br><br>  Gleichzeitig benötigen wir offensichtlich keine Adresse mit der Nummer der Wohnung (oder des Büros) - erstens handelt es sich um personenbezogene Daten mit allen Konsequenzen, und zweitens sind wir immer noch nicht daran interessiert, wie sich die Wohnungen in einem bestimmten Haus befinden und wie ihre Koordinaten lauten .  Es wird nur ein Haus benötigt.  Für Büros ist dies nicht ganz richtig, aber der Standort von Büros in einem Gebäude nach Etagen wird immer noch nicht durch Koordinaten bestimmt. <br><br>  Mit einer Basis von beispielsweise 5 Millionen (bedingt) vorhandenen Häusern können wir das Geokodierungsproblem von 50 oder 100 Millionen Adressen lösen, indem wir einfach die Wohnung oder das Büro aus der Adresse werfen und sie mit der Basis abgleichen. <br><br>  Und wo bekommt man die Koordinaten der Häuser?  Es gibt nur eine offensichtliche Open Source - OpenStreetMap, dort gibt es Häuser mit Geometrien und verschiedenen anderen Attributen wie der Anzahl der Stockwerke oder sogar der Farbe des Daches. <br><br>  Nach all den Diskussionen hatten wir einen napoleonischen Plan.  Hier ist einer: <br><br><ul><li>  Laden von Kartendaten aus OSM in Hadoop </li><li>  Laden Sie FIAS-Daten mit Adressen hoch </li><li>  Erstellen Sie eine Liste eindeutiger vollständiger Adressen mit Hausnummern </li><li>  Wir haben es geocodiert, indem wir in OSM nach Adressen gesucht haben. Was wir nicht gefunden haben, ist über ArcGIS </li></ul><br><br>  Wir bekommen die Basis von Häusern mit Längen- und Breitengrad.  Viel Spaß.  Nutzen Sie die Vorteile.  Trinkgeld (Witz). <br><br>  In diesem Artikel werde ich Ihnen erzählen, wie wir den ersten Punkt dieses Plans umgesetzt haben. <br><br><h2>  Was ist OpenStreetMap? </h2><br>  Wenn Sie OSM aus Datensicht betrachten, können Sie sich die Karten in Form von drei Tabellen vorstellen: <br><br><ul><li>  Punkte </li><li>  Linien (Wege) </li><li>  Beziehungen </li></ul><br><br>  Reale Schemata dieser Daten werden unten angegeben. <br><br>  Nur Punkte haben Koordinaten (Breite und Länge in Grad).  Linien sind eine geordnete Folge von Punkten.  Beziehungen sind eine Reihe von Punkten und Linien, von denen jeder eine <i>Rolle spielt</i> . <br><br>  Alles andere sind die sogenannten Tags.  Das ist zum Beispiel ein Geldautomat oder ein Geschäft oder ein Eingang zur U-Bahn - es kann ein Punkt sein, der mit dem Tag amenity = atm oder shop = etwas oder etwas anderes ausgestattet ist.  Es gibt ein Verzeichnis offiziell empfohlener Tags (für jede anwendbare Sprache und jedes Land können sie teilweise ihre eigenen sein) und die Praxis, nicht standardmäßige Tags zu erfinden. <br><br>  Zusätzlich zu den Tags verfügt jedes Element der Karte über eine eindeutige numerische ID sowie einige Attribute, die sich auf den Verlauf beziehen - wer wann bearbeitet hat, Nummer bearbeitet usw. <br><br>  Die Datenbank mit der Karte ist in verschiedenen Formaten erhältlich: <br>  - pbf ist Google Protobuf, ein tragbares Datenserialisierungsformat. <br>  - XML ​​ist offensichtlich XML.  Viel mehr Volumen. <br><br>  Sie müssen verstehen, dass die Datenbank täglich aktualisiert wird.  Daher sind die Entladungen vollständig und inkrementell. <br><br>  Wir haben PBF als kompakter gewählt. <br><br>  Um es in Hadoop zu lesen, gibt es eine speziell für OSM entwickelte Java-API namens Osmoseprojekt.  Im Prinzip ist die Arbeit damit einfach: Sie laden eine Datei hoch und durchlaufen die Kartenelemente.  Fügen Sie die Punkte an einer Stelle hinzu, die Linien an einer anderen, die Beziehung an der dritten.  Grundsätzlich reichen Osmose und beispielsweise Spark bereits aus, um alle Daten herunterzuladen. <br><br>  Glücklicherweise kam mir bei der Implementierung meines Fahrrads der Gedanke, im Internet nach der Konvertierung von OSM in die in Hadoop - Parkett (Parkett) und Avro akzeptierten Formate zu suchen.  In gewisser Weise sind beide Analoga von PBF, so dass die Möglichkeit bestand, einen Konverter zu finden.  Und er wurde gefunden, aber keiner. <br><br><h2>  Lernen Sie OSM Parquetizer kennen </h2><br>  Sehen Sie, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">was ich gefunden habe!</a> <br><br>  Für faule Leute - direkt in der Readme-Datei des Projekts in der ersten Zeile steht: Telenav veröffentlicht wöchentliche Downloads des Planeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an die Adresse</a> . <br><br>  Für sehr faule Leute: Machen Sie sich bereit, ungefähr 700 Gigabyte zu versenden;) Nun, wenn Sie auf jeden Fall einen Planeten brauchen.  Normalerweise kommt man beispielsweise mit Europa aus. <br><br>  Wenn Sie nicht laden möchten, sieht der Vorgang folgendermaßen aus: Laden Sie eine Karte im PBF-Format herunter, z. B. von einer <a href="">Geofabrik</a> .  Dies sind 2,5 Gigabyte, wenn Sie Russland brauchen, und 19, wenn Europa.  Auch nicht wenig, aber Sie können fein gehackte Proben finden.  Legen Sie als Nächstes die Datei auf die Festplatte und führen Sie das Programm aus: <br><br><pre><code class="plaintext hljs">java -jar ./osm-parquetizer.jar russia-latest.osm.pbf</code> </pre> <br>  Nach einigen Minuten oder sogar Sekunden erhalten Sie je nach Leistung Ihres Geräts drei Dateien im Parkettformat.  So sieht der Autor aus (er kommt aus Rumänien): <br><br><pre> <code class="plaintext hljs">-rw-r--r-- 1 adrianbona adrianbona 145M Apr 3 19:57 romania-latest.osm.pbf -rw-r--r-- 1 adrianbona adrianbona 372M Apr 3 19:58 romania-latest.osm.pbf.node.parquet -rw-r--r-- 1 adrianbona adrianbona 1.1M Apr 3 19:58 romania-latest.osm.pbf.relation.parquet -rw-r--r-- 1 adrianbona adrianbona 123M Apr 3 19:58 romania-latest.osm.pbf.way.parquet</code> </pre> <br>  Schemata der empfangenen Parkettdateien: <br><br> <code>node <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- latitude: double <br> |-- longitude: double <br> <br> way <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- nodes: array <br> | |-- element: struct <br> | | |-- index: integer <br> | | |-- nodeId: long <br> <br> relation <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- members: array <br> | |-- element: struct <br> | | |-- id: long <br> | | |-- role: string <br> | | |-- type: string <br></code> <br><br>  Wie Sie sehen, ist hier alles einfach.  Dann machen wir folgendes: <br><br><ul><li>  Wir legen Dateien mit dem Befehl hdfs dfs -put auf dem Hadoop-Cluster ab </li><li>  Lassen Sie uns in Hue ein Schema / eine Basis und drei Tabellen dafür erstellen, basierend auf den obigen Daten </li><li>  Führen Sie select * aus osm.nodes aus und genießen Sie das Ergebnis. </li></ul><br>  Eine kleine Nuance: In unserer Version von Hive (und möglicherweise auch in Ihrer) können keine Tabellen basierend auf dem Schema von Parquet erstellt werden.  Sie müssen entweder das Obige in CREATE TABLE konvertieren (was im Allgemeinen nicht schwierig ist und ich dies als Heimübung für die Leser belasse) oder etwas kniffliger vorgehen: Spark kann das Diagramm und die Daten vom Boden aus lesen und darauf basierend temporäre Tabellen erstellen .  So können wir die Daten in Spark Shell folgendermaßen lesen: <br><br><pre> <code class="plaintext hljs">val nodeDF = sqlContext.read.parquet("file:/tmp/osm/romania-latest.osm.pbf.node.parquet") nodeDF.createOrReplaceTempView("nodes")</code> </pre><br>  Dann können Sie bereits Tabellen in Hive mit LIKE-Knoten erstellen. <br><br>  Eine weitere Bemerkung für faule Leute: Der Autor hat ein so wunderbares <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> , aus dem im Allgemeinen alles klar wird (na ja, wenn Sie Spark besitzen).  Dies ist natürlich nicht Spark Shell, sondern das Databricks Notebook, aber ich habe ungefähr 15 Minuten gebraucht, um auf eine Tastatur zu tippen, um sie in eine andere zu übersetzen.  Und in 30-40 Minuten war es möglich, alles mit einigen Analoga, die sich geringfügig von Spark unterscheiden, in Abfragen für Hive umzuwandeln. <br><br><h3>  Beispiel für eine echte Anfrage </h3><br>  Was können wir aus dieser Datenbank in ihrer aktuellen Form erhalten?  Im Allgemeinen ziemlich viel.  Wenn Sie über einen Hive oder Spark, ein Spatial Framework, eine Geometry API oder eine der Alternativen GeoSpark oder beispielsweise GeoMesa verfügen, können Sie auf dieser Basis viele verschiedene Probleme lösen. <br><br>  Sehen wir uns ein Beispiel an.  Der einfachste Weg, um mit Punkten zu arbeiten.  Eine Abfrage zum Abrufen einer Liste von Geldautomaten mit ihren Koordinaten sieht beispielsweise folgendermaßen aus: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nodes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tags[<span class="hljs-string"><span class="hljs-string">'amenity'</span></span>]=<span class="hljs-string"><span class="hljs-string">'atm'</span></span></code> </pre><br>  Wie man eine solche Abfrage erstellt, kann man erraten, indem man die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite im Wiki</a> liest.  Dort finden Sie, was andere Tags sind, und einige davon können in Ihrer Anfrage anstelle von * enthalten sein, beispielsweise in Form von Tags ['operator'], um den Namen der Bank anzuzeigen. <br><br>  Aus derselben Seite folgt, dass ATM-Markups in Form von Tags möglich sind. Amenity = bank und atm = yes.  Leider gibt es solche Unklarheiten überall in OSM. <br><br>  Wenn Sie ein Anfänger sind und sich nur mit OSM vertraut machen, empfehle ich dringend, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Overpass-Turbo</a> (anhand guter Beispiele im Wiki) zu beherrschen.  Dies ist ein Tool, mit dem Sie verschiedene Arten von Suchvorgängen für Kartendaten durchführen können, sowohl mit geometrischen Bedingungen als auch mit Bedingungen für Tags. <br><br><h3>  Und wo sind die Adressen? </h3><br>  Gute Frage.  Adressen in OSM sind Kartenelemente, die mit addr: * -Tags versehen sind, d.h.  beginnend mit addr.  Beschreibung finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Wenn Sie alles wissen, was ich oben angegeben habe, können Sie im Prinzip bereits eine Arbeitsanfrage schreiben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nodes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tags[<span class="hljs-string"><span class="hljs-string">'addr:housenumber'</span></span>]!=<span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  Welche Probleme erwarten uns hier?  Erstens werden Adressen sowohl auf Punkten (z. B. Gebäudeeingängen) als auch auf Polygonen platziert, d. H.  auf Wegen.  Also müssen wir die Anfrage zumindest duplizieren.  Und zweitens ist das Wiki auf der oben genannten Seite im Klartext geschrieben. Es wird nicht empfohlen, Tags zu setzen, die Stadt, Region, Region und Land angeben. Dies muss jedoch geometrisch berechnet werden.  Wie kann man das machen?  Im Allgemeinen ist dies praktisch die Aufgabe der umgekehrten Geokodierung mit Lichtmodifikationen, und sie wurde in einem früheren Beitrag beschrieben. <br><br>  Das heißt, Sie müssen im Allgemeinen administrative Grenzen finden und für alle darin enthaltenen Adressen die Adresse zum Bereich und zu allen oben genannten hinzufügen.  Hier wird beschrieben, wie die Grenzen von Verwaltungseinheiten angeordnet sind. <br><br>  Im Allgemeinen ist diese Aufgabe nicht allzu einfach, aber sie kann gelöst werden, und sie wird nicht durch Geokodierung gelöst, sondern durch Herunterladen von OSM-Updates in unsere Datenbank in einer entspannten Atmosphäre. <br><br><h3>  Was ist nützlich als nächstes zu tun </h3><br>  Im Prinzip können Sie bereits mit den vorhandenen Knoten-, Weg- und Beziehungstabellen arbeiten. Es ist jedoch besser, das Schema ein wenig zu ändern, damit es besser für Hive und Spark geeignet ist.  Tatsache ist, dass das OSM-Schema vollständig normalisiert ist und Wege und Beziehungen überhaupt keine Koordinaten enthalten.  Um ein Polygon für den Weg zu erstellen, müssen Sie sich mit Knoten verbinden.  Ich würde empfehlen, diese Operation sofort auszuführen und die Polygone entweder als Array von Strukturen (Hive kann mit den zusammengesetzten Typen Array, Map und Struct arbeiten) oder sofort als serialisierte Darstellung beispielsweise der Geometry-Klasse zu speichern.  Wie das geht, zeigt das Beispiel des Autor Parkettierers. <br><br>  Sie können eine ähnliche Operation auf der Ebene der Beziehungen wiederholen, wenn Sie möchten, aber es lohnt sich kaum.  Erstens benötigen Sie nicht immer alle Elemente einer Beziehung, und zweitens sind die Beziehungen selbst in OSM viel kleiner. <br><br><h2>  Konverter zu Avro </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> ist ein weiterer Konverter, diesmal in das Avro-Format.  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier wird</a> beschrieben, wo man die fertigen Dateien bekommt.  Ich habe die Größen nicht gemessen, aber ich denke, dass ungefähr 15-20 Dateien pro Planet mit PBF vergleichbar sein sollten.  Das heißt, das sind Gigabyte und vieles mehr. <br><br><h2>  Einige Schlussfolgerungen </h2><br>  Und wo ist Geokodierung, fragst du?  Ja, das Herunterladen von Karten und das Extrahieren von Adressen ist nur ein Teil der Gesamtaufgabe.  Ich hoffe es kommt dazu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438374/">https://habr.com/ru/post/de438374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438364/index.html">Replikation des weltweit ersten digitalen Voice Scramblers</a></li>
<li><a href="../de438366/index.html">Noch eine Überprüfung der OATH-Hardware-Token-Funktion in Azure Cloud MFA</a></li>
<li><a href="../de438368/index.html">Intelligente Glühbirnen, die in den Müll geworfen werden, sind eine wertvolle Quelle für persönliche Informationen.</a></li>
<li><a href="../de438370/index.html">Cyberkriminalität als Dienstleistung: Dienstleistungen und Preise</a></li>
<li><a href="../de438372/index.html">Die NASA versucht weiterhin, Kontakt zu Opportunity aufzunehmen</a></li>
<li><a href="../de438376/index.html">Reverse Engineering. Die Geschichte. Meins</a></li>
<li><a href="../de438380/index.html">Männchen, Pause bei gefangenen Ausnahmen</a></li>
<li><a href="../de438382/index.html">Organisation einer Suche auf einer Webseite in JavaScript (ohne jQuery)</a></li>
<li><a href="../de438384/index.html">Chemieunterricht: Wie man den Kristall eines Mikrochips für die Fotografie freilegt</a></li>
<li><a href="../de438386/index.html">Auf dem Weg zu den physikalischen Prinzipien der biologischen Evolution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>