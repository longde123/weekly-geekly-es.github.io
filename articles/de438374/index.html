<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè® ü§òüèæ üë®üèΩ‚ÄçüöÄ Wie lade ich OpenStreetMap in Hive? üí≥ üìª ü§¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem fr√ºheren Artikel habe ich die umgekehrte Geokodierung mit Spark untersucht. Stellen Sie sich nun vor, wir st√ºnden vor der Herausforderung der...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie lade ich OpenStreetMap in Hive?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438374/">  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel habe</a> ich die umgekehrte Geokodierung mit Spark untersucht.  Stellen Sie sich nun vor, wir st√ºnden vor der Herausforderung der direkten Geokodierung von E-Mail-Adressen.  Das hei√üt, Empfangen f√ºr die Adresse, die durch den Text einiger geografischer Koordinaten aufgezeichnet wurde. <br><br>  Die Adressen f√ºr die Bestimmtheit sind russisch und vor allem - sie sind oft schief geschrieben, dh mit Fehlern, Unklarheiten und anderen Freuden.  Diese Adressen befinden sich in der Hive-Datenbank im Hadoop-Cluster. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/8n/_s/vc8n_sp2pkut9qvilbnt6u2whqs.png"></div><br>  Nun, es scheint, wir verwenden die Google Maps-Geokodierungs-API (oder, wenn Sie die Importsubstitution unterst√ºtzen, die Yandex Maps-API) und arbeiten.  Aber hier warten wir ebenso wie bei der umgekehrten Geokodierung auf einen kleinen Hinterhalt. <br><a name="habracut"></a><br>  Oder gro√ü, es ist wie ein Blick.  Tatsache ist, dass wir diesmal ungef√§hr 5 Millionen Adressen verarbeiten m√ºssen.  Und vielleicht 50 - es war nicht sofort klar.  Wie Sie wissen, wird Google Ihre IP-Adresse nach etwa 10.000 Adressen sperren. Yandex wird dasselbe mit Ihnen tun, obwohl dies etwas sp√§ter m√∂glich ist (z. B. 25.000 Anfragen pro Tag).  Au√üerdem sind beide APIs REST, was bedeutet, dass es relativ langsam ist.  Und selbst wenn Sie ein kostenpflichtiges Abonnement kaufen, erh√∂ht sich die Geschwindigkeit nicht um einen Cent. <br><br>  Und doch - wir haben keine Munitionsanekdote mehr. <br><br>  Ich habe das Wichtigste vergessen: Unser Hadoop-Cluster befindet sich im Intranet, und Google Maps f√ºr das Unternehmen mit Yandex Maps und alle anderen sind f√ºr uns vom Cluster aus im Allgemeinen nicht zug√§nglich.  Das hei√üt, wir brauchten eine autonome L√∂sung. <br><br>  Ich werde gleich sagen - hier finden Sie keine fertige L√∂sung.  Ich werde nur den Ansatz beschreiben, den wir anwenden m√∂chten, und zwar etwas detaillierter - einer der Schritte auf dem langen Weg zu einer L√∂sung. <br><br>  Nat√ºrlich hatten wir etwas in Reserve.  Es gab einen internen ArcGIS-Server, den ich bereits erw√§hnt habe.  Wir durften sie nicht steuern, aber wir durften ihre REST-Services nutzen. <br><br>  Das erste, was wir gemacht haben, war es an die Aufgabe zu schrauben.  Er hat uns nicht verboten, sondern manchmal nur wegen Wartungsarbeiten ausgeschaltet.  Und was ist sch√∂n - es gab einen Batch-Modus der Geokodierung, wenn Sie ein Adresspaket an die Eingabe senden (nach der Konfiguration des Servers hatten wir eine Paketgr√∂√üe von 1000 St√ºck, standardm√§√üig scheint etwas um eine Gr√∂√üenordnung oder zwei kleiner zu sein).  All dies war auch nicht einfach, und wir und der ArcGIS-Support waren lange Zeit mit dem Server im Sumo-Wrestling besch√§ftigt, aber das ist eine andere Geschichte. <br><br>  Nach all den Tricks und Wendungen konnten wir unsere f√ºnf Millionen in ungef√§hr einem Tag verarbeiten.  Es war notwendig, weiterzumachen und noch zu beschleunigen. <br><br>  Gleichzeitig wurde klar, dass ein Geocoder mit REST h√∂chstwahrscheinlich nicht f√ºr uns geeignet ist.  Au√üerdem haben wir uns Nominatim, Pelias, Photon und Gisgraphie angesehen und waren im Allgemeinen mit keiner zufrieden.  Qualit√§t und Leistung (oder beides) waren alles andere als ideal. <br><br>  Zum Beispiel wei√ü niemand, wie man Pakete geocodiert (und dies hat die Arbeit mit ArcGIS erheblich beschleunigt). <br><br>  Oder Qualit√§t - gehen Sie zum Demo-Server von gisgraphy.com und versuchen Sie, Moskau zu finden.  Sie erhalten ein paar Dutzend Antworten, darunter: Moskau (eine Stadt in der Russischen F√∂deration), Kansas City (eine Stadt in den USA), Khimki, Kaluga, Vykhino-Zhulebino und viele andere Objekte, die ich in der Antwort des Geocoders nicht sehen m√∂chte, wenn Suche nach Moskau. <br><br>  Nun, das letzte (aber f√ºr uns nicht wichtige) Problem ist, dass die API weit entfernt von allen Geocodierern so gut durchdacht ist wie beispielsweise Google Maps.  Nehmen wir an, die ArcGIS-API ist bereits viel unpraktischer und der Rest ist gr√∂√ütenteils noch schlimmer.  Wenn Sie Adressen f√ºr die Benutzeroberfl√§che geocodieren, w√§hlt in der Regel eine Person die beste Option aus.  Und er macht es besser als das Programm.  Und im Fall der Massengeokodierung ist, wie wir es getan haben, die Bewertung der Qualit√§t des Ergebnisses f√ºr eine bestimmte Adresse eine der wichtigen Komponenten des Erfolgs. <br><br>  Infolgedessen sind auch Optionen wie ‚ÄûErweitern Sie Ihre eigenen Nominatim‚Äú verschwunden. <br><br><h2>  Was tun? </h2><br>  Eine ziemlich offensichtliche L√∂sung war folgende: Da die Adressen nicht von irgendwoher stammen und nicht verschwinden, die H√§user nicht jeden Tag gebaut werden und die Stra√üen nicht gebaut werden, m√ºssen Sie unserem Prozess lediglich eine Datenbank mit offiziell vorhandenen Adressen hinzuf√ºgen.  Besser sofort mit den Koordinaten, und wenn dies nicht passiert, dann geocodieren Sie es einmal.  In diesem Fall reicht es aus, wenn wir unsere Basis mit der gleichen H√§ufigkeit aktualisieren, mit der neue H√§user oder Stra√üen erscheinen, dh nicht oft. <br><br>  Der erste und Hauptkandidat f√ºr die Basis bestehender Adressen ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FIAS</a> .  Warten Sie eine Minute, sagen Sie, aber FIAS hat nur wenige Millionen Adressen - und Sie haben bis zu 50 Millionen?  Ja, es gibt wirklich nur ein paar Millionen <b>H√§user</b> .  Und unsere 50 sind 50 Millionen Adressen unserer Benutzer, das hei√üt, dies sind die Adressen von Menschen, und sie haben pl√∂tzlich eine Wohnung in der Adresse.  F√ºnf Millionen H√§user mit 1-100 Wohnungen, in jeder Wohnung leben mehrere Personen ... Sie verstehen alles.  Und die zweite Option sind die Adressen von B√ºros, in denen auch ein B√ºrozentrum bis zu Hunderte von R√§umlichkeiten hat, die manchmal vermietet werden. <br><br>  Gleichzeitig ben√∂tigen wir offensichtlich keine Adresse mit der Nummer der Wohnung (oder des B√ºros) - erstens handelt es sich um personenbezogene Daten mit allen Konsequenzen, und zweitens sind wir immer noch nicht daran interessiert, wie sich die Wohnungen in einem bestimmten Haus befinden und wie ihre Koordinaten lauten .  Es wird nur ein Haus ben√∂tigt.  F√ºr B√ºros ist dies nicht ganz richtig, aber der Standort von B√ºros in einem Geb√§ude nach Etagen wird immer noch nicht durch Koordinaten bestimmt. <br><br>  Mit einer Basis von beispielsweise 5 Millionen (bedingt) vorhandenen H√§usern k√∂nnen wir das Geokodierungsproblem von 50 oder 100 Millionen Adressen l√∂sen, indem wir einfach die Wohnung oder das B√ºro aus der Adresse werfen und sie mit der Basis abgleichen. <br><br>  Und wo bekommt man die Koordinaten der H√§user?  Es gibt nur eine offensichtliche Open Source - OpenStreetMap, dort gibt es H√§user mit Geometrien und verschiedenen anderen Attributen wie der Anzahl der Stockwerke oder sogar der Farbe des Daches. <br><br>  Nach all den Diskussionen hatten wir einen napoleonischen Plan.  Hier ist einer: <br><br><ul><li>  Laden von Kartendaten aus OSM in Hadoop </li><li>  Laden Sie FIAS-Daten mit Adressen hoch </li><li>  Erstellen Sie eine Liste eindeutiger vollst√§ndiger Adressen mit Hausnummern </li><li>  Wir haben es geocodiert, indem wir in OSM nach Adressen gesucht haben. Was wir nicht gefunden haben, ist √ºber ArcGIS </li></ul><br><br>  Wir bekommen die Basis von H√§usern mit L√§ngen- und Breitengrad.  Viel Spa√ü.  Nutzen Sie die Vorteile.  Trinkgeld (Witz). <br><br>  In diesem Artikel werde ich Ihnen erz√§hlen, wie wir den ersten Punkt dieses Plans umgesetzt haben. <br><br><h2>  Was ist OpenStreetMap? </h2><br>  Wenn Sie OSM aus Datensicht betrachten, k√∂nnen Sie sich die Karten in Form von drei Tabellen vorstellen: <br><br><ul><li>  Punkte </li><li>  Linien (Wege) </li><li>  Beziehungen </li></ul><br><br>  Reale Schemata dieser Daten werden unten angegeben. <br><br>  Nur Punkte haben Koordinaten (Breite und L√§nge in Grad).  Linien sind eine geordnete Folge von Punkten.  Beziehungen sind eine Reihe von Punkten und Linien, von denen jeder eine <i>Rolle spielt</i> . <br><br>  Alles andere sind die sogenannten Tags.  Das ist zum Beispiel ein Geldautomat oder ein Gesch√§ft oder ein Eingang zur U-Bahn - es kann ein Punkt sein, der mit dem Tag amenity = atm oder shop = etwas oder etwas anderes ausgestattet ist.  Es gibt ein Verzeichnis offiziell empfohlener Tags (f√ºr jede anwendbare Sprache und jedes Land k√∂nnen sie teilweise ihre eigenen sein) und die Praxis, nicht standardm√§√üige Tags zu erfinden. <br><br>  Zus√§tzlich zu den Tags verf√ºgt jedes Element der Karte √ºber eine eindeutige numerische ID sowie einige Attribute, die sich auf den Verlauf beziehen - wer wann bearbeitet hat, Nummer bearbeitet usw. <br><br>  Die Datenbank mit der Karte ist in verschiedenen Formaten erh√§ltlich: <br>  - pbf ist Google Protobuf, ein tragbares Datenserialisierungsformat. <br>  - XML ‚Äã‚Äãist offensichtlich XML.  Viel mehr Volumen. <br><br>  Sie m√ºssen verstehen, dass die Datenbank t√§glich aktualisiert wird.  Daher sind die Entladungen vollst√§ndig und inkrementell. <br><br>  Wir haben PBF als kompakter gew√§hlt. <br><br>  Um es in Hadoop zu lesen, gibt es eine speziell f√ºr OSM entwickelte Java-API namens Osmoseprojekt.  Im Prinzip ist die Arbeit damit einfach: Sie laden eine Datei hoch und durchlaufen die Kartenelemente.  F√ºgen Sie die Punkte an einer Stelle hinzu, die Linien an einer anderen, die Beziehung an der dritten.  Grunds√§tzlich reichen Osmose und beispielsweise Spark bereits aus, um alle Daten herunterzuladen. <br><br>  Gl√ºcklicherweise kam mir bei der Implementierung meines Fahrrads der Gedanke, im Internet nach der Konvertierung von OSM in die in Hadoop - Parkett (Parkett) und Avro akzeptierten Formate zu suchen.  In gewisser Weise sind beide Analoga von PBF, so dass die M√∂glichkeit bestand, einen Konverter zu finden.  Und er wurde gefunden, aber keiner. <br><br><h2>  Lernen Sie OSM Parquetizer kennen </h2><br>  Sehen Sie, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">was ich gefunden habe!</a> <br><br>  F√ºr faule Leute - direkt in der Readme-Datei des Projekts in der ersten Zeile steht: Telenav ver√∂ffentlicht w√∂chentliche Downloads des Planeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an die Adresse</a> . <br><br>  F√ºr sehr faule Leute: Machen Sie sich bereit, ungef√§hr 700 Gigabyte zu versenden;) Nun, wenn Sie auf jeden Fall einen Planeten brauchen.  Normalerweise kommt man beispielsweise mit Europa aus. <br><br>  Wenn Sie nicht laden m√∂chten, sieht der Vorgang folgenderma√üen aus: Laden Sie eine Karte im PBF-Format herunter, z. B. von einer <a href="">Geofabrik</a> .  Dies sind 2,5 Gigabyte, wenn Sie Russland brauchen, und 19, wenn Europa.  Auch nicht wenig, aber Sie k√∂nnen fein gehackte Proben finden.  Legen Sie als N√§chstes die Datei auf die Festplatte und f√ºhren Sie das Programm aus: <br><br><pre><code class="plaintext hljs">java -jar ./osm-parquetizer.jar russia-latest.osm.pbf</code> </pre> <br>  Nach einigen Minuten oder sogar Sekunden erhalten Sie je nach Leistung Ihres Ger√§ts drei Dateien im Parkettformat.  So sieht der Autor aus (er kommt aus Rum√§nien): <br><br><pre> <code class="plaintext hljs">-rw-r--r-- 1 adrianbona adrianbona 145M Apr 3 19:57 romania-latest.osm.pbf -rw-r--r-- 1 adrianbona adrianbona 372M Apr 3 19:58 romania-latest.osm.pbf.node.parquet -rw-r--r-- 1 adrianbona adrianbona 1.1M Apr 3 19:58 romania-latest.osm.pbf.relation.parquet -rw-r--r-- 1 adrianbona adrianbona 123M Apr 3 19:58 romania-latest.osm.pbf.way.parquet</code> </pre> <br>  Schemata der empfangenen Parkettdateien: <br><br> <code>node <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- latitude: double <br> |-- longitude: double <br> <br> way <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- nodes: array <br> | |-- element: struct <br> | | |-- index: integer <br> | | |-- nodeId: long <br> <br> relation <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- members: array <br> | |-- element: struct <br> | | |-- id: long <br> | | |-- role: string <br> | | |-- type: string <br></code> <br><br>  Wie Sie sehen, ist hier alles einfach.  Dann machen wir folgendes: <br><br><ul><li>  Wir legen Dateien mit dem Befehl hdfs dfs -put auf dem Hadoop-Cluster ab </li><li>  Lassen Sie uns in Hue ein Schema / eine Basis und drei Tabellen daf√ºr erstellen, basierend auf den obigen Daten </li><li>  F√ºhren Sie select * aus osm.nodes aus und genie√üen Sie das Ergebnis. </li></ul><br>  Eine kleine Nuance: In unserer Version von Hive (und m√∂glicherweise auch in Ihrer) k√∂nnen keine Tabellen basierend auf dem Schema von Parquet erstellt werden.  Sie m√ºssen entweder das Obige in CREATE TABLE konvertieren (was im Allgemeinen nicht schwierig ist und ich dies als Heim√ºbung f√ºr die Leser belasse) oder etwas kniffliger vorgehen: Spark kann das Diagramm und die Daten vom Boden aus lesen und darauf basierend tempor√§re Tabellen erstellen .  So k√∂nnen wir die Daten in Spark Shell folgenderma√üen lesen: <br><br><pre> <code class="plaintext hljs">val nodeDF = sqlContext.read.parquet("file:/tmp/osm/romania-latest.osm.pbf.node.parquet") nodeDF.createOrReplaceTempView("nodes")</code> </pre><br>  Dann k√∂nnen Sie bereits Tabellen in Hive mit LIKE-Knoten erstellen. <br><br>  Eine weitere Bemerkung f√ºr faule Leute: Der Autor hat ein so wunderbares <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> , aus dem im Allgemeinen alles klar wird (na ja, wenn Sie Spark besitzen).  Dies ist nat√ºrlich nicht Spark Shell, sondern das Databricks Notebook, aber ich habe ungef√§hr 15 Minuten gebraucht, um auf eine Tastatur zu tippen, um sie in eine andere zu √ºbersetzen.  Und in 30-40 Minuten war es m√∂glich, alles mit einigen Analoga, die sich geringf√ºgig von Spark unterscheiden, in Abfragen f√ºr Hive umzuwandeln. <br><br><h3>  Beispiel f√ºr eine echte Anfrage </h3><br>  Was k√∂nnen wir aus dieser Datenbank in ihrer aktuellen Form erhalten?  Im Allgemeinen ziemlich viel.  Wenn Sie √ºber einen Hive oder Spark, ein Spatial Framework, eine Geometry API oder eine der Alternativen GeoSpark oder beispielsweise GeoMesa verf√ºgen, k√∂nnen Sie auf dieser Basis viele verschiedene Probleme l√∂sen. <br><br>  Sehen wir uns ein Beispiel an.  Der einfachste Weg, um mit Punkten zu arbeiten.  Eine Abfrage zum Abrufen einer Liste von Geldautomaten mit ihren Koordinaten sieht beispielsweise folgenderma√üen aus: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nodes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tags[<span class="hljs-string"><span class="hljs-string">'amenity'</span></span>]=<span class="hljs-string"><span class="hljs-string">'atm'</span></span></code> </pre><br>  Wie man eine solche Abfrage erstellt, kann man erraten, indem man die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite im Wiki</a> liest.  Dort finden Sie, was andere Tags sind, und einige davon k√∂nnen in Ihrer Anfrage anstelle von * enthalten sein, beispielsweise in Form von Tags ['operator'], um den Namen der Bank anzuzeigen. <br><br>  Aus derselben Seite folgt, dass ATM-Markups in Form von Tags m√∂glich sind. Amenity = bank und atm = yes.  Leider gibt es solche Unklarheiten √ºberall in OSM. <br><br>  Wenn Sie ein Anf√§nger sind und sich nur mit OSM vertraut machen, empfehle ich dringend, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Overpass-Turbo</a> (anhand guter Beispiele im Wiki) zu beherrschen.  Dies ist ein Tool, mit dem Sie verschiedene Arten von Suchvorg√§ngen f√ºr Kartendaten durchf√ºhren k√∂nnen, sowohl mit geometrischen Bedingungen als auch mit Bedingungen f√ºr Tags. <br><br><h3>  Und wo sind die Adressen? </h3><br>  Gute Frage.  Adressen in OSM sind Kartenelemente, die mit addr: * -Tags versehen sind, d.h.  beginnend mit addr.  Beschreibung finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Wenn Sie alles wissen, was ich oben angegeben habe, k√∂nnen Sie im Prinzip bereits eine Arbeitsanfrage schreiben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nodes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tags[<span class="hljs-string"><span class="hljs-string">'addr:housenumber'</span></span>]!=<span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  Welche Probleme erwarten uns hier?  Erstens werden Adressen sowohl auf Punkten (z. B. Geb√§udeeing√§ngen) als auch auf Polygonen platziert, d. H.  auf Wegen.  Also m√ºssen wir die Anfrage zumindest duplizieren.  Und zweitens ist das Wiki auf der oben genannten Seite im Klartext geschrieben. Es wird nicht empfohlen, Tags zu setzen, die Stadt, Region, Region und Land angeben. Dies muss jedoch geometrisch berechnet werden.  Wie kann man das machen?  Im Allgemeinen ist dies praktisch die Aufgabe der umgekehrten Geokodierung mit Lichtmodifikationen, und sie wurde in einem fr√ºheren Beitrag beschrieben. <br><br>  Das hei√üt, Sie m√ºssen im Allgemeinen administrative Grenzen finden und f√ºr alle darin enthaltenen Adressen die Adresse zum Bereich und zu allen oben genannten hinzuf√ºgen.  Hier wird beschrieben, wie die Grenzen von Verwaltungseinheiten angeordnet sind. <br><br>  Im Allgemeinen ist diese Aufgabe nicht allzu einfach, aber sie kann gel√∂st werden, und sie wird nicht durch Geokodierung gel√∂st, sondern durch Herunterladen von OSM-Updates in unsere Datenbank in einer entspannten Atmosph√§re. <br><br><h3>  Was ist n√ºtzlich als n√§chstes zu tun </h3><br>  Im Prinzip k√∂nnen Sie bereits mit den vorhandenen Knoten-, Weg- und Beziehungstabellen arbeiten. Es ist jedoch besser, das Schema ein wenig zu √§ndern, damit es besser f√ºr Hive und Spark geeignet ist.  Tatsache ist, dass das OSM-Schema vollst√§ndig normalisiert ist und Wege und Beziehungen √ºberhaupt keine Koordinaten enthalten.  Um ein Polygon f√ºr den Weg zu erstellen, m√ºssen Sie sich mit Knoten verbinden.  Ich w√ºrde empfehlen, diese Operation sofort auszuf√ºhren und die Polygone entweder als Array von Strukturen (Hive kann mit den zusammengesetzten Typen Array, Map und Struct arbeiten) oder sofort als serialisierte Darstellung beispielsweise der Geometry-Klasse zu speichern.  Wie das geht, zeigt das Beispiel des Autor Parkettierers. <br><br>  Sie k√∂nnen eine √§hnliche Operation auf der Ebene der Beziehungen wiederholen, wenn Sie m√∂chten, aber es lohnt sich kaum.  Erstens ben√∂tigen Sie nicht immer alle Elemente einer Beziehung, und zweitens sind die Beziehungen selbst in OSM viel kleiner. <br><br><h2>  Konverter zu Avro </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> ist ein weiterer Konverter, diesmal in das Avro-Format.  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier wird</a> beschrieben, wo man die fertigen Dateien bekommt.  Ich habe die Gr√∂√üen nicht gemessen, aber ich denke, dass ungef√§hr 15-20 Dateien pro Planet mit PBF vergleichbar sein sollten.  Das hei√üt, das sind Gigabyte und vieles mehr. <br><br><h2>  Einige Schlussfolgerungen </h2><br>  Und wo ist Geokodierung, fragst du?  Ja, das Herunterladen von Karten und das Extrahieren von Adressen ist nur ein Teil der Gesamtaufgabe.  Ich hoffe es kommt dazu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438374/">https://habr.com/ru/post/de438374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438364/index.html">Replikation des weltweit ersten digitalen Voice Scramblers</a></li>
<li><a href="../de438366/index.html">Noch eine √úberpr√ºfung der OATH-Hardware-Token-Funktion in Azure Cloud MFA</a></li>
<li><a href="../de438368/index.html">Intelligente Gl√ºhbirnen, die in den M√ºll geworfen werden, sind eine wertvolle Quelle f√ºr pers√∂nliche Informationen.</a></li>
<li><a href="../de438370/index.html">Cyberkriminalit√§t als Dienstleistung: Dienstleistungen und Preise</a></li>
<li><a href="../de438372/index.html">Die NASA versucht weiterhin, Kontakt zu Opportunity aufzunehmen</a></li>
<li><a href="../de438376/index.html">Reverse Engineering. Die Geschichte. Meins</a></li>
<li><a href="../de438380/index.html">M√§nnchen, Pause bei gefangenen Ausnahmen</a></li>
<li><a href="../de438382/index.html">Organisation einer Suche auf einer Webseite in JavaScript (ohne jQuery)</a></li>
<li><a href="../de438384/index.html">Chemieunterricht: Wie man den Kristall eines Mikrochips f√ºr die Fotografie freilegt</a></li>
<li><a href="../de438386/index.html">Auf dem Weg zu den physikalischen Prinzipien der biologischen Evolution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>