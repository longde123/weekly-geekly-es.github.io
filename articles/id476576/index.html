<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒœ ğŸ§›ğŸ½ ğŸ‘ŒğŸ¼ JSON-RPC? Ambil REST yang rumit ğŸˆ¹ â‡ï¸ â¤ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya yakin bahwa berita utama itu menimbulkan reaksi yang sehat - "Ya, itu mulai lagi ..." Tetapi biarkan saya menarik perhatian Anda selama 5-10 meni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JSON-RPC? Ambil REST yang rumit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476576/"><p><img src="https://habrastorage.org/webt/q0/at/ek/q0atekvadeakqoxlbkht27oxt8c.jpeg"></p><br><p>  Saya yakin bahwa berita utama itu menimbulkan reaksi yang sehat - "Ya, itu mulai lagi ..." Tetapi biarkan saya menarik perhatian Anda selama 5-10 menit, dan saya akan berusaha untuk tidak menipu harapan. </p><br><p> Struktur artikel akan menjadi sebagai berikut: pernyataan stereotip diambil dan "sifat" dari munculnya stereotip ini terungkap.  Saya harap ini memungkinkan Anda untuk melihat pilihan paradigma pertukaran data dalam proyek Anda dari sudut pandang baru. </p><br><p>  Untuk memperjelas apa itu RPC, saya mengusulkan untuk mempertimbangkan standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSON-RPC 2.0</a> .  Tidak ada kejelasan dengan REST.  Dan seharusnya tidak.  Semua yang perlu Anda ketahui tentang REST - tidak bisa dibedakan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HTTP</a> . </p><a name="habracut"></a><br><h2 id="rpc-zaprosy-bystree-i-effektivnee-potomu-chto-pozvolyayut-delat-batch-zaprosy">  Permintaan RPC lebih cepat dan lebih efisien karena memungkinkan permintaan batch. </h2><br><p>  Intinya adalah bahwa dalam RPC dimungkinkan untuk melakukan panggilan ke beberapa prosedur dalam satu permintaan.  Misalnya, buat pengguna, tambahkan avatar padanya dan permintaan yang sama tandatangani dia pada beberapa topik.  Hanya satu permintaan, dan seberapa bagus! </p><br><p>  Memang, jika Anda hanya memiliki satu simpul backend, ini akan tampak lebih cepat dengan permintaan batch.  Karena tiga permintaan REST akan membutuhkan sumber daya tiga kali lebih banyak dari satu node untuk membuat koneksi. </p><br><p><img src="https://habrastorage.org/webt/wd/o9/yy/wdo9yyuiainix3lto2vtfwl4jtu.jpeg"></p><br><p>  Harap dicatat bahwa permintaan pertama dalam kasus REST harus mengembalikan ID pengguna untuk permintaan berikutnya.  Yang juga berdampak negatif pada hasil keseluruhan. </p><br><p>  Tetapi infrastruktur seperti itu dapat ditemukan, mungkin, dalam solusi internal dan Enterprise.  Sebagai upaya terakhir, dalam proyek WEB kecil.  Tetapi solusi WEB lengkap, dan juga disebut HighLoad, tidak boleh dibangun seperti ini.  Infrastruktur mereka harus memenuhi kriteria ketersediaan tinggi dan beban kerja.  Dan gambarnya berubah. </p><br><p><img src="https://habrastorage.org/webt/q5/x_/js/q5x_js3bh9se9vzjejgpyqfeexq.jpeg"></p><br><p>  Hijau menunjukkan saluran aktivitas infrastruktur dalam skenario yang sama.  Perhatikan bagaimana perilaku RPC sekarang.  Permintaan menggunakan infrastruktur hanya satu bahu dari penyeimbang ke backend.  Meskipun REST masih kalah dalam permintaan pertama, tetapi mengganti waktu yang hilang menggunakan seluruh infrastruktur. </p><br><p>  Cukup dengan memasukkan dalam naskah bukan dua permintaan untuk pengayaan, tetapi, katakanlah, lima atau sepuluh ... dan jawaban untuk pertanyaan "siapa yang menang sekarang?" Menjadi tidak jelas. </p><br><p>  Saya mengusulkan untuk melihat masalah yang lebih luas.  Diagram menunjukkan bagaimana saluran infrastruktur digunakan, tetapi infrastruktur tidak terbatas pada saluran.  Komponen penting dari infrastruktur yang sarat muatan adalah cache.  Mari kita ambil beberapa artefak pengguna sekarang.  Beberapa kali.  Katakan 32 kali. </p><br><p><img src="https://habrastorage.org/webt/vp/ts/es/vptseszry2ujpaxxlorxj5dk3gu.jpeg"></p><br><p>  Lihat bagaimana infrastruktur pada RPC telah tampak "pulih" untuk memenuhi tuntutan beban tinggi.  Masalahnya adalah bahwa REST menggunakan kekuatan penuh dari protokol HTTP, tidak seperti RPC.  Dalam diagram di atas, kekuatan ini diwujudkan melalui metode permintaan - GET. </p><br><p>  Metode HTTP, antara lain, memiliki strategi caching.  Anda dapat mengenal mereka di dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HTTP</a> .  Untuk RPC, permintaan POST yang tidak dianggap sebagai idempoten digunakan, yaitu pengulangan berulang dari permintaan POST yang sama dapat mengembalikan hasil yang berbeda (misalnya, setelah setiap komentar dikirim, salinan lain dari komentar ini akan muncul) ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> ). </p><br><p>  Akibatnya, RPC tidak dapat menggunakan cache infrastruktur secara efisien.  Ini mengarah pada fakta bahwa Anda harus "mengimpor" cache perangkat lunak.  Diagram menunjukkan Redis dalam peran ini.  Soft cache, pada gilirannya, mengharuskan pengembang lapisan kode tambahan dan perubahan signifikan dalam arsitektur. </p><br><p>  Sekarang mari kita menghitung berapa banyak permintaan â€œmelahirkanâ€ REST dan RPC dalam infrastruktur yang sedang dipertimbangkan? </p><br><div class="scrollable-table"><table><thead><tr><th>  Pertanyaan </th><th>  Kotak masuk </th><th>  untuk backend </th><th>  ke DBMS </th><th>  untuk melunakkan cache (Redis) </th><th>  TOTAL </th></tr></thead><tbody><tr><td>  SISA </td><td>  1/32 * </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  3/35 </td></tr><tr><td>  Rpc </td><td>  32 </td><td>  32 </td><td>  1 </td><td>  31 </td><td>  96 </td></tr></tbody></table></div><br><p>  [*] dalam kasus terbaik (jika cache lokal digunakan) 1 permintaan (satu!), dalam 32 permintaan terburuk yang masuk. </p><br><p>  Dibandingkan dengan skema pertama, perbedaannya mencolok.  Kemenangan REST sekarang jelas.  Tetapi saya mengusulkan untuk tidak berhenti di situ.  Infrastruktur yang dikembangkan termasuk CDN.  Seringkali, ia juga memecahkan masalah melawan serangan DDoS dan DoS.  Kami mendapatkan: </p><br><p><img src="https://habrastorage.org/webt/k2/9f/ky/k29fkywcpnld_poisd1s7g9oxhs.jpeg"></p><br><p>  Di sini untuk RPC, semuanya menjadi sangat menyedihkan.  RPC tidak dapat mendelegasikan pekerjaan dengan memuat CDN.  Seseorang hanya dapat mengandalkan sistem untuk melawan serangan. </p><br><p>  Apakah mungkin untuk mengakhiri ini?  Dan lagi, tidak.  Metode HTTP, seperti yang disebutkan di atas, memiliki "keajaiban" sendiri.  Dan untuk alasan yang baik, metode GET benar-benar digunakan di Internet.  Harap dicatat bahwa metode ini dapat mengakses bagian dari konten, dapat mengatur kondisi yang dapat menafsirkan elemen infrastruktur sebelum mentransfer kontrol ke kode Anda, dll.  Semua ini memungkinkan Anda untuk membuat infrastruktur yang fleksibel dan dapat dikelola yang dapat mencerna aliran permintaan yang sangat besar.  Dan di RPC, metode ini ... diabaikan. </p><br><p>  Jadi mengapa mitos ini begitu gigih sehingga permintaan batch (RPC) lebih cepat?  Secara pribadi, saya merasa bahwa sebagian besar proyek tidak mencapai tingkat pengembangan ketika REST mampu menunjukkan kekuatannya.  Selain itu, dalam proyek-proyek kecil, ia lebih cenderung menunjukkan kelemahannya. </p><br><p>  Pilihan REST atau RPC bukanlah pilihan sukarela individu dalam proyek.  Pilihan ini harus memenuhi persyaratan proyek.  Jika proyek mampu keluar dari REST semua yang benar-benar bisa, dan itu benar-benar diperlukan, maka REST akan menjadi pilihan yang sangat baik. </p><br><p>  Tetapi jika untuk mendapatkan semua keuntungan REST, Anda perlu menyewa devops untuk segera meningkatkan infrastruktur, administrator untuk mengelola infrastruktur, arsitek untuk merancang semua lapisan layanan WEB ... dan proyek akan menjual tiga bungkus margarin per hari ... Saya akan berhenti di RPC sejak itu  protokol ini lebih bermanfaat.  Ini tidak memerlukan pengetahuan mendalam tentang operasi cache dan infrastruktur, tetapi memfokuskan pengembang pada panggilan sederhana dan dapat dimengerti ke prosedur yang diperlukan.  Bisnis akan senang. </p><br><h2 id="rpc-zaprosy-nadezhnee-potomu-chto-mogut-vypolnyat-batch-zaprosy-v-ramkah-odnoy-tranzakcii">  Permintaan RPC lebih dapat diandalkan karena mereka dapat menjalankan permintaan batch dalam satu transaksi </h2><br><p>  Properti RPC ini merupakan nilai tambah pasti, karena  mudah untuk menjaga database dalam keadaan konsisten.  Tetapi dengan REST, semuanya lebih rumit.  Permintaan dapat tiba secara tidak konsisten pada berbagai node backend. </p><br><p>  "Kelemahan" REST ini adalah sisi lain dari kelebihannya yang dijelaskan di atas - kemampuan untuk menggunakan semua sumber daya infrastruktur secara efektif.  Jika infrastruktur dirancang dengan buruk, dan bahkan lebih lagi jika arsitektur proyek dan database khususnya dirancang dengan buruk, maka ini benar-benar menyebalkan. </p><br><p>  Tetapi apakah permintaan batch dapat diandalkan seperti kelihatannya?  Mari kita lihat kasusnya: membuat pengguna, memperkaya profilnya dengan beberapa deskripsi dan mengiriminya SMS dengan rahasia untuk menyelesaikan pendaftaran.  Yaitu  tiga panggilan dalam satu permintaan batch. </p><br><p><img src="https://habrastorage.org/webt/i5/ry/4k/i5ry4k9evunfpvdeowewzqkpmkm.jpeg"></p><br><p>  Mari kita pertimbangkan skemanya.  Ini menyajikan infrastruktur dengan elemen ketersediaan tinggi.  Ada dua saluran komunikasi independen dengan gateway SMS.  Tapi ... apa yang kita lihat?  Saat mengirim SMS, kesalahan 503 terjadi - layanan sementara tidak tersedia.  Karena  mengirim SMS dikemas dalam permintaan batch, maka seluruh permintaan harus dibatalkan.  Tindakan dalam DBMS dibatalkan.  Klien menerima kesalahan. </p><br><p>  Upaya selanjutnya adalah lotere.  Entah permintaan pergi ke simpul yang sama lagi dan mengembalikan kesalahan, atau Anda beruntung dan itu akan dieksekusi.  Tetapi yang utama adalah bahwa setidaknya sekali infrastruktur kita telah bekerja dengan sia-sia.  Ada beban, tapi tidak ada untung. </p><br><p>  Nah, mari kita bayangkan bahwa kita tegang (!) Dan memikirkan opsi di mana permintaan dapat diselesaikan sebagian.  Dan sisanya, kita akan mencoba lagi untuk memenuhi setelah beberapa interval waktu (Yang? Tentukan bagian depan?).  Tapi lotere tetap ada.  Permintaan untuk mengirim SMS dengan probabilitas 50/50 akan gagal lagi. </p><br><p>  Setuju, di sisi klien, layanan ini tampaknya tidak dapat diandalkan seperti yang kita inginkan ... tetapi bagaimana dengan REST? </p><br><p><img src="https://habrastorage.org/webt/yu/ol/yy/yuolyyficausbg8c3jgzmddc1kk.jpeg"></p><br><p>  REST menggunakan sihir HTTP lagi, tetapi sekarang dengan kode respons.  Jika kesalahan 503 terjadi pada gateway SMS, backend menyiarkan kesalahan ini ke penyeimbang.  Penyeimbang menerima kesalahan ini, dan tanpa memutus koneksi dengan klien, mengirimkan permintaan ke node lain yang berhasil memproses permintaan tersebut.  Yaitu  klien menerima hasil yang diharapkan, dan infrastruktur mengkonfirmasi peringkat tinggi "sangat mudah diakses".  Pengguna itu senang. </p><br><p>  Dan lagi, ini belum semuanya.  Penyeimbang tidak hanya menerima kode respons 503. Disarankan untuk memberikan kode ini dengan tajuk "Coba Lagi" ketika menjawab. Tajuk menjelaskan kepada penyeimbang bahwa Anda tidak boleh mengganggu simpul ini pada rute ini untuk waktu tertentu. Dan permintaan pengiriman SMS berikut ini akan segera dikirim ke node yang tidak memiliki masalah dengan SMS gateway. </p><br><p>  Seperti yang bisa kita lihat, keandalan JSON-RPC terlalu dibesar-besarkan.  Memang, lebih mudah untuk mengatur konsistensi database.  Tetapi korban, dalam hal ini, akan menjadi keandalan sistem secara keseluruhan. </p><br><p>  Kesimpulannya sebagian besar mirip dengan yang sebelumnya.  Ketika infrastrukturnya sederhana, kejelasan JSON-RPC tidak diragukan lagi kelebihannya.  Jika suatu proyek melibatkan ketersediaan tinggi dengan beban tinggi, REST terlihat seperti solusi yang lebih akurat, meskipun lebih kompleks. </p><br><h2 id="porog-vhoda-v-rest-nizhe">  Ambang entri REST di bawah </h2><br><p>  Saya pikir analisis di atas, menghilangkan prasangka stereotip tentang RPC, dengan jelas menunjukkan bahwa ambang batas untuk memasuki REST tidak diragukan lagi lebih tinggi daripada di RPC.  Hal ini disebabkan oleh kebutuhan akan pemahaman yang mendalam tentang HTTP, serta kebutuhan untuk memiliki pengetahuan yang cukup tentang elemen infrastruktur yang ada yang dapat dan harus digunakan dalam proyek WEB. </p><br><p>  Jadi mengapa banyak orang berpikir bahwa REST akan lebih mudah?  Pendapat pribadi saya adalah bahwa kesederhanaan yang tampak ini berasal dari REST yang memanifestasikan diri.  Yaitu  REST bukan protokol, tetapi sebuah konsep ... REST tidak memiliki standar, ada beberapa rekomendasi ... REST tidak lebih rumit dari HTTP.  Kebebasan dan anarki yang tampak menarik "seniman bebas". </p><br><p>  Tidak diragukan lagi, REST tidak lebih rumit dari HTTP.  Tetapi HTTP sendiri adalah protokol yang dirancang dengan baik yang telah terbukti selama beberapa dekade.  Jika tidak ada pemahaman mendalam tentang HTTP itu sendiri, maka REST tidak dapat dinilai. </p><br><p>  Tetapi tentang RPC - Anda bisa.  Sudah cukup untuk mengambil spesifikasinya.  Jadi, apakah Anda memerlukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSON-RPC yang bodoh</a> ?  Atau apakah REST itu licik?  Terserah kamu. </p><br><p>  Saya sungguh berharap bahwa saya tidak membuang waktu Anda dengan sia-sia. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476576/">https://habr.com/ru/post/id476576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476554/index.html">Streaming WebRTC berbasis cloud di DigitalOcean</a></li>
<li><a href="../id476556/index.html">Narasi dan "ruang bawah tanah": bagaimana perancang game mengaitkan lokasi dengan plot</a></li>
<li><a href="../id476558/index.html">ONYX BOOX Max 3 ulasan: pembaca layar maksimum</a></li>
<li><a href="../id476566/index.html">Bagaimana memahami apakah aset digital adalah sekuritas? Instruksi SEC</a></li>
<li><a href="../id476570/index.html">Pendapat pribadi tentang Yandex.Turbo</a></li>
<li><a href="../id476578/index.html">9 Manfaat Utama Teknologi Blockchain Dalam Perangkat Lunak Olah Raga</a></li>
<li><a href="../id476580/index.html">Horizontal vs pertumbuhan vertikal pengembang. Pendapat dari ivi dan Yandex</a></li>
<li><a href="../id476582/index.html">Penghitung DWT</a></li>
<li><a href="../id476590/index.html">Cara mengemas aplikasi VueJS + NodeJS + MongoDB di Docker</a></li>
<li><a href="../id476592/index.html">CLRium # 6: 9 hari lagi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>