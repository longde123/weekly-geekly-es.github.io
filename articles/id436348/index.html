<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍰 🎷 🙎🏾 Pengembangan tim untuk menanyakan data dari database - bagian 2 🛎️ 🙁 🧝🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian sebelumnya, saya fokus pada fakta bahwa tim yang saya kembangkan menerapkan perilaku yang dapat dijelaskan dengan tes ini: 


it('execute ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan tim untuk menanyakan data dari database - bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436348/"><p>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya,</a> saya fokus pada fakta bahwa tim yang saya kembangkan menerapkan perilaku yang dapat dijelaskan dengan tes ini: </p><br><pre><code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'execute should return promise'</span></span>, () =&gt; { request.configure(options); request.execute().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { expect(result.Id).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(result.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <a name="habracut"></a><br><p>  Sepertinya saya sekarang yang mendapatkan <code>Promise</code> sebagai hasil dan memprosesnya tidak seperti yang saya inginkan.  Akan lebih baik jika tim itu sendiri melakukan pekerjaan rutin ini, dan hasilnya akan ditempatkan, misalnya, dalam repositori <code>Redux</code> .  Saya akan mencoba menulis ulang tes yang ada untuk mengungkapkan harapan baru saya di dalamnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../src/store'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DbMock = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../mocks/DbMock'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMock(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Request = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../src/storage/Request'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(db, store); }); it(<span class="hljs-string"><span class="hljs-string">'should dispatch action if record exists'</span></span>, () =&gt; { request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = store.getState().user; expect(user.Id).toEqual(options.query.Id); expect(user.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Ini mungkin lebih nyaman, meskipun saya sekarang harus mengajarkan metode <code>execute</code> dari kelas <code>Request</code> untuk mengeksekusi metode panggilan balik jika pengguna meneruskannya sebagai argumen.  Anda tidak dapat melakukannya tanpa itu, karena <code>execute</code> dalam saya kira akan menggunakan panggilan asinkron, hasil pengujian yang hanya dapat diuji jika mereka yakin bahwa eksekusi mereka telah selesai. </p><br><p>  Selanjutnya ... Melihat baris kode pertama, saya mengerti bahwa sebelum saya dapat kembali mengedit kode kelas <code>Request</code> , saya perlu menambahkan paket <code>Redux</code> ke proyek, mengimplementasikan setidaknya satu <code></code> dan secara terpisah mengemas peredam ini di <code>Store</code> .  Tes pertama mungkin untuk gearbox: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reduce = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../src/reducers/user'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should return new state'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">Name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = reduce(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'USER'</span></span>, user }); expect(state).toEqual(user); });</code> </pre> <br><p>  Saya menjalankan tes dan setuju dengan <code>Jasmine</code> bahwa selain semua kesalahan sebelumnya, modul dengan nama <code>../../src/reducers/user</code> tidak ditemukan.  Oleh karena itu, saya akan menulisnya, terutama karena ia berjanji untuk menjadi kecil dan sangat dapat diprediksi: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, action</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'USER'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action.user; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = user;</code> </pre> <br><p>  Saya menjalankan tes dan tidak melihat peningkatan radikal.  Ini karena modul <code>../../src/store</code> , keberadaan yang saya asumsikan dalam tes untuk kelas <code>Request</code> saya, saya belum diimplementasikan.  Dan belum ada tes untuknya.  Saya akan mulai dengan tes: </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'store'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../src/store'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should reduce USER'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">Name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span> }; store.dispatch({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'USER'</span></span>, user }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = store.getState(); expect(state.user).toEqual(user); }); });</code> </pre> <br><p>  Tes?  Ada lebih banyak laporan tentang kurangnya modul <code>store</code> , jadi saya akan menanganinya segera. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createStore = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).createStore; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combineReducers = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).combineReducers; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./reducers/user'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducers = combineReducers({user}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducers); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = store;</code> </pre> <br><p>  Memahami bahwa saya akan memiliki lebih dari satu gearbox, saya menjalankan sedikit ke depan dalam implementasi <code></code> dan menggunakan metode <code>combineReducers</code> ketika merakitnya.  Saya menjalankan tes lagi dan melihat pesan kesalahan baru yang memberi tahu saya bahwa metode <code>execute</code> kelas <code>Request</code> saya tidak berfungsi seperti yang disarankan tes saya.  Sebagai hasil dari metode eksekusi, catatan pengguna tidak muncul di <code></code> .  Sudah waktunya untuk memperbaiki kelas <code>Request</code> . </p><br><p>  Saya ingat bagaimana sekarang tes dari metode <code>execute</code> terlihat seperti: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should dispatch action if record exists'</span></span>, () =&gt; { request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = store.getState().user; expect(user.Id).toEqual(options.query.Id); expect(user.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Dan saya akan memperbaiki kode metode itu sendiri sehingga tes memiliki kesempatan untuk dieksekusi: </p><br><pre> <code class="javascript hljs">execute(callback){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> table = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.db.Model.extend({ <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.tableName }); table.where(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.query).fetch().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'USER'</span></span>, <span class="hljs-attr"><span class="hljs-attr">user</span></span>: item }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> callback === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) callback(); }); }</code> </pre> <br><p>  Saya akan mengetikkan <code>npm test</code> console dan ... Bingo!  Permintaan saya belajar tidak hanya untuk menerima data dari database, tetapi juga untuk menyimpannya dalam <code> </code> proses pemrosesan di masa depan, sehingga operasi selanjutnya dapat menerima data ini tanpa masalah. </p><br><p>  Tapi!  Pawang saya hanya dapat mengirim satu jenis tindakan ke <code> </code> , dan ini sangat membatasi kemampuannya.  Tapi saya ingin menggunakan kode ini berulang kali setiap kali saya perlu mengekstrak beberapa catatan dari database dan mengirimkannya ke sel <code> </code> untuk diproses lebih lanjut di bawah kunci yang saya butuhkan.  Maka saya mulai refactoring tes lagi: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">Id</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> }, success (result, store) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'USER'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action = { type , <span class="hljs-attr"><span class="hljs-attr">user</span></span>: result }; store.dispatch(action); } }; it(<span class="hljs-string"><span class="hljs-string">'should dispatch action if record exists'</span></span>, () =&gt; { request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = store.getState().user; expect(user.Id).toEqual(options.query.Id); expect(user.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Terpikir oleh saya bahwa akan lebih baik untuk menyimpan kelas <code>Request</code> dari fungsi yang tidak biasa untuk memproses hasil permintaan.  <code>Request</code> semantik adalah permintaan.  Memenuhi permintaan, menerima jawaban, tugas selesai, prinsip tanggung jawab tunggal kelas dihormati.  Dan biarkan seseorang yang terlatih secara khusus dalam proses ini menangani hasilnya, yang tanggung jawabnya seharusnya adalah versi tertentu dari proses itu sendiri.  Oleh karena itu, saya memutuskan untuk mentransfer metode <code>success</code> ke pengaturan permintaan, yang merupakan tugas memproses data yang berhasil dikembalikan oleh permintaan. </p><br><p>  Tes, sekarang Anda tidak bisa lari.  Saya mengerti itu secara intelektual.  Saya tidak memperbaiki apa pun dalam tes itu sendiri dan tidak mengubah apa pun dalam implementasi, dan tes harus terus berjalan dengan sukses.  Tetapi secara emosional, saya perlu menjalankan perintah <code>npm test</code> dan saya menjalankannya, dan saya melanjutkan untuk mengedit implementasi metode <code>execute</code> saya di kelas <code>Request</code> untuk mengganti baris dengan panggilan ke <code>store.dispatch(...)</code> dengan baris dengan panggilan ke <code>this.options.success(...)</code> : </p><br><pre> <code class="javascript hljs">execute(callback){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> table = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.db.Model.extend({ <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.tableName }); table.where(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.query).fetch().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.success(item, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> callback !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) callback(); }); }</code> </pre> <br><p>  Saya menjalankan tes.  Voila!  Tes sepenuhnya hijau.  Hidup menjadi lebih baik!  Apa selanjutnya  Segera saya melihat bahwa Anda perlu mengubah judul tes, karena itu tidak cukup sesuai dengan kenyataan.  Tes tidak memeriksa bahwa pengiriman metode terjadi sebagai hasil dari permintaan, tetapi permintaan memperbarui keadaan dalam wadah.  Oleh karena itu, saya mengubah judul tes menjadi ... yah, misalnya: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should update store user state if record exists'</span></span>, () =&gt; { request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = store.getState().user; expect(user.Id).toEqual(options.query.Id); expect(user.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Apa selanjutnya  Dan kemudian saya pikir sudah waktunya untuk memperhatikan bukan kasus ketika, alih-alih data yang diminta, permintaan saya akan mengembalikan kesalahan.  Ini bukan skenario yang mustahil.  Benar?  Dan hal utama adalah bahwa dalam hal ini, saya tidak akan dapat menyiapkan dan mengirim set data yang diperlukan ke operator KYC saya, demi integrasi dengan mana saya menulis semua kode ini.  Benarkah begitu?  Jadi  Pertama saya akan menulis tes: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should add item to store error state'</span></span>, () =&gt; { options.query = { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">555</span></span> }; options.error = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, store</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action = { type, error }; store.dispatch(action); }; request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = store.getState().error; expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(error)).toBeTruthy(); expect(error.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(error[<span class="hljs-number"><span class="hljs-number">0</span></span>].message).toEqual(<span class="hljs-string"><span class="hljs-string">'Something goes wrong!'</span></span>); }); });</code> </pre> <br><p>  Saya tidak tahu apakah struktur tes menunjukkan bahwa saya memutuskan untuk menghemat waktu dan uang dan menulis kode minimum untuk memeriksa apakah permintaan mengembalikan kesalahan?  Tidak melihat </p><br><p>  Saya tidak ingin membuang waktu coding implementasi tambahan <code>TableMock</code> , yang akan meniru kesalahan.  Saya memutuskan bahwa saat ini beberapa konstruksi kondisional dalam implementasi yang ada akan cukup bagi saya, dan menyarankan bahwa ini dapat disesuaikan melalui parameter kueri <code>query</code> .  Jadi asumsi saya adalah: </p><br><ul><li>  Jika <code>Id</code> dalam kueri <code>options.query</code> adalah <strong>1</strong> , maka pseudo-table saya selalu mengembalikan <code>Promise</code> diizinkan dengan catatan pertama dari koleksi. </li><li>  Jika <code>Id</code> dalam kueri <code>options.query</code> adalah <strong>555</strong> , maka pseudo-table saya selalu mengembalikan <code>Promise</code> ditolak dengan contoh <code>Error</code> di dalam, yang konten <code>message</code> <strong>Ada yang salah!</strong>  . </li></ul><br><p>  Tentu saja, ini jauh dari ideal.  Akan jauh lebih mudah dibaca dan nyaman bagi persepsi untuk menerapkan contoh <code>DbMock</code> sesuai, baik, misalnya, <code>FaultyDbMock</code> , <code>EmptyDbMock</code> , <code>EmptyDbMock</code> .  Dari nama-nama yang segera jelas bahwa yang pertama akan selalu berfungsi dengan benar, yang kedua akan selalu bekerja secara salah, dan untuk yang ketiga, kita dapat mengasumsikan bahwa ia akan selalu mengembalikan <code>null</code> alih-alih hasilnya.  Mungkin, setelah memeriksa asumsi pertama saya dengan cara yang disebutkan di atas, bahwa bagi saya tampaknya mengambil waktu minimum, saya akan <code>DbMock</code> implementasi dua contoh tambahan <code>DbMock</code> yang mensimulasikan perilaku <em>tidak sehat</em> . </p><br><p>  Saya menjalankan tes.  Saya mendapatkan kesalahan yang diharapkan dari kurangnya properti yang saya butuhkan di <code> </code> dan ... Saya sedang menulis tes lain.  Kali ini untuk gearbox yang akan menangani aksi dengan tipe <code>ERROR</code> . </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reduce = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../src/reducers/error'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should add error to state array'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Oooops!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = reduce(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, { type, error }); expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(state)).toBeTruthy(); expect(state.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(state.includes(error)).toBeTruthy(); }); });</code> </pre> <br><p>  Menjalankan tes lagi.  Semuanya diharapkan, satu lagi telah ditambahkan ke kesalahan yang ada.  Saya menyadari <code></code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = [], action</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state.concat([action.error]); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = error;</code> </pre> <br><p>  Sekali lagi, jalankan tes.  Peredam baru berfungsi seperti yang diharapkan, tapi saya masih perlu memastikan bahwa peranti itu terhubung ke repositori dan memproses tindakan yang memang dimaksudkan.  Oleh karena itu, saya menulis tes tambahan untuk suite tes penyimpanan yang ada: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should reduce error'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Oooops!'</span></span>); store.dispatch({ type, error }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = store.getState(); expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(state.error)).toBeTruthy(); expect(state.error.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(state.error.includes(error)).toBeTruthy(); });</code> </pre> <br><p>  Saya menjalankan tes.  Segalanya diharapkan.  Tindakan dengan tipe <code>ERROR</code> tidak memproses penyimpanan yang ada.  Mengubah kode inisialisasi repositori yang ada: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createStore = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).createStore; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combineReducers = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).combineReducers; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./reducers/user'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./reducers/error'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducers = combineReducers({ error, user }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducers); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = store;</code> </pre> <br><p>  Untuk keseratus kalinya dia melempar jaring ... Bagus sekali!  Repositori sekarang mengakumulasi pesan kesalahan yang diterima di properti kontainer yang terpisah. </p><br><p>  Sekarang saya akan memperkenalkan beberapa konstruksi kondisional ke dalam implementasi <code>TableMock</code> ada, mengajarkannya untuk memulai beberapa pertanyaan dengan cara ini, mengembalikan kesalahan.  Kode yang diperbarui terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TableMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(array){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container = array; } where(query){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.query = query; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } fetch(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.query.Id === <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolve(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.query.Id === <span class="hljs-number"><span class="hljs-number">555</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Something goes wrong!'</span></span>)); }); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = TableMock;</code> </pre> <br><p>  Saya menjalankan tes dan mendapatkan pesan tentang penolakan <code>Promise</code> tidak tertangani dalam metode <code>execute</code> dari kelas <code>Request</code> .  Saya menambahkan kode yang hilang: </p><br><pre> <code class="javascript hljs">execute(callback){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> table = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.db.Model.extend({ <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.tableName }); table.where(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.query).fetch().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.success(item, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> callback === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) callback(); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.error(error, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> callback === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) callback(); }); }</code> </pre> <br><p>  Dan saya menjalankan tes lagi.  Dan ???  Sebenarnya tidak ada tes untuk metode <code>execute</code> dari kelas <code>Request</code> , yang ini: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should add item to store error state'</span></span>, () =&gt; { options.query = { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">555</span></span> }; options.error = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, store</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action = { type, error }; store.dispatch(action); }; request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = store.getState().error; expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(error)).toBeTruthy(); expect(error.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(error[<span class="hljs-number"><span class="hljs-number">0</span></span>].message).toEqual(<span class="hljs-string"><span class="hljs-string">'Something goes wrong!'</span></span>); }); });</code> </pre> <br><p>  Ia berhasil menyelesaikan.  Jadi fungsionalitas kueri dalam hal penanganan kesalahan dapat dipertimbangkan diimplementasikan.  Tes lain jatuh, yang memeriksa repositori untuk penanganan kesalahan.  Masalahnya adalah modul implementasi penyimpanan saya mengembalikan instance penyimpanan statis yang sama ke semua konsumen dalam semua pengujian.  Dalam hal ini, karena pengiriman kesalahan sudah terjadi dalam dua pengujian, salah satunya verifikasi jumlah kesalahan dalam wadah belum tentu lulus.  Karena pada saat tes dimulai, sudah ada satu kesalahan dalam wadah dan satu lagi ditambahkan di sana selama peluncuran uji.  Jadi di sini adalah kode ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = store.getState().error; expect(error.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Melempar pengecualian, melaporkan bahwa <code>error.length</code> ekspresi. <code>error.length</code> sebenarnya 2, bukan 1. Masalah ini sekarang saya akan pecahkan hanya dengan mentransfer kode inisialisasi penyimpanan langsung ke kode inisialisasi tes penyimpanan: </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'store'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createStore = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).createStore; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combineReducers = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).combineReducers; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../src/reducers/user'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../src/reducers/error'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducers = combineReducers({ error, user }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducers); it(<span class="hljs-string"><span class="hljs-string">'should reduce USER'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">Name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span> }; store.dispatch({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'USER'</span></span>, user }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = store.getState(); expect(state.user).toEqual(user); }); it(<span class="hljs-string"><span class="hljs-string">'should reduce error'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Oooops!'</span></span>); store.dispatch({ type, error }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = store.getState(); expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(state.error)).toBeTruthy(); expect(state.error.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(state.error.includes(error)).toBeTruthy(); }); });</code> </pre> <br><p>  Kode inisialisasi untuk tes sekarang terlihat sedikit bengkak, tetapi saya dapat kembali ke refactoring nanti. </p><br><p>  Saya menjalankan tes.  Voila!  Semua tes telah selesai dan Anda dapat beristirahat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436348/">https://habr.com/ru/post/id436348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436338/index.html">Bagaimana cara kerja bandara Vnukovo</a></li>
<li><a href="../id436340/index.html">Pisahkan level logging untuk setiap permintaan</a></li>
<li><a href="../id436342/index.html">Pengantar optimasi yang kuat [... dan daftar belanja kecil yang saya lupa ...]</a></li>
<li><a href="../id436344/index.html">Fibaro Home Center 2 dan termostat untuk pemanas di bawah lantai HeatIt. Cara menaikkan suhu</a></li>
<li><a href="../id436346/index.html">Apakah Anda selalu membutuhkan Docker, layanan mikro, dan pemrograman reaktif?</a></li>
<li><a href="../id436350/index.html">Pelajari Taktik Adversarial, Teknik & Pengetahuan Umum (ATT @ CK). Taktik Perusahaan. Bagian 7</a></li>
<li><a href="../id436352/index.html">Intisari berita PostgreSQL. Edisi No14</a></li>
<li><a href="../id436354/index.html">Militer AS mengabaikan masalah keamanan siber</a></li>
<li><a href="../id436356/index.html">[Menarik dari belakang bukit] Bagaimana kita menghentikan ketergantungan teknologi?</a></li>
<li><a href="../id436358/index.html">Mengapa pengembang senior mengajar siswa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>