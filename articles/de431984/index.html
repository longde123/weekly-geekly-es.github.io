<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç™ üëåüèø ‚è≠Ô∏è Golang Datenbankbasierte Client Generator-Schnittstelle üö£üèª üéà üôèüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Golang Datenbank Client Generator basierend auf Schnittstelle. 





 F√ºr die Arbeit mit Datenbanken bietet Golang das database/sql Paket an, eine Abs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang Datenbankbasierte Client Generator-Schnittstelle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431984/"><p>  Golang Datenbank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Client Generator</a> basierend auf Schnittstelle. </p><br><p><img src="https://habrastorage.org/webt/jn/y8/f1/jny8f1pghqry-6htgynybbcufbi.png"></p><br><p> F√ºr die Arbeit mit Datenbanken bietet Golang das <code>database/sql</code> Paket an, eine Abstraktion der relationalen Datenbankprogrammierschnittstelle.  Einerseits enth√§lt das Paket leistungsstarke Funktionen zum Verwalten des Verbindungspools, zum Arbeiten mit vorbereiteten Anweisungen, Transaktionen und zur Datenbankabfrageschnittstelle.  Andererseits m√ºssen Sie f√ºr die Interaktion mit einer Datenbank eine betr√§chtliche Menge des gleichen Codetyps in eine Webanwendung schreiben.  Die go-gad / sal-Bibliothek bietet eine L√∂sung in Form der Generierung des gleichen Codetyps basierend auf der beschriebenen Schnittstelle. </p><a name="habracut"></a><br><h2 id="motivation">  Motivation </h2><br><p>  Heutzutage gibt es eine ausreichende Anzahl von Bibliotheken, die L√∂sungen in Form von ORMs anbieten, Helfer zum Erstellen von Abfragen und Generieren von Helfern basierend auf einem Datenbankschema. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/jmoiron/sqlx</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/go-reform/reform</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/jinzhu/gorm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/Masterminds/squirrel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/volatiletech/sqlboiler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/drone/sqlgen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/gocraft/dbr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/go-gorp/gorp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/doug-martin/goqu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/src-d/go-kallax</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/go-pg/pg</a> </li></ul><br><p>  Als ich vor einigen Jahren zur Sprache Golang wechselte, hatte ich bereits Erfahrung mit Datenbanken in verschiedenen Sprachen.  Verwenden von ORM wie ActiveRecord und ohne.  Nachdem ich von der Liebe zum Hass √ºbergegangen war und keine Probleme hatte, ein paar zus√§tzliche Codezeilen zu schreiben, kam die Interaktion mit der Datenbank in Golang zu einem Repository-Muster.  Wir beschreiben die Schnittstelle f√ºr die Arbeit mit der Datenbank und implementieren sie mit dem Standard db.Query, row.Scan.  Zus√§tzliche Wrapper zu verwenden war einfach nicht sinnvoll, es war undurchsichtig, es w√ºrde zwingen, auf der Hut zu sein. </p><br><p>  Die SQL-Sprache selbst ist bereits eine Abstraktion zwischen Ihrem Programm und den Daten im Repository.  Es erschien mir immer unlogisch, zu versuchen, ein Datenschema zu beschreiben und dann komplexe Abfragen zu erstellen.  Die Antwortstruktur unterscheidet sich in diesem Fall vom Datenschema.  Es stellt sich heraus, dass der Vertrag nicht auf der Ebene des Datenschemas, sondern auf der Ebene der Anforderung und Antwort beschrieben werden muss.  Wir verwenden diesen Ansatz in der Webentwicklung, wenn wir die Datenstrukturen von API-Anforderungen und -Antworten beschreiben.  Beim Zugriff auf den Service mit RESTful JSON oder gRPC deklarieren wir den Vertrag auf Anforderungs- und Antwortebene mit JSON-Schema oder Protobuf und nicht mit dem Datenschema von Entit√§ten innerhalb der Services. </p><br><p>  Das hei√üt, die Interaktion mit der Datenbank ergab eine √§hnliche Methode: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { FindUser(id <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>) (*User, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Postgres <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pg *Postgres)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resp User err := pg.DB.QueryRow(<span class="hljs-string"><span class="hljs-string">"SELECT id, name FROM users WHERE id=$1"</span></span>, id).Scan(&amp;resp.ID, &amp;resp.Name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;resp, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HanlderFindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s Store, id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// logic of service object user, err := s.FindUser(id) //... }</span></span></code> </pre> <br><p>  Auf diese Weise wird Ihr Programm vorhersehbar.  Aber um ehrlich zu sein, ist dies kein Traum eines Dichters.  Wir m√∂chten die Menge an Boilerplate-Code reduzieren, um eine Abfrage zu erstellen, Datenstrukturen zu f√ºllen, Variablenbindungen zu verwenden und so weiter.  Ich habe versucht, eine Liste von Anforderungen zu formulieren, die die gew√ºnschten Dienstprogramme erf√ºllen sollten. </p><br><h2 id="requirements">  Anforderungen </h2><br><ul><li>  Beschreibung der Interaktion in Form einer Schnittstelle. </li><li>  Die Schnittstelle wird durch Methoden und Nachrichten von Anforderungen und Antworten beschrieben. </li><li>  Unterst√ºtzung f√ºr Bindungsvariablen und vorbereitete Anweisungen. </li><li>  Unterst√ºtzung f√ºr benannte Argumente. </li><li>  Verkn√ºpfen der Datenbankantwort mit den Feldern der Nachrichtendatenstruktur. </li><li>  Unterst√ºtzung f√ºr atypische Datenstrukturen (Array, JSON). </li><li>  Transparente Arbeit mit Transaktionen. </li><li>  Native Unterst√ºtzung f√ºr Middleware. </li></ul><br><p>  Wir wollen die Implementierung der Interaktion mit der Datenbank √ºber die Schnittstelle abstrahieren.  Auf diese Weise k√∂nnen wir etwas implementieren, das einem Entwurfsmuster wie einem Repository √§hnelt.  Im obigen Beispiel haben wir die Store-Oberfl√§che beschrieben.  Jetzt k√∂nnen wir es als Abh√§ngigkeit verwenden.  In der Testphase k√∂nnen wir einen auf der Grundlage dieser Schnittstelle generierten Stub √ºbergeben, und im Produkt werden wir unsere Implementierung basierend auf der Postgres-Struktur verwenden. </p><br><p>  Jede Schnittstellenmethode beschreibt eine Datenbankabfrage.  Die Eingabe- und Ausgabeparameter der Methode m√ºssen Bestandteil des Vertrags f√ºr die Anforderung sein.  Die Abfragezeichenfolge muss in Abh√§ngigkeit von den Eingabeparametern formatiert werden k√∂nnen.  Dies gilt insbesondere beim Kompilieren von Abfragen mit einer komplexen Stichprobenbedingung. </p><br><p>  Beim Kompilieren einer Abfrage m√∂chten wir Substitution und Variablenbindung verwenden.  In PostgreSQL schreiben Sie beispielsweise <code>$1</code> anstelle eines Werts und √ºbergeben zusammen mit der Abfrage ein Array von Argumenten.  Das erste Argument wird als Wert in der konvertierten Abfrage verwendet.  Durch die Unterst√ºtzung vorbereiteter Ausdr√ºcke m√ºssen Sie sich keine Gedanken √ºber die Organisation der Speicherung derselben Ausdr√ºcke machen.  Die Datenbank- / SQL-Bibliothek bietet ein leistungsstarkes Tool zur Unterst√ºtzung vorbereiteter Ausdr√ºcke. Sie selbst k√ºmmert sich um den Verbindungspool und geschlossene Verbindungen.  Seitens des Benutzers ist jedoch eine zus√§tzliche Aktion erforderlich, um den vorbereiteten Ausdruck in der Transaktion wiederzuverwenden. </p><br><p>  Datenbanken wie PostgreSQL und MySQL verwenden unterschiedliche Syntax f√ºr die Verwendung von Substitutionen und Variablenbindungen.  PostgreSQL verwendet das Format <code>$1</code> , <code>$2</code> , ... MySQL verwendet <code>?</code>  unabh√§ngig vom Ort des Wertes.  Die Datenbank- / SQL-Bibliothek schlug ein universelles Format f√ºr benannte Argumente vor: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://golang.org/pkg/database/sql/#NamedArg</a> .  Anwendungsbeispiel: </p><br><pre> <code class="go hljs">db.ExecContext(ctx, <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE created_at &lt; @end`</span></span>, sql.Named(<span class="hljs-string"><span class="hljs-string">"end"</span></span>, endTime))</code> </pre> <br><p>  Die Unterst√ºtzung dieses Formats ist im Vergleich zu PostgreSQL- oder MySQL-L√∂sungen vorzuziehen. </p><br><p>  Die Antwort aus der Datenbank, die den Softwaretreiber verarbeitet, kann bedingt wie folgt dargestellt werden: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title | url <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+-------+------------ 1 | 2012-03-13 11:17:23.609 | Tech | technology 2 | 2015-07-21 18:05:43.412 | Style | fashion (2 rows)</span></span></code> </pre> <br><p>  Aus Sicht des Benutzers auf Schnittstellenebene ist es zweckm√§√üig, den Ausgabeparameter als Array von Strukturen des Formulars zu beschreiben: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreatedAt time.Time Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> URL <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  <code>resp.ID</code> als N√§chstes den <code>id</code> Wert auf <code>resp.ID</code> und so weiter.  Im Allgemeinen deckt diese Funktionalit√§t die meisten Anforderungen ab. </p><br><p>  Bei der Deklaration von Nachrichten √ºber interne Datenstrukturen stellt sich die Frage, wie nicht standardm√§√üige Datentypen unterst√ºtzt werden k√∂nnen.  Zum Beispiel ein Array.  Wenn Sie bei der Arbeit mit PostgreSQL den Treiber github.com/lib/pq verwenden, k√∂nnen Sie beim √úbergeben von Abfrageargumenten oder beim Scannen einer Antwort Zusatzfunktionen wie <code>pq.Array(&amp;x)</code> .  Beispiel aus der Dokumentation: </p><br><pre> <code class="go hljs">db.Query(<span class="hljs-string"><span class="hljs-string">`SELECT * FROM t WHERE id = ANY($1)`</span></span>, pq.Array([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">235</span></span>, <span class="hljs-number"><span class="hljs-number">401</span></span>})) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x []sql.NullInt64 db.QueryRow(<span class="hljs-string"><span class="hljs-string">'SELECT ARRAY[235, 401]'</span></span>).Scan(pq.Array(&amp;x))</code> </pre> <br><p>  Dementsprechend muss es M√∂glichkeiten geben, Datenstrukturen vorzubereiten. </p><br><p>  Bei der Ausf√ºhrung einer der Schnittstellenmethoden kann eine Datenbankverbindung in Form eines <code>*sql.DB</code> .  Wenn Sie mehrere Methoden innerhalb einer einzelnen Transaktion ausf√ºhren m√ºssen, m√∂chte ich transparente Funktionen mit einem √§hnlichen Ansatz wie das Arbeiten au√üerhalb einer Transaktion verwenden und keine zus√§tzlichen Argumente √ºbergeben. </p><br><p>  Bei der Arbeit mit Schnittstellenimplementierungen ist es wichtig, dass wir das Toolkit einbetten k√∂nnen.  Beispiel: Protokollieren aller Anforderungen.  Das Toolkit muss Zugriff auf die Anforderungsvariablen, den Antwortfehler, die Laufzeit und den Namen der Schnittstellenmethode erhalten. </p><br><p>  Die Anforderungen wurden gr√∂√ütenteils als Systematisierung von Datenbankszenarien formuliert. </p><br><h2 id="solution-go-gadsal">  L√∂sung: go-gad / sal </h2><br><p>  Eine M√∂glichkeit, mit Boilerplate-Code umzugehen, besteht darin, ihn zu generieren.  Gl√ºcklicherweise hat Golang Tools und Beispiele f√ºr dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://blog.golang.org/generate</a> .  GoMock <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/golang/mock</a> , bei dem die Analyse der Schnittstelle mithilfe von Reflexion durchgef√ºhrt wird, wurde als Architekturl√∂sung f√ºr die Generation ausgeliehen.  Basierend auf diesem Ansatz wurden gem√§√ü den Anforderungen das Dienstprogramm salgen und die Bibliothek sal geschrieben, die Schnittstellenimplementierungscode generieren und eine Reihe von Hilfsfunktionen bereitstellen. </p><br><p>  Um diese L√∂sung verwenden zu k√∂nnen, muss eine Schnittstelle beschrieben werden, die das Verhalten der Interaktionsschicht mit der Datenbank beschreibt.  Geben <code>go:generate</code> Anweisung <code>go:generate</code> mit einer Reihe von Argumenten an und starten Sie die Generierung.  Sie erhalten einen Konstruktor und eine Reihe von Boilerplate-Code, die sofort einsatzbereit sind. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> repo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./postgres_client.go -package=dev/taxi/repo dev/taxi/repo Postgres type Postgres interface { CreateDriver(ctx context.Context, r *CreateDriverReq) error } type CreateDriverReq struct { taxi.Driver } func (r *CreateDriverReq) Query() string { return `INSERT INTO drivers(id, name) VALUES(@id, @name)` }</span></span></code> </pre> <br><h4 id="interface">  Schnittstelle </h4><br><p>  Alles beginnt mit der Deklaration der Schnittstelle und einem speziellen Befehl f√ºr das Dienstprogramm <code>go generate</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./client.go -package=github.com/go-gad/sal/examples/profile/storage github.com/go-gad/sal/examples/profile/storage Store type Store interface { ...</span></span></code> </pre> <br><p>  Hier wird beschrieben, dass f√ºr unsere <code>Store</code> Oberfl√§che das Konsolendienstprogramm <code>salgen</code> aus dem Paket mit zwei Optionen und zwei Argumenten <code>salgen</code> wird.  Die erste Option <code>-destination</code> bestimmt, in welche Datei der generierte Code geschrieben wird.  Das zweite Optionspaket definiert den vollst√§ndigen Pfad (Importpfad) der Bibliothek f√ºr die generierte Implementierung.  Das Folgende sind zwei Argumente.  Der erste beschreibt den vollst√§ndigen Paketpfad ( <code>github.com/go-gad/sal/examples/profile/storage</code> ), in dem sich die Schnittstelle befindet, der zweite gibt den Schnittstellennamen selbst an.  Beachten Sie, dass sich der Befehl f√ºr <code>go generate</code> beliebigen Stelle befinden kann, nicht unbedingt neben der Zielschnittstelle. </p><br><p>  Nach dem Ausf√ºhren des Befehls <code>go generate</code> wir einen Konstruktor, dessen Name durch Hinzuf√ºgen des Pr√§fixes <code>New</code> zum Schnittstellennamen erstellt wird.  Der Konstruktor verwendet einen erforderlichen Parameter, der der Schnittstelle <code>sal.QueryHandler</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryHandler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { QueryContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (*sql.Rows, error) ExecContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (sql.Result, error) PrepareContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (*sql.Stmt, error) }</code> </pre> <br><p>  Diese Schnittstelle entspricht dem Objekt <code>*sql.DB</code> </p><br><pre> <code class="go hljs">connStr := <span class="hljs-string"><span class="hljs-string">"user=pqgotest dbname=pqgotest sslmode=verify-full"</span></span> db, err := sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, connStr) client := storage.NewStore(db)</code> </pre> <br><h4 id="methods">  Methoden </h4><br><p>  Schnittstellenmethoden bestimmen den Satz verf√ºgbarer Datenbankabfragen. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CreateAuthor(ctx context.Context, req CreateAuthorReq) (CreateAuthorResp, error) GetAuthors(ctx context.Context, req GetAuthorsReq) ([]*GetAuthorsResp, error) UpdateAuthor(ctx context.Context, req *UpdateAuthorReq) error }</code> </pre> <br><ul><li>  Die Anzahl der Argumente betr√§gt immer streng zwei. </li><li>  Das erste Argument ist der Kontext. </li><li>  Das zweite Argument enth√§lt Daten zum Binden von Variablen und definiert die Abfragezeichenfolge. </li><li>  Der erste Ausgabeparameter kann ein Objekt, ein Array von Objekten oder nicht vorhanden sein. </li><li>  Der letzte Ausgabeparameter ist immer ein Fehler. </li></ul><br><p>  Das erste Argument ist immer das <code>context.Context</code> Objekt.  Dieser Kontext wird beim Aufrufen der Datenbank und des Toolkits weitergegeben.  Das zweite Argument erwartet einen Parameter mit dem Basistyp <code>struct</code> (oder einem Zeiger auf <code>struct</code> ).  Der Parameter muss die folgende Schnittstelle erf√ºllen: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Queryer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Query() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Die <code>Query()</code> -Methode wird aufgerufen, bevor eine Datenbankabfrage ausgef√ºhrt wird.  Die resultierende Zeichenfolge wird in ein datenbankspezifisches Format konvertiert.  Das hei√üt, f√ºr PostgreSQL wird <code>@end</code> durch <code>$1</code> und der Wert <code>&amp;req.End</code> wird an das Array von Argumenten √ºbergeben </p><br><p>  Abh√§ngig von den Ausgabeparametern wird festgelegt, welche der Methoden (Query / Exec) aufgerufen wird: </p><br><ul><li>  Wenn der erste Parameter vom Basistyp <code>struct</code> (oder ein Zeiger auf <code>struct</code> ) ist, wird die <code>QueryContext</code> Methode aufgerufen.  Wenn die Antwort aus der Datenbank keine einzelne Zeile enth√§lt, wird der Fehler <code>sql.ErrNoRows</code> .  Das hei√üt, das Verhalten ist √§hnlich wie bei <code>db.QueryRow</code> . </li><li>  Wenn sich der erste Parameter mit dem <code>slice</code> vom <code>QueryContext</code> , wird die <code>QueryContext</code> Methode aufgerufen.  Wenn die Antwort aus der Datenbank keine Zeilen enth√§lt, wird eine leere Liste zur√ºckgegeben.  Der Basistyp des Listenelements muss <code>stuct</code> (oder ein Zeiger auf eine <code>struct</code> ) sein. </li><li>  Wenn der Ausgabeparameter eins mit dem <code>error</code> , wird die <code>ExecContext</code> Methode aufgerufen. </li></ul><br><h4 id="prepared-statements">  Vorbereitete Aussagen </h4><br><p>  Der generierte Code unterst√ºtzt vorbereitete Ausdr√ºcke.  Vorbereitete Ausdr√ºcke werden zwischengespeichert.  Nach der ersten Vorbereitung des Ausdrucks wird er zwischengespeichert.  Die Datenbank- / SQL-Bibliothek selbst stellt sicher, dass vorbereitete Ausdr√ºcke transparent auf die gew√ºnschte Datenbankverbindung angewendet werden, einschlie√ülich der Verarbeitung geschlossener Verbindungen.  Die <code>go-gad/sal</code> Bibliothek sorgt wiederum daf√ºr, dass die vorbereitete Anweisung im Kontext der Transaktion wiederverwendet wird.  Wenn der vorbereitete Ausdruck ausgef√ºhrt wird, werden die Argumente mithilfe einer Variablenbindung √ºbergeben, die f√ºr den Entwickler transparent ist. </p><br><p>  Um benannte Argumente auf der Seite der <code>go-gad/sal</code> Bibliothek zu unterst√ºtzen, wird die Anforderung in eine f√ºr die Datenbank geeignete Ansicht konvertiert.  Es gibt jetzt Konvertierungsunterst√ºtzung f√ºr PostgreSQL.  Die Feldnamen des Abfrageobjekts werden verwendet, um benannte Argumente zu ersetzen.  Um einen anderen Namen anstelle des Objektfeldnamens anzugeben, m√ºssen Sie das <code>sql</code> Tag f√ºr Strukturfelder verwenden.  Betrachten Sie ein Beispiel: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteOrdersRequest <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { UserID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"user_id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r * DeleteOrdersRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE user_id=@user_id AND created_at&lt;@end`</span></span> }</code> </pre> <br><p>  Die Abfragezeichenfolge wird konvertiert und unter Verwendung der Korrespondenztabelle und der Variablenbindung wird eine Liste an die Ausf√ºhrungsargumente der Abfrage √ºbergeben: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// generated code: db.Query("DELETE FROM orders WHERE user_id=$1 AND created_at&lt;$2", &amp;req.UserID, &amp;req.CreatedAt)</span></span></code> </pre> <br><h4 id="map-structs-to-requests-arguments-and-response-messages">  Ordnen Sie Strukturen den Argumenten und Antwortnachrichten der Anforderung zu </h4><br><p>  Die <code>go-gad/sal</code> Bibliothek k√ºmmert sich um die Zuordnung von Datenbankantwortzeilen zu Antwortstrukturen, Tabellenspalten zu Strukturfeldern: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r GetRubricReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`SELECT * FROM rubrics`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp []*Rubric <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetRubrics(ctx context.Context, req GetRubricsReq) (GetRubricsResp, error) }</code> </pre> <br><p>  Und wenn die Datenbankantwort lautet: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+------- 1 | 2012-03-13 11:17:23.609 | Tech 2 | 2015-07-21 18:05:43.412 | Style (2 rows)</span></span></code> </pre> <br><p>  Dann kehrt die GetRubricsResp-Liste zu uns zur√ºck, deren Elemente Zeiger auf die Rubrik sind, in der die Felder mit Werten aus den Spalten gef√ºllt sind, die den Tag-Namen entsprechen. </p><br><p>  Wenn die Datenbankantwort Spalten mit demselben Namen enth√§lt, werden die entsprechenden Strukturfelder in der Deklarationsreihenfolge ausgew√§hlt. </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rubrics, subrubrics; id | title | id | title <span class="hljs-comment"><span class="hljs-comment">----+-------+----+---------- 1 | Tech | 3 | Politics</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Subrubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetCategoryResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Rubric Subrubric }</code> </pre> <br><h4 id="non-standard-data-types">  Nicht standardm√§√üige Datentypen </h4><br><p>  Das <code>database/sql</code> Paket bietet Unterst√ºtzung f√ºr grundlegende Datentypen (Zeichenfolgen, Zahlen).  Um Datentypen wie Array oder JSON in einer Anforderung oder Antwort verarbeiten zu k√∂nnen, <code>sql.Scanner</code> <code>driver.Valuer</code> und <code>sql.Scanner</code> .  Verschiedene Treiberimplementierungen haben spezielle Hilfsfunktionen.  Zum Beispiel <code>lib/pq.Array</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://godoc.org/github.com/lib/pq#Array</a> ): </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span> { driver.Valuer sql.Scanner }</code> </pre> <br><p>  Standardm√§√üig die <code>go-gad/sql</code> Bibliothek f√ºr Ansichtsstrukturfelder </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteAuthrosReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Tags []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"tags"`</span></span> }</code> </pre> <br><p>  verwendet den Wert <code>&amp;req.Tags</code> .  Wenn die Struktur die <code>sal.ProcessRower</code> Schnittstelle erf√ºllt, </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ProcessRower <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ProcessRow(rowMap RowMap) }</code> </pre> <br><p>  dann kann der verwendete Wert angepasst werden </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rowMap sal.RowMap)</span></span></span></span> { rowMap.Set(<span class="hljs-string"><span class="hljs-string">"tags"</span></span>, pq.Array(r.Tags)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM authors WHERE tags=ANY(@tags::UUID[])`</span></span> }</code> </pre> <br><p>  Dieser Handler kann f√ºr Anforderungs- und Antwortargumente verwendet werden.  Bei einer Liste in der Antwort muss die Methode zum Listenelement geh√∂ren. </p><br><h4 id="transactions">  Transaktionen </h4><br><p>  Zur Unterst√ºtzung von Transaktionen sollte die Schnittstelle (Store) mit den folgenden Methoden erweitert werden: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BeginTx(ctx context.Context, opts *sql.TxOptions) (Store, error) sal.Txer ...</code> </pre> <br><p>  Die Implementierung der Methoden wird generiert.  Die <code>BeginTx</code> Methode verwendet die Verbindung vom aktuellen <code>sal.QueryHandler</code> Objekt und √∂ffnet die Transaktion <code>db.BeginTx(...)</code> .  Gibt ein neues Implementierungsobjekt der <code>Store</code> Schnittstelle zur√ºck, verwendet jedoch das empfangene <code>*sql.Tx</code> Objekt als <code>*sql.Tx</code> </p><br><h4 id="middleware">  Middleware </h4><br><p>  Zum Einbetten von Werkzeugen sind Haken vorgesehen. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BeforeQueryFunc <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, FinalizerFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalizerFunc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span></code> </pre> <br><p>  Der <code>BeforeQueryFunc</code> Hook wird aufgerufen, bevor <code>db.PrepareContext</code> oder <code>db.Query</code> .  Das hei√üt, zu Beginn des Programms, wenn der Cache f√ºr vorbereitete Ausdr√ºcke leer ist und <code>store.GetAuthors</code> aufgerufen wird, wird der <code>BeforeQueryFunc</code> Hook zweimal aufgerufen.  Der <code>BeforeQueryFunc</code> Hook kann einen <code>FinalizerFunc</code> Hook zur√ºckgeben, der vor dem Beenden der Benutzermethode in unserem Fall <code>store.GetAuthors</code> mit <code>store.GetAuthors</code> wird. </p><br><p>  Zum Zeitpunkt der Ausf√ºhrung der Hooks wird der Kontext mit Dienstschl√ºsseln mit den folgenden Werten gef√ºllt: </p><br><ul><li>  <code>ctx.Value(sal.ContextKeyTxOpened)</code> boolescher Wert bestimmt, ob die Methode im Kontext der Transaktion aufgerufen wird oder nicht. </li><li>  <code>ctx.Value(sal.ContextKeyOperationType)</code> , Zeichenfolgenwert des Operationstyps, <code>"QueryRow"</code> , <code>"Query"</code> , <code>"Exec"</code> , <code>"Commit"</code> usw. </li><li>  <code>ctx.Value(sal.ContextKeyMethodName)</code> Zeichenfolgenwert der Schnittstellenmethode, z. B. <code>"GetAuthors"</code> . </li></ul><br><p>  Als Argumente akzeptiert der <code>BeforeQueryFunc</code> Hook die SQL-Zeichenfolge der Abfrage und das <code>req</code> Argument der Benutzerabfragemethode.  Der <code>FinalizerFunc</code> Hook verwendet eine <code>err</code> Variable als Argument. </p><br><pre> <code class="go hljs">beforeHook := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, sal.FinalizerFunc)</span></span></span></span> { start := time.Now() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span> { log.Printf( <span class="hljs-string"><span class="hljs-string">"%q &gt; Opeartion %q: %q with req %#v took [%v] inTx[%v] Error: %+v"</span></span>, ctx.Value(sal.ContextKeyMethodName), ctx.Value(sal.ContextKeyOperationType), query, req, time.Since(start), ctx.Value(sal.ContextKeyTxOpened), err, ) } } client := NewStore(db, sal.BeforeQuery(beforeHook))</code> </pre> <br><p>  Ausgabebeispiele: </p><br><pre> <code class="plaintext hljs">"CreateAuthor" &gt; Opeartion "Prepare": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES($1, $2, now()) RETURNING ID, CreatedAt" with req &lt;nil&gt; took [50.819¬µs] inTx[false] Error: &lt;nil&gt; "CreateAuthor" &gt; Opeartion "QueryRow": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES(@Name, @Desc, now()) RETURNING ID, CreatedAt" with req bookstore.CreateAuthorReq{BaseAuthor:bookstore.BaseAuthor{Name:"foo", Desc:"Bar"}} took [150.994¬µs] inTx[false] Error: &lt;nil&gt;</code> </pre> <br><h3 id="whats-next">  Was kommt als n√§chstes? </h3><br><ul><li>  Unterst√ºtzung f√ºr Bindungsvariablen und vorbereitete Ausdr√ºcke f√ºr MySQL. </li><li>  RowAppender-Hook zum Anpassen der Antwort. </li><li>  Gibt den Wert von <code>Exec.Result</code> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431984/">https://habr.com/ru/post/de431984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431972/index.html">Quora-Benutzerdaten sind durchgesickert</a></li>
<li><a href="../de431974/index.html">Tumblr verzichtet vollst√§ndig auf den "Erdbeer" -Inhalt</a></li>
<li><a href="../de431976/index.html">Tag der Informatik in Russland: Die Geschichte des ersten Projekts eines automatischen Computers</a></li>
<li><a href="../de431978/index.html">Online-Shop-Promotion: Was muss behoben werden</a></li>
<li><a href="../de431982/index.html">Digerati, Hakerazzi und Cholesterin in den Daten: √úber IT-Slang</a></li>
<li><a href="../de431986/index.html">Fuck Up Story: Wie ich von digitalen Diensten f√ºr Unternehmen entt√§uscht war und mein eigenes Gesch√§ft hatte (na ja, fast)</a></li>
<li><a href="../de431988/index.html">Als der Satz zum Axiom wurde: ONYX BOOX Euclid review</a></li>
<li><a href="../de431990/index.html">L√ºcken gewonnen. √úbersetzen der Dokumentation zu Kotlin-Codierungskonventionen aus JetBrains</a></li>
<li><a href="../de431992/index.html">Biometrie: Wie geht es uns und ihnen?</a></li>
<li><a href="../de431994/index.html">Diskussion der kostenlosen PVS-Studio-Lizenz f√ºr auf GitHub gehostete Projekte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>