<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍪 👌🏿 ⏭️ Golang Datenbankbasierte Client Generator-Schnittstelle 🚣🏻 🎈 🙏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Golang Datenbank Client Generator basierend auf Schnittstelle. 





 Für die Arbeit mit Datenbanken bietet Golang das database/sql Paket an, eine Abs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang Datenbankbasierte Client Generator-Schnittstelle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431984/"><p>  Golang Datenbank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Client Generator</a> basierend auf Schnittstelle. </p><br><p><img src="https://habrastorage.org/webt/jn/y8/f1/jny8f1pghqry-6htgynybbcufbi.png"></p><br><p> Für die Arbeit mit Datenbanken bietet Golang das <code>database/sql</code> Paket an, eine Abstraktion der relationalen Datenbankprogrammierschnittstelle.  Einerseits enthält das Paket leistungsstarke Funktionen zum Verwalten des Verbindungspools, zum Arbeiten mit vorbereiteten Anweisungen, Transaktionen und zur Datenbankabfrageschnittstelle.  Andererseits müssen Sie für die Interaktion mit einer Datenbank eine beträchtliche Menge des gleichen Codetyps in eine Webanwendung schreiben.  Die go-gad / sal-Bibliothek bietet eine Lösung in Form der Generierung des gleichen Codetyps basierend auf der beschriebenen Schnittstelle. </p><a name="habracut"></a><br><h2 id="motivation">  Motivation </h2><br><p>  Heutzutage gibt es eine ausreichende Anzahl von Bibliotheken, die Lösungen in Form von ORMs anbieten, Helfer zum Erstellen von Abfragen und Generieren von Helfern basierend auf einem Datenbankschema. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/jmoiron/sqlx</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/go-reform/reform</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/jinzhu/gorm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/Masterminds/squirrel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/volatiletech/sqlboiler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/drone/sqlgen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/gocraft/dbr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/go-gorp/gorp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/doug-martin/goqu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/src-d/go-kallax</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/go-pg/pg</a> </li></ul><br><p>  Als ich vor einigen Jahren zur Sprache Golang wechselte, hatte ich bereits Erfahrung mit Datenbanken in verschiedenen Sprachen.  Verwenden von ORM wie ActiveRecord und ohne.  Nachdem ich von der Liebe zum Hass übergegangen war und keine Probleme hatte, ein paar zusätzliche Codezeilen zu schreiben, kam die Interaktion mit der Datenbank in Golang zu einem Repository-Muster.  Wir beschreiben die Schnittstelle für die Arbeit mit der Datenbank und implementieren sie mit dem Standard db.Query, row.Scan.  Zusätzliche Wrapper zu verwenden war einfach nicht sinnvoll, es war undurchsichtig, es würde zwingen, auf der Hut zu sein. </p><br><p>  Die SQL-Sprache selbst ist bereits eine Abstraktion zwischen Ihrem Programm und den Daten im Repository.  Es erschien mir immer unlogisch, zu versuchen, ein Datenschema zu beschreiben und dann komplexe Abfragen zu erstellen.  Die Antwortstruktur unterscheidet sich in diesem Fall vom Datenschema.  Es stellt sich heraus, dass der Vertrag nicht auf der Ebene des Datenschemas, sondern auf der Ebene der Anforderung und Antwort beschrieben werden muss.  Wir verwenden diesen Ansatz in der Webentwicklung, wenn wir die Datenstrukturen von API-Anforderungen und -Antworten beschreiben.  Beim Zugriff auf den Service mit RESTful JSON oder gRPC deklarieren wir den Vertrag auf Anforderungs- und Antwortebene mit JSON-Schema oder Protobuf und nicht mit dem Datenschema von Entitäten innerhalb der Services. </p><br><p>  Das heißt, die Interaktion mit der Datenbank ergab eine ähnliche Methode: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { FindUser(id <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>) (*User, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Postgres <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pg *Postgres)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resp User err := pg.DB.QueryRow(<span class="hljs-string"><span class="hljs-string">"SELECT id, name FROM users WHERE id=$1"</span></span>, id).Scan(&amp;resp.ID, &amp;resp.Name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;resp, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HanlderFindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s Store, id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// logic of service object user, err := s.FindUser(id) //... }</span></span></code> </pre> <br><p>  Auf diese Weise wird Ihr Programm vorhersehbar.  Aber um ehrlich zu sein, ist dies kein Traum eines Dichters.  Wir möchten die Menge an Boilerplate-Code reduzieren, um eine Abfrage zu erstellen, Datenstrukturen zu füllen, Variablenbindungen zu verwenden und so weiter.  Ich habe versucht, eine Liste von Anforderungen zu formulieren, die die gewünschten Dienstprogramme erfüllen sollten. </p><br><h2 id="requirements">  Anforderungen </h2><br><ul><li>  Beschreibung der Interaktion in Form einer Schnittstelle. </li><li>  Die Schnittstelle wird durch Methoden und Nachrichten von Anforderungen und Antworten beschrieben. </li><li>  Unterstützung für Bindungsvariablen und vorbereitete Anweisungen. </li><li>  Unterstützung für benannte Argumente. </li><li>  Verknüpfen der Datenbankantwort mit den Feldern der Nachrichtendatenstruktur. </li><li>  Unterstützung für atypische Datenstrukturen (Array, JSON). </li><li>  Transparente Arbeit mit Transaktionen. </li><li>  Native Unterstützung für Middleware. </li></ul><br><p>  Wir wollen die Implementierung der Interaktion mit der Datenbank über die Schnittstelle abstrahieren.  Auf diese Weise können wir etwas implementieren, das einem Entwurfsmuster wie einem Repository ähnelt.  Im obigen Beispiel haben wir die Store-Oberfläche beschrieben.  Jetzt können wir es als Abhängigkeit verwenden.  In der Testphase können wir einen auf der Grundlage dieser Schnittstelle generierten Stub übergeben, und im Produkt werden wir unsere Implementierung basierend auf der Postgres-Struktur verwenden. </p><br><p>  Jede Schnittstellenmethode beschreibt eine Datenbankabfrage.  Die Eingabe- und Ausgabeparameter der Methode müssen Bestandteil des Vertrags für die Anforderung sein.  Die Abfragezeichenfolge muss in Abhängigkeit von den Eingabeparametern formatiert werden können.  Dies gilt insbesondere beim Kompilieren von Abfragen mit einer komplexen Stichprobenbedingung. </p><br><p>  Beim Kompilieren einer Abfrage möchten wir Substitution und Variablenbindung verwenden.  In PostgreSQL schreiben Sie beispielsweise <code>$1</code> anstelle eines Werts und übergeben zusammen mit der Abfrage ein Array von Argumenten.  Das erste Argument wird als Wert in der konvertierten Abfrage verwendet.  Durch die Unterstützung vorbereiteter Ausdrücke müssen Sie sich keine Gedanken über die Organisation der Speicherung derselben Ausdrücke machen.  Die Datenbank- / SQL-Bibliothek bietet ein leistungsstarkes Tool zur Unterstützung vorbereiteter Ausdrücke. Sie selbst kümmert sich um den Verbindungspool und geschlossene Verbindungen.  Seitens des Benutzers ist jedoch eine zusätzliche Aktion erforderlich, um den vorbereiteten Ausdruck in der Transaktion wiederzuverwenden. </p><br><p>  Datenbanken wie PostgreSQL und MySQL verwenden unterschiedliche Syntax für die Verwendung von Substitutionen und Variablenbindungen.  PostgreSQL verwendet das Format <code>$1</code> , <code>$2</code> , ... MySQL verwendet <code>?</code>  unabhängig vom Ort des Wertes.  Die Datenbank- / SQL-Bibliothek schlug ein universelles Format für benannte Argumente vor: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://golang.org/pkg/database/sql/#NamedArg</a> .  Anwendungsbeispiel: </p><br><pre> <code class="go hljs">db.ExecContext(ctx, <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE created_at &lt; @end`</span></span>, sql.Named(<span class="hljs-string"><span class="hljs-string">"end"</span></span>, endTime))</code> </pre> <br><p>  Die Unterstützung dieses Formats ist im Vergleich zu PostgreSQL- oder MySQL-Lösungen vorzuziehen. </p><br><p>  Die Antwort aus der Datenbank, die den Softwaretreiber verarbeitet, kann bedingt wie folgt dargestellt werden: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title | url <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+-------+------------ 1 | 2012-03-13 11:17:23.609 | Tech | technology 2 | 2015-07-21 18:05:43.412 | Style | fashion (2 rows)</span></span></code> </pre> <br><p>  Aus Sicht des Benutzers auf Schnittstellenebene ist es zweckmäßig, den Ausgabeparameter als Array von Strukturen des Formulars zu beschreiben: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreatedAt time.Time Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> URL <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  <code>resp.ID</code> als Nächstes den <code>id</code> Wert auf <code>resp.ID</code> und so weiter.  Im Allgemeinen deckt diese Funktionalität die meisten Anforderungen ab. </p><br><p>  Bei der Deklaration von Nachrichten über interne Datenstrukturen stellt sich die Frage, wie nicht standardmäßige Datentypen unterstützt werden können.  Zum Beispiel ein Array.  Wenn Sie bei der Arbeit mit PostgreSQL den Treiber github.com/lib/pq verwenden, können Sie beim Übergeben von Abfrageargumenten oder beim Scannen einer Antwort Zusatzfunktionen wie <code>pq.Array(&amp;x)</code> .  Beispiel aus der Dokumentation: </p><br><pre> <code class="go hljs">db.Query(<span class="hljs-string"><span class="hljs-string">`SELECT * FROM t WHERE id = ANY($1)`</span></span>, pq.Array([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">235</span></span>, <span class="hljs-number"><span class="hljs-number">401</span></span>})) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x []sql.NullInt64 db.QueryRow(<span class="hljs-string"><span class="hljs-string">'SELECT ARRAY[235, 401]'</span></span>).Scan(pq.Array(&amp;x))</code> </pre> <br><p>  Dementsprechend muss es Möglichkeiten geben, Datenstrukturen vorzubereiten. </p><br><p>  Bei der Ausführung einer der Schnittstellenmethoden kann eine Datenbankverbindung in Form eines <code>*sql.DB</code> .  Wenn Sie mehrere Methoden innerhalb einer einzelnen Transaktion ausführen müssen, möchte ich transparente Funktionen mit einem ähnlichen Ansatz wie das Arbeiten außerhalb einer Transaktion verwenden und keine zusätzlichen Argumente übergeben. </p><br><p>  Bei der Arbeit mit Schnittstellenimplementierungen ist es wichtig, dass wir das Toolkit einbetten können.  Beispiel: Protokollieren aller Anforderungen.  Das Toolkit muss Zugriff auf die Anforderungsvariablen, den Antwortfehler, die Laufzeit und den Namen der Schnittstellenmethode erhalten. </p><br><p>  Die Anforderungen wurden größtenteils als Systematisierung von Datenbankszenarien formuliert. </p><br><h2 id="solution-go-gadsal">  Lösung: go-gad / sal </h2><br><p>  Eine Möglichkeit, mit Boilerplate-Code umzugehen, besteht darin, ihn zu generieren.  Glücklicherweise hat Golang Tools und Beispiele für dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://blog.golang.org/generate</a> .  GoMock <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/golang/mock</a> , bei dem die Analyse der Schnittstelle mithilfe von Reflexion durchgeführt wird, wurde als Architekturlösung für die Generation ausgeliehen.  Basierend auf diesem Ansatz wurden gemäß den Anforderungen das Dienstprogramm salgen und die Bibliothek sal geschrieben, die Schnittstellenimplementierungscode generieren und eine Reihe von Hilfsfunktionen bereitstellen. </p><br><p>  Um diese Lösung verwenden zu können, muss eine Schnittstelle beschrieben werden, die das Verhalten der Interaktionsschicht mit der Datenbank beschreibt.  Geben <code>go:generate</code> Anweisung <code>go:generate</code> mit einer Reihe von Argumenten an und starten Sie die Generierung.  Sie erhalten einen Konstruktor und eine Reihe von Boilerplate-Code, die sofort einsatzbereit sind. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> repo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./postgres_client.go -package=dev/taxi/repo dev/taxi/repo Postgres type Postgres interface { CreateDriver(ctx context.Context, r *CreateDriverReq) error } type CreateDriverReq struct { taxi.Driver } func (r *CreateDriverReq) Query() string { return `INSERT INTO drivers(id, name) VALUES(@id, @name)` }</span></span></code> </pre> <br><h4 id="interface">  Schnittstelle </h4><br><p>  Alles beginnt mit der Deklaration der Schnittstelle und einem speziellen Befehl für das Dienstprogramm <code>go generate</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./client.go -package=github.com/go-gad/sal/examples/profile/storage github.com/go-gad/sal/examples/profile/storage Store type Store interface { ...</span></span></code> </pre> <br><p>  Hier wird beschrieben, dass für unsere <code>Store</code> Oberfläche das Konsolendienstprogramm <code>salgen</code> aus dem Paket mit zwei Optionen und zwei Argumenten <code>salgen</code> wird.  Die erste Option <code>-destination</code> bestimmt, in welche Datei der generierte Code geschrieben wird.  Das zweite Optionspaket definiert den vollständigen Pfad (Importpfad) der Bibliothek für die generierte Implementierung.  Das Folgende sind zwei Argumente.  Der erste beschreibt den vollständigen Paketpfad ( <code>github.com/go-gad/sal/examples/profile/storage</code> ), in dem sich die Schnittstelle befindet, der zweite gibt den Schnittstellennamen selbst an.  Beachten Sie, dass sich der Befehl für <code>go generate</code> beliebigen Stelle befinden kann, nicht unbedingt neben der Zielschnittstelle. </p><br><p>  Nach dem Ausführen des Befehls <code>go generate</code> wir einen Konstruktor, dessen Name durch Hinzufügen des Präfixes <code>New</code> zum Schnittstellennamen erstellt wird.  Der Konstruktor verwendet einen erforderlichen Parameter, der der Schnittstelle <code>sal.QueryHandler</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryHandler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { QueryContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (*sql.Rows, error) ExecContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (sql.Result, error) PrepareContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (*sql.Stmt, error) }</code> </pre> <br><p>  Diese Schnittstelle entspricht dem Objekt <code>*sql.DB</code> </p><br><pre> <code class="go hljs">connStr := <span class="hljs-string"><span class="hljs-string">"user=pqgotest dbname=pqgotest sslmode=verify-full"</span></span> db, err := sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, connStr) client := storage.NewStore(db)</code> </pre> <br><h4 id="methods">  Methoden </h4><br><p>  Schnittstellenmethoden bestimmen den Satz verfügbarer Datenbankabfragen. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CreateAuthor(ctx context.Context, req CreateAuthorReq) (CreateAuthorResp, error) GetAuthors(ctx context.Context, req GetAuthorsReq) ([]*GetAuthorsResp, error) UpdateAuthor(ctx context.Context, req *UpdateAuthorReq) error }</code> </pre> <br><ul><li>  Die Anzahl der Argumente beträgt immer streng zwei. </li><li>  Das erste Argument ist der Kontext. </li><li>  Das zweite Argument enthält Daten zum Binden von Variablen und definiert die Abfragezeichenfolge. </li><li>  Der erste Ausgabeparameter kann ein Objekt, ein Array von Objekten oder nicht vorhanden sein. </li><li>  Der letzte Ausgabeparameter ist immer ein Fehler. </li></ul><br><p>  Das erste Argument ist immer das <code>context.Context</code> Objekt.  Dieser Kontext wird beim Aufrufen der Datenbank und des Toolkits weitergegeben.  Das zweite Argument erwartet einen Parameter mit dem Basistyp <code>struct</code> (oder einem Zeiger auf <code>struct</code> ).  Der Parameter muss die folgende Schnittstelle erfüllen: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Queryer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Query() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Die <code>Query()</code> -Methode wird aufgerufen, bevor eine Datenbankabfrage ausgeführt wird.  Die resultierende Zeichenfolge wird in ein datenbankspezifisches Format konvertiert.  Das heißt, für PostgreSQL wird <code>@end</code> durch <code>$1</code> und der Wert <code>&amp;req.End</code> wird an das Array von Argumenten übergeben </p><br><p>  Abhängig von den Ausgabeparametern wird festgelegt, welche der Methoden (Query / Exec) aufgerufen wird: </p><br><ul><li>  Wenn der erste Parameter vom Basistyp <code>struct</code> (oder ein Zeiger auf <code>struct</code> ) ist, wird die <code>QueryContext</code> Methode aufgerufen.  Wenn die Antwort aus der Datenbank keine einzelne Zeile enthält, wird der Fehler <code>sql.ErrNoRows</code> .  Das heißt, das Verhalten ist ähnlich wie bei <code>db.QueryRow</code> . </li><li>  Wenn sich der erste Parameter mit dem <code>slice</code> vom <code>QueryContext</code> , wird die <code>QueryContext</code> Methode aufgerufen.  Wenn die Antwort aus der Datenbank keine Zeilen enthält, wird eine leere Liste zurückgegeben.  Der Basistyp des Listenelements muss <code>stuct</code> (oder ein Zeiger auf eine <code>struct</code> ) sein. </li><li>  Wenn der Ausgabeparameter eins mit dem <code>error</code> , wird die <code>ExecContext</code> Methode aufgerufen. </li></ul><br><h4 id="prepared-statements">  Vorbereitete Aussagen </h4><br><p>  Der generierte Code unterstützt vorbereitete Ausdrücke.  Vorbereitete Ausdrücke werden zwischengespeichert.  Nach der ersten Vorbereitung des Ausdrucks wird er zwischengespeichert.  Die Datenbank- / SQL-Bibliothek selbst stellt sicher, dass vorbereitete Ausdrücke transparent auf die gewünschte Datenbankverbindung angewendet werden, einschließlich der Verarbeitung geschlossener Verbindungen.  Die <code>go-gad/sal</code> Bibliothek sorgt wiederum dafür, dass die vorbereitete Anweisung im Kontext der Transaktion wiederverwendet wird.  Wenn der vorbereitete Ausdruck ausgeführt wird, werden die Argumente mithilfe einer Variablenbindung übergeben, die für den Entwickler transparent ist. </p><br><p>  Um benannte Argumente auf der Seite der <code>go-gad/sal</code> Bibliothek zu unterstützen, wird die Anforderung in eine für die Datenbank geeignete Ansicht konvertiert.  Es gibt jetzt Konvertierungsunterstützung für PostgreSQL.  Die Feldnamen des Abfrageobjekts werden verwendet, um benannte Argumente zu ersetzen.  Um einen anderen Namen anstelle des Objektfeldnamens anzugeben, müssen Sie das <code>sql</code> Tag für Strukturfelder verwenden.  Betrachten Sie ein Beispiel: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteOrdersRequest <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { UserID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"user_id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r * DeleteOrdersRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE user_id=@user_id AND created_at&lt;@end`</span></span> }</code> </pre> <br><p>  Die Abfragezeichenfolge wird konvertiert und unter Verwendung der Korrespondenztabelle und der Variablenbindung wird eine Liste an die Ausführungsargumente der Abfrage übergeben: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// generated code: db.Query("DELETE FROM orders WHERE user_id=$1 AND created_at&lt;$2", &amp;req.UserID, &amp;req.CreatedAt)</span></span></code> </pre> <br><h4 id="map-structs-to-requests-arguments-and-response-messages">  Ordnen Sie Strukturen den Argumenten und Antwortnachrichten der Anforderung zu </h4><br><p>  Die <code>go-gad/sal</code> Bibliothek kümmert sich um die Zuordnung von Datenbankantwortzeilen zu Antwortstrukturen, Tabellenspalten zu Strukturfeldern: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r GetRubricReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`SELECT * FROM rubrics`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp []*Rubric <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetRubrics(ctx context.Context, req GetRubricsReq) (GetRubricsResp, error) }</code> </pre> <br><p>  Und wenn die Datenbankantwort lautet: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+------- 1 | 2012-03-13 11:17:23.609 | Tech 2 | 2015-07-21 18:05:43.412 | Style (2 rows)</span></span></code> </pre> <br><p>  Dann kehrt die GetRubricsResp-Liste zu uns zurück, deren Elemente Zeiger auf die Rubrik sind, in der die Felder mit Werten aus den Spalten gefüllt sind, die den Tag-Namen entsprechen. </p><br><p>  Wenn die Datenbankantwort Spalten mit demselben Namen enthält, werden die entsprechenden Strukturfelder in der Deklarationsreihenfolge ausgewählt. </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rubrics, subrubrics; id | title | id | title <span class="hljs-comment"><span class="hljs-comment">----+-------+----+---------- 1 | Tech | 3 | Politics</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Subrubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetCategoryResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Rubric Subrubric }</code> </pre> <br><h4 id="non-standard-data-types">  Nicht standardmäßige Datentypen </h4><br><p>  Das <code>database/sql</code> Paket bietet Unterstützung für grundlegende Datentypen (Zeichenfolgen, Zahlen).  Um Datentypen wie Array oder JSON in einer Anforderung oder Antwort verarbeiten zu können, <code>sql.Scanner</code> <code>driver.Valuer</code> und <code>sql.Scanner</code> .  Verschiedene Treiberimplementierungen haben spezielle Hilfsfunktionen.  Zum Beispiel <code>lib/pq.Array</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://godoc.org/github.com/lib/pq#Array</a> ): </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span> { driver.Valuer sql.Scanner }</code> </pre> <br><p>  Standardmäßig die <code>go-gad/sql</code> Bibliothek für Ansichtsstrukturfelder </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteAuthrosReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Tags []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"tags"`</span></span> }</code> </pre> <br><p>  verwendet den Wert <code>&amp;req.Tags</code> .  Wenn die Struktur die <code>sal.ProcessRower</code> Schnittstelle erfüllt, </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ProcessRower <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ProcessRow(rowMap RowMap) }</code> </pre> <br><p>  dann kann der verwendete Wert angepasst werden </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rowMap sal.RowMap)</span></span></span></span> { rowMap.Set(<span class="hljs-string"><span class="hljs-string">"tags"</span></span>, pq.Array(r.Tags)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM authors WHERE tags=ANY(@tags::UUID[])`</span></span> }</code> </pre> <br><p>  Dieser Handler kann für Anforderungs- und Antwortargumente verwendet werden.  Bei einer Liste in der Antwort muss die Methode zum Listenelement gehören. </p><br><h4 id="transactions">  Transaktionen </h4><br><p>  Zur Unterstützung von Transaktionen sollte die Schnittstelle (Store) mit den folgenden Methoden erweitert werden: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BeginTx(ctx context.Context, opts *sql.TxOptions) (Store, error) sal.Txer ...</code> </pre> <br><p>  Die Implementierung der Methoden wird generiert.  Die <code>BeginTx</code> Methode verwendet die Verbindung vom aktuellen <code>sal.QueryHandler</code> Objekt und öffnet die Transaktion <code>db.BeginTx(...)</code> .  Gibt ein neues Implementierungsobjekt der <code>Store</code> Schnittstelle zurück, verwendet jedoch das empfangene <code>*sql.Tx</code> Objekt als <code>*sql.Tx</code> </p><br><h4 id="middleware">  Middleware </h4><br><p>  Zum Einbetten von Werkzeugen sind Haken vorgesehen. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BeforeQueryFunc <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, FinalizerFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalizerFunc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span></code> </pre> <br><p>  Der <code>BeforeQueryFunc</code> Hook wird aufgerufen, bevor <code>db.PrepareContext</code> oder <code>db.Query</code> .  Das heißt, zu Beginn des Programms, wenn der Cache für vorbereitete Ausdrücke leer ist und <code>store.GetAuthors</code> aufgerufen wird, wird der <code>BeforeQueryFunc</code> Hook zweimal aufgerufen.  Der <code>BeforeQueryFunc</code> Hook kann einen <code>FinalizerFunc</code> Hook zurückgeben, der vor dem Beenden der Benutzermethode in unserem Fall <code>store.GetAuthors</code> mit <code>store.GetAuthors</code> wird. </p><br><p>  Zum Zeitpunkt der Ausführung der Hooks wird der Kontext mit Dienstschlüsseln mit den folgenden Werten gefüllt: </p><br><ul><li>  <code>ctx.Value(sal.ContextKeyTxOpened)</code> boolescher Wert bestimmt, ob die Methode im Kontext der Transaktion aufgerufen wird oder nicht. </li><li>  <code>ctx.Value(sal.ContextKeyOperationType)</code> , Zeichenfolgenwert des Operationstyps, <code>"QueryRow"</code> , <code>"Query"</code> , <code>"Exec"</code> , <code>"Commit"</code> usw. </li><li>  <code>ctx.Value(sal.ContextKeyMethodName)</code> Zeichenfolgenwert der Schnittstellenmethode, z. B. <code>"GetAuthors"</code> . </li></ul><br><p>  Als Argumente akzeptiert der <code>BeforeQueryFunc</code> Hook die SQL-Zeichenfolge der Abfrage und das <code>req</code> Argument der Benutzerabfragemethode.  Der <code>FinalizerFunc</code> Hook verwendet eine <code>err</code> Variable als Argument. </p><br><pre> <code class="go hljs">beforeHook := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, sal.FinalizerFunc)</span></span></span></span> { start := time.Now() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span> { log.Printf( <span class="hljs-string"><span class="hljs-string">"%q &gt; Opeartion %q: %q with req %#v took [%v] inTx[%v] Error: %+v"</span></span>, ctx.Value(sal.ContextKeyMethodName), ctx.Value(sal.ContextKeyOperationType), query, req, time.Since(start), ctx.Value(sal.ContextKeyTxOpened), err, ) } } client := NewStore(db, sal.BeforeQuery(beforeHook))</code> </pre> <br><p>  Ausgabebeispiele: </p><br><pre> <code class="plaintext hljs">"CreateAuthor" &gt; Opeartion "Prepare": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES($1, $2, now()) RETURNING ID, CreatedAt" with req &lt;nil&gt; took [50.819µs] inTx[false] Error: &lt;nil&gt; "CreateAuthor" &gt; Opeartion "QueryRow": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES(@Name, @Desc, now()) RETURNING ID, CreatedAt" with req bookstore.CreateAuthorReq{BaseAuthor:bookstore.BaseAuthor{Name:"foo", Desc:"Bar"}} took [150.994µs] inTx[false] Error: &lt;nil&gt;</code> </pre> <br><h3 id="whats-next">  Was kommt als nächstes? </h3><br><ul><li>  Unterstützung für Bindungsvariablen und vorbereitete Ausdrücke für MySQL. </li><li>  RowAppender-Hook zum Anpassen der Antwort. </li><li>  Gibt den Wert von <code>Exec.Result</code> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431984/">https://habr.com/ru/post/de431984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431972/index.html">Quora-Benutzerdaten sind durchgesickert</a></li>
<li><a href="../de431974/index.html">Tumblr verzichtet vollständig auf den "Erdbeer" -Inhalt</a></li>
<li><a href="../de431976/index.html">Tag der Informatik in Russland: Die Geschichte des ersten Projekts eines automatischen Computers</a></li>
<li><a href="../de431978/index.html">Online-Shop-Promotion: Was muss behoben werden</a></li>
<li><a href="../de431982/index.html">Digerati, Hakerazzi und Cholesterin in den Daten: Über IT-Slang</a></li>
<li><a href="../de431986/index.html">Fuck Up Story: Wie ich von digitalen Diensten für Unternehmen enttäuscht war und mein eigenes Geschäft hatte (na ja, fast)</a></li>
<li><a href="../de431988/index.html">Als der Satz zum Axiom wurde: ONYX BOOX Euclid review</a></li>
<li><a href="../de431990/index.html">Lücken gewonnen. Übersetzen der Dokumentation zu Kotlin-Codierungskonventionen aus JetBrains</a></li>
<li><a href="../de431992/index.html">Biometrie: Wie geht es uns und ihnen?</a></li>
<li><a href="../de431994/index.html">Diskussion der kostenlosen PVS-Studio-Lizenz für auf GitHub gehostete Projekte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>