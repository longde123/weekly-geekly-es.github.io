<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò± üë®‚Äçüë©‚Äçüëß‚Äçüë¶ üë∞üèæ STM32F4 Debug Board im Raspberry Pi Formfaktor üõ≥Ô∏è üßïüèø üõï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, liebe Chabrowiten! Ich m√∂chte mein Projekt der √ñffentlichkeit vorstellen - ein kleines Debugboard, das auf STM32 basiert, aber im Raspberry...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>STM32F4 Debug Board im Raspberry Pi Formfaktor</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413101/"><p><img src="https://habrastorage.org/webt/m_/xs/9t/m_xs9tnnhio8gxliqrjhdj3zxxw.jpeg" alt="Bild" align="left">  Guten Tag, liebe Chabrowiten!  Ich m√∂chte mein Projekt der √ñffentlichkeit vorstellen - ein kleines Debugboard, das auf STM32 basiert, aber im Raspberry Pi-Formfaktor.  Es unterscheidet sich von anderen Debug-Boards dadurch, dass es eine mit Raspberry Pi-Geh√§usen kompatible Geometrie und ein ESP8266-Modul als drahtloses Modem aufweist.  Und auch sch√∂ne Erg√§nzungen in Form eines Anschlusses f√ºr eine Micro-SD-Karte und einen Stereoverst√§rker.  Um all diesen Reichtum zu nutzen, habe ich eine Bibliothek auf hoher Ebene und ein Demo-Programm (in C ++ 11) entwickelt.  In dem Artikel m√∂chte ich sowohl die Hardware- als auch die Softwareteile dieses Projekts detailliert beschreiben. </p><a name="habracut"></a><br><p>  Wer kann von diesem Projekt profitieren?  Wahrscheinlich nur f√ºr diejenigen, die diese Platine selbst l√∂ten m√∂chten, da ich selbst f√ºr die Produktion in kleinem Ma√üstab keine Optionen in Betracht ziehe.  Das ist ein reines Hobby.  Meiner Meinung nach deckt das Board ein ziemlich breites Spektrum von Aufgaben ab, die im Rahmen kleiner Heimwerkerarbeiten mit WLAN und Sound entstehen k√∂nnen. </p><br><p>  Zun√§chst werde ich versuchen, die Frage zu beantworten, warum dies alles ist.  Die Hauptmotivatoren dieses Projekts sind: </p><br><ul><li>  Die Wahl der STM32-Plattform beruht auf rein √§sthetischen √úberlegungen - ich mag das Preis-Leistungs-Verh√§ltnis sowie eine breite Palette an Peripherieger√§ten und ein gro√ües und praktisches Entwicklungs-√ñkosystem des Controller-Herstellers (sw4stm, cubeMX, HAL-Bibliothek). </li><li>  Nat√ºrlich gibt es viele Debug-Boards des Controller-Herstellers selbst (Discovery, Nucleo) sowie von Drittherstellern (z. B. Olimex).  Aber viele von ihnen zu Hause in ihrem Formfaktor zu wiederholen, ist zumindest f√ºr mich problematisch.  In meiner Version haben wir eine einfache zweischichtige Topologie und Komponenten, die zum manuellen L√∂ten geeignet sind. </li><li>  F√ºr ihre Ger√§te m√∂chte ich anst√§ndige Geh√§use haben, um die schlechte Qualit√§t der Elektronik im Inneren zu maskieren.  Es gibt mindestens zwei beliebte Plattformen, f√ºr die es eine Vielzahl unterschiedlichster F√§lle gibt: Arduino und Raspberry Pi.  Der zweite von ihnen schien mir in Bezug auf die Position der Ausschnitte f√ºr die Verbinder bequemer zu sein.  Deshalb habe ich mich als Spender f√ºr die Geometrie des Boards daf√ºr entschieden. </li><li>  Der an Bord ausgew√§hlte Controller verf√ºgt √ºber ein USB-, SDIO-, I2S- und Netzwerk.  Andererseits sind dieselben Schnittstellen auch f√ºr eine Heim-Hobby-Plattform n√ºtzlich.  Aus diesem Grund habe ich zus√§tzlich zum Controller mit einem Standardkabelbaum einen USB-Anschluss, eine SD-Karte, einen Audiopfad (Digital-Analog-Wandler und Verst√§rker) sowie ein auf dem ESP8266 basierendes Funkmodul hinzugef√ºgt. </li></ul><br><h2 id="shema-i-komponenty">  Schaltung und Komponenten </h2><br><p>  Es scheint mir, dass sich ein ziemlich sch√∂nes Board mit den folgenden Eigenschaften und Komponenten herausgestellt hat: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM32F405RG-</a> Controller: ARM 32-Bit-Cortex-M4 mit einem mathematischen Coprozessor, Frequenz bis 168 MHz, 1 MB Flash-Speicher, 196 KB RAM. <br><img src="https://habrastorage.org/webt/w1/je/fb/w1jefbi3tuwerk7nyio5awywiky.png" alt="Verwendete Controller-Pins"><br><img src="https://habrastorage.org/webt/-a/ta/sr/-atasrnz4pajsqagowftqvzok5q.png" alt="Controller-Bindung"></li><li>  SWD-Anschluss zur Programmierung der Steuerung (6 Pins). </li><li>  Reset-Taste zum Neustart. </li><li>  Dreifarbige LED.  Einerseits gehen drei Controller-Pins verloren.  Andererseits w√ºrden sie aufgrund der begrenzten Kontakte an den GPIO-Anschl√ºssen immer noch verloren gehen, und zum Debuggen einer solchen LED ist das Ding sehr n√ºtzlich. </li><li>  Hochfrequenz-HSE-Quarz (16 MHz f√ºr Kerntakt) und Niederfrequenz-LSE-Quarz (32,7680 kHz f√ºr Echtzeituhr). </li><li>  GPIO-Pins mit einem Abstand von 2,54 mm sind mit Prototyping-Boards kompatibel. </li><li>  Anstelle der 3,5-mm-Audiobuchse des Raspberry Pi habe ich den 5-Volt-Stromanschluss positioniert.  Die Entscheidung ist auf den ersten Blick umstritten.  Aber es gibt Profis.  Die Stromversorgung √ºber den USB-Anschluss ist optional vorhanden (Details siehe unten). F√ºr das Debuggen der Schaltung ist dies jedoch eine schlechte Option, da die Zeit vor dem Brennen des USB-Anschlusses des Computers in diesem Fall recht kurz sein kann. </li></ul><br><p><img src="https://habrastorage.org/webt/0s/qk/mk/0sqkmkrm5j1lt5bhkaiftrpz-y8.png" alt="Stromkreis"></p><br><ul><li>  Mini-USB-Anschluss  Zum einen wird es √ºber den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schutzchip STF203-22.TCT</a> an den USB-OTG-Port des Controllers angeschlossen.  Andererseits ist der VBUS-Stromanschluss mit dem GPIO-Anschluss verbunden.  Wenn Sie es an den + 5V-Pin anschlie√üen, wird die Karte √ºber den USB-Anschluss mit Strom versorgt. </li></ul><br><p><img src="https://habrastorage.org/webt/4q/te/om/4qteom17ikstddtnjafa78pqpme.png" alt="USB-Schaltung"></p><br><ul><li>  Anschluss f√ºr Micro-SD-Speicherkarte mit Kabelbaum: 47-kŒ©-Pull-up-Widerst√§nde, Power-Management-Transistor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P-Kanal-MOSFET BSH205</a> ) und eine kleine gr√ºne LED an der Stromleitung. </li></ul><br><p><img src="https://habrastorage.org/webt/qb/3x/el/qb3xelfstpguacjkqhnss45nlxk.png" alt="Umriss der Micro-SD-Karte"></p><br><p>  Das Transistor-Gate ist mit dem PA15-Pin der Steuerung verbunden.  Dies ist der Systemkontakt des JTDI-Controllers, was insofern interessant ist, als er in der Ausgangsposition als Ausgang mit einem hohen Spannungspegel (Pull-up) konfiguriert ist.  Da SWD anstelle von JTAG f√ºr die Programmierung verwendet wird, bleibt dieser Kontakt frei und kann f√ºr andere Zwecke verwendet werden, beispielsweise zum Steuern eines Transistors.  Dies ist praktisch: Wenn die Karte mit Strom versorgt wird, ist die Speicherkarte stromlos. Zum Einschalten m√ºssen Sie einen niedrigen Pegel an Pin PA15 anlegen. </p><br><ul><li>  Digital-Analog-Wandler basierend auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UDA1334</a> .  Dieser Chip ben√∂tigt kein externes Taktsignal, was seine Verwendung erleichtert.  Daten werden √ºber den I2S-Bus √ºbertragen.  Auf der anderen Seite empfiehlt Datasheet die Verwendung von bis zu 5 Polarkondensatoren bei 47 ŒºF.  Gr√∂√üe ist in diesem Fall wichtig.  Die kleinsten, die sich als gekauft herausstellten, sind Tantal mit einer Gr√∂√üe von 1411, die nicht einmal billig sind.  Ich werde jedoch weiter unten ausf√ºhrlicher √ºber den Preis schreiben.  F√ºr die analoge Leistung wird ein eigener linearer Stabilisator verwendet, die Leistung des digitalen Teils wird durch einen Doppeltransistor ein- und ausgeschaltet. </li></ul><br><p><img src="https://habrastorage.org/webt/4f/rh/ea/4frheacnbm39nin0t79ubdatfy8.png" alt="DAC-Schaltung"></p><br><ul><li>  Zweikanalverst√§rker basierend auf zwei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">31AP2005-</a> Chips.  Ihr Hauptvorteil ist eine geringe Anzahl von Umreifungskomponenten (nur Leistungsfilter und ein Eingangsfilter).  Audioausgang - 4 Plattformen mit einem Abstand von 2,54 mm.  F√ºr mich selbst habe ich noch nicht entschieden, was am besten ist - eine solche provisorische Option oder, wie bei einer Himbeere, einen 3,5-mm-Stecker.  In der Regel sind 3,5 mm mit Kopfh√∂rern verbunden. In unserem Fall handelt es sich um das Anschlie√üen von Lautsprechern. </li></ul><br><p><img src="https://habrastorage.org/webt/ke/ge/qa/kegeqak09asea0z1npbr7u9clyw.png" alt="Verst√§rkerschaltung"></p><br><ul><li>  Das letzte Modul ist ein ESP11-Schal mit einer Umreifung (Stromversorgung, Programmierbuchse) als WLAN-Modem.  Die Schlussfolgerungen der UART-Karte werden an die Steuerung angeschlossen und gleichzeitig an einen externen Anschluss ausgegeben (zum Arbeiten mit der Karte direkt vom Terminal und zur Programmierung).  Es gibt einen Netzschalter (permanent extern oder Steuerung √ºber einen Mikrocontroller).  Es gibt eine zus√§tzliche LED zur Anzeige der Stromversorgung und einen ‚ÄûFLASH‚Äú -Anschluss, um die Karte in den Programmiermodus zu versetzen. </li></ul><br><p><img src="https://habrastorage.org/webt/3d/cq/1d/3dcq1dpb4u-iog9jbnix9icc1ac.png" alt="ESP-Schaltung"></p><br><p>  Nat√ºrlich ist der ESP8266 selbst ein guter Controller, aber er ist dem STM32F4 in Leistung und Peripherie immer noch unterlegen.  Ja, und die Gr√∂√üe mit dem Preis dieses Moduls deutete darauf hin, dass es sich um eine versch√ºttete Modemeinheit f√ºr seinen √§lteren Bruder handelte.  Das Modul wird von USRT unter Verwendung eines Text- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AT-</a> Protokolls gesteuert. </p><br><p>  Ein paar Fotos: <br> <a href=""><img src="https://habrastorage.org/webt/if/zv/di/ifzvdi77bc5vhkauczq8kwfa6mg.jpeg"></a> <br> <a href=""><img src="https://habrastorage.org/webt/dg/go/lz/dggolzrzpwxghtqnwtdyf_plogo.jpeg"></a> </p><br><h2 id="podgotovka-modulya-esp11">  Vorbereiten des ESP11-Moduls </h2><br><p>  ESP8266 ist eine bekannte Sache.  Ich bin mir sicher, dass viele bereits damit vertraut sind, daher ist eine ausf√ºhrliche Anleitung hier √ºberfl√ºssig.  Aufgrund der schematischen Merkmale beim Anschlie√üen des ESP11-Moduls an die Karte werde ich nur eine kurze Anleitung f√ºr diejenigen geben, die die Firmware √§ndern m√∂chten: </p><br><ul><li>  Ich werde das Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">esptool verwenden</a> , um mit ESP zu arbeiten.  Im Gegensatz zum Standarddienstprogramm des Herstellers ist esptool plattformunabh√§ngig. </li><li>  Schalten Sie zun√§chst den externen Stromversorgungsmodus mit dem ESP-PWR-Jumper ein (wir schlie√üen die Kontakte 1 und 2) und verbinden Sie das Modul √ºber einen beliebigen USART-USB-Adapter mit dem Computer.  Der Adapter wird an die GRD / RX / TD-Pins angeschlossen.  Wir versorgen das Board mit Strom: <br> <a href=""><img src="https://habrastorage.org/webt/qk/sg/_u/qksg_updoacqtvh5a_bmczc_poe.jpeg"></a> </li><li>  Wir stellen sicher, dass der Adapter vom Betriebssystem erkannt wird.  In meinem Beispiel verwende ich einen Adapter, der auf FT232 basiert. In der Liste der Ger√§te sollte er daher als FT232 Serial (UART) IC angezeigt werden: <br><pre><code class="bash hljs">&gt; lsusb ... Bus 001 Device 010: ID 0483:3748 STMicroelectronics ST-LINK/V2 Bus 001 Device 009: ID 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC ...</code> </pre> </li><li>  ESP8266 selbst unterscheiden sich in der Gr√∂√üe des Flash-Speichers.  In der Praxis stie√ü ich im selben ESP11-Modul sowohl auf 512 KB (4 Mbit) als auch auf 1 MB (8 Mbit).  Als erstes muss √ºberpr√ºft werden, wie viel Speicher sich in der verwendeten Modulinstanz befindet.  Schalten Sie die Platine aus, versetzen Sie das Modul in den Programmiermodus und schlie√üen Sie den Jumper "FLASH": </li></ul><br><p> <a href=""><img src="https://habrastorage.org/webt/dr/i8/8p/dri88pfduzkumw9u2_euqtz2_va.jpeg"></a> </p><br><ul><li>  Schalten Sie das Ger√§t ein und f√ºhren Sie esptool mit den folgenden Parametern aus </li></ul><br><pre> <code class="bash hljs">&gt; esptool.py --port /dev/ttyUSB0 flash_id Connecting.... Detecting chip <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>... ESP8266 Chip is ESP8266EX Uploading stub... Running stub... Stub running... Manufacturer: e0 Device: 4014 Detected flash size: 1MB Hard resetting...</code> </pre> <br><ul><li>  esptool berichtet, dass es sich in diesem Fall um ein Modul mit 1 MB Speicher handelt. </li><li>  F√ºr die Version mit 1 MB k√∂nnen Sie die neueste Firmware verwenden, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ESP8266 AT Bin V1.6.1</a> .  Es ist jedoch nicht f√ºr die Version mit 4 Mbit geeignet, f√ºr die Sie etwas √Ñlteres verwenden m√ºssen, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> .  Die Firmware besteht aus mehreren Dateien. Die Startadressen jeder Datei sind im offiziellen Dokument <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ESP8266 AT Instruction Set angegeben</a> .  Diese Startadressen werden als Parameter des Dienstprogramms esptool verwendet.  Bei einem Modul mit 1 MB sehen die Parameter von esptool beispielsweise folgenderma√üen aus (alle erforderlichen Dateien m√ºssen zuerst aus dem Firmware-Archiv extrahiert und im Arbeitsverzeichnis gesammelt werden). <br><pre> <code class="bash hljs">&gt; esptool.py --port /dev/ttyUSB0 write_flash 0x00000 boot.bin 0x01000 user1.1024.new.2.bin 0x7E000 blank.bin 0xFB000 blank.bin 0xFC000 esp_init_data_default.bin 0xFE000 blank.bin</code> </pre> </li><li>  Wir versorgen die Platine mit Strom und f√ºhren esptool mit den angegebenen Parametern aus. </li><li>  Schalten Sie nach Abschluss des Skripts die Stromversorgung von der Karte aus, √∂ffnen Sie den "FLASH" -Jumper und schalten Sie die Stromversorgung √ºber den Mikrocontroller ein.  Das Modul ist betriebsbereit. </li></ul><br><h2 id="programmnoe-obespechenie">  Software </h2><br><p>  Es gibt ein Testprogramm auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> .  Sie macht folgendes: </p><br><ul><li>  zeigt den Controller mit der maximalen Frequenz (168 MHz) an </li><li>  Aktiviert die Echtzeituhr </li><li>  Aktiviert die SD-Karte und liest die Netzwerkkonfiguration daraus.  Die FatFS-Bibliothek wird verwendet, um mit dem Dateisystem zu arbeiten. </li><li>  stellt eine Verbindung zum angegebenen WLAN her </li><li>  stellt eine Verbindung zum angegebenen NTP-Server her und fordert die aktuelle Uhrzeit von diesem an.  F√ºhrt die Uhr. </li><li>  √ºberwacht den Status mehrerer angegebener Ports.  Wenn sich ihr Status ge√§ndert hat, wird eine Textnachricht an den angegebenen TCP-Server gesendet. </li><li>  Wenn Sie auf die externe Schaltfl√§che klicken, wird die angegebene * .wav-Datei von der SD-Karte gelesen und im asynchronen Modus (I2S mit dem DMA-Controller) abgespielt. </li><li>  Die Arbeit mit ESP11 wird auch im asynchronen Modus implementiert (bisher ohne DMA, nur bei Interrupts). </li><li>  meldet sich √ºber USART1 an (Pins PB6 / PB7) </li><li>  und nat√ºrlich blinkt die LED. </li></ul><br><p>  Auf Habr√© gab es viele Artikel, die sich mit der Programmierung von STM32 auf einer relativ niedrigen Ebene befassten (nur durch Registerverwaltung oder CMSIS).  Zum Beispiel vom relativ letzten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei</a> .  Die Artikel sind nat√ºrlich von sehr hoher Qualit√§t, aber meine subjektive Meinung ist, dass sich dieser Ansatz f√ºr die einmalige Entwicklung eines Produkts vielleicht rechtfertigt.  Aber f√ºr ein langfristiges Hobbyprojekt, bei dem alles sch√∂n und erweiterbar sein soll, ist dieser Ansatz zu niedrig.  Einer der Gr√ºnde f√ºr die Popularit√§t von Arduino als Softwareplattform ist meiner Meinung nach, dass die Autoren von Arduino ein so niedriges Niveau f√ºr objektorientierte Architektur hinterlassen haben.  Aus diesem Grund habe ich mich entschlossen, in die gleiche Richtung zu gehen und der HAL-Bibliothek eine objektorientierte Ebene auf ziemlich hoher Ebene hinzuzuf√ºgen. </p><br><p>  Somit werden drei Ebenen des Programms erhalten: </p><br><ul><li>  Herstellerbibliotheken (HAL, FatFS, zuk√ºnftig USB-OTG) bilden die Grundlage </li><li>  Meine StmPlusPlus-Bibliothek basiert auf dieser Grundlage.  Es enth√§lt eine Reihe von Basisklassen (wie System, IOPort, IOPin, Timer, RealTimeClock, Usart, Spi, I2S), eine Reihe von Treiberklassen f√ºr externe Ger√§te (wie SdCard, Esp11, DcfReceiver, Dac_MCP49x1, AudioDac_UDA1334 und dergleichen) Serviceklassen wie ein asynchroner WAV-Player. </li><li>  Basierend auf der StmPlusPlus-Bibliothek wird die Anwendung selbst erstellt. </li></ul><br><p>  Wie f√ºr den Dialekt der Sprache.  W√§hrend ich etwas altmodisch bin, bleibe ich in C ++ 11.  Dieser Standard verf√ºgt √ºber mehrere Funktionen, die besonders f√ºr die Entwicklung von Firmware n√ºtzlich sind: Enum-Klassen, Aufruf von Konstruktoren mit geschweiften Klammern zur Steuerung der √ºbergebenen Parametertypen und statische Container wie std :: array.  Auf Habr√© gibt es √ºbrigens einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wunderbaren Artikel</a> zu diesem Thema. </p><br><h3 id="biblioteka-stmplusplus">  StmPlusPlus-Bibliothek </h3><br><p>  Der vollst√§ndige Bibliothekscode kann auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> eingesehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Hier werde ich nur einige kleine Beispiele geben, um die Struktur, Idee und Probleme zu zeigen, die durch diese Idee erzeugt werden. </p><br><p>  <strong>Das erste Beispiel</strong> ist eine Klasse zum periodischen Abrufen eines Pin-Status (z. B. einer Schaltfl√§che) und zum Aufrufen eines Handlers, wenn sich dieser Status √§ndert: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> :</span></span> IOPin { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onButtonPressed</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Button *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numOccured)</span></span></span><span class="hljs-function"> </span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; }; Button (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; _rtc, duration_ms _pressDelay = <span class="hljs-number"><span class="hljs-number">50</span></span>, duration_ms _pressDuration = <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventHandler * _handler)</span></span></span><span class="hljs-function"> </span></span>{ handler = _handler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">periodic</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; rtc; duration_ms pressDelay, pressDuration; time_ms pressTime; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> currentState; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numOccured; EventHandler * handler; };</code> </pre> <br><p>  Der Konstruktor definiert alle Schaltfl√§chenparameter: </p><br><pre> <code class="cpp hljs">Button::Button (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; _rtc, duration_ms _pressDelay, duration_ms _pressDuration): IOPin{name, pin, GPIO_MODE_INPUT, pull, GPIO_SPEED_LOW}, rtc{_rtc}, pressDelay{_pressDelay}, pressDuration{_pressDuration}, pressTime{INFINITY_TIME}, currentState{<span class="hljs-literal"><span class="hljs-literal">false</span></span>}, numOccured{<span class="hljs-number"><span class="hljs-number">0</span></span>}, handler{<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>} { <span class="hljs-comment"><span class="hljs-comment">// empty }</span></span></code> </pre> <br><p>  Wenn die Behandlung solcher Ereignisse keine Priorit√§t hat, ist die Verwendung von Interrupts eindeutig √ºberfl√ºssig.  Daher werden in der periodischen Prozedur verschiedene Pressenszenarien (z. B. ein einzelnes Dr√ºcken oder Halten) implementiert, die regelm√§√üig aus dem Hauptprogrammcode aufgerufen werden sollten.  analysiert regelm√§√üig die Status√§nderung und ruft synchron den virtuellen Handler onButtonPressed auf, der im Hauptprogramm implementiert werden sollte: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Button::periodic () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> newState = (gpioParameters.Pull == GPIO_PULLUP)? !getBit() : getBit(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentState == newState) { <span class="hljs-comment"><span class="hljs-comment">// state is not changed: check for periodical press event if (currentState &amp;&amp; pressTime != INFINITY_TIME) { duration_ms d = rtc.getUpTimeMillisec() - pressTime; if (d &gt;= pressDuration) { handler-&gt;onButtonPressed(this, numOccured); pressTime = rtc.getUpTimeMillisec(); ++numOccured; } } } else if (!currentState &amp;&amp; newState) { pressTime = rtc.getUpTimeMillisec(); numOccured = 0; } else { duration_ms d = rtc.getUpTimeMillisec() - pressTime; if (d &lt; pressDelay) { // nothing to do } else if (numOccured == 0) { handler-&gt;onButtonPressed(this, numOccured); } pressTime = INFINITY_TIME; } currentState = newState; }</span></span></code> </pre> <br><p>  Der Hauptvorteil dieses Ansatzes ist die Vielfalt von Logik und Code zum Erkennen eines Ereignisses aus seiner Verarbeitung.  Es ist nicht HAL_GetTick, das zum Z√§hlen der Zeit verwendet wird, die aufgrund ihres Typs (uint32_t) alle 2 ^ 32 Millisekunden (alle 49 Tage) durch √úberlauf zur√ºckgesetzt wird.  Ich habe meine eigene Klasse RealTimeClock implementiert, die Millisekunden ab dem Start des Programms z√§hlt, oder den Controller wie uint64_t eingeschaltet, was ungef√§hr 5 ^ 8 Jahre ergibt. </p><br><p>  <strong>Das zweite Beispiel</strong> ist die Arbeit mit einer Hardwareschnittstelle, von der sich mehrere in der Steuerung befinden.  Zum Beispiel SPI.  Aus Sicht des Hauptprogramms ist es sehr praktisch, nur die gew√ºnschte Schnittstelle (SPI1 / SPI2 / SPI3) auszuw√§hlen, und alle anderen Parameter, die von dieser Schnittstelle abh√§ngen, werden vom Klassenkonstruktor konfiguriert. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Spi</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TIMEOUT = <span class="hljs-number"><span class="hljs-number">5000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceName</span></span></span><span class="hljs-class"> {</span></span> SPI_1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, SPI_2 = <span class="hljs-number"><span class="hljs-number">1</span></span>, SPI_3 = <span class="hljs-number"><span class="hljs-number">2</span></span>, }; Spi (DeviceName _device, IOPort::PortName sckPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sckPin, IOPort::PortName misoPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> misoPin, IOPort::PortName mosiPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mosiPin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull = GPIO_NOPULL); <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prescaler, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dataSize = SPI_DATASIZE_8BIT, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CLKPhase = SPI_PHASE_1EDGE)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeBuffer</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_SPI_Transmit(hspi, pData, pSize, TIMEOUT); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: DeviceName device; IOPin sck, miso, mosi; SPI_HandleTypeDef *hspi; SPI_HandleTypeDef spiParams; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enableClock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disableClock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br><p>  Pin-Parameter und Schnittstellenparameter werden lokal in der Klasse gespeichert.  Leider habe ich mich f√ºr eine nicht ganz erfolgreiche Implementierungsoption entschieden, wenn Parametereinstellungen abh√§ngig von einer bestimmten Schnittstelle direkt implementiert werden: </p><br><pre> <code class="cpp hljs">Spi::Spi (DeviceName _device, IOPort::PortName sckPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sckPin, IOPort::PortName misoPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> misoPin, IOPort::PortName mosiPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mosiPin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull): device(_device), sck(sckPort, sckPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), miso(misoPort, misoPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), mosi(mosiPort, mosiPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), hspi(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (device) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DeviceName::SPI_1: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SPI1 sck.setAlternate(GPIO_AF5_SPI1); miso.setAlternate(GPIO_AF5_SPI1); mosi.setAlternate(GPIO_AF5_SPI1); spiParams.Instance = SPI1; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> break; ... case DeviceName::SPI_3: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SPI3 sck.setAlternate(GPIO_AF6_SPI3); miso.setAlternate(GPIO_AF6_SPI3); mosi.setAlternate(GPIO_AF6_SPI3); spiParams.Instance = SPI3; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> break; } spiParams.Init.Mode = SPI_MODE_MASTER; spiParams.Init.DataSize = SPI_DATASIZE_8BIT; spiParams.Init.CLKPolarity = SPI_POLARITY_HIGH; spiParams.Init.CLKPhase = SPI_PHASE_1EDGE; spiParams.Init.FirstBit = SPI_FIRSTBIT_MSB; spiParams.Init.TIMode = SPI_TIMODE_DISABLE; spiParams.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; spiParams.Init.CRCPolynomial = 7; spiParams.Init.NSS = SPI_NSS_SOFT; }</span></span></code> </pre> <br><p>  Das gleiche Schema implementiert die Prozeduren enableClock und disableClock, die schlecht erweiterbar und f√ºr andere Controller schlecht portierbar sind.  In diesem Fall ist es besser, Vorlagen zu verwenden, bei denen der Vorlagenparameter der Name der HAL-Schnittstelle (SPI1, SPI2, SPI3), Pin-Parameter (GPIO_AF5_SPI1) und etwas ist, das die Uhr ein / aus steuert.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es</a> gibt einen interessanten Artikel zu diesem Thema, der sich jedoch mit AVR-Controllern befasst, der jedoch keinen grundlegenden Unterschied macht. </p><br><p>  Der Start und das Ende der √úbertragung werden durch zwei Start / Stopp-Methoden gesteuert: </p><br><pre> <code class="cpp hljs">HAL_StatusTypeDef Spi::start (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> direction, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> prescaler, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dataSize, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> CLKPhase) { hspi = &amp;spiParams; enableClock(); spiParams.Init.Direction = direction; spiParams.Init.BaudRatePrescaler = prescaler; spiParams.Init.DataSize = dataSize; spiParams.Init.CLKPhase = CLKPhase; HAL_StatusTypeDef status = HAL_SPI_Init(hspi); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not initialize SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; } <span class="hljs-comment"><span class="hljs-comment">/* Configure communication direction : 1Line */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spiParams.Init.Direction == SPI_DIRECTION_1LINE) { SPI_1LINE_TX(hspi); } <span class="hljs-comment"><span class="hljs-comment">/* Check if the SPI is already enabled */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((spiParams.Instance-&gt;CR1 &amp; SPI_CR1_SPE) != SPI_CR1_SPE) { <span class="hljs-comment"><span class="hljs-comment">/* Enable SPI peripheral */</span></span> __HAL_SPI_ENABLE(hspi); } USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Started SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device &lt;&lt; <span class="hljs-string"><span class="hljs-string">": BaudRatePrescaler = "</span></span> &lt;&lt; spiParams.Init.BaudRatePrescaler &lt;&lt; <span class="hljs-string"><span class="hljs-string">", DataSize = "</span></span> &lt;&lt; spiParams.Init.DataSize &lt;&lt; <span class="hljs-string"><span class="hljs-string">", CLKPhase = "</span></span> &lt;&lt; spiParams.Init.CLKPhase &lt;&lt; <span class="hljs-string"><span class="hljs-string">", Status = "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; } HAL_StatusTypeDef Spi::stop () { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Stopping SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device); HAL_StatusTypeDef retValue = HAL_SPI_DeInit(&amp;spiParams); disableClock(); hspi = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retValue; }</code> </pre> <br><p>  <strong>Arbeiten Sie mit der Hardware-Schnittstelle mithilfe von Interrupts</strong> .  Die Klasse implementiert eine I2S-Schnittstelle mithilfe eines DMA-Controllers.  I2S (Inter-IC Sound) ist ein Hardware- und Software-Add-On √ºber SPI, das beispielsweise selbst die Taktfrequenz ausw√§hlt und die Kan√§le abh√§ngig vom Audioprotokoll und der Bitrate steuert. </p><br><p>  In diesem Fall wird die I2S-Klasse von der "Port" -Klasse geerbt, dh I2S ist ein Port mit speziellen Eigenschaften.  Einige Daten werden in HAL-Strukturen gespeichert (plus der Einfachheit halber minus der Datenmenge).  Einige Daten werden vom Hauptcode √ºber Links √ºbertragen (z. B. die irqPrio-Struktur). </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I2S</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOPort { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IRQn_Type I2S_IRQ = SPI2_IRQn; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IRQn_Type DMA_TX_IRQ = DMA1_Stream4_IRQn; I2S (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; prio); <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> standard, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> audioFreq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dataFormat)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transmit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_I2S_Transmit_DMA(&amp;i2s, pData, size); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processI2SInterrupt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HAL_I2S_IRQHandler(&amp;i2s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processDmaTxInterrupt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HAL_DMA_IRQHandler(&amp;i2sDmaTx); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: I2S_HandleTypeDef i2s; DMA_HandleTypeDef i2sDmaTx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; irqPrio; };</code> </pre> <br><p>  Sein Konstruktor legt alle statischen Parameter fest: </p><br><pre> <code class="cpp hljs">I2S::I2S (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; prio): IOPort{name, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW, pin, <span class="hljs-literal"><span class="hljs-literal">false</span></span>}, irqPrio{prio} { i2s.Instance = SPI2; i2s.Init.Mode = I2S_MODE_MASTER_TX; i2s.Init.Standard = I2S_STANDARD_PHILIPS; <span class="hljs-comment"><span class="hljs-comment">// will be re-defined at communication start i2s.Init.DataFormat = I2S_DATAFORMAT_16B; // will be re-defined at communication start i2s.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE; i2s.Init.AudioFreq = I2S_AUDIOFREQ_44K; // will be re-defined at communication start i2s.Init.CPOL = I2S_CPOL_LOW; i2s.Init.ClockSource = I2S_CLOCK_PLL; i2s.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE; i2sDmaTx.Instance = DMA1_Stream4; i2sDmaTx.Init.Channel = DMA_CHANNEL_0; i2sDmaTx.Init.Direction = DMA_MEMORY_TO_PERIPH; i2sDmaTx.Init.PeriphInc = DMA_PINC_DISABLE; i2sDmaTx.Init.MemInc = DMA_MINC_ENABLE; i2sDmaTx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD; i2sDmaTx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD; i2sDmaTx.Init.Mode = DMA_NORMAL; i2sDmaTx.Init.Priority = DMA_PRIORITY_LOW; i2sDmaTx.Init.FIFOMode = DMA_FIFOMODE_ENABLE; i2sDmaTx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL; i2sDmaTx.Init.MemBurst = DMA_PBURST_SINGLE; i2sDmaTx.Init.PeriphBurst = DMA_PBURST_SINGLE; }</span></span></code> </pre> <br><p>  Der Start der Daten√ºbertragung wird durch die Startmethoden gesteuert, die f√ºr die Konfiguration der Portparameter, die Taktung der Schnittstelle, das Setzen von Interrupts, das Starten des DMA und das Starten der Schnittstelle selbst mit den angegebenen √úbertragungsparametern verantwortlich sind. </p><br><pre> <code class="cpp hljs">HAL_StatusTypeDef I2S::start (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> standard, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> audioFreq, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dataFormat) { i2s.Init.Standard = standard; i2s.Init.AudioFreq = audioFreq; i2s.Init.DataFormat = dataFormat; setMode(GPIO_MODE_AF_PP); setAlternate(GPIO_AF5_SPI2); __HAL_RCC_SPI2_CLK_ENABLE(); HAL_StatusTypeDef status = HAL_I2S_Init(&amp;i2s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not start I2S: "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_ERROR; } __HAL_RCC_DMA1_CLK_ENABLE(); __HAL_LINKDMA(&amp;i2s, hdmatx, i2sDmaTx); status = HAL_DMA_Init(&amp;i2sDmaTx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not initialize I2S DMA/TX channel: "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_ERROR; } HAL_NVIC_SetPriority(I2S_IRQ, irqPrio.first, irqPrio.second); HAL_NVIC_EnableIRQ(I2S_IRQ); HAL_NVIC_SetPriority(DMA_TX_IRQ, irqPrio.first + <span class="hljs-number"><span class="hljs-number">1</span></span>, irqPrio.second); HAL_NVIC_EnableIRQ(DMA_TX_IRQ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_OK; }</code> </pre> <br><p>  Das Stoppverfahren macht das Gegenteil: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I2S::stop () { HAL_NVIC_DisableIRQ(I2S_IRQ); HAL_NVIC_DisableIRQ(DMA_TX_IRQ); HAL_DMA_DeInit(&amp;i2sDmaTx); __HAL_RCC_DMA1_CLK_DISABLE(); HAL_I2S_DeInit(&amp;i2s); __HAL_RCC_SPI2_CLK_DISABLE(); setMode(GPIO_MODE_INPUT); }</code> </pre> <br><p>  Hier gibt es einige interessante Funktionen: </p><br><ul><li>  Verwendete Interrupts werden in diesem Fall als statische Konstanten definiert.  Dies ist ein Minus f√ºr die Portabilit√§t auf andere Controller. </li><li>  Eine solche Organisation des Codes stellt sicher, dass sich die Port-Pins immer im Status GPIO_MODE_INPUT befinden, wenn keine √úbertragung erfolgt.  Das ist ein Plus. </li><li>  Die Priorit√§t von Interrupts wird von au√üen √ºbertragen, dh es besteht eine gute M√∂glichkeit, eine Interrupt-Priorit√§tszuordnung an einer Stelle des Hauptcodes festzulegen.  Dies ist auch ein Plus. </li><li>  Die Stoppprozedur deaktiviert die DMA1-Taktung.  In diesem Fall kann diese Vereinfachung sehr negative Folgen haben, wenn jemand anderes weiterhin DMA1 verwendet.  Das Problem wird gel√∂st, indem ein zentrales Register der Verbraucher solcher Ger√§te erstellt wird, das f√ºr das Timing verantwortlich ist. </li><li>  Eine weitere Vereinfachung: Die Startprozedur bringt die Schnittstelle im Fehlerfall nicht in den urspr√ºnglichen Zustand (dies ist ein Minus, aber leicht zu beheben).  Gleichzeitig werden Fehler detaillierter protokolliert, was ein Plus ist. </li><li>  Bei Verwendung dieser Klasse sollte der Hauptcode die Interrupts SPI2_IRQn und DMA1_Stream4_IRQn abfangen und sicherstellen, dass die entsprechenden Handler processI2SInterrupt und processDmaTxInterrupt aufgerufen werden. </li></ul><br><h3 id="osnovnaya-programma">  Hauptprogramm </h3><br><p>  Das Hauptprogramm wird mit der oben beschriebenen Bibliothek ganz einfach geschrieben: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ HAL_Init(); <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::A, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::B, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::C, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// System frequency 168MHz System::ClockDiv clkDiv; clkDiv.PLLM = 16; clkDiv.PLLN = 336; clkDiv.PLLP = 2; clkDiv.PLLQ = 7; clkDiv.AHBCLKDivider = RCC_SYSCLK_DIV1; clkDiv.APB1CLKDivider = RCC_HCLK_DIV8; clkDiv.APB2CLKDivider = RCC_HCLK_DIV8; clkDiv.PLLI2SN = 192; clkDiv.PLLI2SR = 2; do { System::setClock(clkDiv, FLASH_LATENCY_3, System::RtcType::RTC_EXT); } while (System::getMcuFreq() != 168000000L); MyApplication app; appPtr = &amp;app; app.run(); }</span></span></code> </pre> <br><p>  Hier initialisieren wir die HAL-Bibliothek und konfigurieren standardm√§√üig alle Controller-Pins per Eingabe (GPIO_MODE_INPUT / PULLDOWN).  Wir stellen die Frequenz des Controllers ein, starten die Uhr (einschlie√ülich der Echtzeituhr vom externen Quarz).  Danach erstellen wir, etwas im Stil von Java, eine Instanz unserer Anwendung und rufen deren Ausf√ºhrungsmethode auf, die die gesamte Anwendungslogik implementiert. </p><br><p>  In einem separaten Abschnitt m√ºssen wir alle verwendeten Interrupts definieren.  Da wir in C ++ schreiben und Interrupts Dinge aus der Welt von C sind, m√ºssen wir sie entsprechend maskieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SysTick_Handler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ HAL_IncTick(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (appPtr != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { appPtr-&gt;getRtc().onMilliSecondInterrupt(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA2_Stream3_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processDmaRxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA2_Stream6_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processDmaTxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDIO_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processSdIOInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SPI2_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;getI2S().processI2SInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA1_Stream4_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;getI2S().processDmaTxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HAL_I2S_TxCpltCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I2S_HandleTypeDef *channel)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;processDmaTxCpltCallback(channel); } ... }</code> </pre> <br><p>  Die MyApplication-Klasse deklariert alle verwendeten Ger√§te, ruft Konstruktoren f√ºr alle diese Ger√§te auf und implementiert auch die erforderlichen Ereignishandler: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RealTimeClock::EventHandler, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RealTimeClock::EventHandler, WavStreamer::EventHandler, Devices::Button::EventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> INPUT_PINS = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Number of monitored input pins private: UsartLogger log; RealTimeClock rtc; IOPin ledGreen, ledBlue, ledRed; PeriodicalEvent heartbeatEvent; IOPin mco; // Interrupt priorities InterruptPriority irqPrioI2S; InterruptPriority irqPrioEsp; InterruptPriority irqPrioSd; InterruptPriority irqPrioRtc; // SD card IOPin pinSdPower, pinSdDetect; IOPort portSd1, portSd2; SdCard sdCard; bool sdCardInserted; // Configuration Config config; // ESP Esp11 esp; EspSender espSender; // Input pins std::array&lt;IOPin, INPUT_PINS&gt; pins; std::array&lt;bool, INPUT_PINS&gt; pinsState; // I2S2 Audio I2S i2s; AudioDac_UDA1334 audioDac; WavStreamer streamer; Devices::Button playButton; ...</span></span></code> </pre> <br><p>  Das hei√üt, tats√§chlich werden alle verwendeten Ger√§te statisch deklariert, was m√∂glicherweise zu einer Erh√∂hung des verwendeten Speichers f√ºhrt, aber den Zugriff auf Daten erheblich vereinfacht.  Im Konstruktor der MyApplication-Klasse m√ºssen die Designer aller Ger√§te aufgerufen werden. Danach werden zum Start der Ausf√ºhrungsprozedur alle verwendeten Mikrocontroller-Ger√§te initialisiert: </p><br><pre> <code class="cpp hljs"> MyApplication::MyApplication () : <span class="hljs-comment"><span class="hljs-comment">// logging log(Usart::USART_1, IOPort::B, GPIO_PIN_6, GPIO_PIN_7, 115200), // RTC rtc(), ledGreen(IOPort::C, GPIO_PIN_1, GPIO_MODE_OUTPUT_PP), ledBlue(IOPort::C, GPIO_PIN_2, GPIO_MODE_OUTPUT_PP), ledRed(IOPort::C, GPIO_PIN_3, GPIO_MODE_OUTPUT_PP), heartbeatEvent(rtc, 10, 2), mco(IOPort::A, GPIO_PIN_8, GPIO_MODE_AF_PP), // Interrupt priorities irqPrioI2S(6, 0), // I2S DMA interrupt priority: 7 will be also used irqPrioEsp(5, 0), irqPrioSd(3, 0), // SD DMA interrupt priority: 4 will be also used irqPrioRtc(2, 0), // SD card pinSdPower(IOPort::A, GPIO_PIN_15, GPIO_MODE_OUTPUT_PP, GPIO_PULLDOWN, GPIO_SPEED_HIGH, true, false), pinSdDetect(IOPort::B, GPIO_PIN_3, GPIO_MODE_INPUT, GPIO_PULLUP), portSd1(IOPort::C, /* mode = */GPIO_MODE_OUTPUT_PP, /* pull = */GPIO_PULLUP, /* speed = */GPIO_SPEED_FREQ_VERY_HIGH, /* pin = */GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12, /* callInit = */false), portSd2(IOPort::D, /* mode = */GPIO_MODE_OUTPUT_PP, /* pull = */GPIO_PULLUP, /* speed = */GPIO_SPEED_FREQ_VERY_HIGH, /* pin = */GPIO_PIN_2, /* callInit = */false), sdCard(pinSdDetect, portSd1, portSd2), sdCardInserted(false), // Configuration config(pinSdPower, sdCard, "conf.txt"), //ESP esp(rtc, Usart::USART_2, IOPort::A, GPIO_PIN_2, GPIO_PIN_3, irqPrioEsp, IOPort::A, GPIO_PIN_1), espSender(rtc, esp, ledRed), // Input pins pins { { IOPin(IOPort::A, GPIO_PIN_4, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_5, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_6, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_7, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::C, GPIO_PIN_4, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::C, GPIO_PIN_5, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::B, GPIO_PIN_0, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::B, GPIO_PIN_1, GPIO_MODE_INPUT, GPIO_PULLUP) } }, // I2S2 Audio Configuration // PB10 --&gt; I2S2_CK // PB12 --&gt; I2S2_WS // PB15 --&gt; I2S2_SD i2s(IOPort::B, GPIO_PIN_10 | GPIO_PIN_12 | GPIO_PIN_15, irqPrioI2S), audioDac(i2s, /* power = */ IOPort::B, GPIO_PIN_11, /* mute = */ IOPort::B, GPIO_PIN_13, /* smplFreq = */ IOPort::B, GPIO_PIN_14), streamer(sdCard, audioDac), playButton(IOPort::B, GPIO_PIN_2, GPIO_PULLUP, rtc) { mco.activateClockOutput(RCC_MCO1SOURCE_PLLCLK, RCC_MCODIV_5); }</span></span></code> </pre> <br><p>  Beispiel: Der Ereignishandler zum Klicken auf eine Schaltfl√§che zum Starten / Stoppen der Wiedergabe einer WAV-Datei: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyApplication::onButtonPressed (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Devices::Button * b, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numOccured) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == &amp;playButton) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"play button pressed: "</span></span> &lt;&lt; numOccured); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (streamer.isActive()) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">" Stopping WAV"</span></span>); streamer.stop(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">" Starting WAV"</span></span>); streamer.start(AudioDac_UDA1334::SourceType:: STREAM, config.getWavFile()); } } }</code> </pre> <br><p>  Schlie√ülich schlie√üt die Hauptausf√ºhrungsmethode die Konfiguration der Ger√§te ab (z. B. legt MyApplication als Ereignishandler fest) und startet eine Endlosschleife, in der regelm√§√üig auf die Ger√§te verwiesen wird, die regelm√§√üige Aufmerksamkeit erfordern: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyApplication::run () { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.initInstance(); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Oscillator frequency: "</span></span> &lt;&lt; System::getExternalOscillatorFreq() &lt;&lt; <span class="hljs-string"><span class="hljs-string">", MCU frequency: "</span></span> &lt;&lt; System::getMcuFreq()); HAL_StatusTypeDef status = HAL_TIMEOUT; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { status = rtc.start(<span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">2047</span></span> + <span class="hljs-number"><span class="hljs-number">7</span></span>, RTC_WAKEUPCLOCK_RTCCLK_DIV2, irqPrioRtc, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"RTC start status: "</span></span> &lt;&lt; status); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (status != HAL_OK); sdCard.setIrqPrio(irqPrioSd); sdCard.initInstance(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sdCard.isCardInserted()) { updateSdCardState(); } USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Input pins: "</span></span> &lt;&lt; pins.size()); pinsState.fill(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Pin state: "</span></span> &lt;&lt; fillMessage()); esp.assignSendLed(&amp;ledGreen); streamer.stop(); streamer.setHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); streamer.setVolume(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); playButton.setHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reportState = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { updateSdCardState(); playButton.periodic(); streamer.periodic(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInputPinsChanged()) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Input pins change detected"</span></span>); ledBlue.putBit(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); reportState = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } espSender.periodic(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (espSender.isOutputMessageSent()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reportState) { espSender.sendMessage(config, <span class="hljs-string"><span class="hljs-string">"TCP"</span></span>, config.getServerIp(), config.getServerPort(), fillMessage()); reportState = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!reportState) { ledBlue.putBit(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (heartbeatEvent.isOccured()) { ledGreen.putBit(heartbeatEvent.occurance() == <span class="hljs-number"><span class="hljs-number">1</span></span>); } } }</code> </pre> <br><h3 id="nemnogo-eksperimentov">  Ein bisschen experimentieren </h3><br><p>  Interessant ist, dass sich der Mikrocontroller zum teilweisen √úbertakten eignet.    ‚Äî 168 MHz. ,   ,      172 MHz   180 MHz,          ,      ,         MCO.     ,   USART  I2S, ,  ,      HAL. </p><br><h2 id="cena">  Preis </h2><br><p>        .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://htmlpreview.github.io/%3F">github</a>     .    - ,            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mouser</a> (   ).     37      .            .  ,        STM  Olimex,      . </p><br><h2 id="problemy-i-perspektivy">    </h2><br><p>        .       ,   : </p><br><ul><li>        (   ).  ,       ,            .       :     4  8 .        PLL,         . </li><li>    ,       .      47 ŒºF  . ,    . </li><li>   SWD      .    -  ,     .     . </li><li>     .     SMD ,    .       3       . </li></ul><br><h2 id="dokumentaciya">  Die Dokumentation </h2><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a>   GPL v3: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.google.com/viewer%3Furl%3D">Schema</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.google.com/viewer%3Furl%3D">Abmessungen</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.google.com/viewer%3Furl%3D"> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.google.com/viewer%3Furl%3D"> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://htmlpreview.github.io/%3F"> </a> </li></ul><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413101/">https://habr.com/ru/post/de413101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413091/index.html">Bequeme Protokollierung in SpringBoot + Log4j2 + Maven</a></li>
<li><a href="../de413093/index.html">In Erwartung des Rennens der Weltraumh√§ndler in den USA und in China</a></li>
<li><a href="../de413095/index.html">Anwendung neuronaler Netzwerktechnologien: Softwareentwicklung</a></li>
<li><a href="../de413097/index.html">Basierend auf Software auf Unternehmensebene, millionenfach getestet: openSUSE Leap 15 ver√∂ffentlicht</a></li>
<li><a href="../de413099/index.html">Downclocking RAM auf MacBook</a></li>
<li><a href="../de413103/index.html">3CX v15.5 Update 5 Beta und REST-Integration mit AmoCRM ver√∂ffentlicht</a></li>
<li><a href="../de413105/index.html">Hinweise des IoT-Anbieters. Aktivierung und Sicherheit in LoraWAN</a></li>
<li><a href="../de413107/index.html">√úbersetzung des Svelto.ECS-Projekt-Wikis. ECS-Framework f√ºr Unity3D</a></li>
<li><a href="../de413109/index.html">So erstellen Sie eine SaaS-Produktintegrationsplattform: Poster Cloud Checkout Experience</a></li>
<li><a href="../de413111/index.html">STM32 + NetBeans =?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>