<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîé üì∑ üë®üèª‚Äçüé® Menghibur JavaScript: Tanpa kurung kurawal üÜô üòº üïâÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript selalu mengejutkan saya, pertama-tama, karena mungkin tidak seperti bahasa luas lainnya yang mendukung kedua paradigma pada saat yang sama:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menghibur JavaScript: Tanpa kurung kurawal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428337/"><p><img src="https://habrastorage.org/webt/dl/n7/qy/dln7qyv9wb8ysot5ip5th9nxocu.png" alt="gambar"></p><br><p>  <strong>JavaScript</strong> selalu mengejutkan saya, pertama-tama, karena mungkin tidak seperti bahasa luas lainnya yang mendukung kedua paradigma pada saat yang sama: pemrograman normal dan abnormal.  Dan jika hampir semuanya telah dibaca tentang praktik dan templat terbaik yang memadai, maka dunia yang indah tentang bagaimana tidak menulis kode tetapi Anda bisa, tetap hanya sedikit terbuka. </p><br><p>  Dalam artikel ini, kami akan menganalisis tugas lain yang dibuat yang membutuhkan penyalahgunaan solusi normal yang tidak dapat dimaafkan. </p><a name="habracut"></a><br><p>  Tugas sebelumnya: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memoizer terpendek</a> </li></ul><br><h2 id="formulirovka">  Kata-kata </h2><br><blockquote> Terapkan fungsi dekorator yang menghitung jumlah panggilan ke fungsi yang diteruskan dan menyediakan kemampuan untuk mendapatkan nomor ini sesuai permintaan.  Solusinya <strong>tidak</strong> menggunakan kurung keriting dan variabel global. </blockquote><p>  Penghitung panggilan hanyalah alasan, karena ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">console.count ()</a> .  Intinya adalah bahwa fungsi kami mengakumulasi beberapa data saat memanggil fungsi yang dibungkus dan menyediakan antarmuka tertentu untuk mengaksesnya.  Itu bisa menyimpan semua hasil panggilan, dan mengumpulkan log, dan semacam memoisasi.  Hanya kontra - primitif dan dapat dimengerti oleh semua orang. </p><br><p>  Semua kompleksitas berada dalam batasan abnormal.  Anda tidak dapat menggunakan kurung kurawal, yang berarti Anda harus mempertimbangkan kembali praktik sehari-hari dan sintaksis biasa. </p><br><h2 id="privychnoe-reshenie">  Solusi kebiasaan </h2><br><p>  Pertama, Anda harus memilih titik awal.  Biasanya, jika bahasa atau ekstensi tidak menyediakan fungsi dekorasi yang diperlukan, kami akan mengimplementasikan beberapa wadah sendiri: fungsi yang dibungkus, akumulasi data, dan antarmuka untuk mengaksesnya.  Ini sering merupakan kelas: </p><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CountFunction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f = f; } invoke() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.calls += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f(...arguments); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csum = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountFunction(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> x + y); csum.invoke(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 10 csum.invoke(9, 6); // 15 csum.calls; // 2</span></span></code> </pre> <br><p>  Ini tidak cocok untuk kita segera, karena: </p><br><ol><li>  Dalam JavaScript, Anda tidak dapat menerapkan properti pribadi dengan cara ini: kami berdua dapat membaca <em>panggilan</em> instance (yang kami butuhkan) dan menulis nilai dari luar (yang kami TIDAK perlu).  Tentu saja, kita bisa menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">closure di konstruktor</a> , tapi lalu apa artinya kelas?  Dan saya masih takut menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bidang pribadi yang</a> segar tanpa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">babel 7</a> . </li><li>  Bahasa ini mendukung paradigma fungsional, dan menciptakan contoh melalui yang <em>baru</em> tampaknya bukan solusi terbaik di sini.  Lebih baik menulis fungsi yang mengembalikan fungsi lain.  Ya! </li><li>  Akhirnya, sintaks <em>ClassDeclaration</em> dan <em>MethodDefinition</em> tidak akan memungkinkan kita untuk menyingkirkan semua kurung kurawal. </li></ol><br><p>  Tetapi kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pola modul yang</a> luar biasa yang mengimplementasikan privasi menggunakan penutupan: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">invoke</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ calls += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(...arguments); }, <span class="hljs-attr"><span class="hljs-attr">getCalls</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> calls; } }; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csum = count(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> x + y); csum.invoke(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 10 csum.invoke(9, 6); // 15 csum.getCalls(); // 2</span></span></code> </pre> <br><p>  Anda sudah bisa bekerja dengan ini. </p><br><h2 id="zanimatelnoe-reshenie">  Keputusan yang menghibur </h2><br><p>  Mengapa kawat gigi digunakan di sini?  Ini adalah 4 kasus berbeda: </p><br><ol><li>  Menentukan isi fungsi hitungan ( <em>FunctionDeclaration</em> ) </li><li>  Inisialisasi objek yang dikembalikan </li><li>  Definisi tubuh fungsi panggil ( <em>FunctionExpression</em> ) dengan dua ekspresi </li><li>  Mendefinisikan tubuh fungsi getCalls ( <em>FunctionExpression</em> ) dengan satu ekspresi </li></ol><br><p>  Mari kita mulai dengan paragraf <strong>kedua</strong> .  Faktanya, kita tidak perlu mengembalikan objek baru, sementara mempersulit pemanggilan fungsi final melalui pemanggilan.  Kita dapat memanfaatkan fakta bahwa fungsi dalam JavaScript adalah objek, yang artinya dapat berisi bidang dan metode sendiri.  Mari kita buat fungsi return <em>df kita</em> dan menambahkan metode <em>getCalls</em> ke <em>dalamnya</em> , yang melalui penutupan akan memiliki akses ke <em>panggilan</em> seperti sebelumnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">df</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ calls += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(...arguments); } df.getCalls = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> calls; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; }</code> </pre> <br><p>  Lebih menyenangkan bekerja dengan ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csum = count(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> x + y); csum(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 10 csum(9, 6); // 15 csum.getCalls(); // 2</span></span></code> </pre> <br><p>  Poin <strong>keempat</strong> jelas: kita hanya mengganti <em>FunctionExpression</em> dengan <em>ArrowFunction</em> .  Tidak adanya kurung kurawal akan memberi kita catatan singkat tentang fungsi panah jika ada ekspresi tunggal di tubuhnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">df</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ calls += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(...arguments); } df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; }</code> </pre> <br><p>  Dengan yang <strong>ketiga</strong> - semuanya lebih rumit.  Ingat bahwa hal pertama yang kami lakukan adalah mengganti <em>FunctionExpression dengan</em> <em>memanggil</em> fungsi dengan <em>FunctionDeclaration df</em> .  Untuk menulis ulang ini ke <em>ArrowFunction,</em> dua masalah harus dipecahkan: untuk tidak kehilangan akses ke argumen (sekarang ini adalah pseudo-array <em>argumen</em> ) dan untuk menghindari badan fungsi dari dua ekspresi. </p><br><p>  Masalah pertama akan membantu kita mengatasi <em>argumen</em> parameter fungsi yang ditentukan secara eksplisit dengan <em>operator spread</em> .  Dan untuk menggabungkan dua ekspresi menjadi satu, Anda bisa menggunakan <em>logika AND</em> .  Tidak seperti operator penghubung logis klasik yang mengembalikan Boolean, operator ini menghitung operan dari kiri ke kanan ke "false" pertama dan mengembalikannya, dan jika semua "benar" - maka nilai terakhir.  Peningkatan pertama dari penghitung akan memberi kita 1, yang berarti bahwa sub-ekspresi ini akan selalu dilemparkan ke true.  Pengurangan ke "kebenaran" dari hasil pemanggilan fungsi pada sub-ekspresi kedua tidak menarik bagi kami: dalam hal apa pun, kalkulator berhenti melakukannya.  Sekarang kita bisa menggunakan <em>ArrowFunction</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> (calls += <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; f(...args); df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; }</code> </pre> <br><p>  Anda dapat menghias catatan sedikit menggunakan kenaikan awalan: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args); df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; }</code> </pre> <br><p>  Solusi ke titik <strong>pertama</strong> dan paling sulit akan dimulai dengan mengganti <em>FunctionDeclaration</em> dengan <em>ArrowFunction</em> .  Tapi kita masih memiliki tubuh dalam kurung kurawal: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args); df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; };</code> </pre> <br><p>  Jika kita ingin menghilangkan kurung kurawal membingkai tubuh fungsi, kita harus menghindari mendeklarasikan dan menginisialisasi variabel melalui <em>let</em> .  Dan kami memiliki dua variabel keseluruhan: <em>panggilan</em> dan <em>df</em> . </p><br><p>  Pertama, mari kita berurusan dengan konter.  Kita dapat membuat variabel lokal dengan mendefinisikannya dalam daftar parameter fungsi, dan mentransfer nilai awal dengan memanggilnya menggunakan IIFE (Ekspresi Fungsi yang Segera Diminta): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">calls</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args); df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; })(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Masih untuk menggabungkan tiga ekspresi menjadi satu.  Karena kami memiliki ketiga ekspresi yang mewakili fungsi yang selalu dapat direduksi menjadi true, kami juga dapat menggunakan <em>logika DAN</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">calls</span></span></span><span class="hljs-function"> =&gt;</span></span> (df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args)) &amp;&amp; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">df.getCalls = (</span></span></span><span class="hljs-function">) =&gt;</span></span> calls) &amp;&amp; df)(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Tetapi ada opsi lain untuk ekspresi gabungan: menggunakan <em>operator koma</em> .  Itu lebih disukai, karena tidak berurusan dengan transformasi logis yang tidak perlu dan memerlukan kurung lebih sedikit.  Operan dievaluasi dari kiri ke kanan, dan hasilnya adalah nilai yang terakhir: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">calls</span></span></span><span class="hljs-function"> =&gt;</span></span> (df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args), df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls, df))(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Kurasa aku berhasil membodohimu?  Kami dengan berani menyingkirkan deklarasi variabel <em>df</em> dan hanya menyisakan penugasan fungsi panah kami.  Dalam hal ini, variabel ini akan dideklarasikan secara global, yang tidak dapat diterima!  Untuk <em>df</em> , kami mengulang inisialisasi variabel lokal dalam parameter fungsi IIFE kami, tetapi kami tidak akan melewatkan nilai awal apa pun: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">calls, df</span></span></span><span class="hljs-function">) =&gt;</span></span> (df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args), df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls, df))(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Dengan demikian tujuan tercapai. </p><br><h2 id="variacii-na-temu">  Variasi pada Tema </h2><br><p>  Menariknya, kami dapat menghindari membuat dan menginisialisasi variabel lokal, beberapa ekspresi dalam blok fungsi, dan membuat objek literal.  Pada saat yang sama, solusi asli tetap bersih: tidak adanya variabel global, privasi counter, akses ke argumen fungsi yang dibungkus. </p><br><p>  Secara umum, Anda dapat mengambil implementasi apa pun dan mencoba melakukan hal serupa.  Misalnya, polyfill untuk fungsi <em>bind</em> dalam hal ini cukup sederhana: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bind = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, ctx, ...a</span></span></span><span class="hljs-function">) =&gt;</span></span> (...args) =&gt; f.apply(ctx, a.concat(args));</code> </pre> <br><p>  Namun, jika argumen <em>f</em> bukan fungsi, kita harus melemparkan pengecualian dengan cara yang baik.  Dan pengecualian <em>lemparan</em> tidak dapat dilemparkan dalam konteks ekspresi.  Anda dapat menunggu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekspresi lemparan (tahap 2)</a> dan coba lagi.  Atau apakah seseorang sudah memiliki pemikiran sekarang? </p><br><p>  Atau pertimbangkan kelas yang menggambarkan koordinat suatu titik: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x, y) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.y}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br><p>  Yang dapat diwakili oleh suatu fungsi: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function"> =&gt;</span></span> (px = x, py = y, p.toString = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> [<span class="hljs-string"><span class="hljs-string">'('</span></span>, x, <span class="hljs-string"><span class="hljs-string">', '</span></span>, y, <span class="hljs-string"><span class="hljs-string">')'</span></span>].join(<span class="hljs-string"><span class="hljs-string">''</span></span>), p))(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>);</code> </pre> <br><p>  Hanya di sini kita telah kehilangan warisan prototipe: <em>toString</em> adalah properti dari objek prototipe <em>Point</em> , bukan objek yang dibuat secara terpisah.  Bisakah ini dihindari jika Anda berusaha keras? </p><br><p>  Dalam hasil transformasi, kami mendapatkan campuran pemrograman fungsional yang tidak sehat dengan peretasan imperatif dan beberapa fitur bahasa itu sendiri.  Jika Anda memikirkannya, ini bisa menjadi obfuscator kode sumber yang menarik (tetapi tidak praktis).  Anda dapat membuat versi sendiri dari tugas "bracketing obfuscator" dan menghibur kolega dan teman JavaScripter di waktu luang mereka dari pekerjaan yang bermanfaat. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Pertanyaannya adalah, kepada siapa ini berguna dan mengapa itu dibutuhkan?  Ini benar-benar berbahaya bagi pemula, karena membentuk gagasan keliru tentang kerumitan dan penyimpangan bahasa yang berlebihan.  Tetapi ini bisa bermanfaat bagi para praktisi, karena memungkinkan Anda untuk melihat fitur-fitur bahasa dari sisi lain: panggilan itu bukan untuk menghindari, dan panggilan itu untuk mencoba untuk menghindari di masa depan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428337/">https://habr.com/ru/post/id428337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428321/index.html">Analitik data prediktif - pemodelan dan validasi</a></li>
<li><a href="../id428327/index.html">Apa yang harus diperhatikan: Peraturan Identifikasi Elektronik eIDAS Eropa</a></li>
<li><a href="../id428329/index.html">Pelatihan penguatan: parsing video game</a></li>
<li><a href="../id428333/index.html">2018 RAIF Hackathon AI Hackathon Hasil</a></li>
<li><a href="../id428335/index.html">Pembaruan Shortcut Siri</a></li>
<li><a href="../id428339/index.html">Jangan Otomatiskan: Tip Bisnis Buruk</a></li>
<li><a href="../id428341/index.html">Qsan RAID EE Technology</a></li>
<li><a href="../id428343/index.html">Teka-teki yang menarik di C</a></li>
<li><a href="../id428345/index.html">Mencakup persyaratan dengan kasing. Realitas SuperJob</a></li>
<li><a href="../id428347/index.html">Masa depan WebAssembly sebagai "pohon keterampilan"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>