<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§æüèΩ üëºüèΩ üë©üèª‚Äçüíª Ber√ßos de seguran√ßa: JWT üë©üèø‚Äçüöí üê¢ üö¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muitos aplicativos usam JSON Web Tokens (JWT) para permitir que o cliente se identifique para troca de informa√ß√µes adicionais ap√≥s a autentica√ß√£o. 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ber√ßos de seguran√ßa: JWT</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acribia/blog/457090/"><img src="https://habrastorage.org/webt/db/hk/3r/dbhk3r8z4e24imgvw6mjwyuat4m.png"><br><br>  Muitos aplicativos usam JSON Web Tokens (JWT) para permitir que o cliente se identifique para troca de informa√ß√µes adicionais ap√≥s a autentica√ß√£o. <br><br>  O JSON Web Token √© um padr√£o aberto (RFC 7519) que define uma maneira compacta e independente de transferir com seguran√ßa informa√ß√µes entre partes como um objeto JSON. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/oq/x9/6o/oqx96ozecxiq4qbsrzrk-dw7n5u.png"><br>  Essas informa√ß√µes s√£o verificadas e confi√°veis ‚Äã‚Äãporque s√£o assinadas digitalmente. <br>  Os JWTs podem ser assinados usando um segredo (usando o algoritmo HMAC) ou pares de chaves p√∫blica / privada usando RSA ou ECDSA. <br><br>  O JSON Web Token √© usado para transmitir informa√ß√µes sobre a identidade e as caracter√≠sticas do cliente.  Esse "cont√™iner" √© assinado pelo servidor para que o cliente n√£o interfira com ele e n√£o possa alterar, por exemplo, dados de identifica√ß√£o ou quaisquer caracter√≠sticas (por exemplo, a fun√ß√£o de um usu√°rio simples para um administrador ou alterar o login do cliente). <br><br>  Esse token √© criado em caso de autentica√ß√£o bem-sucedida e √© verificado pelo servidor antes de iniciar a execu√ß√£o de cada solicita√ß√£o do cliente.  O token √© usado pelo aplicativo como um ‚Äúcart√£o de identidade‚Äù do cliente (um cont√™iner com todas as informa√ß√µes sobre ele).  O servidor tem a capacidade de verificar a validade e a integridade do token de maneira segura.  Isso permite que o aplicativo seja sem estado (um aplicativo sem estado n√£o salva os dados do cliente gerados em uma sess√£o para uso na pr√≥xima sess√£o com esse cliente (cada sess√£o √© independente)) e o processo de autentica√ß√£o √© independente dos servi√ßos utilizados (no sentido de que as tecnologias de cliente e servidor pode variar, incluindo at√© o canal de transporte, embora o HTTP seja mais comumente usado). <br><br><h2>  Considera√ß√µes para usar o JWT </h2><br>  Mesmo que o token JWT seja f√°cil de usar e permita que voc√™ forne√ßa servi√ßos (principalmente REST) ‚Äã‚Äãsem monitora√ß√£o de estado (sem estado), essa solu√ß√£o n√£o √© adequada para todos os aplicativos, pois vem com algumas ressalvas, como a quest√£o de armazenar o token. <br><br>  Se o aplicativo n√£o precisar ser completamente sem estado, considere o uso do sistema de sess√µes tradicional fornecido por todas as plataformas da web.  No entanto, para aplicativos sem estado, o JWT √© uma boa op√ß√£o se implementado corretamente. <br><br>
<h2>  Problemas e ataques do JWT </h2><br><h4>  Usando o algoritmo de hash NONE </h4><br>  Um ataque semelhante ocorre quando um invasor altera o token e tamb√©m altera o algoritmo de hash (campo "alg") para indicar atrav√©s da palavra-chave none que a integridade do token j√° foi verificada.  Algumas bibliotecas visualizaram tokens assinados usando o algoritmo none como um token v√°lido com uma assinatura verificada, para que um invasor pudesse alterar a carga √∫til do token e o aplicativo confiasse no token. <br><br>  Para impedir um ataque, voc√™ deve usar a biblioteca JWT, que n√£o √© afetada por esta vulnerabilidade.  Al√©m disso, durante a valida√ß√£o do token, voc√™ deve solicitar explicitamente o uso do algoritmo esperado. <br><br>  <b><u>Exemplo de implementa√ß√£o:</u></b> <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; ... //        //    HMAC-256 - JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC)).build(); //   DecodedJWT decodedToken = verifier.verify(token);</span></span></code> </pre> <br><h4>  Intercep√ß√£o de token </h4><br>  O ataque ocorre quando um token √© interceptado ou roubado por um invasor e ele o usa para obter acesso ao sistema usando as credenciais de um usu√°rio espec√≠fico. <br><br>  A prote√ß√£o consiste em adicionar um "contexto de usu√°rio" ao token.  O contexto do usu√°rio consistir√° nas seguintes informa√ß√µes: <br><br><ol><li>  Uma sequ√™ncia aleat√≥ria gerada no est√°gio de autentica√ß√£o e inclu√≠da no token e tamb√©m enviada ao cliente como um cookie mais seguro (sinalizadores: prefixos de cookie HttpOnly + Secure + SameSite +). </li><li>  O hash SHA256 da cadeia aleat√≥ria ser√° armazenado no token, para que qualquer problema XSS n√£o permita que o invasor leia o valor da cadeia aleat√≥ria e defina o cookie esperado. </li></ol><br>  O endere√ßo IP n√£o ser√° usado em contexto, porque h√° situa√ß√µes em que o endere√ßo IP pode ser alterado durante uma sess√£o, por exemplo, quando um usu√°rio acessa o aplicativo por meio de seu telefone celular.  Ent√£o o endere√ßo IP est√° constantemente mudando legitimamente.  Al√©m disso, o uso de um endere√ßo IP pode causar problemas no n√≠vel de conformidade com o GDPR europeu. <br><br>  Se durante a verifica√ß√£o do token, o token recebido n√£o cont√©m o contexto correto, ele deve ser rejeitado. <br>  <b><u>Exemplo de implementa√ß√£o:</u></b> <br><br>  <i>C√≥digo para criar um token ap√≥s autentica√ß√£o bem-sucedida:</i> <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; //    private SecureRandom secureRandom = new SecureRandom(); ... //   ,     byte[] randomFgp = new byte[50]; secureRandom.nextBytes(randomFgp); String userFingerprint = DatatypeConverter.printHexBinary(randomFgp); //    cookie String fingerprintCookie = "__Secure-Fgp=" + userFingerprint + "; SameSite=Strict; HttpOnly; Secure"; response.addHeader("Set-Cookie", fingerprintCookie); // SHA256          // (  )  XSS      //     cookie MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] userFingerprintDigest = digest.digest(userFingerprint.getBytes("utf-8")); String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest); //      15     Calendar c = Calendar.getInstance(); Date now = c.getTime(); c.add(Calendar.MINUTE, 15); Date expirationDate = c.getTime(); Map&lt;String, Object&gt; headerClaims = new HashMap&lt;&gt;(); headerClaims.put("typ", "JWT"); String token = JWT.create().withSubject(login) .withExpiresAt(expirationDate) .withIssuer(this.issuerID) .withIssuedAt(now) .withNotBefore(now) .withClaim("userFingerprint", userFingerprintHash) .withHeader(headerClaims) .sign(Algorithm.HMAC256(this.keyHMAC));</span></span></code> </pre> <br><br>  <i>C√≥digo para verificar a validade do token:</i> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; ... //     cookie String userFingerprint = null; if (request.getCookies() != null &amp;&amp; request.getCookies().length &gt; 0) { List&lt;Cookie&gt; cookies = Arrays.stream(request.getCookies()).collect(Collectors.toList()); Optional&lt;Cookie&gt; cookie = cookies.stream().filter(c -&gt; "__Secure-Fgp" .equals(c.getName())).findFirst(); if (cookie.isPresent()) { userFingerprint = cookie.get().getValue(); } } //  SHA256      cookie  //       MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] userFingerprintDigest = digest.digest(userFingerprint.getBytes("utf-8")); String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest); //      JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC)) .withIssuer(issuerID) .withClaim("userFingerprint", userFingerprintHash) .build(); //   DecodedJWT decodedToken = verifier.verify(token);</span></span></code> </pre> <br><h4>  Revoga√ß√£o expl√≠cita do token pelo usu√°rio </h4><br>  Como o token se torna inv√°lido somente ap√≥s sua expira√ß√£o, o usu√°rio n√£o possui uma fun√ß√£o interna que permita cancelar explicitamente o token.  Assim, em caso de roubo, o usu√°rio n√£o pode retirar o token sozinho e depois bloquear o atacante. <br><br>  Um dos m√©todos de prote√ß√£o √© a introdu√ß√£o de uma lista negra de tokens, que ser√° adequada para simular a fun√ß√£o de "logout" existente em um sistema tradicional de sess√µes. <br><br>  A cole√ß√£o (na codifica√ß√£o SHA-256 em HEX) do token com a data de cancelamento, que deve exceder o per√≠odo de validade do token emitido, ser√° armazenada na lista negra. <br><br>  Quando o usu√°rio deseja "efetuar logout", ele chama um servi√ßo especial que adiciona o token de usu√°rio fornecido √† lista negra, o que leva ao cancelamento imediato do token para uso posterior no aplicativo. <br><br>  <u><b>Exemplo de implementa√ß√£o:</b></u> <br><br>  <i>Reposit√≥rio da lista negra:</i> <br>  Para armazenamento centralizado da lista negra, ser√° utilizado um banco de dados com a seguinte estrutura: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">create table </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> not exists </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revoked_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jwt_token_digest varchar(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">255</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> primary key, revokation_date timestamp </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">now</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  <i>Gerenciamento de revoga√ß√£o de token:</i> <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    (logout). //  ,      //         . public class TokenRevoker { //    @Resource("jdbc/storeDS") private DataSource storeDS; //      public boolean isTokenRevoked(String jwtInHex) throws Exception { boolean tokenIsPresent = false; if (jwtInHex != null &amp;&amp; !jwtInHex.trim().isEmpty()) { //   byte[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex); //  SHA256   MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] cipheredTokenDigest = digest.digest(cipheredToken); String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest); //     try (Connection con = this.storeDS.getConnection()) { String query = "select jwt_token_digest from revoked_token where jwt_token_digest = ?"; try (PreparedStatement pStatement = con.prepareStatement(query)) { pStatement.setString(1, jwtTokenDigestInHex); try (ResultSet rSet = pStatement.executeQuery()) { tokenIsPresent = rSet.next(); } } } } return tokenIsPresent; } //    HEX      public void revokeToken(String jwtInHex) throws Exception { if (jwtInHex != null &amp;&amp; !jwtInHex.trim().isEmpty()) { //   byte[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex); //  SHA256   MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] cipheredTokenDigest = digest.digest(cipheredToken); String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest); //             //   if (!this.isTokenRevoked(jwtInHex)) { try (Connection con = this.storeDS.getConnection()) { String query = "insert into revoked_token(jwt_token_digest) values(?)"; int insertedRecordCount; try (PreparedStatement pStatement = con.prepareStatement(query)) { pStatement.setString(1, jwtTokenDigestInHex); insertedRecordCount = pStatement.executeUpdate(); } if (insertedRecordCount != 1) { throw new IllegalStateException("Number of inserted record is invalid," + " 1 expected but is " + insertedRecordCount); } } } } }</span></span></code> </pre><br><h4>  Divulga√ß√£o de Token </h4><br>  Esse ataque ocorre quando um invasor obt√©m acesso a um token (ou um conjunto de tokens) e extrai as informa√ß√µes nele armazenadas (as informa√ß√µes sobre o token JWT s√£o codificadas usando base64) para obter informa√ß√µes sobre o sistema.  As informa√ß√µes podem ser, por exemplo, fun√ß√µes de seguran√ßa, formato de login etc. <br><br>  O m√©todo de prote√ß√£o √© bastante √≥bvio e consiste em criptografar o token.  Tamb√©m √© importante proteger os dados criptografados contra ataques usando a an√°lise de criptografia.  Para atingir todos esses objetivos, √© usado o algoritmo AES-GCM, que fornece criptografia autenticada com dados associados (AEAD).  A primitiva AEAD fornece funcionalidade de criptografia autenticada sim√©trica.  As implementa√ß√µes dessa primitiva s√£o protegidas contra ataques adaptativos com base no texto cifrado selecionado.  Ao criptografar texto sem formata√ß√£o, voc√™ pode opcionalmente especificar dados relacionados que devem ser autenticados, mas n√£o criptografados. <br><br>  Ou seja, a criptografia com os dados relevantes garante a autenticidade e a integridade dos dados, mas n√£o o sigilo. <br><br>  No entanto, deve-se observar que a criptografia √© adicionada principalmente para ocultar informa√ß√µes internas, mas √© muito importante lembrar que a prote√ß√£o inicial contra a falsifica√ß√£o do token JWT √© a assinatura, portanto, a assinatura do token e sua verifica√ß√£o sempre devem ser usadas. <br><br><h4>  Armazenamento de token do lado do cliente </h4><br>  Se o aplicativo armazena o token para que ocorra uma ou mais das seguintes situa√ß√µes: <br><br><ul><li>  o token √© enviado automaticamente pelo navegador (armazenamento de cookies); </li><li>  o token √© obtido mesmo se o navegador for reiniciado (usando o cont√™iner localStorage do navegador); </li><li>  o token √© obtido no caso de um ataque XSS (cookie dispon√≠vel para c√≥digo JavaScript ou um token armazenado em localStorage ou sessionStorage). </li></ul><br>  Para impedir um ataque: <br><br><ol><li>  Armazene o token no navegador usando o cont√™iner sessionStorage. </li><li>  Adicione-o ao cabe√ßalho de Autoriza√ß√£o usando o esquema Portador.  O t√≠tulo deve ficar assim: <br><br><pre> <code class="xml hljs">Authorization: Bearer <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">token</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </li><li>  Adicione informa√ß√µes de impress√£o digital ao token. </li></ol><br>  Armazenando o token no cont√™iner sessionStorage, ele fornece um token para roubo no caso do XSS.  No entanto, uma impress√£o digital adicionada ao token impede que um invasor reutilize o token roubado em seu computador.  Para fechar as √°reas de uso m√°ximo de um invasor, adicione uma Pol√≠tica de Seguran√ßa de Conte√∫do para limitar o contexto de execu√ß√£o. <br><br>  Ainda existe um caso em que um invasor usa o contexto de navega√ß√£o do usu√°rio como um servidor proxy para usar o aplicativo de destino atrav√©s de um usu√°rio leg√≠timo, mas a Pol√≠tica de Seguran√ßa de Conte√∫do pode impedir a comunica√ß√£o com dom√≠nios inesperados. <br><br>  Tamb√©m √© poss√≠vel implementar um servi√ßo de autentica√ß√£o para que o token seja emitido dentro de um cookie seguro, mas, nesse caso, a prote√ß√£o contra o CSRF deve ser implementada. <br><br><h4>  Usando uma chave fraca para criar um token </h4><br>  Se o segredo usado no caso do algoritmo HMAC-SHA256, necess√°rio para assinar o token, for fraco, ele poder√° ser invadido (detectado usando um ataque de for√ßa bruta).  Como resultado, um invasor pode falsificar um token v√°lido arbitr√°rio em termos de assinatura. <br><br>  Para evitar esse problema, voc√™ deve usar uma chave secreta complexa: alfanum√©rica (mai√∫sculas e min√∫sculas) + caracteres especiais. <br><br>  Como a chave √© necess√°ria apenas para c√°lculos de computador, o tamanho da chave secreta pode exceder 50 posi√ß√µes. <br><br>  Por exemplo: <br><br><pre> <code class="plaintext hljs">A&amp;'/}Z57M(2hNg=;LE?~]YtRMS5(yZ&lt;vcZTA3N-($&gt;2j:ZeX-BGftaVk`)jKP~q?,jk)EMbgt*kW'</code> </pre> <br>  Para avaliar a complexidade da chave secreta usada para sua assinatura de token, voc√™ pode aplicar um ataque de dicion√°rio de senha ao token em combina√ß√£o com a API JWT. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457090/">https://habr.com/ru/post/pt457090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457072/index.html">Como resolver um problema antigo usando o ML em Python e .Net</a></li>
<li><a href="../pt457074/index.html">A evolu√ß√£o dos desenvolvedores: quais jogos devemos esperar no futuro</a></li>
<li><a href="../pt457078/index.html">Como transformar seu avatar do Telegram em um rel√≥gio</a></li>
<li><a href="../pt457082/index.html">Concess√£o impercept√≠vel de direitos de administrador</a></li>
<li><a href="../pt457086/index.html">Padr√£o arquitetural "Builder" no universo de "Swift" e "iOS" / "macOS"</a></li>
<li><a href="../pt457092/index.html">Estudamos MITRE ATT & CK. Matrizes m√≥veis: acesso ao dispositivo. Parte 5</a></li>
<li><a href="../pt457094/index.html">Suplemento do Excel que facilita a defini√ß√£o de filtros ao trabalhar com cubos (VBA)</a></li>
<li><a href="../pt457096/index.html">Liberamos nossas m√£os para v√°rios analistas: API Livy para automa√ß√£o de tarefas banc√°rias t√≠picas</a></li>
<li><a href="../pt457098/index.html">Tratamento elegante de erros de JavaScript com a m√¥nada Ou</a></li>
<li><a href="../pt457100/index.html">AWS Lambda - Teoria, conhecimento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>