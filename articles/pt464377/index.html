<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó°Ô∏è üë©üèª‚Äçüíª üë®üèª‚Äçüî¨ Montador sujo hacks 6502 üîõ ü§ôüèø ‚óÄÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo lista alguns dos truques que os participantes do meu pequeno concurso de programa√ß√£o Commodore 64 usaram. As regras do concurso eram simpl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Montador sujo hacks 6502</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464377/">  Este artigo lista alguns dos truques que os participantes do meu pequeno <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">concurso de programa√ß√£o Commodore 64</a> usaram.  As regras do concurso eram simples: crie um arquivo execut√°vel C64 (PRG), que desenha duas linhas para formar a imagem abaixo.  Aquele cujo arquivo √© menor em tamanho venceu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/5d1/afc/3f45d1afc9817c6530b6b34c44dd0497.png"></div><br>  As entradas da competi√ß√£o foram publicadas em tweets abertos e em mensagens privadas que continham apenas bytes do arquivo PRG e um hash MD5. <br><a name="habracut"></a><br>  Lista de participantes com links para o c√≥digo fonte: <br><br><ul>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Philip Heron</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo</a> - 34 bytes, vencedor) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Geir Straume</a> ( <a href="">c√≥digo</a> - 34 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Petri Hakkinen</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo</a> - 37 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Matlev Raksenblatts</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo</a> - 38 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jan Ahrenius</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo</a> - 48 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jamie Fuller</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo</a> - 50 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">David A. Gershman</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo</a> - 53 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Janne Hellsten</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo</a> - 56 bytes) </li></ul><br>  (Se eu perdi algu√©m, entre em contato, atualizarei a lista). <br><br>  O restante do artigo √© dedicado a alguns truques de montador que foram usados ‚Äã‚Äãna competi√ß√£o. <br><br><h1>  O b√°sico </h1><br>  Os gr√°ficos C64 funcionam por padr√£o no modo de codifica√ß√£o de 40x25 caracteres.  O framebuffer na RAM √© dividido em duas matrizes: <br><br><ul><li> <code>$0400</code> (RAM da tela, 40x25 bytes) <br></li><li>  <code>$d800</code> (RAM colorida, 40x25 bytes) </li></ul><br>  Para definir um caractere, salve o byte na RAM da tela, em <code>$0400</code> (por exemplo, <code>$0400+y*40+x</code> ).  A RAM colorida √© inicializada em azul claro por padr√£o (cor 14): essa √© a cor que usamos para as linhas, ou seja, a RAM colorida pode ser deixada sem toque. <br><br>  Voc√™ controla as cores da borda e do fundo usando os registros de E / S de mem√≥ria em <code>$d020</code> (borda) e <code>$d021</code> (fundo). <br><br>  Desenhar duas linhas √© muito f√°cil se voc√™ programar diretamente a inclina√ß√£o de uma linha fixa.  Aqui est√° uma implementa√ß√£o C que desenha linhas e libera o conte√∫do da tela para que stdout ( <code>malloc()</code> seja usado para fazer o c√≥digo funcionar em um PC): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void dump(const uint8_t* screen) { const uint8_t* s = screen; for (int y = 0; y &lt; 25; y++) { for (int x = 0; x &lt; 40; x++, s++) { printf("%c", *s == 0xa0 ? '#' : '.'); } printf("\n"); } } void setreg(uintptr_t dst, uint8_t v) { // *((uint8_t *)dst) = v; } int main() { // uint8_t* screenRAM = (uint_8*)0x0400; uint8_t* screenRAM = (uint8_t *)calloc(40*25, 0x20); setreg(0xd020, 0); // Set border color setreg(0xd021, 0); // Set background color int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; for (int x = 0; x &lt; 40; x++) { int yi = yf &gt;&gt; 8; // First line screenRAM[x + yi*40] = 0xa0; // Second line (X-mirrored) screenRAM[(39-x) + yi*40] = 0xa0; yf += yslope; } dump(screenRAM); }</span></span></span></span></code> </pre> <br>  Os c√≥digos de tela acima s√£o <code>$20</code> (em branco) e <code>$a0</code> (bloco 8 √ó 8 preenchido).  Se voc√™ executar, voc√™ ver√° uma imagem ASCII com duas linhas: <br><br><pre>  ## .................................... ##
 .. # .................................. # ..
 ... ## .............................. ## ...
 ..... # ............................ # .....
 ...... ## ........................ ## ......
 ........ ## .................... ## ........
 .......... # .................. # ..........
 ........... ## .............. ## ...........
 ............. # ............ # .............
 .............. ## ........ ## ..............
 ................ ## .... ## ................
 .................. # .. # ..................
 ................... ## ...................
 .................. # .. # ..................
 ................ ## .... ## ................
 .............. ## ........ ## ..............
 ............. # ............ # .............
 ........... ## .............. ## ...........
 .......... # .................. # ..........
 ........ ## .................... ## ........
 ...... ## ........................ ## ......
 ..... # ............................ # .....
 ... ## .............................. ## ...
 .. # .................................. # ..
 ## .................................... ## </pre><br>  O mesmo √© trivialmente implementado no assembler: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) entry: { lda #0 ; black color sta $d020 ; set border to 0 sta $d021 ; set background to 0 ; clear the screen ldx #0 lda #$20 clrscr: !for i in [0, $100, $200, $300] { sta $0400 + i, x } inx bne clrscr ; line drawing, completely unrolled ; with assembly pseudos lda #$a0 !for i in range(40) { !let y0 = Math.floor(25/40*(i+0.5)) sta $0400 + y0*40 + i sta $0400 + (24-y0)*40 + i } inf: jmp inf ; halt }</code> </pre> <br>  Acontece que o PRG possui um tamanho bastante grande de 286 bytes. <br><br>  Antes de mergulhar na otimiza√ß√£o, fazemos algumas observa√ß√µes. <br><br>  Primeiramente, trabalhamos em C64 com as rotinas de ROM em vigor.  Existem in√∫meras rotinas que podem ser √∫teis.  Por exemplo, limpando a tela com <code>JSR $E544</code> . <br><br>  Em segundo lugar, os c√°lculos de endere√ßo em um processador de 8 bits como o 6502 podem ser complicados e consumir muitos bytes.  Esse processador tamb√©m n√£o possui um multiplicador; portanto, um c√°lculo como <code>y*40+i</code> geralmente inclui v√°rias mudan√ßas l√≥gicas ou uma tabela de pesquisa que tamb√©m consome bytes.  Para evitar multiplicar por 40, √© melhor avan√ßar o cursor da tela de forma incremental: <br><br><pre> <code class="plaintext hljs"> int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xa0; dst[(39-x)] = 0xa0; yf += yslope; if (yf &amp; 256) { // Carry set? dst += 40; yf &amp;= 255; } }</code> </pre> <br>  Continuamos adicionando a inclina√ß√£o da linha ao contador fixo <code>yf</code> e, quando a adi√ß√£o de 8 bits define o sinalizador de transporte, adicione 40. <br><br>  Aqui est√° uma abordagem incremental do montador: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) !let screenptr = $20 !let x0 = $40 !let x1 = $41 !let yf = $60 entry: { lda #0 sta x0 sta $d020 sta $d021 ; kernal clear screen jsr $e544 ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1 lda #80 sta yf lda #39 sta x1 xloop: lda #$a0 ldy x0 ; screenRAM[x] = 0xA0 sta (screenptr), y ldy x1 ; screenRAM[39-x] = 0xA0 sta (screenptr), y clc lda #160 ; line slope adc yf sta yf bcc no_add ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1 no_add: inc x0 dec x1 bpl xloop inf: jmp inf }</code> </pre> <br>  Com 82 bytes, ainda √© bastante robusto.  Um problema √≥bvio s√£o os c√°lculos de endere√ßos de 16 bits.  Defina o valor <code>screenptr</code> para <code>screenptr</code> indireta: <br><br><pre> <code class="plaintext hljs"> ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1</code> </pre> <br>  <code>screenptr</code> para a pr√≥xima linha adicionando 40: <br><br><pre> <code class="plaintext hljs"> ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1</code> </pre> <br>  Obviamente, esse c√≥digo pode ser otimizado, mas e se voc√™ se livrar dos endere√ßos de 16 bits?  Vamos ver como fazer isso. <br><br><h1>  Truque 1. Rolagem! </h1><br>  Em vez de construir uma linha na RAM da tela, desenhamos apenas na √∫ltima linha Y = 24 e <code>JSR $E8EA</code> a tela inteira, chamando a fun√ß√£o de rolagem ROM com <code>JSR $E8EA</code> ! <br><br>  Veja como o xloop √© otimizado: <br><br><pre> <code class="plaintext hljs"> lda #0 sta x0 lda #39 sta x1 xloop: lda #$a0 ldx x0 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: inc x0 dec x1 bpl xloop</code> </pre> <br>  √â assim que a renderiza√ß√£o se parece: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/081/6a6/63f0816a6728ec839de0197b6e0a3179.gif"></div><br><br>  Este √© um dos meus truques favoritos neste programa.  Quase todos os competidores encontraram por conta pr√≥pria. <br><br><h1>  Truque 2. C√≥digo de Auto-Modifica√ß√£o </h1><br>  O c√≥digo para armazenar valores de pixels termina assim: <br><br><pre> <code class="plaintext hljs"> ldx x1 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x0 sta $0400 + 24*40, x inc x0 dec x1</code> </pre> <br>  Isso √© codificado na seguinte sequ√™ncia de 14 bytes: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: A6 20 LDX $20 080A: 9D C0 07 STA $07C0,X 080D: E6 22 INC $22 080F: C6 20 DEC $20</code> </pre> <br>  Usando o c√≥digo de modifica√ß√£o pr√≥pria (SMC), voc√™ pode escrever isso de forma mais compacta: <br><br><pre> <code class="plaintext hljs"> ldx x1 sta $0400 + 24*40, x addr0: sta $0400 + 24*40 ; advance the second x-coord with SMC inc addr0+1 dec x1</code> </pre> <br>  ... que √© codificado em 13 bytes: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: 8D C0 07 STA $07C0 080B: EE 09 08 INC $0809 080E: C6 22 DEC $22</code> </pre> <br><h1>  Truque 3. Estado da opera√ß√£o 'power on' </h1><br>  Foi considerado normal na competi√ß√£o fazer suposi√ß√µes malucas sobre o ambiente de trabalho.  Por exemplo, que o desenho da linha √© a primeira coisa que come√ßa ap√≥s ligar a energia do C64 e n√£o h√° requisitos para uma sa√≠da limpa de volta √† linha de comando do BASIC.  Portanto, tudo o que voc√™ encontra no ambiente inicial ao entrar no PRG pode e deve ser usado para sua vantagem: <br><br><ul><li>  Os registros A, X, Y s√£o tomados como zeros <br></li><li>  Todos os sinalizadores da CPU limpos <br></li><li>  Conte√∫do do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zeropage</a> (endere√ßos de <code>$00</code> <code>$ff</code> ) </li></ul><br>  Da mesma forma, ao chamar alguns procedimentos de KERNAL ROM, voc√™ pode tirar proveito de todos os efeitos colaterais: sinalizadores de CPU retornados, valores tempor√°rios de zeropage, etc. <br><br>  Ap√≥s as primeiras otimiza√ß√µes, vamos procurar algo interessante na mem√≥ria da m√°quina: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/43f/93c/0df43f93c58a142911607d3ba5ba44dd.png"></div><br><br>  O Zeropage cont√©m alguns valores √∫teis para nossos prop√≥sitos: <br><br><ul><li>  <code>$d5</code> : 39 / $ 27 == comprimento da linha - 1 <br></li><li>  <code>$22</code> : 64 / $ 40 == valor inicial para o contador de inclina√ß√£o da linha </li></ul><br>  Isso economizar√° alguns bytes durante a inicializa√ß√£o.  Por exemplo: <br><br><pre> <code class="plaintext hljs">!let x0 = $20 lda #39 ; 0801: A9 27 LDA #$27 sta x0 ; 0803: 85 20 STA $20 xloop: dec x0 ; 0805: C6 20 DEC $20 bpl xloop ; 0807: 10 FC BPL $0805</code> </pre> <br>  Como <code>$d5</code> cont√©m o valor 39, voc√™ pode indic√°-lo para o contador <code>x0</code> , livrando-se do par LDA / STA: <br><br><pre> <code class="plaintext hljs">!let x0 = $d5 ; nothing here! xloop: dec x0 ; 0801: C6 D5 DEC $D5 bpl xloop ; 0803: 10 FC BPL $0801</code> </pre> <br>  Philip, o vencedor do concurso, leva isso a extremos em <a href="">seu c√≥digo</a> .  Lembre-se do endere√ßo do √∫ltimo caractere da cadeia <code>$07C0</code> (== <code>$0400+24*40</code> ).  Este valor n√£o est√° presente no zeropage durante a inicializa√ß√£o.  No entanto, como efeito colateral de como a rotina de rolagem da ROM usa valores tempor√°rios de zeropage, os endere√ßos <code>$D1-$D2</code> na sa√≠da da fun√ß√£o conter√£o o valor <code>$07C0</code> .  Portanto, para armazenar um pixel, em vez de <code>STA $07C0,x</code> voc√™ pode usar um menor do <code>STA ($D1),y</code> indiretamente indexado <code>STA ($D1),y</code> . <br><br><h1>  Truque 4. Otimiza√ß√£o de download </h1><br>  Um bin√°rio PRG C64 t√≠pico cont√©m o seguinte: <br><br><ul><li>  Primeiros 2 bytes: endere√ßo de download (geralmente <code>$0801</code> ) <br></li><li>  12 bytes da sequ√™ncia de inicializa√ß√£o do BASIC </li></ul><br>  A sequ√™ncia principal de inicializa√ß√£o fica assim (aborda <code>$801-$80C</code> ): <br><br><pre> <code class="plaintext hljs">0801: 0B 08 0A 00 9E 32 30 36 31 00 00 00 080D: 8D 20 D0 STA $D020</code> </pre> <br>  Sem entrar em detalhes sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">layout da mem√≥ria tokenizada BASIC</a> , essa sequ√™ncia corresponde mais ou menos a '10 SYS 2061 '.  O endere√ßo <code>2061</code> ( <code>$080D</code> ) √© onde nosso programa de c√≥digo de m√°quina real √© executado quando o int√©rprete BASIC executa o comando SYS. <br><br>  Parece que 14 bytes √© demais.  Philip, Matlev e Geir usaram v√°rios truques complicados para se livrar completamente da sequ√™ncia principal.  Isso requer o carregamento do PRG com <code>LOAD"*",8,1</code> , pois <code>LOAD"*",8</code> ignora o endere√ßo de carregamento do PRG (dois primeiros bytes) e sempre √© carregado em <code>$0801</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/911/d07/fdb/911d07fdb2c0e2e13b07e360bb16d03c.png"></div><br><br>  Dois m√©todos foram usados ‚Äã‚Äãaqui: <br><br><ul><li>  Truque de pilha <br></li><li>  Truque de redefini√ß√£o quente b√°sico </li></ul><br><h3>  Truque de pilha </h3><br>  O truque √© <code>$01F8</code> na pilha do processador a <code>$01F8</code> valor que indica nosso ponto de entrada desejado.  Isso √© feito criando um PRG que come√ßa com um ponteiro de 16 bits para o nosso c√≥digo e carregando o PRG em <code>$01F8</code> : <br><br><pre> <code class="plaintext hljs"> * = $01F8 !word scroll - 1 ; overwrite stack scroll: jsr $E8EA</code> </pre> <br>  Assim que o carregador BASIC (consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo ap√≥s a desmontagem</a> ) terminar o carregamento e desejar retornar ao chamador usando <code>RTS</code> , ele retornar√° diretamente ao nosso PRG. <br><br><h3>  Truque de redefini√ß√£o quente b√°sico </h3><br>  Isso √© um pouco mais f√°cil de explicar simplesmente olhando para o PRG ap√≥s a desmontagem. <br><br><pre> <code class="plaintext hljs">02E6: 20 EA E8 JSR $E8EA 02E9: A4 D5 LDY $D5 02EB: A9 A0 LDA #$A0 02ED: 99 20 D0 STA $D020,Y 02F0: 91 D1 STA ($D1),Y 02F2: 9D B5 07 STA $07B5,X 02F5: E6 D6 INC $D6 02F7: 65 90 ADC $90 02F9: 85 90 STA $90 02FB: C6 D5 DEC $D5 02FD: 30 FE BMI $02FD 02FF: 90 E7 BCC $02E8 0301: 4C E6 02 JMP $02E6</code> </pre> <br>  Preste aten√ß√£o na √∫ltima linha ( <code>JMP $02E6</code> ).  A instru√ß√£o JMP come√ßa em <code>$0301</code> com um endere√ßo de salto de <code>$0302-$0303</code> . <br><br>  Quando esse c√≥digo √© carregado na mem√≥ria, come√ßando no endere√ßo <code>$02E6</code> , o valor <code>$02E6</code> gravado nos endere√ßos <code>$0302-$0303</code> .  Bem, este local tem um significado especial: cont√©m um ponteiro para o ‚Äúciclo de espera BASIC‚Äù (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o cart√£o de mem√≥ria C64</a> para obter mais detalhes).  O download do PRG o substitui por <code>$02E6</code> e, portanto, quando o int√©rprete BASIC ap√≥s uma reinicializa√ß√£o a quente tenta ir para o loop de espera, ele nunca entra nesse loop, mas entra no programa de renderiza√ß√£o! <br><br><h3>  Outros truques com o lan√ßamento do BASIC </h3><br>  Petri descobriu <a href="">outro truque b√°sico de lan√ßamento</a> que permite inserir suas pr√≥prias constantes no zeropage.  Neste m√©todo, voc√™ cria manualmente sua pr√≥pria sequ√™ncia inicial BASIC tokenizada e codifica as constantes nos n√∫meros de linha do programa BASIC.  Na entrada, os n√∫meros da linha BASIC, ou seja, suas constantes ser√£o armazenadas nos endere√ßos <code>$39-$3A</code> .  Muito esperto! <br><br><h1>  Truque 5. Fluxo de controle personalizado </h1><br>  Aqui est√° uma vers√£o ligeiramente simplificada do loop x que imprime apenas uma linha e interrompe a execu√ß√£o: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: dec x1 bpl xloop ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  Mas h√° um erro.  Quando desenhamos o √∫ltimo pixel, n√£o podemos mais rolar a tela.  Assim, s√£o necess√°rias ramifica√ß√µes adicionais para interromper a rolagem ap√≥s a grava√ß√£o do √∫ltimo pixel: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x dec x1 ; skip scrolling if last pixel bmi done adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: jmp xloop done: ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  O fluxo de controle √© muito semelhante ao que o compilador C produzir√° a partir de um programa estruturado.  O c√≥digo para pular a √∫ltima rolagem apresenta uma nova instru√ß√£o <code>JMP abs</code> que leva 3 bytes.  Os saltos condicionais t√™m apenas dois bytes de comprimento, pois codificam endere√ßos de salto usando um operando de 8 bits relativo com endere√ßamento direto. <br><br>  O JMP para ‚Äúpular a √∫ltima rolagem‚Äù pode ser evitado movendo a chamada de rolagem para o topo do loop e alterando ligeiramente a estrutura do fluxo de controle.  Veja como Philip o implementou: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 scroll: jsr $e8ea xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf dec x1 ; doesn't set carry! inf: bmi inf ; hang here if last pixel! bcc xloop ; next pixel if no scroll bcs scroll ; scroll up and continue</code> </pre> <br>  Isso elimina completamente um JMP de tr√™s bytes e converte o outro JMP em uma ramifica√ß√£o condicional de dois bytes, economizando um total de 4 bytes. <br><br><h1>  Truque 6. Linhas com compress√£o de bits </h1><br>  Alguns elementos n√£o usam o contador de inclina√ß√£o de linha, mas compactam os bits em uma constante de 8 bits.  Essa embalagem √© baseada no fato de que a posi√ß√£o do pixel ao longo da linha corresponde a um padr√£o repetitivo de 8 pixels: <br><br><pre> <code class="plaintext hljs">int mask = 0xB6; // 10110110 uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xA0; if (mask &amp; (1 &lt;&lt; (x&amp;7))) { dst += 40; // go down a row } }</code> </pre> <br>  Isso se traduz em um montador bastante compacto.  No entanto, as op√ß√µes do contador de inclina√ß√£o s√£o geralmente ainda menores. <br><br><h3>  Vencedor </h3><br>  Aqui <a href="">est√° o programa vencedor do concurso de 34 bytes</a> de Philip.  A maioria dos truques acima funciona bem em seu c√≥digo: <br><br><pre> <code class="plaintext hljs">ov = $22 ; == $40, initial value for the overflow counter ct = $D5 ; == $27 / 39, number of passes. Decrementing, finished at -1 lp = $D1 ; == $07C0, pointer to bottom line. Set by the kernal scroller ; Overwrite the return address of the kernal loader on the stack ; with a pointer to our own code * = $01F8 .word scroll - 1 scroll: jsr $E8EA ; Kernal scroll up, also sets lp pointer to $07C0 loop: ldy ct ; Load the decrementing counter into Y (39 &gt; -1) lda #$A0 ; Load the PETSCII block / black col / ov step value sta $D020, y ; On the last two passes, sets the background black p1: sta $07C0 ; Draw first block (left &gt; right line) sta (lp), y ; Draw second block (right &gt; left line) inc p1 + 1 ; Increment pointer for the left &gt; right line adc ov ; Add step value $A0 to ov sta ov dec ct ; Decrement the Y counter bmi * ; If it goes negative, we're finished bcc loop ; Repeat. If ov didn't overflow, don't scroll bcs scroll ; Repeat. If ov overflowed, scroll</code> </pre> <br><h3>  Mas por que insistir em 34 bytes? </h3><br>  Assim que o concurso terminou, todos compartilharam seu c√≥digo e anota√ß√µes - e uma s√©rie de discuss√µes animadas ocorreu sobre como melhor√°-lo ainda mais.  Ap√≥s o prazo, v√°rias outras op√ß√µes foram apresentadas: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filipe - 33 bytes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Felipe - 32 bytes</a> <br></li><li>  <a href="">Petri - 31 bytes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filipe - 29 bytes</a> </li></ul><br>  Certifique-se de olhar - existem v√°rias p√©rolas reais. <br><br><hr><br>  Obrigado pela leitura.  E um agradecimento especial a Matlev, Phil, Geir, Petri, Jamie, Ian e David pela participa√ß√£o (espero n√£o ter sentido falta de ningu√©m - foi realmente dif√≠cil rastrear todas as men√ß√µes no Twitter!) <br><br>  O PS Petri chamou meu concurso de "anual", ent√£o provavelmente te vejo no pr√≥ximo ano. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464377/">https://habr.com/ru/post/pt464377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464367/index.html">E outro escalonamento de privil√©gios locais no cliente Windows Steam 0 dia</a></li>
<li><a href="../pt464369/index.html">Qual bloqueador voc√™ usa? Resultados</a></li>
<li><a href="../pt464371/index.html">/etc/resolv.conf para os pods do Kubernetes, op√ß√£o ndots: 5, pois isso pode afetar adversamente o desempenho do aplicativo</a></li>
<li><a href="../pt464373/index.html">Edge-to-edge no Android: fazendo certo</a></li>
<li><a href="../pt464375/index.html">Como os mecanismos de pesquisa funcionam</a></li>
<li><a href="../pt464381/index.html">Viagem ao Alasca ou KDD'19 atrav√©s dos olhos de uma testemunha ocular</a></li>
<li><a href="../pt464383/index.html">Como eu coloco as coisas em ordem em um projeto em que h√° uma floresta de m√£os diretas (configura√ß√µes tslint, mais bonitas, etc.)</a></li>
<li><a href="../pt464385/index.html">Python como o caso final de C ++. Parte 1/2</a></li>
<li><a href="../pt464387/index.html">Pegada russa na saga escandinava dos videogames, terminando</a></li>
<li><a href="../pt464391/index.html">10 relat√≥rios interessantes de confer√™ncias de hackers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>