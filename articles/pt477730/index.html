<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💘 🎠 🏝️ ChipWhisperer: ataque de energia no magma 🤗 👨🏻‍🔬 👩🏿‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Postado por rakf 





 Como parte do verão do Hack 2019 na Digital Security, lidei com um ataque de energia e trabalhei com o ChipWhisperer. 
 O que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ChipWhisperer: ataque de energia no magma</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/477730/"><p>  Postado por <a href="https://habr.com/ru/users/rakf/" class="user_link">rakf</a> </p><br><p><img src="https://habrastorage.org/webt/t1/qx/44/t1qx44fuppd2dlfmn-vvb6fsriq.jpeg"></p><br><p>  Como parte do verão do Hack 2019 na Digital Security, lidei com um ataque de energia e trabalhei com o ChipWhisperer. </p><br><h2 id="chto-eto">  O que é isso </h2><br><p>  A análise de energia é um tipo de ataque através de canais de terceiros.  Ou seja, ataques que usam informações que aparecem como resultado da implementação física do sistema. </p><br><p>  Quais informações podem ser úteis para um invasor: </p><br><ul><li>  tempo de conversão criptográfica; </li><li>  consumo de energia; </li><li>  campos eletromagnéticos; </li><li>  barulho etc. </li></ul><br><p>  Um ataque de energia é considerado o mais universal. </p><a name="habracut"></a><br><h2 id="pochemu-rabotaet">  Por que isso funciona? </h2><br><p>  Microprocessadores, microcontroladores, RAM e muitos outros circuitos lógicos são baseados na tecnologia CMOS.  O consumo de energia dos circuitos CMOS consiste em dois componentes: estático e dinâmico.  O consumo de energia estática é muito pequeno, o que é uma das razões da monopolização da tecnologia.  A potência dinâmica é devida à comutação de transistores e depende dos dados processados ​​e das operações executadas.  Como o componente estático é principalmente constante, a mudança na potência total é devida exclusivamente à energia dinâmica e, portanto, o consumo total de energia pode ser usado para análise. </p><br><h2 id="instrumentariy">  Toolkit </h2><br><p>  <a href="https://newae.com/tools/chipwhisperer/">ChipWhisperer</a> , usei a versão em duas partes: </p><br><p><img src="https://habrastorage.org/webt/56/p3/p4/56p3p4nq89l3drktqn9c0eo1mta.jpeg" alt="Versão em 2 Partes ChipWhisperer"></p><br><p>  O ChipWhisperer é um kit de ferramentas de código aberto para pesquisar a segurança de dispositivos incorporados.  Permite análise de energia e ataques baseados em erros. </p><br><p>  A taxa vai custar US $ 250.  Os desenvolvedores a posicionam como uma solução revolucionária, porque esses complexos, segundo os criadores, custam US $ 30 mil.  O dispositivo consiste em 2 placas: placa de captura e alvo. </p><br><p>  Existem outras versões, com suas vantagens (mas também com um grande custo), você também pode comprar separadamente várias placas de destino, placas de expansão, sondar para uma análise completa de seus dispositivos e usar o ChipWhisperer apenas para remoção. </p><br><p>  O ChipWhisperer possui um <a href="https://wiki.newae.com/Main_Page">wiki</a> excelente, pequenos <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials.html">laboratórios de</a> desenvolvimento e, na 5ª versão, eles até fizeram uma boa <a href="https://chipwhisperer.readthedocs.io/en/latest/api.html">documentação da</a> API.  As faixas são removidas do dispositivo conectado usando seu software e gravadas como uma matriz NumPy. </p><br><p>  Primeiro você precisa escrever o firmware para o dispositivo de destino.  Como parte do laboratório, as cifras AES, DES, TEA são consideradas.  Para eles, já existem firmware e configurações prontos para remover rastreamentos (o número de amostras a serem coletadas, deslocamento, frequência ADC, etc.).  Para pesquisas independentes, as configurações deverão ser selecionadas experimentalmente. </p><br><p>  Como mencionado acima, você pode provocar uma falha no quadro de destino: causando um mau funcionamento do sinal do relógio, pular instruções e extrair informações secretas. </p><br><p>  Em grandes complexos, um osciloscópio é usado para rastrear trilhas. </p><br><h2 id="analiz">  Análise </h2><br><p>  Existem vários métodos básicos de análise: </p><br><ul><li>  análise simples de energia (SPA); </li><li>  análise de potência diferencial (DPA); </li><li>  análise de correlação de potência (CPA). </li></ul><br><p> Uma simples análise de potência inclui uma análise visual do gráfico de potência.  Por exemplo, uma senha pode ser obtida com um caractere de cada vez, observando o perfil de potência quando o caractere correto é inserido e comparando com o errado. </p><br><p><img src="https://habrastorage.org/webt/ep/rf/tg/eprftggxt26idk5tq4uccp3p9kq.png" alt="Análise de poder da senha"></p><br><p>  Ou você pode ver as rodadas de criptografia nas faixas.  Não há dados suficientes para obter uma chave, mas pode-se assumir qual algoritmo é executado.  A figura mostra claramente 10 rodadas de AES. </p><br><p><img src="https://habrastorage.org/webt/ib/pl/e7/ibple7hxooxtxb1bkah2d1k-i_s.png" alt="AES SPA"></p><br><p>  A análise diferencial (DPA) é muito mais eficiente do que a análise simples, baseada em métodos de análise estatística para detectar diferenças nos traços de energia.  Uma ferramenta muito eficaz, no entanto, para "abrir" a chave exigirá um grande número de rotas.  Não usei esse método para análise, mas no final darei alguns links para fontes onde é bem descrito. </p><br><p>  A base da análise de correlação é um aparato estatístico para determinar a chave de criptografia secreta.  Às vezes, é isolado em um tipo separado, às vezes chamado de DPA.  Este método requer menos traços do que o DPA, usei-o para análise de energia.  Vou lhe contar mais sobre isso. </p><br><p>  A principal tarefa é construir um modelo preciso de consumo de energia do dispositivo em estudo.  Se um modelo preciso for construído, há uma correlação perceptível entre o valor previsto e o real. </p><br><p>  Um dos modelos de potência que pode ser usado é o modelo de peso de Hamming.  O peso de Hamming é o número de valores diferentes de zero na representação binária.  A suposição deste modelo é que o número de bits definido no registro se correlacionará com a energia consumida pelo dispositivo.  O próprio peso de Hamming é usado posteriormente como uma unidade convencional de energia.  O modelo de distância de Hamming também é usado - o número de bits diferentes em 2 valores. </p><br><p>  Para comparar o modelo de peso de Hamming e o consumo real de energia, é usado um coeficiente linear de Pearson.  Mostra a dependência linear de uma quantidade em outra.  Com um modelo construído corretamente, esse coeficiente tenderá a 1. </p><br><p>  O algoritmo de CPA generalizado consiste nas seguintes etapas principais: </p><br><ul><li>  remova o consumo de energia ao converter mensagens em uma chave desconhecida; </li><li>  construímos um modelo de consumo de energia do chip ao converter as mesmas mensagens em todas as variantes possíveis do sub-bloco de chaves (256 opções para cada byte); </li><li>  encontramos o coeficiente de correlação linear para o consumo de energia simulado e real.  No caso de uma chave verdadeira, o coeficiente tenderá a 1; </li><li>  o algoritmo é repetido para os sub-blocos de chaves restantes. </li></ul><br><p>  Como resultado, a chave é restaurada sequencialmente, em pequenas partes.  Se atacarmos um byte da chave de cada vez, usaremos 2 <sup>8</sup> tentativas para cada chave.  Por exemplo, se você escolher AES - 128, o número total de tentativas para 16 bytes da chave será 2 <sup>12</sup> , o que é muito melhor do que pressionar 2 <sup>128</sup> . </p><br><h3 id="analiz-shifra-magma">  Análise de Cifras de Magma </h3><br><p>  Magma é um código definido no GOST R 34.12-2015, na verdade o mesmo GOST 28147-89, apenas no perfil.  O bloco criptografado passa por 32 rodadas nas quais ocorrem algumas transformações.  A chave consiste em 256 bits, cada tecla redonda faz parte do original. </p><br><p><img src="https://habrastorage.org/webt/il/lf/jg/illfjg84nei10xf2xgboiifkmjy.png" alt="Função Feistel GOST"></p><br><p>  Analisaremos os dados obtidos usando o método CPA. </p><br><p>  Primeiro, você precisa escolher um valor intermediário do algoritmo, que depende dos dados conhecidos e de uma pequena parte da chave e pode ser calculado por transformações simples.  Normalmente, esse valor é a saída da caixa S (o Magma agora possui 1 tabela de substituição, portanto, é mais fácil realizar esses ataques) do primeiro (textos abertos são conhecidos) ou da última rodada (textos cifrados são conhecidos). </p><br><p>  Eu pesquisei uma chave com textos abertos bem conhecidos, portanto essa opção será considerada mais adiante.  No algoritmo Magma, ao contrário do DES, AES, a adição de um bloco de 32 bits com uma chave redonda ocorre no módulo 2 <sup>32</sup> , portanto, é melhor iniciar a análise a partir das últimas saídas S-box, pois a adição dos valores mais altos não afeta os mais novos.  Consideramos a saída de cada caixa S: primeiro 8, depois 8, 7 e assim sucessivamente até o primeiro.  A remoção da faixa foi realizada em um microcontrolador de 8 bits e podemos assumir que funcionou com duas caixas S.  Portanto, atacarei imediatamente por 1 byte. </p><br><p>  Cálculo do modelo de energia para o último byte chave: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> kguess <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>): <span class="hljs-comment"><span class="hljs-comment">#Initialize arrays &amp; variables to zero sumnum = np.zeros(numpoint) sumden1 = np.zeros(numpoint) sumden2 = np.zeros(numpoint) hyp = np.zeros(numtraces) for tnum in range(numtraces): hyp[tnum] = HW[leak("Gost28147_tc26_ParamZ", kguess, block2ns(text[tnum])[0], 0)]</span></span></code> </pre> <br><p>  onde a função de vazamento simplesmente retorna a saída S-box do último byte. </p><br><p>  Calculamos o coeficiente linear de Pearson para os valores simulados e reais de acordo com a fórmula: </p><br><p><img src="https://habrastorage.org/webt/yt/wd/f-/ytwdf-ah0p0fshbi-i83_tldkvs.png" alt="Correlação"></p><br><pre> <code class="python hljs"> cpaoutput = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*<span class="hljs-number"><span class="hljs-number">256</span></span> maxcpa = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*<span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-comment"><span class="hljs-comment">#Mean of hypothesis meanh = np.mean(hyp, dtype=np.float64) #Mean of all points in trace meant = np.mean(traces, axis=0, dtype=np.float64) #For each trace, do the following for tnum in range(0, numtraces): hdiff = (hyp[tnum] - meanh) tdiff = traces[tnum,:] - meant sumnum = sumnum + (hdiff*tdiff) sumden1 = sumden1 + hdiff*hdiff sumden2 = sumden2 + tdiff*tdiff cpaoutput[kguess] = sumnum / np.sqrt( sumden1 * sumden2 ) maxcpa[kguess] = max(abs(cpaoutput[kguess]))</span></span></code> </pre> <br><p>  Ao escolher uma subchave verdadeira, o coeficiente de correlação terá um aumento significativo: </p><br><p><img src="https://habrastorage.org/webt/8o/7j/8z/8o7j8zrfxosgutb_eymflrxxhp0.png" alt="Correlação1"></p><br><p>  Assim, cada byte da chave redonda é analisado. </p><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> bnum <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>): cpaoutput = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*<span class="hljs-number"><span class="hljs-number">256</span></span> maxcpa = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*<span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> kguess <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>): best_round_key = kguess &lt;&lt; (bnum * <span class="hljs-number"><span class="hljs-number">8</span></span>) | best_round ...</code> </pre> <br><p>  Dada a chave da primeira rodada, podemos calcular as 2 e as chaves da rodada subsequentes da mesma maneira.  Uma chave Magma completa pode ser obtida retirando 8 teclas redondas. </p><br><p>  No processo de solução desse problema, várias nuances surgem.  Ao contrário de AES, DES, cifras Grasshopper, a adição de uma chave redonda em texto simples ocorre no módulo 2 <sup>32</sup> .  A adição de bits baixos afeta o alto, ao contrário do XORa.  Ao calcular cada subchave subseqüente, você deve considerar os resultados do passado.  Da mesma forma com as teclas redondas.  Os dados são muito sensíveis.  Se um dos valores for calculado incorretamente, o cálculo adicional da chave inteira estará incorreto. </p><br><p>  Também vale a pena considerar que agora é bastante difícil encontrar um chip com arquitetura de quatro bits: a maioria dos chips possui oito bits.  Obviamente, existem chips criptográficos especializados, projetados para um algoritmo de conversão de segurança específico (ou vários algoritmos) e com a arquitetura mais eficiente. </p><br><p>  Para executar a cifra DES, esse criptoprocessador pode ter uma arquitetura de seis bits para o Magma - uma de quatro bits, que permite que cada caixa S seja processada separadamente.  Meu dispositivo de destino é de 8 bits e, no caso de "Magma", a conversão será realizada em oito bits em uma abordagem, ou seja,  a substituição ocorrerá na caixa 2 S, o consumo de energia será considerado na caixa 2 S.  Se uma das caixas S, sênior ou junior, corresponder à chave verdadeira e a outra não corresponder, poderão ocorrer altas explosões de correlação. </p><br><p>  Diante de tudo isso, na saída, temos o seguinte script para a análise dos caminhos de consumo de energia para a cifra Magma: </p><br><div class="spoiler">  <b class="spoiler_title">Script Python</b> <div class="spoiler_text"><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np path = <span class="hljs-string"><span class="hljs-string">r'C:\Users\user\chipwhisperer\projects\gost_10000_2_data\traces\2019.08.11-19.53.25_'</span></span> traces = np.load(path + <span class="hljs-string"><span class="hljs-string">'traces.npy'</span></span>) text = np.load(path + <span class="hljs-string"><span class="hljs-string">'textin.npy'</span></span>) keys = np.load(path + <span class="hljs-string"><span class="hljs-string">'keylist.npy'</span></span>) HW = [bin(n).count(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">256</span></span>)] SBOXES = {<span class="hljs-string"><span class="hljs-string">"Gost28147_tc26_ParamZ"</span></span>: ( (<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>), (<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>), (<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), )} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_K</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, _in)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" S-box substitution :param s: S-box :param _in: 32-bit word :returns: substituted 32-bit word """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( (s[<span class="hljs-number"><span class="hljs-number">0</span></span>][(_in &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) + (s[<span class="hljs-number"><span class="hljs-number">1</span></span>][(_in &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + (s[<span class="hljs-number"><span class="hljs-number">2</span></span>][(_in &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + (s[<span class="hljs-number"><span class="hljs-number">3</span></span>][(_in &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">12</span></span>) + (s[<span class="hljs-number"><span class="hljs-number">4</span></span>][(_in &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) + (s[<span class="hljs-number"><span class="hljs-number">5</span></span>][(_in &gt;&gt; <span class="hljs-number"><span class="hljs-number">20</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) + (s[<span class="hljs-number"><span class="hljs-number">6</span></span>][(_in &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) + (s[<span class="hljs-number"><span class="hljs-number">7</span></span>][(_in &gt;&gt; <span class="hljs-number"><span class="hljs-number">28</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">28</span></span>) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">block2ns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Convert block to N1 and N2 integers """</span></span> data = bytearray(data) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( data[<span class="hljs-number"><span class="hljs-number">7</span></span>] | data[<span class="hljs-number"><span class="hljs-number">6</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> | data[<span class="hljs-number"><span class="hljs-number">5</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | data[<span class="hljs-number"><span class="hljs-number">4</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>, data[<span class="hljs-number"><span class="hljs-number">3</span></span>] | data[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> | data[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | data[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>, ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addmod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, mod=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ** </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Modulo adding of two integers """</span></span> r = x + int(y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r &lt; mod <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> r - mod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_shift11</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" 11-bit cyclic shift """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((x &lt;&lt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; (<span class="hljs-number"><span class="hljs-number">2</span></span> ** <span class="hljs-number"><span class="hljs-number">32</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>)) | ((x &gt;&gt; (<span class="hljs-number"><span class="hljs-number">32</span></span> - <span class="hljs-number"><span class="hljs-number">11</span></span>)) &amp; (<span class="hljs-number"><span class="hljs-number">2</span></span> ** <span class="hljs-number"><span class="hljs-number">32</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sbox, key, data, byte)</span></span></span><span class="hljs-function">:</span></span> s = SBOXES[sbox] _in = addmod(data, key) sbox_leak = _K(s, _in); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (sbox_leak &gt;&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span> * byte)) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Feistel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sbox, key, data, nround)</span></span></span><span class="hljs-function">:</span></span> s = SBOXES[sbox] w = bytearray(key) x = [ w[<span class="hljs-number"><span class="hljs-number">3</span></span> + i * <span class="hljs-number"><span class="hljs-number">4</span></span>] | w[<span class="hljs-number"><span class="hljs-number">2</span></span> + i * <span class="hljs-number"><span class="hljs-number">4</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> | w[<span class="hljs-number"><span class="hljs-number">1</span></span> + i * <span class="hljs-number"><span class="hljs-number">4</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | w[<span class="hljs-number"><span class="hljs-number">0</span></span> + i * <span class="hljs-number"><span class="hljs-number">4</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>) ] n1, n2 = block2ns(data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(nround): n1, n2 = _shift11(_K(s, addmod(n1, x[i]))) ^ n2, n1 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n1 numtraces = len(traces) numpoint = np.shape(traces)[<span class="hljs-number"><span class="hljs-number">1</span></span>] bestguess = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*<span class="hljs-number"><span class="hljs-number">32</span></span> round_data = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * numtraces <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(numtraces): round_data[i] = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rnum <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>): best_round = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> tnum_r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(numtraces): round_data[tnum_r][rnum] = Feistel(<span class="hljs-string"><span class="hljs-string">"Gost28147_tc26_ParamZ"</span></span>, bestguess, text[tnum_r], rnum) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> bnum <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>): cpaoutput = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*<span class="hljs-number"><span class="hljs-number">256</span></span> maxcpa = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*<span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> kguess <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>): <span class="hljs-comment"><span class="hljs-comment">#Initialize arrays &amp; variables to zero best_round_key = kguess &lt;&lt; (bnum * 8) | best_round sumnum = np.zeros(numpoint) sumden1 = np.zeros(numpoint) sumden2 = np.zeros(numpoint) hyp = np.zeros(numtraces) for tnum in range(numtraces): hyp[tnum] = HW[round("Gost28147_tc26_ParamZ", best_round_key, round_data[tnum][rnum], bnum)] #Mean of hypothesis meanh = np.mean(hyp, dtype=np.float64) #Mean of all points in trace meant = np.mean(traces, axis=0, dtype=np.float64) #For each trace, do the following for tnum in range(0, numtraces): hdiff = (hyp[tnum] - meanh) tdiff = traces[tnum,:] - meant sumnum = sumnum + (hdiff*tdiff) sumden1 = sumden1 + hdiff*hdiff sumden2 = sumden2 + tdiff*tdiff cpaoutput[kguess] = sumnum / np.sqrt( sumden1 * sumden2 ) maxcpa[kguess] = max(abs(cpaoutput[kguess])) best_round = best_round | (np.argmax(maxcpa) &lt;&lt; (bnum * 8)) bestguess[((rnum + 1) * 4)-bnum - 1] = np.argmax(maxcpa) print "Best Key Guess: " for b in bestguess: print "%02x "%b,</span></span></code> </pre> </div></div><br><p>  <a href="https://github.com/rakf/ChipWhisperer/tree/master/GOST">Repositório de Resultados do GitHub</a> </p><br><h2 id="vyvody">  Conclusões </h2><br><p>  Como parte do estudo, trabalhei com o ChipWhisperer.  Apesar de não ter experimentado todas as ferramentas (por exemplo, falhas), definitivamente considero o ChipWhisperer útil, especialmente se você não deseja comprar hardware especial caro. </p><br><p>  Quanto à análise de nossa cifra para consumo de energia, ela é mais resistente a esse ataque do que as cifras descritas acima, mas com dados suficientes, a chave pode ser obtida sem problemas. </p><br><p>  Materiais interessantes: </p><br><ul><li>  Análise de Potência Diferencial P. Kocher </li><li>  "Ataques de análise de energia: revelando os segredos dos cartões inteligentes" </li><li>  <a href="https://xakep.ru/2015/01/29/crypto-i-keys/">Criptografia na mira da arma I: procurando chaves de algoritmos criptográficos</a> R. Korkikyan. </li><li>  <a href="https://xakep.ru/2015/01/27/kriptogry-191/">Criptografia na mira da arma II: análise nutricional diferencial</a> R. Korkikyan. </li><li>  <a href="https://xakep.ru/2015/01/27/kriptogry-191/">Relatório com ZeroNights 2014</a> R. Korkikyan. </li><li>  <a href="http://2014.zeronights.org/assets/files/slides/cryptocodingv2.pdf">cryptocoding v2</a> com ZeroNights 2014 sobre implementação de software. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt477730/">https://habr.com/ru/post/pt477730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt477716/index.html">Os matemáticos que usam o exemplo de "tag" calculam como a aleatoriedade ocorre</a></li>
<li><a href="../pt477718/index.html">Camada convolucional: convolução rápida de acordo com o método de Shmuel Vinograd</a></li>
<li><a href="../pt477722/index.html">Guia de estilo do Google em C ++. Parte 8</a></li>
<li><a href="../pt477724/index.html">Marca de RH habraseminar: sobre talentos, caça e conteúdo</a></li>
<li><a href="../pt477728/index.html">O que fazer liderar a equipe para que ela não se queime</a></li>
<li><a href="../pt477732/index.html">Classificação errada dos dedos dos sistemas de navegação subaquática</a></li>
<li><a href="../pt477734/index.html">Compreendendo o UICollectionViewLayout com o aplicativo Fotos</a></li>
<li><a href="../pt477736/index.html">O caminho do testador: do "freio de mão" à automação</a></li>
<li><a href="../pt477738/index.html">iKassa ou como domamos o "caixa digital"</a></li>
<li><a href="../pt477740/index.html">E onde olhar para este telescópio com o olho?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>