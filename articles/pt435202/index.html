<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏼 👨🏿‍🤝‍👨🏼 🔁 Escrevemos nossa linguagem de programação, parte 1: escrevemos uma linguagem VM 🤜🏼 👩🏾‍💻 ⏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdução 
 Bom dia a todos habrachitateli! 

 Então, talvez valha a pena dizer que o objetivo do meu trabalho, com base no qual várias estátuas s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escrevemos nossa linguagem de programação, parte 1: escrevemos uma linguagem VM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435202/"><h3>  1. Introdução </h3><br>  Bom dia a todos habrachitateli! <br><br>  Então, talvez valha a pena dizer que o objetivo do meu trabalho, com base no qual várias estátuas serão escritas, era criar um YP totalmente funcional a partir de 0 e depois compartilhar meu conhecimento, melhores práticas e experiência com aqueles que estão interessados. <br><br>  Vou descrever a criação da linguagem que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descrevi anteriormente aqui</a> . <br><br>  Ele interessou muitos e provocou uma discussão acalorada nos comentários.  Portanto - o tópico é interessante para muitos. <br><br>  Acho que vale a pena postar imediatamente informações sobre o projeto: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Site</a> (será preenchido com a documentação um pouco mais tarde). <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Repositório</a> <br><br>  Para tocar no projeto você mesmo e ver tudo em ação, é melhor baixar o repositório e executar tudo da pasta bin.  No lançamento, não tenho pressa em carregar as versões mais recentes do idioma e do tempo de execução, porque  às vezes é muito preguiçoso para eu fazer isso. <br><br>  Eu posso codificar em C / C ++ e Object Pascal.  Eu escrevi o projeto no FPC desde  na minha opinião, essa linguagem é muito mais simples e mais adequada para escrever assim.  O segundo fator determinante foi que o FPC suporta um grande número de plataformas de destino e é possível reconstruir um projeto para a plataforma desejada com um mínimo de alterações.  Se, por algum motivo, eu não gostar do Object Pascal, não se apresse em fechar a publicação e correr para atirar pedras no comentário.  Essa linguagem é muito bonita e intuitiva, mas não fornecerei tanto código.  Apenas o que você precisa. <br><br>  Então, talvez eu comece minha história. <br><a name="habracut"></a><br><h3>  Estabelecemos metas </h3><br>  Antes de tudo, qualquer projeto precisa de seus objetivos e do TK, que deverá ser implementado no futuro.  É necessário decidir com antecedência que tipo de idioma será criado para gravar a VM principal para ele. <br><br>  Os principais pontos que determinaram o desenvolvimento adicional da minha VM são os seguintes: <br><br><ul><li>  Digitação dinâmica e conversão de tipos.  Decidi organizar o apoio dela no estágio de desenvolvimento da VM. </li><li>  Suporte multithreading.  Eu incluí este item nesta lista antecipadamente, a fim de projetar adequadamente a arquitetura da VM e organizar o suporte para multithreading no nível principal da VM e, posteriormente, com muletas. </li><li>  Exportação de métodos externos.  Sem isso, a linguagem será inútil.  A menos que seja incorporado a qualquer projeto. </li><li>  Compilação do idioma (em um único arquivo executável abstrato).  Parcialmente compilado ou interpretado?  Muito depende disso. </li><li>  Arquitetura geral da VM.  A pilha ou o registro será nossa VM?  Eu tentei implementar isso e aquilo.  Eu escolhi uma VM empilhada para suporte. </li><li>  Como você vê o trabalho com variáveis, matrizes, estruturas?  Pessoalmente, naquele momento, eu queria implementar uma linguagem na qual quase tudo estivesse vinculado a indicadores implícitos, porque essa abordagem economizaria bastante memória e simplificaria a vida do desenvolvedor.  Se permitirmos que algo grande seja passado para os métodos, apenas um ponteiro para esse grande será automaticamente transferido. </li></ul><br>  Então, eu escolhi as prioridades acima e comecei a implementar a máquina virtual de idiomas.  Isso é estranho, é claro, geralmente todos os analisadores / tradutores são escritos primeiro e depois as VMs.  Bem, comecei a desenvolver o projeto nesta ordem e descreverei-o ainda mais na ordem em que o desenvolvi. <br><br>  Devo dizer imediatamente que chamei de VM o mais eloquente possível - SVM (Máquina Virtual Baseada em Pilha). <br><br><h3>  Vamos começar com a implementação da classe variável </h3><br>  Inicialmente, simplesmente usei um tipo de variante, porque é mais simples e rápido.  Era uma muleta, mas sustentou o projeto e me permitiu implementar rapidamente a primeira versão da VM e do idioma.  Mais tarde, sentei-me no código e escrevi uma implementação da minha "variante".  Em essência, você precisa escrever uma classe que armazene um ponteiro para um valor na memória, na minha implementação é <code>null/cardinal/int64/double/string/array</code> .  Pode-se usar a digitação de casos, mas achei que seria melhor implementar a maneira como implementei. <br><br>  Antes de começar a escrever o código da classe, decidi colocar imediatamente a diretiva {$ H +} no cabeçalho do módulo para oferecer suporte mais flexível a seqüências de caracteres no idioma futuro. <br><blockquote>  P.S.  para aqueles que podem não estar cientes da diferença entre os modos H e H + FPC. <br><br>  Ao montar o código no modo H, as strings serão apresentadas como uma matriz de caracteres.  Quando H + - como um ponteiro para um pedaço de memória.  No primeiro caso, as linhas serão inicialmente fixadas em comprimento e limitadas por padrão a 256 caracteres.  No segundo caso, as linhas serão dinamicamente expansíveis e muito mais caracteres poderão ser inseridos nelas.  Eles funcionarão um pouco mais devagar, mas com mais funcionalidade.  Com o H +, você também pode declarar cadeias de caracteres como uma matriz de caracteres, por exemplo, desta maneira: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[<span class="hljs-number"><span class="hljs-number">256</span></span>];</code> </pre></blockquote>  Portanto, para iniciantes, declararemos Enum um tipo, que usaremos como um determinado sinalizador para determinar o tipo de dados por ponteiro: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVMType = (svmtNull, svmtWord, svmtInt, svmtReal, svmtStr, svmtArr);</code> </pre><br>  A seguir, descrevemos a estrutura básica do nosso tipo de variável e alguns métodos: <br><br><pre> <code class="delphi hljs"> TSVMMem = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> m_val: pointer; m_type: TSVMType; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> m_val := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; m_type := svmtNull; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Clear; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtNull: <span class="hljs-comment"><span class="hljs-comment">{ nop }</span></span>; svmtWord: Dispose(PCardinal(m_val)); svmtInt: Dispose(PInt64(m_val)); svmtReal: Dispose(PDouble(m_val)); svmtStr: Dispose(PString(m_val)); svmtArr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(PMemArray(m_val)^, <span class="hljs-number"><span class="hljs-number">0</span></span>); Dispose(PMemArray(m_val)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  A classe não herda de nada, portanto, chamadas herdadas no construtor e destruidor podem ser omitidas.  Vou prestar atenção à diretiva em linha.  É melhor adicionar {$ inline on} ao cabeçalho do arquivo, com certeza.  Seu uso ativo em VMs aumentou significativamente a produtividade (Mb em algum lugar de 15 a 20%!).  Ela diz ao compilador que o corpo do método é melhor incorporado no local de sua invocação.  O código de saída será um pouco maior no final, mas funcionará mais rápido.  Nesse caso, é recomendável usar o inline. <br><br>  Ok, nesta fase, lavamos a base de nossa classe.  Agora precisamos descrever um número de setters e getters (setter &amp; getter) em nossa classe. <br><br>  A tarefa é escrever alguns métodos que permitirão empinar e depois recuperar os valores de nossa classe. <br><br>  Primeiro, vamos descobrir a atribuição de um valor para a nossa classe.  Primeiro, você pode escrever um setter generalizado e, em seguida, para tipos de dados individuais: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value; t:TSVMType)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = t) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: PCardinal(m_val)^ := Cardinal(value); svmtInt: PInt64(m_val)^ := Int64(value); svmtReal: PDouble(m_val)^ := Double(value); svmtStr: PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := t; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PCardinal(m_val)); PCardinal(m_val)^ := Cardinal(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PInt64(m_val)); PInt64(m_val)^ := Int64(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PDouble(m_val)); PDouble(m_val)^ := Double(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PString(m_val)); PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value:cardinal)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = svmtWord) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PCardinal(m_val)^ := value <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := svmtWord; New(PCardinal(m_val)); PCardinal(m_val)^ := value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Agora você pode escrever código para alguns getters: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetW</span></span></span><span class="hljs-function">:</span></span>cardinal; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: Result := PCardinal(m_val)^; svmtInt: Result := PInt64(m_val)^; svmtReal: Result := Trunc(PDouble(m_val)^); svmtStr: Result := StrToQWord(PString(m_val)^); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Ok, ótimo, agora que você passou algum tempo olhando para o IDE e digitando com entusiasmo o código de setters e getters, somos confrontados com a tarefa de implementar o suporte para nosso tipo de operações matemáticas e lógicas.  Como exemplo, darei a implementação da operação de adição: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m:TSVMMem)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetW(GetW + m.GetW); svmtInt: SetI(GetW + m.GetI); svmtReal: SetD(GetW + m.GetD); svmtStr: SetD(GetW + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetI(GetI + m.GetW); svmtInt: SetI(GetI + m.GetI); svmtReal: SetD(GetI + m.GetD); svmtStr: SetD(GetI + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetD(GetD + m.GetW); svmtInt: SetD(GetD + m.GetI); svmtReal: SetD(GetD + m.GetD); svmtStr: SetD(GetD + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetS(GetS + IntToStr(m.GetW)); svmtInt: SetS(GetS + IntToStr(m.GetI)); svmtReal: SetS(GetS + FloatToStr(m.GetD)); svmtStr: SetS(GetS + m.GetS); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Tudo é simples.  Outras operações podem ser descritas de maneira semelhante e agora nossa classe está pronta. <br>  Para matrizes, é claro, você ainda precisa de alguns métodos, um exemplo de obter um elemento pelo índice: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: cardinal; grabber:PGrabber)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtArr: Result := PMemArray(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TSVMMem.CreateFW(Ord(PString(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>])); grabber^.AddTask(Result); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Ótimo.  Agora podemos seguir em frente. <br><br><h3>  Percebemos uma pilha </h3><br>  Depois de um tempo, cheguei a esses pensamentos.  A pilha deve ser estática (para velocidade) e dinâmica (para flexibilidade) ao mesmo tempo. <br><br>  Portanto, a pilha é implementada em blocos.  I.e.  como deve funcionar - inicialmente a matriz da pilha tem um determinado tamanho (decidi definir o tamanho do bloco para 256 elementos, para que ficasse bonito e não pequeno).  Consequentemente, um contador é incluído na matriz, indicando a parte superior atual da pilha.  A realocação de memória é uma operação extra longa, que pode ser executada com menos frequência.  Se mais valores forem empurrados para a pilha, seu tamanho sempre poderá ser expandido para o tamanho de outro bloco. <br><br>  Trago toda a implementação da pilha: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TStack = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> items: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pointer; size, i_pos: cardinal; parent_vm: pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PStack = ^TStack; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; size := StackBlockSize; parent_vm := vm; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> items[i_pos] := p; inc(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i_pos &gt;= size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size + StackBlockSize; SetLength(items, size) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); Result := items[i_pos]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p := items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>] := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>] := p; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); size := StackBlockSize; i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Nos métodos externos, a VM passa um ponteiro para a pilha para que eles possam pegar os argumentos necessários a partir daí.  Um ponteiro para o fluxo da VM foi adicionado posteriormente, para que as chamadas de retorno de chamada de métodos externos pudessem ser implementadas e, em geral, para transferir mais energia sobre os métodos da VM. <br><br>  Então, como você se familiarizou com a organização da pilha.  A pilha de retorno de chamada é organizada da mesma maneira, para simplicidade e conveniência das operações de chamada e retorno e a pilha do coletor de lixo.  A única coisa são os outros tamanhos dos blocos. <br><br><h3>  Fale sobre lixo </h3><br>  Geralmente é muito, muito.  E você precisa fazer algo com isso. <br><br>  Antes de tudo, quero falar sobre como os coletores de lixo são organizados em outras linguagens, por exemplo, em Lua, Ruby, Java, Perl, PHP, etc.  Eles trabalham com o princípio de contar ponteiros para objetos na memória. <br><br>  I.e.  então alocamos memória para alguma coisa, é lógico - o ponteiro foi imediatamente colocado em uma variável / array / em outro lugar.  O coletor de lixo em tempo de execução imediatamente adiciona esse ponteiro a si mesmo com uma lista de possíveis objetos de lixo.  Em segundo plano, o coletor de lixo monitora constantemente todas as variáveis, matrizes etc.  Se não houver ponteiro para algo da lista de lixo possível, isso significa que o lixo e a memória dele devem ser removidos. <br><br>  Eu decidi vender minha bicicleta.  Estou mais acostumado a trabalhar com a memória no princípio de Taras Bulba.  Eu te dei à luz - quero matar você, quando eu ligar para o próximo Livre na próxima aula.  Portanto, o coletor de lixo da minha VM é semi-automático.  I.e.  ele precisa ser chamado no modo manual e trabalhar com ele de acordo.  Por sua vez, são adicionados indicadores para objetos temporários declarados (esse papel cabe principalmente ao tradutor e um pouco ao desenvolvedor).  Para liberar memória de outros objetos, você pode usar um código de operação separado. <br><br>  I.e.  o coletor de lixo no momento da chamada possui uma lista pronta de ponteiros que você precisa examinar e liberar memória. <br><br><h3>  Então, agora vamos lidar com a compilação em um arquivo executável abstrato </h3><br>  Originalmente, a idéia era que aplicativos escritos em meu idioma pudessem ser executados sem fonte, como é o caso de muitos idiomas semelhantes.  I.e.  pode ser usado para fins comerciais. <br><br>  Para fazer isso, determine o formato dos arquivos executáveis.  Eu tenho o seguinte: <br><br><ol><li>  Cabeçalho, por exemplo "SVMEXE_CNS". </li><li>  Uma seção que contém uma lista de bibliotecas das quais os métodos serão importados. </li><li>  A seção de importação dos métodos necessários, as bibliotecas das quais os métodos são importados são indicadas por seu número na seção acima. </li><li>  Seção de constantes. </li><li>  Seção de Código </li></ol><br>  Acho que não vale a pena definir as etapas detalhadas para implementar analisadores para essas seções, porque você pode ver tudo por si mesmo no meu repositório. <br><br><h3>  Execução de código </h3><br>  Após analisar as seções acima e inicializar a VM, temos uma seção com o código.  Na minha VM, um bytecode não alinhado é executado, ou seja,  as instruções podem ter comprimento arbitrário. <br><br>  Um conjunto de códigos de operação - instruções para uma máquina virtual com pequenos comentários, mostrados com antecedência abaixo: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TComand = ( <span class="hljs-comment"><span class="hljs-comment">{** for stack **}</span></span> bcPH, <span class="hljs-comment"><span class="hljs-comment">// [top] = [var] bcPK, // [var] = [top] bcPP, // pop bcSDP, // stkdrop bcSWP, // [top] &lt;-&gt; [top-1] {** jump's **} bcJP, // jump [top] bcJZ, // [top] == 0 ? jp [top-1] bcJN, // [top] &lt;&gt; 0 ? jp [top-1] bcJC, // jp [top] &amp; push callback point as ip+1 bcJR, // jp to last callback point &amp; rem last callback point {** for untyped's **} bcEQ, // [top] == [top-1] ? [top] = 1 : [top] = 0 bcBG, // [top] &gt; [top-1] ? [top] = 1 : [top] = 0 bcBE, // [top] &gt;= [top-1] ? [top] = 1 : [top] = 0 bcNOT, // [top] = ![top] bcAND, // [top] = [top] and [top-1] bcOR, // [top] = [top] or [top-1] bcXOR, // [top] = [top] xor [top-1] bcSHR, // [top] = [top] shr [top-1] bcSHL, // [top] = [top] shl [top-1] bcNEG, // [top] = -[top] bcINC, // [top]++ bcDEC, // [top]-- bcADD, // [top] = [top] + [top-1] bcSUB, // [top] = [top] - [top-1] bcMUL, // [top] = [top] * [top-1] bcDIV, // [top] = [top] / [top-1] bcMOD, // [top] = [top] % [top-1] bcIDIV, // [top] = [top] \ [top-1] bcMV, // [top]^ = [top-1]^ bcMVBP, // [top]^^ = [top-1]^ bcGVBP, // [top]^ = [top-1]^^ bcMVP, // [top]^ = [top-1] {** memory operation's **} bcMS, // memory map size = [top] bcNW, // [top] = @new bcMC, // copy [top] bcMD, // double [top] bcRM, // rem @[top] bcNA, // [top] = @new array[ [top] ] of pointer bcTF, // [top] = typeof( [top] ) bcSF, // [top] = sizeof( [top] ) {** array's **} bcAL, // length( [top] as array ) bcSL, // setlength( [top] as array, {stack} ) bcPA, // push ([top] as array)[top-1] bcSA, // peek [top-2] -&gt; ([top] as array)[top-1] {** memory grabber **} bcGPM, // add pointer to TMem to grabber task-list bcGC, // run grabber {** constant's **} bcPHC, // push copy of const bcPHCP, // push pointer to original const {** external call's **} bcPHEXMP, // push pointer to external method bcINV, // call external method bcINVBP, // call external method by pointer [top] {** for thread's **} bcPHN, // push null bcCTHR, // [top] = thread(method = [top], arg = [top+1]):id bcSTHR, // suspendthread(id = [top]) bcRTHR, // resumethread(id = [top]) bcTTHR, // terminatethread(id = [top]) {** for try..catch..finally block's **} bcTR, // try @block_catch = [top], @block_end = [top+1] bcTRS, // success exit from try/catch block bcTRR, // raise exception, message = [top] {** for string's **} bcSTRD, // strdel bcCHORD, bcORDCH, {** [!] directly memory operations **} bcALLC, //alloc memory bcRALLC, //realloc memory bcDISP, //dispose memory bcGTB, //get byte bcSTB, //set byte bcCBP, //mem copy bcRWBP, //read word bcWWBP, //write word bcRIBP, //read int bcWIBP, //write int bcRFBP, //read float bcWFBP, //write float bcRSBP, //read string bcWSBP, //write string bcTHREXT,//stop code execution bcDBP //debug method call );</span></span></code> </pre><br>  Portanto, você se familiariza fluentemente com as operações que a VM escrita por mim pode realizar.  Agora eu quero falar sobre como tudo funciona. <br><br>  Uma VM é implementada como um objeto, para que você possa implementar facilmente o suporte a multithreading. <br><br>  Possui um ponteiro para uma matriz com opcodes, IP (Instruction Pointer) - deslocamento da instrução executada e ponteiros para outras estruturas da VM. <br><br>  A execução de código é um grande caso de mudança. <br><br>  Basta fornecer uma descrição da VM: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVM = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ip, end_ip: TInstructionPointer; mainclasspath: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; mem: PMemory; stack: TStack; cbstack: TCallBackStack; bytes: PByteArr; grabber: TGrabber; consts: PConstSection; extern_methods: PImportSection; try_blocks: TTRBlocks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunThread</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b: TByteArr)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><h3>  Um pouco sobre o tratamento de exceções </h3><br>  Para fazer isso, a VM possui uma pilha de manipuladores de exceção e um grande bloco try / catch no qual a execução do código é quebrada.  Na pilha, é possível colocar uma estrutura que possui um deslocamento do ponto de entrada no bloco de tratamento de captura e finalmente / final de exceção.  Também forneci o ops trs, que é colocado antes da captura e lança o código para finalmente / final, se for bem-sucedido, excluindo simultaneamente o bloco com informações sobre manipuladores de exceção da parte superior da pilha correspondente.  Apenas?  Simples.  É conveniente?  Convenientemente. <br><br><h3>  Vamos falar sobre métodos e bibliotecas externas </h3><br>  Eu já os mencionei antes.  Importações, bibliotecas ... Sem elas, o idioma não terá a flexibilidade e a funcionalidade desejadas. <br><br>  Primeiramente, na implementação da VM, declaramos o tipo do método externo e o protocolo para chamá-lo. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TExternalFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PStack: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; PExternalFunction = ^TExternalFunction;</code> </pre><br>  Ao importar uma VM, o analisador de seção de importação preenche uma matriz de ponteiros para métodos externos.  Portanto, cada método tem um endereço estático, calculado no estágio de montagem do aplicativo na VM e pelo qual o método desejado pode ser chamado. <br><br>  A chamada ocorre posteriormente desta maneira durante a execução do código: <br><br><pre> <code class="delphi hljs">TExternalFunction(self.extern_methods^.GetFunc(TSVMMem(self.stack.popv).GetW))(@self.stack);</code> </pre><br><h3>  Vamos escrever uma biblioteca simples para nossa VM </h3><br>  E deixe-a primeiro implementar o método Sleep: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> bf; <span class="hljs-meta"><span class="hljs-meta">{$mode objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, svm_api <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'..\svm_api.pas'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DSleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stack:PStack)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sleep(TSVMMem(Stack^.popv).GetW); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> DSleep <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'SLEEP'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br><h3>  Sumário </h3><br>  Provavelmente, terminarei meu primeiro artigo de um ciclo concebido. <br><br>  Hoje descrevi a criação do idioma runtime com alguns detalhes.  Acredito que este artigo será muito útil para pessoas que decidem tentar escrever sua própria linguagem ou entender como funcionam linguagens de programação semelhantes. <br><br>  O código completo da VM está disponível no repositório, na ramificação / runtime / svm. <br><br>  Se você gostou deste artigo, não tenha preguiça de dar uma vantagem no carma e elevá-lo no topo, tentei e tentarei por você. <br><br>  Se algo não estiver claro para você, bem-vindo aos comentários ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ao fórum</a> . <br><br>  Talvez suas perguntas e respostas sejam interessantes não apenas para você. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435202/">https://habr.com/ru/post/pt435202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435186/index.html">Rolls-Royce desenvolve o avião elétrico mais rápido do mundo</a></li>
<li><a href="../pt435190/index.html">O Google conseguiu retirar a tributação de US $ 22,7 bilhões através da Irlanda e Bermuda</a></li>
<li><a href="../pt435194/index.html">Simplifique a escrita do currículo de um desenvolvedor</a></li>
<li><a href="../pt435196/index.html">Pesquisadores aprovam ReCAPTCHA usando os serviços do Google</a></li>
<li><a href="../pt435198/index.html">Arduin e LED, ou como atualizar o designer infantil</a></li>
<li><a href="../pt435204/index.html">Recepção para que os desenvolvedores superem a procrastinação</a></li>
<li><a href="../pt435206/index.html">Europa aprova diretiva de direitos autorais - por que as plataformas de streaming se opõem</a></li>
<li><a href="../pt435208/index.html">Internet das coisas ... que choram por uma boa UI / UX</a></li>
<li><a href="../pt435210/index.html">O trabalho de Xamarin com o C SDK</a></li>
<li><a href="../pt435212/index.html">Como esquecer os cartões de visita em papel no ano novo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>