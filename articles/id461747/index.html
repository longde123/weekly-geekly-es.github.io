<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦆 🈚️ 👆 Bagaimana kami menerapkan ML dalam aplikasi dengan hampir 50 juta pengguna. Pengalaman Sberbank 👨🏽‍⚕️ 👍🏻 🌁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Nama saya Nikolai, dan saya terlibat dalam konstruksi dan implementasi model pembelajaran mesin di Sberbank. Hari ini saya akan berbicara ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami menerapkan ML dalam aplikasi dengan hampir 50 juta pengguna. Pengalaman Sberbank</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/461747/">  Halo, Habr!  Nama saya Nikolai, dan saya terlibat dalam konstruksi dan implementasi model pembelajaran mesin di Sberbank.  Hari ini saya akan berbicara tentang mengembangkan sistem rekomendasi untuk pembayaran dan transfer dalam aplikasi di ponsel cerdas Anda. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/358/23c/0f8/35823c0f8e513f268f58de291b8504c7.png"></a> <br>  <i>Desain layar utama aplikasi seluler dengan rekomendasi</i> <br><br>  Kami memiliki dua ratus ribu opsi pembayaran, 55 juta pelanggan, 5 sumber perbankan berbeda, setengah kolom pengembang dan segudang aktivitas perbankan, algoritme dan semua itu, semua warna, serta satu liter benih acak, sekotak hiperparameter, setengah liter faktor koreksi, dan dua puluhan perpustakaan.  Bukan berarti semua ini diperlukan dalam pekerjaan, tetapi karena ia mulai meningkatkan kehidupan klien, maka pergilah hobi Anda sampai akhir.  Di bawah potongan adalah kisah pertempuran untuk UX, perumusan masalah yang benar, perjuangan melawan dimensi data, kontribusi untuk open-source dan hasil kami. <br><br><a name="habracut"></a><br><h2>  Pernyataan masalah </h2><br>  Seiring perkembangan dan peningkatan, aplikasi Sberbank Online mendapatkan fitur yang bermanfaat dan fungsionalitas tambahan.  Secara khusus, dalam aplikasi Anda dapat mentransfer uang atau membayar layanan berbagai organisasi. <br><br>  “Kami dengan cermat melihat semua jalur pengguna di dalam aplikasi dan menyadari bahwa banyak di antaranya dapat dikurangi secara signifikan.  Untuk melakukan ini, kami memutuskan untuk mempersonalisasi layar utama dalam beberapa tahap.  Pertama, kami mencoba menghapus dari layar apa yang tidak digunakan klien, dimulai dengan kartu bank.  Kemudian mereka mengemukakan tindakan-tindakan yang sudah dilakukan klien sebelumnya dan untuk itu ia bisa masuk ke aplikasi sekarang.  Sekarang daftar tindakan termasuk pembayaran ke organisasi dan transfer ke kontak, maka daftar tindakan tersebut akan diperluas, ”kata kolega saya Sergey Komarov, yang mengembangkan fungsionalitas dari sudut pandang klien di tim Sberbank Online.  Penting untuk membangun model yang akan mengisi slot yang ditunjuk dalam widget Tindakan (gambar di atas) dengan rekomendasi pribadi tentang pembayaran dan transfer, bukan aturan sederhana. <br><br><h2>  Solusi </h2><br>  Kami di tim menguraikan tugas menjadi dua bagian: <br><br><ul><li>  rekomendasi pengulangan operasi untuk membayar layanan atau mentransfer dana (blok "Operasi yang disarankan") <br></li><li>  rekomendasi contoh permintaan pencarian untuk pembayaran untuk layanan yang sebelumnya tidak digunakan oleh klien ini (memblokir "Contoh Pencarian") <br></li></ul><br>  Kami memutuskan untuk menguji fungsionalitas terlebih dahulu pada tab pencarian: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fe/450/0ee/8fe4500ee0d612b4210a7237a643850b.png"></div><br>  <i>Desain Layar Pencarian yang Disarankan</i> <br><br><h2>  Operasi yang Disarankan </h2><br><h3>  Optimalisasi penilaian </h3><br>  Jika kami menetapkan subtugas sebagai rekomendasi untuk mengulangi operasi, ini memungkinkan kami untuk menyingkirkan perhitungan dan evaluasi triliunan kombinasi dari semua operasi yang mungkin untuk semua pelanggan dan fokus pada jumlah yang jauh lebih terbatas.  Jika, dari seluruh rangkaian operasi yang tersedia untuk klien kami, klien hipotetis dengan hasy YYY hanya menggunakan pembayaran untuk gas dan parkir, maka kami akan mengevaluasi kemungkinan mengulang hanya operasi ini untuk klien ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33f/d0e/415/33fd0e4159a1143ff54c6834c0cd964d.png"><br>  <i>Contoh mengurangi dimensi data untuk penilaian</i> <br><br><h3>  Mempersiapkan dataset </h3><br>  Sampel adalah observasi transaksional, diperkaya dengan faktor-faktor demografi klien, agregat keuangan dan berbagai karakteristik frekuensi operasi tertentu. <br><br>  Variabel target dalam kasus ini adalah biner dan mencerminkan fakta peristiwa pada hari setelah hari faktor-faktor dihitung.  Dengan demikian, secara iteratif menggerakkan hari menghitung faktor-faktor dan menetapkan bendera variabel target, kami melipatgandakan dan menandai operasi yang sama dan menandainya secara berbeda tergantung pada posisi relatif terhadap hari ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/929/618/c8a/929618c8a1fbcf3b2385300bf9669ae3.png"></div><br>  <i>Skema Pengamatan</i> <br><br>  Menghitung pemotongan pada 17/03/2019 untuk klien "YYY", kami mendapatkan dua pengamatan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78b/e70/741/78be707412f6a3fee92dcb5d62413de9.png"></div><br>  <i>Contoh pengamatan untuk dataset</i> <br><br>  "Fitur 1" dapat berarti, misalnya, keseimbangan pada semua kartu klien, "Fitur 2" - keberadaan jenis operasi ini dalam minggu terakhir. <br><br>  Kami melakukan transaksi yang sama, tetapi membentuk pengamatan untuk pelatihan pada tanggal yang berbeda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/901/c8e/618/901c8e6188d792bb9c77fc207f7d95d1.png"></div><br>  <i>Skema Pengamatan</i> <br><br>  Kami akan mendapatkan pengamatan untuk dataset dengan nilai lain dari kedua fitur dan variabel target: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e99/a4f/060/e99a4f0602c8c127f47aecee38f02292.png"><br>  <i>Contoh pengamatan untuk dataset</i> <br><br>  Dalam contoh di atas, untuk kejelasan, nilai aktual dari faktor diberikan, tetapi pada kenyataannya, nilai diproses oleh algoritma otomatis: hasil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konversi WOE</a> diumpankan ke input model.  Hal ini memungkinkan Anda untuk membawa variabel ke hubungan monoton dengan variabel target dan pada saat yang sama menyingkirkan efek pencilan.  Misalnya, kami memiliki faktor "Jumlah kartu" dan beberapa distribusi variabel target: <br><br><img src="https://habrastorage.org/webt/4z/vz/xt/4zvzxtz04cy0corijvcyz4zfhf0.png"><br><br>  <i>Contoh konversi WOE</i> <br><br>  Transformasi WOE memungkinkan kita untuk mengubah ketergantungan nonlinear menjadi setidaknya monotonik.  Setiap nilai faktor yang dianalisis dikaitkan dengan nilai WOE sendiri dan dengan demikian faktor baru terbentuk, dan yang asli dihapus dari dataset: <br><br><img src="https://habrastorage.org/webt/9j/os/o4/9joso4mjqdpris64sxtrb3ji34k.png"><br>  <i>Pengaruh transformasi WOE pada hubungan dengan variabel target</i> <br><br>  Kamus untuk mengonversi nilai variabel ke WOE disimpan dan digunakan nanti untuk penilaian.  Artinya, jika kita perlu menghitung probabilitas untuk besok, kita membuat dataset seperti pada tabel dengan contoh pengamatan di atas, mengubah variabel yang diperlukan menjadi WOE dengan kode yang disimpan, dan menerapkan model pada data ini. <br><br><h3>  Pelatihan </h3><br>  Pilihan metode sangat terbatas - interpretabilitas.  Oleh karena itu, untuk memenuhi tenggat waktu, diputuskan untuk menunda penjelasan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SHAP yang</a> sama di bagian kedua dari masalah dan menguji metode yang relatif sederhana: regresi dan neuron dangkal.  Alat itu adalah SAS Miner, perangkat lunak untuk preprocessing, menganalisis dan membangun model pada berbagai data dalam bentuk interaktif, yang menghemat banyak waktu dalam menulis kode. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ae/80d/b3c/1ae80db3c2741d5c70a2cbc9e48dd0ff.png"><br>  <i>Antarmuka SAS Miner</i> <br><br><h3>  Penilaian kualitas </h3><br>  Perbandingan metrik GINI pada sampel out-of-time menunjukkan bahwa jaringan saraf mengatasi tugas terbaik: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/553/e79/d24553e79a193415b2fa94c6e3b0d987.png"></div><br>  <i>Tabel perbandingan model kualitas dan aturan frekuensi</i> <br><br>  Model memiliki dua titik keluar.  Rekomendasi dalam bentuk kartu widget di layar utama termasuk operasi yang perkiraannya di atas ambang batas tertentu (lihat gambar pertama di pos).  Perbatasan dipilih berdasarkan keseimbangan kualitas dan jangkauan, yang dalam arsitektur semacam itu adalah setengah dari semua operasi yang dilakukan.  Operasi 4 besar dikirim ke blok "operasi yang direkomendasikan" pada layar pencarian (lihat gambar kedua). <br><br><h2>  Contoh Pencarian </h2><br>  Beralih ke bagian kedua dari tugas, kami kembali ke masalah sejumlah besar opsi pembayaran yang mungkin untuk layanan penyedia yang perlu dievaluasi dan disortir dalam setiap klien - triliunan pasangan.  Selain itu, kami memiliki data tersirat, yaitu, tidak ada informasi tentang penilaian pembayaran yang dilakukan, atau mengapa klien tidak melakukan pembayaran apa pun.  Oleh karena itu, sebagai permulaan, diputuskan untuk menguji berbagai metode memperluas matriks pembayaran dari pelanggan ke penyedia: ALS dan FM. <br><br><h3>  ALS </h3><br>  ALS (Alternating Least Squares) atau Alternating Least Squares - dalam penyaringan kolaboratif, salah satu metode untuk memecahkan masalah faktorisasi dari matriks interaksi.  Kami akan menyajikan data transaksional kami tentang pembayaran layanan dalam bentuk matriks di mana kolom adalah pengidentifikasi unik dari semua layanan penyedia, dan baris adalah pelanggan unik.  Dalam sel kami menempatkan jumlah operasi klien tertentu dengan penyedia spesifik untuk periode waktu tertentu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/430/fcd/db7/430fcddb7494ed4ba54411d0423b5b16.png"><br>  <i>Prinsip dekomposisi matriks</i> <br><br>  Arti dari metode ini adalah kita membuat dua matriks dengan dimensi yang lebih rendah, perkalian yang memberikan hasil terdekat dengan matriks besar asli dalam sel yang diisi.  Model belajar untuk membuat deskripsi faktorial tersembunyi untuk pelanggan dan penyedia.  Implementasi metode di perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implisit</a> digunakan.  Pelatihan berlangsung sesuai dengan algoritma berikut: <br><br><ol><li>  Matriks klien dan penyedia dengan faktor tersembunyi diinisialisasi.  Jumlah mereka adalah hiperparameter model. <br></li><li>  Matriks faktor-faktor tersembunyi penyedia diperbaiki dan turunan dari fungsi kerugian untuk koreksi matriks klien dipertimbangkan.  Penulis menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode konjugasi gradien yang menarik</a> , yang memungkinkan Anda mempercepat langkah ini. <br></li><li>  Langkah sebelumnya diulangi sama untuk matriks faktor tersembunyi pelanggan. </li><li>  Langkah 2-3 bergantian sampai algoritma menyatu. </li></ol><br><h3>  Persiapan </h3><br>  Data transaksional ditransformasikan ke dalam matriks interaksi dengan tingkat kelangkaan ~ 99% dengan ketidakmerataan yang besar di antara penyedia.  Untuk memisahkan data menjadi sampel latih dan validasi, kami secara acak menutupi proporsi sel yang diisi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d60/d96/282/d60d96282aac1b7425ee0ea597253d66.png"><br>  <i>Contoh Berbagi Data</i> <br><br>  Transaksi diambil sebagai tes untuk periode waktu setelah pelatihan, dan ditata dalam matriks dengan format yang sama - ternyata out-of-time. <br><br><h3>  Pelatihan </h3><br>  Model ini memiliki beberapa hiperparameter yang dapat disesuaikan untuk meningkatkan kualitas: <br><br><ul><li>  Alpha adalah koefisien dengan mana matriks ditimbang, menyesuaikan tingkat kepercayaan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C_iu</a> ) bahwa layanan yang diberikan benar-benar "disukai" oleh klien. <br></li><li>  Jumlah faktor dalam matriks tersembunyi dari klien dan penyedia adalah jumlah kolom dan baris, masing-masing. <br></li><li>  Koefisien pengaturan L2 λ. <br></li><li>  Jumlah iterasi metode. <br></li></ul><br>  Kami menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hyperopt</a> , yang memungkinkan kami untuk mengevaluasi efek hyperparameter pada metrik kualitas menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TPE</a> dan memilih nilai optimalnya.  Algoritma dimulai dengan awal yang dingin dan membuat beberapa penilaian metrik kualitas tergantung pada nilai-nilai dari parameter yang dianalisis.  Kemudian, pada dasarnya, ia mencoba untuk memilih satu set nilai hyperparameters yang lebih cenderung memberikan nilai yang baik untuk metrik kualitas.  Hasilnya disimpan dalam kamus di mana Anda dapat membuat grafik dan mengevaluasi secara visual hasil pengoptimal (biru lebih baik): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa2/175/64a/fa217564a3f448a81abbbfad1d27f7a1.png"></div><br>  <i>Grafik ketergantungan metrik kualitas pada kombinasi hiperparameter</i> <br><br>  Grafik menunjukkan bahwa nilai-nilai hiperparameter sangat mempengaruhi kualitas model.  Karena perlu menerapkan rentang untuk masing-masing input ke metode, grafik selanjutnya dapat menentukan apakah masuk akal untuk memperluas ruang nilai atau tidak.  Sebagai contoh, dalam tugas kita jelas bahwa masuk akal untuk menguji nilai-nilai besar untuk sejumlah faktor.  Di masa depan, ini benar-benar meningkatkan model. <br><br><h3>  Metrik dan kompleksitas penilaian kualitas </h3><br>  Bagaimana cara mengevaluasi kualitas model?  Salah satu metrik yang paling umum digunakan untuk sistem rekomendasi di mana pesanan penting adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MAP @ k</a> atau Mean Average Precision di K. Metrik ini memperkirakan keakuratan model pada rekomendasi K, dengan mempertimbangkan urutan item dalam daftar rekomendasi ini rata-rata untuk semua pelanggan. <br><br>  Sayangnya, operasi penilaian kualitas bahkan pada sampel memakan waktu beberapa jam.  Setelah menyingsingkan lengan baju kami, kami mulai membuat profil fungsi mean_average_pecision_at_k () dengan pustaka line_profiler.  Tugas itu semakin rumit oleh fakta bahwa fungsi tersebut menggunakan kode cython dan harus diperhitungkan dengan benar, jika tidak, statistik yang diperlukan tidak dikumpulkan.  Akibatnya, kami kembali menghadapi masalah dimensi data kami.  Untuk menghitung metrik ini, Anda perlu mendapatkan beberapa perkiraan setiap layanan dari semua kemungkinan untuk setiap klien dan memilih rekomendasi pribadi top-K dengan mengurutkan dari array yang dihasilkan.  Bahkan mempertimbangkan penggunaan penyortiran parsial numpy.argpartition () dengan O (n) kompleksitas, menyortir nilai ternyata menjadi langkah terpanjang memperluas kualitas penilaian dari jam ke jam.  Karena numpy.argpartition () tidak menggunakan semua kernel di server kami, diputuskan untuk meningkatkan algoritme dengan menulis ulang bagian ini dalam C ++ dan OpenMP melalui cython.  Algoritma baru yang singkat adalah sebagai berikut: <br><br><ol><li>  Data dipotong-potong oleh pelanggan. <br></li><li>  Matriks kosong dan pointer ke memori diinisialisasi. <br></li><li>  String batch oleh pointer diurutkan dalam dua cara: oleh fungsi partial_sort dan kemudian urutkan berdasarkan pustaka algoritma C ++. <br></li><li>  Hasilnya ditulis ke sel-sel matriks kosong secara paralel. <br></li><li>  Data dikembalikan dalam python. <br></li></ol><br>  Ini memungkinkan kami untuk mempercepat perhitungan rekomendasi beberapa kali.  Revisi telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditambahkan</a> ke repositori resmi. <br><br><h2>  Analisis Hasil OOT </h2><br>  Dan sekarang saatnya untuk mengevaluasi kualitas model.  Mengapa kita perlu pengambilan sampel yang tidak tepat waktu?  Jika kita melihat distribusi operasi oleh penyedia, kita akan melihat gambar berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/5d2/3d4/3455d23d4093172fbbf416d9719e14fa.png"></div><br>  <i>Distribusi popularitas penyedia layanan</i> <br><br>  Ada ketidakseimbangan.  Ini mengarah pada fakta bahwa model ini mencoba untuk merekomendasikan layanan populer.  Kembali ke gambar di atas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ef/0fd/b08/6ef0fdb084bd7495ad12821c42cd70c2.png"><br><br>  Masalahnya adalah jika Anda memeriksa keakuratan model dengan menutupi matriks yang sama, seperti yang disarankan hampir di mana-mana, maka untuk sebagian besar pelanggan (contoh marginal: "W", "E" dan "I") kualitas perkiraan validasi (kami akan berpura-pura bahwa dia tidak berpartisipasi dalam pemilihan hiperparameter) akan tinggi jika ini adalah penyedia paling populer.  Sebagai hasilnya, kami mendapatkan kepercayaan salah pada kekuatan model.  Karena itu, kami bertindak sebagai berikut: <br><br><ol><li>  Perkiraan penyedia dibentuk berdasarkan model. <br></li><li>  Pasangan layanan klien yang ada dikeluarkan dari peringkat (lihat gambar di bawah) dan matriks OOT. <br></li><li>  Dibentuk dari peringkat yang tersisa dari rekomendasi K-top dan memberi peringkat MAP @ k pada OOT yang tersisa. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/ee7/c06/f4b/ee7c06f4b68beda0b4f0e22e3c8163c1.png"><br>  <i>Logika mempersiapkan matriks untuk menghasilkan perkiraan</i> <br><br>  Sebagai garis dasar, kami menyusun daftar penyedia, diurutkan berdasarkan popularitas, dan dikalikan dengan semua pelanggan, sekali lagi tidak termasuk pasangan layanan pelanggan yang ada.  Ternyata itu menyedihkan dan sama sekali tidak seperti yang kami harapkan dan lihat pada sampel validasi kereta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/a94/050/ee2a94050abe17d305bdcffeb895f2d0.png"></div><br>  <i>Benchmark dan Bagan Perbandingan Kualitas Model</i> <br><br>  Hentikan itu!  Kami memiliki faktor klien dan parameter penyedia.  Kami mendapatkan mesin faktorisasi. <br><br><h3>  FM </h3><br>  Mesin faktorisasi (mesin faktorisasi) - algoritma pembelajaran dengan guru, yang dirancang untuk menemukan hubungan antara faktor-faktor yang menggambarkan entitas yang berinteraksi, yang disajikan dalam bentuk matriks yang jarang.  Kami menggunakan implementasi FM dari pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LightFM</a> . <br><br><h3>  Format data </h3><br>  Selain matriks interaksi yang dinormalisasi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode ini</a> menggunakan dua set data tambahan dengan faktor-faktor untuk pelanggan dan untuk layanan penyedia dalam bentuk matriks satu-panas-dikodekan terhubung ke yang tunggal: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61b/fa6/c8a/61bfa6c8ab458cfb9b747a37a28e0e32.png"><br>  <i>Logika mempersiapkan matriks untuk menghasilkan perkiraan</i> <br><br><h3>  Penilaian kualitas </h3><br>  Kualitas model FM pada data kami ternyata lebih rendah dari ALS: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/457/003/48b457003013f435b77ba2d9ecc4cb25.png"></div><br>  <i>Tabel perbandingan model kualitas dan baseline</i> <br><br><h3>  Ubah Arsitektur Model - Meningkatkan </h3><br>  Diputuskan untuk datang dari sisi lain.  Mengingat distribusi popularitas layanan, kami mengidentifikasi 300 dari mereka, transaksi yang mencakup 80% dari semua operasi, dan melatih classifier pada mereka.  Di sini, data mewakili agregat transaksi pelanggan yang diperkaya dengan fitur klien: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d25/47d/718/d2547d718a7199fba96be2d0f653bf9a.png"><br>  <i>Skema agregasi transaksi</i> <br><br>  Kenapa hanya sisi klien, Anda bertanya?  Karena dalam hal ini, untuk menyiapkan rekomendasi, cukup bagi kita untuk memiliki satu jalur per klien.  Menerapkan model untuk itu, kami mendapatkan vektor output probabilitas untuk semua kelas, dari mana mudah untuk memilih rekomendasi top-K.  Jika kita menambahkan fitur layanan penyedia ke set pelatihan, maka pada tahap penerapan model kita akan dipaksa untuk menyiapkan 300 baris untuk setiap klien - satu untuk setiap layanan penyedia dengan fitur yang menggambarkan mereka, atau membangun model lain untuk calon penyortiran skor pre-sorting . <br><br>  Menambahkan fitur ke klien dari ALS tidak menambah data kami, karena kami sudah memperhitungkan aktivitas transaksional - misalnya, di bagian PKS atau kategori dengan gaya "gamer" atau "teater".  Dalam format ini, kami berhasil mendapatkan hasil yang baik: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eed/66a/389/eed66a389e4b545fa18a59c6c4ac123a.png"></div><br>  <i>Tabel perbandingan model kualitas dan baseline</i> <br><br><h3>  Filter regional </h3><br>  Terlepas dari kualitas model yang tinggi, satu masalah lagi tetap dalam pendekatan ini.  Karena arsitektur data dan model tidak menyiratkan penggunaan fitur layanan penyedia, model tidak sepenuhnya memperhitungkan geografi akun dan dapat merekomendasikan agar orang membayar untuk layanan penyedia lokal dari wilayah lain.  Untuk meminimalkan risiko ini, kami telah mengembangkan filter kecil untuk memotong opsi sebelum memasukkan ke dalam rekomendasi.  Rekursi yang mudah dilemparkan ke algoritma: <br><br><ol><li>  Kami mengumpulkan informasi tentang wilayah klien dari profil bank dan sumber internal lainnya. <br></li><li>  Kami memilih wilayah utama kehadiran untuk setiap penyedia. <br></li><li>  Kami mengklarifikasi / mengisi informasi tentang wilayah klien dengan wilayah penyedia yang dia gunakan. <br></li></ol><br>  Setelah manipulasi ini, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks Herfindahl, kami</a> memisahkan penyedia regional, yang diwakili dalam rangkaian wilayah terbatas, dari yang federal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/15f/090/62015f090d3bdcc34d468f7b36ffef90.png"></div><br>  <i>Pemisahan penyedia dengan kehadiran di daerah</i> <br><br>  Kami membentuk topeng dengan penyedia regional yang dapat diterima untuk pelanggan dan mengecualikan item yang tidak perlu dari prediksi model sebelum membuat daftar rekomendasi. <br><br><h2>  Kesimpulan </h2><br>  Kami telah mengembangkan dua model yang bersama-sama membentuk serangkaian rekomendasi lengkap tentang pembayaran dan transfer.  Dimungkinkan untuk mengurangi jalur klien untuk setengah operasi berulang menjadi satu klik.  Dalam rencana masa depan untuk meningkatkan model "operasi yang direkomendasikan" menggunakan data umpan balik (kartu dapat disembunyikan, dll.), Yang akan mengurangi ambang batas untuk memilih rekomendasi dan meningkatkan cakupan.  Juga direncanakan untuk memperluas cakupan pembayaran yang direkomendasikan dalam model "contoh pencarian" dan mengembangkan algoritma untuk penilaian optimasi untuk itu. <br><br>  Kami telah melalui jalur sulit membangun sistem pembayaran dan transfer yang direkomendasikan.  Di tengah jalan, kami mendapatkan masalah dan mendapatkan pengalaman dalam mendekomposisi dan menyederhanakan tugas-tugas tersebut, mengevaluasi dengan benar sistem tersebut, penerapan metode, kerja optimal dengan volume data yang besar, dan secara signifikan memperluas pemahaman kami tentang spesifikasi tugas-tugas tersebut.  Sepanjang jalan, saya berhasil berkontribusi pada open-source, yang kami gunakan sendiri.  Saya berharap Anda melakukan tugas yang menarik, garis dasar yang realistis dan F1 tunggal.  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461747/">https://habr.com/ru/post/id461747/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461737/index.html">Kami mengumpulkan lingkungan untuk TDD modern pada kode JavaScript + VS</a></li>
<li><a href="../id461739/index.html">Backend United 4: Okroshka. Insiden</a></li>
<li><a href="../id461741/index.html">Pengelompokan hirarki data kategorikal dalam R</a></li>
<li><a href="../id461743/index.html">Minggu Keamanan 31: Kerentanan VLC dan telepon rusak</a></li>
<li><a href="../id461745/index.html">DeviceLock DLP: Harga pasar gelap Rusia karena menerobos data pribadi (ditambah respons terhadap jawaban Tinkoff Bank)</a></li>
<li><a href="../id461749/index.html">Keindahan di mata yang melihatnya</a></li>
<li><a href="../id461751/index.html">Kontribusi desainer untuk pengembangan aplikasi seluler</a></li>
<li><a href="../id461753/index.html">InterSystems, Transaksi Global IRIS</a></li>
<li><a href="../id461755/index.html">The Psychology of Sound Vision. Svetlana Lebedeva menceritakan bagaimana orang diajari cara pandang yang baru</a></li>
<li><a href="../id461759/index.html">Mendengarkan Komunikasi VoIP Terenkripsi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>