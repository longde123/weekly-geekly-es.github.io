<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♨️ 🥫 🧛🏻 Cómo no hacer el más rápido y encontrar un defecto en la comunidad de Visual Studio 2019 👎🏼 🤸🏾 🦃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Me impulsó un artículo sobre el uso de la instrucción "popcount" extraña en los procesadores modernos . No se trata de contar el número de unidades, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo no hacer el más rápido y encontrar un defecto en la comunidad de Visual Studio 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467699/">  Me impulsó un artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre el uso de la instrucción "popcount" extraña en los procesadores modernos</a> .  No se trata de contar el número de unidades, sino de detectar el signo del final de la línea C ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">línea terminada en cero</a> ). <br><blockquote>  Una cadena terminada en nulo es una forma de representar cadenas en lenguajes de programación, en la que, en lugar de introducir un tipo de cadena especial, se utiliza una matriz de caracteres, y el final de la cadena es el primer carácter nulo especial encontrado (NUL del código ASCII, con un valor de 0). </blockquote><br>  Para determinar la duración de dicho término, se aplica una función estándar. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> __<span class="hljs-function"><span class="hljs-function">cdecl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* str)</span></span></span></span></code> </pre> <br>  El algoritmo de operación del cual se puede describir en C como: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> strlen_algo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* str) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*str++) length++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br>  Veamos en qué se convierte el compilador de la comunidad de MS Visual Studio 2019 (Release, x86): <br><br><pre> <code class="plaintext hljs">08811F7h: mov al,byte ptr [ecx] inc ecx test al,al jne main+0D7h (08811F7h)</code> </pre><a name="habracut"></a><br>  Es decir, un byte se carga desde la memoria y se compara con cero.  El mismo código se sustituye por las llamadas eliminadas si construye el proyecto en Release, el algoritmo es correcto, pero la velocidad, me parece, no es suficiente.  ¿Qué sucede si compila el código con una llamada a strlen estándar en Debug?  - Se llamará a la función de biblioteca strlen, como se esperaba, pero una persona la escribirá manualmente en el ensamblador. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler de código de la función strlen estándar en MS Visual Studio</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">;strlen.asm - contains strlen() routine ; ; Copyright (c) Microsoft Corporation. All rights reserved. ; ;Purpose: ; strlen returns the length of a null-terminated string, ; not including the null byte itself. ; ;******************************************************************************* .xlist include cruntime.inc .list page ;*** ;strlen - return the length of a null-terminated string ; ;Purpose: ; Finds the length in bytes of the given string, not including ; the final null character. ; ; Algorithm: ; int strlen (const char * str) ; { ; int length = 0; ; ; while( *str++ ) ; ++length; ; ; return( length ); ; } ; ;Entry: ; const char * str - string whose length is to be computed ; ;Exit: ; EAX = length of the string "str", exclusive of the final null byte ; ;Uses: ; EAX, ECX, EDX ; ;Exceptions: ; ;******************************************************************************* CODESEG public strlen strlen proc \ buf:ptr byte OPTION PROLOGUE:NONE, EPILOGUE:NONE .FPO ( 0, 1, 0, 0, 0, 0 ) string equ [esp + 4] mov ecx,string ; ecx -&gt; string test ecx,3 ; test if string is aligned on 32 bits je short main_loop str_misaligned: ; simple byte loop until string is aligned mov al,byte ptr [ecx] add ecx,1 test al,al je short byte_3 test ecx,3 jne short str_misaligned add eax,dword ptr 0 ; 5 byte nop to align label below align 16 ; should be redundant main_loop: mov eax,dword ptr [ecx] ; read 4 bytes mov edx,7efefeffh add edx,eax xor eax,-1 xor eax,edx add ecx,4 test eax,81010100h je short main_loop ; found zero byte in the loop mov eax,[ecx - 4] test al,al ; is it byte 0 je short byte_0 test ah,ah ; is it byte 1 je short byte_1 test eax,00ff0000h ; is it byte 2 je short byte_2 test eax,0ff000000h ; is it byte 3 je short byte_3 jmp short main_loop ; taken if bits 24-30 are clear and bit ; 31 is set byte_3: lea eax,[ecx - 1] mov ecx,string sub eax,ecx ret byte_2: lea eax,[ecx - 2] mov ecx,string sub eax,ecx ret byte_1: lea eax,[ecx - 3] mov ecx,string sub eax,ecx ret byte_0: lea eax,[ecx - 4] mov ecx,string sub eax,ecx ret strlen endp end</code> </pre><br></div></div><br>  Tabla 1: tiempo de ejecución del benchmark strlen en segundos (comunidad MS VS 2019, versión C ++ cl: 19.22.27905) <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Bloque grande, 1K </th><th>  Bloque grande, 1K, * llamada strlen </th><th>  Bloque pequeño, 10 elementos. </th><th>  Bloque pequeño, 10 elementos, * llamada strlen </th></tr><tr><td>  <b>Depuración, x86</b> </td><td>  7.25 </td><td>  7.25 </td><td>  3,06 </td><td>  3,06 </td></tr><tr><td>  <b>Lanzamiento, x86</b> </td><td>  9.0 </td><td>  3.9 </td><td>  0,15 </td><td>  0,12 </td></tr><tr><td>  <b>Depuración, x64</b> </td><td>  6.0 </td><td>  6.0 </td><td>  3.4 </td><td>  3.4 </td></tr><tr><td>  <b>Lanzamiento, x64</b> </td><td>  8.5 </td><td>  2.3 </td><td>  0,15 </td><td>  0,11 </td></tr></tbody></table></div><br>  * obligar al compilador a llamar a la función de biblioteca strlen <br><br>  Por lo tanto, podemos concluir que la sustitución de la comparación de bytes por el compilador MS VS es ineficiente incluso en cadenas pequeñas, y en cadenas grandes, ¡Debug está por delante de Release! <br><br><div class="spoiler">  <b class="spoiler_title">Código de banco</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;chrono&gt; #include &lt;nmmintrin.h&gt; inline size_t strlen_algo(const char* str) { size_t length = 0; while (*str++) length++; return length; } inline size_t strlen_sse4(const char* str) { size_t length = 0; int res = 0; //align to 16 bytes while (((size_t(str+length)) &amp; (sizeof(__m128i) - 1)) != 0) { if (str[length] == 0) return length; length++; } __m128i z128 = _mm_setzero_si128(); for(; ; length += 16) { __m128i data = _mm_load_si128((__m128i*)(str + length)); if ((res = _mm_cmpistri(z128, data, _SIDD_CMP_EQUAL_EACH)) != 16) break; } /*while (str[length]) length++;*/ return length + res; } #define _DISABLE_ASM_BSF //https://www.strchr.com/sse2_optimised_strlen #ifndef WORDS_BIGENDIAN #if 0 #elif 0 #else static inline int count_bits_to_0(unsigned int x) // counting trailing zeroes, by Nazo, post: 2009/07/20 03:40 { // this is current winner for speed static const unsigned char table[256] = { 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, }; if ((unsigned char)x) return table[(unsigned char)x]; return table[x &gt;&gt; 8] + 8; // t[x / 256] + 8 } #endif #else #if 0 static inline int count_bits_to_0(unsigned int x) // counting trailing zeroes { register int i = 0; if (!(x &amp; (1 &lt;&lt; 15))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 14))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 13))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 12))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 11))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 10))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 9))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 8))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 7))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 6))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 5))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 4))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 3))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 2))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 1))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 0))) i++; return i; } #else static inline int count_bits_to_0(unsigned int x) // counting trailing zeroes { // http://www.hackersdelight.org/: nlz1() shortened for 16-bit mask register int n = 0; if (x &lt;= 0x000000FFU) { n = n + 8; x = x &lt;&lt; 8; } if (x &lt;= 0x00000FFFU) { n = n + 4; x = x &lt;&lt; 4; } if (x &lt;= 0x00003FFFU) { n = n + 2; x = x &lt;&lt; 2; } if (x &lt;= 0x00007FFFU) { n = n + 1; } return n; } #endif #endif size_t strlen2(const char* str) { register size_t len = 0; // align to 16 bytes while ((((intptr_t)str) &amp; (sizeof(__m128i) - 1)) != 0) { if (*str++ == 0) return len; ++len; } // search for 0 __m128i xmm0 = _mm_setzero_si128(); __m128i xmm1; int mask = 0; for (;;) { xmm1 = _mm_load_si128((__m128i*)str); xmm1 = _mm_cmpeq_epi8(xmm1, xmm0); if ((mask = _mm_movemask_epi8(xmm1)) != 0) { // got 0 somewhere within 16 bytes in xmm1, or within 16 bits in mask // find index of first set bit #ifndef _DISABLE_ASM_BSF // define it to disable ASM #if (_MSC_VER &gt;= 1300) // make sure &lt;intrin.h&gt; is included unsigned long pos; _BitScanForward(&amp;pos, mask); len += (size_t)pos; #elif defined(_MSC_VER) // earlier MSVC's do not have _BitScanForward, use inline asm __asm bsf edx, mask; edx = bsf(mask) __asm add edx, len; edx += len __asm mov len, edx; len = edx #elif ((__GNUC__ &gt;= 4) || ((__GNUC__ == 3) &amp;&amp; (__GNUC_MINOR__ &gt;= 4))) // modern GCC has built-in __builtin_ctz len += __builtin_ctz(mask); #elif defined(__GNUC__) // older GCC shall use inline asm unsigned int pos; asm("bsf %1, %0" : "=r" (pos) : "rm" (mask)); len += (size_t)pos; #else // none of choices exist, use local BSF implementation len += count_bits_to_0(mask); #endif #else len += count_bits_to_0(mask); #endif break; } str += sizeof(__m128i); len += sizeof(__m128i); } return len; } int main() { std::vector&lt;std::string&gt; vstr; const int str_num = 1024; const int str_size = 1024; size_t len_result = 0; srand(0); for (int i = 0; i &lt; str_num; i++) { std::string str1; for (int j = 0; j &lt; str_size; j++) { str1.push_back('0' + rand() % 78); } vstr.push_back(std::move(str1)); } auto strlen_func = strlen; //auto strlen_func = strlen_algo; //auto strlen_func = strlen_sse4; //auto strlen_func = strlen2; auto time_std = std::chrono::steady_clock::now(); for (int k = 0; k &lt; 10*1000; k++) { for (int i = 0; i &lt; str_num; i++) { const char* str_for_test = vstr[i].c_str(); len_result += strlen_func(str_for_test); //len_result += strlen(str_for_test); } for (int i = 0; i &lt; str_num; i++) { const char* str_for_test = vstr[i].c_str(); len_result -= strlen_func(str_for_test); //len_result -= strlen(str_for_test); } } auto finish = std::chrono::steady_clock::now(); double elapsed_seconds = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(finish - time_std).count(); std::cout &lt;&lt; "\n" &lt;&lt; len_result; std::cout &lt;&lt; "\n\nTime: " &lt;&lt; elapsed_seconds; return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Cadena <pre> <code class="cpp hljs">len_result += <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(str_for_test);</code> </pre>  compila <br>  Depurar en: llamar a la función de biblioteca strlen; <br>  Lanzamiento en: comparación de bytes. <br><br>  Si comentas y escribes <br><br><pre> <code class="cpp hljs">len_result += strlen_func(str_for_test);</code> </pre> <br>  donde <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> strlen_func = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>;</code> </pre> <br>  obligaremos al compilador a llamar siempre a la función de biblioteca. <br><br>  ¿Debido a lo que se logró la aceleración de la función de biblioteca antes de la comparación de bytes en 2,3 veces (para Release, x86, 1k)? <br><br>  Debido a la comparación, no por un byte, sino inmediatamente por 4. Toda la magia aquí: <br><br><pre> <code class="plaintext hljs">main_loop: mov eax,dword ptr [ecx] ; read 4 bytes mov edx,7efefeffh add edx,eax xor eax,-1 xor eax,edx add ecx,4 test eax,81010100h je short main_loop</code> </pre><br>  ¿Es posible hacerlo más rápido usando instrucciones vectoriales de procesadores modernos?  Probémoslo. <br><br>  Usando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">guía Intel Intrinsics</a> , encontramos el _mm_cmpistri SSE4.2 intrínseco, diseñado solo para trabajar con cadenas.  Dos vectores de longitud de 128 bits y una máscara de operaciones se alimentan a la entrada.  Como máscara usamos: _SIDD_UBYTE_OPS = 0 - tipo de datos, _SIDD_CMP_EQUAL_EACH = 8 - operación de alineación de bytes, y la compararemos con un vector cero.  El valor devuelto será el número de los primeros elementos desiguales por pares (es decir, si el elemento coincide de izquierda a derecha, el recuento se detiene, me alegrará si alguien confirma el comportamiento). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//align to 16 bytes while (((size_t(str+length)) &amp; (sizeof(__m128i) - 1)) != 0) { if (str[length] == 0) return length; length++; } __m128i z128 = _mm_setzero_si128(); for(; ; length += 16) { __m128i data = _mm_load_si128((__m128i*)(str + length)); if ((res = _mm_cmpistri(z128, data, _SIDD_CMP_EQUAL_EACH)) != 16) break; } /*while (str[length]) length++;*/ return length + res;</span></span></code> </pre><br>  Código <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(str+length)) &amp; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(__m128i) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str[length] == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; length++; }</code> </pre><br>  Sirve para igualar la dirección de la línea cargada, la dirección se necesita en múltiplos de 16 para que la mayoría de las instrucciones SSE funcionen.  Para la instrucción pcmpistri utilizada por nosotros, la alineación no es estrictamente necesaria, no se lanzará una excepción de acceso. <br>  Intrínseca <br><pre> <code class="cpp hljs">__m128i data = _mm_load_si128((__m128i*)(str + length)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((res = _mm_cmpistri(z128, data, _SIDD_CMP_EQUAL_EACH)) != <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre> <br>  Compilado en: <br><pre> <code class="plaintext hljs">pcmpistri xmm1,xmmword ptr [eax+edx],8</code> </pre> <br>  Sin embargo, la alineación a 16 también es útil en nuestro caso, ya que proporciona un pequeño aumento en la velocidad, por lo que estamos seguros de que un ciclo de lectura de 16 bytes no irá a una página potencialmente no asignada ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">página de memoria 4K</a> ). <br><br>  Ciclo: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (str[length]) length++;</code> </pre><br>  <s>"Obtiene" el tamaño de la cadena si se detecta su final (ya que no estoy completamente seguro del algoritmo de operación _mm_cmpistri).</s> <br>  eliminado después del comentario <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">picul</a> , lo que dio un aumento en las líneas pequeñas. <br><br>  ¿Hicimos el strlen más rápido?  - Desafortunadamente, no, los chicos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.strchr.com/sse2_optimised_strlen lo</a> hicieron aún más rápido y sin usar SSE4.2. <br><br>  Tabla 2: tiempo de ejecución del benchmark strlen en segundos (lanzamiento) <br><div class="scrollable-table"><table><tbody><tr><th>  Numero de caracteres </th><th>  Comparación de bytes MS </th><th>  Ms strlen </th><th>  SSE 4.2 </th><th>  SSE 2 </th></tr><tr><td>  <b>10, x86</b> </td><td>  0,15 </td><td>  0,12 </td><td>  0,12 </td><td>  0,125 </td></tr><tr><td>  <b>1K, x86</b> </td><td>  9.0 </td><td>  3.9 </td><td>  1,65 </td><td>  1,42 </td></tr><tr><td>  <b>10, x64</b> </td><td>  0,15 </td><td>  0,11 </td><td>  0,08 </td><td>  0.1 </td></tr><tr><td>  <b>1K, x64</b> </td><td>  8.5 </td><td>  2.3 </td><td>  1.6 </td><td>  1,32 </td></tr></tbody></table></div><br>  Conclusiones: <br><br>  Me parece que MS siempre necesita llamar a la biblioteca strlen, y no hacer comparaciones de bytes de sustitución. <br><br>  UPD <br>  Se agregó prueba x64. <br>  Se eliminó el último bucle en strlen_SSE4 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467699/">https://habr.com/ru/post/467699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467683/index.html">Tratando de componer lo no composable: esquemas de acoplamiento</a></li>
<li><a href="../467689/index.html">Una pequeña descripción de SIMD en .NET / C #</a></li>
<li><a href="../467691/index.html">Intel Nervana NNP-T y NNP-I: chips especializados para IA</a></li>
<li><a href="../467693/index.html">Resumen de eventos de TI de septiembre (segunda parte)</a></li>
<li><a href="../467697/index.html">¿Es cierto que GOPATH y GOROOT ya no son necesarios?</a></li>
<li><a href="../467701/index.html">Categorías en lugar de directorios. Una herramienta para el almacenamiento conveniente de archivos</a></li>
<li><a href="../467703/index.html">IT África: las empresas y startups tecnológicas más interesantes del continente</a></li>
<li><a href="../467705/index.html">Paramagnones y magnones: energía del calor.</a></li>
<li><a href="../467707/index.html">Cómo configurar Linux para ingresar al dominio usando algoritmos GOST</a></li>
<li><a href="../467711/index.html">IoT, niebla y nubes: ¿hablar de tecnología?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>