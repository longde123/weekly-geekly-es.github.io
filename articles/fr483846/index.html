<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕗 🏳️ 👨🏿‍⚕️ Gestion alternative des fenêtres sous Linux 🤣 👉 ♂️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je fais partie de ceux qui mettent en place des dispositions de commutation de verrouillage des majuscules parce que je suis trop paresseux pour appuy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gestion alternative des fenêtres sous Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483846/"><p>  Je fais partie de ceux qui mettent en place des dispositions de commutation de verrouillage des majuscules parce que je suis trop paresseux pour appuyer sur 2 touches lorsque vous pouvez appuyer sur une.  Je voudrais même avoir 2 clés inutiles: j'en utiliserais une pour activer la mise en page en anglais et la seconde pour le russe.  Mais la deuxième touche inutile est un appel au menu contextuel, qui est si inutile qu'il est coupé par de nombreux fabricants d'ordinateurs portables.  Vous devez donc vous contenter de ce que vous avez. </p><br><p>  Et lorsque je change de fenêtre, je ne veux pas chercher leurs icônes dans la barre des tâches, jeter un coup d'œil aux noms lorsque je fais défiler <em>Alt + Tab</em> , faire défiler les bureaux, etc. Je veux appuyer sur une combinaison de touches (idéalement, il n'y en a qu'une, mais il n'y a plus de touches inutiles gratuites ) et entrez immédiatement dans la fenêtre dont j'ai besoin.  Par exemple, comme ceci: </p><br><ul><li>  Alt + F: Firefox </li><li>  Alt + D: Firefox (navigation privée) </li><li>  Alt + T: Terminal </li><li>  Alt + M: calculatrice </li><li>  Alt + E: Idée IntelliJ </li><li>  etc. </li></ul><br><p>  De plus, en appuyant, par exemple, <em>Alt + M,</em> je veux voir la calculatrice, que ce programme soit en cours d'exécution ou non.  S'il est en cours d'exécution, sa fenêtre doit recevoir le focus, et sinon, démarrez le programme souhaité et transférez le focus lors du chargement. </p><br><p>  Pour les cas qui ne sont pas couverts par le scénario précédent, je souhaite disposer de raccourcis clavier universels auxquels vous pouvez facilement affecter n'importe laquelle des fenêtres ouvertes.  Par exemple, j'ai 10 combinaisons attribuées de <em>Alt + 1</em> à <em>Alt + 0</em> qui ne sont liées à aucun programme.  Je peux simplement appuyer sur <em>Alt + 1</em> et la fenêtre actuellement mise au point recevra le focus lorsque <em>Alt + 1 sera</em> enfoncé. </p><br><p>  Sous la coupe, une description de quelques fonctionnalités supplémentaires et une réponse à la façon de procéder.  Mais je vous avertis immédiatement qu'une telle personnalisation "pour vous-même" peut provoquer une forte dépendance et même se casser si nécessaire, utiliser Windows, Mac OS ou même l'ordinateur de quelqu'un d'autre avec Linux. </p><a name="habracut"></a><br><p>  En fait, si vous y réfléchissez, nous n'utilisons pas de nombreux programmes tous les jours.  Un navigateur, un terminal, un IDE, une sorte de messager, un gestionnaire de fichiers, une calculatrice et, peut-être, c'est presque tout.  Peu de combinaisons de touches sont nécessaires pour couvrir 95% des tâches quotidiennes. </p><br><p>  Pour les programmes qui ont plusieurs fenêtres ouvertes, l'une d'entre elles peut être affectée comme principale.  Par exemple, plusieurs fenêtres Idée IntelliJ sont ouvertes, affectées à <em>Alt + E.</em>  Dans des conditions normales, appuyer sur <em>Alt + E</em> ouvrira une fenêtre de ce programme, probablement celle qui a été ouverte en premier.  Cependant, si vous appuyez sur <em>Alt + E</em> alors que l'une des fenêtres de ce programme est déjà mise au point, cette fenêtre sera affectée comme principale et la mise au point lui sera transférée la prochaine fois que la combinaison sera pressée. </p><br><p>  La fenêtre principale peut être réaffectée.  Pour ce faire, vous devez d'abord réinitialiser la combinaison, puis lui attribuer une autre fenêtre comme principale.  Pour réinitialiser une combinaison, vous devez appuyer sur la combinaison elle-même, puis sur une combinaison de réinitialisation spéciale, je l'ai affectée à <em>Alt + Backspace</em> .  Cela invoquera un script qui désattribuera la fenêtre principale pour la combinaison précédente.  Et puis vous pouvez attribuer une nouvelle fenêtre principale comme décrit dans le paragraphe précédent.  La réinitialisation d'une fenêtre liée à des combinaisons universelles est similaire. </p><br><p>  L'introduction s'est avérée longue, mais je voulais d'abord dire ce que nous ferons, puis expliquer comment le faire. </p><br><h2 id="dlya-teh-komu-nadoelo-chitat">  Pour ceux qui en ont assez de lire </h2><br><p>  Bref, un lien vers les scripts à la fin de l'article. </p><br><p>  Mais tout de même, cela ne fonctionnera pas et sera immédiatement installé et utilisé.  Vous devez d'abord comprendre comment le script trouve la bonne fenêtre.  Sans cela, il ne fonctionnera pas pour dire au script exactement où se concentrer.  Et vous devez savoir quoi faire si vous ne trouvez pas soudainement une fenêtre appropriée. </p><br><p>  Et je ne me concentrerai pas sur la façon de configurer l'exécution du script en appuyant sur les combinaisons de touches.  Par exemple, dans KDE, c'est dans Paramètres système → Raccourcis → Raccourcis personnalisés.  Dans d'autres gestionnaires de fenêtres, cela devrait également l'être. </p><br><h2 id="znakomstvo-s-wmctrl">  Présentation de wmctrl </h2><br><p>  <em>Wmctrl</em> est un utilitaire de console pour interagir avec X Window Manager.  Il s'agit d'un programme de script clé.  Jetons un coup d'œil à la façon dont vous pouvez l'utiliser. </p><br><p>  D'abord, listez les fenêtres ouvertes: </p><br><pre><code class="plaintext hljs">$ wmctrl -lx 0x01e0000e -1 plasmashell.plasmashell N/A Desktop — Plasma 0x01e0001e -1 plasmashell.plasmashell N/A Plasma 0x03a00001 0 skype.Skype N/A Skype 0x04400003 0 Navigator.Firefox N/A Google  - Mozilla Firefox 0x04400218 0 Navigator.Firefox N/A     /  - Mozilla Firefox (Private Browsing) ...</code> </pre> <br><p>  L'option <em>-l</em> affiche une liste de toutes les fenêtres ouvertes et <em>-x</em> ajoute le nom de la classe ( <em>skype.Skype</em> , <em>Navigator.Firefox</em> , etc.) à la sortie.  Nous aurons besoin de l'id de la fenêtre (colonne 1), du nom de la classe (colonne 3) et du nom de la fenêtre (dernière colonne). </p><br><p>  Vous pouvez essayer d'activer une fenêtre en utilisant l'option <em>-a</em> : </p><br><pre> <code class="plaintext hljs">$ wmctrl -a skype.Skype -x</code> </pre> <br><p>  Si tout s'est déroulé comme prévu, une fenêtre Skype devrait apparaître à l'écran.  Si vous utilisez l'option <em>-i</em> au lieu de l'option <em>-x</em> , vous pouvez spécifier l'ID de fenêtre au lieu du nom de classe.  Avec id, le problème est que l'id de la fenêtre change à chaque démarrage de l'application et que nous ne pouvons pas le savoir à l'avance.  En revanche, cet attribut indique uniquement une fenêtre, ce qui peut être important lorsqu'une application ouvre plusieurs fenêtres.  À ce sujet un peu plus loin. </p><br><p>  À ce stade, nous devons nous rappeler que nous rechercherons la fenêtre souhaitée en utilisant l' <em>expression régulière en</em> fonction de la sortie de <em>wmctrl -lx</em> .  Mais cela ne signifie pas que nous devons utiliser quelque chose de compliqué.  Habituellement, un nom de classe ou un nom de fenêtre est suffisant. </p><br><p>  En principe, l'idée de base doit déjà être claire.  Dans les paramètres globaux des raccourcis / raccourcis de votre gestionnaire de fenêtres, nous configurons la combinaison souhaitée pour exécuter le script. </p><br><h2 id="kak-polzovatsya-skriptami">  Comment utiliser les scripts </h2><br><p>  Vous devez d'abord installer les utilitaires de console <em>wmctrl</em> et <em>xdotool</em> : </p><br><pre> <code class="plaintext hljs">$ sudo apt-get install wmctrl xdotool</code> </pre> <br><p>  Ensuite, vous devez télécharger les scripts et les ajouter à <em>$ PATH</em> .  Je les mets généralement dans <em>~ / bin</em> : </p><br><pre> <code class="plaintext hljs">$ cd ~/bin $ git clone https://github.com/masyamandev/Showwin-script.git $ ln -s ./Showwin-script/showwin showwin $ ln -s ./Showwin-script/showwinDetach showwinDetach</code> </pre> <br><p>  S'il n'y avait pas de <em>répertoire ~ / bin</em> , alors il doit être créé et redémarré (ou connecté), sinon <em>~ / bin</em> n'entrera pas dans <em>$ PATH</em> .  Si tout est fait correctement, les scripts doivent être accessibles à partir de la console et la complétion des onglets devrait fonctionner. </p><br><p>  Le script <strong>showwin</strong> principal prend 2 paramètres: le premier est regex, par lequel nous rechercherons la fenêtre désirée, et le second paramètre est la commande qui doit être exécutée si la fenêtre désirée n'a pas été trouvée. </p><br><p>  Vous pouvez essayer d'exécuter un script, par exemple: </p><br><pre> <code class="plaintext hljs">$ showwin "Mozilla Firefox$" firefox</code> </pre> <br><p>  Si Firefox est installé, l'accent doit être mis sur sa fenêtre.  Même si Firefox n'était pas en cours d'exécution, il aurait dû démarrer. </p><br><p>  Si cela s'est avéré, vous pouvez essayer de configurer l'exécution des commandes sur une combinaison.  Dans les paramètres de raccourcis clavier / raccourcis globaux, ajoutez: </p><br><ul><li>  Alt + F: showwin "Mozilla Firefox $" firefox </li><li>  Alt + D: showwin "Mozilla Firefox (navigation privée) $" "firefox -private-window" </li><li>  Alt + C: showwin "navigateur chrome. Navigateur chrome N *" navigateur chrome </li><li>  Alt + X: showwin "chrome-browser.Chromium-browser I *" "chromium-browser -incognito" </li><li>  Alt + S: showwin "skype.Skype" skypeforlinux </li><li>  Alt + E: showwin "jetbrains-idea" idea.sh </li></ul><br><p>  Et ainsi de suite: des combinaisons de touches et de logiciels que chacun peut configurer à sa guise. <br>  Si tout s'est bien passé, alors selon les combinaisons ci-dessus, nous pouvons basculer entre les fenêtres avec une simple touche. </p><br><p>  Je vais décevoir les amateurs de chrome: il est incognito de distinguer une fenêtre ordinaire de la <em>sortie wmctrl</em> , ils ont les mêmes noms de classe et les mêmes en-têtes de fenêtre.  Dans l'expression régulière proposée, les caractères N * et I * ne sont nécessaires que pour que ces habitués diffèrent les uns des autres et qu'ils puissent être affectés à différentes fenêtres comme fenêtres principales. </p><br><p>  Pour réinitialiser la fenêtre principale de la combinaison précédente (en fait pour regex, qui <strong>showwin a</strong> été appelé pour la dernière fois), vous devez appeler le script <strong>showwinDetach</strong> .  J'ai ce script affecté à la <em>combinaison de touches Alt + Backspace</em> . </p><br><p>  Le script <strong>showwin</strong> a une autre fonctionnalité.  Lorsqu'il est appelé avec un paramètre (dans ce cas, le paramètre n'est qu'un identifiant), il ne vérifie pas du tout l'expression régulière et considère que toutes les fenêtres sont appropriées.  En soi, cela semble inutile, cependant, de cette façon, nous pouvons désigner n'importe quelle fenêtre comme principale et passer rapidement à cette fenêtre particulière. </p><br><p>  J'ai configuré de telles combinaisons: </p><br><ul><li>  Alt + 1: showwin "CustomKey1" </li><li>  Alt + 2: showwin "CustomKey2" </li><li>  ... </li><li>  Alt + 0: showwin "CustomKey0" </li><li>  Alt + Retour arrière: showwinDetach </li></ul><br><p>  De cette façon, je peux lier toutes les fenêtres aux <em>combinaisons Alt + 1</em> ... <em>Alt + 0</em> .  En appuyant simplement sur <em>Alt + 1,</em> je lie la fenêtre actuelle à cette combinaison.  Je peux dissocier en appuyant sur <em>Alt + 1</em> , puis sur <em>Alt + Retour arrière</em> .  Ou fermez la fenêtre, cela fonctionne aussi. </p><br><p>  De plus, je dirai quelques détails techniques.  Vous ne pouvez pas les lire, mais essayez simplement de les configurer et de les voir.  Mais je recommanderais quand même de comprendre les scripts des autres avant de les exécuter sur votre ordinateur :). </p><br><h2 id="kak-razlichat-raznye-okna-odnogo-prilozheniya">  Comment distinguer différentes fenêtres d'une même application </h2><br><p>  En principe, le tout premier exemple de «wmctrl -a skype.Skype -x» fonctionnait et peut être utilisé.  Mais regardons à nouveau l'exemple avec Firefox, dans lequel 2 fenêtres sont ouvertes: </p><br><pre> <code class="plaintext hljs">0x04400003 0 Navigator.Firefox N/A Google  - Mozilla Firefox 0x04400218 0 Navigator.Firefox N/A     /  - Mozilla Firefox (Private Browsing)</code> </pre> <br><p>  La première fenêtre est en mode normal et la seconde est la navigation privée.  Je voudrais considérer ces fenêtres comme des applications différentes et y basculer en utilisant différentes combinaisons de touches. </p><br><p>  Vous devez compliquer le script qui change de fenêtre.  J'ai utilisé cette solution: afficher une liste de toutes les fenêtres, faire <em>grep</em> par regex, prendre la première ligne avec <em>head</em> , récupérer la première colonne (ce sera l'id de la fenêtre) avec <em>cut</em> , basculer vers la fenêtre par id. </p><br><p>  Il devrait y avoir une blague sur les expressions régulières et deux problèmes, mais en fait je n'utilise rien de compliqué.  J'ai besoin de réguliers pour pouvoir indiquer la fin de la ligne (le caractère «$») et faire la distinction entre «Mozilla Firefox $» et «Mozilla Firefox (navigation privée) $». </p><br><p>  La commande ressemble à ceci: </p><br><pre> <code class="plaintext hljs">$ wmctrl -i -a `wmctrl -lx | grep -i "Mozilla Firefox$" | head -1 | cut -d" " -f1`</code> </pre> <br><p>  Ici, vous pouvez déjà deviner la deuxième fonctionnalité du script: si grep n'a rien retourné, alors l'application souhaitée n'est pas ouverte et vous devez l'exécuter en exécutant la commande à partir du deuxième paramètre.  Et puis vérifiez périodiquement si la fenêtre de droite s'est ouverte pour lui donner le focus.  Je ne me concentrerai pas sur cela, ceux qui en ont besoin regarderont la source. </p><br><h2 id="kogda-okna-prilozheniya-ne-razlichimy">  Lorsque les fenêtres d'application ne sont pas distinguables </h2><br><p>  Nous avons donc appris à transférer le focus vers la fenêtre de l'application souhaitée.  Mais que faire si plusieurs fenêtres d'une application sont ouvertes?  Sur laquelle dois-je me concentrer?  Le script ci-dessus passera, très probablement, à la première fenêtre ouverte.  Cependant, nous aimerions plus de flexibilité.  Je voudrais pouvoir me souvenir de quelle fenêtre nous avons besoin et passer à cette fenêtre. </p><br><p>  L'idée était la suivante: si nous voulons nous souvenir d'une certaine fenêtre pour une combinaison de touches, alors nous devons appuyer sur cette combinaison lorsque la fenêtre souhaitée est mise au point.  À l'avenir, lorsque vous cliquerez sur cette combinaison, l'accent sera mis sur cette fenêtre particulière.  Jusqu'à la fermeture de la fenêtre ou une réinitialisation de cette <strong>combinaison de</strong> scripts <strong>showwinDetach</strong> . </p><br><p>  L' <strong>algorithme de</strong> script <strong>showwin</strong> ressemble à ceci: </p><br><ul><li>  Vérifiez si nous nous sommes déjà souvenus de l'identifiant de la fenêtre à laquelle le focus doit être passé. <br>  Si vous vous en souvenez et qu'une telle fenêtre existe toujours, nous y transférons le focus et sortons. </li><li>  Nous regardons quelle fenêtre est actuellement au point, et si elle correspond à notre demande, alors nous nous souviendrons de son identifiant pour y aller à l'avenir et quitter. </li><li>  Nous passons à au moins une fenêtre appropriée si elle existe ou ouvrons l'application souhaitée. </li></ul><br><p>  Vous pouvez découvrir quelle fenêtre est actuellement au point en utilisant l'utilitaire de console xdotool, convertissant sa sortie au format hexadécimal: </p><br><pre> <code class="plaintext hljs">$ printf "0x%08x" `xdotool getwindowfocus`</code> </pre> <br><p>  Se souvenir de quelque chose dans bash est le moyen le plus simple de créer des fichiers dans un système de fichiers virtuel en mémoire.  Sur Ubuntu, ceci est connecté par défaut dans <em>/ dev / shm /</em> .  Je ne peux rien dire sur les autres distributions, j'espère que cela existe aussi.  Vous pouvez voir la commande: </p><br><pre> <code class="plaintext hljs">$ mount -l | grep tmpfs</code> </pre> <br><p>  Le script créera des répertoires vides dans ce dossier, comme ceci: <em>/ dev / shm / $ USER / showwin / $ SEARCH_REGEX / $ WINDOW_ID</em> .  De plus, à chaque appel, il créera un lien symbolique <em>/ dev / shm / $ USER / showwin / showwin_last</em> sur <em>/ dev / shm / $ USER / showwin / $ SEARCH_REGEX</em> .  Cela sera nécessaire afin de supprimer l'ID de fenêtre pour une combinaison spécifique si nécessaire en utilisant le script <strong>showwinDetach</strong> . </p><br><h2 id="chto-mozhno-uluchshit">  Ce qui peut être amélioré </h2><br><p>  Tout d'abord, les scripts doivent être configurés à la main.  Certes, en raison de la nécessité de se plonger et de faire beaucoup avec vos mains, beaucoup d'entre vous n'essaieront même pas de configurer le système.  S'il était possible de simplement mettre le paquet et de tout configurer plus facilement, alors il gagnerait peut-être en popularité.  Et là, regardez les distributions standard, elles entailleraient l'application. </p><br><p>  Et peut-être plus facile peut être fait.  Si l'ID de la fenêtre vous permet de trouver l'ID du processus qui l'a créé et l'ID du processus pour savoir quelle équipe l'a créé, vous pouvez automatiser la configuration.  En fait, je ne comprenais pas si ce que j'avais écrit dans ce paragraphe était possible.  Le fait est que pour moi personnellement, cela correspond à la façon dont cela fonctionne maintenant.  Mais si pour quelqu'un d'autre que moi, toute l'approche semble pratique et que quelqu'un l'améliore, alors je serai heureux d'utiliser la meilleure solution. </p><br><p>  Un autre problème, comme je l'ai déjà écrit, est que dans certains cas, les fenêtres ne peuvent pas être distinguées les unes des autres.  Jusqu'à présent, je n'ai vu cela qu'avec incognito en chrome / chrome, mais peut-être ailleurs, il y a quelque chose de similaire.  Dans les cas extrêmes, il existe toujours une variante des combinaisons universelles <em>Alt + 1</em> ... <em>Alt + 0</em> .  Encore une fois, j'utilise Firefox et pour moi personnellement ce problème n'est pas significatif. </p><br><p>  Mais un problème important pour moi est que j'utilise Mac OS pour le travail et je ne pouvais rien configurer de tel là-bas.  <em>Il</em> semble être en mesure de fournir l'utilitaire <em>wmctrl</em> , mais il ne fonctionne pas vraiment sur Mac OS.  Quelque chose peut être fait avec l'application <em>Automator</em> , mais elle est si lente qu'il n'est pas pratique de l'utiliser même lorsqu'elle fonctionne.  Je ne pouvais pas non plus configurer les combinaisons de touches pour qu'elles fonctionnent dans tous les programmes.  Si tout à coup quelqu'un trouve une solution - je serai heureux de l'utiliser. </p><br><h2 id="vmesto-zaklyucheniya">  Au lieu d'une conclusion </h2><br><p>  Il s'est avéré de manière inattendue beaucoup de mots pour une fonctionnalité aussi simple en apparence.  Je voulais transmettre l'idée et ne pas surcharger le texte, mais je n'ai pas encore trouvé comment le dire plus facilement.  Ce serait peut-être mieux en format vidéo, mais ils n'aiment pas ça comme ça. </p><br><p>  J'ai parlé un peu de ce qui se trouve sous le capot du script et comment le configurer.  Je ne suis pas entré dans les détails du script lui-même, mais ce n'est que 50 lignes, ce n'est pas difficile à comprendre. </p><br><p>  J'espère que quelqu'un d'autre tentera cette idée et l'appréciera peut-être même.  Je peux dire par moi-même que le script a été écrit il y a environ 3 ans et qu'il est TRÈS pratique pour moi.  Il est si pratique qu'il provoque une gêne grave lorsque vous travaillez avec les ordinateurs d'autres personnes.  Et avec un macbook fonctionnel. </p><br><p>  <a href="https://github.com/masyamandev/Showwin-script">Lien de script</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483846/">https://habr.com/ru/post/fr483846/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483828/index.html">Échanges atomiques de brillance et de pauvreté</a></li>
<li><a href="../fr483832/index.html">RxJava à Coroutines: migration des fonctionnalités de bout en bout</a></li>
<li><a href="../fr483834/index.html">Debian: transformer simplement i386 en amd64</a></li>
<li><a href="../fr483842/index.html">L'histoire de la création d'un cloud domestique. Partie 5. Mise à jour 2019 - PHP 7.2, MariaDB 10.4 et Nextcloud 17</a></li>
<li><a href="../fr483844/index.html">Analyse des documents réglementaires sur la protection des informations dans le secteur russe du crédit et des finances</a></li>
<li><a href="../fr483850/index.html">Aucun dieux ne brûle de pots</a></li>
<li><a href="../fr483860/index.html">WHD Global 2012: la vraie valeur des domaines bon marché</a></li>
<li><a href="../fr483862/index.html">Fonctions virtuelles dans les microcontrôleurs - le côté obscur</a></li>
<li><a href="../fr483864/index.html">Plus rapide que C ++; plus lent que php</a></li>
<li><a href="../fr483872/index.html">Motifs sur la fenêtre ou le fléau des automobilistes: comment la glace en deux dimensions se développe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>