<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↖️ 👩🏼‍🔬 😡 ZIO和Cats Effect：成功的联盟 🧐 ♀️ 🕕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cats Effect已成为功能性Scala世界的一种“反应流”，可让您将整个多样化的图书馆生态系统结合在一起。 

 许多出色的库：http4s，fs2，doobie-仅基于Cats Effect中的类型类实现。 ZIO和Monix之类的库又为它们的效果类型提供了这些类型类的实例。 尽管在3.0版...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZIO和Cats Effect：成功的联盟</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/472386/">  Cats Effect已成为功能性Scala世界的一种“反应流”，可让您将整个多样化的图书馆生态系统结合在一起。 <br><br> 许多出色的库：http4s，fs2，doobie-仅基于Cats Effect中的类型类实现。  ZIO和Monix之类的库又为它们的效果类型提供了这些类型类的实例。 尽管在3.0版中将解决一些问题，但Cats Effect帮助许多开源贡献者有机地支持Scala语言的整个功能生态系统。 使用Cats Effect的开发人员面临一个艰难的选择：将哪种效果实现用于其应用程序。 <br><br> 今天有三种选择： <br><br><ul><li>  Cat IO，参考实现； </li><li>  Monix，任务数据类型及其在代码中的反应性； </li><li>  ZIO，ZIO数据类型及其跨线程范围。 </li></ul><br> 在本文中，我将尝试向您证明，使用Cats Effect创建您的应用程序，ZIO是与Cats IO中的参考实现完全不同的设计解决方案和功能的理想选择。 <br><a name="habracut"></a><br><h2>  1.更好的MTL /无标签最终架构 </h2><br>  MTL（Monad变形金刚库）是一种编程风格，其中函数根据其作用类型而多态，并通过“类型类约束”表达其要求。 在Scala中，这通常称为“无标签最终样式”（尽管不是同一回事），尤其是在类型类没有法律的情况下。 <br><br> 众所周知，无法为经典的MTL类型类（如Writer和State）以及效果类型（如Cats IO）定义全局实例。 问题在于，针对这些类型的效果的这些类型类的实例需要访问可变状态，该状态不能全局创建，因为创建可变状态也是一种效果。 <br><br> 但是，为了获得最佳性能，重要的是要避免使用“ monad变换器”，并在主要效果类型之上直接提供Write和State实现。 <br><br> 为此，Scala程序员使用了一个技巧：他们在程序的顶层创建（但干净的）具有效果的实例，然后将它们作为局部含义在程序中进一步提供： <br><br><pre><code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Ref</span></span>.make[<span class="hljs-type"><span class="hljs-type">AppState</span></span>](initialAppState).flatMap(ref =&gt; <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monadState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>, <span class="hljs-type"><span class="hljs-type">AppState</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">AppState</span></span>] = ref.get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">AppState</span></span>): <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = ref.set(s).unit } myProgram )</code> </pre> <br> 尽管这种技巧很有用，但它仍然是“拐杖”。 在理想情况下，类型类的所有实例可以是连贯的（每种类型一个实例），而不是在本地创建，从而产生效果，然后将其神奇地包装在隐式值中，以供后续方法使用。 <br><br>  MTL /无标签最终处理的一个伟大功能是，您可以使用ZIO环境在ZIO数据类型之上直接定义大多数实例。 <br><br> 这是为ZIO数据类型创建全局MonadState定义的一种方法： <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadState</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">State</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">S</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.set(s).unit) }</code> </pre><br> 现在，为至少支持<code>State[S]</code>任何环境全局定义一个实例。 <br><br> 与<code>FunctorListen</code>类似，也称为<code>MonadWriter</code> ： <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOFunctorListen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>: <span class="hljs-type"><span class="hljs-type">Semigroup</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">Writer</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get.flatMap(w =&gt; fa.map(a =&gt; a -&gt; w))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span></span>(w: <span class="hljs-type"><span class="hljs-type">W</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.update(_ |+| w).unit) }</code> </pre><br> 当然，我们可以对<code>MonadError</code>执行相同的<code>MonadError</code> ： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>]{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">E</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = fa catchAll f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raiseError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](e: <span class="hljs-type"><span class="hljs-type">E</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fail(e) }</code> </pre> <br> 此技术很容易应用于其他类型类，包括无标签最终类型类，其实例可能需要生成效果（更改，配置），测试生成效果的函数（将环境效果与无标签最终组合）或从环境中容易访问的任何其他方法。 <br><br> 不再需要缓慢的单调转换！ 假设在初始化类的实例时产生效果，以本地含义为“否”。 不再需要拐杖。 直接沉浸在纯函数式编程中。 <br><br><h2>  2.为凡人节省资源 </h2><br>  ZIO的最初功能之一是中断– ZIO运行时能够立即中断任何可执行效果并保证释放所有资源的能力。  Cats IO对该功能的粗略实现。 <br><br>  Haskell称这种功能为异步异常，它使您可以创建并有效使用延迟，有效的并行和竞争操作以及全局最佳计算。 这种中断不仅带来巨大的好处，而且在支持对资源的安全访问方面也带来了复杂的任务。 <br><br> 程序员用于通过简单分析来跟踪程序中的错误。  ZIO也可以做到这一点，ZIO使用类型系统来帮助检测错误。 但是中断是另外一回事。 由许多其他效果创建的效果可以在任何边界处中断。 <br><br> 考虑以下效果： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle) _ &lt;- closeFile(handle) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> data</code> </pre> <br> 大多数开发人员在这种情况下不会感到惊讶：如果<code>readFile</code>崩溃， <code>closeFile</code>将不会执行。 幸运的是，效果系统具有<code>ensuring</code> （Cats Effect中的<code>guarantee</code> ），使您可以将最终处理程序添加到终结器效果中，类似于final。 <br><br> 因此，上面代码的主要问题可以轻松解决： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle).ensuring(closeFile(handle)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br> 从某种意义上说，现在的效果已经变得“抗摔”，如果<code>readFile</code> ，文件仍将关闭。 如果<code>readFile</code>成功，该文件也将关闭。 在所有情况下，文件都会关闭。 <br><br> 但仍然一点也不。 中断意味着效果可以在任何地方中断，即使在<code>openFile</code>和<code>readFile</code>之间也可以中断。 如果发生这种情况，打开的文件将不会关闭，并且会发生资源泄漏。 <br><br> 获取和释放资源的模式是如此广泛，以至于ZIO引入了括号运算符，该运算符也出现在Cats Effect 1.0中。  Bracket语句可防止中断：如果成功接收资源，则即使中断使用该资源的效果，也会发生释放。 此外，资源的接收和释放都不会中断，从而提供了资源安全性的保证。 <br><br> 使用方括号，上面的示例如下所示： <br><br><pre> <code class="scala hljs">openFile(file).bracket(closeFile(_))(readFile(_))</code> </pre> <br> 不幸的是，方括号仅封装了一种（相当普遍的）资源消耗模式。 还有许多其他功能，尤其是具有竞争性的数据结构，中断必须访问这些数据结构，否则可能导致泄漏。 <br><br> 通常，所有中断工作都归结为两点： <br><br><ul><li> 防止在某些可能被中断的区域中出现中断； </li><li> 允许在可能结冰的区域打断。 </li></ul><br>  ZIO可以同时实现两者。 例如，我们可以使用低级ZIO抽象来开发我们自己的支架版本： <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.uninterruptible { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { a &lt;- acquire exit &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.interruptible(use(a)) .run.flatMap(exit =&gt; release(a, exit) .const(exit)) b &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.done(exit) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> b }</code> </pre><br> 在此代码中， <code>use(a)</code>是唯一可以中断的部分。 周围的代码保证在任何情况下都可以执行<code>release</code> 。 <br><br> 您可以随时检查是否有中断的机会。 为此，仅需要两个原始操作（其余所有操作均从这些操作派生）。 <br><br> 这种组合式功能齐全的中断模型使您不仅可以实现简单的括号实现，而且还可以实现资源管理中的其他方案，在这些方案中，可以在中断的优缺点之间找到平衡。 <br><br>  Cat IO仅提供一种用于控制中断的操作：不可取消的组合器。 它使整个代码块不间断。 尽管很少使用此操作，但它可能导致资源泄漏或锁定。 <br><br> 同时，事实证明您可以在Cats IO中定义一个原语，从而使您可以更好地控制中断。  Fabio Labella的非常复杂的实现过程极其缓慢。 <br><br>  ZIO允许您编写带有中断的代码，使用声明性复合运算符进行高级操作，而不会强迫您在严重的复杂性，低性能和阻止泄漏之间进行选择。 <br><br> 此外，最近在ZIO中添加的软件事务性存储器使用户可以声明性地编写自动异步，竞争性并允许中断的数据结构和代码。 <br><br><h2>  3.有保证的终结者 </h2><br> 许多编程语言中的try / finally块提供了编写同步代码而不泄漏资源所必需的保证。 <br><br> 特别是，此块可保证以下各项：如果try块开始执行，则try停止时将执行finally块。 <br><br> 此保修适用于： <br><br><ul><li> 有嵌套的“ try / finally”块； </li><li>  “ try块”中有错误； </li><li> 嵌套的finally块中有错误。 </li></ul><br>  ZIO“确保”操作可以像try / final一样使用： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect2 = effect.ensuring(cleanup)</code> </pre> <br>  ZIO为“ effect.ensuring（finalizer）”提供以下保证：如果开始执行“ effect”，则当“ effect”停止时，“ finalizer”将开始执行。 <br><br> 像try / final，这些保证在以下情况下仍然存在： <br><br><ul><li> 有嵌套的“确保”成分； </li><li>  “效果”中存在错误； </li><li> 嵌套的“ finalizer”中有错误。 </li></ul><br> 而且，即使影响被打断，保证仍然得以维持（“括号”的保证是相似的，实际上，“保证”是实施“括号”）。 <br><br>  Cats IO数据类型提供了另一个较弱的保证。 对于“ effect.guarantee（finalizer）”，它的弱点如下：如果开始执行“ effect”，则当问题效果未插入“ effect”时，“ finalizer”将在“ effect”停止时开始执行。 <br><br> 在Cats IO中执行“括号”时，也发现较弱的保证。 <br><br> 要获取资源泄漏，只需使用“ guarantee”或“ bracket.use”效果中使用的效果，并使用以下内容进行组合： <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   `interruptedFiber` -    val bigTrouble = interruptedFiber.join</span></span></code> </pre> <br> 当以这种方式将bigTrouble插入到另一个效果中时，该效果将不会中断-将不会执行通过“保证”设置的“终结器”或通过“括号”进行的资源清理。 即使块中存在“ finalizer”，所有这些都会导致资源消耗。 <br><br> 例如，以下代码中的“ finalizer”将永远不会开始执行： <br><br><pre> <code class="scala hljs">(<span class="hljs-type"><span class="hljs-type">IO</span></span>.unit &gt;&gt; bigTrouble).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>(println(<span class="hljs-string"><span class="hljs-string">"Won't be executed!!!«)))</span></span></code> </pre> <br> 在不考虑全局上下文的情况下评估代码时，无法确定是否将诸如“ bigTrouble”之类的效果插入“ bracket”操作的“ use”效果中的任何位置或“ finalizer”块内。 <br><br> 因此，如果不评估整个程序，就无法找出Cats IO程序是否可以解决资源泄漏或缺少“ finalizer”块的问题。 整个程序只能手动评估，并且此过程总是伴随着编译器无法验证的错误。 此外，每次代码中发生任何重要更改时，都必须重复此过程。 <br><br>  ZIO具有Cats Effect，“ guaranteeCase”和“ bracket”中的“保证”的自定义实现。 实现使用本地ZIO语义（而不是Cats IO语义），这使我们能够在此时和现在评估资源泄漏的可能问题，并且知道在所有情况下都将启动终结器并释放资源。 <br><br><h2>  4.稳定的切换 </h2><br>  Cats Effect具有“ ContextShift”中的“ evalOn”方法，该方法使您可以将某些代码的执行转移到另一个执行上下文。 <br><br> 出于多种原因，这很有用： <br><br><ul><li> 许多客户端库迫使您在其线程池中执行一些工作； </li><li>  UI库要求在UI线程中进行一些更新。 </li><li> 有些影响需要隔离以适应其特定功能的线程池。 </li></ul><br>  “ EvalOn”操作在应运行的位置执行效果，然后返回到原始执行上下文。 例如： <br><br><pre> <code class="scala hljs">cs.evalOn(kafkaContext)(kafkaEffect)</code> </pre> <br> 注意：Cats IO具有类似的“ shift”构造，该构造使您无需回退即可切换到其他上下文，但是在实践中，这种行为很少需要，因此首选“ evalOn”。 <br><br>  “ evalOn”的ZIO实现（在ZIO原语“锁”上进行）提供了必要的保证，可以唯一地了解效果在哪里工作-效果将始终在特定的上下文中执行。 <br><br>  Cats IO的保证则有所不同，但较弱-效果将在特定上下文中执行，直到第一次异步操作或内部切换为止。 <br><br> 考虑一小段代码，不可能确定是否会在要切换的效果中内置异步效果（或嵌套切换），因为异步不会显示在类型中。 <br><br> 因此，与资源安全性一样，要了解Cats IO效果将在何处启动，有必要研究整个程序。 在实践中，根据我的经验，当在一种情况下使用“ evalOn”时，Cats IO用户感到惊讶的是，随后发现大多数效果是在另一种情况下意外执行的。 <br><br>  ZIO允许您确定应在何处触发效果，并且不管效果如何内置到其他效果中，都可以相信它会在所有情况下发生。 <br><br><h2>  5.错误消息的安全性 </h2><br> 任何支持并发，并发或对资源的安全访问的影响都将陷入线性错误模型：通常，并非所有错误都可以保存。 <br><br> 对于“ Throwable”，Cats IO内置的固定错误类型以及ZIO支持的多态错误类型，都是如此。 <br><br> 具有多个一次性错误的情况的示例： <br><br><ul><li> 终结器抛出异常； </li><li> 两个（下降）效果在并行执行中组合在一起； </li><li> 赛车状态下的两种（下降）影响； </li><li> 中断的效果会下降，然后才使该部分免受中断。 </li></ul><br> 由于未保存所有错误，因此ZIO提供了基于自由半环（来自抽象代数的抽象，此处不提供其知识）的“原因[E]”数据结构，该结构允许针对任何类型的错误连接串行和并行错误。 在所有操作期间（包括清除掉落的或中断的效果），ZIO会将错误汇总到“原因[E]”数据结构中。 该数据结构随时可用。 结果，ZIO始终存储所有错误：它们始终可用，可以根据业务需求进行记录，研究和转换。 <br><br>  Cats IO选择了具有错误信息丢失的模型。  ZIO将通过原因[E]连接两个错误，而Cats IO将“丢失”错误消息之一，例如，通过对发生的错误调用“ e.printStackTrace（）”。 <br><br> 例如，此代码中“ finalizer”中的错误将丢失。 <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 1"</span></span>)).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 2«)))</span></span></code> </pre> <br> 这种跟踪错误的方法意味着您无法本地定位和处理由于各种影响而发生的所有错误。  ZIO允许您使用任何类型的错误，包括“ Throwable”（或更具体的子类型，如“ IOExceptio”或其他自定义异常层次结构），以确保在程序执行期间不会丢失任何错误。 <br><br><h2>  6.异步无死锁 </h2><br>  ZIO和Cats IO都提供了一个构造函数，使您可以通过回调获取代码并将其包装 <br><br> 此功能是通过Cats Effect中的Async管道类提供的： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Data</span></span>] = <span class="hljs-type"><span class="hljs-type">Async</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>].async(k =&gt; getDataWithCallbacks( onSuccess = v =&gt; k(<span class="hljs-type"><span class="hljs-type">Right</span></span>(v)), onFailure = e =&gt; k(<span class="hljs-type"><span class="hljs-type">Left</span></span>(e)) ))</code> </pre><br> 这将创建一个异步效果，该效果在执行时将等待，直到该值出现，然后再继续，所有这些对于效果用户而言都是显而易见的。 因此，函数式编程对于开发异步代码非常有吸引力。 <br><br> 请注意，一旦回调代码变成了效果，就会调用回调函数（在此称为“ k”）。 该回调函数以成功/错误值退出。 调用此回调函数后，将恢复执行效果（先前已暂停）。 <br><br> 如果未将效果分配给任何特定的特殊上下文或未附加该效果的另一个上下文，则ZIO保证该效果将在运行时线程池上恢复执行。 <br><br>  Cats IO恢复对回调线程的影响。 这些选项之间的差异非常深：导致回调的线程不希望回调代码永远执行，而只允许在控件返回之前稍有延迟。 另一方面，Cats IO根本不提供这样的保证：调用线程，启动回调可能冻结，等待执行控制返回时的不确定时间。 <br><br>  Cats Effect中的竞争数据结构的早期版本（“ Deferred”，“ Semaphore”）恢复了无法将执行控制权返回给调用线程的效果。 结果，在其中发现了与死锁和执行调度程序损坏有关的问题。 尽管已发现所有这些问题，但仅在Cats Effect中解决了竞争数据结构的问题。 <br><br> 使用与Cats IO中类似的方法的用户代码会遇到此类麻烦，因为此类任务是不确定的，因此在运行时错误很少会发生，这使得调试和问题检测变得困难。 <br><br>  ZIO提供了开箱即用的死锁保护和常规任务调度程序，还使用户可以明确选择Cats IO的行为（例如，在“ Promise”上使用“ unsafeRun”，最终会恢复异步效果）。 <br><br> 尽管这些解决方案都不适合所有情况，并且ZIO和Cats IO提供了足够的灵活性来解决所有情况（以不同的方式），但是选择ZIO意味着使用“异步”而无需担心，并迫使您将问题代码置于“ unsafeRun”中，已知会导致死锁 <br><br><h2>  7.与未来兼容 </h2><br> 对于大量代码库而言，使用Scala标准库中的“ Future”是现实。  ZIO带有“ fromFuture”方法，该方法提供了现成的执行上下文： <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fromFuture(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ec =&gt; <span class="hljs-comment"><span class="hljs-comment">// Create some Future using `ec`: ??? )</span></span></code> </pre> <br> 当此方法用于包装效果中的Future时，ZIO可以设置执行Future的位置，而其他方法（例如evalOn）将Future正确地传输到所需的执行上下文。  Cats IO接受使用外部“ ExecutionContext”创建的“ Future”。 这意味着Cats IO无法根据evalOn或shift方法的要求移动Future的执行。 此外，这给用户增加了确定Future的执行上下文的负担，这意味着选择范围狭窄且环境独立。 <br><br> 由于可以忽略提供的ExecutionContext，因此ZIO可以表示为Cats IO功能的总和，在通常情况下可以确保与Future的交互更加顺畅和准确，但是仍然有例外。 <br><br><h2>  8.阻塞IO </h2><br> 如文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">线程池。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用ZIO的最佳做法</a> ，对于服务器应用程序，至少需要两个单独的池才能实现最大效率： <br><br><ul><li> 用于CPU /异步效果的固定池； </li><li> 动态的，并可能增加阻塞线程的数量。 </li></ul><br> 在固定线程池上运行所有影响的决定有一天会导致死锁，而在动态池上触发所有影响则可能导致性能损失。 <br><br> 在JVM上，ZIO提供了两种支持阻塞效果的操作： <br><br><ul><li>  “阻塞（效果）运算符，它在具有良好预设的阻塞线程池中切换某种效果的执行，可以根据需要更改这些预设”； </li><li> «effectBlocking(effect)» ,          ,        . </li></ul><br>     ,     ,       ,       «blocking».   ,    -    ,  ,       «effectBlocking»     ,    ZIO  (  ). <br><br> Cats IO    ,         .    ,     «blocking»,    «evalOn», , ,         . <br><br>           (      ZIO)         (,        ),          . <br><br><h2> 9.   </h2><br>  ,      Scala,          : <br><br><ul><li> «ReaderT»/ «Kleisli»,       ; </li><li> «EitherT»,      ( «OptionT»,     «EitherT»   «Unit»    ). </li></ul><br>    ,          (, http4s   «Kleisli»  «OptionT»).        («effect totation»), ZIO   «reader»  «typed error»      ZIO.         «reader»  «typed error» , ZIO    ,    . , «Task[A]»,    «reader»  «typed errors». <br><br>   ZIO     ()      - .  ,      ZIO     ,      . <br><br> Cats IO    .  ,  ,   «reader»  «typed errors»      «state», «writer»  ,      . <br><br> ZIO     8   Cats IO    .               ,          Scala          . <br><br><h2> 10.   </h2><br> ZIO   ,        ,      . ,           Scala,      . <br><br>   ZIO   2000  ,    «typed errors»  ,       —     375    .        Scala ,      .     ,      ,         . <br><br>           : <br><br><ul><li>      ; </li><li>        ; </li><li>  ,       ; </li><li>       . </li></ul><br>         .   , -    ,      . <br><br> -            .        ,     .      ZIO    . Cats IO    ,     ,  ZIO ( ,       ). <br><br><h2> 11.   </h2><br>  ZIO   ,     ,  -       . <br><br><ul><li>  ,  : «ZIO. succeed»  «Applicative[F].pure», «zip»  «Apply[F].product», «ZIO.foreach»  «Traverse[F].traverse». <br></li><li>         (Cats, Cats Effect, Scalaz     ). </li><li>  ,       (  «Runtime»,      Cats Effect  -   Cats Effect).  —        Cats IO. </li><li>    . </li><li>         . : "zip"/"zipPar", "ZIO.foreach"/"ZIO.foreachPar", "ZIO.succeed"/"ZIO.succeedLazy«. <br></li><li>      ,        «».   ZIO    IDE. </li><li>      Scala  ZIO  : «ZIO.fromFuture», «ZIO.fromOption», «ZIO.fromEither», «ZIO.fromTry». </li><li>         «». </li></ul><br> ,          Scala,    ,  ZIO   ,       ,   ,   ZIO,     . Cats IO     ,        Cats. <br><br>     ,      ,     ,       ( , ,    ). <br><br><h2> 12.  </h2><br> ZIO —  - ,           . <br><br>     : <br><br><ul><li>     ,  «Ref», «Promise», «Queue», «Semaphore»   «Stream»    //; </li><li> STM,       , ,     ; </li><li> «Schedule»,    ; </li><li>    «Clock», «Random», «Console»  «System» ,     ; </li><li>      ,    . </li></ul><br> -   Cats IO    .    Cats IO  ,      (  )      . <br><br><h2> 结论 </h2><br>  Cats Effect      Scala-,   ,    . <br><br>  ,   Cats Effect,    ,         Cats Effect : Cats IO, Monix, Zio. <br><br>    ,      .        ,    , ,  : ZIO  Cats Effect    . <br><br><blockquote>          Scala      —    .          ,   Scala. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ScalaConf  ,   18     ,     John A De Goes  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN472386/">https://habr.com/ru/post/zh-CN472386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN472372/index.html">Android自动化 超级轻松的指南来创建您的第一个Espresso测试</a></li>
<li><a href="../zh-CN472374/index.html">为什么我们将服务器移至冰岛</a></li>
<li><a href="../zh-CN472378/index.html">闪存可靠性：预期和意外。 第2部分。USENIX协会的XIV会议。 文件存储技术</a></li>
<li><a href="../zh-CN472380/index.html">MIRO-一个开放的室内机器人平台</a></li>
<li><a href="../zh-CN472384/index.html">从开发人员的角度看Android更新</a></li>
<li><a href="../zh-CN472388/index.html">沃尔玛宣布亚马逊价格战</a></li>
<li><a href="../zh-CN472392/index.html">录音带的上升，下降和可能的归还-我们处理神话并概述情况</a></li>
<li><a href="../zh-CN472394/index.html">评估人工智能对海上石油和天然气的影响</a></li>
<li><a href="../zh-CN472396/index.html">Columnstore中的4秒内环游世界（第1部分）</a></li>
<li><a href="../zh-CN472402/index.html">RTMP视频通话流</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>