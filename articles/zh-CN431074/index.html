<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛽️ 🚾 📥 JavaScript指南第8部分：ES6功能概述 👬 👩🏽‍🏫 👩🏽‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，在JavaScript手册翻译的第八部分中，我们将回顾ES6标准发布后出现在其中的语言的功能。 一种或另一种方式是，我们较早地遇到了许多此类机会，其中更详细地介绍了这些机会，而某些地方则视为理所当然。 本指南的这一部分旨在与我们之前未涉及的一些主题的公开内容一起，以简化现代JavaScript...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript指南第8部分：ES6功能概述</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431074/"> 今天，在JavaScript手册翻译的第八部分中，我们将回顾ES6标准发布后出现在其中的语言的功能。 一种或另一种方式是，我们较早地遇到了许多此类机会，其中更详细地介绍了这些机会，而某些地方则视为理所当然。 本指南的这一部分旨在与我们之前未涉及的一些主题的公开内容一起，以简化现代JavaScript领域中新手开发人员的知识。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：第一个程序，语言功能，标准</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分：代码样式和程序结构</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：变量，数据类型，表达式，对象</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4部分：功能</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5部分：数组和循环</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6部分：异常，分号，通配符文字</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7部分：严格模式，此关键字，事件，模块，数学计算</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8部分：ES6功能概述</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9部分：ES7，ES8和ES9标准概述</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">关于ES6</font> </h2><br>  ES6标准可以更正确地称为ES2015或ECMAScript 2015（这些是其官方名称，尽管每个人都称其为ES6），它在前一个标准ES5.1发行4年后才出现。 开发进入ES5.1标准的所有内容大约花了十年时间。 如今，此标准中出现的所有内容都已成为JS开发人员的常用工具。 应当指出，ES6对语言进行了重大更改（同时保持了与以前版本的向后兼容性）。 为了理解这些变化的严重性，可以注意到描述ES5标准的文档的大小约为250页，而标准ES6在已经约600页的文档中进行了描述。 <br><br>  ES2015标准最重要的创新列表可以包括以下内容： <br><br><ul><li> 箭头功能 </li><li> 承诺 </li><li> 发电机 </li><li>关键字<code>let</code>和<code>const</code> </li><li> 班级 </li><li> 模组 </li><li> 模板文字支持 </li><li> 支持默认功能参数 </li><li> 点差运算符 </li><li> 破坏性分配 </li><li> 增强对象文字 </li><li>  <code>for...of</code>循环 </li><li> 支持<code>Map</code>和<code>Set</code>数据结构 </li></ul><br> 考虑这些可能性。 <br><br><h2>  <font color="#3AC1EF">箭头功能</font> </h2><br> 箭头功能改变了JavaScript代码的外观。 就外观而言，它们的使用使函数声明更短，更容易。 这是一个常规函数的声明。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br> 但是箭头功能几乎相同（尽管与上面并不完全相似）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br> 如果箭头函数的主体仅包含一行，则必须从该函数返回其结果，那么它的编写会更短。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething()</code> </pre> <br> 如果箭头功能仅使用一个参数，则可以按如下所示编写它。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething(param)</code> </pre> <br> 应当指出，随着箭头功能的出现，普通功能并未消失，它们仍然可以在代码中使用，它们的工作方式与以前相同。 <br><br><h2>  <font color="#3AC1EF">箭头功能中的此关键字功能</font> </h2><br> 箭头函数没有自己的<code>this</code>值；它们从执行上下文继承它。 <br><br> 这解决了这个问题，为此，在使用常规函数时，必须使用诸如<code>var that = this</code>来保留上下文。 但是，如本手册前面的部分所示，此更改严重影响了使用箭头功能的功能及其应用范围。 <br><br><h2>  <font color="#3AC1EF">承诺</font> </h2><br> 承诺使您摆脱称为“回调地狱”的众所周知的问题，尽管它们的使用暗示使用相当复杂的结构。 在ES2017标准中，基于Promise的<code>async/await</code>构造的出现解决了此问题。 <br><br>  JavaScript开发人员在ES2015标准出现之前就使用了promise，为此使用了各种库（例如jQuery，q，deferred.js，誓言）。 这表明了该机制的重要性和相关性。 不同的库以不同的方式实现它，在这一领域中标准的出现可以认为是一个非常积极的事实。 <br> 这是使用回调函数（回调）编写的代码。 <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br> 使用promise，可以将其重写如下。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) wait().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait() }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">发电机</font> </h2><br> 生成器是特殊功能，可以暂停其执行并继续执行。 这允许在生成器空闲时执行另一个代码。 <br><br> 生成器自行决定需要暂停并允许另一个“等待”的代码执行。 同时，生成器有机会在其等待结果的操作完成后继续执行。 <br><br> 这一切都归功于一个简单的关键字<code>yield</code> 。 在生成器中找到此关键字后，其执行将暂停。 <br> 生成器可以使用此关键字包含许多行，从而多次暂停其执行。 生成器使用<code>*function</code>构造进行声明。 对于诸如C，C ++或Go之类的语言中使用的指针解引用运算符之类的东西，不应在单词<code>function</code>前使用星号。 <br><br> 生成器标志着新的JavaScript编程范例的出现。 特别是，它们允许在生成器和其他代码之间进行双向数据交换，并允许创建不会“挂起”程序的长寿命<code>while</code>循环。 <br><br> 考虑一个示例，说明发电机运行的特征。 这是发电机本身。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doubleThat = <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (input / <span class="hljs-number"><span class="hljs-number">2</span></span>))   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> another = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (doubleThat)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (input * doubleThat * another) }</code> </pre> <br> 使用此命令，我们对其进行初始化。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calc = calculator(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br> 然后我们转向它的迭代器。 <br><br><pre> <code class="javascript hljs">calc.next()</code> </pre> <br> 该命令启动迭代器，它返回这样的对象。 <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br> 在这里发生以下情况。 该代码使用传递给生成器构造函数的<code>input</code>值执行函数。 执行生成器代码，直到在其中找到<code>yield</code>关键字为止。 此时，它返回将<code>input</code>除以<code>2</code>的结果，由于<code>input</code>为<code>10</code> ，因此得出数字<code>5</code> 。 由于有了迭代器，我们得到了这个数字，并伴随着它表明生成器尚未完成（迭代器返回的对象中的<code>done</code>属性设置为<code>false</code> ），也就是说，该函数仅被暂停了。 <br> 下次调用迭代器时，我们将数字<code>7</code>传递给生成器。 <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre> <br> 响应于此，迭代器将下一个对象返回给我们。 <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">14</span></span> }</code> </pre> <br> 在这里，数字<code>7</code>用于计算<code>doubleThat</code>值。 <br><br> 乍一看， <code>input / 2</code>代码似乎有点像某个函数的参数，但这只是第一次迭代时返回的值。 在这里，我们跳过此值，并使用新的输入值<code>7</code>乘以<code>2</code> 。 之后，我们获得第二个<code>yield</code>关键字，结果，第二次迭代中获得的值为<code>14</code> 。 <br><br> 在下一次迭代（即最后一次迭代）中，我们将数字<code>100</code>传递给生成器。 <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br> 作为响应，我们得到以下对象。 <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> value: <span class="hljs-number"><span class="hljs-number">14000</span></span> }</code> </pre> <br> 迭代完成（在生成器中不再找到<code>yield</code>关键字），在对象中返回计算表达式<code>(input * doubleThat * another)</code>的结果，即<code>10 * 14 * 100</code>并指示迭代器已完成（ <code>done: true</code> ）。 <br><br><h2>  <font color="#3AC1EF">关键字let和const</font> </h2><br>  JavaScript一直使用<code>var</code>关键字来声明变量。 这样的变量具有功能范围。 使用<code>let</code>和<code>const</code>关键字分别可以声明具有块范围的变量和常量。 <br><br> 这意味着，例如，在循环中， <code>if</code>块内或由花括号限制的常规代码块内使用<code>let</code>关键字声明的变量将不会超出该块。 用<code>var</code>声明的变量不保存在此类块中，而是在声明它们的级别的函数中可用。 <br><br>  <code>const</code>关键字的工作方式与<code>let</code>一样，但是使用它，可以声明不可变的常量。 <br><br> 在现代JS代码中，很少使用<code>var</code>关键字。 它让位于<code>let</code>和<code>const</code>关键字。 同时，这似乎很不寻常，但是<code>const</code>关键字在今天已被广泛使用，这表明在现代编程中实体豁免的思想很流行。 <br><br><h2>  <font color="#3AC1EF">班级</font> </h2><br> 事实证明，JavaScript是使用原型继承模型的唯一极为广泛的语言。 在这种环境下，程序员从实现基于类的继承机制的语言切换到JS感到不舒服。  ES2015标准引入了JavaScript中的类支持。 这本质上是使用原型围绕JS内部机制的“语法糖”。 但是，这会影响JS应用程序的精确编写方式。 <br><br>  JavaScript继承机制现在看起来像其他面向对象语言中的类似机制。 <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name } hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, I am '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name + <span class="hljs-string"><span class="hljs-string">'.'</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.hello() + <span class="hljs-string"><span class="hljs-string">' I am an actor.'</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomCruise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Actor(<span class="hljs-string"><span class="hljs-string">'Tom Cruise'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(tomCruise.hello())</code> </pre> <br> 该程序向控制台显示文本“ <code>Hello, I am Tom Cruise. I am an actor</code> ” <code>Hello, I am Tom Cruise. I am an actor</code>  <code>Hello, I am Tom Cruise. I am an actor</code> 。 <br> 在JS类中，无法声明实例变量；必须在构造函数中对其进行初始化。 <br><br><h3>  <font color="#3AC1EF">类构造函数</font> </h3><br> 类有一个特殊的<code>constructor</code>方法，当使用<code>new</code>关键字创建类的实例时会调用该方法。 <br><br><h3>  <font color="#3AC1EF">super关键字超级</font> </h3><br>  <code>super</code>关键字使您可以从后代类访问父类。 <br><br><h3>  <font color="#3AC1EF">▍吸气和吸气</font> </h3><br> 属性的getter可以如下设置。 <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ get fullName() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.firstName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.lastName}</span></span></span><span class="hljs-string">`</span></span> } }</code> </pre> <br> 设置器的说明如下。 <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ set age(years) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.theAge = years } }</code> </pre> <br> 它们与getter和setter一起使用，就好像它们不是函数而是对象的普通属性一样。 <br><br><h2>  <font color="#3AC1EF">模组</font> </h2><br> 在ES2015标准之前，有几种使用模块的竞争方法。 特别是，我们正在谈论RequireJS和CommonJS技术。 这种情况导致JS开发人员社区出现了分歧。 <br><br> 如今，由于ES2015中模块的标准化，这种情况正在逐渐正常化。 <br><br><h3>  <font color="#3AC1EF">▍导入模块</font> </h3><br> 使用形式<code>import...from...</code>的结构<code>import...from...</code> 这里有一些例子。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { React, Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyLibrary <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍导出模块</font> </h3><br> 该模块的内部机制与外界隔离，但您可以从该模块导出它可以提供其他模块的所有内容。 这是使用<code>export</code>关键字完成的。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">▍模板文字</font> </h3><br> 模板文字是在JavaScript中描述字符串的新方法。 这是它的外观。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aString = <span class="hljs-string"><span class="hljs-string">`A string`</span></span></code> </pre> <br> 此外，使用模板文字的语法可以将表达式嵌入字符串中并进行插值。 这是使用<code>${a_variable}</code>格式的构造完成的。 这是其用法的一个简单示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-comment"><span class="hljs-comment">//something test</span></span></code> </pre> <br> 这是一个更复杂的示例，说明了评估任何表达式并将其结果替换为字符串的能力。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str2 = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${foo() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span></code> </pre> <br> 由于使用了模板文字，声明多行字符串变得更加容易。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str3 = <span class="hljs-string"><span class="hljs-string">`Hey this string is awesome!`</span></span></code> </pre> <br> 将其与使用ES2015之前的语言中可用功能描述多行字符串时需要做的比较。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">'One\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Two\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Three'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">默认功能参数</font> </h2><br> 现在，函数支持默认情况下使用的参数-如果在调用函数时未将相应的参数传递给它们，则这些函数将被支持。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, testing = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } foo()</code> </pre> <br><h2>  <font color="#3AC1EF">点差运算符</font> </h2><br> 扩展运算符（扩展运算符）使您可以“扩展”数组，对象或字符串。 该运算符看起来像三个点（ <code>...</code> ）。 首先，考虑一个数组示例。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br> 这是基于此数组创建新数组的方法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [...a, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]</code> </pre> <br> 这是创建数组副本的方法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = [...a]</code> </pre> <br> 该运算符还可以处理对象。 例如，这是使用它来克隆对象的方法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newObj = { ...oldObj }</code> </pre> <br> 将扩展运算符应用于字符串，可以将其转换为数组，该数组的每个元素都包含一个来自此字符串的字符。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrayized = [...hey] <span class="hljs-comment"><span class="hljs-comment">// ['h', 'e', 'y']</span></span></code> </pre> <br> 除了其应用程序的上述变体之外，此运算符在调用需要正常参数列表的函数并将这些参数传递给它们的数组时方便使用。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) =&gt;</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] f(...a)</code> </pre> <br> 以前，这是使用<code>f.apply(null, a)</code>形式的构造完成的，但是这样的代码更难编写，并且可读性更差。 <br><br><h2>  <font color="#3AC1EF">破坏性分配</font> </h2><br> 例如，解构分配技术允许获取一个对象，从该对象中提取一些值，然后将其放入命名的变量或常量中。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">'Tom'</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">'Cruise'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actor</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">54</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: name, age} = person</code> </pre> <br> 在这里， <code>firstName</code>和<code>age</code>属性是从对象中检索的。 将<code>age</code>属性写入以相同名称声明的常量，并且在提取之后， <code>firstName</code>属性属于常量<code>name</code> 。 <br><br> 破坏性分配也适用于处理数组。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, , , fifth] = a</code> </pre> <br>  <code>first</code> ， <code>second</code>和<code>fifth</code>常数分别获取数组的第一，第二和第五个元素。 <br><br><h2>  <font color="#3AC1EF">增强对象文字</font> </h2><br>  ES2015极大地扩展了使用对象文字描述对象的能力。 <br><br><h3>  <font color="#3AC1EF">▍简化对象中变量的包含</font> </h3><br> 以前，为了将变量分配给对象的属性，必须使用以下构造。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">something</span></span>: something }</code> </pre> <br> 现在可以像这样完成同一件事。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { something }</code> </pre> <br><h3>  <font color="#3AC1EF">▍原型</font> </h3><br> 现在可以使用以下结构设置对象的原型。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject }</code> </pre> <br><h3>  <font color="#3AC1EF">super关键字超级</font> </h3><br> 使用<code>super</code>关键字，对象可以访问原型对象。 例如，要调用与这些对象本身的方法具有相同名称的方法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'zoo'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject, test() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.test() + <span class="hljs-string"><span class="hljs-string">'x'</span></span> } } x.test() <span class="hljs-comment"><span class="hljs-comment">//zoox</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">property计算出的属性名称</font> </h3><br> 计算的属性名称是在对象创建阶段形成的。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { [<span class="hljs-string"><span class="hljs-string">'a'</span></span> + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + <span class="hljs-string"><span class="hljs-string">'b'</span></span>]: <span class="hljs-string"><span class="hljs-string">'z'</span></span> } x.a_b <span class="hljs-comment"><span class="hljs-comment">//z</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">对于...的循环</font> </h2><br>  2009年，在ES5标准中，出现了<code>forEach()</code>循环。 这是一种有用的设计，其缺点是这样的循环非常不方便中断。 在需要在正常完成循环之前中断循环执行的情况下，经典的<code>for</code>循环更为合适。 <br><br>  ES2015出现了<code>for...of</code>循环，一方面，其简洁的语法和<code>forEach</code>便利性使其与众不同，另一方面，它支持早期退出循环的可能性。 <br><br> 这里有两个<code>for...of</code>循环示例。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    for (const v of ['a', 'b', 'c']) { console.log(v); } //           entries() for (const [i, v] of ['a', 'b', 'c'].entries()) { console.log(i, v); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">映射并设置数据结构</font> </h2><br>  ES2015引入了<code>Map</code>和<code>Set</code>数据结构（以及其“弱”版本<code>WeakMap</code>和<code>WeakSet</code> ，它们的使用提高了“垃圾收集器”的性能-负责管理JS引擎中的内存的机制）。 这些是非常流行的数据结构，在正式实施之前，必须使用可用的语言工具来模仿它们。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 今天，我们回顾了ES2015标准的功能，这些功能极大地影响了该语言的当前状态。 我们的下一个主题将是ES2016，ES2017和ES2018标准的功能。 <br><br>  <b>亲爱的读者们！</b> 您发现ES6标准的哪些创新最有用？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431074/">https://habr.com/ru/post/zh-CN431074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431064/index.html">刚性程序员宣言</a></li>
<li><a href="../zh-CN431066/index.html">DEFCON 16.我怎么能抓住你？ 让我列出方法。 第二部分</a></li>
<li><a href="../zh-CN431068/index.html">教育的艺术：老虎机的思想</a></li>
<li><a href="../zh-CN431070/index.html">原吃吗 我们正在谈论现代IT专家的饮食习惯</a></li>
<li><a href="../zh-CN431072/index.html">JavaScript指南第7部分：严格模式，此关键字，事件，模块，数学</a></li>
<li><a href="../zh-CN431076/index.html">2018年最受欢迎的Node.js框架</a></li>
<li><a href="../zh-CN431078/index.html">JavaScript错误处理指南</a></li>
<li><a href="../zh-CN431080/index.html">如何组织远程办公室而不失去太空团队</a></li>
<li><a href="../zh-CN431082/index.html">Kotlin：寻找营销主管</a></li>
<li><a href="../zh-CN431084/index.html">在任何无法理解的情况下-编写脚本</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>