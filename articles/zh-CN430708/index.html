<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏿 ⏸️ 🦑 井字游戏“无国界” 🆘 🎸 📩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="井字游戏...我敢肯定，每个人都玩过。 该游戏的简单性非常吸引人，尤其是当您将时钟拖到课程中的某个位置（一对夫妇）时，除了笔记本纸和一支简单的铅笔之外，什么都没有。 我不知道谁是第一个猜出要在9个正方形内画十字和圆形的人，但是从那以后，游戏的需求就丝毫没有减少，尤其是因为人们提出了很多游戏变种。 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>井字游戏“无国界”</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430708/">井字游戏...我敢肯定，每个人都玩过。 该游戏的简单性非常吸引人，尤其是当您将时钟拖到课程中的某个位置（一对夫妇）时，除了笔记本纸和一支简单的铅笔之外，什么都没有。 我不知道谁是第一个猜出要在9个正方形内画十字和圆形的人，但是从那以后，游戏的需求就丝毫没有减少，尤其是因为人们提出了很多游戏变种。 <br><br><img src="https://habrastorage.org/webt/pd/gx/-c/pdgx-cibc6880fmwfxt90nxmi-k.jpeg"><br><br> 本文是关于在JavaScript上开发AI以播放井字游戏的这些变体之一的过程：我有很多资料，但我用动画和图片稀释了。 无论如何，至少值得一试。 <br> 此版本的游戏与原始版本之间的区别如下： <br><br><ol><li>  <b>该字段</b>可以任意<b>大</b> （笔记本计算机可以使用多长时间） </li><li> 获胜者是连续放置<b>5件</b> （如果可以这样称呼）的人。 </li></ol><br> 一切都很简单……同时又很复杂：游戏的结果无法像经典模拟游戏一样预先计算。 这种“小预测”夺走了我很多时间和神经。 希望你觉得有趣。 <a name="habracut"></a><br><br><h3> 在开始之前 </h3><br> 我被迫提前为文章的数量道歉，并且在某些地方还不太清楚地表达思想，但是，我不能挤鸡群而不损失内容和质量。 <br> 我建议您首先熟悉<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结果</a> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代号</a> <br><br> 热键和命令： <br><br><ul><li>  <b>D</b> -AI将为您迈出第一步 </li><li>  <b>T-</b>查看细胞重量 </li><li> 在控制台中编写<b>SHOW_WEIGHTS = true</b>可以查看所有已分析单元的权重。 </li></ul><br><h3> 让我们开始吧 </h3><br> 您需要从游戏本身的实现开始，即 到目前为止，没有机器人的情况下为两个玩家编写了一个应用程序。 就我的目的而言，我决定使用javascript + jquery + bootstrap4，尽管实际上并没有在其中使用它，但最好保留它-否则表会浮动。 没有什么特别的要说的，关于js，jquery和bootstrap的材料很多。 我只能说我使用了MVC。 无论如何，我不会绝对解释所有代码-已经有很多资料。 <br><br> 这样，运动场就准备好了。 您可以在单元格中设置形状。 但是，任何球员的胜利都没有以任何方式确定。 <br><br><h3> 游戏结束 </h3><br> 当其中一名玩家连续放置<b>5张棋子</b>时，游戏结束。  “很简单！” 我以为 然后他开始扫描场中的所有单元：首先是水平的，然后是垂直的，最后是对角线。 <br><br> 这是一种愚蠢的方法，但它确实有效。 但是，它可以大大改善，我做到了：大多数游戏单元在整个游戏过程中都将保持空白-比赛场地太大，无法完全填充。 由于必须每一步扫描一次，并且一次只能放置一块，因此您只能专注于这一块（单元）：只扫描拥有同一单元的单元的一个水平，垂直和两个对角线。 <br><br> 另外，您无需扫描所有细胞系。 由于游戏的结尾是连续5个块，因此彼此不相隔6个单元的块对我们来说并不重要。 扫描每侧五个单元就足够了。 不明白吗？ 请参见下面的动画。 <br><br><img src="https://habrastorage.org/webt/nt/fj/wu/ntfjwuj6nfabfj2qtedcs4g-fp0.gif"><br><br><div class="spoiler">  <b class="spoiler_title">查看代码</b> <div class="spoiler_text"><pre><code class="javascript hljs">checkWin( cellX, cellY ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newFig = getFig(cellX,cellY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! newFig ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res; res = res || checkLine( cellX, cellY, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//horizontal res = res || checkLine( cellX, cellY, 0, 1 ); //vertical res = res || checkLine( cellX, cellY, 1, 1 ); //diagonal 45 res = res || checkLine( cellX, cellY, 1, -1 ); //diagonal 135 return res; function getFig( x, y ){ return Model.Field[x] &amp;&amp; Model.Field[x][y] ? Model.Field[x][y] : 'b'; } function checkLine( x, y, dx, dy ){ x = +x; y = +y; var score = 0; while( getFig( x - dx, y - dy ) == newFig ){ x -= dx; y -= dy; } while( getFig( x, y ) == newFig ){ x += dx; y += dy; score++; } if( score &gt;= 5 ) return true; return false; } }</span></span></code> </pre> <br></div></div><br><h3> 让我们来看看机器人本身 </h3><br> 因此，我们已经写了一个带有tic-tac-toe的页面。 我们完成了主要任务-AI。 <br> 如果您不知道怎么做，就不能只接受并编写代码：您需要考虑机器人的逻辑。 <br><br> 底线是分析运动场（至少是其中的一部分），并计算场上每个单元的<b>价格（权重）</b> 。 重量最重-最有希望的单元将被机器人放置在那里。 主要困难在于计算一个细胞的重量。 <br><br><h3> 术语学 </h3><br>  <b>十字架和脚趾</b>是数字。 <br>  <b>一次进攻</b>将被称为并排在同一条线上的几个相同的人物。 实际上，这很多。 攻击的次数就是它的<b>威力</b> 。 一个单独的部分也是攻击（力量1）。 <br><br> 在相邻的攻击单元（末端）上可能有空的单元或敌方碎片。 逻辑上可以认为，在“端”有两个空单元的攻击可以朝两个方向发展，这使其更具希望。 攻击“末尾”的空单元数将被称为其<b>潜能</b> 。 电位可以是0、1或2。 <br> 我们将攻击表示如下： <b>[攻击力，潜力]</b> 。 例如， <b>攻击[4：1]</b> 。 <br><br><img src="https://habrastorage.org/webt/1_/pk/e3/1_pke3kve1yjbf6cjjzg3hnnzvm.jpeg"><br>  <i>图1.攻击[4：1]</i> <br><br> 在分析过程中，我们将评估进入特定区域的所有单元格。 每个单元将计算其<b>重量</b> 。 它是根据该单元影响的所有攻击的权重计算的。 <br><br><h3> 分析的实质 </h3><br> 想象一下，在运动场上已经有一个和第二个玩家进行了几次攻击。 其中一位球员出了招（让十字架）。 自然，他将自己移到一个空的单元格，因此他可以： <br><br><ol><li> 发展您的攻击，甚至可能不止一次，以增强攻击力。 可能会发起新的攻击等 </li><li> 防止发展或完全阻止敌人的进攻。 </li></ol><br> 也就是说，我们的主角可以进攻和防守。 或者一次全部完成。 对他来说，第一和第二都很重要。 <br><br> 分析的实质如下： <br><br><ol><li> 机器人将其替换为选中单元格中的数字：首先是一个十字，然后是一个零。 </li><li> 然后，他搜索此类举动收到的所有攻击并总结其权重。 </li><li> 收到的数量就是电池的重量。 </li><li> 对运动场的所有单元执行类似的算法。 </li></ol><br><img src="https://habrastorage.org/webt/ur/rc/qz/urrcqzyrjrnp9oupxjoqc1iu6wg.gif"><br><br> 实际上，我们使用这种算法来检查如果我们这样走会发生什么……以及如果对手这样走会发生什么。 我们期待着一步，并选择最合适的电池-重量最大。 <br><br> 如果一个单元比另一个单元具有更大的权重，那么它会导致产生更多危险的攻击，或者阻止强大的敌人攻击。 一切都是合乎逻辑的……在我看来。 <br> 如果转到该页面并在控制台中写入SHOW_WEIGHTS = true，则可以直观地感觉到算法的操作（将显示单元权重）。 <br><br><h3> 进攻权重 </h3><br> 我动脑筋，带来了这样的攻击和重量对应： <br><br><pre> <code class="javascript hljs">ATTACK_WEIGHT = [[],[],[],[],[],[]]; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">6</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.25</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre><br> 根据经验选择-也许这不是最佳选择。 <br><br> 我为阵列增加了5的攻击力，而且重量过大。 这可以通过以下事实来解释：机器人分析游戏，向前看（将单元格中的数字替换）。 跳过这样的攻击不过是失败。 好吧，还是胜利……取决于谁。 <br><br> 具有高潜力的攻击的价值更高。 <br><br> 在大多数情况下，进攻[4：2]决定了比赛的结果。 如果玩家成功进行了这种攻击，那么对手将不再能够阻止它。 但是，这不是胜利。 即使我们在场上有[4：2]的攻击，敌人也可以更快地完成游戏，所以它的权重低于5的攻击力。请参见下面的示例。 <br><br><img src="https://habrastorage.org/webt/pk/4u/mm/pk4ummarchcw9j4lpkujlmj_iig.jpeg"><br>  <i>图2.攻击[4：2]</i> <br><br><h3> 撕裂袭击 </h3><br> 该段代码未列出。 在这里，我们介绍攻击分隔器的概念，并解释<b>“撕裂攻击”</b>的本质。 <br><br> 请考虑以下情况：替换图形以删除几个空单元格（但不超过5个）时，将再定位一个。 <br><br> 而且，似乎在同一行上有两个相同的数字……在视觉上看起来像是攻击，但实际上并非如此。 这不是命令，因为此类“撕裂”攻击也可能带来潜在威胁。 <br><br> 特别是在这种情况下，对于每次攻击，我们都会计算除数。 最初，其值为1。 <br><br><ol><li> 我们将“撕裂”攻击列为几种普通攻击 </li><li> 我们计算中心攻击和侧方之间的空单元数 </li><li> 对于每个空单元格，将除数增加1 </li><li> 我们照常计算中央攻击的权重，侧面攻击的权重-除以除数 </li></ol><br><img src="https://habrastorage.org/webt/dc/w9/62/dcw9629rd4zdhomn6q2uwi5yxkg.jpeg"><br>  <i>图3.“ Torn攻击”分析。</i>  <i>扫描带有黄色叉号的单元格。</i> <br><br> 因此，AI也将考虑到撕裂的攻击。 实际上，这将是普通攻击，但距离扫描单元越远，对其的影响就越小，因此权重也就越小（这要归功于分隔器）。 <br><br><h3> 攻击搜索算法 </h3><br> 首先，创建<b>一个</b>攻击<b>类</b> 。 该攻击将具有3个属性，这是我之前写的： <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attack</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( cap = 0, pot = 0, div = 1 ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability = cap; <span class="hljs-comment"><span class="hljs-comment">// this.potential = pot; // this.divider = div; // }</span></span></code> </pre><br> 一种将返回给定攻击的权重的<b>方法</b> ： <br><br><pre> <code class="javascript hljs">countWeigth(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ATTACK_WEIGHT[ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.potential ] / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.divider } }</code> </pre><br> 下一个 我们将搜索所有针对一个单元的攻击分为： <br><br><ol><li> 横向搜索 </li><li> 垂直搜索 </li><li>  45度对角线搜索 </li><li>  135度对角线搜索 </li></ol><br> 所有这些都是<b>线路</b> ，可以概括搜索这些线路上的攻击的算法： <b>checkLine class</b> 。 <br><br> 但是，我们不需要检查整个行。 我们感兴趣的最大攻击力是5。当然，有可能产生6的攻击力。 但是对于分析下一局游戏情况的AI来说，它等于6或5。获得其中一种攻击的可能性表明下一局游戏即将结束。 因此，在两种情况下，被分析单元的重量将相同。 <br><br> 类属性： <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">checkLine</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">//,        this.subFig = "×"; //     .    «0» - . this.Attacks = []; //  this.curAttack = new Attack; // (      ) this.iter = 1; //,     this.checkEdge = false;</span></span></code> </pre><br> 必须停在这里，因为可能会出现问题：如果最大攻击力为5，为什么要检查第6个单元格。答案是确定远离攻击中心的潜在位置。 <br><br> 这是一个示例：图片中功率为1的攻击位于扫描区域的边界上。 要发现这种攻击的可能性，您需要“放眼国外”。 <br><br><img src="https://habrastorage.org/webt/cg/hb/0r/cghb0ryfnk7kgmaqhw-67emn0qc.jpeg"><br>  <i>图</i>  <i>3.扫描第6个细胞。</i>  <i>如果不扫描第6个单元，则可能会错误地确定潜在的攻击可能性。</i> <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   this.attackplace = 1; }</span></span></code> </pre><br> 可能根本没有足够的空间来完成某些攻击。 在计算了攻击地点之后，我们可以提前了解哪些攻击是没有希望的。 <br><br><img src="https://habrastorage.org/webt/ww/fy/n4/wwfyn4tolymet3ylnf53hax6gju.jpeg"><br>  <i>图</i>  <i>4.攻击地点</i> <br><br> 算法如下： <br><br>  1）让我们从中央单元开始。 它应该是空的（我们要在其中移动，对吗？但是我们不要忘记，我们的AI必须替换此单元格中的数字来分析下一步移动。我们替换的数字是<b>this.subfig-</b>默认为叉号。由于中心单元在替换后最初将包含某种形状，因此它将属于<b>this.curAttack的</b>攻击： <br><br><ul><li> 其功率将不小于1（中央单元格中的数字） </li><li> 分隔线-1，因为 这是一次集中攻击（它属于被扫描的单元）； </li><li> 电位未知-默认值为0；默认值为0。 </li></ul><br><br> 我们在默认的构造函数值中显示了所有这些点-参见上面的代码。 <br><br>  2）接下来，减少迭代器，在已扫描单元的一侧迭代5个以上的单元。  <b>getAttacks</b>函数<b>（cellX，cellY，subFig，dx，dy）</b>对此负责，其中： <br><br>  <b>cellX，cellY-</b>所检查单元格的坐标 <br>  <b>subFig-</b>我们在选中的单元格中替换的图 <br>  <b>dx，dy-</b>周期中x和y坐标的变化-这是我们设置搜索方向的方式： <br><br><ul><li> 水平（dx = 1，dy = 0） </li><li> 垂直（dx = 0，dy = 1） </li><li> 对角线45（dx = 1，dy = -1） </li><li> 对角线135（dx = 1，dy = 1） </li></ul><br> 从某种意义上讲，这是平行于搜索线的向量。 因此，一个功能将能够在4个方向上搜索，而我们不会再次违反DRY原理。 <br><br> 功能码： <br><br><pre> <code class="javascript hljs">getAttacks( cellX, cellY, subFig, dx, dy ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.substitudeFigure( subFig ); <span class="hljs-comment"><span class="hljs-comment">//  –  ... for( var x = cellX - dx, y = cellY - dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x -= dx, y -= dy ) if( this.checkCell( x, y ) ) break; //: //    (  ) this.turnAround(); //  -    ... for( var x = cellX + dx, y = cellY + dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x += dx, y += dy ) if( this.checkCell( x, y ) ) break; return this.Attacks; }</span></span></code> </pre><br> 请注意，如果checkCell（）返回某些内容，则循环停止。 <br><br>  3）我们检查这些单元格的数字。 <br>  <b>checkCell（x，y）</b>函数负责： <br><br> 首先，将形状写入到<b>fig</b>变量中： <br>  <b>Model.Field</b>是我们的竞争环境。 <br><br><pre> <code class="javascript hljs">checkCell( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fig = Model.Field[x] &amp;&amp; Model.Field[x][y] !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? Model.Field[x][y] : <span class="hljs-string"><span class="hljs-string">'b'</span></span>;</code> </pre><br>  <b>图</b>可以是“ x”，“ o”，“ b”（边界），0（空单元格）。 <br><br><ul><li> 如果这样的数字与中央单元格的图形（ <b>this.subFig</b> ） <b>相符</b> ，则我们继续算法-然后继续扫描攻击，一切都很好，我们本着同样的精神继续前进。 攻击中的额外内容是其功能（ <b>this.curAttack.capability</b> ）和位置（ <b>this.attackplace</b> ）的<b>增强</b> 。 <br><br>  （请参阅下一段中的代码） </li><li> 如果这是不同的数字，则我们从此侧阻止了之前扫描的攻击（this.curAttack）。 我们不会更改攻击参数中的任何内容，而是将其写入攻击数组并退出循环。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'○'</span></span> || fig == <span class="hljs-string"><span class="hljs-string">'×'</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig != fig ){ <span class="hljs-comment"><span class="hljs-comment">//  this.Attacks.push( this.curAttack ); //  return fig; //      } else{ //    this.curAttack.capability++; // +   this.attackplace++; // +   } }</span></span></code> </pre><br></li><li> 如果没有这样的单元，则意味着它们掉出了田野边界，这意味着攻击被阻止了。 我们将其写入所有攻击的数组并退出循环。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'b'</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">// this.Attacks.push( this.curAttack ); return 'b'; }</span></span></code> </pre><br></li><li> 如果您抓住空的笼子，则说明当前攻击已经结束，或者我们正在处理“撕裂攻击”。 加上攻击的可能和地点（因为没有阻止攻击）。 但是，我们并没有跳出循环-也许这是“撕裂式攻击”-我们只是将this.curAttack写入this.Attacks []行的所有攻击数组中。 创建一个新的“当前”攻击，并将其除数增加1（这是一个侧面攻击）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  if( this.curAttack.capability ){ this.curAttack.potential++; this.Attacks.push( this.curAttack ); this.curAttack = new Attack; this.curAttack.potential++; } this.curAttack.divider++; this.attackplace++; }</span></span></code> </pre><br></li></ul><br><br>  4）如果在第5个单元格上该图与中心单元格重合，则攻击“搁置”在边界上，并确定攻击可能性，您必须“检查边界”（ <b>this.checkEdge = true</b> ）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; fig == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig ) <span class="hljs-comment"><span class="hljs-comment">// 5-  this.checkEdge = true; else if( this.iter == 5 ){ if( this.checkEdge ){ if( fig == this.curFig || fig == 0 ) this.curAttack.potential++; this.Attacks.push( this.curAttack ) } return 0; } this.iter++</span></span></code> </pre><br>  <b>checkCell</b>功能已准备就绪。 但是，我们将继续处理<b>checkLine</b>类。 <br><br>  5）完成第一个周期后，您需要“转身”。 我们将迭代器转换为中心和中心攻击（索引为0），将其从攻击数组中删除，并将其设置为当前攻击。 <br><br><pre> <code class="javascript hljs">turnAround(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkEdge = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curAttack = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre><br>  6）接下来，转到当前单元格的另一侧，增加迭代器。 <br> 绝对相同的数字检查。  （已编写代码<b>-getAttacks</b>函数） <br><br>  7）一切，我们将所有攻击集中在一个阵列中。 <br>  <b>checkLine</b>类就是这样<b>...</b>一切都完成了。 <br><br> 好了，那么一切都很简单-为每条线（水平和垂直的两个对角线）创建一个<b>checkLine</b>对象，然后调用<b>getAttacks</b>函数。 也就是说，对于每一行-自己的<b>checkLine</b>对象，以及相应的自己的攻击集。 <br><br> 让<b>getAllAttacks（）</b>函数负责所有这些工作-已经与上述类分开； <br><br><pre> <code class="javascript hljs">getAllAttacks( cellX, cellY ){ <span class="hljs-comment"><span class="hljs-comment">// ,  , //       if( Model.Field[ cellX ][ cellY ] ) return false var cX = []; var cO = []; //   ... cX['0'] = this.getAttacksLine( cellX, cellY, '×', 1, 0 ); cX['90'] = this.getAttacksLine( cellX, cellY, '×', 0, 1 ); cX['45'] = this.getAttacksLine( cellX, cellY, '×', 1, -1 ); cX['135'] = this.getAttacksLine( cellX, cellY, '×', 1, 1 ); //  ... cO['0'] = this.getAttacksLine( cellX, cellY, '○', 1, 0 ); cO['90'] = this.getAttacksLine( cellX, cellY, '○', 0, 1 ); cO['45'] = this.getAttacksLine( cellX, cellY, '○', 1, -1 ); cO['135'] = this.getAttacksLine( cellX, cellY, '○', 1, 1 ); return { //     'x': cX, 'o': cO } } getAttacksLine( cellX, cellY, subFig, dx, dy ){ //      var C = new checkLine; C.getAttacks( cellX, cellY, subFig, dx, dy ); return this.filterAttacks( C ) //   }</span></span></code> </pre><br> 在输出中，我们有一个对象，其中包含针对测试单元的所有攻击 <br><br> 但是，您可能已经注意到某种过滤功能。 它的任务是筛选“徒劳的”攻击： <br><br><ul><li> 零功耗（您永远不知道它们是否会进入阵列） </li><li> 缺少空间的攻击（攻击场所&lt;5） </li><li> 零电位。 </li></ul><br> 但是，如果攻击的功效大于5，则过滤器将跳过它。 该漫游器必须看到此类攻击，它们的筛选将导致游戏结束时出现干扰。 <br><br><pre> <code class="javascript hljs">filterAttacks( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( attackLine.attackplace &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) attackLine.Attacks.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &amp;&amp; a.potential || a.capability &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) res.push( a ) }) attackLine.Attacks = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res }</code> </pre><br><h3> 断点 </h3><br> 是的...再次抱歉！ 因此，当一个错误的举动决定了游戏的结果时，我们将这种情况称为游戏中的情况。 <br><br> 例如，攻击[3：2]是一个断点。 如果对手没有通过在其旁边放置一个棋子来阻止它，那么下一招，我们就已经在运动场上发动了进攻[4：2]-嗯，无论结果如何，比赛的结果都是决定的（在大多数情况下）。 <br><br> 或攻击[4：1]。 打哈欠-游戏可以轻松完成。 <br><br><img src="https://habrastorage.org/webt/bd/vc/d0/bdvcd0jzf2wiiqqm9wupccpgmn4.jpeg"><br>  <i>图5.断点</i> <br><br> 一切都清晰易懂，并且上述算法已经能够考虑断点并及时阻止它们。 该机器人非常期待。 他将看到对手在下一回合能够发起攻击[5：1]，例如其体重为200-这意味着狡猾的书呆子将来到这里。 <br><br> 但是，想象一下一个球员设法在场上获得2个断点的情况。 显然，这没有给对手任何机会，因为 一口气，我们只能阻止一个断点。 如何教我们的AI阻止此类攻击？ <br><br><img src="https://habrastorage.org/webt/bh/qu/79/bhqu79lupldi6d3pshuan0lxcmg.jpeg"><br>  <i>图6. 2个断点</i> <br><br> 很简单，当分析一个单元格时，在其中替换一个单元格时，我们将计算下一个回合将获得的断点数（机器人会看着前进，不要忘记）。 通过计算2个断点，我们将单元重量增加了100。 <br><br> 而现在，该机器人不仅可以防止此类游戏情况，而且还能够创建它们，这使其现在成为更强大的对手。 <br><br><h3> 如何理解攻击是一个断点 </h3><br> 让我们从显而易见的地方开始：任何幂为4的攻击都是一个断点。 错过的一招让我们有机会完成比赛，即 连续放置5件。 <br><br> 此外，如果攻击可能性为2，则我们将多花1圈来阻止此类攻击，这意味着存在一个断点，其功效为3。但是只有一个这样的断点-这是一次攻击[3：2]。 <br><br> 以及更困难的<b>“撕毁式攻击”</b> 。 <br> 我们将只考虑中间有一个空单元的攻击，而不再考虑。 这是因为为了在中间有两个空单元来完成攻击，您需要花费至少2步-这显然不是断点。 <br><br> 我们记得，撕裂攻击被视为几种常规攻击：一次中央攻击和侧面攻击。 中央攻击属于已扫描的单元，侧面分配器有1个以上-这已在上面描述。 <br><br> 查找断点的算法（更轻松，请阅读下文）： <br><br><ol><li> 我们介绍可变<b>分数</b> </li><li> 我们采取集中进攻，我们考虑力量 </li><li> 如果除数不超过2倍，则选择其中一个。 </li><li>  <b>得分</b> -中央和侧面攻击力的总和 </li><li> 如果中央和侧面攻击的可能性为2，则要阻止此类攻击，您需要多转一圈。 因此，分数增加1 </li><li> 如果<b>得分</b> &gt; = 4，则这是一个断点 <br> 实际上，可以简单地列举断点，但断点并不多，但是我并没有立即理解这一点。 </li></ol><br><pre> <code class="javascript hljs">isBreakPoint( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attackLine || ! attackLine.length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centAtk; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">1</span></span> ) centAtk = a; }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.potential == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> score = centAtk.capability; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">//side attack if( centAtk.potential == 2 &amp;&amp; a.potential == 2 ) score++; if( score + a.capability &gt;= 4 ){ res = true; return; } } }) return res; }</span></span></code> </pre><br><h3> 是的，我们最终将所有东西整合在一起 </h3><br> 因此，上面描述了主要的地狱。 是时候从中塑造出一些有用的东西了。 函数<b>countWeight（x，y）</b> -将单元格的坐标作为输入，并返回其权重。 她的内幕是什么？ <br><br> 首先，我们获得该单元所属的所有攻击的数组。  （ <b>getAllAttacks（x，y）</b> ）。 遍历所有行，我们计算断点的数量。 如果有两个断点，我们记得这种情况可以决定游戏的结果，并使单元重量增加100。 <br> 但是，所有断点必须属于一个玩家，因此我必须分两步实施检查：首先进行交叉，然后进行零。 <br><br> 由于在攻击权重数组（ <b>ATTACK_WEIGHTS []</b> ）中，我没有提供6或更高<b>功效的</b>攻击，因此我不得不用5的<b>功效</b>替代攻击。这没有什么区别-它们都导致游戏结束。 <br><br> 好吧，我们总结一下攻击权重-仅此而已。 <br><br> 另一个要点是：为了使机器人在游戏结束时不会愚蠢，当它已经以4的幂进行攻击并考虑当前移动时，有必要显着增加单元的重量以完成这种攻击。 没有这个，AI可以简单地开始防御对手的“危险”攻击，尽管这场比赛似乎将获胜。 最后一步很重要。 <br><br><pre> <code class="javascript hljs">countWeight( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attacks = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getAttacks( x, y ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attacks ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.x, <span class="hljs-string"><span class="hljs-string">'×'</span></span> ); sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.o, <span class="hljs-string"><span class="hljs-string">'○'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> atks, curFig </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weight = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> breakPoints = <span class="hljs-number"><span class="hljs-number">0</span></span>; [ <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"45"</span></span>, <span class="hljs-string"><span class="hljs-string">"90"</span></span>, <span class="hljs-string"><span class="hljs-string">"135"</span></span> ].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> p </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isBreakPoint( atks[p] ) ){ debug( <span class="hljs-string"><span class="hljs-string">"Break point"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ++breakPoints == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; debug( <span class="hljs-string"><span class="hljs-string">"Good cell"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } atks[p].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) a.capability = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability == <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; curFig == Model.whoPlays.char ) weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; weight += a.getWeight(); }); }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weight } }</code> </pre><br> 现在，当为特定单元格调用此函数时，我们将获得其权重。 我们对所有单元格执行此操作，然后选择最佳（权重最高）。 到那里去） <br><br> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>上找到其余的代码。 已经有很多资料，而且我还没有尝试过，它的呈现方式有很多不足之处。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是，亲爱的读者，如果您能读到这一点，那么，我感谢您。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我对结果的看法 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下来吧 </font><font style="vertical-align: inherit;">是的，您可以击败他，但是这样做对我个人而言有点麻烦。</font><font style="vertical-align: inherit;">也许我只是不够小心。</font><font style="vertical-align: inherit;">也尝试一下自己的力量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我知道这很容易，但是我不知道如何。</font><font style="vertical-align: inherit;">我想听听知道或关注这种机器人其他实现的人们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我知道有什么更好的。</font><font style="vertical-align: inherit;">是的...您可以使用众所周知的算法，例如minimax，但是为此，您需要具有博弈论领域的一些知识基础，但不幸的是，我对此并不吹嘘。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将来，我计划将断点分析添加到几个步骤中，这将使该机器人成为更加严重的竞争对手。</font><font style="vertical-align: inherit;">但是，我现在对此实施尚不明确。</font><font style="vertical-align: inherit;">我只有即将举行的课程和不完整的文凭，这让我感到很难过。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谢谢，如果您读完了。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430708/">https://habr.com/ru/post/zh-CN430708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430694/index.html">学习C ++的简短指南：创建内容，时间和内容的方法</a></li>
<li><a href="../zh-CN430700/index.html">一个用于记录在线电影观看次数的统一系统将在俄罗斯开始工作</a></li>
<li><a href="../zh-CN430702/index.html">非常奇怪的训练</a></li>
<li><a href="../zh-CN430704/index.html">人工智能技术如何帮助Aviasales成长：七个例子</a></li>
<li><a href="../zh-CN430706/index.html">新进化论</a></li>
<li><a href="../zh-CN430710/index.html">如果黑色星期五是明天并且您的服务器未准备好怎么办</a></li>
<li><a href="../zh-CN430712/index.html">NeurIPS：如何征服最佳ML会议</a></li>
<li><a href="../zh-CN430714/index.html">VMware收购Heptio-对Kubernetes意味着什么</a></li>
<li><a href="../zh-CN430718/index.html">使用云视频监控对哪些对象有价值？</a></li>
<li><a href="../zh-CN430720/index.html">英特尔实感D435i：较小的更新和较短的历史题外话</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>