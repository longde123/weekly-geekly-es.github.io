<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🚀 🏫 🕟 Grundlagen der Zeiger für Anfänger 🤱 ⛲️ 👨🏿‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 Aufgrund der Verbesserung und Verbilligung der Technologie wächst heute die Menge an Speicher und Verarbeitungsleistung stetig. 

 Nach M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen der Zeiger für Anfänger</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456318/"><h2>  Einführung </h2><br>  Aufgrund der Verbesserung und Verbilligung der Technologie wächst heute die Menge an Speicher und Verarbeitungsleistung stetig. <br><br>  Nach Moores Gesetz: <br><blockquote>  Die Anzahl der auf einem integrierten Schaltkreischip platzierten Transistoren verdoppelt sich alle 24 Monate. </blockquote>  Es ist zu beachten, dass zwei Parameter geändert werden: <br><br><ul><li>  Anzahl der Transistoren </li><li>  Modulabmessungen </li></ul><br>  Die gleichen Prinzipien werden auf die RAM-Größe (DRAM) projiziert. <br><br>  Jetzt ist das Problem des Gedächtnisses nicht akut, da sich die Speichermenge in den letzten 10 Jahren pro Würfel um das 16-fache erhöht hat. <br><a name="habracut"></a><br>  Die meisten High Level Programming Languages ​​(PL) sind bereits "out of the box" und verbergen die Arbeit mit dem Speicher vor dem Programmierer.  Und da diese Frage geschlafen hat, erscheint eine neue Kaste von Programmierern, die nicht verstehen <s>oder</s> nicht verstehen <s>wollen,</s> wie die Arbeit mit dem Gedächtnis funktioniert. <br><br>  In diesem Thema werden die wichtigsten Punkte der Arbeit mit dem Speicher am Beispiel der C ++ - Sprache betrachtet, da es sich um eine der wenigen zwingenden Sprachen handelt, die die direkte Arbeit mit dem Speicher und OOP unterstützt. <br><br><h2>  Wofür ist IT? </h2><br><blockquote>  Es ist erwähnenswert, dass dieser Artikel für Leute gedacht ist, die gerade erst mit C ++ beginnen oder nur eine Vorstellung vom dynamischen Speicher haben möchten. </blockquote><br>  Zur Laufzeit reserviert jedes Programm ein Stück Speicher für sich im DRAM.  Alle anderen freien DRAM-Speicherplätze werden als <u>"Heap"</u> (englisch "Heap") bezeichnet.  Die Zuweisung von Speicher während der Ausführung für die Anforderungen des Programms erfolgt genau aus dem Heap und wird als Zuweisung von dynamischem Speicher bezeichnet. <br><br>  Das ganze Problem ist, dass, wenn Sie sich nicht darum kümmern, den zugewiesenen Speicher zu bereinigen, wenn er nicht mehr benötigt wird, ein sogenannter Speicherverlust auftreten kann, bei dem Ihr System <u>(Programm)</u> einfach hängt.  Ähnlich wie ein Auto, das mitten auf der Straße stehen blieb, weil jemand vergessen hatte, es rechtzeitig aufzutanken. <br><br><div class="spoiler">  <b class="spoiler_title">Was du schon wissen solltest</b> <div class="spoiler_text">  Die meisten modernen PLs sind mit Müllsammlern ausgestattet und löschen ihren Speicher selbstständig. <br>  C ++ hat sich jedoch als eine der APIs mit der schnellsten Leistung etabliert, auch weil die gesamte Arbeit mit dem darin enthaltenen Speicher manuell ausgeführt wird. <br></div></div><br><br><h2>  neu und löschen </h2><br>  Die Speicherzuordnung kann statisch und dynamisch sein.  Die statische Speicherzuweisung wird als einmalige Speicherzuweisung während der Programmkompilierung bezeichnet, und die Größe des statischen Speichers ändert sich zur Laufzeit nicht.  Ein klassisches Beispiel ist die Deklaration einer ganzzahligen Variablen oder eines Arrays.  Was aber, wenn der Programmierer nicht im Voraus weiß, wie viele Elemente im Container benötigt werden? <br>  Die Verwendung von dynamischem Speicher ist ratsam, wenn die Speicherzuweisung für die Anforderungen des Programms nach Bedarf organisiert werden muss. <br>  Der <i>neue</i> Operator ist für die Zuweisung des dynamischen Speichers in C ++ verantwortlich, und <i>delete</i> ist für die <i>Löschung</i> verantwortlich. <br>  Der <i>neue</i> Operator gibt dem Ergebnis seiner Operation einen Zeiger auf eine neue Instanz der Klasse zurück. <br>  Die Syntax lautet wie folgt: <br><br>  |  <b>Datentyp (T1) Zeiger</b> |  * |  <b>Zeigername</b> | = <i>neu</i> |  <b>Typ T1</b> |; <br><br>  Nach dem <i>neuen</i> Operator können Sie beispielsweise den Konstruktor verwenden, um die Felder der Klasse zu initialisieren. <br>  Es ist anzumerken, dass der gleiche Speicherverlust genau dann auftritt, wenn der Programmierer die Kontrolle über seine Zuordnung verliert. <br><blockquote>  Es ist wichtig, sich zu erinnern: <br>  Wenn Sie vergessen haben, den dynamischen Speicher der "verbrauchten" unnötigen Elemente zu löschen, wird früher oder später ein kritischer Moment eintreten, in dem der Speicher einfach nicht mehr benötigt wird. </blockquote><br>  Ein Beispiel für die Speicherzuweisung und deren Reinigung: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main{ <span class="hljs-comment"><span class="hljs-comment">// ,       new int *ptr = new int(); //   cout&lt;&lt;*ptr&lt;&lt;endl; // ,     delete ptr; //  delete     ,         return 0; }</span></span></code> </pre> <br><br>  In diesem Artikel werden die sogenannten „intelligenten“ Zeiger nicht behandelt, da das Thema sehr umfangreich ist. Kurz gesagt: „Intelligente Zeiger automatisieren teilweise das Löschen des Speichers für den Programmierer.“ <br><br><h2>  Zeiger </h2><br>  Zeiger sind für die Arbeit mit dynamischem Speicher in C ++ verantwortlich.  Dies ist ein Thema, von dem Appetit Anfänger verwöhnt. <br><br>  Sie können einen Zeiger mit dem Operator <b>*</b> deklarieren.  Standardmäßig zeigt es auf einen zufälligen Speicherbereich.  Damit wir auf den benötigten Speicherbereich zugreifen können, müssen wir einen Link (Operator <b>&amp;</b> ) an die gewünschte Variable übergeben. <br><br>  Der Zeiger selbst ist einfach die Adresse einer Speicherzelle, und um auf die in dieser Zelle gespeicherten Daten zuzugreifen, muss er dereferenziert werden. <br><h3>  Wichtiger Rückzug </h3><br><blockquote>  Wenn Sie versuchen, den Zeiger ohne Dereferenzierung anzuzeigen, wird anstelle des Werts aus dem Speicherbereich, auf den er zeigt, die Adresse dieses Speicherbereichs angezeigt. <br>  Um einen Zeiger zu dereferenzieren, setzen Sie einfach den Operator <b>*</b> vor seinen Namen. </blockquote><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,          int* pNum= new int(1) ; cout&lt;&lt;*pNum&lt;&lt;endl; //    ,        ,       (   int   ) pNum++; cout&lt;&lt;*pNum&lt;&lt;endl; // ,         return 0; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/ka/bg/0k/kabg0kkojm0kefvksto7cye60ps.png"><br><br>  Anhand solcher Beispiele möchte ich fragen: „Warum ist das überhaupt notwendig, wenn Sie sofort eine Variable ableiten können?“ <br><br>  Ein weiteres Beispiel: <br><br>  Wir haben eine Programmiererklasse, die Mitglieder eines Teams von Programmierern beschreibt, <s>die nichts über Zeiger wissen.</s> <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Programmers</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Programmers(){} Programmers(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iWeight, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iAge){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;weight = iWeight; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;age = iAge; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> weight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     Programmers int size = 9; Programmers *prog [size]; //  Programmers Programmers *ptr = nullptr; //     Programmers       //          for (int i =0;i&lt;size;i++) { ptr=new Programmers(i+100,i); prog[i]=ptr; } return 0; }</span></span></code> </pre> <br>  Auf diese Weise kann das Gedächtnis nach Belieben manipuliert werden.  Und deshalb können Sie sich bei der Arbeit mit dem Gedächtnis "in den Fuß schießen".  Es ist zu beachten, dass die Arbeit mit dem Zeiger viel schneller ist, da der Wert selbst nicht kopiert wird, sondern ihm nur ein Link zu einer bestimmten Adresse zugewiesen wird. <br><br>  Ein so beliebtes Schlüsselwort liefert übrigens einen Zeiger auf das aktuelle Klassenobjekt.  <s>Diese Hinweise sind überall.</s> <br><br>  <b>Ein Beispiel für einen Zeiger im Alltag:</b> <br><br>  Stellen Sie sich eine Situation vor, in der Sie ein Gericht in einem Restaurant bestellen.  Um eine Bestellung aufzugeben, müssen Sie nur auf das Gericht im Menü zeigen und schon werden Sie vorbereitet.  Auf die gleiche Weise geben andere Besucher des Restaurants den gewünschten Menüpunkt an.  Somit ist jede Zeile im Menü ein Zeiger auf die Kochfunktion eines Gerichts, und dieser Zeiger wurde in der Entwurfsphase dieses Menüs selbst erstellt. <br><br><div class="spoiler">  <b class="spoiler_title">Funktionszeiger Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      void Chicken(){ cout&lt;&lt;"Wait 5 min...Chicken is cooking"&lt;&lt;endl; } void JustWater(){ cout&lt;&lt;"Take your water"&lt;&lt;endl; } int main() { //    void   void (*ptr)(); ptr = Chicken; ptr(); ptr=JustWater; ptr(); return 0; }</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ja/kn/0p/jakn0pthuo6au9wx9w_uqlfbd00.png"><br></div></div><br>  Zurück zu unseren Programmierern.  Angenommen, wir müssen jetzt die Klassenfelder in den <b>privaten</b> Bereich verschieben, wie es dem Prinzip der Kapselung von OOP entspricht. Dann müssen wir <b>Getter verwenden</b> , um Lesezugriff auf diese Felder zu erhalten.  Aber stellen Sie sich vor, wir haben nicht 2 Felder, sondern 100, und dafür müssen wir für jedes einen eigenen Accessor schreiben? <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  Natürlich nicht, ich verstehe nicht einmal, warum Sie diesen Spoiler geöffnet haben. <br></div></div><br>  Zu diesem Zweck machen wir einen "Accessor" vom Typ void und übergeben ihm Argumente als Referenz.  Die Übergabe eines Arguments als Referenz bedeutet, dass der Wert des Arguments nicht kopiert wird, sondern nur die Adresse des realen Arguments übertragen wird.  Wenn Sie also den Wert eines solchen Arguments ändern, ändern sich auch die Daten in der Speicherzelle des aktuellen Arguments. <br>  Dies wirkt sich auch auf die Gesamtleistung aus, da das Übergeben eines Arguments als Referenz schneller ist als das Übergeben eines Werts.  Ganz zu schweigen von den großen Elementensammlungen. <br><br>  Beispielsweise <i>ändert</i> die <i>darin enthaltene</i> Methode <i>getParams</i> die eingehenden Argumente und ihre Werte, auch im Bereich, von wo aus sie aufgerufen wurden. <br>  Ein Zeiger hilft uns beim Navigieren im Array.  Aus der Theorie der Datenstrukturen wissen wir, dass ein Array ein kontinuierlicher Speicherbereich ist, dessen Elemente nacheinander angeordnet sind. <br>  Dies bedeutet, dass Sie jedes Element erreichen können, wenn Sie den Wert des Zeigers auf die Anzahl der Bytes ändern, die das Element im Array belegt, bis der Zeiger die Grenzen des Arrays überschreitet. <br>  Erstellen Sie einen weiteren Zeiger, der auf das erste Element des <u>Programmierer-</u> Arrays zeigt. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Programmers</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Programmers(){} Programmers(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iWeight, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iAge){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;weight = iWeight; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;age = iAge; } <span class="hljs-comment"><span class="hljs-comment">//    ,   main     void getParams(int &amp;w, int &amp;a){ w=weight; a=age; } private: int weight; int age; }; int main() { int size = 9; Programmers *prog [size]; Programmers *ptr=nullptr; for (int i =0;i&lt;size;i++) { ptr=new Programmers(i+100,i); prog[i]=ptr; } int w,a; int count = 9; //    //        Programmers **iter = prog; for (int i=0;i&lt;count;i++) { ptr = *iter++; ptr-&gt;getParams(w,a); if(*(iter-1) != nullptr){ delete *(iter-1); ptr = nullptr; } cout&lt;&lt;w&lt;&lt;"\t"&lt;&lt;a&lt;&lt;endl; } return 0; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/6q/9v/pi/6q9vpiibfo8zddb4znzbfkqcvuu.png"><br><br>  In diesem Beispiel möchte ich Ihnen die Essenz der Tatsache vermitteln, dass Sie auf einen anderen Speicherbereich zugreifen können, wenn Sie den Wert der Adresse des Zeigers ändern. <br><br>  Datenstrukturen wie Listen, Vektoren usw.  basierend auf Zeigern und daher als dynamische Datenstrukturen bezeichnet.  Und um über sie zu iterieren, ist es korrekter, Iteratoren zu verwenden.  Ein Iterator ist ein Zeiger auf ein Element der Datenstruktur und bietet Zugriff auf das Element des Containers. <br><br><h3>  Abschließend </h3><br>  Nachdem Sie das Thema Zeiger verstanden haben, wird die Arbeit mit dem Speicher zu einem angenehmen Teil der Programmierung, und insgesamt erscheint ein detailliertes Verständnis der Funktionsweise der Maschine mit dem Speicher und ihrer Verwaltung.  In gewisser Weise steckt eine Philosophie hinter dem Konzept des „Arbeitens mit dem Gedächtnis“.  An Ihren Fingerspitzen ändern Sie die Ladung auf den Platten selbst sehr kleiner Kondensatoren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456318/">https://habr.com/ru/post/de456318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456304/index.html">So veröffentlichen Sie das Konsolendienstprogramm in 1 Minute auf PyPI</a></li>
<li><a href="../de456306/index.html">Mikroelektronik-Technologien an den Fingern: Moores Gesetz, Marketingbewegungen und warum Nanometer jetzt nicht mehr dasselbe sind. Teil 3</a></li>
<li><a href="../de456310/index.html">Logistik der Maßnahme zur getrennten Sammlung von Wertstoffen</a></li>
<li><a href="../de456314/index.html">Ich habe einen Punkt</a></li>
<li><a href="../de456316/index.html">Frontend Weekly Digest (10. - 16. Juni 2019)</a></li>
<li><a href="../de456322/index.html">So holen Sie das Beste aus der Konferenz heraus. Anleitung für die Kleinsten</a></li>
<li><a href="../de456332/index.html">PHP Digest Nr. 158 (3.-17. Juni 2019)</a></li>
<li><a href="../de456334/index.html">Verdiente Unsterblichkeit: Spiele, bei denen Sie sich nicht langweilen konnten</a></li>
<li><a href="../de456336/index.html">11 Tipps zur Verwendung von Redux bei der Entwicklung von React-Anwendungen</a></li>
<li><a href="../de456338/index.html">13 nützliche JavaScript-Einzeiler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>