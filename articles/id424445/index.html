<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏽 🍌 ⬅️ Neil Ford menerjemahkan Microservices sebagai Arsitektur Evolusi 🥟 🅿️ 🗑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami telah menyiapkan terjemahan sebuah artikel oleh Neil Ford, seorang arsitek sistem dan otak ideologis di ThoughtWorks, sebuah perusahaan pengemban...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Neil Ford menerjemahkan Microservices sebagai Arsitektur Evolusi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/luxoft/blog/424445/">  Kami telah menyiapkan terjemahan sebuah artikel oleh Neil Ford, seorang arsitek sistem dan otak ideologis di ThoughtWorks, sebuah perusahaan pengembangan perangkat lunak yang mengotomatiskan pengujian perangkat lunak dan proses penyebaran. <br><br><img align="left" width="140" src="https://habrastorage.org/webt/gi/gn/cm/gigncmbcb8gysz-vdgyt7izb12g.jpeg">  Neil adalah pakar pengembangan perangkat lunak yang diakui yang bekerja di persimpangan desain lincah dan arsitektur sistem.  Dia adalah penulis berbagai artikel, buku, puluhan presentasi video, membuat presentasi di konferensi pengembang terkemuka.  Anda dapat melihat karyanya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nealford.com</a> . <br><a name="habracut"></a><br><h2>  Layanan microser sebagai arsitektur evolusioner </h2><br>  Arsitektur microservice dengan cepat menaklukkan dunia.  Pada bulan Maret, perusahaan penerbitan O'Reilly menyelenggarakan Konferensi Arsitektur Perangkat Lunak O'Reilly yang pertama.  Dan hampir 60% dari laporan dikhususkan untuk aspek-aspek tertentu dari penggunaan layanan-mikro.  Mengapa gaya arsitektur khusus ini tiba-tiba menjadi begitu populer? <br><br>  Arsitektur Microservice adalah gaya desain arsitektur baru yang muncul setelah DevOps dan menggabungkan praktik pengiriman perangkat lunak berkelanjutan.  Ini juga merupakan contoh arsitektur evolusi yang mengikuti prinsip perubahan bertahap dan berkesinambungan dalam beberapa dimensi pada tingkat struktural aplikasi.  Artikel ini membahas beberapa fitur unik dan prinsip keluarga gaya arsitektur ini. <br><br><h2>  Arsitektur evolusioner </h2><br>  Sebelumnya diyakini bahwa unsur-unsur arsitektur "sangat sulit untuk berubah setelah penciptaannya."  Perubahan bertahap adalah prinsip utama arsitektur evolusi.  Ini menarik perhatian umum justru karena perubahan dalam arsitektur selalu sulit untuk diramalkan dan sangat mahal untuk dilakukan.  Jika kemungkinan perubahan evolusioner dibangun ke dalam arsitektur itu sendiri, maka implementasinya menjadi jauh lebih sederhana dan lebih murah, berkontribusi terhadap perubahan dalam pengembangan perangkat lunak dan praktik rilis, serta meningkatkan tingkat fleksibilitas proses secara keseluruhan. <br><br>  Arsitektur Microservice sepenuhnya konsisten dengan ide ini karena ia memiliki <i>Bounded Contexts</i> yang dialokasikan secara logis sesuai dengan Eric Evans 'Domain Driven Design dan diimplementasikan sebagai komponen yang terpisah secara fisik.  Pemisahan ini dicapai melalui penerapan praktik-praktik DevOps seperti penyediaan mesin virtual, pengujian, dan penyebaran otomatis.  Karena setiap layanan dipisahkan dari semua layanan lain (pada tingkat struktural), mengganti satu layanan mikro dengan yang lain semudah menukar lego cubes. <br><br><h2>  Fitur arsitektur evolusioner </h2><br>  Arsitektur evolusi memiliki sejumlah karakteristik umum.  Semua fitur ini akan dijelaskan dalam buku yang akan datang tentang arsitektur evolusi.  Dalam artikel ini kami hanya memberikan beberapa di antaranya. <br><br><h3>  Modularitas dan konektivitas </h3><br>  Kemampuan untuk berbagi komponen dalam batas-batas yang ditentukan dengan baik memberi pengembang manfaat dari perubahan berkelanjutan jika perlu.  Jika arsitekturnya tidak dirancang dan sistemnya tampak seperti bola lumpur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">besar</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur Bola Besar Lumpur</a> ), maka perubahan evolusioner tidak mungkin, karena tidak ada bagian yang dapat dibedakan dalam struktur seperti itu. <br><img src="https://habrastorage.org/webt/tb/ll/no/tbllnoetavmhatzxhtqqzfipcvy.png"><br><br>  <i>[Hubungan antara kelas (menunjuk sekeliling) dalam segumpal besar kotoran dari proyek klien yang tidak disebutkan namanya.]</i> <br><br>  Interkoneksi komponen yang salah menghambat evolusi sistem karena fakta bahwa membuat perubahan dapat secara tak terduga mempengaruhi bagian lain dari sistem.  Semua arsitektur evolusi menyediakan beberapa tingkat modularitas, biasanya pada tingkat arsitektur teknis (misalnya, arsitektur berlapis). <br><br><h3>  Organisasi di sekitar peluang bisnis </h3><br>  Dipengaruhi oleh prinsip-prinsip desain berorientasi subjek dalam arsitektur sukses modern, modularitas di tingkat domain semakin banyak digunakan.  Arsitektur berbasis layanan berbeda dari arsitektur berorientasi layanan tradisional (SOA) terutama dalam strategi alokasi layanannya.  Arsitektur berorientasi layanan secara ketat dibagi oleh tingkat teknis, sedangkan arsitektur berbasis layanan dibangun terutama di bagian-bagian dari area subjek yang ditentukan oleh layanan-layanan microser. <br><br><h3>  Eksperimennya </h3><br>  Melakukan eksperimen adalah salah satu keuntungan signifikan yang diberikan arsitektur evolusi pada bisnis.  Kemampuan untuk dengan mudah melakukan perubahan kecil pada aplikasi menyediakan penggunaan praktik penerapan terus menerus yang umum seperti pengujian A / B, pengujian untuk sekelompok pengguna terbatas (Canary release), dan lainnya.  Arsitektur microservice sering dibangun berdasarkan routing layanan panggilan, yang memungkinkan untuk menggunakan beberapa versi layanan dalam seluruh ekosistem.  Ini pada gilirannya membuka peluang besar untuk eksperimen dan perubahan fungsionalitas yang ada.  Pada akhirnya, ketika mengembangkan aplikasi bisnis, lebih sedikit waktu yang dihabiskan untuk membahas rencana dan simpanan, dan pengembangan dilakukan terutama dalam mode pengujian hipotesis cepat. <br><br><h2>  Prinsip Arsitektur Evolusi </h2><br>  Gambaran arsitektur evolusi yang lebih lengkap dapat diperoleh dengan mengenal prinsip-prinsip dasarnya.  Prinsip-prinsip ini berkaitan dengan berbagai karakteristik arsitektur itu sendiri dan metode desainnya.  Bagian dari prinsip-prinsip berkaitan dengan pilihan saat membuat keputusan arsitektur dalam proses perancangan sistem. <br><br><h3>  Fungsi kebugaran </h3><br>  Penting untuk membedakan antara yang muncul (terbentuk sebagai hasil dari proses desain) dan arsitektur evolusioner - ini sangat penting.  Seperti metode perhitungan evolusioner (seperti algoritma genetika), fungsi kebugaran arsitektur menetapkan tujuan dalam desain arsitektur.  Untuk beberapa sistem, persyaratan utama adalah waktu kerja yang lama, untuk yang lain, kinerja tinggi atau keamanan. <br><br><img src="https://habrastorage.org/webt/kh/c3/_g/khc3_gz_0ocw-kpiakepfit73ak.png"><br>  <i>[Grafik radar digunakan untuk menyoroti fungsi kebugaran penting yang relevan dengan sistem perangkat lunak ini.]</i> <i><br></i> <br>  Jika Anda menentukan terlebih dahulu fungsi kebugaran untuk sistem tertentu, ini akan membantu di masa depan untuk membuat keputusan yang tepat secara tepat waktu.  Untuk solusi arsitektur yang berbeda, Anda dapat menghitung fungsi kebugaran, dan jika nilainya menjadi lebih baik, ini berarti bahwa arsitektur berkembang ke arah yang benar. <br><br><h3>  Perhatian pada poin nyeri </h3><br>  Banyak metode kerja yang digunakan dalam penyediaan perangkat lunak yang berkelanjutan dan pengembangan arsitektur yang berkembang didasarkan pada prinsip "perhatian pada titik-titik nyeri" yang dirumuskan oleh komunitas Pemrograman eXtreme.  Ketika momen muncul dalam karya desain yang dapat menjadi sumber masalah (titik nyeri), perlu untuk memperhatikan mereka sesegera mungkin.  Ini akan membantu untuk mengidentifikasi potensi masalah di muka dan menghilangkannya dalam urutan kerja.  Praktik pengiriman kontinu yang umum, seperti pipa penempatan, penyediaan otomatis mesin virtual, dan migrasi basis data, ketika merancang arsitektur evolusi, sangat menyederhanakan penghapusan titik nyeri selama fase perubahan. <br><br><h3>  Titik keputusan </h3><br>  Perbedaan utama antara arsitektur tradisional dan evolusi adalah ketika keputusan penting dibuat.  Keputusan ini mungkin terkait dengan struktur aplikasi, tumpukan teknologi, alat individu, atau pola komunikasi.  Dalam hal merancang arsitektur tradisional, keputusan seperti itu dibuat pada tahap awal, sebelum menulis kode.  Dalam proses pengembangan arsitektur evolusioner, setiap keputusan dibuat selambat mungkin, pada saat terakhir, ketika itu masih dapat diterima.  Keuntungan dari pengambilan keputusan nanti adalah bahwa informasi tambahan mungkin tersedia pada saat ini.  Biaya metode ini termasuk biaya kemungkinan perbaikan arsitektur setelah keputusan dibuat.  Biaya-biaya ini dapat dikurangi dengan menggunakan abstraksi yang sesuai, tetapi mereka masih bisa terjadi.  Namun, biaya pengambilan keputusan pada tahap awal juga cukup nyata.  Ambil, misalnya, keputusan untuk memilih alat pengiriman pesan.  Alat yang berbeda mendukung fungsi yang berbeda.  Jika kita memilih alat yang lebih kuat dari yang diperlukan, kita mendapatkan arsitektur yang salah yang pasti akan membutuhkan pengembangan lebih lanjut.  "Hutang teknis" ini, yang timbul dari pemilihan alat yang salah, akan menjadi beban tambahan bagi pengembang. <br><br>  Tentu saja, masalah utama dengan momen terakhir yang memungkinkan untuk mengambil keputusan adalah menentukan kapan saatnya tiba.  Untuk melakukan ini, fokuslah pada fungsi kebugaran.  Pertama-tama, perlu untuk membuat keputusan yang dapat memiliki dampak signifikan pada pilihan arsitektur atau elemen desain, serta keputusan yang secara signifikan mempengaruhi keberhasilan keseluruhan proyek.  Dampak negatif dari penundaan keputusan seperti itu seringkali lebih besar daripada manfaat yang mungkin diperoleh dari keputusan selanjutnya. <br><br><h2>  Kesimpulan </h2><br>  Arsitek perangkat lunak harus menjelaskan keputusan yang dibuat tentang desain sistem yang dikembangkan, sebagai aturan, menggunakan berbagai macam diagram.  Pengembang arsitektur sering jatuh ke dalam perangkap menyajikan arsitektur perangkat lunak sebagai persamaan yang harus mereka selesaikan.  Banyak alat komersial yang ditawarkan oleh arsitek perangkat lunak memungkinkan Anda untuk mendeskripsikan arsitektur secara formal dalam bentuk kuadrat, garis, dan panah.  Meskipun diagram semacam itu mungkin berguna, mereka hanya menawarkan tampilan dua dimensi, potret dunia yang ideal, tetapi kita hidup dalam realitas empat dimensi. <br><br>  Untuk mengisi diagram dua dimensi dengan kehidupan, perlu untuk menentukannya.  Label <i>ORM</i> dalam diagram dua dimensi menjadi <i>Hibernate v4.2.17</i> , membuat dunia menjadi tiga dimensi.  Ketika Anda memiliki rencana untuk penerapannya dalam produksi dan memperbarui enam bulan kemudian ke versi <i>Hibernate v4.3.0.1 yang</i> tak terhindarkan, Anda akan siap untuk dunia empat dimensi.  Banyak arsitek tidak menyadari bahwa pandangan statis arsitektur memiliki umur yang pendek.  Alam semesta perangkat lunak ada dalam keadaan aliran; ia dinamis, bukan statis.  Arsitektur bukanlah sebuah persamaan, melainkan potret dari proses yang sedang berlangsung. <br><br>  Praktik pengiriman perangkat lunak berkelanjutan dan DevOps telah menunjukkan masalah yang muncul dari kurangnya pemahaman tentang upaya yang diperlukan untuk menerapkan dan mendukung arsitektur.  Menerapkan arsitektur hanyalah langkah pertama.  <b>Arsitektur tetap merupakan abstraksi sampai diterapkan.</b>  Dengan kata lain, kelayakan arsitektur apa pun dalam jangka panjang hanya dapat dinilai jika Anda tidak hanya mengimplementasikannya, tetapi juga memodifikasinya setidaknya sekali.  Dan mungkin mereka berhasil mengatasi kejutan di sepanjang jalan. <br>  Pemahaman seorang arsitek perangkat lunak tentang kemampuan operasional sangat penting untuk mengembangkan arsitektur evolusi.  Perkembangan evolusi arsitektur memengaruhi fitur-fitur implementasinya, dan karenanya harus diperhitungkan dalam proses penyelesaiannya.  Persyaratan proses pengiriman berkelanjutan untuk arsitektur ditujukan untuk meningkatkan visualisasi dan menyederhanakan perubahan.  Dengan cara ini, pengiriman terus menerus meningkatkan arsitektur evolusioner. <br><br>  Pada 19 November, Neil Ford tiba di Moskow dengan kelas master <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk menciptakan arsitektur perangkat lunak evolusioner</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424445/">https://habr.com/ru/post/id424445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424433/index.html">Mengapa hacker Mikrotik dan bagaimana saya menyembunyikan 100 ribu. RouterOS dari botnet</a></li>
<li><a href="../id424435/index.html">Kebun binatang pengeboran minyak: menertibkan</a></li>
<li><a href="../id424437/index.html">Elm Nyaman dan canggung. Json.Encoder dan Json.Decoder</a></li>
<li><a href="../id424441/index.html">Apa yang Baru di CTP Pertama SQL Server 2019</a></li>
<li><a href="../id424443/index.html">Vivaldi 2.0 mendukung kami</a></li>
<li><a href="../id424447/index.html">Lisp dibumbui dengan Pascal atau bahasa pemrograman 8501</a></li>
<li><a href="../id424453/index.html">Pelajari OpenGL. Pelajaran 6.2 - Rendering Berbasis Fisik. Sumber Cahaya Analitik</a></li>
<li><a href="../id424455/index.html">Intel Optane - Sekarang 1,5 Terabytes</a></li>
<li><a href="../id424457/index.html">Meningkatkan IDA Pro. Belajar menulis bootloader dengan Python</a></li>
<li><a href="../id424459/index.html">Kisah Sukses, atau DEV + DEVOPS + OPS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>