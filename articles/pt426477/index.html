<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçµ üàπ üìµ Toda a verdade sobre o RTOS. Artigo 15. Parti√ß√µes de mem√≥ria: servi√ßos e estruturas de dados üëãüèø üöÖ üë©‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, continuamos a revisar as se√ß√µes de mem√≥ria do RTOS. 

 O Nucleus RTOS possui tr√™s chamadas de API que fornecem fun√ß√µes utilit√°rias relac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda a verdade sobre o RTOS. Artigo 15. Parti√ß√µes de mem√≥ria: servi√ßos e estruturas de dados</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426477/"><img src="https://habrastorage.org/webt/3t/wd/au/3twdaubgcbrqlkg0al5lttnqs-y.jpeg"><br><br>  Neste artigo, continuamos a revisar as se√ß√µes de mem√≥ria do RTOS. <br><br>  O Nucleus RTOS possui tr√™s chamadas de API que fornecem fun√ß√µes utilit√°rias relacionadas aos conjuntos de parti√ß√µes de armazenamento: retornando informa√ß√µes sobre conjuntos de parti√ß√µes, retornando o n√∫mero de conjuntos de parti√ß√µes em um aplicativo e retornando ponteiros para todos os conjuntos de parti√ß√µes em um aplicativo.  Os dois primeiros desafios s√£o implementados no Nucleus SE. <br><a name="habracut"></a><br>  Artigos anteriores da s√©rie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Se√ß√µes de mem√≥ria: introdu√ß√£o e servi√ßos b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estruturas de dados da tarefa e chamadas de API n√£o suportadas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Servi√ßos para trabalhar com tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas: configura√ß√£o e introdu√ß√£o √† API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: recursos avan√ßados e preserva√ß√£o de contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: implementa√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√∫cleo SE: Projeto Interno e Implanta√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 7</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√∫cleo SE: Introdu√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outros servi√ßos RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intera√ß√£o e sincroniza√ß√£o de tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas, altern√¢ncia de contexto e interrup√ß√µes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas e planejamento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: estrutura e modo em tempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: introdu√ß√£o.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a> <br><h2>  Recuperando informa√ß√µes do conjunto de parti√ß√µes </h2><br>  Esta chamada de servi√ßo fornece informa√ß√µes parciais sobre o conjunto de parti√ß√µes.  A implementa√ß√£o do Nucleus SE difere do Nucleus RTOS, pois retorna menos informa√ß√µes porque os objetos de nomea√ß√£o e as solicita√ß√µes de pausa n√£o s√£o suportados e a tarefa n√£o pode ser pausada. <br><br><h3>  Chamando informa√ß√µes do pool de parti√ß√µes no Nucleus RTOS </h3><br>  Prot√≥tipo de chamada: <br><br>  <b>STATUS NU_Partition_Pool_Information (NU_PARTITION_POOL * pool, CHAR * nome, VOID ** start_address, UNSIGNED * pool_size, UNSIGNED * partition_size, UNSIGNED * dispon√≠vel, UNSIGNED * alocado, OPTION * suspend_type, UNSIGNED * tasks_waiting ** first_task;</b> <br><br>  Par√¢metros: <br><br>  <b>pool</b> - um ponteiro para o pool de parti√ß√µes sobre o qual as informa√ß√µes s√£o solicitadas; <br>  <b>nome</b> - ponteiro para a √°rea de destino de 8 caracteres para o nome do conjunto de parti√ß√µes;  inclui um local para terminar zero; <br>  <b>start_address</b> - um ponteiro para uma vari√°vel que recebe um ponteiro para o in√≠cio da √°rea de dados do pool de parti√ß√µes; <br>  <b>pool_size</b> - um ponteiro para uma vari√°vel que recebe o tamanho do pool de parti√ß√µes (em bytes); <br>  <b>partition_size</b> - ponteiro para uma vari√°vel que obt√©m o tamanho das parti√ß√µes em um determinado pool; <br>  <b>available</b> - um ponteiro para uma vari√°vel que recebe o n√∫mero de parti√ß√µes atualmente dispon√≠veis nesse pool; <br>  <b>alocado</b> - um ponteiro para uma vari√°vel que recebe o n√∫mero de parti√ß√µes usadas atualmente em um determinado pool; <br>  <b>suspend_type</b> - ponteiro para uma vari√°vel para obter o tipo de suspens√£o da tarefa;  tipos de suspens√£o v√°lidos: <b>NU_FIFO</b> e <b>NU_PRIORITY</b> ; <br>  <b>task_waiting</b> - um ponteiro para uma vari√°vel que recebe o n√∫mero de tarefas suspensas em um determinado conjunto de parti√ß√µes; <br>  <b>first_task</b> - ponteiro para o ponteiro da tarefa em que o ponteiro da primeira tarefa suspensa est√° localizado. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - chamada conclu√≠da com sucesso; <br>  <b>NU_INVALID_POOL</b> - ponteiro inv√°lido para o conjunto de parti√ß√µes. <br><br><h3>  Chamando Informa√ß√µes do Conjunto de Parti√ß√µes no Nucleus SE </h3><br>  Prot√≥tipo de chamada: <br><br>  <b>STATUS NUSE_Partition_Pool_Information (pool NUSE_PARTITION_POOL, ADDR * endere√ßo_address, U32 * tamanho_do_s Pool, U16 * tamanho_de_parti√ß√£o, U8 * dispon√≠vel, U8 * alocado, U8 * tarefas_a espera, NUSE_TASK * first_task)</b> <br><br>  Par√¢metros: <br><br>  <b>pool</b> - o √≠ndice do pool de parti√ß√µes sobre o qual as informa√ß√µes s√£o solicitadas; <br>  <b>start_address</b> - um ponteiro para uma vari√°vel que recebe um ponteiro para o in√≠cio da √°rea de dados do pool de parti√ß√µes; <br>  <b>pool_size</b> - um ponteiro para uma vari√°vel que recebe o tamanho do pool de parti√ß√µes (em bytes); <br>  <b>partition_size</b> - ponteiro para uma vari√°vel que obt√©m o tamanho das parti√ß√µes em um determinado pool; <br>  <b>available</b> - um ponteiro para uma vari√°vel que recebe o n√∫mero de parti√ß√µes atualmente dispon√≠veis nesse pool; <br>  <b>alocado</b> - um ponteiro para uma vari√°vel que recebe o n√∫mero de parti√ß√µes usadas atualmente em um determinado pool; <br>  <b>tasks_waiting</b> - um ponteiro para uma vari√°vel que recebe o n√∫mero de tarefas suspensas nesse conjunto de parti√ß√µes (se a suspens√£o da tarefa estiver desativada, 0 ser√° retornado); <br>  <b>first_task</b> - um ponteiro para uma vari√°vel do tipo <b>NUSE_TASK</b> , que recebe o √≠ndice da primeira tarefa suspensa (se a suspens√£o da tarefa estiver desativada, 0 ser√° retornado). <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> - chamada conclu√≠da com sucesso; <br>  <b>NUSE_INVALID_POOL</b> - √≠ndice do conjunto de parti√ß√µes inv√°lido; <br>  <b>NUSE_INVALID_POINTER</b> - um ou mais dos ponteiros transmitidos s√£o inv√°lidos. <br><br><h3>  Implementando recupera√ß√£o de informa√ß√µes e pool de parti√ß√µes no Nucleus SE </h3><br>  A implementa√ß√£o de uma chamada de API √© simples de executar: <br><br><img src="https://habrastorage.org/webt/ia/82/sj/ia82sj807l4yuaio-mvf-ypjivm.jpeg"><br><br>  A fun√ß√£o retorna o status do conjunto de parti√ß√µes.  Se o bloqueio de chamadas da API estiver ativado, o n√∫mero de tarefas pendentes e o √≠ndice da primeira delas ser√£o retornados (caso contr√°rio, esses par√¢metros ser√£o definidos como 0). <br><br><h2>  Obtendo o n√∫mero de conjuntos de parti√ß√µes </h2><br>  Essa chamada retorna informa√ß√µes sobre o n√∫mero de conjuntos de parti√ß√µes configurados no aplicativo.  Enquanto no Nucleus RTOS esse n√∫mero muda com o tempo e o valor de retorno representa o n√∫mero atual de conjuntos, no Nucleus SE o valor de retorno √© definido durante a montagem e permanece inalterado. <br><br><h3>  O desafio de obter o n√∫mero de conjuntos de parti√ß√µes no Nucleus RTOS </h3><br>  A chamada suporta a funcionalidade principal da API Nucleus RTOS. <br><br>  Prot√≥tipo de chamada: <br><br>  <b>UNSIGNED NU_Established_Partition_Pools (VOID);</b> <br><br>  Par√¢metros: <br><br>  Est√£o ausentes. <br><br>  Valor de retorno: <br><br>  O n√∫mero de conjuntos de parti√ß√µes criados no aplicativo. <br><br><h3>  O desafio de obter o n√∫mero de conjuntos de parti√ß√µes no Nucleus SE </h3><br>  Essa chamada de utilit√°rio suporta a funcionalidade principal da API Nucleus RTOS. <br><br>  Prot√≥tipo de chamada: <br><br>  <b>U8 NUSE_Partition_Pool_Count (nulo);</b> <br><br>  Par√¢metros: <br><br>  Est√£o ausentes <br><br>  Valor de retorno: <br><br>  O n√∫mero de conjuntos de parti√ß√µes criados no aplicativo. <br><br><h3>  Implementa√ß√£o </h3><br>  A implementa√ß√£o desta chamada de API √© extremamente simples: o valor <b>#define</b> do s√≠mbolo <b>NUSE_PARTITION_POOL_NUMBER</b> √© <b>retornado</b> . <br><br><h2>  Estruturas de dados </h2><br>  Como todos os outros objetos do Nucleus SE, os conjuntos de parti√ß√µes usam matrizes de estrutura na ROM e na RAM, cujo n√∫mero depende do n√∫mero de conjuntos especificado nas configura√ß√µes. <br><br>  Eu recomendo fortemente que o c√≥digo do aplicativo acesse essas estruturas de dados por meio de fun√ß√µes da API e n√£o diretamente.  Isso evita incompatibilidade com vers√µes futuras do Nucleus SE e efeitos colaterais indesejados, al√©m de simplificar a portabilidade do aplicativo para o Nucleus RTOS.  A seguir, √© apresentada uma descri√ß√£o detalhada das estruturas de dados para facilitar o entendimento do c√≥digo de chamada de servi√ßo e da depura√ß√£o. <br><br><h3>  Estrutura dos dados do kernel colocados na RAM </h3><br>  Essas estruturas de dados incluem: <br><br>  <b>NUSE_Partition_Pool_Partition_Used []</b> - uma matriz do tipo <b>U8</b> , com uma entrada para cada conjunto de parti√ß√µes configurado, contendo um contador dos conjuntos usados ‚Äã‚Äãno momento; <br>  <b>NUSE_Partition_Pool_Blocking_Count []</b> - uma matriz do tipo <b>U8 que</b> cont√©m um contador de tarefas bloqueadas em cada pool de parti√ß√µes.  Essa matriz existe se for poss√≠vel bloquear a chamada da API. <br><br>  Tais estruturas de dados s√£o inicializadas em zeros usando <b>NUSE_Init_ Partition_Pool ()</b> ao iniciar o Nucleus SE.  Isso √© l√≥gico, pois torna cada parti√ß√£o em cada pool n√£o utilizada (gratuita).  O artigo a seguir fornecer√° uma descri√ß√£o completa dos procedimentos de inicializa√ß√£o no Nucleus SE. <br><br>  A seguir, s√£o apresentadas descri√ß√µes das estruturas de dados no arquivo <b>nuse_init.c</b> . <br><br><img src="https://habrastorage.org/webt/vi/3x/sx/vi3xsxmbwdzkwgfge9ws_dsvups.jpeg"><br><br><h3>  Dados do usu√°rio da RAM </h3><br>  O usu√°rio precisa alocar uma √°rea na RAM para armazenar dados para cada conjunto de parti√ß√µes.  A quantidade de espa√ßo na RAM deve corresponder ao volume de parti√ß√µes configuradas (consulte "Dados na ROM" abaixo) com um byte adicional para cada parti√ß√£o no pool.  Cada se√ß√£o da √°rea de dados √© precedida por um byte de status. <br><br><h3>  Dados ROM </h3><br>  Estes incluem: <br><br>  <b>NUSE_Partition_Pool_Data_Address []</b> - uma matriz do tipo <b>ADDR</b> , com uma entrada para cada pool de parti√ß√µes configurado, contendo o endere√ßo do in√≠cio da √°rea de armazenamento de dados; <br>  <b>NUSE_Partition_Pool_Partition_Number []</b> - uma matriz do tipo <b>U8</b> com uma entrada para cada conjunto de parti√ß√µes configurado, contendo informa√ß√µes sobre o n√∫mero de parti√ß√µes no conjunto; <br>  <b>NUSE_Partition_Pool_Partition_Size []</b> - uma matriz do tipo <b>U16</b> com uma entrada para cada conjunto de parti√ß√µes configurado, contendo o tamanho das parti√ß√µes para os conjuntos. <br><br>  Tais estruturas de dados s√£o declaradas e inicializadas (estaticamente) em <b>nuse_config.c</b> : <br><br><img src="https://habrastorage.org/webt/zt/67/lq/zt67lqadvkdzmuvazbj0mmlhp8a.jpeg"><br><br><h3>  Pegada de dados para o conjunto de parti√ß√µes </h3><br>  Como em todos os objetos principais do Nucleus SE, a quantidade de mem√≥ria necess√°ria para os conjuntos de parti√ß√µes √© previs√≠vel. <br><br>  O tamanho da ROM (em bytes) para todos os conjuntos de parti√ß√µes de aplicativos pode ser calculado da seguinte maneira: <br><br>  <b>NUSE_PARTITION_POOL_NUMBER * (tamanho de (ADDR) + 2)</b> <br><br>  A quantidade de dados do kernel na RAM para todos os conjuntos de parti√ß√µes de aplicativos quando o bloqueio de chamadas da API √© ativado leva apenas 2 bytes por conjunto de parti√ß√µes e, quando o bloqueio n√£o √© ativado, s√£o necess√°rios 1 byte. <br><br>  A quantidade de mem√≥ria para armazenar dados do usu√°rio na RAM varia para cada conjunto de parti√ß√µes, embora, como j√° mencionado, para um conjunto com √≠ndice n possa ser calculado como: <br><br>  <b>NUSE_Partition_Pool_Partition_Number [n] *</b> <br>  <b>(NUSE_Partition_Pool_Partition_Size [n] + 1)</b> <br><br><h2>  Chamadas de API n√£o realizadas </h2><br>  Tr√™s chamadas de API para conjuntos de parti√ß√µes implementadas no Nucleus RTOS n√£o s√£o suportadas no Nucleus SE. <br><br><h3>  Criar conjunto de parti√ß√µes </h3><br>  Essa chamada de API cria um conjunto de parti√ß√µes.  O Nucleus SE n√£o precisa disso porque as tarefas s√£o criadas estaticamente. <br><br>  Prot√≥tipo de chamada: <br><br>  <b>STATUS NU_Create_Partition_Pool (NU_PARTITION_POOL * pool, nome CHAR *, VOID * start_address, UNSIGNED pool_size, UNSIGNED pool_size, UNSIGNED partition_size, OPTION suspend_type);</b> <br><br>  Par√¢metros: <br><br>  <b>pool</b> - um ponteiro para uma unidade de controle de <b>pool de</b> parti√ß√µes definida pelo usu√°rio;  usado como um identificador para o conjunto de parti√ß√µes em outras chamadas de API; <br>  <b>nome</b> - um ponteiro para o nome do conjunto de parti√ß√µes, uma cadeia de 7 caracteres com um zero final; <br>  <b>start_address</b> - define o endere√ßo inicial da √°rea de mem√≥ria do pool de parti√ß√µes; <br>  <b>pool_size</b> - quantidade total de mem√≥ria em bytes; <br>  <b>partition_size</b> - a quantidade de mem√≥ria em bytes para cada parti√ß√£o no pool.  Al√©m disso, uma pequena quantidade adicional de mem√≥ria √© alocada associada a cada se√ß√£o, o que √© conseguido gra√ßas aos dois ponteiros de dados usados. <br>  <b>suspend_type</b> - determina como as tarefas s√£o suspensas no conjunto de parti√ß√µes;  As op√ß√µes de par√¢metro v√°lidas s√£o <b>NU_FIFO</b> e <b>NU_PRIORITY</b> . <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - indica uma conclus√£o bem-sucedida da chamada; <br>  <b>NU_INVALID_POOL</b> - indica o valor zero da unidade de controle do conjunto de parti√ß√µes ( <b>NULL</b> ); <br>  <b>NU_INVALID_MEMORY</b> - indica o valor zero da √°rea de mem√≥ria definida pelo <b>endere√ßo start_</b> ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - indica que o tamanho da parti√ß√£o √© 0 ou maior que a mem√≥ria alocada para a parti√ß√£o; <br>  <b>NU_INVALID_SUSPEND</b> - valor inv√°lido de <b>suspend_type</b> . <br><br><h3>  Excluindo pool de parti√ß√µes </h3><br>  Essa chamada de API exclui um conjunto de parti√ß√µes criado anteriormente.  O Nucleus SE n√£o precisa dele porque os objetos s√£o criados estaticamente e n√£o podem ser exclu√≠dos. <br><br>  Prot√≥tipo de chamada: <br><br>  <b>STATUS NU_Delete_Partition_Pool (pool NU_PARTITION_POOL *);</b> <br><br>  Par√¢metros: <br><br>  <b>pool</b> - ponteiro para a unidade de controle do pool de parti√ß√µes; <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - indica uma conclus√£o bem-sucedida da chamada; <br>  <b>NU_INVALID_POOL</b> - indica um valor inv√°lido para o ponteiro do conjunto de parti√ß√µes; <br><br><h3>  Ponteiros do Conjunto de Parti√ß√µes </h3><br>  Essa chamada de API cria uma lista seq√ºencial de ponteiros para todos os conjuntos de parti√ß√µes no sistema.  O N√∫cleo SE n√£o precisa disso porque os objetos s√£o identificados por um √≠ndice, n√£o por um ponteiro. <br><br>  Prot√≥tipo de chamada: <br><br>  <b>UNSIGNED NU_Partition_Pool_Pointers (NU_PARTITION_POOL ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Par√¢metros: <br><br>  <b>pointer_list</b> - ponteiro para uma matriz de ponteiros <b>NU_PARTITION_POOL</b> ;  a matriz √© preenchida com ponteiros para conjuntos configurados no sistema; <br>  <b>maximum_pointers</b> - o n√∫mero m√°ximo de ponteiros que podem ser colocados na matriz. <br><br>  Valor de retorno: <br><br>  O n√∫mero de ponteiros <b>NU_PARTITION_POOL</b> colocados na matriz. <br><br><h2>  Compat√≠vel com n√∫cleo RTOS </h2><br>  Ao desenvolver o Nucleus SE, uma das principais tarefas foi garantir um alto n√≠vel de compatibilidade de c√≥digo com o Nucleus RTOS.  Os pools de parti√ß√µes n√£o foram exce√ß√£o e, do ponto de vista do desenvolvedor, eles s√£o implementados da mesma maneira que no Nucleus RTOS.  Algumas √°reas existentes de incompatibilidade s√£o aceit√°veis, embora valha a pena considerar que o c√≥digo final √© mais f√°cil de entender e mais eficiente em termos de mem√≥ria.  No entanto, as chamadas da API do Nucleus RTOS podem ser usadas quase diretamente como chamadas do Nucleus SE.  Um artigo futuro √© planejado com informa√ß√µes sobre o uso do Nucleus SE pelos usu√°rios do Nucleus RTOS. <br><br><h3>  Identificadores de objeto </h3><br>  No Nucleus RTOS, todos os objetos s√£o descritos por estruturas de dados (unidades de controle) de um tipo espec√≠fico.  Um ponteiro para esse bloco de controle √© usado como um identificador para o conjunto de parti√ß√µes.  Decidi que o Nucleus SE exigia uma abordagem diferente para um uso mais eficiente da mem√≥ria.  Todos os objetos do kernel s√£o descritos por v√°rias tabelas na RAM e / ou ROM.  Os tamanhos dessas tabelas s√£o determinados pelo n√∫mero de tipos configur√°veis ‚Äã‚Äãde todos os objetos.  O identificador para um objeto espec√≠fico √© o √≠ndice nessas tabelas.  Portanto, defini <b>NUSE_PARTITION_POOL como</b> equivalente a <b>U8</b> , ap√≥s o qual uma vari√°vel (n√£o um ponteiro) desse tipo serve como identificador da tarefa.  Essa leve incompatibilidade √© f√°cil de descobrir se o c√≥digo √© portado de ou para o Nucleus RTOS.  Os identificadores de objetos geralmente s√£o armazenados e transmitidos inalterados. <br><br>  O Nucleus RTOS tamb√©m suporta nomear pools de parti√ß√µes.  Esses nomes s√£o usados ‚Äã‚Äãapenas para depura√ß√£o.  Exclu√≠-os do Nucleus SE para economizar mem√≥ria. <br><br><h3>  N√∫mero de se√ß√µes e seu volume </h3><br>  No Nucleus RTOS, o pool de parti√ß√µes √© configurado com base no volume total do pool e no volume de parti√ß√µes (que carregam mais 2 ponteiros).  Esses par√¢metros s√£o definidos como UNSIGNED (aproximadamente 32 bits).  No Nucleus SE, o conjunto de parti√ß√µes √© configurado com base no tamanho da parti√ß√£o (para a qual um byte extra foi adicionado) e no n√∫mero total de parti√ß√µes.  Esses par√¢metros s√£o definidos como U16 e U8, respectivamente. <br><br><h3>  Chamadas de API n√£o realizadas </h3><br>  O Nucleus RTOS suporta 7 chamadas para trabalhar com conjuntos de parti√ß√µes, 3 das quais n√£o s√£o implementadas no Nucleus SE.  Mais detalhes sobre esses desafios e os motivos de sua exclus√£o est√£o descritos acima. <br><br>  O pr√≥ximo artigo ser√° sobre sinais. <br><br>  <b>Sobre o autor:</b> Colin Walls trabalha na ind√∫stria eletr√¥nica h√° mais de trinta anos, dedicando a maior parte de seu tempo ao firmware.  Ele agora √© engenheiro de firmware na Mentor Embedded (uma divis√£o da Mentor Graphics).  Colin Walls frequentemente fala em confer√™ncias e semin√°rios, autor de v√°rios artigos t√©cnicos e dois livros sobre firmware.  Vive no Reino Unido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Blog</a> profissional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de Colin</a> , e-mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426477/">https://habr.com/ru/post/pt426477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426465/index.html">‚ÄúEstamos mudando o terreno‚Äù - a TI vai para um grande canteiro de obras</a></li>
<li><a href="../pt426469/index.html">Telegrama como padr√£o corporativo</a></li>
<li><a href="../pt426471/index.html">Como os dados de spyware vazam</a></li>
<li><a href="../pt426473/index.html">Arquitetura Redux. Sim ou n√£o?</a></li>
<li><a href="../pt426475/index.html">Miya - assistente do smartphone</a></li>
<li><a href="../pt426479/index.html">Banco de teste caseiro para placas-m√£e</a></li>
<li><a href="../pt426481/index.html">Mapas hexagonais no Unity: Path Finder, esquadr√µes de jogadores, anima√ß√µes</a></li>
<li><a href="../pt426483/index.html">Aquele que ultrapassa Tesla. Para mais rent√°vel</a></li>
<li><a href="../pt426485/index.html">Terceiro teste do Qt 5 com o PVS-Studio</a></li>
<li><a href="../pt426487/index.html">Teste a automa√ß√£o do zero. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>