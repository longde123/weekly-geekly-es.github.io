<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ø üíø ‚ú® 5 Dinge, die ich gerne wissen w√ºrde, als ich mit Angular anfing üî´ üë®üèΩ‚Äçüíª üë®‚Äçüë©‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern Angular ist ein leistungsstarkes Framework mit vielen Funktionen, mit denen auf den ersten Blick komplexe Konzepte und Mechanismen einhergehen....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 Dinge, die ich gerne wissen w√ºrde, als ich mit Angular anfing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/480782/"><p>  Modern Angular ist ein leistungsstarkes Framework mit vielen Funktionen, mit denen auf den ersten Blick komplexe Konzepte und Mechanismen einhergehen.  Dies macht sich insbesondere bei jenen bemerkbar, die gerade erst im Frontend und insbesondere bei Angular angefangen haben, zu arbeiten. </p><br><p>  Das gleiche Problem hatte ich auch, als ich vor ungef√§hr zwei Jahren zu Tinkoff kam und die Position eines Junior Frontend-Entwicklers innehatte und in die Welt von Angular eintauchte.  Deshalb biete ich Ihnen eine kurze Geschichte √ºber f√ºnf Dinge an, deren Verst√§ndnis meine Arbeit zun√§chst sehr erleichtern w√ºrde. </p><br><p><img src="https://habrastorage.org/webt/er/qq/op/erqqope6skve-m43vun9ivrjyda.png"></p><a name="habracut"></a><br><h2 id="dependency-injection-di">  Abh√§ngigkeitsinjektion (DI) </h2><br><p>  Zuerst ging ich in die Komponente und sah, dass der Klassenkonstruktor einige Argumente enthielt.  Ich habe die Arbeit der Klassenmethoden ein wenig analysiert, und es wurde klar, dass dies einige externe Abh√§ngigkeiten sind.  Aber wie sind sie in den Unterricht gekommen?  Wo hie√ü der Konstruktor? </p><br><p>  Ich schlage sofort vor, ein Beispiel zu verstehen, aber daf√ºr brauchen wir eine Klasse.  Wenn in "normalem" JavaScript OOP mit bestimmten "Hacks" vorhanden ist, gibt es zusammen mit ES6 eine "echte" Syntax.  Angular verwendet TypeScript von Anfang an, wobei die Syntax in etwa gleich ist.  Daher schlage ich vor, es weiter zu verwenden. </p><br><p> Stellen Sie sich vor, es gibt eine <code>JokerService</code> Klasse in unserer Anwendung, die Witze verwaltet.  Die Methode <code>getJokes()</code> gibt eine Liste von Witzen zur√ºck.  Angenommen, wir verwenden es an drei Stellen.  Wie bekomme ich Witze an drei verschiedenen Stellen im Code?  Es gibt verschiedene M√∂glichkeiten: </p><br><ol><li>  Erstellen Sie an jeder Stelle eine Instanz der Klasse.  Aber warum m√ºssen wir den Speicher verstopfen und so viele identische Dienste erstellen?  Und wenn es 100 Pl√§tze gibt? </li><li>  Machen Sie die Methode statisch und rufen Sie Daten mit JokerService.getJokes () ab. </li><li>  Implementieren Sie eines der Entwurfsmuster.  Wenn wir den Dienst f√ºr die gesamte Anwendung ben√∂tigen, ist dies Singleton.  Daf√ºr m√ºssen Sie jedoch eine neue Logik in die Klasse schreiben. </li></ol><br><p>  Wir haben also drei recht funktionierende Optionen.  Das erste wird uns nicht passen - in diesem Fall ist es unwirksam.  Wir m√∂chten keine zus√§tzlichen Kopien erstellen, da diese vollkommen identisch sind.  Es bleiben zwei M√∂glichkeiten. </p><br><p>  Lassen Sie uns die Aufgabe komplizieren, um zu verstehen, welche Methode am besten zu uns passt.  Angenommen, an dritter Stelle m√ºssen wir aus irgendeinem Grund unseren eigenen Service mit bestimmten Parametern erstellen.  Dies kann ein bestimmter Autor sein, die L√§nge des Witzes, die Sprache und mehr.  Was machen wir dann? </p><br><p>  Bei der statischen Methode m√ºssen Sie die Einstellungen bei jedem Aufruf √ºbergeben, da die Klasse allen Orten gemeinsam ist.  Das hei√üt, bei jedem Aufruf von <code>getJokes()</code> werden alle f√ºr diesen Ort eindeutigen Parameter √ºbergeben.  Nat√ºrlich ist es besser, sie beim Instanziieren zu √ºbergeben und dann einfach die <code>getJokes()</code> -Methode <code>getJokes()</code> . </p><br><p>  Es stellt sich heraus, dass uns auch die zweite Option nicht zusagt: Wir duplizieren immer viel Code an jedem Ort.  Es bleibt nur Singleton, der wiederum die Logik aktualisieren muss, jedoch mit Variationen.  Aber wie kann man verstehen, welche Option wir brauchen? </p><br><p>  Wenn Sie dachten, dass Sie einfach ein Objekt erstellen und den Schl√ºssel verwenden k√∂nnen, um den gew√ºnschten Dienst in Anspruch zu nehmen, kann ich Ihnen gratulieren: Sie haben gerade festgestellt, wie die <em>Abh√§ngigkeitsinjektion</em> im Allgemeinen funktioniert.  Aber gehen wir etwas tiefer. </p><br><p>  Stellen Sie sich vor, dass JokerService zwei weitere Dienste ben√∂tigt, von denen einer optional ist und der zweite an einer bestimmten Stelle ein spezielles Ergebnis liefern sollte, um sicherzustellen, dass ein Mechanismus erforderlich ist, um die richtigen Instanzen zu ermitteln.  Es ist nicht schwer. </p><br><h3 id="dependency-injection-v-angular">  Abh√§ngigkeitsinjektion in Angular </h3><br><p>  Wie in der <a href="https://angular.io/guide/dependency-injection">Dokumentation angegeben</a> , ist DI ein wichtiges Entwurfsmuster f√ºr eine Anwendung.  Angular verf√ºgt √ºber ein eigenes Abh√§ngigkeits-Framework, das in Angular verwendet wird, um die Effizienz und Modularit√§t zu erh√∂hen. </p><br><p>  Im Allgemeinen ist die <em>Abh√§ngigkeitsinjektion</em> ein leistungsf√§higer Mechanismus, mit dem eine Klasse die erforderlichen Abh√§ngigkeiten von au√üerhalb erh√§lt, anstatt Instanzen selbst zu erstellen. </p><br><p>  Lassen Sie sich von der Syntax und den Dateien mit der <code>html</code> Erweiterung nicht verwirren.  Jede Komponente in Angular ist ein regul√§res JavaScript-Objekt, eine Instanz einer Klasse.  Allgemein ausgedr√ºckt: Wenn Sie eine Komponente in eine Vorlage einf√ºgen, wird eine Instanz der Komponentenklasse erstellt.  Dementsprechend k√∂nnen Sie zu diesem Zeitpunkt die erforderlichen Abh√§ngigkeiten an den Konstruktor √ºbergeben.  Betrachten Sie nun ein Beispiel: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'jokes', template: './jokes.template.html', }) export class JokesComponent { private jokes: Observable&lt;IJoke[]&gt;; constructor(private jokerService: JokerService) { this.jokes = this.jokerService.getJokes(); } }</code> </pre> <br><p>  Im Komponentenkonstruktor geben wir einfach an, dass wir einen <code>JokerService</code> ben√∂tigen.  Wir schaffen es nicht selbst.  Wenn es f√ºnf weitere Komponenten gibt, die es verwenden, verweisen sie alle auf dieselbe Instanz.  All dies erm√∂glicht es uns, Zeit zu sparen, Kesselplatten zu eliminieren und sehr produktive Anwendungen zu schreiben. </p><br><h3 id="providers">  Anbieter </h3><br><p>  Und jetzt schlage ich vor, mich mit dem Fall zu befassen, wenn Sie verschiedene Instanzen des Dienstes ben√∂tigen.  Schauen Sie sich zun√§chst den Service selbst an: </p><br><pre> <code class="plaintext hljs">@Injectable({ providedIn: 'root', //   ,   ¬´¬ª  }) export class JokerService { getJokes(): Observable&lt;IJoke[]&gt; { //     } }</code> </pre> <br><p>  Wenn es sich bei dem Dienst um einen Dienst f√ºr die gesamte Anwendung handelt, ist diese Option ausreichend.  Aber was ist, wenn wir beispielsweise zwei Implementierungen von <code>JokerService</code> ?  Oder ist es nur aus irgendeinem Grund so, dass eine bestimmte Komponente eine eigene Service-Instanz ben√∂tigt?  Die Antwort ist einfach: <a href="https://angular.io/guide/providers"><code>provider</code></a> . </p><br><p>  Der Einfachheit halber werde ich den <code>provider</code> <em>Anbieter nennen</em> , und der Vorgang des Ersetzens eines Werts in eine Klasse wird <em>√ºberpr√ºft</em> .  So k√∂nnen wir auf unterschiedliche Weise und an unterschiedlichen Orten Serviceleistungen erbringen.  Beginnen wir mit dem letzten.  Es stehen drei Optionen zur Verf√ºgung: </p><br><ul><li>  <code>provideIn: 'root'</code> die gesamte Anwendung im Service Decorator selbst <code>provideIn: 'root'</code> an. </li><li>  Im Modul - <code>provideIn: JokesModule</code> den Provider im Service Decorator als <code>provideIn: JokesModule</code> oder im Decorator des <code>@NgModule  providers: [JokerService]</code> Moduls <code>@NgModule  providers: [JokerService]</code> . </li><li>  In der Komponente - Geben Sie den Anbieter im Dekorator der Komponente wie im Modul an. </li></ul><br><p>  Der Ort wird je nach Ihren Bed√ºrfnissen gew√§hlt.  Wir haben den Ort herausgefunden, gehen wir zum Mechanismus selbst √ºber.  Wenn wir im Service einfach <code>provideIn: root</code> angeben, entspricht dies dem folgenden Eintrag im Modul: </p><br><pre> <code class="plaintext hljs">@NgModule({ // ...     providers: [{provide: JokerService, useClass: JokerService}], }) //  </code> </pre> <br><p>  Dies kann in etwa so lauten: "Wenn ein <code>JokerService</code> angefordert wird, geben Sie eine Instanz der <code>JokerService¬ª</code> Klasse an <code>JokerService¬ª</code>  Von hier aus k√∂nnen Sie eine bestimmte Instanz auf verschiedene Arten abrufen: </p><br><ul><li><p>  Per Token - Sie m√ºssen ein <code>InjectionToken</code> angeben und einen Dienst darauf erhalten.  Beachten Sie, dass Sie in den folgenden Beispielen in " <code>provide</code> dasselbe Token √ºbergeben k√∂nnen: </p><br><pre> <code class="plaintext hljs">const JOKER_SERVICE_TOKEN = new InjectionToken&lt;string&gt;('JokerService'); // ...     [{provide: JOKER_SERVICE_TOKEN, useClass: JokerService}];</code> </pre> <br></li><li><p>  Nach Klasse - Sie k√∂nnen die Klasse ersetzen.  Zum Beispiel werden wir nach <code>JokerService</code> fragen und geben - <code>JokerHappyService</code> : </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useClass: JokerHappyService}];</code> </pre> <br></li><li><p>  Nach Wert - Sie k√∂nnen sofort die gew√ºnschte Instanz zur√ºckgeben: </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useValue: jokerService}];</code> </pre> <br></li><li><p>  Nach Factory - Sie k√∂nnen die Klasse durch eine Factory ersetzen, die beim Zugriff auf die gew√ºnschte Instanz erstellt: </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useFactory: jokerServiceFactory}];</code> </pre> <br></li></ul><br><p>  Das ist alles.  Das hei√üt, um das Beispiel mit einer speziellen Instanz zu l√∂sen, k√∂nnen Sie eine der oben genannten Methoden verwenden.  W√§hlen Sie die f√ºr Ihre Bed√ºrfnisse am besten geeignete aus. </p><br><p>  √úbrigens funktioniert DI nicht nur f√ºr Services, sondern generell f√ºr alle Entit√§ten, die Sie im Komponentenkonstruktor erhalten.  Dies ist ein sehr leistungsf√§higer Mechanismus, der voll ausgesch√∂pft werden sollte. </p><br><h3 id="nebolshoy-itog">  Eine kleine Zusammenfassung </h3><br><p>  F√ºr ein vollst√§ndiges Verst√§ndnis schlage ich vor, den vereinfachten Mechanismus der Abh√§ngigkeitsinjektion in Angular schrittweise anhand des Dienstbeispiels zu betrachten: </p><br><ol><li>  Beim Initialisieren der Anwendung verf√ºgt der Dienst √ºber ein Token.  Wenn wir es im Provider nicht speziell angegeben haben, dann ist dies JokerService. </li><li>  Wenn ein Dienst in einer Komponente angefordert wird, pr√ºft der DI-Mechanismus, ob das √ºbertragene Token vorhanden ist. </li><li>  Wenn das Token nicht existiert, gibt DI einen Fehler aus.  In unserem Fall existiert das Token und der JokerService befindet sich darauf. </li><li>  Beim Erstellen der Komponente wird eine Instanz von JokerService als Argument an den Konstruktor √ºbergeben. </li></ol><br><h2 id="change-detection">  Erkennung √§ndern </h2><br><p>  Als Argument f√ºr die Verwendung von Frameworks h√∂ren wir oft etwas wie ‚ÄûDas Framework erledigt alles f√ºr Sie - schneller und effizienter.  Sie m√ºssen an nichts denken.  Verwalten Sie einfach die Daten. ‚Äú  Vielleicht ist dies bei einer sehr einfachen Anwendung der Fall.  Wenn Sie jedoch mit Benutzereingaben arbeiten und st√§ndig mit Daten arbeiten m√ºssen, m√ºssen Sie nur wissen, wie der Prozess zum Erkennen von √Ñnderungen und zum Rendern funktioniert. </p><br><p>  In Angular ist die √Ñnderungserkennung f√ºr die √úberpr√ºfung von √Ñnderungen verantwortlich.  Infolge verschiedener Vorg√§nge - √Ñndern des Werts einer Klasseneigenschaft, Abschlie√üen eines asynchronen Vorgangs, Beantworten einer HTTP-Anforderung usw. - wird der √úberpr√ºfungsprozess in der gesamten Komponentenstruktur gestartet. </p><br><p>  Da das Hauptziel des Prozesses darin besteht, zu verstehen, wie eine Komponente erneut gerendert wird, besteht das Wesentliche darin, die in den Vorlagen verwendeten Daten zu √ºberpr√ºfen.  Wenn sie unterschiedlich sind, wird die Vorlage als "ge√§ndert" markiert und neu gezeichnet. </p><br><h3 id="zonejs">  Zone.js </h3><br><p>  Es ist ziemlich einfach zu verstehen, wie Angular Klasseneigenschaften und synchrone Operationen verfolgt.  Aber wie verfolgt es asynchron?  Verantwortlich daf√ºr ist die von einem der Angular-Entwickler erstellte Zone.js-Bibliothek. </p><br><p>  Hier ist was es ist.  Eine Zone an sich ist ein ‚ÄûAusf√ºhrungskontext‚Äú, kurz gesagt der Ort und Zustand, in dem der Code ausgef√ºhrt wird.  Nachdem der asynchrone Vorgang abgeschlossen ist, wird die R√ºckruffunktion in derselben Zone ausgef√ºhrt, in der sie registriert wurde.  So findet Angular heraus, wo die √Ñnderung stattgefunden hat und was zu √ºberpr√ºfen ist. </p><br><p>  Zone.js ersetzt mit seinen Implementierungen fast alle nativen asynchronen Funktionen und Methoden.  Daher kann verfolgt werden, wann der <code>callback</code> einer asynchronen Funktion aufgerufen wird.  Das hei√üt, Zone teilt Angular mit, wann und wo der √Ñnderungs√ºberpr√ºfungsprozess gestartet werden soll. </p><br><h3 id="strategii-obnaruzheniya-izmeneniy">  Erkennungsstrategien √§ndern </h3><br><p>  Wir haben herausgefunden, wie Angular eine Komponente √ºberwacht und √Ñnderungspr√ºfungen durchf√ºhrt.  Stellen Sie sich jetzt vor, Sie haben eine riesige Anwendung mit Dutzenden von Komponenten.  Und f√ºr jeden Klick, jede asynchrone Operation, jede erfolgreich ausgef√ºhrte Anforderung wird eine √úberpr√ºfung √ºber den gesamten Komponentenbaum gestartet.  H√∂chstwahrscheinlich weist eine solche Anwendung schwerwiegende Leistungsprobleme auf. </p><br><p>  Angular-Entwickler haben dar√ºber nachgedacht und uns die M√∂glichkeit gegeben, eine √Ñnderungserkennungsstrategie zu entwickeln, deren richtige Auswahl die Produktivit√§t erheblich steigern kann. </p><br><p>  Es gibt zwei M√∂glichkeiten zur Auswahl: </p><br><ul><li>  Standard - wie der Name schon sagt, ist dies die Standardstrategie, wenn f√ºr jede Aktion eine CD gestartet wird. </li><li>  OnPush ist eine Strategie, bei der eine CD nur in wenigen F√§llen gestartet wird: <br><ul><li>  wenn sich der Wert von <code>@Input()</code> ge√§ndert hat; </li><li>  wenn ein Ereignis innerhalb der Komponente oder ihrer Nachkommen aufgetreten ist; </li><li>  ob die Pr√ºfung manuell gestartet wurde; </li><li>  wenn ein neues Ereignis in Async Pipe eintrifft. </li></ul></li></ul><br><p>  Aufgrund meiner eigenen Entwicklungserfahrung in Angular sowie der Erfahrung meiner Kollegen kann ich mit Sicherheit sagen, dass es besser ist, immer die <code>OnPush</code> Strategie <code>OnPush</code> , es sei denn, <code>default</code> wirklich erforderlich.  Dies bietet Ihnen mehrere Vorteile: </p><br><ul><li>  Ein klares Verst√§ndnis der Funktionsweise des CD-Prozesses. </li><li>  <code>@Input()</code> Arbeiten mit <code>@Input()</code> -Eigenschaften. </li><li>  Leistungsgewinn. </li></ul><br><h2 id="rabota-s-input">  Mit <code>@Input()</code> </h2><br><p>  Wie andere g√§ngige Frameworks verwendet Angular einen Downstream-Datenstrom.  Die Komponente akzeptiert Eingabeparameter, die mit dem <code>@Input()</code> .  Betrachten Sie ein Beispiel: </p><br><pre> <code class="plaintext hljs">interface IJoke { author: string; text: string; } @Component({ selector: 'joke', template: './joke.template.html', }) export class JokeComponent { @Input() joke: IJoke; }</code> </pre> <br><p>  Angenommen, es gibt eine oben beschriebene Komponente, die den Text des Witzes und des Autors anzeigt.  Das Problem bei diesem Schreiben ist, dass Sie das √ºbertragene Objekt versehentlich oder spezifisch mutieren k√∂nnen.  Zum Beispiel Text oder Autor √ºberschreiben. </p><br><pre> <code class="plaintext hljs">setAuthorNameOnly() { const name = this.joke.author.split(' ')[0]; this.joke.author = name; }</code> </pre> <br><p>  Ich stelle sofort fest, dass dies ein schlechtes Beispiel ist, aber es zeigt deutlich, was passieren k√∂nnte.  Um sich vor solchen Fehlern zu sch√ºtzen, m√ºssen Sie die Eingabeparameter schreibgesch√ºtzt machen.  Dank dessen haben Sie ein Verst√§ndnis daf√ºr, wie Sie richtig mit Daten arbeiten und eine CD erstellen.  Auf dieser Basis sieht der beste Weg, eine Klasse zu schreiben, so aus: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'joke', template: './joke.template.html', changeDetection: ChangeDetectionStrategy.OnPush, }) export class JokeComponent { @Input() readonly joke: IJoke; @Output() updateName = new EventEmitter&lt;string&gt;(); setAuthorNameOnly() { const name = this.joke.author.split(' ')[0]; this.updateName.emit(name); } }</code> </pre> <br><p>  Der beschriebene Ansatz ist keine Regel, sondern nur eine Empfehlung.  Es gibt viele Situationen, in denen dieser Ansatz unpraktisch und ineffektiv ist.  Mit der Zeit werden Sie verstehen, in welchem ‚Äã‚ÄãFall Sie die vorgeschlagene Methode zum Arbeiten mit Eingaben ablehnen k√∂nnen. </p><br><h2 id="rxjs">  Rxjs </h2><br><p>  Nat√ºrlich k√∂nnte ich mich irren, aber es scheint, dass ReactiveX und reaktive Programmierung im Allgemeinen ein neuer Trend sind.  Angular ist diesem Trend erlegen (oder hat ihn vielleicht erstellt) und verwendet standardm√§√üig RxJS.  Die Grundlogik des gesamten Frameworks basiert auf dieser Bibliothek, daher ist es sehr wichtig, die Prinzipien der reaktiven Programmierung zu verstehen. </p><br><p>  Aber was ist RxJS?  Es kombiniert drei Ideen, die ich in einer ziemlich einfachen Sprache mit einigen Auslassungen enth√ºllen werde: </p><br><ul><li>  <em>Das "Beobachter" -Muster</em> ist eine Entit√§t, die Ereignisse erzeugt, und es gibt einen Listener, der Informationen √ºber diese Ereignisse erh√§lt. </li><li>  <em>Das Iterator-Muster</em> - erm√∂glicht Ihnen den sequentiellen Zugriff auf die Elemente eines Objekts, ohne dessen interne Struktur preiszugeben. </li><li>  <em>Funktionale Programmierung mit Sammlungen</em> ist ein Muster, bei dem Logik in kleine und sehr einfache Komponenten zerlegt wird, von denen jede nur ein Problem l√∂st. </li></ul><br><p>  Durch die Kombination dieser Muster k√∂nnen wir sehr einfach auf den ersten Blick komplexe Algorithmen beschreiben, zum Beispiel: </p><br><pre> <code class="plaintext hljs">private loadUnreadJokes() { this.showLoader(); //   fromEvent(document, 'load') .pipe( switchMap( () =&gt; this.http .get('/api/v1/jokes') //   .pipe(map((jokes: any[]) =&gt; jokes.filter(joke =&gt; joke.unread))), //   ), ) .subscribe( (jokes: any[]) =&gt; (this.jokes = jokes), //   error =&gt; { /*   */ }, () =&gt; this.hideLoader(), //       ); }</code> </pre> <br><p>  Nur 18 Zeilen mit all den sch√∂nen Einkerbungen.  Versuchen Sie nun, dieses Beispiel in Vanilla oder zumindest in jQuery umzuschreiben.  Fast 100% davon beanspruchen mindestens doppelt so viel Platz und sind weniger aussagekr√§ftig.  Hier k√∂nnen Sie einfach die Linie mit Ihren Augen verfolgen und den Code wie ein Buch lesen. </p><br><h3 id="observable">  Beobachtbar </h3><br><p>  Zu verstehen, dass Daten als Stream dargestellt werden k√∂nnen, kommt nicht sofort.  Daher schlage ich vor, zu einer einfachen Analogie √ºberzugehen.  Stellen Sie sich vor, ein Stream ist ein Array von Daten, die nach Zeit sortiert sind.  Zum Beispiel in dieser Ausf√ºhrungsform: </p><br><pre> <code class="plaintext hljs">const observable = []; let counter = 0; const intervalId = setInterval(() =&gt; { observable.push(counter++); }, 1000); setTimeout(() =&gt; { clearInterval(intervalId); }, 6000);</code> </pre> <br><p>  Wir betrachten den letzten Wert im Array als relevant.  Jede Sekunde wird eine Zahl zum Array hinzugef√ºgt.  Wie k√∂nnen wir an anderer Stelle in der Anwendung feststellen, dass dem Array ein Element hinzugef√ºgt wurde?  In einer normalen Situation w√ºrden wir eine Art <code>callback</code> aufrufen und den Wert des Arrays darauf aktualisieren und dann einfach das letzte Element nehmen. </p><br><p>  Dank der reaktiven Programmierung m√ºssen Sie nicht nur viel neue Logik schreiben, sondern auch √ºber die Aktualisierung von Informationen nachdenken.  Dies kann mit einem einfachen Listener verglichen werden: </p><br><pre> <code class="plaintext hljs">document.addEventListener('click', event =&gt; {});</code> </pre> <br><p>  Sie k√∂nnen eine Menge <code>EventListener</code> in die gesamte Anwendung <code>EventListener</code> , und sie werden funktionieren, es sei denn, Sie k√ºmmern sich absichtlich um das Gegenteil. </p><br><p>  Reaktive Programmierung funktioniert auch.  An einer Stelle erstellen wir einfach einen Datenstrom und l√∂schen dort regelm√§√üig neue Werte. An einer anderen Stelle abonnieren wir diesen Strom und h√∂ren uns diese Werte einfach an.  Das hei√üt, wir erfahren immer etwas √ºber das Update und k√∂nnen damit umgehen. </p><br><p>  Schauen wir uns nun ein reales Beispiel an: </p><br><pre> <code class="plaintext hljs">export class JokesListComponent implements OnInit { jokes$: Observable&lt;IJoke&gt;; authors$ = new Subject&lt;string[]&gt;(); unread$ = new Subject&lt;number&gt;(); constructor(private jokerService: JokerService) {} ngOnInit() { //  ,    subscribe()    this.jokes$ = this.jokerService.getJokes(); this.jokes$.subscribe(jokes =&gt; { this.authors$.next(jokes.map(joke =&gt; joke.author)); this.unread$.next(jokes.filter(joke =&gt; joke.unread).length); }); } }</code> </pre> <br><p>  Dank dieser Logik aktualisieren wir beim √Ñndern von Daten in <code>jokes</code> automatisch die Daten zur Anzahl der ungelesenen Witze und zur Liste der Autoren.  Wenn Sie mehrere Komponenten haben, von denen eine Statistiken √ºber die Anzahl der von einem Autor gelesenen Witze sammelt und die zweite die durchschnittliche L√§nge der Witze berechnet, werden die Vorteile offensichtlich. </p><br><h2 id="testbed">  Pr√ºfstand </h2><br><p>  Fr√ºher oder sp√§ter versteht der Entwickler, dass Sie Tests schreiben m√ºssen, wenn das Projekt nicht MVP ist.  Und je mehr Tests geschrieben werden, desto klarer und detaillierter ist ihre Beschreibung, desto einfacher, schneller und zuverl√§ssiger ist es, √Ñnderungen vorzunehmen und neue Funktionen zu implementieren. </p><br><p>  Angular hat dies wahrscheinlich vorausgesehen und uns ein leistungsf√§higes Testwerkzeug zur Verf√ºgung gestellt.  Viele Entwickler versuchen zun√§chst, eine Technologie ‚Äûvon Anfang an‚Äú zu beherrschen, ohne auf die Dokumentation einzugehen.  Ich habe das gleiche getan, weshalb ich ziemlich sp√§t alle verf√ºgbaren Testm√∂glichkeiten "out of the box" erkannte. </p><br><p>  Sie k√∂nnen alles in Angular testen. Wenn Sie jedoch nur Methoden instanziieren und aufrufen m√ºssen, um eine regul√§re Klasse oder einen regul√§ren Dienst zu testen, ist die Situation mit der Komponente v√∂llig anders. </p><br><p>  Wie wir bereits herausgefunden haben, werden Abh√§ngigkeiten dank DI au√üerhalb der Komponente genommen.  Einerseits kompliziert dies das gesamte System ein wenig, andererseits gibt es uns gro√üe M√∂glichkeiten, Tests einzurichten und viele F√§lle zu √ºberpr√ºfen.  Ich schlage vor, das Beispiel einer Komponente zu verstehen: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'app-joker', template: '&lt;some-dependency&gt;&lt;/some-dependency&gt;', styleUrls: ['./joker.component.less'], }) export class JokerComponent { constructor( private jokesService: JokesService, @Inject(PARTY_TOKEN) private partyService: PartyService, @Optional() private sleepService: SleepService, ) {} makeNewFriend(): IFriend { if (this.sleepService &amp;&amp; this.sleepService.isSleeping) { this.sleepService.wakeUp(); } const joke = this.jokesService.generateNewJoke(); this.partyService.goToParty('Pacha'); this.partyService.toSay(joke.text); const laughingPeople = this.partyService.getPeopleByReaction('laughing'); const girl = laughingPeople.find(human =&gt; human.sex === 'female'); const friend = this.partyService.makeFriend(girl); return friend; } }</code> </pre> <br><p>  Im aktuellen Beispiel gibt es also drei Dienste.  Einer wird auf die √ºbliche Weise importiert, einer per Token und ein weiterer Dienst ist optional.  Wie konfigurieren wir das Testmodul?  Ich zeige sofort die fertige Ansicht: </p><br><pre> <code class="plaintext hljs">beforeEach(async(() =&gt; { TestBed.configureTestingModule({ imports: [SomeDependencyModule], declarations: [JokerComponent], //  ,    providers: [{provide: PARTY_TOKEN, useClass: PartyService}], }).compileComponents(); fixture = TestBed.createComponent(JokerComponent); component = fixture.componentInstance; fixture.detectChanges(); //    ,     }));</code> </pre> <br><p>  <code>TestBed</code> k√∂nnen wir eine vollst√§ndige Simulation des erforderlichen Moduls durchf√ºhren.  Sie k√∂nnen beliebige Dienste einbinden, Module ersetzen, Instanzen von Klassen von einer Komponente abrufen und vieles mehr.  Nachdem wir das Modul bereits konfiguriert haben, gehen wir zu den M√∂glichkeiten √ºber. </p><br><h3 id="mozhno-izbegat-lishnih-zavisimostey">  Unn√∂tige Abh√§ngigkeiten k√∂nnen vermieden werden </h3><br><p>  Eine Angular-Anwendung besteht aus Modulen, die andere Module, Dienste, Anweisungen und mehr enthalten k√∂nnen.  Im Test m√ºssen wir tats√§chlich die Funktionsweise des Moduls wiederherstellen.  Wenn wir in unserem Beispiel <code>&lt;some-dependency&gt;&lt;/some-dependency&gt;</code> in der Vorlage verwenden, bedeutet dies, dass wir auch <code>SomeDependencyModule</code> in den Test importieren m√ºssen.  Und wenn da Sucht ist?  Sie m√ºssen also auch importiert werden. <br>  Wenn die Anwendung komplex ist, gibt es viele solche Abh√§ngigkeiten.  Das Importieren aller Abh√§ngigkeiten f√ºhrt dazu, dass in jedem Test die gesamte Anwendung lokalisiert und alle Methoden aufgerufen werden.  Vielleicht passt uns das nicht. </p><br><p>  Es gibt mindestens eine M√∂glichkeit, die notwendigen Abh√§ngigkeiten zu beseitigen - schreiben Sie einfach die Vorlage neu.  Angenommen, Sie haben Screenshot- oder Integrationstests und m√ºssen das Erscheinungsbild der Komponente nicht testen.  Dann reicht es aus, einfach die Funktionsweise der Methoden zu √ºberpr√ºfen.  In diesem Fall k√∂nnen Sie die Konfiguration wie folgt schreiben: </p><br><pre> <code class="plaintext hljs">TestBed.configureTestingModule({ declarations: [JokerComponent], providers: [{provide: PARTY_TOKEN, useClass: PartyService}], }) .overrideTemplate(JokerComponent, '') //   ,   .compileComponents();</code> </pre> <br><p> ,    .           ,      . ,          .    ,       , ,    ,     .        ‚Äî    . </p><br><h3 id="mozhno-mokirovat-vse-zavisimosti-iz-konstruktora">       </h3><br><p>     <em>Injection Token</em> ,      .           .      ,       ,   . </p><br><p>        <code>ts-mockito</code> ,     ,    . Angular    ¬´ ¬ª. </p><br><pre> <code class="plaintext hljs">//    export class MockPartyService extends PartyService { meetFriend(): IFriend { return {} as IFriend; } goToParty() {} toSay(some: string) { console.log(some); } } // ... TestBed.configureTestingModule({ declarations: [JokerComponent, MockComponent], providers: [{provide: PARTY_TOKEN, useClass: MockPartyService}], //    }).compileComponents();</code> </pre> <br><p>   .         . </p><br><h3 id="mnozhestvo-keysov">   </h3><br><p>       .    ,  ‚Äî  ,   ‚Äî . ,              : </p><br><ul><li>          . </li><li>      ‚Äî ,      .    ‚Äî    . </li></ul><br><p>  ‚Äî       .          ,          .   ‚Äî     . </p><br><h2 id="itog">  Zusammenfassung </h2><br><p>       Angular,           .     ,   ,        ¬´¬ª. </p><br><p>      , Angular       - .    HTTP-, , lazy-loading  .            <a href="https://angular.io/docs"> Angular</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480782/">https://habr.com/ru/post/de480782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480772/index.html">Einfache Gr√ºnde f√ºr die Unvermeidlichkeit der technischen Verschuldung</a></li>
<li><a href="../de480774/index.html">Nicht Nginx Unified: Ayhor Hosting - Dash-Scratch Live</a></li>
<li><a href="../de480776/index.html">Wir stellen Active Directory mit allen m√∂glichen Methoden bereit.</a></li>
<li><a href="../de480778/index.html">Gestenverwaltung: Umgang mit visuellen Overlays. Teil 2</a></li>
<li><a href="../de480780/index.html">Wie man eine Illustration aus W√ºrfeln und Piktogrammen zusammensetzt</a></li>
<li><a href="../de480786/index.html">Unabh√§ngiges Klonen von Objekten in JavaScript</a></li>
<li><a href="../de480788/index.html">Weihnachtsbaum auf der Kommandozeile</a></li>
<li><a href="../de480790/index.html">"Werkseffizienz". Suche nach einem Engpass und Implementierung eines Pull-Systems zur Steigerung der Produktivit√§t</a></li>
<li><a href="../de480792/index.html">Geschenk Engineering</a></li>
<li><a href="../de480794/index.html">Ein wenig √ºber den Spezialfall der Implementierung von Suchalgorithmen f√ºr offene T√ºren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>