<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò± üéÖüèø üíû Sidecar pour un fractionnement de code üè≠ üëå üë®üèø‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fractionnement de code. Le fractionnement de code est partout. Mais pourquoi? Tout simplement parce qu'il y a trop de javascript de nos jours, et que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sidecar pour un fractionnement de code</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450942/"><p><img src="https://habrastorage.org/webt/ts/bi/e4/tsbie49wsfunvcztrdwhlnik6ge.jpeg"></p><br><p>  Fractionnement de code.  Le fractionnement de code est partout.  Mais pourquoi?  Tout simplement parce qu'il y a <strong>trop de javascript de</strong> nos jours, et que tous ne sont pas utilis√©s en m√™me temps. </p><br><p>  JS est une chose tr√®s <em>lourde</em> .  Pas pour votre iPhone Xs ou tout nouvel ordinateur portable i9, mais pour des millions (probablement des milliards) de propri√©taires d'appareils <em>plus lents</em> .  Ou, au moins, pour vos montres. </p><br><p>  Donc - JS est mauvais, mais que se passerait-il si nous le <strong>d√©sactivions simplement</strong> - le probl√®me dispara√Ætrait ... pour certains sites, et dispara√Ætrait "avec les sites" pour ceux bas√©s sur React.  Mais de toute fa√ßon - il y a des sites qui pourraient fonctionner sans JS ... et il y a quelque chose que nous devrions apprendre d'eux ... </p><a name="habracut"></a><br><h1 id="code-splitting">  Fractionnement de code </h1><br><p>  Aujourd'hui, nous avons deux fa√ßons de proc√©der, deux fa√ßons de l'am√©liorer ou de ne pas l'aggraver: </p><br><h2 id="1-write-less-code">  1. √âcrivez moins de code </h2><br><p> C'est la meilleure chose que vous puissiez faire.  Alors que <code>React Hooks</code> vous permet de livrer un peu moins de code et que des solutions comme <code>Svelte</code> vous permettent de g√©n√©rer juste moins de code que d' <em>habitude</em> , ce n'est pas si facile √† faire. </p><br><p>  Il ne s'agit pas seulement du code, mais aussi de la <em>fonctionnalit√©</em> - pour garder le code "compact", vous devez le garder "compact".  Il n'y a aucun moyen de garder un petit ensemble d'applications s'il fait tant de choses (et a √©t√© livr√© en 20 langues). </p><br><p>  Il existe des moyens d'√©crire <em>du</em> code <em>court et sain</em> , et il existe des moyens d'√©crire l'impl√©mentation oppos√©e - <em>l'entreprise sanglante</em> .  Et, vous savez, les deux sont l√©gitimes. </p><br><p><img src="https://habrastorage.org/webt/dz/fc/kn/dzfcknugbqrpbxturkjjae2v2se.jpeg"></p><br><p>  Mais le principal probl√®me - le code lui-m√™me.  Une simple application React pourrait facilement contourner 250 Ko "recommand√©s".  Et vous pourriez passer un mois √† l'optimiser et √† le r√©duire.  Les "petites" optimisations sont bien document√©es et tr√®s utiles - il suffit de disposer d' <code>bundle-analyzer</code> avec une <code>size-limit</code> et de se remettre en forme. <br>  Il existe de nombreuses biblioth√®ques, qui se battent pour chaque octet, essayant de vous garder dans vos limites - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©agir</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stocker</a> , pour n'en nommer que quelques-unes. </p><br><p>  Mais notre application d√©passe un peu 200kb.  Il est plus proche de <strong>100 Mo.</strong>  Supprimer des kilo-octets n'a aucun sens.  M√™me supprimer des m√©gaoctets n'a aucun sens. </p><br><blockquote>  Apr√®s un moment, il est impossible de garder votre application petite.  Il grossira avec le temps. </blockquote><br><h2 id="2-ship-less-code">  2. Exp√©dier moins de code </h2><br><p>  Alternativement, le <code>code split</code> .  En d'autres termes - se <strong>rendre</strong> .  Prenez votre paquet de 100 Mo et faites-en vingt paquets de 5 Mo.  Honn√™tement - c'est le seul moyen possible de g√©rer votre application si elle est grande - cr√©ez-en un pack de petites applications. </p><br><p>  Mais il y a une chose que vous devez savoir d√®s maintenant: quelle que soit l'option que vous choisissez, c'est un d√©tail d'impl√©mentation, alors que nous recherchons quelque chose de plus fiable. </p><br><h1 id="the-truth-about-code-splitting">  La v√©rit√© sur le fractionnement de code </h1><br><p>  La v√©rit√© sur le fractionnement de code est que sa nature est la <strong>S√âPARATION DU TEMPS</strong> .  Vous ne divisez pas simplement votre code, vous le divisez d'une mani√®re o√π vous en <strong>utiliserez</strong> le moins possible en un seul instant. </p><br><p>  N'exp√©diez pas le code dont vous n'avez pas besoin pour le moment.  D√©barrassez-vous-en. </p><br><p><img src="https://habrastorage.org/webt/py/eg/mi/pyegmilj0w2cshkxcj8nwqxhpg0.jpeg"></p><br><p>  Facile √† dire, difficile √† faire.  J'ai quelques applications lourdes, mais pas suffisamment r√©parties, o√π n'importe quelle page se charge comme 50% de tout.  Parfois <code>code splitting</code> devient <code>code separation</code> , je veux dire - vous pouvez d√©placer le code vers les diff√©rents morceaux, mais tout de m√™me, utilisez-le tout.  Rappelez-vous que <em>"</em> n'exp√©diez <em>pas le code dont vous n'avez pas besoin en ce moment"</em> , - j'avais <em>besoin de</em> 50% du code, et c'√©tait le vrai probl√®me. </p><br><blockquote>  Parfois, simplement ajouter des <code>import</code> ici et l√† n'est pas suffisant.  Jusqu'√† ce que ce ne soit pas une s√©paration <strong>temporelle</strong> , mais seulement une s√©paration <strong>spatiale</strong> - cela n'a pas d'importance du tout. </blockquote><p>  Il existe 3 fa√ßons courantes de coder la division: </p><br><ol><li>  <code>import</code> juste dynamique.  √Ä peine utilis√© seul de nos jours.  Il s'agit davantage de probl√®mes de suivi d'un <em>√©tat</em> . </li><li>  Composant <code>Lazy</code> , lorsque vous pouvez diff√©rer le rendu et le chargement d'un composant React.  Probablement 90% de la "r√©action au fractionnement du code" de nos jours. </li><li>  <em>Lazy</em> <code>Library</code> , qui est en fait <code>.1</code> , mais vous recevrez un code de biblioth√®que via les accessoires de rendu React.  Impl√©ment√© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les composants import√©s et les composants</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chargeables</a> .  Assez utile, mais peu connu. </li></ol><br><h2 id="component-level-code-splitting">  Fractionnement du code au niveau des composants </h2><br><p>  Celui-ci est le plus populaire.  En tant que fractionnement de code par route ou fractionnement de code par composant.  Ce n'est pas si facile de le faire et de maintenir ainsi de bons <em>r√©sultats perceptifs</em> .  C'est la mort de <code>Flash of Loading Content</code> . </p><br><p>  Les bonnes techniques sont: </p><br><ul><li>  charger le <code>js chunk</code> et les <code>data</code> pour un itin√©raire en parall√®le. </li><li>  utilisez un <code>skeleton</code> pour afficher quelque chose de similaire √† la page avant le chargement de la page (comme Facebook). </li><li>  <code>prefetch</code> chunks, vous pouvez m√™me utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guess-js</a> pour une meilleure pr√©diction. </li><li>  utilisez quelques retards, indicateurs de chargement, <code>animations</code> et <code>Suspense</code> (√† l'avenir) pour adoucir les transitions. </li></ul><br><p>  Et, vous savez, c'est une question de performance <em>perceptuelle</em> . </p><br><p><img src="https://habrastorage.org/webt/yk/4o/s1/yk4os1fia5xv28cfdsoccss6nr0.png"></p><br><blockquote>  Image d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://blog.angularindepth.com/">UX am√©lior√©e avec Ghost Elements</a> </blockquote><br><h1 id="that-doesnt-sound-good">  √áa ne sonne pas bien </h1><br><p>  Vous savez, je pourrais m'appeler un expert en fractionnement de code - mais j'ai mes propres √©checs. </p><br><p>  Parfois, je ne pouvais pas r√©duire la taille du paquet.  Parfois, je ne pouvais pas am√©liorer les performances r√©sultantes, tant que <code>the _more_ code splitting you are introducing - the more you spatially split your page - the more time you need to _reassemble_ your page back</code> *.  Cela s'appelle une <strong>vague de chargement</strong> . </p><br><ul><li>  sans SSR ni pr√©-rendu.  La bonne SSR change la donne en ce moment. </li></ul><br><p><img src="https://habrastorage.org/webt/fl/kn/hn/flknhn-kd8_aad9ro7g6fisrpqy.jpeg"></p><br><p>  La semaine derni√®re, j'ai eu deux √©checs: </p><br><ul><li>  J'ai perdu dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une comparaison de biblioth√®ques</a> , tant que ma biblioth√®que √©tait meilleure, mais BEAUCOUP plus grande qu'une autre.  J'ai √©chou√© √† <strong>¬´1. √âcrivez moins de code¬ª</strong> . </li><li>  optimiser un petit site, r√©alis√© en React par ma femme.  Il utilisait la division des composants bas√©e sur l'itin√©raire, mais l'en- <code>header</code> et le <code>footer</code> √©taient conserv√©s dans le bundle principal pour rendre les transitions plus "acceptables".  Juste quelques trucs, <strong>√©troitement coupl√©s les</strong> uns avec les autres c√¥t√© bundle mont√© en fl√®che jusqu'√† 320 Ko (avant gzip).  Il n'y avait rien d'important et rien que je pouvais vraiment supprimer.  <strong>Une mort de mille coupures</strong> .  Je n'ai pas <strong>envoy√© moins de code</strong> . </li></ul><br><blockquote>  React-Dom √©tait de 20%, core-js √©tait de 10%, react-router, jsLingui, react-powerplug ... 20% de son propre code ... Nous avons d√©j√† termin√©. </blockquote><p><img src="https://habrastorage.org/webt/ec/zx/xo/eczxxohgulg4yvyjdeyxvzwi3g0.png"></p><br><h2 id="the-solution">  La solution </h2><br><p>  J'ai commenc√© √† r√©fl√©chir √† la fa√ßon de r√©soudre mon probl√®me et aux raisons pour lesquelles <em>les solutions communes</em> ne fonctionnent pas correctement pour mon cas d'utilisation. </p><br><blockquote>  Qu'est-ce que j'ai fait?  J'ai r√©pertori√© tous les endroits cruciaux, sans lesquels l'application ne fonctionnerait pas du tout, et j'ai essay√© de comprendre pourquoi j'avais le reste. </blockquote><p>  Ce fut une surprise.  Mais mon probl√®me √©tait en CSS.  En transition CSS vanille. </p><br><p>  Voici le code </p><br><ul><li>  une variable de <em>contr√¥le</em> - <code>componentControl</code> , serait √©ventuellement d√©finie sur quelque chose que <code>DisplayData</code> devrait afficher. </li><li>  une fois la valeur d√©finie - <code>DisplayData</code> devient visible, modifiant <code>className</code> , d√©clenchant ainsi une transition fantaisiste.  Simultaneusly <code>FocusLock</code> devient actif faisant de <code>DisplayData</code> un <strong>modal</strong> . <br><pre> <code class="javascript hljs">&lt;FocusLock enabled={componentControl.value} <span class="hljs-comment"><span class="hljs-comment">// ^ it's "disabled". When it's disabled - it's dead. &gt; {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} // ^ it's does not exists. Also dead &lt;DisplayData data={componentControl.value} visible={componentControl.value !== null} // ^ would change a className basing on visible state /&gt; // ^ that is just not visible, but NOT dead &lt;/FocusLock&gt;</span></span></code> </pre> </li></ul><br><p>  Je voudrais coder fractionner cette pi√®ce dans son ensemble, mais c'est quelque chose que je ne pouvais pas faire, pour deux raisons: </p><br><ol><li>  l'information doit √™tre visible imm√©diatement, une fois requise, sans d√©lai.  Une exigence commerciale. </li><li>  les informations "chrome" doivent exister avant, pour g√©rer la transition de la propri√©t√©. </li></ol><br><p>  Ce probl√®me pourrait √™tre partiellement r√©solu en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CSSTransitionGroup</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">reconditionn√©</a> .  Mais, vous savez, corriger <em>un code en</em> ajoutant <em>un autre code</em> semble bizarre, m√™me si cela <em>suffit</em> .  Je veux dire que l'ajout de plus de code pourrait aider √† supprimer encore plus de code.  Mais ... mais ... </p><br><blockquote>  Il devrait y avoir une meilleure fa√ßon! </blockquote><p>  TL; DR - il y a deux points cl√©s ici: </p><br><ul><li>  <code>DisplayData</code> doit √™tre <strong>mont√©</strong> et existe dans le DOM avant. </li><li>  <code>FocusLock</code> devrait √©galement exister avant, pour ne pas provoquer de <code>DisplayData</code> , mais ses <strong>cerveaux ne sont pas n√©cessaires</strong> au d√©but. </li></ul><br><hr><br><p>  Alors changeons notre mod√®le mental </p><br><h1 id="batman-and-robin">  Batman et Robin </h1><br><p>  Supposons que notre code soit Batman et Robin.  Batman peut g√©rer la plupart des m√©chants, mais quand il ne le peut pas, son acolyte Robin vient √† la rescousse .. </p><br><blockquote>  Batman s'engageait √† nouveau dans la bataille, Robin arrivera plus tard. </blockquote><p>  Voici Batman: </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+&lt;FocusLock - enabled={componentControl.value} +&gt; - {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} + &lt;DisplayData + data={componentControl.value} + visible={componentControl.value !== null} + /&gt; +&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Voici son acolyte, Robin :: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-&lt;FocusLock + enabled={componentControl.value} -&gt; + {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} - &lt;DisplayData - data={componentControl.value} - visible={componentControl.value !== null} - /&gt; -&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Batman et Robin pourraient former une <em>√âQUIPE</em> , mais ils sont en r√©alit√© deux personnes diff√©rentes. </p><br><p>  Et n'oubliez pas - nous parlons toujours de <strong>fractionnement de code</strong> .  Et, en termes de fractionnement de code, o√π est l'acolyte?  O√π est Robin? </p><br><p><img src="https://habrastorage.org/webt/m3/3a/fu/m33afuxsi_rirx3uwjusiprzj94.jpeg"></p><br><blockquote>  dans un side-car.  Robin attend dans un <strong>morceau de side</strong> - <strong>car</strong> . </blockquote><br><h1 id="sidecar">  Sidecar </h1><br><ul><li>  <code>Batman</code> est ici tout ce que votre client doit voir le plus t√¥t possible.  Id√©alement instantan√©ment. </li><li>  <code>Robin</code> est ici toute logique et fonctionnalit√©s interactives de fantaisie, qui peuvent √™tre disponibles une seconde apr√®s, mais pas au tout d√©but. </li></ul><br><p>  Il serait pr√©f√©rable d'appeler cela un <strong>fractionnement de code vertical</strong> o√π les branches de code existent en parall√®le, contrairement √† un <strong>fractionnement de code horizontal</strong> commun o√π les branches de code sont <em>coup√©es</em> . </p><br><p>  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certains pays</a> , ce trio √©tait connu comme <code>replace reducer</code> ou d'autres fa√ßons de charger la logique de redux paresseux et les effets secondaires. </p><br><p>  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certains autres pays</a> , il est connu sous le nom de <code>"3 Phased" code splitting</code> . </p><br><blockquote>  C'est juste une autre s√©paration des pr√©occupations, applicable uniquement aux cas, o√π vous pouvez diff√©rer le chargement d'une partie d'un composant, mais pas d'une autre partie. </blockquote><p><img src="https://habrastorage.org/webt/sw/fq/if/swfqifrldpp0n6o7qcfr6osdunk.jpeg" alt="phase 3"></p><br><blockquote>  image de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Building the New facebook.com avec React, GraphQL et Relay</a> , o√π <code>importForInteractions</code> ou <code>importAfter</code> <strong>sont le <code>sidecar</code></strong> . </blockquote><p>  Et il y a une observation <strong>int√©ressante</strong> - alors que <code>Batman</code> est plus pr√©cieux pour un client, tant que c'est quelque chose que le client peut <em>voir</em> , il est toujours en forme ... Alors que <code>Robin</code> , vous savez, il pourrait √™tre un peu en <em>surpoids</em> et n√©cessiter beaucoup plus d'octets pour vivant. </p><br><p>  En cons√©quence - Batman seul est quelque chose de bien supportable pour un client - il offre plus de valeur √† moindre co√ªt.  Tu es mon h√©ros Bat! </p><br><h2 id="what-could-be-moved-to-a-sidecar">  Ce qui pourrait √™tre d√©plac√© vers un side-car: </h2><br><ul><li>  majorit√© de <code>useEffect</code> , <code>componentDidMount</code> et amis. </li><li>  comme tous les effets <em>Modal</em> .  C'est √† dire les verrous de <code>focus</code> et de <code>scroll</code> .  Vous pouvez d'abord afficher un modal, puis <strong>seulement</strong> faire du modal <em>modal</em> , c'est-√†-dire "verrouiller" l'attention du client. </li><li>  Formulaires  D√©placez toutes les logiques et validations vers un side-car et bloquez la soumission du formulaire jusqu'√† ce que cette logique soit charg√©e.  Le client pourrait commencer √† remplir le formulaire, ne sachant pas que ce n'est que <code>Batman</code> . </li><li>  Quelques animations.  Tout un <code>react-spring</code> dans mon cas. </li><li>  Quelques trucs visuels.  Comme les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">barres de d√©filement personnalis√©es</a> , qui peuvent afficher des barres de d√©filement sophistiqu√©es une seconde plus tard. </li></ul><br><p>  N'oubliez pas non plus - Chaque morceau de code, d√©charg√© sur un sidecar, d√©charge √©galement des √©l√©ments comme les poly-core et ponyfills core-js, utilis√©s par le code supprim√©. </p><br><p>  Le fractionnement de code peut √™tre plus intelligent qu'il ne l'est aujourd'hui dans nos applications.  Nous devons r√©aliser qu'il y a 2 types de <em>code</em> √† diviser: 1) les aspects visuels 2) les aspects interactifs.  Ce dernier peut arriver quelques instants plus tard.  <code>Sidecar</code> facilite la s√©paration des deux t√¢ches, donnant l' <em>impression que tout se charge plus rapidement</em> .  Et ce sera le cas. </p><br><h2 id="the-oldest-way-to-code-split">  La fa√ßon la plus ancienne de coder la division </h2><br><p>  Bien qu'il ne soit toujours pas tr√®s clair quand et ce qu'est un <code>sidecar</code> - <code>sidecar</code> , je vais donner une explication simple: </p><br><blockquote>  <code>Sidecar</code> est <strong>TOUS VOS SCRIPTS</strong> .  Le Sidecar est la fa√ßon dont nous <em>codons</em> avant tout ce que nous avons eu aujourd'hui. </blockquote><p>  Je parle du rendu c√¥t√© serveur ( <strong>SSR</strong> ), ou simplement du <strong>HTML</strong> , <strong>auquel</strong> nous √©tions tous habitu√©s hier.  <code>Sidecar</code> rend les choses aussi faciles qu'elles l'√©taient lorsque les pages contenaient du HTML et de la logique v√©cues s√©par√©ment dans des scripts externes int√©grables (s√©paration des pr√©occupations). </p><br><p>  Nous avions HTML, <strong>plus</strong> CSS, <strong>plus</strong> certains scripts en ligne, <strong>plus</strong> le reste des scripts extraits dans un fichier <code>.js</code> . </p><br><p>  <code>HTML</code> + <code>CSS</code> + <code>inlined-js</code> √©taient <code>Batman</code> , tandis que les scripts externes √©taient <code>Robin</code> , et le site a pu fonctionner sans Robin, et, honn√™tement, partiellement sans Batman (il continuera le combat avec les deux jambes (scripts int√©gr√©s) cass√©s).  C'√©tait hier, et de nombreux sites "non modernes et sympas" sont les m√™mes aujourd'hui. </p><br><hr><br><p>  Si votre application prend en charge SSR - essayez de <strong>d√©sactiver js</strong> et de le faire fonctionner sans lui.  Ensuite, il serait clair ce qui pourrait √™tre d√©plac√© vers un side-car. <br>  Si votre application est un SPA c√¥t√© client uniquement - essayez d'imaginer comment cela fonctionnerait, si la SSR existait. </p><br><blockquote>  Par exemple - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">theurge.com</a> , √©crit en React, est enti√®rement fonctionnel <strong>sans aucun js activ√©</strong> . </blockquote><p>  Il y a beaucoup de choses que vous pouvez d√©charger sur un side-car.  Par exemple: </p><br><ul><li>  commentaires.  Vous pouvez envoyer du code pour <code>display</code> commentaires, mais pas <code>answer</code> , tant qu'il peut n√©cessiter plus de code (y compris l'√©diteur WYSIWYG), ce qui n'est pas n√©cessaire au d√©part.  Il est pr√©f√©rable de retarder une zone de <em>commentaires</em> , ou m√™me de masquer le chargement du code derri√®re l'animation, plut√¥t que de retarder une page enti√®re. </li><li>  lecteur vid√©o.  Exp√©diez la "vid√©o" sans "commandes".  Chargez-les une seconde plus tard, le client pourrait essayer d'interagir avec lui. </li><li>  galerie d'images, comme <code>slick</code> .  Ce n'est pas un gros probl√®me pour le <strong>dessiner</strong> , mais beaucoup plus difficile √† animer et √† g√©rer.  Il est clair ce qui pourrait √™tre d√©plac√© vers un side-car. </li></ul><br><blockquote>  Pensez simplement √† ce qui est essentiel pour votre application et √† ce qui ne l'est pas tout √† fait ... </blockquote><br><h1 id="implementation-details">  D√©tails d'impl√©mentation </h1><br><h2 id="di-component-code-splitting">  (DI) Fractionnement du code composant </h2><br><p>  La forme la plus simple de <code>sidecar</code> est facile √† impl√©menter - d√©placez simplement tout vers un sous-composant, vous pouvez coder le fractionnement en utilisant une "ancienne" m√©thode.  C'est presque une s√©paration entre les composants Smart et Dumb, mais cette fois, Smart ne <em>contient</em> pas un <em>composant</em> Dumb - c'est l'oppos√©. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SmartComponent = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./SmartComponent'</span></span>)); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DumbComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;React.Fragment&gt; &lt;SmartComponent ref={this} /&gt; // &lt;-- move smart one inside &lt;TheActualMarkup /&gt; // &lt;-- the "real" stuff is here &lt;/React.Fragment&gt; } }</code> </pre> <br><p>  Cela n√©cessite √©galement de d√©placer le code d' <em>initialisation</em> vers un code muet, mais vous pouvez toujours diviser en code la partie la <em>plus lourde</em> d'un code. </p><br><blockquote>  Pouvez-vous voir un mod√®le de fractionnement de code <code>parallel</code> ou <code>vertical</code> maintenant? </blockquote><br><h2 id="usesidecar">  useSidecar </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Construire le nouveau facebook.com avec React, GraphQL et Relay</a> , je l'ai d√©j√† mentionn√© ici, avait un concept de <code>loadAfter</code> ou <code>importForInteractivity</code> , qui est assez similaire au concept de sidecar. </p><br><p>  Dans le m√™me temps, je ne recommanderais pas de cr√©er quelque chose comme <code>useSidecar</code> tant que vous pourriez intentionnellement essayer d'utiliser des <code>hooks</code> int√©rieur, mais le fractionnement de code sous cette forme violerait la <em>r√®gle des hooks</em> . </p><br><p>  Veuillez pr√©f√©rer une m√©thode de composants plus d√©clarative.  Et vous pouvez utiliser des <code>hooks</code> int√©rieur <code>SideCar</code> composant <code>SideCar</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Controller = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./Controller'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DumbComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = useState(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;Controller componentRef={ref} state={state} /&gt; &lt;TheRealStuff ref={ref} state={state[0]} /&gt; &lt;/&gt; ) }</code> </pre> <br><h2 id="prefetching">  Pr√©lecture </h2><br><p>  N'oubliez pas - vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des indications de priorit√© de chargement</a> pour pr√©charger ou pr√©charger le <code>sidecar</code> - <code>sidecar</code> et le rendre plus transparent et invisible. </p><br><p>  Choses importantes - la pr√©lecture des scripts la chargerait via le <strong>r√©seau</strong> , mais ne s'ex√©cuterait pas (et ne d√©penserait pas de CPU) √† moins que cela ne soit r√©ellement n√©cessaire. </p><br><h2 id="ssr">  SSR </h2><br><p>  Contrairement au fractionnement de code <em>normal</em> , aucune action sp√©ciale n'est requise pour SSR.  <code>Sidecar</code> peut ne pas faire partie du processus SSR et n'est pas requis avant l'√©tape d' <code>hydration</code> .  Il pourrait √™tre report√© "par conception". </p><br><p>  Ainsi - n'h√©sitez pas √† utiliser <code>React.lazy</code> (id√©alement quelque chose <strong>sans</strong> <code>Suspense</code> , vous n'avez pas besoin d'indicateurs de r√©tablissement (chargement) ici), ou toute autre biblioth√®que, avec, mais mieux sans le support SSR pour <em>ignorer les</em> morceaux de side-car pendant le processus SSR. </p><br><h1 id="the-bad-parts">  Les mauvaises parties </h1><br><p>  Mais il y a quelques mauvaises parties de cette id√©e </p><br><h2 id="batman-is-not-a-production-name">  Batman n'est pas un nom de production </h2><br><p>  Alors que <code>Batman</code> / <code>Robin</code> pourrait √™tre un bon concept d'esprit, et que le <code>sidecar</code> - <code>sidecar</code> est parfaitement adapt√© √† la technologie elle-m√™me - il n'y a pas de "bon" nom pour la <code>maincar</code> .  Il n'y a rien de tel qu'une <code>maincar</code> , et √©videmment <code>Batman</code> , <code>Lonely Wolf</code> , <code>Solitude</code> , <code>Driver</code> et <code>Solo</code> ne doivent pas √™tre utilis√©s pour nommer une partie autre qu'un side-car. </p><br><p>  Facebook a utilis√© l' <code>display</code> et l' <code>interactivity</code> , et cela pourrait √™tre la meilleure option pour nous tous. </p><br><blockquote>  Si vous avez un bon nom pour moi - laissez-le dans les commentaires </blockquote><br><h2 id="tree-shaking">  Tremblement d'arbre </h2><br><p>  Il s'agit davantage de la s√©paration des pr√©occupations du point de vue du <em>bundler</em> .  Imaginons que vous ayez <code>Batman</code> et <code>Robin</code> .  Et <code>stuff.js</code> </p><br><ul><li> <code>stuff.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./batman.js`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./robin.js`</span></span></code> </pre> </li></ul><br><p>  Ensuite, vous pouvez essayer de fractionner le code du <em>composant</em> pour impl√©menter un side-car </p><br><ul><li><p> <code>main.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {batman} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./stuff.js'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Robin = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./sidecar.js'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Robin</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // sidecar </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Batman</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // main content </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br></li><li><p> <code>sidecar.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// and sidecar.js... that's another chunk as long as we `import` it import {robin} from './stuff.js' .....</span></span></code> </pre> <br></li></ul><br><p>  En bref - le code ci-dessus fonctionnerait, mais ne fera pas "le travail". </p><br><ul><li>  si vous utilisez uniquement <code>batman</code> de <code>stuff.js</code> - le tremblement d'arbre ne le conservera que. </li><li>  si vous utilisez uniquement <code>robin</code> de <code>stuff.js</code> - le tremblement d'arbre ne le conservera que. </li><li>  <strong>mais</strong> si vous utilisez les deux, m√™me dans des morceaux diff√©rents - les deux seront regroup√©s dans une <strong>premi√®re</strong> occurrence de <code>stuff.js</code> , c'est-√†-dire le <strong>regroupement principal</strong> . </li></ul><br><blockquote>  Le tremblement d'arbre n'est pas convivial pour le fractionnement de code.  Vous devez s√©parer les pr√©occupations par fichiers. </blockquote><br><h2 id="un-import">  D√©simporter </h2><br><p>  Une autre chose, oubli√©e par tout le monde, est le co√ªt du javascript.  Il √©tait assez courant √† l'√®re jQuery, l'√®re de la charge utile <code>jsonp</code> de charger le script (avec la charge utile <code>json</code> ), d'obtenir la charge utile et de <strong>supprimer</strong> le script. </p><br><blockquote>  De nos jours, nous <code>import</code> tous du script, et il sera import√© pour toujours, m√™me s'il n'est plus n√©cessaire. </blockquote><p>  Comme je l'ai d√©j√† dit - il y a trop de JS, et t√¥t ou tard, avec <em>une navigation continue,</em> vous allez tout charger.  Nous devons trouver un moyen de d√©simporter sans avoir besoin de morceaux, en effa√ßant tous les caches internes et en lib√©rant de la m√©moire pour rendre le Web plus fiable, et ne pas √©craser les applications avec des exceptions de m√©moire insuffisante. </p><br><p>  La possibilit√© de d√©simporter (le webpack <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pourrait le faire</a> ) est probablement l'une des raisons pour lesquelles nous devrions nous en tenir √† l'API <em>bas√©e</em> sur les <em>composants</em> , √† condition qu'elle nous donne la possibilit√© de g√©rer le <code>unmount</code> . </p><br><p>  Jusqu'√† pr√©sent - les normes des modules ESM n'ont rien √† voir avec des choses comme √ßa - ni sur le contr√¥le du cache, ni sur l'inversion de l'action d'importation. </p><br><h2 id="creating-a-sidecar-enabled-library">  Cr√©ation d'une biblioth√®que compatible side-car </h2><br><p>  √Ä l'heure actuelle, il n'y a qu'une seule fa√ßon de cr√©er une biblioth√®que compatible avec les <code>sidecar</code> cars: </p><br><ul><li>  divisez votre composant en parties </li><li>  exposer une partie <code>main</code> et une partie <code>connected</code> (pour ne pas casser l'API) via un <code>index</code> </li><li>  exposer un <code>sidecar</code> - <code>sidecar</code> via un point d'entr√©e s√©par√©. </li><li>  dans le code cible - importez la partie <code>main</code> et le <code>sidecar</code> - la secousse de l'arbre devrait couper une partie <code>connected</code> . </li></ul><br><p>  Cette fois, le tremblement de l'arbre devrait fonctionner correctement, et le seul probl√®me - est de savoir comment nommer la partie <code>main</code> . </p><br><ul><li> <code>main.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Main = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{sidecar, ...props}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {sidecar} .... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><ul><li> <code>connected.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Sidecar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Main</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sidecar</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Sidecar</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">} {...props} /&gt; );</span></span></code> </pre> <br><ul><li> <code>index.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Main'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Connected'</span></span>;</code> </pre> <br><ul><li> <code>sidecar.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>;</code> </pre> <br><p>  En bref, le changement pourrait √™tre repr√©sent√© par une petite comparaison </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//your app BEFORE import {Connected} from 'library'; // // ------------------------- //your app AFTER, compare this core to `connected.js` import {Main} from 'library'; const Sidecar = React.lazy(import( () =&gt; import('library/sidecar'))); // ^ all the difference ^ export SideConnected = props =&gt; ( &lt;Main sidecar={&lt;Sidecar /&gt;} {...props} /&gt; ); // ^ you will load only Main, Sidecar will arrive later.</span></span></code> </pre> <br><p>  L' <code>dynamic import</code> th√©oriquement <code>dynamic import</code> pourrait √™tre utilis√©e √† l'int√©rieur de node_modules, rendant le <em>processus d'assemblage</em> plus transparent. </p><br><blockquote>  Quoi qu'il en soit - ce n'est rien de plus que le mod√®le <code>children</code> / <code>slot</code> , si commun dans React. </blockquote><br><h1 id="the-future">  Le futur </h1><br><p>  <code>Facebook</code> prouv√© que l'id√©e √©tait bonne.  Si vous n'avez pas vu cette vid√©o, faites-le maintenant.  Je viens d'expliquer la m√™me id√©e sous un angle un peu diff√©rent (et j'ai commenc√© √† √©crire cet article une semaine avant la conf√©rence F8). </p><br><p>  √Ä l'heure actuelle, il n√©cessite que certains changements de code soient appliqu√©s √† votre base de code.  Il faut une s√©paration plus explicite des pr√©occupations pour les s√©parer r√©ellement, et laisser les codesplit non pas horizontalement, mais verticalement, exp√©diant <em>moins de</em> code pour une <em>plus grande</em> exp√©rience utilisateur. </p><br><p>  <code>Sidecar</code> , probablement, est le seul moyen, √† l'exception du SSR old school, de g√©rer les bases de code BIG.  Derni√®re chance d'envoyer une quantit√© minimale de code, lorsque vous en avez beaucoup. </p><br><blockquote>  Cela pourrait rendre une grande application plus petite et une petite application encore plus petite. </blockquote><p>  Il y a 10 ans, le site Web moyen √©tait "pr√™t" en 300 ms, et √©tait <em>vraiment</em> pr√™t quelques millisecondes apr√®s.  Aujourd'hui, les secondes et m√™me plus de 10 secondes sont les nombres communs.  Quelle honte. </p><br><p>  Prenons une pause et r√©fl√©chissons √† la fa√ßon dont nous pourrions r√©soudre le probl√®me et rendre √† nouveau UX g√©nial ... </p><br><p><img src="https://habrastorage.org/webt/8_/5u/7e/8_5u7ehdn7nkcjiaqfv1-rzadfa.jpeg"></p><br><h1 id="overall">  Global </h1><br><ul><li>  Le fractionnement du code des composants est un outil tr√®s puissant, vous donnant la possibilit√© de fractionner <em>compl√®tement</em> quelque chose, mais il a un co√ªt - vous n'aurez peut-√™tre rien √† afficher, sauf une page vierge ou un <em>squelette</em> pendant un certain temps.  C'est une s√©paration horizontale. </li><li>  La division du code de la biblioth√®que pourrait aider lorsque la s√©paration des composants ne le serait pas.  C'est une s√©paration horizontale. </li><li>  Le code, d√©charg√© sur un sidecar compl√©terait l'image et pourrait vous permettre de fournir une bien meilleure exp√©rience utilisateur.  Mais cela n√©cessiterait √©galement des efforts d'ing√©nierie.  C'est une s√©paration verticale. </li></ul><br><p>  <strong>Ayons une conversation √† ce sujet</strong> . </p><br><h2 id="stop-so-what-about-the-problems-you-tried-to-solve">  Arr√™te!  Qu'en est-il des probl√®mes que vous avez essay√© de r√©soudre? </h2><br><p>  Eh bien, ce n'√©tait que la premi√®re partie.  <strong>Nous sommes maintenant dans la phase finale</strong> , il faudrait encore quelques semaines pour r√©diger la deuxi√®me partie de cette proposition.  Pendant ce temps ... montez dans le side-car! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr450942/">https://habr.com/ru/post/fr450942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr450926/index.html">Jeu 3D sur three.js, nw.js</a></li>
<li><a href="../fr450928/index.html">Comment les centres de donn√©es sauvent les vacances</a></li>
<li><a href="../fr450930/index.html">Comment nous d√©veloppons # bigdataX5 et qui est n√©cessaire dans le Big Data</a></li>
<li><a href="../fr450938/index.html">Linux Install Fest 05.19 √† Nizhny Novgorod 18 mai 2019</a></li>
<li><a href="../fr450940/index.html">Vivaldi 2.5 - Macrocosme attrayant</a></li>
<li><a href="../fr450946/index.html">Disque cellulaire sur LPC810</a></li>
<li><a href="../fr450948/index.html">MU-MIMO: l'un des algorithmes d'impl√©mentation</a></li>
<li><a href="../fr450950/index.html">Dart Streams Basics</a></li>
<li><a href="../fr450952/index.html">Indice moyen et antibank</a></li>
<li><a href="../fr450954/index.html">Comment nous avons appris √† exploiter Java dans Docker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>