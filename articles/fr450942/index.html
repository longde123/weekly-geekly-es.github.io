<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😱 🎅🏿 💞 Sidecar pour un fractionnement de code 🏭 👌 👨🏿‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fractionnement de code. Le fractionnement de code est partout. Mais pourquoi? Tout simplement parce qu'il y a trop de javascript de nos jours, et que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sidecar pour un fractionnement de code</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450942/"><p><img src="https://habrastorage.org/webt/ts/bi/e4/tsbie49wsfunvcztrdwhlnik6ge.jpeg"></p><br><p>  Fractionnement de code.  Le fractionnement de code est partout.  Mais pourquoi?  Tout simplement parce qu'il y a <strong>trop de javascript de</strong> nos jours, et que tous ne sont pas utilisés en même temps. </p><br><p>  JS est une chose très <em>lourde</em> .  Pas pour votre iPhone Xs ou tout nouvel ordinateur portable i9, mais pour des millions (probablement des milliards) de propriétaires d'appareils <em>plus lents</em> .  Ou, au moins, pour vos montres. </p><br><p>  Donc - JS est mauvais, mais que se passerait-il si nous le <strong>désactivions simplement</strong> - le problème disparaîtrait ... pour certains sites, et disparaîtrait "avec les sites" pour ceux basés sur React.  Mais de toute façon - il y a des sites qui pourraient fonctionner sans JS ... et il y a quelque chose que nous devrions apprendre d'eux ... </p><a name="habracut"></a><br><h1 id="code-splitting">  Fractionnement de code </h1><br><p>  Aujourd'hui, nous avons deux façons de procéder, deux façons de l'améliorer ou de ne pas l'aggraver: </p><br><h2 id="1-write-less-code">  1. Écrivez moins de code </h2><br><p> C'est la meilleure chose que vous puissiez faire.  Alors que <code>React Hooks</code> vous permet de livrer un peu moins de code et que des solutions comme <code>Svelte</code> vous permettent de générer juste moins de code que d' <em>habitude</em> , ce n'est pas si facile à faire. </p><br><p>  Il ne s'agit pas seulement du code, mais aussi de la <em>fonctionnalité</em> - pour garder le code "compact", vous devez le garder "compact".  Il n'y a aucun moyen de garder un petit ensemble d'applications s'il fait tant de choses (et a été livré en 20 langues). </p><br><p>  Il existe des moyens d'écrire <em>du</em> code <em>court et sain</em> , et il existe des moyens d'écrire l'implémentation opposée - <em>l'entreprise sanglante</em> .  Et, vous savez, les deux sont légitimes. </p><br><p><img src="https://habrastorage.org/webt/dz/fc/kn/dzfcknugbqrpbxturkjjae2v2se.jpeg"></p><br><p>  Mais le principal problème - le code lui-même.  Une simple application React pourrait facilement contourner 250 Ko "recommandés".  Et vous pourriez passer un mois à l'optimiser et à le réduire.  Les "petites" optimisations sont bien documentées et très utiles - il suffit de disposer d' <code>bundle-analyzer</code> avec une <code>size-limit</code> et de se remettre en forme. <br>  Il existe de nombreuses bibliothèques, qui se battent pour chaque octet, essayant de vous garder dans vos limites - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pré</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réagir</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stocker</a> , pour n'en nommer que quelques-unes. </p><br><p>  Mais notre application dépasse un peu 200kb.  Il est plus proche de <strong>100 Mo.</strong>  Supprimer des kilo-octets n'a aucun sens.  Même supprimer des mégaoctets n'a aucun sens. </p><br><blockquote>  Après un moment, il est impossible de garder votre application petite.  Il grossira avec le temps. </blockquote><br><h2 id="2-ship-less-code">  2. Expédier moins de code </h2><br><p>  Alternativement, le <code>code split</code> .  En d'autres termes - se <strong>rendre</strong> .  Prenez votre paquet de 100 Mo et faites-en vingt paquets de 5 Mo.  Honnêtement - c'est le seul moyen possible de gérer votre application si elle est grande - créez-en un pack de petites applications. </p><br><p>  Mais il y a une chose que vous devez savoir dès maintenant: quelle que soit l'option que vous choisissez, c'est un détail d'implémentation, alors que nous recherchons quelque chose de plus fiable. </p><br><h1 id="the-truth-about-code-splitting">  La vérité sur le fractionnement de code </h1><br><p>  La vérité sur le fractionnement de code est que sa nature est la <strong>SÉPARATION DU TEMPS</strong> .  Vous ne divisez pas simplement votre code, vous le divisez d'une manière où vous en <strong>utiliserez</strong> le moins possible en un seul instant. </p><br><p>  N'expédiez pas le code dont vous n'avez pas besoin pour le moment.  Débarrassez-vous-en. </p><br><p><img src="https://habrastorage.org/webt/py/eg/mi/pyegmilj0w2cshkxcj8nwqxhpg0.jpeg"></p><br><p>  Facile à dire, difficile à faire.  J'ai quelques applications lourdes, mais pas suffisamment réparties, où n'importe quelle page se charge comme 50% de tout.  Parfois <code>code splitting</code> devient <code>code separation</code> , je veux dire - vous pouvez déplacer le code vers les différents morceaux, mais tout de même, utilisez-le tout.  Rappelez-vous que <em>"</em> n'expédiez <em>pas le code dont vous n'avez pas besoin en ce moment"</em> , - j'avais <em>besoin de</em> 50% du code, et c'était le vrai problème. </p><br><blockquote>  Parfois, simplement ajouter des <code>import</code> ici et là n'est pas suffisant.  Jusqu'à ce que ce ne soit pas une séparation <strong>temporelle</strong> , mais seulement une séparation <strong>spatiale</strong> - cela n'a pas d'importance du tout. </blockquote><p>  Il existe 3 façons courantes de coder la division: </p><br><ol><li>  <code>import</code> juste dynamique.  À peine utilisé seul de nos jours.  Il s'agit davantage de problèmes de suivi d'un <em>état</em> . </li><li>  Composant <code>Lazy</code> , lorsque vous pouvez différer le rendu et le chargement d'un composant React.  Probablement 90% de la "réaction au fractionnement du code" de nos jours. </li><li>  <em>Lazy</em> <code>Library</code> , qui est en fait <code>.1</code> , mais vous recevrez un code de bibliothèque via les accessoires de rendu React.  Implémenté dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les composants importés et les composants</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chargeables</a> .  Assez utile, mais peu connu. </li></ol><br><h2 id="component-level-code-splitting">  Fractionnement du code au niveau des composants </h2><br><p>  Celui-ci est le plus populaire.  En tant que fractionnement de code par route ou fractionnement de code par composant.  Ce n'est pas si facile de le faire et de maintenir ainsi de bons <em>résultats perceptifs</em> .  C'est la mort de <code>Flash of Loading Content</code> . </p><br><p>  Les bonnes techniques sont: </p><br><ul><li>  charger le <code>js chunk</code> et les <code>data</code> pour un itinéraire en parallèle. </li><li>  utilisez un <code>skeleton</code> pour afficher quelque chose de similaire à la page avant le chargement de la page (comme Facebook). </li><li>  <code>prefetch</code> chunks, vous pouvez même utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guess-js</a> pour une meilleure prédiction. </li><li>  utilisez quelques retards, indicateurs de chargement, <code>animations</code> et <code>Suspense</code> (à l'avenir) pour adoucir les transitions. </li></ul><br><p>  Et, vous savez, c'est une question de performance <em>perceptuelle</em> . </p><br><p><img src="https://habrastorage.org/webt/yk/4o/s1/yk4os1fia5xv28cfdsoccss6nr0.png"></p><br><blockquote>  Image d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://blog.angularindepth.com/">UX améliorée avec Ghost Elements</a> </blockquote><br><h1 id="that-doesnt-sound-good">  Ça ne sonne pas bien </h1><br><p>  Vous savez, je pourrais m'appeler un expert en fractionnement de code - mais j'ai mes propres échecs. </p><br><p>  Parfois, je ne pouvais pas réduire la taille du paquet.  Parfois, je ne pouvais pas améliorer les performances résultantes, tant que <code>the _more_ code splitting you are introducing - the more you spatially split your page - the more time you need to _reassemble_ your page back</code> *.  Cela s'appelle une <strong>vague de chargement</strong> . </p><br><ul><li>  sans SSR ni pré-rendu.  La bonne SSR change la donne en ce moment. </li></ul><br><p><img src="https://habrastorage.org/webt/fl/kn/hn/flknhn-kd8_aad9ro7g6fisrpqy.jpeg"></p><br><p>  La semaine dernière, j'ai eu deux échecs: </p><br><ul><li>  J'ai perdu dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une comparaison de bibliothèques</a> , tant que ma bibliothèque était meilleure, mais BEAUCOUP plus grande qu'une autre.  J'ai échoué à <strong>«1. Écrivez moins de code»</strong> . </li><li>  optimiser un petit site, réalisé en React par ma femme.  Il utilisait la division des composants basée sur l'itinéraire, mais l'en- <code>header</code> et le <code>footer</code> étaient conservés dans le bundle principal pour rendre les transitions plus "acceptables".  Juste quelques trucs, <strong>étroitement couplés les</strong> uns avec les autres côté bundle monté en flèche jusqu'à 320 Ko (avant gzip).  Il n'y avait rien d'important et rien que je pouvais vraiment supprimer.  <strong>Une mort de mille coupures</strong> .  Je n'ai pas <strong>envoyé moins de code</strong> . </li></ul><br><blockquote>  React-Dom était de 20%, core-js était de 10%, react-router, jsLingui, react-powerplug ... 20% de son propre code ... Nous avons déjà terminé. </blockquote><p><img src="https://habrastorage.org/webt/ec/zx/xo/eczxxohgulg4yvyjdeyxvzwi3g0.png"></p><br><h2 id="the-solution">  La solution </h2><br><p>  J'ai commencé à réfléchir à la façon de résoudre mon problème et aux raisons pour lesquelles <em>les solutions communes</em> ne fonctionnent pas correctement pour mon cas d'utilisation. </p><br><blockquote>  Qu'est-ce que j'ai fait?  J'ai répertorié tous les endroits cruciaux, sans lesquels l'application ne fonctionnerait pas du tout, et j'ai essayé de comprendre pourquoi j'avais le reste. </blockquote><p>  Ce fut une surprise.  Mais mon problème était en CSS.  En transition CSS vanille. </p><br><p>  Voici le code </p><br><ul><li>  une variable de <em>contrôle</em> - <code>componentControl</code> , serait éventuellement définie sur quelque chose que <code>DisplayData</code> devrait afficher. </li><li>  une fois la valeur définie - <code>DisplayData</code> devient visible, modifiant <code>className</code> , déclenchant ainsi une transition fantaisiste.  Simultaneusly <code>FocusLock</code> devient actif faisant de <code>DisplayData</code> un <strong>modal</strong> . <br><pre> <code class="javascript hljs">&lt;FocusLock enabled={componentControl.value} <span class="hljs-comment"><span class="hljs-comment">// ^ it's "disabled". When it's disabled - it's dead. &gt; {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} // ^ it's does not exists. Also dead &lt;DisplayData data={componentControl.value} visible={componentControl.value !== null} // ^ would change a className basing on visible state /&gt; // ^ that is just not visible, but NOT dead &lt;/FocusLock&gt;</span></span></code> </pre> </li></ul><br><p>  Je voudrais coder fractionner cette pièce dans son ensemble, mais c'est quelque chose que je ne pouvais pas faire, pour deux raisons: </p><br><ol><li>  l'information doit être visible immédiatement, une fois requise, sans délai.  Une exigence commerciale. </li><li>  les informations "chrome" doivent exister avant, pour gérer la transition de la propriété. </li></ol><br><p>  Ce problème pourrait être partiellement résolu en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CSSTransitionGroup</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">reconditionné</a> .  Mais, vous savez, corriger <em>un code en</em> ajoutant <em>un autre code</em> semble bizarre, même si cela <em>suffit</em> .  Je veux dire que l'ajout de plus de code pourrait aider à supprimer encore plus de code.  Mais ... mais ... </p><br><blockquote>  Il devrait y avoir une meilleure façon! </blockquote><p>  TL; DR - il y a deux points clés ici: </p><br><ul><li>  <code>DisplayData</code> doit être <strong>monté</strong> et existe dans le DOM avant. </li><li>  <code>FocusLock</code> devrait également exister avant, pour ne pas provoquer de <code>DisplayData</code> , mais ses <strong>cerveaux ne sont pas nécessaires</strong> au début. </li></ul><br><hr><br><p>  Alors changeons notre modèle mental </p><br><h1 id="batman-and-robin">  Batman et Robin </h1><br><p>  Supposons que notre code soit Batman et Robin.  Batman peut gérer la plupart des méchants, mais quand il ne le peut pas, son acolyte Robin vient à la rescousse .. </p><br><blockquote>  Batman s'engageait à nouveau dans la bataille, Robin arrivera plus tard. </blockquote><p>  Voici Batman: </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+&lt;FocusLock - enabled={componentControl.value} +&gt; - {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} + &lt;DisplayData + data={componentControl.value} + visible={componentControl.value !== null} + /&gt; +&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Voici son acolyte, Robin :: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-&lt;FocusLock + enabled={componentControl.value} -&gt; + {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} - &lt;DisplayData - data={componentControl.value} - visible={componentControl.value !== null} - /&gt; -&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Batman et Robin pourraient former une <em>ÉQUIPE</em> , mais ils sont en réalité deux personnes différentes. </p><br><p>  Et n'oubliez pas - nous parlons toujours de <strong>fractionnement de code</strong> .  Et, en termes de fractionnement de code, où est l'acolyte?  Où est Robin? </p><br><p><img src="https://habrastorage.org/webt/m3/3a/fu/m33afuxsi_rirx3uwjusiprzj94.jpeg"></p><br><blockquote>  dans un side-car.  Robin attend dans un <strong>morceau de side</strong> - <strong>car</strong> . </blockquote><br><h1 id="sidecar">  Sidecar </h1><br><ul><li>  <code>Batman</code> est ici tout ce que votre client doit voir le plus tôt possible.  Idéalement instantanément. </li><li>  <code>Robin</code> est ici toute logique et fonctionnalités interactives de fantaisie, qui peuvent être disponibles une seconde après, mais pas au tout début. </li></ul><br><p>  Il serait préférable d'appeler cela un <strong>fractionnement de code vertical</strong> où les branches de code existent en parallèle, contrairement à un <strong>fractionnement de code horizontal</strong> commun où les branches de code sont <em>coupées</em> . </p><br><p>  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certains pays</a> , ce trio était connu comme <code>replace reducer</code> ou d'autres façons de charger la logique de redux paresseux et les effets secondaires. </p><br><p>  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certains autres pays</a> , il est connu sous le nom de <code>"3 Phased" code splitting</code> . </p><br><blockquote>  C'est juste une autre séparation des préoccupations, applicable uniquement aux cas, où vous pouvez différer le chargement d'une partie d'un composant, mais pas d'une autre partie. </blockquote><p><img src="https://habrastorage.org/webt/sw/fq/if/swfqifrldpp0n6o7qcfr6osdunk.jpeg" alt="phase 3"></p><br><blockquote>  image de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Building the New facebook.com avec React, GraphQL et Relay</a> , où <code>importForInteractions</code> ou <code>importAfter</code> <strong>sont le <code>sidecar</code></strong> . </blockquote><p>  Et il y a une observation <strong>intéressante</strong> - alors que <code>Batman</code> est plus précieux pour un client, tant que c'est quelque chose que le client peut <em>voir</em> , il est toujours en forme ... Alors que <code>Robin</code> , vous savez, il pourrait être un peu en <em>surpoids</em> et nécessiter beaucoup plus d'octets pour vivant. </p><br><p>  En conséquence - Batman seul est quelque chose de bien supportable pour un client - il offre plus de valeur à moindre coût.  Tu es mon héros Bat! </p><br><h2 id="what-could-be-moved-to-a-sidecar">  Ce qui pourrait être déplacé vers un side-car: </h2><br><ul><li>  majorité de <code>useEffect</code> , <code>componentDidMount</code> et amis. </li><li>  comme tous les effets <em>Modal</em> .  C'est à dire les verrous de <code>focus</code> et de <code>scroll</code> .  Vous pouvez d'abord afficher un modal, puis <strong>seulement</strong> faire du modal <em>modal</em> , c'est-à-dire "verrouiller" l'attention du client. </li><li>  Formulaires  Déplacez toutes les logiques et validations vers un side-car et bloquez la soumission du formulaire jusqu'à ce que cette logique soit chargée.  Le client pourrait commencer à remplir le formulaire, ne sachant pas que ce n'est que <code>Batman</code> . </li><li>  Quelques animations.  Tout un <code>react-spring</code> dans mon cas. </li><li>  Quelques trucs visuels.  Comme les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">barres de défilement personnalisées</a> , qui peuvent afficher des barres de défilement sophistiquées une seconde plus tard. </li></ul><br><p>  N'oubliez pas non plus - Chaque morceau de code, déchargé sur un sidecar, décharge également des éléments comme les poly-core et ponyfills core-js, utilisés par le code supprimé. </p><br><p>  Le fractionnement de code peut être plus intelligent qu'il ne l'est aujourd'hui dans nos applications.  Nous devons réaliser qu'il y a 2 types de <em>code</em> à diviser: 1) les aspects visuels 2) les aspects interactifs.  Ce dernier peut arriver quelques instants plus tard.  <code>Sidecar</code> facilite la séparation des deux tâches, donnant l' <em>impression que tout se charge plus rapidement</em> .  Et ce sera le cas. </p><br><h2 id="the-oldest-way-to-code-split">  La façon la plus ancienne de coder la division </h2><br><p>  Bien qu'il ne soit toujours pas très clair quand et ce qu'est un <code>sidecar</code> - <code>sidecar</code> , je vais donner une explication simple: </p><br><blockquote>  <code>Sidecar</code> est <strong>TOUS VOS SCRIPTS</strong> .  Le Sidecar est la façon dont nous <em>codons</em> avant tout ce que nous avons eu aujourd'hui. </blockquote><p>  Je parle du rendu côté serveur ( <strong>SSR</strong> ), ou simplement du <strong>HTML</strong> , <strong>auquel</strong> nous étions tous habitués hier.  <code>Sidecar</code> rend les choses aussi faciles qu'elles l'étaient lorsque les pages contenaient du HTML et de la logique vécues séparément dans des scripts externes intégrables (séparation des préoccupations). </p><br><p>  Nous avions HTML, <strong>plus</strong> CSS, <strong>plus</strong> certains scripts en ligne, <strong>plus</strong> le reste des scripts extraits dans un fichier <code>.js</code> . </p><br><p>  <code>HTML</code> + <code>CSS</code> + <code>inlined-js</code> étaient <code>Batman</code> , tandis que les scripts externes étaient <code>Robin</code> , et le site a pu fonctionner sans Robin, et, honnêtement, partiellement sans Batman (il continuera le combat avec les deux jambes (scripts intégrés) cassés).  C'était hier, et de nombreux sites "non modernes et sympas" sont les mêmes aujourd'hui. </p><br><hr><br><p>  Si votre application prend en charge SSR - essayez de <strong>désactiver js</strong> et de le faire fonctionner sans lui.  Ensuite, il serait clair ce qui pourrait être déplacé vers un side-car. <br>  Si votre application est un SPA côté client uniquement - essayez d'imaginer comment cela fonctionnerait, si la SSR existait. </p><br><blockquote>  Par exemple - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">theurge.com</a> , écrit en React, est entièrement fonctionnel <strong>sans aucun js activé</strong> . </blockquote><p>  Il y a beaucoup de choses que vous pouvez décharger sur un side-car.  Par exemple: </p><br><ul><li>  commentaires.  Vous pouvez envoyer du code pour <code>display</code> commentaires, mais pas <code>answer</code> , tant qu'il peut nécessiter plus de code (y compris l'éditeur WYSIWYG), ce qui n'est pas nécessaire au départ.  Il est préférable de retarder une zone de <em>commentaires</em> , ou même de masquer le chargement du code derrière l'animation, plutôt que de retarder une page entière. </li><li>  lecteur vidéo.  Expédiez la "vidéo" sans "commandes".  Chargez-les une seconde plus tard, le client pourrait essayer d'interagir avec lui. </li><li>  galerie d'images, comme <code>slick</code> .  Ce n'est pas un gros problème pour le <strong>dessiner</strong> , mais beaucoup plus difficile à animer et à gérer.  Il est clair ce qui pourrait être déplacé vers un side-car. </li></ul><br><blockquote>  Pensez simplement à ce qui est essentiel pour votre application et à ce qui ne l'est pas tout à fait ... </blockquote><br><h1 id="implementation-details">  Détails d'implémentation </h1><br><h2 id="di-component-code-splitting">  (DI) Fractionnement du code composant </h2><br><p>  La forme la plus simple de <code>sidecar</code> est facile à implémenter - déplacez simplement tout vers un sous-composant, vous pouvez coder le fractionnement en utilisant une "ancienne" méthode.  C'est presque une séparation entre les composants Smart et Dumb, mais cette fois, Smart ne <em>contient</em> pas un <em>composant</em> Dumb - c'est l'opposé. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SmartComponent = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./SmartComponent'</span></span>)); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DumbComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;React.Fragment&gt; &lt;SmartComponent ref={this} /&gt; // &lt;-- move smart one inside &lt;TheActualMarkup /&gt; // &lt;-- the "real" stuff is here &lt;/React.Fragment&gt; } }</code> </pre> <br><p>  Cela nécessite également de déplacer le code d' <em>initialisation</em> vers un code muet, mais vous pouvez toujours diviser en code la partie la <em>plus lourde</em> d'un code. </p><br><blockquote>  Pouvez-vous voir un modèle de fractionnement de code <code>parallel</code> ou <code>vertical</code> maintenant? </blockquote><br><h2 id="usesidecar">  useSidecar </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Construire le nouveau facebook.com avec React, GraphQL et Relay</a> , je l'ai déjà mentionné ici, avait un concept de <code>loadAfter</code> ou <code>importForInteractivity</code> , qui est assez similaire au concept de sidecar. </p><br><p>  Dans le même temps, je ne recommanderais pas de créer quelque chose comme <code>useSidecar</code> tant que vous pourriez intentionnellement essayer d'utiliser des <code>hooks</code> intérieur, mais le fractionnement de code sous cette forme violerait la <em>règle des hooks</em> . </p><br><p>  Veuillez préférer une méthode de composants plus déclarative.  Et vous pouvez utiliser des <code>hooks</code> intérieur <code>SideCar</code> composant <code>SideCar</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Controller = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./Controller'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DumbComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = useState(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;Controller componentRef={ref} state={state} /&gt; &lt;TheRealStuff ref={ref} state={state[0]} /&gt; &lt;/&gt; ) }</code> </pre> <br><h2 id="prefetching">  Prélecture </h2><br><p>  N'oubliez pas - vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des indications de priorité de chargement</a> pour précharger ou précharger le <code>sidecar</code> - <code>sidecar</code> et le rendre plus transparent et invisible. </p><br><p>  Choses importantes - la prélecture des scripts la chargerait via le <strong>réseau</strong> , mais ne s'exécuterait pas (et ne dépenserait pas de CPU) à moins que cela ne soit réellement nécessaire. </p><br><h2 id="ssr">  SSR </h2><br><p>  Contrairement au fractionnement de code <em>normal</em> , aucune action spéciale n'est requise pour SSR.  <code>Sidecar</code> peut ne pas faire partie du processus SSR et n'est pas requis avant l'étape d' <code>hydration</code> .  Il pourrait être reporté "par conception". </p><br><p>  Ainsi - n'hésitez pas à utiliser <code>React.lazy</code> (idéalement quelque chose <strong>sans</strong> <code>Suspense</code> , vous n'avez pas besoin d'indicateurs de rétablissement (chargement) ici), ou toute autre bibliothèque, avec, mais mieux sans le support SSR pour <em>ignorer les</em> morceaux de side-car pendant le processus SSR. </p><br><h1 id="the-bad-parts">  Les mauvaises parties </h1><br><p>  Mais il y a quelques mauvaises parties de cette idée </p><br><h2 id="batman-is-not-a-production-name">  Batman n'est pas un nom de production </h2><br><p>  Alors que <code>Batman</code> / <code>Robin</code> pourrait être un bon concept d'esprit, et que le <code>sidecar</code> - <code>sidecar</code> est parfaitement adapté à la technologie elle-même - il n'y a pas de "bon" nom pour la <code>maincar</code> .  Il n'y a rien de tel qu'une <code>maincar</code> , et évidemment <code>Batman</code> , <code>Lonely Wolf</code> , <code>Solitude</code> , <code>Driver</code> et <code>Solo</code> ne doivent pas être utilisés pour nommer une partie autre qu'un side-car. </p><br><p>  Facebook a utilisé l' <code>display</code> et l' <code>interactivity</code> , et cela pourrait être la meilleure option pour nous tous. </p><br><blockquote>  Si vous avez un bon nom pour moi - laissez-le dans les commentaires </blockquote><br><h2 id="tree-shaking">  Tremblement d'arbre </h2><br><p>  Il s'agit davantage de la séparation des préoccupations du point de vue du <em>bundler</em> .  Imaginons que vous ayez <code>Batman</code> et <code>Robin</code> .  Et <code>stuff.js</code> </p><br><ul><li> <code>stuff.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./batman.js`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./robin.js`</span></span></code> </pre> </li></ul><br><p>  Ensuite, vous pouvez essayer de fractionner le code du <em>composant</em> pour implémenter un side-car </p><br><ul><li><p> <code>main.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {batman} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./stuff.js'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Robin = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./sidecar.js'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Robin</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // sidecar </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Batman</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // main content </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br></li><li><p> <code>sidecar.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// and sidecar.js... that's another chunk as long as we `import` it import {robin} from './stuff.js' .....</span></span></code> </pre> <br></li></ul><br><p>  En bref - le code ci-dessus fonctionnerait, mais ne fera pas "le travail". </p><br><ul><li>  si vous utilisez uniquement <code>batman</code> de <code>stuff.js</code> - le tremblement d'arbre ne le conservera que. </li><li>  si vous utilisez uniquement <code>robin</code> de <code>stuff.js</code> - le tremblement d'arbre ne le conservera que. </li><li>  <strong>mais</strong> si vous utilisez les deux, même dans des morceaux différents - les deux seront regroupés dans une <strong>première</strong> occurrence de <code>stuff.js</code> , c'est-à-dire le <strong>regroupement principal</strong> . </li></ul><br><blockquote>  Le tremblement d'arbre n'est pas convivial pour le fractionnement de code.  Vous devez séparer les préoccupations par fichiers. </blockquote><br><h2 id="un-import">  Désimporter </h2><br><p>  Une autre chose, oubliée par tout le monde, est le coût du javascript.  Il était assez courant à l'ère jQuery, l'ère de la charge utile <code>jsonp</code> de charger le script (avec la charge utile <code>json</code> ), d'obtenir la charge utile et de <strong>supprimer</strong> le script. </p><br><blockquote>  De nos jours, nous <code>import</code> tous du script, et il sera importé pour toujours, même s'il n'est plus nécessaire. </blockquote><p>  Comme je l'ai déjà dit - il y a trop de JS, et tôt ou tard, avec <em>une navigation continue,</em> vous allez tout charger.  Nous devons trouver un moyen de désimporter sans avoir besoin de morceaux, en effaçant tous les caches internes et en libérant de la mémoire pour rendre le Web plus fiable, et ne pas écraser les applications avec des exceptions de mémoire insuffisante. </p><br><p>  La possibilité de désimporter (le webpack <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pourrait le faire</a> ) est probablement l'une des raisons pour lesquelles nous devrions nous en tenir à l'API <em>basée</em> sur les <em>composants</em> , à condition qu'elle nous donne la possibilité de gérer le <code>unmount</code> . </p><br><p>  Jusqu'à présent - les normes des modules ESM n'ont rien à voir avec des choses comme ça - ni sur le contrôle du cache, ni sur l'inversion de l'action d'importation. </p><br><h2 id="creating-a-sidecar-enabled-library">  Création d'une bibliothèque compatible side-car </h2><br><p>  À l'heure actuelle, il n'y a qu'une seule façon de créer une bibliothèque compatible avec les <code>sidecar</code> cars: </p><br><ul><li>  divisez votre composant en parties </li><li>  exposer une partie <code>main</code> et une partie <code>connected</code> (pour ne pas casser l'API) via un <code>index</code> </li><li>  exposer un <code>sidecar</code> - <code>sidecar</code> via un point d'entrée séparé. </li><li>  dans le code cible - importez la partie <code>main</code> et le <code>sidecar</code> - la secousse de l'arbre devrait couper une partie <code>connected</code> . </li></ul><br><p>  Cette fois, le tremblement de l'arbre devrait fonctionner correctement, et le seul problème - est de savoir comment nommer la partie <code>main</code> . </p><br><ul><li> <code>main.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Main = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{sidecar, ...props}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {sidecar} .... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><ul><li> <code>connected.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Sidecar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Main</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sidecar</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Sidecar</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">} {...props} /&gt; );</span></span></code> </pre> <br><ul><li> <code>index.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Main'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Connected'</span></span>;</code> </pre> <br><ul><li> <code>sidecar.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>;</code> </pre> <br><p>  En bref, le changement pourrait être représenté par une petite comparaison </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//your app BEFORE import {Connected} from 'library'; // // ------------------------- //your app AFTER, compare this core to `connected.js` import {Main} from 'library'; const Sidecar = React.lazy(import( () =&gt; import('library/sidecar'))); // ^ all the difference ^ export SideConnected = props =&gt; ( &lt;Main sidecar={&lt;Sidecar /&gt;} {...props} /&gt; ); // ^ you will load only Main, Sidecar will arrive later.</span></span></code> </pre> <br><p>  L' <code>dynamic import</code> théoriquement <code>dynamic import</code> pourrait être utilisée à l'intérieur de node_modules, rendant le <em>processus d'assemblage</em> plus transparent. </p><br><blockquote>  Quoi qu'il en soit - ce n'est rien de plus que le modèle <code>children</code> / <code>slot</code> , si commun dans React. </blockquote><br><h1 id="the-future">  Le futur </h1><br><p>  <code>Facebook</code> prouvé que l'idée était bonne.  Si vous n'avez pas vu cette vidéo, faites-le maintenant.  Je viens d'expliquer la même idée sous un angle un peu différent (et j'ai commencé à écrire cet article une semaine avant la conférence F8). </p><br><p>  À l'heure actuelle, il nécessite que certains changements de code soient appliqués à votre base de code.  Il faut une séparation plus explicite des préoccupations pour les séparer réellement, et laisser les codesplit non pas horizontalement, mais verticalement, expédiant <em>moins de</em> code pour une <em>plus grande</em> expérience utilisateur. </p><br><p>  <code>Sidecar</code> , probablement, est le seul moyen, à l'exception du SSR old school, de gérer les bases de code BIG.  Dernière chance d'envoyer une quantité minimale de code, lorsque vous en avez beaucoup. </p><br><blockquote>  Cela pourrait rendre une grande application plus petite et une petite application encore plus petite. </blockquote><p>  Il y a 10 ans, le site Web moyen était "prêt" en 300 ms, et était <em>vraiment</em> prêt quelques millisecondes après.  Aujourd'hui, les secondes et même plus de 10 secondes sont les nombres communs.  Quelle honte. </p><br><p>  Prenons une pause et réfléchissons à la façon dont nous pourrions résoudre le problème et rendre à nouveau UX génial ... </p><br><p><img src="https://habrastorage.org/webt/8_/5u/7e/8_5u7ehdn7nkcjiaqfv1-rzadfa.jpeg"></p><br><h1 id="overall">  Global </h1><br><ul><li>  Le fractionnement du code des composants est un outil très puissant, vous donnant la possibilité de fractionner <em>complètement</em> quelque chose, mais il a un coût - vous n'aurez peut-être rien à afficher, sauf une page vierge ou un <em>squelette</em> pendant un certain temps.  C'est une séparation horizontale. </li><li>  La division du code de la bibliothèque pourrait aider lorsque la séparation des composants ne le serait pas.  C'est une séparation horizontale. </li><li>  Le code, déchargé sur un sidecar compléterait l'image et pourrait vous permettre de fournir une bien meilleure expérience utilisateur.  Mais cela nécessiterait également des efforts d'ingénierie.  C'est une séparation verticale. </li></ul><br><p>  <strong>Ayons une conversation à ce sujet</strong> . </p><br><h2 id="stop-so-what-about-the-problems-you-tried-to-solve">  Arrête!  Qu'en est-il des problèmes que vous avez essayé de résoudre? </h2><br><p>  Eh bien, ce n'était que la première partie.  <strong>Nous sommes maintenant dans la phase finale</strong> , il faudrait encore quelques semaines pour rédiger la deuxième partie de cette proposition.  Pendant ce temps ... montez dans le side-car! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr450942/">https://habr.com/ru/post/fr450942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr450926/index.html">Jeu 3D sur three.js, nw.js</a></li>
<li><a href="../fr450928/index.html">Comment les centres de données sauvent les vacances</a></li>
<li><a href="../fr450930/index.html">Comment nous développons # bigdataX5 et qui est nécessaire dans le Big Data</a></li>
<li><a href="../fr450938/index.html">Linux Install Fest 05.19 à Nizhny Novgorod 18 mai 2019</a></li>
<li><a href="../fr450940/index.html">Vivaldi 2.5 - Macrocosme attrayant</a></li>
<li><a href="../fr450946/index.html">Disque cellulaire sur LPC810</a></li>
<li><a href="../fr450948/index.html">MU-MIMO: l'un des algorithmes d'implémentation</a></li>
<li><a href="../fr450950/index.html">Dart Streams Basics</a></li>
<li><a href="../fr450952/index.html">Indice moyen et antibank</a></li>
<li><a href="../fr450954/index.html">Comment nous avons appris à exploiter Java dans Docker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>