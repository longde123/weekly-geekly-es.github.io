<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏼 🙎🏿 👍🏽 在命令行中快速有效地工作 👩🏿‍🤝‍👩🏾 👨‍🎓 👉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="互联网上有很多命令行技巧和指标。 他们中的大多数都将琐碎的事情描述为“学习热键”或“ sudo !!将使用sudo运行先前的命令”。 取而代之的是，当您已经学会了热键并了解sudo !!时，我会告诉您该怎么做sudo !! 。 
 终端应立即启动 


 您花费多少时间启动终端机？ 还有一个？ 很长...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在命令行中快速有效地工作</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481940/"><p>互联网上有很多命令行技巧和指标。 他们中的大多数都将琐碎的事情描述为“学习热键”或“ <code>sudo !!</code>将使用sudo运行先前的命令”。 取而代之的是，当您已经学会了热键并了解<code>sudo !!</code>时，我会告诉您该怎么做<code>sudo !!</code>  。 </p><a name="habracut"></a><br><h3 id="the-terminal-should-start-instantly"> 终端应立即启动 </h3><br><p> 您花费多少时间启动终端机？ 还有一个？ 很长时间以来，我一直使用Ctrl + Alt + T快捷方式启动终端，我认为它很快。 从Openbox迁移到i3后，我开始通过Win + Enter启动终端，该绑定开箱即用。 你知道吗 现在，我认为Ctrl + Alt + T不够快。 </p><br><p> 当然，这不是毫秒级的提速，而是您在反射级别打开终端，完全没有意识到。 </p><br><p> 因此，如果您经常使用终端，但是抓住鼠标来启动它，请尝试配置方便的热键。 我敢肯定，您会喜欢的。 </p><br><h3 id="zsh-instead-of-bash">  Zsh代替bash </h3><br><p> 我知道这是一个神圣的话题。 您应该为至少三个功能安装Zsh：高级自动完成，错字校正和多个路径名完成：当单个Tab将<code>/u/s/d</code>转换为<code>/usr/share/doc</code> 。  Arch Linux已经在其安装CD中迁移到Zsh。 我希望Zsh能够成为Ubuntu中的默认Shell。 那将是一个历史性的时刻。 </p><br><p> 开始使用Zsh一点也不困难。 只需通过包管理器安装它，然后找到一个漂亮的配置即可。 我建议采用Arch Linux中使用的配置： </p><br><pre> <code class="plaintext hljs">$ wget -O ~/.zshrc https://git.grml.org/f/grml-etc-core/etc/zsh/zshrc</code> </pre> <br><p> 剩下的唯一一件事就是更改您的默认Shell并重新登录。 </p><br><pre> <code class="plaintext hljs">$ chsh -s $(which zsh)</code> </pre> <br><p> 仅此而已，就像什么都没有发生一样，继续工作。 </p><br><h3 id="how-the-shell-prompt-should-look-like">  shell提示应该是什么样子 </h3><br><p>  Shell提示符是命令行开头在终端中显示的一小段文本。 应该为您的工作进行配置。 您可以将其视为车辆的仪表板。 请在此放置一些有用的信息，以帮助您导航！ 方便使用，尤其是每天都看到的时候！ </p><br><p> 外壳提示应为彩色。 不同意吗？ 尝试计算在此终端中执行了多少命令： </p><br><p><img src="https://habrastorage.org/webt/yh/mu/s7/yhmus7x5-abqnlrho5u5djwau8o.png"></p><br><p> 现在带有颜色： </p><br><p><img src="https://habrastorage.org/webt/re/1b/ln/re1blnqfemmydwf99758sbirqai.png"></p><br><p>  Shell提示符应显示Shell的当前工作目录。 如果未显示当前工作目录，则必须牢记该目录，并使用<code>pwd</code>命令定期对其进行检查。 请不要那样做。 请记住一些非常重要的事情，不要浪费时间执行<code>pwd</code>命令。 </p><br><p> 如果有时切换到root帐户，则需要“当前用户”指示。 特定的用户名通常并不重要，但是它的状态（常规或root）才是重要的。 解决方案是使用颜色：红色shell提示输入root，绿色提示普通用户。 而且您将永远不会像常规那样接管root shell。 </p><br><p> 如果使用ssh连接到服务器，则需要区分本地外壳程序和远程外壳程序。 为此，您的shell提示应包含一个主机名，甚至更好-指示ssh连接。 </p><br><p>  Shell提示符可以显示最后一条命令的退出代码。 请记住，退出代码为零表示命令成功退出，非零表示命令成功退出。 您可以通过<code>echo $?</code>获得上一条命令的退出代码<code>echo $?</code>  ，但输入所有内容都是一件漫长的事情。 让外壳显示不成功的退出。 </p><br><p> 如果您使用Git仓库，那么在shell提示符下查看存储库状态会很有用：当前分支和工作目录的状态。 您将在<code>git status</code>和<code>git branch</code>命令上节省一些时间，并且不会提交到错误的分支。 是的，在脂肪储存库中，状态的计算可能会花费大量时间，但对我而言，不利因素超过了缺点。 </p><br><p> 有人在shell提示中添加了时钟，甚至在虚拟终端（tty）的名称中添加了时钟，或者在一些任意的波形上添加了时钟。 都是多余的。 最好为命令留出更多空间。 </p><br><p> 那就是我的shell提示符在不同条件下的样子： </p><br><p><img src="https://habrastorage.org/webt/ka/q3/gf/kaq3gfz9idb6pkxdglx44qyuxlq.png"></p><br><p> 您可以在屏幕截图中看到终端标题栏执行了类似的工作。 它也是仪表板的一部分，还应该进行配置。 </p><br><p> 那么，所有这些东西应该如何在<code>.zshrc</code>实现？  <code>PROMPT</code>变量设置左提示，而<code>RPROMPT</code>设置右提示。  <code>EUID</code>变量定义用户（常规或root）的状态，并且<code>SSH_CLIENT</code>或<code>SSH2_CLIENT</code>存在表示ssh连接。 所以我们可以有一个模板： </p><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH_CLIENT</span></span></span><span class="hljs-string">"</span></span> || -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH2_CLIENT</span></span></span><span class="hljs-string">"</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$EUID</span></span> == 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment"># not SSH if [[ $EUID == 0 ]]; then PROMPT=... else PROMPT=... fi fi</span></span></code> </pre> <br><p> 我不显示可复制粘贴的代码，因为确切的实现只取决于口味。 如果您不想打扰，并且上面的屏幕截图适合您，则可以从<a href="" rel="nofollow">Github中</a>获取我的cofig。 </p><br><p> 总结： </p><br><ul><li> 彩色外壳提示是必须具备的。 </li><li> 最低要求是当前工作目录。 </li><li> 根壳应该清晰可见。 </li><li> 如果您仅使用一个帐户，则用户名不在乎有效负载。 </li><li> 如果通过ssh连接到服务器，则主机名很有用，如果不是，则不是必需的。 </li><li> 查看最后一个命令的失败退出代码很有用。 </li><li>  Git回购状态节省了<code>git status</code>和<code>git branch</code>命令的时间，并提供了万无一失的方法。 </li></ul><br><h3 id="heavily-use-the-command-history"> 大量使用命令历史记录 </h3><br><p> 您一生中大部分命令都会多次输入，因此将其从历史记录中拉出而不是再次键入很酷。 所有现代外壳程序都保存命令历史记录，并提供了几种搜索历史记录的方式。 </p><br><p> 也许您已经可以使用Ctrl + R键绑定来挖掘历史记录。 不幸的是，它有两个缺点： </p><br><ol><li> 命令行应该为空以开始搜索，例如，如果“一个人开始键入命令-记住了搜索”，则必须先清除输入内容，然后按Ctrl + R并重复输入。 太久了 </li><li> 由于Ctrl + S停止了终端，因此默认搜索无法进行正向搜索。 </li></ol><br><p> 最快速，最方便的搜索类型通过以下方式工作： </p><br><ol><li> 您开始输入命令， </li><li> 您还记得有关搜索的信息， </li><li> 按下热键，shell将以相同的方式从历史记录中提供命令。 </li></ol><br><p> 例如，您想使用Rsync将本地目录与远程目录同步，而您已经在两个小时前完成了。 键入<code>rsync</code> ，按热键一两次，即可启动所需的命令。 您无需先打开搜索模式，shell提示符不会更改为<code>(reverse-i-search)':</code> ：，并且任何地方都不会跳动。 您只需按箭头↑↓滚动历史记录，即可滚动浏览先前输入的命令，但具有其他过滤功能。 真是太酷了，节省了很多时间。 </p><br><p> 默认情况下，这种搜索在Bash和Zsh中不起作用，因此您必须手动启用它。 我选择PgUp进行向前搜索，选择PgDown进行向后搜索。 距离他们很远，但是我已经养成了习惯。 也许以后我会切换到更接近的位置，例如Ctrl + P和Ctrl +N。 </p><br><p> 对于Bash，您需要在<code>~/.inputrc</code> <code>/etc/inputrc</code>中添加几个字符串： </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[5~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[6~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p> 如果您使用了外国完整的<code>.zshrc</code> ，则很有可能PgUp和PgDown已经完成了该工作。 如果没有，则添加到<code>~/.zshrc</code> ： </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[5~"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-beginning-search-backward <span class="hljs-comment"><span class="hljs-comment"># pg up bindkey "^[[6~" history-beginning-search-forward # pg down</span></span></code> </pre> <br><p>  Fish和Ipython壳已经具有与箭头↑↓绑定的搜索。 我认为许多用户只是出于箭头行为而迁移到了Fish。 当然，如果需要，可以在Bash和Zsh中以这种方式绑定箭头。 在<code>~/.inputrc</code> <code>/etc/inputrc</code>中<code>~/.inputrc</code> ： </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[A"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[B"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p> 这在<code>~/.zshrc</code> ： </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[A"</span></span> up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[B"</span></span> down-line-or-beginning-search</code> </pre> <br><p> 奇怪的是，随着时间的流逝，我开始编写命令时会牢记，稍后我会将它们从历史中拉出来。 让我向您展示一些技巧。 </p><br><p>  <strong>加入</strong>始终相互遵循<strong>的命令</strong> ： </p><br><pre> <code class="plaintext hljs"># ip link set eth1 up &amp;&amp; dhclient eth1 # mkdir /tmp/t &amp;&amp; mount /dev/sdb1 /tmp/t</code> </pre> <br><p>  <strong>绝对路径而不是相对路径</strong>使您可以从任何目录运行命令： <br>  <code>systemd-nspawn /home/chroot/stretch</code> <code>vim ~/.ssh/config</code>代替<code>systemd-nspawn /home/chroot/stretch</code> <code>vim .ssh/config</code> ，用<code>systemd-nspawn /home/chroot/stretch</code>代替<code>systemd-nspawn stretch</code>等。 </p><br><p>  <strong>通配符的使用</strong>使您的命令更加通用。 我通常将它与<code>chmod</code>和<code>chown</code>结合使用。 </p><br><pre> <code class="plaintext hljs"># chown root:root /var/www/*.sq &amp;&amp; chmod 644 /var/www/*.sq</code> </pre> <br><h3 id="keyboard-shortcuts"> 键盘快捷键 </h3><br><p> 这是最低要求。 </p><br><p>  Alt +。  -替换上一个命令的最后一个参数。 也可以使用<code>!$</code>进行访问。 <br>  Ctrl + A，Ctrl + E-分别跳至该行的开头和结尾。 <br>  Ctrl + U，Ctrl + Y-剪切和粘贴。 当您键入复杂的命令并注意到需要首先执行另一个命令时，这非常方便。 嗯，在哪里保存当前输入？ 就在这里 <br>  Ctrl + W-杀死光标前的一个单词。 按住不放会清除该行。 默认情况下，输入保存到剪贴板（用于Ctrl + Y）。 <br>  Ctrl + K-剪切光标后的部分行，将其添加到剪贴板。  Ctrl + A Ctrl + K快速清除该行。 <br>  PgUp，PgDown，Ctrl + R-历史记录搜索。 <br>  Ctrl + L清除终端。 </p><br><h3 id="keyboard-responsiveness"> 键盘响应度 </h3><br><p> 我想向您展示一个小的设置，使您可以更快地滚动，导航和擦除。 当我们要擦除大的东西时我们该怎么办？ 我们按住Backspace并观察它向后擦字符。 到底是怎么回事？ 按下Backspace键后，一个字符消失，然后经过一小段延迟，然后触发自动重复：Backspace一次又一次擦除字符，就像您反复按下它一样。 </p><br><p> 我建议您根据手指的速度调整延迟和自动重复频率。 如果您只想擦除一个字符，则需要延迟-它使您有时间释放键。 太大的延迟会使您等待自动重复。 这不足以让您感到烦恼，但足以减慢您的思想从头脑向计算机的转移。 自动重复频率越大，删除文本的速度就越快，停止此过程就越困难。 目的是找到最佳值。 </p><br><p> 因此，魔术命令是： </p><br><pre> <code class="plaintext hljs">$ xset r rate 190 20</code> </pre> <br><p>  190-延迟持续时间（以毫秒为单位）， <br>  20-每秒重复的频率。 </p><br><p> 我建议从这些值开始，并逐渐增加延迟，直到出现误报，然后再返回一点。 如果延迟太小，您将无法使用键盘。 要解决此问题，应重新启动X服务器或完整的计算机。 所以，请小心。 </p><br><p> 为了保存参数，您需要在X自动启动的某处添加此命令。 </p><br><h3 id="process-exit-indication"> 流程退出指示 </h3><br><p> 我经常不得不开始一些长期运行的过程：繁琐的备份，大数据传输，归档打包/提取，打包构建等等。 通常，我会启动这样一个过程，切换到另一个任务，如果我的长时间运行过程已经退出，则偶尔会凝视。 有时我会投入太多工作而忘了它。 解决方案是添加流程退出通知，这将使我摆脱困境。 </p><br><p> 有许多用于此目的的工具：通知发送，dzen2，蜂鸣，播放，隔离。 所有这些都以某种方式很好，但是不适用于ssh连接。 这就是为什么我使用终端提示音： </p><br><pre> <code class="plaintext hljs">$ long-running-command; echo $'\a'</code> </pre> <br><p>  ASCII编码具有0x7字符，名为<a href="https://en.wikipedia.org/wiki/Bell_character" rel="nofollow">bell</a> 。 它用于蜂鸣PC扬声器。  PC扬声器不是现代事物，不是每台计算机都具备，并且耳机中听不到。 这就是为什么某些终端使用所谓的可视铃。 我使用urxvt，它通过提高紧急标志来执行可视铃声。 怎么了 当窗口想告诉您紧急情况时，可以使用此功能。 </p><br><p> 您现在可以检查终端对铃声的反应： </p><br><pre> <code class="plaintext hljs">$ sleep 3; echo $'\a'</code> </pre> <br><p> 您可能需要三秒钟才能切换到另一个窗口。 </p><br><p> 不幸的是，并非每个终端都可以通过提高紧急标志来显示可视铃声。 我检查了最受欢迎的。 </p><br><div class="scrollable-table"><table><thead><tr><th> 终端模拟器 </th><th> 可视铃作为紧急标志 </th></tr></thead><tbody><tr><td> 康索尔 </td><td> 可以在首选项中启用 </td></tr><tr><td>  urxvt </td><td> 是的 </td></tr><tr><td>  xfce4终端 </td><td> 可以在首选项中启用 </td></tr><tr><td>  xterm </td><td> 没有啦 </td></tr><tr><td> 很酷的复古词 </td><td> 没有啦 </td></tr><tr><td> 终端 </td><td> 没有啦 </td></tr><tr><td> 侏儒终端 </td><td> 没有啦 </td></tr></tbody></table></div><br><p> 输入<code>echo $'\a'</code>太长<code>echo $'\a'</code> ，所以我做了一个<code>wake</code>别名。 </p><br><h3 id="aliases"> 别名 </h3><br><p> 默认情况下， <code>cp</code> ， <code>scp</code>和<code>rm</code>命令是非递归工作的，这很糟糕！ 这是该死的糟糕遗产！ 好吧，可以使用别名对其进行修复。 但是首先让我们看看非递归行为何时有用。 </p><br><pre> <code class="plaintext hljs">$ mkdir foodir $ cp * foodir</code> </pre> <br><p> 仅文件将被复制到<code>foodir</code> ，而不是目录。  <code>rm</code>同样的情况： </p><br><pre> <code class="plaintext hljs">$ rm *</code> </pre> <br><p> 将仅删除文件和符号链接，但保留目录。 但是，您多久需要一次此功能？ 我喜欢认为<code>cp</code>和<code>rm</code>总是递归工作。 </p><br><p> 好的，但是安全性如何？ 也许非递归行为可以保护您的文件？ 在一种情况下，您有一个指向目录的符号链接，并且想要删除该符号链接，但保留目录。 如果在目录名后附加（有意或无意）斜杠，并且通过<code>-r</code>启用了递归模式，则目录将为空！ 空！ </p><br><pre> <code class="plaintext hljs">$ ln -s foodir dir_link $ rm -r dir_link/</code> </pre> <br><p> 如果没有<code>-r</code> arg，它将滥用并且不会删除任何内容。 因此，递归<code>rm</code>增加了丢失数据的风险。 </p><br><p> 我为<code>cp</code> ， <code>scp</code>和<code>rm</code>启用了递归模式，还为<code>mkdir</code>添加了<code>-p</code>来轻松创建嵌套目录。 </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> cp=<span class="hljs-string"><span class="hljs-string">'cp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> scp=<span class="hljs-string"><span class="hljs-string">'scp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> rm=<span class="hljs-string"><span class="hljs-string">'rm -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> mkdir=<span class="hljs-string"><span class="hljs-string">'mkdir -p'</span></span></code> </pre> <br><p> 两年来，我从未为这些别名感到后悔，也从未丢失数据。 还有一个缺点：复制/删除的数据可能少于需要的数量，并且在没有别名的系统上工作时看不到它。 因此，请小心。 我知道我做什么，并总是谨慎地运行<code>rm</code> 。 </p><br><p> 最受欢迎的是<code>ls</code>别名，您可能已经在使用它们： </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ls=<span class="hljs-string"><span class="hljs-string">'ls -F --color=auto'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> la=<span class="hljs-string"><span class="hljs-string">'ls -A'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ll=<span class="hljs-string"><span class="hljs-string">'ls -lh'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> lla=<span class="hljs-string"><span class="hljs-string">'ll -A'</span></span></code> </pre> <br><p> 同样，彩色grep比无色grep更漂亮： </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> grep=<span class="hljs-string"><span class="hljs-string">'grep --colour=auto'</span></span></code> </pre> <br><p> 别名在脚本中不起作用，请不要忘记这一事实！ 您必须明确指定所有参数。 </p><br><h3 id="touch-typing"> 触摸打字 </h3><br><p> 这很明显，但我提醒您：触摸打字有助于快速打字。 一开始会很困难，但是随着时间的推移，您将克服这些限制。 </p><br><p> 学习触摸打字的最佳时间是休假，没有人打扰您。 学习时请不要着急！ 您的目标是<em>记住</em>每个角色的位置，而不是记住您的大脑，而是记住您的手指。 最好输入慢速，但不要输入错误，而不要输入有错误的快速输入。 请记住，大师们的成绩不是靠快速手指就能实现的，而不会犯错误。 </p><br><p> 不要忘记休息一下。 您的大脑和手指需要休息。 当错误开始出现时，这意味着您需要休息一下。 </p><br><h3 id="that-is-all-for-today"> 今天就这些 </h3><br><p> 希望这些提示对您有所帮助。 祝你好运！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481940/">https://habr.com/ru/post/zh-CN481940/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481926/index.html">满足适用于AWS的新Veeam Backup解决方案</a></li>
<li><a href="../zh-CN481930/index.html">发展文化：如何评估绩效和效率</a></li>
<li><a href="../zh-CN481932/index.html">零停机时间部署和数据库</a></li>
<li><a href="../zh-CN481934/index.html">分析：特斯拉股价为何上涨</a></li>
<li><a href="../zh-CN481936/index.html">A / B测试的优缺点：大公司的经验</a></li>
<li><a href="../zh-CN481942/index.html">回到未来：2010年展示了哪些现代游戏</a></li>
<li><a href="../zh-CN481944/index.html">是什么决定了网站在搜索页面上的位置？</a></li>
<li><a href="../zh-CN481946/index.html">Microsoft团队中的交流方法：渠道VS聊天</a></li>
<li><a href="../zh-CN481948/index.html">如何创建虚拟机器人？</a></li>
<li><a href="../zh-CN481950/index.html">教程：响应式Spring Boot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>