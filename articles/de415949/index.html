<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥧 🍿 🖖🏾 High Mining: Die neueste Option zum Schutz der PoW-Blockchain vor einem „51% -Angriff“. ✂️ ✋🏿 👨🏾‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Entwickler der Litecoin Cash-Gabel präsentierten einen Vorabdruck des technischen Dokuments ' The Hive: Agent-based Mining in Litecoin Cash ', in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>High Mining: Die neueste Option zum Schutz der PoW-Blockchain vor einem „51% -Angriff“.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415949/"><img src="https://habrastorage.org/webt/d1/oo/5w/d1oo5wr_cgcroc3091uoyu1trbw.png" alt="Bild"><br><br>  Die Entwickler der Litecoin Cash-Gabel präsentierten einen Vorabdruck des technischen Dokuments ' <i>The Hive: Agent-based Mining in Litecoin Cash</i> ', in dem sie ihren Vorschlag zum Schutz der Kryptowährungs-Blockchain basierend auf dem Proof-of-Work-Algorithmus vor einem „51% -Angriff“ beschrieben.  Ihre Lösung kombiniert Mining mit alternden ASIC-Geräten (SHA-256) und demokratisches virtuelles Mining mit „Working Bees“ (HiveMine).  Bei ordnungsgemäßer Implementierung der Blockchain wird LCC eines der größten Probleme moderner Blockchain-Projekte (von Bitcoin bis Ethereum) lösen: die Gefahr eines Angriffs, wenn mehr als die Hälfte der gesamten Netzwerkleistung in den Händen des Angreifers konzentriert ist. <br><a name="habracut"></a><br><h3>  51% Angriffsproblem </h3><br>  Diejenigen, die den Kryptowährungsmarkt überwachen, konnten den jüngsten Ausbruch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von 51% Angriffen</a> auf relativ kleine PoW-Projekte (Proof-of-Work - „Proof-of-Work-done“) nicht übersehen, als Angreifer Transaktionen umschrieben und Gelder so schnell wie möglich über Börsen transferierten.  "Relativ" bedeutet in diesem Fall, dass ein kleiner Teil der Geräte, die die kryptografische Sicherheit einer großen Blockchain unterstützen (z. B. Bitcoin oder Ethereum), ausreicht, um den Konsens einer kleinen Blockchain zu brechen, die mit demselben Hash-Algorithmus arbeitet (Bitcoin Cash bzw. Bitcoin Gold). . <br><br>  Bei Kryptowährungen, die den SHA-256-Algorithmus (LCC oder BCH) als Grundlage für die Verschlüsselung verwenden, wird das Risiko durch die Tatsache erhöht, dass die größte und sicherste Kryptowährung der Welt - Bitcoin (BTC) - mit demselben Algorithmus arbeitet. <br><br>  In diesem Artikel konzentrieren wir uns auf das mathematische Modell des Schutzes vor 51% -Angriffen und heben oberflächlich die wichtigsten verwandten Begriffe und Konzepte hervor, die in der Kryptographie von Blockchains verwendet werden. <br><br><h3>  Einführung in den Hochbergbau </h3><br>  Im klassischen PoW-Blockchain-Sicherheitsschema konkurrieren Bergleute, indem sie eine große Anzahl potenzieller Block-Hashes berechnen, um einen zu finden, der die im Netzwerkkonsens festgelegten Komplexitätsbedingungen erfüllt.  Wenn die Komplexität Null ist und ein Hash vom Netzwerk als gültig akzeptiert wird, funktioniert der Proof-of-Work nicht und jeder Netzwerkknoten kann problemlos Blöcke abbauen. <br><br>  Auf den ersten Blick ist das nicht schlecht: Der Bergbau wird demokratisch und energiesparend.  In der Praxis wird jedoch jeder billige Blöcke abbauen und in das Netzwerk einbinden, was bedeutet, dass es viele Kandidaten für die Fortsetzung der Blockkette geben wird.  Da Bergleute nicht mehr verstehen, auf welchem ​​Block die Fortsetzung der Blockchain aufgebaut werden soll, werden viele verwaiste Ketten angezeigt.  Es wird Chaos geben, das von PoW-Münzen mit einem unzureichenden Algorithmus zur Anpassung der Komplexität des Bergbaus beobachtet wurde. <br><br>  Wenn die Komplexität Null ist und die Herstellung des Blocks keine Kosten verursacht, kann niemand bestimmen, welche Kandidatenketten mehr wert sind, was bedeutet, dass es keine Priorität gibt.  Bergleute können auch an verschiedenen Ketten arbeiten, ohne etwas zu verlieren. <br><br>  Dieses Gedankenexperiment zeigt lediglich, dass der Hauptzweck des Proof-of-Work-Algorithmus, des Proof-of-Stake oder des allgemeinen Proof-of-irgendetwas darin besteht, dem Netzwerk eine deterministische Methode zur Bestimmung des Rechts auf Bergbau, Prägung oder Fälschung eines Blocks bereitzustellen, mit der andere Teilnehmer einverstanden sind .  Darüber hinaus besteht eine weitere wichtige Bedingung für alle Blocksucher darin, nicht ungestraft an mehreren Ketten gleichzeitig zu arbeiten.  Im Proof-of-Stake-System wird ein solcher Ansatz durch den teilweisen oder vollständigen Entzug eines Einsatzes bestraft. <br><br>  <b>High Mining</b> ist eine alternative Form des Blockkampfes, wenn das Recht, einen Block zu produzieren, von einem Agenten gesichert wird, der im Auftrag des Benutzers arbeitet.  Diese Agenten - "arbeitende Bienen" - befinden sich in der Blockchain selbst.  Sie sind vollständig dezentralisiert und werden erstellt, wenn ein Benutzer eine spezielle Transaktion zum Erstellen eines Agenten ausführt. <br><br>  Nach der Erstellung beginnen die arbeitenden Bienen als virtuelle Geräte für den Bergbau (Rig) zu fungieren, und ihre Besitzer werden zu "Imkern".  Wenn die Arbeiterinnen den Block erfolgreich erhalten, wird dem Imker eine Vergütung für den Block (einschließlich der im Block enthaltenen Provisionen) gezahlt.  Arbeitsbienen benötigen sehr wenig Energie und benötigen keine spezielle Ausrüstung für die Herstellung von Blöcken.  Auch ihre Lebensdauer ist begrenzt und die Schaffung einer Biene ist eine spekulative Handlung mit einem bestimmten Preis;  Dies verhindert Versuche, an mehreren Ketten gleichzeitig zu arbeiten.  Der Erfolg einer einzelnen Biene hängt ausschließlich von der Bienenpopulation ab, die im gesamten Netzwerk lebt.  Einige Bienen werden niemals einen Block finden, während andere unverhältnismäßig viel Glück haben werden (ähnlich wie beim Solo-Bergbau). <br><br><img src="https://habrastorage.org/webt/9r/aw/je/9rawje4irkcraqt-hpczoggsuqq.png" alt="Bild"><br><br>  <i>Abb.</i>  <i>1: Eine arbeitende Biene wird der Blockchain durch eine Bienenerstellungstransaktion (BCT) und Minenblöcke während ihrer Lebensdauer hinzugefügt</i> <br><br><h3>  Schaffung von Agenten (Arbeitsbienen) </h3><br>  Um eine funktionierende Biene zu erstellen, sendet der Benutzer die Transaktion an eine spezielle "tote" Adresse, z. B. <code>CReateLitecoinCashWorkerBeeXYs19YQ</code> .  Beachten Sie, dass jeder dieselbe Adresse verwendet, um die Biene zu erstellen.  Diese Adresse wird als vorhanden und korrekt analysiert, aber niemand hat einen privaten Schlüssel dafür.  Das Dienstprogramm vanitygen bestimmt, dass die Suche nach einem privaten Schlüssel mit 24 * 2-GHz-Kernen etwa 1,7 * 10 ^ 31 Jahre dauert (mit einer 50-prozentigen Erfolgschance). <br><br>  Eine Transaktion, die eine Biene erstellt, muss mindestens zwei Ausgaben haben.  Die erste definiert eine feste Gebühr für die Erstellung einer Biene, die an eine unzugängliche Adresse gesendet wird.  Obwohl der Preis für die Erstellung einer Biene dynamisch bestimmt wird, wird davon ausgegangen, dass er ein Prozentsatz der Blockbelohnung ist.  Diese Berechnung beinhaltet die Mindestkosten, sodass es zum Zeitpunkt des Abbaus aller Münzen sinnvoll ist, High Mining zu verwenden, um Transaktionsgebühren zu erhalten. <br><br>  Die zweite Schlussfolgerung hat keine Kosten, gibt jedoch die Basisadresse an, die eine Belohnung für den Block erhält, den die Biene in Zukunft gefunden hat.  Sie können es "die zukünftige Adresse des Imkers" nennen.  Falls gewünscht, kann der Benutzer dies selbst klären.  Standardmäßig wird jedes Mal eine neue Adresse in seiner Brieftasche generiert. <br><br>  Ein Beispiel: <br><br><pre> <code class="hljs powershell"><span class="hljs-string"><span class="hljs-string">"vout"</span></span>: [ { // <span class="hljs-type"><span class="hljs-type">Bee</span></span> <span class="hljs-type"><span class="hljs-type">creation</span></span> <span class="hljs-type"><span class="hljs-type">fee</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"CReateLitecoinCashWorkerBeeXYs19YQ"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">1.0000000</span></span> }, { // <span class="hljs-type"><span class="hljs-type">Address</span></span> <span class="hljs-type"><span class="hljs-type">to</span></span> <span class="hljs-type"><span class="hljs-type">receive</span></span> <span class="hljs-type"><span class="hljs-type">block</span></span> <span class="hljs-type"><span class="hljs-type">rewards</span></span> <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">any</span></span> <span class="hljs-type"><span class="hljs-type">blocks</span></span> <span class="hljs-type"><span class="hljs-type">this</span></span> <span class="hljs-type"><span class="hljs-type">bee</span></span> <span class="hljs-type"><span class="hljs-type">mines</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0000000</span></span> }, { // <span class="hljs-type"><span class="hljs-type">Change</span></span> <span class="hljs-type"><span class="hljs-type">address</span></span> <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">change</span></span> <span class="hljs-type"><span class="hljs-type">from</span></span> <span class="hljs-type"><span class="hljs-type">creation</span></span> <span class="hljs-type"><span class="hljs-type">fee</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"Cd6CRuWCu6p4NLR6XG7BKyC8hzvEoYuKbn"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">123.5274346</span></span> } ]</code> </pre> <br>  Bienen reifen und sind in der Lage, Blöcke zu produzieren, nachdem 576 Blöcke ab dem Zeitpunkt der Bienenerstellung in der Blockchain erscheinen.  Dies ist die erwartete Anzahl neuer Blöcke, die innerhalb von 24 Stunden zur Litecoin Cash-Blockchain hinzugefügt wurden.  Nachdem die Bienen reif sind, gibt es 4032 Blöcke (ca. 1 Woche) und suchen nach Blöcken, dann sterben sie. <br><br>  Die Biene wird in einer QT-Brieftasche erstellt.  So etwas sieht so aus: <br><br><img src="https://habrastorage.org/webt/qx/pj/wt/qxpjwt6tv6k5il6empln0azugxe.png" alt="Bild"><br><br>  <i>Abb.</i>  <i>2: Layout der LCC-Brieftasche mit Arbeitsbienen</i> <br><br><h3>  Bienen bei der Arbeit: Block Search </h3><br>  Nehmen wir zum Beispiel an, dass die Blockchain-Höhe = 1000 ist und das Netzwerk bestimmen sollte, welche Biene Block 1001 finden soll. Alices Imker hat jetzt 4 Bienen (erstellt zwischen 576 und 4608 Blöcken). <br><br>  Wenn Block 1000 erscheint, berechnet Alices Brieftasche zwei Werte. <br><br>  Der erste ist ein deterministischer Wert, der unvorhersehbar, aber leicht überprüfbar ist.  Dies ist einfach zu bewerkstelligen, indem Block-Hashes in unterschiedlichen (fest codierten) Tiefen zwischen beispielsweise 0 und 500000 Blöcken hinzugefügt werden, um sicherzustellen, dass unser Zufallswert gut in der Blockchain verwurzelt ist: <br><br><pre> <code class="hljs powershell">string deterministicRandString = blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">13</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">173</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">1363</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">27363</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">496393</span></span>].hash;</code> </pre> <br>  Als nächstes berechnet ihre Brieftasche den Ziel-Hash der Biene, <code>beeTargetHash</code> .  Dieser Wert wird durch den exponentiellen gleitenden Durchschnitt mit einem sehr hohen Dynamikbereich bestimmt, der <code>beeTargetHash</code> so <code>beeTargetHash</code> , dass für jede <code>beeTargetHash</code> die Häufigkeit der während des <code>beeTargetHash</code> erhaltenen Blöcke bestimmt wird.  Auf der positiven Seite ist, je mehr PoW-Blöcke seit dem letzten hohen <code>beeTargetHash</code> abgebaut wurden, desto höher (einfacher) <code>beeTargetHash</code> .  Der Algorithmus ist wie folgt definiert;  Die Werte von <code>maxTarget</code> , <code>emaWindowsSize</code> und <code>emaDesiredSpacing</code> werden während der Simulation ermittelt. <br><br><pre> <code class="hljs pgsql">beeHashTarget = previousBeeHashTarget (<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> highest (easiest) target maxTarget) numPowBlocks = number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pow blocks since the previous hive mined block; emaInterval = emaWindowSize / emaDesiredSpacing; beeHashTarget *= (<span class="hljs-type"><span class="hljs-type">interval</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * emaDesiredSpacing + numPowBlocks + numPowBlocks; beeHashTarget /= (<span class="hljs-type"><span class="hljs-type">interval</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) * emaDesiredSpacing;</code> </pre> <br>  Sowohl <code>deterministicRandString</code> als auch <code>beeHashTarget</code> können von jedem Knoten im Netzwerk berechnet werden. <br><br>  Alices Brieftasche durchläuft nun jede ihrer lebenden Bienen durch eine deterministische Zufallskette, kombiniert die BCT-Transaktionen der Bienen und hasht sie, um einen neuen Hash zu erhalten - den beeHash einer einzelnen Biene.  Daher generiert jede Biene einen Hash pro Block.  Dieser Hash ähnelt dem besten Hash, der von einem PoW-Mining-Rig im selben Zeitraum generiert wurde. <br><br><pre> <code class="hljs lisp">hash beeHash = sha256(<span class="hljs-name"><span class="hljs-name">deterministicRandString</span></span> + bee.creationTransaction.ID)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Da in Alices Brieftasche Bienen <code>beeHash</code> , von denen jede <code>beeHash</code> berechnet, werden die besten (niedrigsten) entdeckten Hashes <code>beeHash</code> .  Wenn der beste von Alices Brieftasche entdeckte Hash die Bedingung <code>beeHash &lt; beeTargetHash</code> , erhält Alice das Recht, einen Block hinzuzufügen. <br><br>  Angenommen, Alice hat eine lebende Biene, deren Hash niedriger als das Ziel ist, und die BCT-Transaktionskennung einer erfolgreichen Biene lautet wie folgt: <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">0f</span></span>6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841.</code> </pre> <br>  In dem Wissen, dass Alices Brieftasche das Recht hat, einen Block zu signieren, erstellt das Netzwerk einen Block mit einer speziellen Transaktion mit zwei Ausgängen: <br><br><pre> <code class="hljs powershell"><span class="hljs-string"><span class="hljs-string">"vout"</span></span>: [ { // <span class="hljs-type"><span class="hljs-type">Zero</span></span>-<span class="hljs-type"><span class="hljs-type">value</span></span> <span class="hljs-type"><span class="hljs-type">output</span></span> <span class="hljs-type"><span class="hljs-type">identifies</span></span> <span class="hljs-type"><span class="hljs-type">the</span></span> <span class="hljs-type"><span class="hljs-type">bee</span></span> <span class="hljs-type"><span class="hljs-type">and</span></span> <span class="hljs-type"><span class="hljs-type">proves</span></span> <span class="hljs-type"><span class="hljs-type">it</span></span><span class="hljs-string"><span class="hljs-string">'s really minting for Alice "value": 0, "n": 0, "scriptPubKey": { "asm": "OP_RETURN OP_BEE 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 IH3Emz49KJeRbw0q4R48pD6GWPQtvHCxLeQOxxH+yv14Tn5KzUFIXBe9Td8EHudejzebMYt/XpusENzNkGM/a4I=" } }, { // Block reward (subsidy + fees) - must pay to bee'</span></span><span class="hljs-type"><span class="hljs-type">s</span></span> <span class="hljs-type"><span class="hljs-type">correct</span></span> <span class="hljs-type"><span class="hljs-type">coinbase</span></span> <span class="hljs-type"><span class="hljs-type">address</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">250.0001125</span></span>, <span class="hljs-string"><span class="hljs-string">"n"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"scriptPubKey"</span></span>: { <span class="hljs-string"><span class="hljs-string">"addresses"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR"</span></span> ] } }</code> </pre> <br>  <code>vout[0]</code> ist eine Nullwertausgabe, die nicht ausgegeben werden kann.  Es wird sowohl verwendet, um die Biene zu identifizieren, die den Block erhalten hat, als auch um zu beweisen, dass sie ihn für Alice erhalten hat. <br><br>  <code>vout[1]</code> ist die Ausgabe, die Alice eine Blockbelohnung zahlt. <br><br><h3>  Blockbestätigung </h3><br>  Bobs Brieftasche, die Alices Block erhält, muss nun sicherstellen, dass er den Konsens erfüllt.  Zunächst stellt er sicher, dass die Transaktion zwei Eingaben enthält, von denen die erste Null ist, und dass das Skript mit <code>OP_RETURN OP_BEE</code> beginnt.  Dann ruft er Alices Bienentransaktions-ID ab: <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">0f</span></span>6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841.</code> </pre> <br><blockquote>  Exkurs: Da die Transaktion zum Erstellen einer Biene an eine unzugängliche Adresse übertragen wird, bleibt die Ausgabe nicht ausgegebener Transaktionen (UTXO) darin.  Infolgedessen muss Bobs Brieftasche nicht die <code>txindex</code> (die alle Transaktionen aufgrund verzögerter Überprüfung und erhöhter Festplattennutzung vollständig indiziert), um die BCT-Ausgaben von Alice einfach überprüfen zu können.  Aufgrund der Verwendung von UTXO benötigt die QT-Brieftasche keine Datenbanken oder Änderungen, um High Mining zu unterstützen.  Die Registerkarte Bienen wird auch dynamisch integriert. </blockquote><br><br>  Durch die Validierung des High-Mine-Blocks implementiert Bobs Brieftasche das Äquivalent von RPC (Remote Procedure Call): <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">gettxout</span></span> 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Dies gibt ihm die erste BTC-Ausgabe, <code>vout [0]</code> , und stellt sicher, dass 1) die Transaktionstiefe im Bereich der Lebensdauer der Biene liegt;  2) für die Schaffung einer Biene wurde eine Provision gezahlt;  3) Es wurde an die richtige Sackgasse gesendet. <br><br>  Wenn die Überprüfung erfolgreich ist, wird in Bobs Brieftasche Folgendes angezeigt: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">gettxout</span></span> 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Somit wird die zweite Ausgabe von BCT <code>vout [1]</code> , was bestätigt, dass 1) der Wert Null ist;  2) Die Adresse ist dieselbe wie die Adresse für den Empfang der Überweisung von Münzen im Block (im Beispiel <code>CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR</code> ). <br><br>  Die folgende Überprüfung überprüft die Nachrichtensignatur aus dem letzten Teil von <code>vout [0]</code> .  Die Nachricht sollte die aktuelle Blocknummer enthalten, die von der Adresse für den Empfang der Münzüberweisung signiert ist. Daher erstellt Bobs Brieftasche Folgendes: <br><br><pre> <code class="hljs objectivec">verifymessage <span class="hljs-built_in"><span class="hljs-built_in">CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR</span></span> <span class="hljs-string"><span class="hljs-string">"IH3Emz49KJeRbw0q4R48pD6GWPQtvHCxLeQOxxH+yv14Tn5KzUFIXBe9Td8EHudejzebMYt/XpusENzNkGM/a 4I="</span></span> <span class="hljs-string"><span class="hljs-string">"1001"</span></span></code> </pre> <br>  Schließlich berechnet Bob <code>deterministicRandString</code> und <code>beeHashTarget</code> für den aktuellen Block, berechnet dann Alice's <code>beeHash</code> und vergleicht es mit <code>beeHashTarget</code> .  Wenn alle Prüfungen bestanden sind, gilt der Block als gültig und verifiziert.  Der Blockvalidierungsprozess ist schnell und erfordert keine teure Überprüfung historischer Blöcke. <br><br><h3>  Pairing von Hi-Mining und PoW Mining </h3><br>  Es wird davon ausgegangen, dass High Mining nicht die einzige Methode ist, um die Netzwerksicherheit zu gewährleisten.  Litecoin Cash-Entwickler möchten die Mining-Community nicht nur retten, sondern auch in keiner Weise stören.  High Mining muss mit PoW Mining in einer Blockchain gepaart werden. <br><br>  Derzeit wird der Betrieb der Schaltung wie folgt berechnet: <br><br><img src="https://habrastorage.org/webt/vg/pz/np/vgpznpd0y6ijk9bv6ota03ybhn4.png" alt="Bild"><br><br>  Das heißt, der Betrieb der Schaltung akkumuliert als Funktion der Komplexität in jedem Block der Schaltung.  Die Entwickler schlagen vor, diese Definition wie folgt zu ändern: <br><br><img src="https://habrastorage.org/webt/af/fo/e4/affoe4zxpceo_ow-jtscjvpb2lm.png" alt="Bild"><br><br>  Somit wird jeder Hive-Mine-Block in Abhängigkeit von der im vorherigen PoW-Block abgeschlossenen Arbeitsmenge belohnt, und die Konstante <code>k</code> wird experimentell bestimmt. <br><br><h3>  Fazit: High Mining als Abwehr gegen Angriffe 51% </h3><br>  Laut Jane 'Tanner' Craig, Chefentwicklerin von Litecoin Cash, besteht die Idee von HiveMine nicht nur darin, einen zuverlässigen Schutz gegen 51% ige Angriffe zu bieten, sondern auch den Bergbau zu demokratisieren und zu dezentralisieren.  Im Gegensatz zu PoS-Blockchains erfordert HiveMine immer noch die Kosten für die Erstellung einer Biene, die sich möglicherweise nicht auszahlt, wenn „die Reichen reicher werden“ und ihren Anteil ansammeln.  Agent-based Mining erfüllt die drei Hauptaufgaben des Teams: Die 51% ige Attacke wird erheblich verkompliziert, das Mining und die Freiheit für Bergleute mithilfe des SHA-256-Algorithmus demokratisiert, der eine hohe Sicherheit desselben Bitcoin-Netzwerks gewährleistet.  Für einen erfolgreichen Angriff muss ein Angreifer 51% der Netzwerkleistung sowie 51% der Bienenpopulation im Netzwerk übernehmen. Angesichts des Prozesses der Bienenbildung wird dies sofort offensichtlich. <br><br>  Laut Craig ist das HiveMine-Modell nach dem Testen und Implementieren im Litecoin Cash-Netzwerk, das nicht mit der gleichen SHA-256-Hash-Rate wie das gleiche Bitcoin Cash ausgestattet ist, dennoch schneller und zuverlässiger als das Bitcoin Cash- oder Bitcoin-Netzwerk . <br><br>  Referenzen: <br>  1. " <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Hive: Agent-basierter Bergbau in Litecoin Cash</a></i> ", Iain CRAIG, Sebastian CLARKE, Michał WYSZYŃSKI und Federico DE GONZÁLEZ-SOLER.  (2018) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415949/">https://habr.com/ru/post/de415949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415939/index.html">Verteilte Grafikverarbeitung mit Spark GraphX</a></li>
<li><a href="../de415941/index.html">Wie wir versucht haben, Barcodes herauszufinden und nichts verstanden haben</a></li>
<li><a href="../de415943/index.html">"Spieleentwicklung und Unterhaltungstheorie": Wichtige Punkte aus Raff Costers Buch</a></li>
<li><a href="../de415945/index.html">Neue chinesische SPS mit Aliexpress: Wecon LX3VP / LX3VE</a></li>
<li><a href="../de415947/index.html">Fehlerkompensationssystem für die Installation von optischen Fasern während der Verarbeitung durch Laserstrahlung während der Rotation</a></li>
<li><a href="../de415951/index.html">Mitap Sberbank und IBM auf HyperLedger Fabric</a></li>
<li><a href="../de415953/index.html">Wie blutiges Unternehmen Open Source gewinnt: der Kampf um BPMS</a></li>
<li><a href="../de415957/index.html">Wir brauchen mehr Rucksäcke: Bobby XL von XD Design</a></li>
<li><a href="../de415959/index.html">Wie wir den Netzwerkcode des mobilen PvP-Shooters geschrieben haben: Player-Synchronisation auf dem Client</a></li>
<li><a href="../de415961/index.html">Russischer verteilter Speicher. Wie es funktioniert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>