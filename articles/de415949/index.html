<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ß üçø üññüèæ High Mining: Die neueste Option zum Schutz der PoW-Blockchain vor einem ‚Äû51% -Angriff‚Äú. ‚úÇÔ∏è ‚úãüèø üë®üèæ‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Entwickler der Litecoin Cash-Gabel pr√§sentierten einen Vorabdruck des technischen Dokuments ' The Hive: Agent-based Mining in Litecoin Cash ', in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>High Mining: Die neueste Option zum Schutz der PoW-Blockchain vor einem ‚Äû51% -Angriff‚Äú.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415949/"><img src="https://habrastorage.org/webt/d1/oo/5w/d1oo5wr_cgcroc3091uoyu1trbw.png" alt="Bild"><br><br>  Die Entwickler der Litecoin Cash-Gabel pr√§sentierten einen Vorabdruck des technischen Dokuments ' <i>The Hive: Agent-based Mining in Litecoin Cash</i> ', in dem sie ihren Vorschlag zum Schutz der Kryptow√§hrungs-Blockchain basierend auf dem Proof-of-Work-Algorithmus vor einem ‚Äû51% -Angriff‚Äú beschrieben.  Ihre L√∂sung kombiniert Mining mit alternden ASIC-Ger√§ten (SHA-256) und demokratisches virtuelles Mining mit ‚ÄûWorking Bees‚Äú (HiveMine).  Bei ordnungsgem√§√üer Implementierung der Blockchain wird LCC eines der gr√∂√üten Probleme moderner Blockchain-Projekte (von Bitcoin bis Ethereum) l√∂sen: die Gefahr eines Angriffs, wenn mehr als die H√§lfte der gesamten Netzwerkleistung in den H√§nden des Angreifers konzentriert ist. <br><a name="habracut"></a><br><h3>  51% Angriffsproblem </h3><br>  Diejenigen, die den Kryptow√§hrungsmarkt √ºberwachen, konnten den j√ºngsten Ausbruch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von 51% Angriffen</a> auf relativ kleine PoW-Projekte (Proof-of-Work - ‚ÄûProof-of-Work-done‚Äú) nicht √ºbersehen, als Angreifer Transaktionen umschrieben und Gelder so schnell wie m√∂glich √ºber B√∂rsen transferierten.  "Relativ" bedeutet in diesem Fall, dass ein kleiner Teil der Ger√§te, die die kryptografische Sicherheit einer gro√üen Blockchain unterst√ºtzen (z. B. Bitcoin oder Ethereum), ausreicht, um den Konsens einer kleinen Blockchain zu brechen, die mit demselben Hash-Algorithmus arbeitet (Bitcoin Cash bzw. Bitcoin Gold). . <br><br>  Bei Kryptow√§hrungen, die den SHA-256-Algorithmus (LCC oder BCH) als Grundlage f√ºr die Verschl√ºsselung verwenden, wird das Risiko durch die Tatsache erh√∂ht, dass die gr√∂√üte und sicherste Kryptow√§hrung der Welt - Bitcoin (BTC) - mit demselben Algorithmus arbeitet. <br><br>  In diesem Artikel konzentrieren wir uns auf das mathematische Modell des Schutzes vor 51% -Angriffen und heben oberfl√§chlich die wichtigsten verwandten Begriffe und Konzepte hervor, die in der Kryptographie von Blockchains verwendet werden. <br><br><h3>  Einf√ºhrung in den Hochbergbau </h3><br>  Im klassischen PoW-Blockchain-Sicherheitsschema konkurrieren Bergleute, indem sie eine gro√üe Anzahl potenzieller Block-Hashes berechnen, um einen zu finden, der die im Netzwerkkonsens festgelegten Komplexit√§tsbedingungen erf√ºllt.  Wenn die Komplexit√§t Null ist und ein Hash vom Netzwerk als g√ºltig akzeptiert wird, funktioniert der Proof-of-Work nicht und jeder Netzwerkknoten kann problemlos Bl√∂cke abbauen. <br><br>  Auf den ersten Blick ist das nicht schlecht: Der Bergbau wird demokratisch und energiesparend.  In der Praxis wird jedoch jeder billige Bl√∂cke abbauen und in das Netzwerk einbinden, was bedeutet, dass es viele Kandidaten f√ºr die Fortsetzung der Blockkette geben wird.  Da Bergleute nicht mehr verstehen, auf welchem ‚Äã‚ÄãBlock die Fortsetzung der Blockchain aufgebaut werden soll, werden viele verwaiste Ketten angezeigt.  Es wird Chaos geben, das von PoW-M√ºnzen mit einem unzureichenden Algorithmus zur Anpassung der Komplexit√§t des Bergbaus beobachtet wurde. <br><br>  Wenn die Komplexit√§t Null ist und die Herstellung des Blocks keine Kosten verursacht, kann niemand bestimmen, welche Kandidatenketten mehr wert sind, was bedeutet, dass es keine Priorit√§t gibt.  Bergleute k√∂nnen auch an verschiedenen Ketten arbeiten, ohne etwas zu verlieren. <br><br>  Dieses Gedankenexperiment zeigt lediglich, dass der Hauptzweck des Proof-of-Work-Algorithmus, des Proof-of-Stake oder des allgemeinen Proof-of-irgendetwas darin besteht, dem Netzwerk eine deterministische Methode zur Bestimmung des Rechts auf Bergbau, Pr√§gung oder F√§lschung eines Blocks bereitzustellen, mit der andere Teilnehmer einverstanden sind .  Dar√ºber hinaus besteht eine weitere wichtige Bedingung f√ºr alle Blocksucher darin, nicht ungestraft an mehreren Ketten gleichzeitig zu arbeiten.  Im Proof-of-Stake-System wird ein solcher Ansatz durch den teilweisen oder vollst√§ndigen Entzug eines Einsatzes bestraft. <br><br>  <b>High Mining</b> ist eine alternative Form des Blockkampfes, wenn das Recht, einen Block zu produzieren, von einem Agenten gesichert wird, der im Auftrag des Benutzers arbeitet.  Diese Agenten - "arbeitende Bienen" - befinden sich in der Blockchain selbst.  Sie sind vollst√§ndig dezentralisiert und werden erstellt, wenn ein Benutzer eine spezielle Transaktion zum Erstellen eines Agenten ausf√ºhrt. <br><br>  Nach der Erstellung beginnen die arbeitenden Bienen als virtuelle Ger√§te f√ºr den Bergbau (Rig) zu fungieren, und ihre Besitzer werden zu "Imkern".  Wenn die Arbeiterinnen den Block erfolgreich erhalten, wird dem Imker eine Verg√ºtung f√ºr den Block (einschlie√ülich der im Block enthaltenen Provisionen) gezahlt.  Arbeitsbienen ben√∂tigen sehr wenig Energie und ben√∂tigen keine spezielle Ausr√ºstung f√ºr die Herstellung von Bl√∂cken.  Auch ihre Lebensdauer ist begrenzt und die Schaffung einer Biene ist eine spekulative Handlung mit einem bestimmten Preis;  Dies verhindert Versuche, an mehreren Ketten gleichzeitig zu arbeiten.  Der Erfolg einer einzelnen Biene h√§ngt ausschlie√ülich von der Bienenpopulation ab, die im gesamten Netzwerk lebt.  Einige Bienen werden niemals einen Block finden, w√§hrend andere unverh√§ltnism√§√üig viel Gl√ºck haben werden (√§hnlich wie beim Solo-Bergbau). <br><br><img src="https://habrastorage.org/webt/9r/aw/je/9rawje4irkcraqt-hpczoggsuqq.png" alt="Bild"><br><br>  <i>Abb.</i>  <i>1: Eine arbeitende Biene wird der Blockchain durch eine Bienenerstellungstransaktion (BCT) und Minenbl√∂cke w√§hrend ihrer Lebensdauer hinzugef√ºgt</i> <br><br><h3>  Schaffung von Agenten (Arbeitsbienen) </h3><br>  Um eine funktionierende Biene zu erstellen, sendet der Benutzer die Transaktion an eine spezielle "tote" Adresse, z. B. <code>CReateLitecoinCashWorkerBeeXYs19YQ</code> .  Beachten Sie, dass jeder dieselbe Adresse verwendet, um die Biene zu erstellen.  Diese Adresse wird als vorhanden und korrekt analysiert, aber niemand hat einen privaten Schl√ºssel daf√ºr.  Das Dienstprogramm vanitygen bestimmt, dass die Suche nach einem privaten Schl√ºssel mit 24 * 2-GHz-Kernen etwa 1,7 * 10 ^ 31 Jahre dauert (mit einer 50-prozentigen Erfolgschance). <br><br>  Eine Transaktion, die eine Biene erstellt, muss mindestens zwei Ausgaben haben.  Die erste definiert eine feste Geb√ºhr f√ºr die Erstellung einer Biene, die an eine unzug√§ngliche Adresse gesendet wird.  Obwohl der Preis f√ºr die Erstellung einer Biene dynamisch bestimmt wird, wird davon ausgegangen, dass er ein Prozentsatz der Blockbelohnung ist.  Diese Berechnung beinhaltet die Mindestkosten, sodass es zum Zeitpunkt des Abbaus aller M√ºnzen sinnvoll ist, High Mining zu verwenden, um Transaktionsgeb√ºhren zu erhalten. <br><br>  Die zweite Schlussfolgerung hat keine Kosten, gibt jedoch die Basisadresse an, die eine Belohnung f√ºr den Block erh√§lt, den die Biene in Zukunft gefunden hat.  Sie k√∂nnen es "die zuk√ºnftige Adresse des Imkers" nennen.  Falls gew√ºnscht, kann der Benutzer dies selbst kl√§ren.  Standardm√§√üig wird jedes Mal eine neue Adresse in seiner Brieftasche generiert. <br><br>  Ein Beispiel: <br><br><pre> <code class="hljs powershell"><span class="hljs-string"><span class="hljs-string">"vout"</span></span>: [ { // <span class="hljs-type"><span class="hljs-type">Bee</span></span> <span class="hljs-type"><span class="hljs-type">creation</span></span> <span class="hljs-type"><span class="hljs-type">fee</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"CReateLitecoinCashWorkerBeeXYs19YQ"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">1.0000000</span></span> }, { // <span class="hljs-type"><span class="hljs-type">Address</span></span> <span class="hljs-type"><span class="hljs-type">to</span></span> <span class="hljs-type"><span class="hljs-type">receive</span></span> <span class="hljs-type"><span class="hljs-type">block</span></span> <span class="hljs-type"><span class="hljs-type">rewards</span></span> <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">any</span></span> <span class="hljs-type"><span class="hljs-type">blocks</span></span> <span class="hljs-type"><span class="hljs-type">this</span></span> <span class="hljs-type"><span class="hljs-type">bee</span></span> <span class="hljs-type"><span class="hljs-type">mines</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0000000</span></span> }, { // <span class="hljs-type"><span class="hljs-type">Change</span></span> <span class="hljs-type"><span class="hljs-type">address</span></span> <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">change</span></span> <span class="hljs-type"><span class="hljs-type">from</span></span> <span class="hljs-type"><span class="hljs-type">creation</span></span> <span class="hljs-type"><span class="hljs-type">fee</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"Cd6CRuWCu6p4NLR6XG7BKyC8hzvEoYuKbn"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">123.5274346</span></span> } ]</code> </pre> <br>  Bienen reifen und sind in der Lage, Bl√∂cke zu produzieren, nachdem 576 Bl√∂cke ab dem Zeitpunkt der Bienenerstellung in der Blockchain erscheinen.  Dies ist die erwartete Anzahl neuer Bl√∂cke, die innerhalb von 24 Stunden zur Litecoin Cash-Blockchain hinzugef√ºgt wurden.  Nachdem die Bienen reif sind, gibt es 4032 Bl√∂cke (ca. 1 Woche) und suchen nach Bl√∂cken, dann sterben sie. <br><br>  Die Biene wird in einer QT-Brieftasche erstellt.  So etwas sieht so aus: <br><br><img src="https://habrastorage.org/webt/qx/pj/wt/qxpjwt6tv6k5il6empln0azugxe.png" alt="Bild"><br><br>  <i>Abb.</i>  <i>2: Layout der LCC-Brieftasche mit Arbeitsbienen</i> <br><br><h3>  Bienen bei der Arbeit: Block Search </h3><br>  Nehmen wir zum Beispiel an, dass die Blockchain-H√∂he = 1000 ist und das Netzwerk bestimmen sollte, welche Biene Block 1001 finden soll. Alices Imker hat jetzt 4 Bienen (erstellt zwischen 576 und 4608 Bl√∂cken). <br><br>  Wenn Block 1000 erscheint, berechnet Alices Brieftasche zwei Werte. <br><br>  Der erste ist ein deterministischer Wert, der unvorhersehbar, aber leicht √ºberpr√ºfbar ist.  Dies ist einfach zu bewerkstelligen, indem Block-Hashes in unterschiedlichen (fest codierten) Tiefen zwischen beispielsweise 0 und 500000 Bl√∂cken hinzugef√ºgt werden, um sicherzustellen, dass unser Zufallswert gut in der Blockchain verwurzelt ist: <br><br><pre> <code class="hljs powershell">string deterministicRandString = blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">13</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">173</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">1363</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">27363</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">496393</span></span>].hash;</code> </pre> <br>  Als n√§chstes berechnet ihre Brieftasche den Ziel-Hash der Biene, <code>beeTargetHash</code> .  Dieser Wert wird durch den exponentiellen gleitenden Durchschnitt mit einem sehr hohen Dynamikbereich bestimmt, der <code>beeTargetHash</code> so <code>beeTargetHash</code> , dass f√ºr jede <code>beeTargetHash</code> die H√§ufigkeit der w√§hrend des <code>beeTargetHash</code> erhaltenen Bl√∂cke bestimmt wird.  Auf der positiven Seite ist, je mehr PoW-Bl√∂cke seit dem letzten hohen <code>beeTargetHash</code> abgebaut wurden, desto h√∂her (einfacher) <code>beeTargetHash</code> .  Der Algorithmus ist wie folgt definiert;  Die Werte von <code>maxTarget</code> , <code>emaWindowsSize</code> und <code>emaDesiredSpacing</code> werden w√§hrend der Simulation ermittelt. <br><br><pre> <code class="hljs pgsql">beeHashTarget = previousBeeHashTarget (<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> highest (easiest) target maxTarget) numPowBlocks = number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pow blocks since the previous hive mined block; emaInterval = emaWindowSize / emaDesiredSpacing; beeHashTarget *= (<span class="hljs-type"><span class="hljs-type">interval</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * emaDesiredSpacing + numPowBlocks + numPowBlocks; beeHashTarget /= (<span class="hljs-type"><span class="hljs-type">interval</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) * emaDesiredSpacing;</code> </pre> <br>  Sowohl <code>deterministicRandString</code> als auch <code>beeHashTarget</code> k√∂nnen von jedem Knoten im Netzwerk berechnet werden. <br><br>  Alices Brieftasche durchl√§uft nun jede ihrer lebenden Bienen durch eine deterministische Zufallskette, kombiniert die BCT-Transaktionen der Bienen und hasht sie, um einen neuen Hash zu erhalten - den beeHash einer einzelnen Biene.  Daher generiert jede Biene einen Hash pro Block.  Dieser Hash √§hnelt dem besten Hash, der von einem PoW-Mining-Rig im selben Zeitraum generiert wurde. <br><br><pre> <code class="hljs lisp">hash beeHash = sha256(<span class="hljs-name"><span class="hljs-name">deterministicRandString</span></span> + bee.creationTransaction.ID)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Da in Alices Brieftasche Bienen <code>beeHash</code> , von denen jede <code>beeHash</code> berechnet, werden die besten (niedrigsten) entdeckten Hashes <code>beeHash</code> .  Wenn der beste von Alices Brieftasche entdeckte Hash die Bedingung <code>beeHash &lt; beeTargetHash</code> , erh√§lt Alice das Recht, einen Block hinzuzuf√ºgen. <br><br>  Angenommen, Alice hat eine lebende Biene, deren Hash niedriger als das Ziel ist, und die BCT-Transaktionskennung einer erfolgreichen Biene lautet wie folgt: <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">0f</span></span>6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841.</code> </pre> <br>  In dem Wissen, dass Alices Brieftasche das Recht hat, einen Block zu signieren, erstellt das Netzwerk einen Block mit einer speziellen Transaktion mit zwei Ausg√§ngen: <br><br><pre> <code class="hljs powershell"><span class="hljs-string"><span class="hljs-string">"vout"</span></span>: [ { // <span class="hljs-type"><span class="hljs-type">Zero</span></span>-<span class="hljs-type"><span class="hljs-type">value</span></span> <span class="hljs-type"><span class="hljs-type">output</span></span> <span class="hljs-type"><span class="hljs-type">identifies</span></span> <span class="hljs-type"><span class="hljs-type">the</span></span> <span class="hljs-type"><span class="hljs-type">bee</span></span> <span class="hljs-type"><span class="hljs-type">and</span></span> <span class="hljs-type"><span class="hljs-type">proves</span></span> <span class="hljs-type"><span class="hljs-type">it</span></span><span class="hljs-string"><span class="hljs-string">'s really minting for Alice "value": 0, "n": 0, "scriptPubKey": { "asm": "OP_RETURN OP_BEE 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 IH3Emz49KJeRbw0q4R48pD6GWPQtvHCxLeQOxxH+yv14Tn5KzUFIXBe9Td8EHudejzebMYt/XpusENzNkGM/a4I=" } }, { // Block reward (subsidy + fees) - must pay to bee'</span></span><span class="hljs-type"><span class="hljs-type">s</span></span> <span class="hljs-type"><span class="hljs-type">correct</span></span> <span class="hljs-type"><span class="hljs-type">coinbase</span></span> <span class="hljs-type"><span class="hljs-type">address</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">250.0001125</span></span>, <span class="hljs-string"><span class="hljs-string">"n"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"scriptPubKey"</span></span>: { <span class="hljs-string"><span class="hljs-string">"addresses"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR"</span></span> ] } }</code> </pre> <br>  <code>vout[0]</code> ist eine Nullwertausgabe, die nicht ausgegeben werden kann.  Es wird sowohl verwendet, um die Biene zu identifizieren, die den Block erhalten hat, als auch um zu beweisen, dass sie ihn f√ºr Alice erhalten hat. <br><br>  <code>vout[1]</code> ist die Ausgabe, die Alice eine Blockbelohnung zahlt. <br><br><h3>  Blockbest√§tigung </h3><br>  Bobs Brieftasche, die Alices Block erh√§lt, muss nun sicherstellen, dass er den Konsens erf√ºllt.  Zun√§chst stellt er sicher, dass die Transaktion zwei Eingaben enth√§lt, von denen die erste Null ist, und dass das Skript mit <code>OP_RETURN OP_BEE</code> beginnt.  Dann ruft er Alices Bienentransaktions-ID ab: <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">0f</span></span>6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841.</code> </pre> <br><blockquote>  Exkurs: Da die Transaktion zum Erstellen einer Biene an eine unzug√§ngliche Adresse √ºbertragen wird, bleibt die Ausgabe nicht ausgegebener Transaktionen (UTXO) darin.  Infolgedessen muss Bobs Brieftasche nicht die <code>txindex</code> (die alle Transaktionen aufgrund verz√∂gerter √úberpr√ºfung und erh√∂hter Festplattennutzung vollst√§ndig indiziert), um die BCT-Ausgaben von Alice einfach √ºberpr√ºfen zu k√∂nnen.  Aufgrund der Verwendung von UTXO ben√∂tigt die QT-Brieftasche keine Datenbanken oder √Ñnderungen, um High Mining zu unterst√ºtzen.  Die Registerkarte Bienen wird auch dynamisch integriert. </blockquote><br><br>  Durch die Validierung des High-Mine-Blocks implementiert Bobs Brieftasche das √Ñquivalent von RPC (Remote Procedure Call): <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">gettxout</span></span> 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Dies gibt ihm die erste BTC-Ausgabe, <code>vout [0]</code> , und stellt sicher, dass 1) die Transaktionstiefe im Bereich der Lebensdauer der Biene liegt;  2) f√ºr die Schaffung einer Biene wurde eine Provision gezahlt;  3) Es wurde an die richtige Sackgasse gesendet. <br><br>  Wenn die √úberpr√ºfung erfolgreich ist, wird in Bobs Brieftasche Folgendes angezeigt: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">gettxout</span></span> 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Somit wird die zweite Ausgabe von BCT <code>vout [1]</code> , was best√§tigt, dass 1) der Wert Null ist;  2) Die Adresse ist dieselbe wie die Adresse f√ºr den Empfang der √úberweisung von M√ºnzen im Block (im Beispiel <code>CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR</code> ). <br><br>  Die folgende √úberpr√ºfung √ºberpr√ºft die Nachrichtensignatur aus dem letzten Teil von <code>vout [0]</code> .  Die Nachricht sollte die aktuelle Blocknummer enthalten, die von der Adresse f√ºr den Empfang der M√ºnz√ºberweisung signiert ist. Daher erstellt Bobs Brieftasche Folgendes: <br><br><pre> <code class="hljs objectivec">verifymessage <span class="hljs-built_in"><span class="hljs-built_in">CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR</span></span> <span class="hljs-string"><span class="hljs-string">"IH3Emz49KJeRbw0q4R48pD6GWPQtvHCxLeQOxxH+yv14Tn5KzUFIXBe9Td8EHudejzebMYt/XpusENzNkGM/a 4I="</span></span> <span class="hljs-string"><span class="hljs-string">"1001"</span></span></code> </pre> <br>  Schlie√ülich berechnet Bob <code>deterministicRandString</code> und <code>beeHashTarget</code> f√ºr den aktuellen Block, berechnet dann Alice's <code>beeHash</code> und vergleicht es mit <code>beeHashTarget</code> .  Wenn alle Pr√ºfungen bestanden sind, gilt der Block als g√ºltig und verifiziert.  Der Blockvalidierungsprozess ist schnell und erfordert keine teure √úberpr√ºfung historischer Bl√∂cke. <br><br><h3>  Pairing von Hi-Mining und PoW Mining </h3><br>  Es wird davon ausgegangen, dass High Mining nicht die einzige Methode ist, um die Netzwerksicherheit zu gew√§hrleisten.  Litecoin Cash-Entwickler m√∂chten die Mining-Community nicht nur retten, sondern auch in keiner Weise st√∂ren.  High Mining muss mit PoW Mining in einer Blockchain gepaart werden. <br><br>  Derzeit wird der Betrieb der Schaltung wie folgt berechnet: <br><br><img src="https://habrastorage.org/webt/vg/pz/np/vgpznpd0y6ijk9bv6ota03ybhn4.png" alt="Bild"><br><br>  Das hei√üt, der Betrieb der Schaltung akkumuliert als Funktion der Komplexit√§t in jedem Block der Schaltung.  Die Entwickler schlagen vor, diese Definition wie folgt zu √§ndern: <br><br><img src="https://habrastorage.org/webt/af/fo/e4/affoe4zxpceo_ow-jtscjvpb2lm.png" alt="Bild"><br><br>  Somit wird jeder Hive-Mine-Block in Abh√§ngigkeit von der im vorherigen PoW-Block abgeschlossenen Arbeitsmenge belohnt, und die Konstante <code>k</code> wird experimentell bestimmt. <br><br><h3>  Fazit: High Mining als Abwehr gegen Angriffe 51% </h3><br>  Laut Jane 'Tanner' Craig, Chefentwicklerin von Litecoin Cash, besteht die Idee von HiveMine nicht nur darin, einen zuverl√§ssigen Schutz gegen 51% ige Angriffe zu bieten, sondern auch den Bergbau zu demokratisieren und zu dezentralisieren.  Im Gegensatz zu PoS-Blockchains erfordert HiveMine immer noch die Kosten f√ºr die Erstellung einer Biene, die sich m√∂glicherweise nicht auszahlt, wenn ‚Äûdie Reichen reicher werden‚Äú und ihren Anteil ansammeln.  Agent-based Mining erf√ºllt die drei Hauptaufgaben des Teams: Die 51% ige Attacke wird erheblich verkompliziert, das Mining und die Freiheit f√ºr Bergleute mithilfe des SHA-256-Algorithmus demokratisiert, der eine hohe Sicherheit desselben Bitcoin-Netzwerks gew√§hrleistet.  F√ºr einen erfolgreichen Angriff muss ein Angreifer 51% der Netzwerkleistung sowie 51% der Bienenpopulation im Netzwerk √ºbernehmen. Angesichts des Prozesses der Bienenbildung wird dies sofort offensichtlich. <br><br>  Laut Craig ist das HiveMine-Modell nach dem Testen und Implementieren im Litecoin Cash-Netzwerk, das nicht mit der gleichen SHA-256-Hash-Rate wie das gleiche Bitcoin Cash ausgestattet ist, dennoch schneller und zuverl√§ssiger als das Bitcoin Cash- oder Bitcoin-Netzwerk . <br><br>  Referenzen: <br>  1. " <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Hive: Agent-basierter Bergbau in Litecoin Cash</a></i> ", Iain CRAIG, Sebastian CLARKE, Micha≈Ç WYSZY≈ÉSKI und Federico DE GONZ√ÅLEZ-SOLER.  (2018) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415949/">https://habr.com/ru/post/de415949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415939/index.html">Verteilte Grafikverarbeitung mit Spark GraphX</a></li>
<li><a href="../de415941/index.html">Wie wir versucht haben, Barcodes herauszufinden und nichts verstanden haben</a></li>
<li><a href="../de415943/index.html">"Spieleentwicklung und Unterhaltungstheorie": Wichtige Punkte aus Raff Costers Buch</a></li>
<li><a href="../de415945/index.html">Neue chinesische SPS mit Aliexpress: Wecon LX3VP / LX3VE</a></li>
<li><a href="../de415947/index.html">Fehlerkompensationssystem f√ºr die Installation von optischen Fasern w√§hrend der Verarbeitung durch Laserstrahlung w√§hrend der Rotation</a></li>
<li><a href="../de415951/index.html">Mitap Sberbank und IBM auf HyperLedger Fabric</a></li>
<li><a href="../de415953/index.html">Wie blutiges Unternehmen Open Source gewinnt: der Kampf um BPMS</a></li>
<li><a href="../de415957/index.html">Wir brauchen mehr Rucks√§cke: Bobby XL von XD Design</a></li>
<li><a href="../de415959/index.html">Wie wir den Netzwerkcode des mobilen PvP-Shooters geschrieben haben: Player-Synchronisation auf dem Client</a></li>
<li><a href="../de415961/index.html">Russischer verteilter Speicher. Wie es funktioniert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>