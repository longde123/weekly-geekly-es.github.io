<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö±Ô∏è ‚öæÔ∏è üë®üèª‚Äçüíº Haskell soll eine Sprache f√ºr Genies und Akademiker sein. Richtig? üõåüèæ üöó üëÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe einmal mit dem Gr√ºnder eines israelischen Startups gesprochen, das eine Hochgeschwindigkeits-GPU-Datenbank entwickelt. Haskell und C ++ waren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haskell soll eine Sprache f√ºr Genies und Akademiker sein. Richtig?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438970/"><img src="https://habrastorage.org/webt/o6/qs/0d/o6qs0dg9mgydyepqfcn6kpobfnc.jpeg"><br><br>  Ich habe einmal mit dem Gr√ºnder eines israelischen Startups gesprochen, das eine Hochgeschwindigkeits-GPU-Datenbank entwickelt.  Haskell und C ++ waren auf ihrem Stapel und der Gr√ºnder beschwerte sich dar√ºber, wie schwierig es sei, Leute im Team zu finden.  Er flog nach Moskau, auch um gute Programmierer zu suchen. <br><br>  Ich fragte sorgf√§ltig, ob es besser sei, etwas allgemeineres und neues zu verwenden.  Und obwohl die Antwort h√∂flich und konstruktiv war, schien es mir zwischen den Zeilen: "Pff, erw√§hne diese Spielzeug-Yapes nicht einmal." <br><br>  Alles, was ich seitdem von der Seite √ºber Haskell geh√∂rt habe, war auf eines zur√ºckzuf√ºhren: "Witze sind schlecht mit ihm."  Um die Haskellisten besser kennenzulernen, kam ich zum Telegramm-Chat, um ihnen Fragen zu stellen.  Es war ziemlich be√§ngstigend und wie sich herausstellte, nicht umsonst. <br><br>  Sie wollen nicht im Volksmund √ºber Haskell sprechen, und es scheint, dass sie solche Unternehmungen mit Verachtung betrachten.  Schon gesprochen - mit maximaler Vollst√§ndigkeit und Objektivit√§t.  ‚ÄûEine der charakteristischen Eigenschaften von Haskell als Sprache und Gemeinschaft ist, dass sie gemeinsam nicht danach strebten, popul√§r zu werden, und eine einfache Antwort auf popul√§re Fragen gaben.  Stattdessen haben sie einen logischen, prinzipiellen Weg gefunden, um echte Probleme zu l√∂sen, anstatt schnell in das Herz eines Passanten einer interessierten Person einzudringen ‚Äú, schrieben sie mir dort. <br><br>  Einige Personen teilten jedoch ihre Erfahrungen mit, und ich sammelte hier ihre Meinungen. <br><a name="habracut"></a><br>  <b>Denis Mirzoev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">nolane</a> )</b> : An der Universit√§t wurde mir zum Thema "Programmiersprachen" angeboten, einen Kurs bei Haskell Coursera f√ºr einen weiteren von hundert Punkten zu <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">belegen</a></b> .  Dann gab es einen funktionalen Programmierkurs, bei dem Haskell stattfand.  Er schrieb eine Hausarbeit und eine Abschlussarbeit des Bachelor √ºber GHC.  Ich habe einen Job als Haskell-Programmierer gefunden. <br><br>  Es war schwer und immer noch schwer.  Wenn Sie anfangen, Haskell zu studieren, m√ºssen Sie viele neue Konzepte verstehen.  Das ist harte Arbeit.  Sie lernen buchst√§blich wieder zu programmieren. <br><br>  F√ºr viele wird es jetzt schwierig sein, sich daran zu erinnern, wie sie ihre Reise in die Programmierung begonnen haben, wie schwierig es war zu verstehen, was ein ‚ÄûZeiger‚Äú war, was eine ‚ÄûFunktion‚Äú, was eine ‚ÄûKlasse‚Äú ist.  Vielleicht ist es deshalb so schwer, Haskell zu studieren.  Mit zunehmendem Alter wird es schwieriger, neue Dinge zu lernen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Einmal in einer Probezeit bin ich in Redux gefallen. Als ich mir die Lektionen seines Sch√∂pfers <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ansah</a></b> , beschloss ich, alle besser kennenzulernen.  Zuerst habe ich die erlernten Praktiken in JavaScript angewendet, dann aber Haskell kennengelernt, das als echte funktionale Sprache gilt.  Ich war sofort von seiner Eleganz und einer Reihe neuer Konzepte angezogen, die mir unbekannt waren. <br><br>  Es war nicht einfach mit endlosen Tutorials √ºber Monaden am Beispiel von Burritos, die sehr verwirrend sind.  Ein zwingender Hintergrund macht es auch schwierig, neue Konzepte zu er√∂ffnen. <br><br>  <b>Yuri Syrovetsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">cblp</a> )</b> : Am schwierigsten zu lernen ist Haskell als Zweiter, als das Entlein-Syndrom nicht in die erste Sprache <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">√ºberging</a></b> . <br><br><h2>  Was ist gut und was ist schlechte Sprache? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Die Sprache ist sehr pr√§gnant, elegant und flexibel, nicht umsonst ist die H√§lfte der Bibliotheken EDSL (zumindest dieser Eindruck). <br><br>  <b>Yuri Syrovetsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">cblp</a> )</b> : Hohe Ausdruckskraft, einfache √úbertragung des Themenbereichs auf Code, die optimale Kombination von imperativen und funktionalen Paradigmen.  Es ist einfach, Abstraktionen auf Daten und Algorithmen zu erstellen, sodass Sie √ºber das Problem nachdenken k√∂nnen, ohne von kleinen Dingen abgelenkt zu werden. <br><br>  <b>John Doe</b> : Streng starkes (ich w√ºrde sagen faschistisches) Tippen. <br><br>  <b>Igor Shevnin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">interphx</a> )</b> : Ein sehr ausdrucksstarkes <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Typensystem</a></b> .  Nicht so m√§chtig wie Idris oder Agda, aber es erreicht diesen Mittelweg, wenn fast alles ausgedr√ºckt werden kann und die Typinferenz gut funktioniert.  Sie m√ºssen sie nicht √ºberall manuell markieren. <br><br>  Bei einem leistungsstarken Typsystem m√ºssen Sie jedoch auf die √ºbergebenen Werte achten.  Eine Reihe von Typdefinitionen k√∂nnte wie ein Boilerplate aussehen.  Jedes Team verwendet seine eigenen Erweiterungen oder verwendet sie √ºberhaupt nicht.  Der Code ist "dichter" - eine Zeile enth√§lt h√§ufig mehr Informationen als in anderen Sprachen, sodass es f√ºr einen unerfahrenen Entwickler schwieriger ist, sie zu lesen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Wenn Sie Haskell studieren, werden Sie h√∂chstwahrscheinlich auf das Sprichwort sto√üen: "Wenn es kompiliert, ist es wahrscheinlich richtig."  Es gibt keine Null, das Funktionsparadigma selbst ist sehr streng und zwingt Sie, bestimmte Regeln zu befolgen, die in den meisten F√§llen zu einem besseren Design f√ºhren. <br><br>  Zum Beispiel gibt es keine Variablen in der Sprache - nur Konstanten.  Sie m√ºssen nicht verfolgen, was und wo Sie zuweisen.  Haskell empfiehlt die Verwendung reiner Funktionen, was zu keinen Nebenwirkungen f√ºhrt.  Das funktionale Design l√§sst das Programm einfach als Ganzes funktionieren, im Gegensatz zu OOP, wo eine Reihe von Objekten in die Welt geworfen werden und Objekte versuchen, durch Nebenwirkungen miteinander zu kommunizieren, was die Anwendung in ein unvorhersehbares Chaos verwandelt.  Bei der Arbeit leiden wir mit C # in Unity genug darunter. <br><br>  <b>Denis Mirzoev</b> : Eingebaute Faulheit erh√∂ht die Ausdruckskraft der Sprache.  Viele Algorithmen werden einfacher.  Es kann die Produktivit√§t steigern, wenn die Ergebnisse von Zwischenberechnungen nicht verwendet werden.  (Zum Beispiel arbeitet `head. Sort` in linearer Zeit). <br><br>  <b>Igor Shevnin</b> : Ein faules Rechenmodell hilft normalerweise, aber wenn die Reihenfolge der aufrufenden Funktionen wichtig ist, kann es schwierig sein, herauszufinden, was passiert. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Es wird kompiliert, was die Geschwindigkeit sofort enorm erh√∂ht. <br><br>  <b>Denis Mirzoev</b> : Im Vergleich zu Java in der Geschwindigkeit, aber nicht so schnell wie C. <br><br>  <b>Igor Shevnin</b> : <b>Standardm√§√üig werden</b> Erweiterungen unterst√ºtzt, mit denen Sie das Sprach- und <b>Typensystem</b> fertigstellen k√∂nnen.  Es gibt jedoch viele weit verbreitete Erweiterungen, die der Community vertraut sind, anst√§ndige Beispiele und Dokumentationen enthalten und keine Nische darstellen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Die Prelude-Standardbibliothek hat sehr schlechte Funktionen wie read, head, readFile, die eine Ausnahme ausl√∂sen und in ein Programm einf√ºgen k√∂nnen, anstatt Vielleicht zur√ºckzugeben.  Daher m√ºssen Sie Alternativen verwenden oder Ihre eigenen Implementierungen schreiben. <br><br>  <b>Igor Shevnin</b> : Das Hauptproblem ist die mangelnde Standardisierung, da viele die Standardbibliothek durch eine der inkompatiblen Alternativen ersetzen.  In der Community gibt es Meinungsverschiedenheiten dar√ºber, was eine Standardbibliothek sein sollte, was im Kern der Sprache enthalten sein sollte und was durch Erweiterungen erg√§nzt werden sollte, und ich bin der Meinung, dass dies die Entwicklung der Sprache verlangsamt. <br><br>  <b>Denis Mirzoev</b> : Es gibt nicht gen√ºgend Tools: Es gibt keine vollwertige IDE, es gibt nur sehr wenige Tools zum Messen der Leistung, es gibt kein "schrittweises" Debuggen - dies ist im Allgemeinen ein grundlegendes Problem. <br><br><h2>  F√ºr welche Projekte ist Haskell am besten geeignet? </h2><br>  <b>Yuri Syrovetsky</b> : F√ºr komplexe Aufgaben im Zusammenhang mit Sicherheit oder Geld, bei denen die Fehlerkosten hoch sind. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : F√ºr alles, wo Sie Berechnungen, Transformationen und Datenanalysen durchf√ºhren m√ºssen.  Sehr √ºberrascht, dass Haskell in Data Science weniger beliebt ist als Python. <br><br>  <b>Igor Shevnin</b> : Ich w√ºrde nicht riskieren, es f√ºr eingebettete Systeme zu verwenden (die Leistung ist nicht schlecht, aber es gibt immer noch einen erheblichen Overhead f√ºr den Speicherverbrauch aufgrund fauler Berechnungen) und kleine Skripte (diese Genauigkeit wird dort einfach nicht ben√∂tigt).  Sie m√ºssen auch verstehen, dass es viel schwieriger ist, Entwickler in einem Team zu finden als f√ºr Mainstream-Sprachen. <br><br>  <b>John Doe</b> : Um Branchencode zu schreiben, den andere lesen werden, ben√∂tigen Sie ein ganzes Team von Haskellisten.  So wenige Menschen haben es geschafft zu sammeln. <br><br>  <b>Igor Shevnin</b> : Aufgrund seiner K√ºrze und Genauigkeit ist Haskell f√ºr fast jede Aufgabe geeignet. <br><br><h2>  Es ist eine gute Idee, mit Haskell die Entwicklung zu lernen? </h2><br>  Igor Shevnin: Es ist unwahrscheinlich, dass es anf√§ngt, da die √ºberwiegende Mehrheit der Codebasen, mit denen eine Person arbeiten muss, nicht darauf geschrieben ist. <br><br>  <b>John Doe</b> : Schlechte, schlechte Idee!  Sprachen, die nicht aus der ML-Familie stammen, sondern aus den Industriesprachen im Allgemeinen, werden Sie dann schockieren. <br><br>  <b>Denis Mirzoev</b> : Normalerweise studieren die Leute zuerst Mathematik und dann Programmieren.  Daher sollte das Erlernen einer Sprache mit mathematischen Konzepten (algebraische Datentypen, reine Funktionen) einfacher als zwingend sein.  Das hei√üt, ich denke, das ist eine gute Idee. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Alle Neuank√∂mmlinge, die ich trainiere, werde ich Ihnen auf jeden Fall Haskell vorstellen.  Menschen, die den imperativen Stil nicht studiert haben, sind viel einfacher im Funktionscode zu navigieren und lernen schneller. Selbst wenn sie mit objektorientierten Sprachen arbeiten, bringen sie gute architektonische L√∂sungen und funktionale Praktiken mit. <br><br>  <b>Yuri Syrovetsky</b> : Es ist besser, sofort mit mehreren grundlegend unterschiedlichen Sprachen zu beginnen, zum Beispiel C, Haskell und Smalltok, in beliebiger Reihenfolge.  Keine einzige Sprache in <br>  separat wird kein vollst√§ndiges Verst√§ndnis geben. <br><br><h2>  Haskell ist eine ziemlich alte Sprache.  Ist das gut oder schlecht? </h2><br>  Yuri Syrovetsky: Die Sprache entwickelt sich sehr aktiv, die Last der Kompatibilit√§t nur aus Gr√ºnden der Kompatibilit√§t zieht nicht. <br><br>  <b>John Doe</b> : Der Standard wurde 1998 √ºbernommen, aber das f√§llt nicht auf: Bis jetzt werden ungef√§hr alle sechs Monate neue Versionen des Compilers ver√∂ffentlicht, die m√∂glicherweise die Abw√§rtskompatibilit√§t beeintr√§chtigen. <br><br>  <b>Denis Mirzoev</b> : Haskell ist nicht alt, aber erprobt.  Gedankenlose √Ñnderungen werden niemals in die Sprache gelangen.  Es ist also ziemlich gut. <br><br><h2>  Haskell gilt als eine der komplexesten Sprachen.  Ist das so? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Wie die Sprache selbst, nein.  Wahrscheinlicher sind die darin verwendeten Abstraktionen.  Eine Person, die noch nie Haskell-Code gesehen hat, kann mit dem Fluss neuer Informationen und verschiedenen ungew√∂hnlichen Konstruktionen einfach verr√ºckt werden. <br><br>  √ñl tr√§gt zum Feuer bei, dass die Sprache eine Reihe von "Einschr√§nkungen" auferlegt, eine Reihe von Dingen, die nicht in ein Funktionskonzept passen, nicht zul√§sst oder stark erschwert. <br><br>  <b>John Doe</b> : Bis das erste Grundprojekt mindestens zusammengestellt war, dauerte es fast zwei Monate, um abends Lehrb√ºcher, Handb√ºcher und Tutorials zu rauchen.  Richtig, nach dem Kompilieren begann das Projekt sofort und arbeitete sechs Monate lang unter Volllast (6k U / min mit Spitzenwerten bis zu 15), ohne dass √Ñnderungen vorgenommen wurden. <br><br>  <b>Denis Mirzoev</b> : Ich wette, wenn ein Student anf√§ngt, Programmieren bei Haskell zu studieren und sich weit genug bewegt, wird ihm die imperative Programmierung komplizierter und weniger intuitiv erscheinen. <br><br>  <b>Igor Shevnin</b> : Die Komplexit√§t ist relativ.  Von den Mainstream-Sprachen finde ich C ++ immer noch die komplexeste.  Sprachen zum Beweisen von Theoremen (Agda, Coq) werden im konzeptionellen Sinne komplizierter sein als Haskell.  Haskell ist eine einfache Sprache, aber ihre Muster und Bibliotheken - Standard- und Drittanbieter-Sprachen - k√∂nnen bei weitem nicht sofort erlernt werden. <br><br><h2>  Ist seine Komplexit√§t immer gerechtfertigt? </h2><br>  <b>Igor Shevnin</b> : Muster und ein hohes Ma√ü an Abstraktion sind gerechtfertigt, da sie den Code zuverl√§ssiger und k√ºrzer machen.  Aber ich denke, dass Operatoren, Funktionsnamen und viele andere Dinge klarer sein k√∂nnten. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Mit komplexen Haskell-Konstrukten k√∂nnen Sie h√§ufig sehr kurze L√∂sungen erstellen, die sich auch als sehr flexibel und modular herausstellen. <br><br>  <b>Yuri Syrovetsky</b> : Abgesehen davon, dass das Verwalten von Effekten umst√§ndlich ist, wenn auch fast <br>  Es ist immer besser als mangelnde Kontrolle.  Aber √ºber die Vereinfachung <br>  Die Arbeit ist im Gange. <br><br>  <b>John Doe</b> : Die Sprache f√ºr diejenigen, die an regul√§res Python / PHP / was auch immer gew√∂hnt sind, l√§sst es im Allgemeinen orthogonal zur Realit√§t erscheinen.  F√ºr Menschen, die anfangs nicht an Kategorietheorie interessiert waren, ist es sehr schwierig, Ergebnisse vom absoluten Nullpunkt zu erzielen. <br><br>  Wenn Sie jedoch die Sprache verstehen, erhalten Sie eine neue M√∂glichkeit, √ºber das zu l√∂sende Problem nachzudenken. <br><br><h2>  Haskell scheint eine Sprache f√ºr Mathematiker zu sein, nicht f√ºr Entwickler.  Denken Sie, dass es deshalb nicht weit verbreitet ist? </h2><br>  <b>Denis Mirzoev</b> : Dies ist eine Demonstration des Prinzips, dem die Hauptentwickler von Haskell folgen: "Vermeiden Sie Erfolg um jeden Preis".  Es geht nat√ºrlich nicht darum, Erfolg zu vermeiden, sondern um Erfolg, dessen Preis zu hoch ist. <br><br>  Haskell k√∂nnte popul√§r gemacht werden.  Diese Sprache wird beispielsweise von Microsoft unterst√ºtzt.  Es war m√∂glich, die Sprache zwingender zu machen, einige schnelle und schlecht durchdachte Entscheidungen zu treffen, um an Popularit√§t zu gewinnen.  Es war m√∂glich, viele schmutzige Tricks anzuwenden, aber dank der richtigen Position der Hauptentwickler gab es nichts Vergleichbares. <br><br>  Ja, die Popularit√§t der Sprache ist nicht sehr hoch, aber ihre Qualit√§t leidet nicht.  Die Vorteile von Haskell gegen√ºber imperativen Sprachen liegen f√ºr mich auf der Hand. Die meisten seiner Probleme sind l√∂sbar. Ich bin mir daher sicher, dass die Entwicklung im Laufe der Zeit sehr beliebt sein wird. <br><br>  <b>Yuri Syrovetsky</b> : Also wird er nur von Leuten gesehen, die nichts √ºber ihn wissen.  In <br>  Haskell nutzt die "echte" Entwicklung seit langem, Beispiele sind leicht zu finden <br>  Ihre Lieblingssuchmaschine.  Insbesondere verwenden wir in LC <br>  Haskell ist zufrieden und wir sehen nichts anderes an seiner Stelle. <br><br>  <b>Igor Shevnin</b> : Was eine "Sprache f√ºr Mathematiker" ist, wei√ü ich wirklich nicht.  Dies ist entweder R / MatLab / Mathematica f√ºr Berechnungen und Statistiken oder Python, da es einfach ist und weniger technischen Hintergrund erfordert.  Aber nicht Haskell.  Algebraische Konzepte wie Monoide werden darin aus praktischen Gr√ºnden und nicht nur f√ºr zus√§tzliche Genauigkeit verwendet. <br><br>  Die Hauptrolle bei der Popularit√§t spielte die historische Verbreitung von C / C ++ / Java / C # im Unternehmen, sie besetzten eine Nische.  Aber jetzt beginnen viele Unternehmen, Haskell und andere funktionale Sprachen zu verwenden. <br><br><h2>  Mit welchem ‚Äã‚ÄãYap w√ºrden Sie Haskell vergleichen und zu wessen Gunsten? </h2><br>  <b>John Doe</b> : Mehr oder weniger h√§ufig - mit Erlang.  Aber Erlang ist immer noch leichter zu schreiben und leichter zu lernen, scheint mir. <br><br>  <b>Denis Mirzoev</b> : Ich kenne C, C ++, Java und Haskell gut.  C ++ muss nicht einmal mit irgendetwas verglichen werden, die Sprache ist schrecklich.  C ist eine gute Sprache f√ºr die Entwicklung auf niedriger Ebene.  In dieser Nische wird er besser sein.  Ansonsten w√ºrde ich Haskell vorziehen. <br><br>  Die Wahl zwischen Java und Haskell ist bereits schwieriger, aber hier m√ºssen Sie sich auch eine bestimmte Aufgabe ansehen.  F√ºr Android auf Haskell wird es h√∂chstwahrscheinlich schwierig sein zu schreiben, in diesem Fall ist Java besser.  Der in Haskell zu schreibende Server ist jedoch fast so praktisch wie in Java.  Wenn die Umgebung dies zul√§sst - Optimierung, Zug√§nglichkeit von Bibliotheken -, w√§hle ich normalerweise Haskell. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Mit C # googeln Sie einfach, wie Sie Vielleicht in C # und in Haskell implementieren.  Es ist sehr seltsam, dass sich der diktatorische rein funktionale Haskell viel flexibler und freier f√ºhlt.  In der Tat sind dies zwei Extreme. <br><br>  C # ist eine der objektorientiertesten Sprachen, und die Vorteile von Haskell stehen in starkem Kontrast dazu.  In C # muss man st√§ndig eine Menge unn√∂tiger Dinge schreiben, und das alles ist sehr unangenehm.  Die Verwendung von Funktionen h√∂herer Ordnung kann den Code in Bezug auf die Syntax verderben.  Inmitten all dessen ist es bereits schwierig, von Haskells kurzen und eleganten L√∂sungen zur√ºck zu kommen. <br><br>  <b>Igor Shevnin</b> : Mit Rust bisher zugunsten von Rust.  Es erfordert viel von Haskell und anderen FP-Sprachen, aber gleichzeitig ist der funktionale Ansatz mit dem Imperativ vereinbar, und die Entwickler und die Community sind von Anfang an viel kompetenter und konsequenter bei der Entwicklung der Sprache. <br><br><h2>  Was halten Sie von der Haskellistengemeinschaft? </h2><br>  <b>John Doe</b> : Die √ºberwiegende Mehrheit sind sehr freundliche Menschen, die immer bereit sind zu helfen.  Ein sch√∂ner Unterschied zu den Communities vieler anderer Sprachen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : In Haskell-Communities gibt es oft erschreckend kluge Leute, die immer bereit sind zu helfen.  Nicht umsonst gehen lokale Memes √ºber PhD, Kategorietheorie und Akademiker.  Wenn Sie in anderen Sprachen in den Chat gehen, sehen Sie, dass die Leute √ºber normale Produktionsprobleme und Datenstrukturen diskutieren.  In einem Haskell-Chat tauchen sofort Monaden, Yonedas Lemma, anwendbare Funktoren, das Schreiben verr√ºckter Typen usw. vor Ihnen auf. <br><br>  Sie sehen sofort so viel Neues, dass Sie es vorher nicht wussten - verr√ºckte Kompositionen, elegante Transformationen und Transformationen, L√∂sungen f√ºr Probleme, die Dutzende von Zeilen in den Mainstream-Sprachen einnehmen, fast in einer Zeile. <br><br><h2>  Sie sagen, die Haskellisten seien arrogant.  Richtig? </h2><br>  <b>Denis Mirzoev</b> : Ja.  Es scheint mir, dass Arroganz auf die Tatsache zur√ºckzuf√ºhren ist, dass sie ihre Sprache wirklich lieben und sich √ºber ihre Untersch√§tzung aufregen. <br><br>  <b>John Doe</b> : Nifiga so. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Diese Meinung ist h√∂chstwahrscheinlich verschwunden, da viele Mainstream-Entwickler sehr ver√§rgert sind, wenn Haskelists √ºber funktionale Programmierung und ihre Vorteile sprechen.  Ein schreckliches Missverst√§ndnis kann wiederum den Haskelisten selbst √§rgern, und er wird anfangen, sich in Begriffen zu beeilen, f√ºr die er von den FAQ stigmatisiert wird. <br><br>  <b>Igor Shevnin</b> : Arroganz ist ein zu starkes Wort.  Hier geht es vielmehr darum, dass FP, OOP, der Unterschied zwischen OOP-Klassen und Unionstypen, das Erweiterungsproblem und viele andere Konzepte einst ein sehr klares Bild ergeben und es danach schwierig wird, Menschen wahrzunehmen, die versuchen, sich OOP und FI zu widersetzen oder sich auf andere Weise vorzustellen weit verbreitetes Problem in einer engen Perspektive. <br><br><h2>  Warum sind FP-Sprachen immer noch eine Nische? </h2><br>  <b>Denis Mirzoev</b> : Ihre Vorteile reichen immer noch nicht aus, um eine gro√üe Anzahl von Programmierern zu interessieren.  Lernschwierigkeiten beg√ºnstigen die Popularit√§t nicht.  Probleme mit dem Tuning schrecken auch viele ab, aber es scheint mir, dass nur eine Vergr√∂√üerung der Community dieses Problem l√∂sen k√∂nnte.  Es stellt sich ein Teufelskreis heraus. <br><br>  <b>Igor Shevnin</b> : Die Nische <b>vergeht</b> allm√§hlich und funktionale Konzepte werden in andere Sprachen gezogen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Die Funktionsprinzipien selbst und die Sprachen, die sie unterst√ºtzen, sind bereits allgegenw√§rtig.  Selbst f√ºr Sharps gibt es Linq und einige andere Bibliotheken.  Nischen sind eher rein funktionale Sprachen, da sie nicht standardm√§√üige Konzepte verwenden. <br><br>  Vergessen Sie nicht, dass Eisen vor 20 Jahren f√ºr funktionale Sprachen nicht produktiv genug war, so dass der Funktionalismus in den letzten Jahren in den Mainstream eintrat und das Interesse an Haskell nur w√§chst. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438970/">https://habr.com/ru/post/de438970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438960/index.html">Wie ich Ruby zugunsten von Python aufgegeben habe, als ich an einem Backend gearbeitet habe</a></li>
<li><a href="../de438962/index.html">Zum gr√∂√üten Teil ein positiver Ausblick f√ºr die Zukunft der Chips</a></li>
<li><a href="../de438964/index.html">Wer steht wirklich hinter den beliebten kostenlosen VPNs?</a></li>
<li><a href="../de438966/index.html">Haproxy-Dokumentation, die den Verlauf durchl√§uft, oder worauf bei der Konfiguration zu achten ist</a></li>
<li><a href="../de438968/index.html">Schuhe in Russland markieren: Der Markt ist noch nicht fertig, muss aber funktionieren</a></li>
<li><a href="../de438972/index.html">Das Gehirn von innen (Visualisierung des Durchgangs des Musters durch das k√ºnstliche neuronale Netzwerkmodell)</a></li>
<li><a href="../de438974/index.html">Virtuelle Realit√§t hilft bei psychischen St√∂rungen</a></li>
<li><a href="../de438976/index.html">Das Buch "Fr√ºhling. Alle Designmuster ¬ª</a></li>
<li><a href="../de438978/index.html">Immer und √ºberall lernen! Podcasts f√ºr Entwickler in englischer Sprache</a></li>
<li><a href="../de438980/index.html">Spring Boot 2: Was ist neu?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>