<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚱️ ⚾️ 👨🏻‍💼 Haskell soll eine Sprache für Genies und Akademiker sein. Richtig? 🛌🏾 🚗 👂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe einmal mit dem Gründer eines israelischen Startups gesprochen, das eine Hochgeschwindigkeits-GPU-Datenbank entwickelt. Haskell und C ++ waren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haskell soll eine Sprache für Genies und Akademiker sein. Richtig?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438970/"><img src="https://habrastorage.org/webt/o6/qs/0d/o6qs0dg9mgydyepqfcn6kpobfnc.jpeg"><br><br>  Ich habe einmal mit dem Gründer eines israelischen Startups gesprochen, das eine Hochgeschwindigkeits-GPU-Datenbank entwickelt.  Haskell und C ++ waren auf ihrem Stapel und der Gründer beschwerte sich darüber, wie schwierig es sei, Leute im Team zu finden.  Er flog nach Moskau, auch um gute Programmierer zu suchen. <br><br>  Ich fragte sorgfältig, ob es besser sei, etwas allgemeineres und neues zu verwenden.  Und obwohl die Antwort höflich und konstruktiv war, schien es mir zwischen den Zeilen: "Pff, erwähne diese Spielzeug-Yapes nicht einmal." <br><br>  Alles, was ich seitdem von der Seite über Haskell gehört habe, war auf eines zurückzuführen: "Witze sind schlecht mit ihm."  Um die Haskellisten besser kennenzulernen, kam ich zum Telegramm-Chat, um ihnen Fragen zu stellen.  Es war ziemlich beängstigend und wie sich herausstellte, nicht umsonst. <br><br>  Sie wollen nicht im Volksmund über Haskell sprechen, und es scheint, dass sie solche Unternehmungen mit Verachtung betrachten.  Schon gesprochen - mit maximaler Vollständigkeit und Objektivität.  „Eine der charakteristischen Eigenschaften von Haskell als Sprache und Gemeinschaft ist, dass sie gemeinsam nicht danach strebten, populär zu werden, und eine einfache Antwort auf populäre Fragen gaben.  Stattdessen haben sie einen logischen, prinzipiellen Weg gefunden, um echte Probleme zu lösen, anstatt schnell in das Herz eines Passanten einer interessierten Person einzudringen “, schrieben sie mir dort. <br><br>  Einige Personen teilten jedoch ihre Erfahrungen mit, und ich sammelte hier ihre Meinungen. <br><a name="habracut"></a><br>  <b>Denis Mirzoev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">nolane</a> )</b> : An der Universität wurde mir zum Thema "Programmiersprachen" angeboten, einen Kurs bei Haskell Coursera für einen weiteren von hundert Punkten zu <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">belegen</a></b> .  Dann gab es einen funktionalen Programmierkurs, bei dem Haskell stattfand.  Er schrieb eine Hausarbeit und eine Abschlussarbeit des Bachelor über GHC.  Ich habe einen Job als Haskell-Programmierer gefunden. <br><br>  Es war schwer und immer noch schwer.  Wenn Sie anfangen, Haskell zu studieren, müssen Sie viele neue Konzepte verstehen.  Das ist harte Arbeit.  Sie lernen buchstäblich wieder zu programmieren. <br><br>  Für viele wird es jetzt schwierig sein, sich daran zu erinnern, wie sie ihre Reise in die Programmierung begonnen haben, wie schwierig es war zu verstehen, was ein „Zeiger“ war, was eine „Funktion“, was eine „Klasse“ ist.  Vielleicht ist es deshalb so schwer, Haskell zu studieren.  Mit zunehmendem Alter wird es schwieriger, neue Dinge zu lernen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Einmal in einer Probezeit bin ich in Redux gefallen. Als ich mir die Lektionen seines Schöpfers <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ansah</a></b> , beschloss ich, alle besser kennenzulernen.  Zuerst habe ich die erlernten Praktiken in JavaScript angewendet, dann aber Haskell kennengelernt, das als echte funktionale Sprache gilt.  Ich war sofort von seiner Eleganz und einer Reihe neuer Konzepte angezogen, die mir unbekannt waren. <br><br>  Es war nicht einfach mit endlosen Tutorials über Monaden am Beispiel von Burritos, die sehr verwirrend sind.  Ein zwingender Hintergrund macht es auch schwierig, neue Konzepte zu eröffnen. <br><br>  <b>Yuri Syrovetsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">cblp</a> )</b> : Am schwierigsten zu lernen ist Haskell als Zweiter, als das Entlein-Syndrom nicht in die erste Sprache <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">überging</a></b> . <br><br><h2>  Was ist gut und was ist schlechte Sprache? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Die Sprache ist sehr prägnant, elegant und flexibel, nicht umsonst ist die Hälfte der Bibliotheken EDSL (zumindest dieser Eindruck). <br><br>  <b>Yuri Syrovetsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">cblp</a> )</b> : Hohe Ausdruckskraft, einfache Übertragung des Themenbereichs auf Code, die optimale Kombination von imperativen und funktionalen Paradigmen.  Es ist einfach, Abstraktionen auf Daten und Algorithmen zu erstellen, sodass Sie über das Problem nachdenken können, ohne von kleinen Dingen abgelenkt zu werden. <br><br>  <b>John Doe</b> : Streng starkes (ich würde sagen faschistisches) Tippen. <br><br>  <b>Igor Shevnin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">interphx</a> )</b> : Ein sehr ausdrucksstarkes <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Typensystem</a></b> .  Nicht so mächtig wie Idris oder Agda, aber es erreicht diesen Mittelweg, wenn fast alles ausgedrückt werden kann und die Typinferenz gut funktioniert.  Sie müssen sie nicht überall manuell markieren. <br><br>  Bei einem leistungsstarken Typsystem müssen Sie jedoch auf die übergebenen Werte achten.  Eine Reihe von Typdefinitionen könnte wie ein Boilerplate aussehen.  Jedes Team verwendet seine eigenen Erweiterungen oder verwendet sie überhaupt nicht.  Der Code ist "dichter" - eine Zeile enthält häufig mehr Informationen als in anderen Sprachen, sodass es für einen unerfahrenen Entwickler schwieriger ist, sie zu lesen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Wenn Sie Haskell studieren, werden Sie höchstwahrscheinlich auf das Sprichwort stoßen: "Wenn es kompiliert, ist es wahrscheinlich richtig."  Es gibt keine Null, das Funktionsparadigma selbst ist sehr streng und zwingt Sie, bestimmte Regeln zu befolgen, die in den meisten Fällen zu einem besseren Design führen. <br><br>  Zum Beispiel gibt es keine Variablen in der Sprache - nur Konstanten.  Sie müssen nicht verfolgen, was und wo Sie zuweisen.  Haskell empfiehlt die Verwendung reiner Funktionen, was zu keinen Nebenwirkungen führt.  Das funktionale Design lässt das Programm einfach als Ganzes funktionieren, im Gegensatz zu OOP, wo eine Reihe von Objekten in die Welt geworfen werden und Objekte versuchen, durch Nebenwirkungen miteinander zu kommunizieren, was die Anwendung in ein unvorhersehbares Chaos verwandelt.  Bei der Arbeit leiden wir mit C # in Unity genug darunter. <br><br>  <b>Denis Mirzoev</b> : Eingebaute Faulheit erhöht die Ausdruckskraft der Sprache.  Viele Algorithmen werden einfacher.  Es kann die Produktivität steigern, wenn die Ergebnisse von Zwischenberechnungen nicht verwendet werden.  (Zum Beispiel arbeitet `head. Sort` in linearer Zeit). <br><br>  <b>Igor Shevnin</b> : Ein faules Rechenmodell hilft normalerweise, aber wenn die Reihenfolge der aufrufenden Funktionen wichtig ist, kann es schwierig sein, herauszufinden, was passiert. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Es wird kompiliert, was die Geschwindigkeit sofort enorm erhöht. <br><br>  <b>Denis Mirzoev</b> : Im Vergleich zu Java in der Geschwindigkeit, aber nicht so schnell wie C. <br><br>  <b>Igor Shevnin</b> : <b>Standardmäßig werden</b> Erweiterungen unterstützt, mit denen Sie das Sprach- und <b>Typensystem</b> fertigstellen können.  Es gibt jedoch viele weit verbreitete Erweiterungen, die der Community vertraut sind, anständige Beispiele und Dokumentationen enthalten und keine Nische darstellen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Die Prelude-Standardbibliothek hat sehr schlechte Funktionen wie read, head, readFile, die eine Ausnahme auslösen und in ein Programm einfügen können, anstatt Vielleicht zurückzugeben.  Daher müssen Sie Alternativen verwenden oder Ihre eigenen Implementierungen schreiben. <br><br>  <b>Igor Shevnin</b> : Das Hauptproblem ist die mangelnde Standardisierung, da viele die Standardbibliothek durch eine der inkompatiblen Alternativen ersetzen.  In der Community gibt es Meinungsverschiedenheiten darüber, was eine Standardbibliothek sein sollte, was im Kern der Sprache enthalten sein sollte und was durch Erweiterungen ergänzt werden sollte, und ich bin der Meinung, dass dies die Entwicklung der Sprache verlangsamt. <br><br>  <b>Denis Mirzoev</b> : Es gibt nicht genügend Tools: Es gibt keine vollwertige IDE, es gibt nur sehr wenige Tools zum Messen der Leistung, es gibt kein "schrittweises" Debuggen - dies ist im Allgemeinen ein grundlegendes Problem. <br><br><h2>  Für welche Projekte ist Haskell am besten geeignet? </h2><br>  <b>Yuri Syrovetsky</b> : Für komplexe Aufgaben im Zusammenhang mit Sicherheit oder Geld, bei denen die Fehlerkosten hoch sind. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Für alles, wo Sie Berechnungen, Transformationen und Datenanalysen durchführen müssen.  Sehr überrascht, dass Haskell in Data Science weniger beliebt ist als Python. <br><br>  <b>Igor Shevnin</b> : Ich würde nicht riskieren, es für eingebettete Systeme zu verwenden (die Leistung ist nicht schlecht, aber es gibt immer noch einen erheblichen Overhead für den Speicherverbrauch aufgrund fauler Berechnungen) und kleine Skripte (diese Genauigkeit wird dort einfach nicht benötigt).  Sie müssen auch verstehen, dass es viel schwieriger ist, Entwickler in einem Team zu finden als für Mainstream-Sprachen. <br><br>  <b>John Doe</b> : Um Branchencode zu schreiben, den andere lesen werden, benötigen Sie ein ganzes Team von Haskellisten.  So wenige Menschen haben es geschafft zu sammeln. <br><br>  <b>Igor Shevnin</b> : Aufgrund seiner Kürze und Genauigkeit ist Haskell für fast jede Aufgabe geeignet. <br><br><h2>  Es ist eine gute Idee, mit Haskell die Entwicklung zu lernen? </h2><br>  Igor Shevnin: Es ist unwahrscheinlich, dass es anfängt, da die überwiegende Mehrheit der Codebasen, mit denen eine Person arbeiten muss, nicht darauf geschrieben ist. <br><br>  <b>John Doe</b> : Schlechte, schlechte Idee!  Sprachen, die nicht aus der ML-Familie stammen, sondern aus den Industriesprachen im Allgemeinen, werden Sie dann schockieren. <br><br>  <b>Denis Mirzoev</b> : Normalerweise studieren die Leute zuerst Mathematik und dann Programmieren.  Daher sollte das Erlernen einer Sprache mit mathematischen Konzepten (algebraische Datentypen, reine Funktionen) einfacher als zwingend sein.  Das heißt, ich denke, das ist eine gute Idee. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Alle Neuankömmlinge, die ich trainiere, werde ich Ihnen auf jeden Fall Haskell vorstellen.  Menschen, die den imperativen Stil nicht studiert haben, sind viel einfacher im Funktionscode zu navigieren und lernen schneller. Selbst wenn sie mit objektorientierten Sprachen arbeiten, bringen sie gute architektonische Lösungen und funktionale Praktiken mit. <br><br>  <b>Yuri Syrovetsky</b> : Es ist besser, sofort mit mehreren grundlegend unterschiedlichen Sprachen zu beginnen, zum Beispiel C, Haskell und Smalltok, in beliebiger Reihenfolge.  Keine einzige Sprache in <br>  separat wird kein vollständiges Verständnis geben. <br><br><h2>  Haskell ist eine ziemlich alte Sprache.  Ist das gut oder schlecht? </h2><br>  Yuri Syrovetsky: Die Sprache entwickelt sich sehr aktiv, die Last der Kompatibilität nur aus Gründen der Kompatibilität zieht nicht. <br><br>  <b>John Doe</b> : Der Standard wurde 1998 übernommen, aber das fällt nicht auf: Bis jetzt werden ungefähr alle sechs Monate neue Versionen des Compilers veröffentlicht, die möglicherweise die Abwärtskompatibilität beeinträchtigen. <br><br>  <b>Denis Mirzoev</b> : Haskell ist nicht alt, aber erprobt.  Gedankenlose Änderungen werden niemals in die Sprache gelangen.  Es ist also ziemlich gut. <br><br><h2>  Haskell gilt als eine der komplexesten Sprachen.  Ist das so? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Wie die Sprache selbst, nein.  Wahrscheinlicher sind die darin verwendeten Abstraktionen.  Eine Person, die noch nie Haskell-Code gesehen hat, kann mit dem Fluss neuer Informationen und verschiedenen ungewöhnlichen Konstruktionen einfach verrückt werden. <br><br>  Öl trägt zum Feuer bei, dass die Sprache eine Reihe von "Einschränkungen" auferlegt, eine Reihe von Dingen, die nicht in ein Funktionskonzept passen, nicht zulässt oder stark erschwert. <br><br>  <b>John Doe</b> : Bis das erste Grundprojekt mindestens zusammengestellt war, dauerte es fast zwei Monate, um abends Lehrbücher, Handbücher und Tutorials zu rauchen.  Richtig, nach dem Kompilieren begann das Projekt sofort und arbeitete sechs Monate lang unter Volllast (6k U / min mit Spitzenwerten bis zu 15), ohne dass Änderungen vorgenommen wurden. <br><br>  <b>Denis Mirzoev</b> : Ich wette, wenn ein Student anfängt, Programmieren bei Haskell zu studieren und sich weit genug bewegt, wird ihm die imperative Programmierung komplizierter und weniger intuitiv erscheinen. <br><br>  <b>Igor Shevnin</b> : Die Komplexität ist relativ.  Von den Mainstream-Sprachen finde ich C ++ immer noch die komplexeste.  Sprachen zum Beweisen von Theoremen (Agda, Coq) werden im konzeptionellen Sinne komplizierter sein als Haskell.  Haskell ist eine einfache Sprache, aber ihre Muster und Bibliotheken - Standard- und Drittanbieter-Sprachen - können bei weitem nicht sofort erlernt werden. <br><br><h2>  Ist seine Komplexität immer gerechtfertigt? </h2><br>  <b>Igor Shevnin</b> : Muster und ein hohes Maß an Abstraktion sind gerechtfertigt, da sie den Code zuverlässiger und kürzer machen.  Aber ich denke, dass Operatoren, Funktionsnamen und viele andere Dinge klarer sein könnten. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Mit komplexen Haskell-Konstrukten können Sie häufig sehr kurze Lösungen erstellen, die sich auch als sehr flexibel und modular herausstellen. <br><br>  <b>Yuri Syrovetsky</b> : Abgesehen davon, dass das Verwalten von Effekten umständlich ist, wenn auch fast <br>  Es ist immer besser als mangelnde Kontrolle.  Aber über die Vereinfachung <br>  Die Arbeit ist im Gange. <br><br>  <b>John Doe</b> : Die Sprache für diejenigen, die an reguläres Python / PHP / was auch immer gewöhnt sind, lässt es im Allgemeinen orthogonal zur Realität erscheinen.  Für Menschen, die anfangs nicht an Kategorietheorie interessiert waren, ist es sehr schwierig, Ergebnisse vom absoluten Nullpunkt zu erzielen. <br><br>  Wenn Sie jedoch die Sprache verstehen, erhalten Sie eine neue Möglichkeit, über das zu lösende Problem nachzudenken. <br><br><h2>  Haskell scheint eine Sprache für Mathematiker zu sein, nicht für Entwickler.  Denken Sie, dass es deshalb nicht weit verbreitet ist? </h2><br>  <b>Denis Mirzoev</b> : Dies ist eine Demonstration des Prinzips, dem die Hauptentwickler von Haskell folgen: "Vermeiden Sie Erfolg um jeden Preis".  Es geht natürlich nicht darum, Erfolg zu vermeiden, sondern um Erfolg, dessen Preis zu hoch ist. <br><br>  Haskell könnte populär gemacht werden.  Diese Sprache wird beispielsweise von Microsoft unterstützt.  Es war möglich, die Sprache zwingender zu machen, einige schnelle und schlecht durchdachte Entscheidungen zu treffen, um an Popularität zu gewinnen.  Es war möglich, viele schmutzige Tricks anzuwenden, aber dank der richtigen Position der Hauptentwickler gab es nichts Vergleichbares. <br><br>  Ja, die Popularität der Sprache ist nicht sehr hoch, aber ihre Qualität leidet nicht.  Die Vorteile von Haskell gegenüber imperativen Sprachen liegen für mich auf der Hand. Die meisten seiner Probleme sind lösbar. Ich bin mir daher sicher, dass die Entwicklung im Laufe der Zeit sehr beliebt sein wird. <br><br>  <b>Yuri Syrovetsky</b> : Also wird er nur von Leuten gesehen, die nichts über ihn wissen.  In <br>  Haskell nutzt die "echte" Entwicklung seit langem, Beispiele sind leicht zu finden <br>  Ihre Lieblingssuchmaschine.  Insbesondere verwenden wir in LC <br>  Haskell ist zufrieden und wir sehen nichts anderes an seiner Stelle. <br><br>  <b>Igor Shevnin</b> : Was eine "Sprache für Mathematiker" ist, weiß ich wirklich nicht.  Dies ist entweder R / MatLab / Mathematica für Berechnungen und Statistiken oder Python, da es einfach ist und weniger technischen Hintergrund erfordert.  Aber nicht Haskell.  Algebraische Konzepte wie Monoide werden darin aus praktischen Gründen und nicht nur für zusätzliche Genauigkeit verwendet. <br><br>  Die Hauptrolle bei der Popularität spielte die historische Verbreitung von C / C ++ / Java / C # im Unternehmen, sie besetzten eine Nische.  Aber jetzt beginnen viele Unternehmen, Haskell und andere funktionale Sprachen zu verwenden. <br><br><h2>  Mit welchem ​​Yap würden Sie Haskell vergleichen und zu wessen Gunsten? </h2><br>  <b>John Doe</b> : Mehr oder weniger häufig - mit Erlang.  Aber Erlang ist immer noch leichter zu schreiben und leichter zu lernen, scheint mir. <br><br>  <b>Denis Mirzoev</b> : Ich kenne C, C ++, Java und Haskell gut.  C ++ muss nicht einmal mit irgendetwas verglichen werden, die Sprache ist schrecklich.  C ist eine gute Sprache für die Entwicklung auf niedriger Ebene.  In dieser Nische wird er besser sein.  Ansonsten würde ich Haskell vorziehen. <br><br>  Die Wahl zwischen Java und Haskell ist bereits schwieriger, aber hier müssen Sie sich auch eine bestimmte Aufgabe ansehen.  Für Android auf Haskell wird es höchstwahrscheinlich schwierig sein zu schreiben, in diesem Fall ist Java besser.  Der in Haskell zu schreibende Server ist jedoch fast so praktisch wie in Java.  Wenn die Umgebung dies zulässt - Optimierung, Zugänglichkeit von Bibliotheken -, wähle ich normalerweise Haskell. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Mit C # googeln Sie einfach, wie Sie Vielleicht in C # und in Haskell implementieren.  Es ist sehr seltsam, dass sich der diktatorische rein funktionale Haskell viel flexibler und freier fühlt.  In der Tat sind dies zwei Extreme. <br><br>  C # ist eine der objektorientiertesten Sprachen, und die Vorteile von Haskell stehen in starkem Kontrast dazu.  In C # muss man ständig eine Menge unnötiger Dinge schreiben, und das alles ist sehr unangenehm.  Die Verwendung von Funktionen höherer Ordnung kann den Code in Bezug auf die Syntax verderben.  Inmitten all dessen ist es bereits schwierig, von Haskells kurzen und eleganten Lösungen zurück zu kommen. <br><br>  <b>Igor Shevnin</b> : Mit Rust bisher zugunsten von Rust.  Es erfordert viel von Haskell und anderen FP-Sprachen, aber gleichzeitig ist der funktionale Ansatz mit dem Imperativ vereinbar, und die Entwickler und die Community sind von Anfang an viel kompetenter und konsequenter bei der Entwicklung der Sprache. <br><br><h2>  Was halten Sie von der Haskellistengemeinschaft? </h2><br>  <b>John Doe</b> : Die überwiegende Mehrheit sind sehr freundliche Menschen, die immer bereit sind zu helfen.  Ein schöner Unterschied zu den Communities vieler anderer Sprachen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : In Haskell-Communities gibt es oft erschreckend kluge Leute, die immer bereit sind zu helfen.  Nicht umsonst gehen lokale Memes über PhD, Kategorietheorie und Akademiker.  Wenn Sie in anderen Sprachen in den Chat gehen, sehen Sie, dass die Leute über normale Produktionsprobleme und Datenstrukturen diskutieren.  In einem Haskell-Chat tauchen sofort Monaden, Yonedas Lemma, anwendbare Funktoren, das Schreiben verrückter Typen usw. vor Ihnen auf. <br><br>  Sie sehen sofort so viel Neues, dass Sie es vorher nicht wussten - verrückte Kompositionen, elegante Transformationen und Transformationen, Lösungen für Probleme, die Dutzende von Zeilen in den Mainstream-Sprachen einnehmen, fast in einer Zeile. <br><br><h2>  Sie sagen, die Haskellisten seien arrogant.  Richtig? </h2><br>  <b>Denis Mirzoev</b> : Ja.  Es scheint mir, dass Arroganz auf die Tatsache zurückzuführen ist, dass sie ihre Sprache wirklich lieben und sich über ihre Unterschätzung aufregen. <br><br>  <b>John Doe</b> : Nifiga so. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Diese Meinung ist höchstwahrscheinlich verschwunden, da viele Mainstream-Entwickler sehr verärgert sind, wenn Haskelists über funktionale Programmierung und ihre Vorteile sprechen.  Ein schreckliches Missverständnis kann wiederum den Haskelisten selbst ärgern, und er wird anfangen, sich in Begriffen zu beeilen, für die er von den FAQ stigmatisiert wird. <br><br>  <b>Igor Shevnin</b> : Arroganz ist ein zu starkes Wort.  Hier geht es vielmehr darum, dass FP, OOP, der Unterschied zwischen OOP-Klassen und Unionstypen, das Erweiterungsproblem und viele andere Konzepte einst ein sehr klares Bild ergeben und es danach schwierig wird, Menschen wahrzunehmen, die versuchen, sich OOP und FI zu widersetzen oder sich auf andere Weise vorzustellen weit verbreitetes Problem in einer engen Perspektive. <br><br><h2>  Warum sind FP-Sprachen immer noch eine Nische? </h2><br>  <b>Denis Mirzoev</b> : Ihre Vorteile reichen immer noch nicht aus, um eine große Anzahl von Programmierern zu interessieren.  Lernschwierigkeiten begünstigen die Popularität nicht.  Probleme mit dem Tuning schrecken auch viele ab, aber es scheint mir, dass nur eine Vergrößerung der Community dieses Problem lösen könnte.  Es stellt sich ein Teufelskreis heraus. <br><br>  <b>Igor Shevnin</b> : Die Nische <b>vergeht</b> allmählich und funktionale Konzepte werden in andere Sprachen gezogen. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Doctor_Ryner</a></b> : Die Funktionsprinzipien selbst und die Sprachen, die sie unterstützen, sind bereits allgegenwärtig.  Selbst für Sharps gibt es Linq und einige andere Bibliotheken.  Nischen sind eher rein funktionale Sprachen, da sie nicht standardmäßige Konzepte verwenden. <br><br>  Vergessen Sie nicht, dass Eisen vor 20 Jahren für funktionale Sprachen nicht produktiv genug war, so dass der Funktionalismus in den letzten Jahren in den Mainstream eintrat und das Interesse an Haskell nur wächst. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438970/">https://habr.com/ru/post/de438970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438960/index.html">Wie ich Ruby zugunsten von Python aufgegeben habe, als ich an einem Backend gearbeitet habe</a></li>
<li><a href="../de438962/index.html">Zum größten Teil ein positiver Ausblick für die Zukunft der Chips</a></li>
<li><a href="../de438964/index.html">Wer steht wirklich hinter den beliebten kostenlosen VPNs?</a></li>
<li><a href="../de438966/index.html">Haproxy-Dokumentation, die den Verlauf durchläuft, oder worauf bei der Konfiguration zu achten ist</a></li>
<li><a href="../de438968/index.html">Schuhe in Russland markieren: Der Markt ist noch nicht fertig, muss aber funktionieren</a></li>
<li><a href="../de438972/index.html">Das Gehirn von innen (Visualisierung des Durchgangs des Musters durch das künstliche neuronale Netzwerkmodell)</a></li>
<li><a href="../de438974/index.html">Virtuelle Realität hilft bei psychischen Störungen</a></li>
<li><a href="../de438976/index.html">Das Buch "Frühling. Alle Designmuster »</a></li>
<li><a href="../de438978/index.html">Immer und überall lernen! Podcasts für Entwickler in englischer Sprache</a></li>
<li><a href="../de438980/index.html">Spring Boot 2: Was ist neu?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>