<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👪 👩🏽‍🎓 🐣 Pemrograman Asinkron dengan Contoh: Merekonstruksi java.util.concurrent.CompletableFuture Methods ☃️ 🍢 ⛹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa rekonstruksi diperlukan jika kode sumber untuk kelas ini terbuka? 


 Jika hanya karena di bawah kap ada kode yang sangat optimal, sulit dibac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman Asinkron dengan Contoh: Merekonstruksi java.util.concurrent.CompletableFuture Methods</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418547/"><p>  Mengapa rekonstruksi diperlukan jika kode sumber untuk kelas ini terbuka? </p><br><p>  Jika hanya karena di bawah kap ada kode yang sangat optimal, sulit dibaca, studi yang memberikan sedikit pedagogis. </p><br><p>  Oleh karena itu, kami akan membuat ulang semantik operasi sesuai dengan spesifikasinya, dan menulis kode yang secara fungsional setara, dapat dimengerti, dan dapat dibaca, meskipun itu mungkin bukan yang paling ekonomis dalam hal konsumsi memori dan waktu prosesor. </p><a name="habracut"></a><br><p>  Mari kita mulai dengan metode yang relatif sederhana: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><span class="hljs-function"> Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor with the value obtained by calling the given Supplier. Type Parameters: U - the function's return type Parameters: supplier - a function returning the value to be used to complete the returned CompletableFuture executor - the executor to use </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> asynchronous execution Returns: the new CompletableFuture</span></span></code> </pre> <br><p>  Baca spesifikasi dengan cermat: </p><br><pre> <code class="java hljs">Returns a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture</code> </pre> <br><p>  Yaitu, objek bertipe <code>CompletableFuture</code> atau subkelasnya dibuat dan dikembalikan sebagai hasilnya. </p><br><pre> <code class="java hljs">that is asynchronously completed by a task running in the given executor`</code> </pre> <br><p>  Selain itu, tugas dijalankan yang dieksekusi pada <code>Executor</code> e. <br>  Seperti yang kita ketahui, <code>Executor</code> hanya menerima objek <code>Runnable</code> . <br>  Runnable adalah sebuah antarmuka, dan objek pertama mungkin mengimplementasikannya - jadi kami akan menggabungkan dua fungsi dalam satu objek. </p><br><pre> <code class="java hljs"> completed ... with the value obtained by calling the given Supplier.</code> </pre> <br><p>  <code>Runnable</code> ini harus memanggil <code>Supplier</code> diberikan dan dengan nilai yang diterima melengkapi <code>CompletableFuture</code> dibuat. </p><br><p>  <code>Supplier</code> adalah fungsi tanpa parameter, jadi menyandikan semuanya sangat sederhana: </p><br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableFutureForSupplyAsync</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableFuture</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ Supplier&lt;U&gt; supplier; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompletableFutureForSupplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.supplier = supplier; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { U result = supplier.get(); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.complete(result); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.completeExceptionally(e); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><span class="hljs-function"> </span></span>{ CompletableFutureForSupplyAsync&lt;U&gt; task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFutureForSupplyAsync&lt;&gt;(supplier); executor.execute(task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Contoh berikut ini sedikit lebih rumit: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thenApplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,? extends U&gt; fn, Executor executor)</span></span></span><span class="hljs-function"> Returns a new CompletionStage that, when </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> stage completes normally, is executed using the supplied Executor, with </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> stage's result as the argument to the supplied function. See the CompletionStage documentation </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> rules covering exceptional completion. Specified by: thenApplyAsync in interface CompletionStage&lt;T&gt; Type Parameters: U - the function's return type Parameters: fn - the function to use to compute the value of the returned CompletionStage executor - the executor to use </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> asynchronous execution Returns: the new CompletionStage</span></span></code> </pre><br><p> <code>Returns a new CompletionStage that... is executed using the supplied Executor</code> </p> <br><p>  Di sini kami ditawarkan untuk mengatur objek yang dibuat untuk diterbitkan dalam bentuk <code>Runnable</code> . </p><br><p> <code>... with this stage's result as the argument to the supplied function.</code> </p> <br><p>  Tapi ini sudah lebih menarik.  Fungsi yang diberikan kepada kami memiliki parameter, dan nilai parameter ini adalah nilai yang melengkapi <code>CompletionStage</code> saat ini.  Pada saat memanggil <code>thenApplyAsync</code> nilai ini mungkin tidak diketahui, jadi kami tidak dapat segera menjalankan tugas pada <code>Executor</code> .  Sebaliknya, kita harus bernegosiasi dengan <code>CompletionStage</code> saat ini, <br>  sehingga pada saat penyelesaiannya, ia mentransfer nilainya ke tugas.  Di antara banyak metode <code>CompletionStage</code> ada satu yang persis cocok untuk tujuan ini, <code>whenComplete</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CompletableFuture&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whenComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BiConsumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Throwable&gt; action)</span></span></span><span class="hljs-function"> Returns a new CompletionStage with the same result or exception as </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> stage, that executes the given action when </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> stage completes.</span></span></code> </pre> <br><p>  Artinya, di objek tugas yang baru dibuat, cukup untuk mengimplementasikan antarmuka <code>BiConsumer</code> untuk menerima argumen: </p><br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableFutureForApplyAsync</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableFuture</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BiConsumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Throwable</span></span></span><span class="hljs-class">&gt; </span></span>{ Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T,? extends U&gt; fn; Executor executor; T arg; Throwable throwable; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompletableFutureForApplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,? extends U&gt; fn, Executor executor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = fn; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.executor = executor; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-comment"><span class="hljs-comment">// implementation of BiConsumer interface public void accept(T argument, Throwable throwable) { if (throwable != null) { this.throwable = throwable; } else { this.arg = argument; } executor.execute(this); } @Override public void run() { if (throwable == null) { try { U result = fn.apply(arg); super.complete(result); } catch (Throwable e) { super.completeExceptionally(e); } } else { super.completeExceptionally(throwable); } } } public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor ) { CompletableFutureForApplyAsync&lt;T,U&gt; task = new CompletableFutureForApplyAsync&lt;&gt;(fn, executor); this.whenComplete(task); return task; } }</span></span></code> </pre> <br><p>  Contoh ini sangat penting untuk memahami sifat pemrograman asinkron, jadi sekali lagi kami daftar langkah-langkah utamanya: </p><br><p>  1) prosedur asinkron dibuat: </p><br><pre> <code class="java hljs"> CompletableFutureForApplyAsync&lt;T,U&gt; task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFutureForApplyAsync&lt;&gt;(fn, executor);</code> </pre> <br><p>  2) belum siap untuk dieksekusi, jadi kami meminta penyedia argumen yang hilang untuk meneruskan argumen ini kepada kami di masa mendatang, dengan memanggil metode yang kami kirimkan: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.whenComplete(task);</code> </pre> <br><p>  3) dalam metode ini kami tidak hanya menyimpan argumen yang diterima, tetapi juga menjalankan tugas untuk dieksekusi (lihat metode <code>accept</code> ()). </p><br><p>  4) pelaksanaan tugas dikurangi menjadi pemenuhan fungsi yang diberikan kepada kami dan menyimpan hasilnya. <br>  Hasil ini dapat seperti yang diminta oleh prosedur lain menggunakan metode <code>whenComplete</code> () yang diterapkan pada objek yang baru dibangun, sehingga kita dapat membangun rantai prosedur asinkron dengan panjang sewenang-wenang.  Tetapi rantai ini akan dipenuhi secara berurutan, tanpa paralelisme. </p><br><p>  Tetapi bagaimana cara menggambarkan diagram perhitungan yang lebih kompleks yang berisi cabang paralel? <br>  Untuk melakukan ini, gunakan metode <code>thenCombineAsync</code> . </p><br><p>  Jika dalam contoh sebelumnya kita memulai prosedur asinkron dengan satu argumen, maka dalam ini - dengan dua. </p><br><p>  Dalam hal ini, perhitungan kedua argumen dapat terjadi secara paralel. </p><br><pre> <code class="java hljs">ublic &lt;U,V&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;V&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thenCombineAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> U,? extends V&gt; fn, Executor executor)</span></span></span><span class="hljs-function"> Description copied from interface: CompletionStage Returns a new CompletionStage that, when </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> and the other given stage complete normally, is executed using the supplied executor, with the two results as arguments to the supplied function.</span></span></code> </pre> <br><p>  Di sini, semuanya sama seperti pada contoh sebelumnya dengan <code>thenApplyAsync</code> , tetapi parameter fungsi sudah memiliki dua argumen, dan <code>CompletionStage&lt;? extends U&gt; other</code> Parameter ditambahkan  <code>CompletionStage&lt;? extends U&gt; other</code> , yang merupakan penyedia asinkron argumen kedua. </p><br><p>  Bagaimana kita memastikan bahwa argumen kedua diproses? </p><br><p>  Yah, pertama, alih-alih satu variabel <code>T arg</code> jelaskan dua: <code>T arg1; U arg2;</code> <code>T arg1; U arg2;</code>  , alih-alih satu metode public <code>void accept(T argument, Throwable throwable)</code> menjelaskan dua - <code>accept1</code> dan <code>accept2</code> , <br>  masing-masing bekerja dengan argumennya sendiri. </p><br><p>  Pada saat yang sama, objek kami yang sedang dibangun tidak lagi mengimplementasikan <code>BiConsumer&lt;T,Throwable&gt;</code> dan kami tidak dapat lagi menulis kalimat kunci untuk menghubungkan node dari grafik perhitungan asinkron. </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.whenComplete(task);</code> </pre> <br><p>  Untungnya, objek antarmuka fungsional dapat diwakili oleh referensi ke suatu metode, tanpa menyimpulkannya dalam kelas yang terpisah: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.whenComplete(task::accept1); other.whenComplete(task::accept2);</code> </pre> <br><p>  Artinya, saat <code>this</code> objek <code>this</code> memasok argumen pertama, dan objek <code>other</code> yang kedua. </p><br><p>  Berikut ini hanya kode metode yang harus diubah sehingga mereka tidak memulai tugas segera setelah kedatangan argumen mereka, tetapi juga memeriksa tanda terima yang kedua: </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T argument, Throwable throwable)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (throwable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.throwable = throwable; executor.execute(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg1 = argument; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg2 != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { executor.execute(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } }</code> </pre> <br><p>  Metode accept2 dijelaskan dengan cara yang sama. </p><br><p>  Perhatikan bahwa: </p><br><ul><li>  metode disinkronkan (kami bekerja dengan data umum) </li><li>  dalam hal transmisi kesalahan, tunggu argumen kedua tidak diperlukan. </li><li>  memeriksa bahwa argumen datang dengan perbandingan dengan <strong><code>null</code></strong> bukan cara terbaik, mungkin Anda perlu menambahkan variabel Boolean untuk setiap argumen. </li></ul><br><p>  Dengan cara ini, Anda dapat membuat prosedur asinkron dari sejumlah besar argumen daripada dua, tetapi pemikiran itu segera muncul - dapatkah Anda masih membuat kelas terpisah untuk parameter, sehingga tidak menulis metode Anda sendiri untuk menerima setiap parameter, tetapi melakukannya dengan secara dinamis membuat parameter? </p><br><pre> <code class="java hljs"> Parameter&lt;Integer&gt; arg1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parameter&lt;&gt;(); Parameter&lt;Float&gt; arg2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parameter&lt;&gt;(); ... future1.whenComplete(arg1); future2.whenComplete(arg2);</code> </pre> <br><p>  Ya, Anda dapat membuat kelas seperti itu, tetapi lebih banyak di waktu berikutnya. </p><br><p>  Ringkasan singkat dari yang disebutkan di atas: </p><br><ul><li>  program asinkron adalah jaringan prosedur asinkron yang saling berhubungan, <br>  seperti halnya program multi-utas adalah jaringan utas eksekusi yang saling terhubung (utas). </li></ul><br><p>  Tetapi sarana arus komunikasi dan prosedur asinkron secara fundamental berbeda. </p><br><p>  Streaming dihubungkan menggunakan semaphores, memblokir antrian dan objek serupa lainnya, <br>  yang memblokir aliran penerima jika informasi belum tiba, tetapi aliran sudah mencoba untuk mengekstraknya menggunakan operasi berbasis tarik. </p><br><p>  Prosedur asinkron - penerima tidak perlu melakukan eksekusi sampai semua informasi yang mereka butuhkan siap. <br>  Mereka secara pasif menunggu sampai penyedia informasi sendiri melewatinya melalui operasi berbasis push. <br>  Karena hal ini, mereka tidak menghabiskan memori pada stack sambil menunggu, dan, oleh karena itu, mengambil memori jauh lebih sedikit daripada untaian eksekusi. </p><br><ul><li>  membangun jaringan prosedur asinkron direduksi menjadi membuat objek dan menghubungkannya bersama, lebih tepatnya, untuk menghubungkan sub-objek mereka - parameter: alamat parameter input penerima ditransmisikan ke parameter output penyedia informasi. </li></ul><br><p>  Himpunan metode <code>CompletableFuture</code> melakukan hal itu, dan pada prinsipnya, Anda dapat melakukannya tanpa metode ini dengan membuat objek secara eksplisit, seperti yang ditunjukkan dalam contoh di atas. <br>  Tetapi untuk ini perlu untuk memiliki kelas yang mirip dengan yang dijelaskan dalam contoh-contoh ini. <br>  Untuk beberapa alasan, pencipta <code>java.util.concurrent</code> memilih untuk tidak memberi pengguna akses ke kelas-kelas ini dan menyembunyikannya di kedalaman kode <code>CompletableFuture</code> . </p><br><p>  Mereka yang ingin memiliki representasi visual dari jaringan asinkron yang sedang dibuat dapat merekonstruksi kelas-kelas ini dengan melanjutkan contoh-contoh di atas.  Kode sumber untuk contoh <a href="">tersedia di Github</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418547/">https://habr.com/ru/post/id418547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418535/index.html">Mengapa Paspor Telegram - Tanpa Akhir ke Akhir</a></li>
<li><a href="../id418537/index.html">Saat membuang sampah, yang utama adalah jangan mulai melihatnya. Bagian 1?</a></li>
<li><a href="../id418539/index.html">Kerentanan Enkripsi dalam Berbagai Implementasi Bluetooth</a></li>
<li><a href="../id418543/index.html">Five Teams Menangkan Habitat Centennial Challenge 3D-Cetak Bagikan Hadiah $ 100.000</a></li>
<li><a href="../id418545/index.html">Menciptakan "kehidupan buatan" di komputer</a></li>
<li><a href="../id418549/index.html">Membuat bot untuk berpartisipasi dalam AI mini cup 2018 berdasarkan pada jaringan saraf berulang (bagian 3)</a></li>
<li><a href="../id418551/index.html">Berapa banyak yang harus diketahui seorang programmer matematika?</a></li>
<li><a href="../id418553/index.html">Kotlin + Bereaksi vs Javasript + Bereaksi</a></li>
<li><a href="../id418557/index.html">Perhitungan proses gelombang dalam saluran hidrolik menggunakan metode karakteristik</a></li>
<li><a href="../id418559/index.html">NL2API: Membuat Antarmuka Bahasa Alami untuk API Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>