<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå† üíáüèæ üì£ Insertion Sorts üòû ü§∞üèº üñïüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das allgemeine Wesen von Einf√ºgungssortierungen ist wie folgt: 



1. Iteriert √ºber die Elemente im unsortierten Teil des Arrays. 
2. Jedes Element wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Insertion Sorts</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415935/"><div style="text-align:center;"><img width="700" height="288" src="https://habrastorage.org/webt/ha/sk/1-/hask1-5bxk5ncdv33awxot2alcq.png"></div><br><br>  Das allgemeine Wesen von Einf√ºgungssortierungen ist wie folgt: <br><br><ol><li>  Iteriert √ºber die Elemente im unsortierten Teil des Arrays. </li><li> Jedes Element wird an der Stelle, an der es sein sollte, in den sortierten Teil des Arrays eingef√ºgt. </li></ol><br><a name="habracut"></a>  <s>Dies ist im Prinzip alles, was Sie √ºber das Sortieren nach Beilagen wissen m√ºssen.</s>  Das hei√üt, Einf√ºgungssortierungen teilen das Array immer in zwei Teile - sortiert und unsortiert.  Jedes Element wird aus dem unsortierten Teil abgerufen.  Da der andere Teil des Arrays sortiert ist, k√∂nnen Sie schnell Ihren Platz in diesem Array f√ºr dieses extrahierte Element finden.  Das Element wird bei Bedarf eingef√ºgt, wodurch der sortierte Teil des Arrays zunimmt und der unsortierte Teil abnimmt.  Das ist alles.  Alle Arten von Eins√§tzen arbeiten nach diesem Prinzip. <br><br>  Der schw√§chste Punkt bei diesem Ansatz ist das Einf√ºgen eines Elements in den sortierten Teil des Arrays.  Tats√§chlich ist es nicht einfach und welche Tricks Sie nicht ausf√ºhren m√ºssen, um diesen Schritt abzuschlie√üen. <br><br><h2>  Einfache Einf√ºgesortierung </h2><br><img width="684" height="95" src="https://habrastorage.org/webt/x4/nz/uu/x4nzuuiuosxzaj2y88ewj-vu9zo.gif"><br><br>  Wir gehen das Array von links nach rechts durch und verarbeiten jedes Element nacheinander.  Links vom n√§chsten Element vergr√∂√üern wir den sortierten Teil des Arrays, rechts im Verlauf des Prozesses verdunstet der unsortierte Teil langsam.  Im sortierten Teil des Arrays wird die Einf√ºgemarke f√ºr das n√§chste Element gesucht.  Das Element selbst wird an den Puffer gesendet, wodurch eine leere Zelle im Array angezeigt wird. Auf diese Weise k√∂nnen Sie die Elemente verschieben und die Einf√ºgemarke freigeben. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(data)): j = i - <span class="hljs-number"><span class="hljs-number">1</span></span> key = data[i] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> data[j] &gt; key <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: data[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[j] j -= <span class="hljs-number"><span class="hljs-number">1</span></span> data[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = key <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br>  Am Beispiel einfacher Einf√ºgungen sieht der Hauptvorteil der meisten (aber nicht aller!) Sortieren nach Einf√ºgungen demonstrativ aus, n√§mlich die sehr schnelle Verarbeitung fast geordneter Arrays: <br><br><img width="684" height="95" src="https://habrastorage.org/webt/qq/6e/ud/qq6eudehsux_10xmkh1b-x1sata.gif"><br><br>  In diesem Szenario wird wahrscheinlich sogar die primitivste Implementierung von Sortiereins√§tzen den superoptimierten Algorithmus f√ºr eine schnelle Sortierung √ºberholen, auch bei gro√üen Arrays. <br><br>  Dies wird durch die Hauptidee dieser Klasse erleichtert - die √úbertragung von Elementen vom unsortierten Teil des Arrays zum sortierten.  Bei unmittelbarer N√§he von Daten √§hnlicher Gr√∂√üe befindet sich die Einf√ºgemarke normalerweise nahe der Kante des sortierten Teils, sodass Sie mit dem geringsten Overhead einf√ºgen k√∂nnen. <br><br>  Es gibt nichts Besseres f√ºr die Handhabung fast geordneter Arrays als die Sortierung nach Einf√ºgungen.  Wenn Sie irgendwo auf Informationen sto√üen, dass die beste zeitliche Komplexit√§t beim Sortieren nach Einf√ºgungen <nobr>O ( <b>n</b> ) ist</nobr> , beziehen Sie sich h√∂chstwahrscheinlich auf Situationen mit fast geordneten Arrays. <br><br><h2>  Sortieren Sie nach einfachen bin√§ren Sucheinf√ºgungen </h2><br><img width="684" height="96" src="https://habrastorage.org/webt/ni/rs/nv/nirsnv-0nl-tntp5fecd21-4eiu.gif"><br><br>  Da der einzuf√ºgende Ort im sortierten Teil des Arrays gesucht wird, bietet sich die Idee an, eine bin√§re Suche zu verwenden.  Eine andere Sache ist, dass die Suche nach der Einf√ºgungsstelle f√ºr die zeitliche Komplexit√§t des Algorithmus nicht kritisch ist (der Hauptressourcenfresser ist die Phase des Einf√ºgens des Elements in die gefundene Position selbst), weshalb diese Optimierung wenig bewirkt. <br><br>  Und im Fall eines fast sortierten Arrays kann eine bin√§re Suche noch langsamer arbeiten, da sie in der Mitte des sortierten Abschnitts beginnt, der h√∂chstwahrscheinlich zu weit vom Einf√ºgepunkt entfernt ist (und weniger Schritte ben√∂tigt, um eine normale Suche von der Elementposition zum Einf√ºgepunkt durchzuf√ºhren, wenn die Daten vorliegen im gesamten Array bestellt). <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertion_binary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(data)): key = data[i] lo, hi = <span class="hljs-number"><span class="hljs-number">0</span></span>, i - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> lo &lt; hi: mid = lo + (hi - lo) // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key &lt; data[mid]: hi = mid <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: lo = mid + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(i, lo + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>): data[j] = data[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] data[lo] = key <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br>  Zur Verteidigung der bin√§ren Suche stelle ich fest, dass er das letzte Wort in der Wirksamkeit anderer Sortierungen durch Einf√ºgungen sagen kann.  Insbesondere dank ihm gehen Algorithmen wie Bibliothekarensortierung und Solit√§rsortierung auf die durchschnittliche Zeitkomplexit√§t <nobr>O ( <b>n</b> log <b>n</b> )</nobr> .  Aber sp√§ter dar√ºber. <br><br><h2>  Paarsortierung nach einfachen Eins√§tzen </h2><br>  Modifikation einfacher Beilagen, entwickelt in den geheimen Labors der Oracle Corporation.  Diese Sortierung ist Teil des JDK und Teil des Dual-Pivot Quicksort.  Es wird verwendet, um kleine Arrays (bis zu 47 Elemente) und kleine Bereiche gro√üer Arrays zu sortieren. <br><br><img width="684" height="95" src="https://habrastorage.org/webt/fi/iv/q6/fiivq621vdspxj9bxxq0pqe3jne.gif"><br><br>  Nicht ein, sondern zwei benachbarte Elemente werden gleichzeitig an den Puffer gesendet.  Zuerst wird das gr√∂√üere Element des Paares eingef√ºgt, und unmittelbar danach wird die einfache Einf√ºgemethode auf das kleinere Element des Paares angewendet. <br><br>  Was gibt es?  Einsparungen bei der Bearbeitung eines kleineren Artikels aus einem Paar.  F√ºr ihn werden die Suche nach der Einf√ºgemarke und die Einf√ºgung selbst nur f√ºr den sortierten Teil des Arrays ausgef√ºhrt, der nicht den sortierten Bereich enth√§lt, der zum Verarbeiten eines gr√∂√üeren Elements aus dem Paar verwendet wird.  Dies wird m√∂glich, weil die gr√∂√üeren und kleineren Elemente unmittelbar nacheinander in einem Durchgang der √§u√üeren Schleife verarbeitet werden. <br><br>  Dies hat keinen Einfluss auf die durchschnittliche Zeitkomplexit√§t (sie bleibt immer noch gleich <nobr>O ( <b>n <sup>2</sup></b> ))</nobr> . Gepaarte Inserts arbeiten jedoch etwas schneller als √ºbliche. <br><br>  Ich illustriere die Algorithmen in Python, aber hier gebe ich die Originalquelle (aus Gr√ºnden der Lesbarkeit ge√§ndert) in Java an: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = left; ++left &lt;= right; k = ++left) { <span class="hljs-comment"><span class="hljs-comment">//   ÃÅ  //     int a1 = a[k], a2 = a[left]; if (a1 &lt; a2) { a2 = a1; a1 = a[left]; } //     while (a1 &lt; a[--k]) { a[k + 2] = a[k]; } a[++k + 1] = a1; //     while (a2 &lt; a[--k]) { a[k + 1] = a[k]; } a[k + 1] = a2; } // ,       //       int last = a[right]; while (last &lt; a[--right]) { a[right + 1] = a[right]; } a[right + 1] = last;</span></span></code> </pre> <br><br><h2>  Shell Sort </h2><br><img width="684" height="95" src="https://habrastorage.org/webt/ig/rb/aa/igrbaajcuoxuj4q-l-38x0qsoq4.gif"><br><br>  Dieser Algorithmus hat einen sehr witzigen Ansatz bei der Bestimmung, welcher Teil des Arrays als sortiert betrachtet wird.  In einfachen Einf√ºgungen ist alles einfach: Vom aktuellen Element ist alles links bereits sortiert, alles rechts ist noch nicht sortiert.  Im Gegensatz zu einfachen Einf√ºgungen versucht die Shell-Sortierung nicht sofort, einen streng sortierten Teil des Arrays links von einem Element zu bilden.  Es erstellt einen <em>fast sortierten</em> Teil des Arrays links vom Element und erledigt dies schnell genug. <br><br>  Die Shell-Sortierung wirft das aktuelle Element in den Puffer und vergleicht es mit der linken Seite des Arrays.  Wenn links gr√∂√üere Elemente gefunden werden, werden diese nach rechts verschoben, sodass Platz zum Einf√ºgen vorhanden ist.  Gleichzeitig nimmt es aber nicht den gesamten linken Teil, sondern nur eine bestimmte Gruppe von Elementen, wobei die Elemente um einen bestimmten Abstand voneinander beabstandet sind.  Mit einem solchen System k√∂nnen Sie Elemente schnell in ungef√§hr den Bereich des Arrays einf√ºgen, in dem sie sich befinden sollten. <br><br>  Mit jeder Iteration der Hauptschleife nimmt dieser Abstand allm√§hlich ab, und wenn er gleich eins wird, verwandelt sich die Shell-Sortierung in diesem Moment in eine klassische Sortierung mit einfachen Einf√ºgungen, die f√ºr die Verarbeitung eines fast sortierten Arrays verwendet wurden.  Eine fast sortierte Array-Sortierung f√ºgt schnell in vollst√§ndig sortierte Konvertierungen ein. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> inc = len(data) // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> inc: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, el <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(data): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &gt;= inc <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[i - inc] &gt; el: data[i] = data[i - inc] i -= inc data[i] = el inc = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> inc == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> int(inc * <span class="hljs-number"><span class="hljs-number">5.0</span></span> / <span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br>  Die Kammsortierung nach einem √§hnlichen Prinzip verbessert die Blasensortierung, sodass die zeitliche Komplexit√§t des Algorithmus mit <nobr>O ( <b>n <sup>2</sup></b> )</nobr> bis zu <nobr>O ( <b>n</b> log <b>n</b> )</nobr> springt.  Leider schafft es Shell nicht, dieses Kunstst√ºck zu wiederholen - die beste Zeitkomplexit√§t erreicht <nobr>O ( <b>n</b> log <sup>2</sup> <b>n</b> )</nobr> . <br><br>  Es wurden mehrere Habrastati √ºber das Sortieren von Shell geschrieben, damit wir nicht mit Informationen √ºberladen werden und weitermachen. <br><br><h2>  Baumsortierung </h2><br><img width="570" height="277" src="https://habrastorage.org/webt/uo/6e/d8/uo6ed8lcpyvdpg9fzfwsye2pnuu.gif"><br><br>  Das Sortieren mit einem Baum aufgrund zus√§tzlichen Speichers l√∂st schnell das Problem, dem sortierten Teil des Arrays ein weiteres Element hinzuzuf√ºgen.  Dar√ºber hinaus fungiert der Bin√§rbaum als sortierter Teil des Arrays.  Ein Baum wird buchst√§blich im laufenden Betrieb gebildet, wenn Elemente durchlaufen werden. <br><br>  Das Element wird zuerst mit der Wurzel und dann mit mehr verschachtelten Knoten nach dem Prinzip verglichen: Wenn das Element kleiner als der Knoten ist, gehen wir den linken Zweig hinunter, wenn nicht weniger, dann den rechten.  Ein nach einer solchen Regel konstruierter Baum kann dann leicht umgangen werden, um von Knoten mit niedrigeren Werten zu Knoten mit gr√∂√üeren Werten zu gelangen (und somit alle Elemente in aufsteigender Reihenfolge zu erhalten). <br><br>  Der Hauptfehler beim Sortieren nach Einf√ºgungen (die Kosten f√ºr das Einf√ºgen eines Elements an seiner Stelle im sortierten Teil des Arrays) ist hier gel√∂st. Die Konstruktion geht recht schnell voran.  In jedem Fall ist es zum Freigeben der Einf√ºgemarke nicht erforderlich, die Karawanen der Elemente wie in den vorherigen Algorithmen langsam zu bewegen.  Es scheint, dass hier die besten Sortiereins√§tze sind.  Aber es gibt ein Problem. <br><br>  Wenn Sie einen sch√∂nen symmetrischen Weihnachtsbaum (den sogenannten perfekt ausbalancierten Baum) wie in der Animation drei Abs√§tze oben erhalten, erfolgt das Einf√ºgen schnell, da der Baum in diesem Fall die niedrigstm√∂glichen Verschachtelungsebenen aufweist.  Eine ausgeglichene (oder zumindest nahe daran liegende) Struktur aus einem zuf√§lligen Array wird jedoch selten erhalten.  Und der Baum wird h√∂chstwahrscheinlich unvollkommen und unausgeglichen sein - mit Verzerrungen, einem verschmutzten Horizont und einer √ºberm√§√üigen Anzahl von Ebenen. <br><br>  <em>Ein zuf√§lliges Array mit Werten von 1 bis 10. Elemente in dieser Reihenfolge erzeugen einen unausgeglichenen Bin√§rbaum:</em> <br><br><img width="564" height="384" src="https://habrastorage.org/webt/io/mj/25/iomj25xs6mtppplwt02gdgmbsiq.png"><br><br>  Ein Baum reicht nicht zum Bauen, er muss noch umgangen werden.  Je mehr Ungleichgewicht - desto st√§rker rutscht der Algorithmus f√ºr die Baumdurchquerung.  Hier kann, wie die Sterne sagen, ein zuf√§lliges Array sowohl einen h√§sslichen Haken (was wahrscheinlicher ist) als auch ein baumartiges Fraktal erzeugen. <br><br>  <em>Die Werte der Elemente sind gleich, aber die Reihenfolge ist unterschiedlich.</em>  <em>Ein ausgeglichener Bin√§rbaum wird generiert:</em> <br><br><img height="311" src="https://habrastorage.org/webt/sc/k8/_y/sck8_y-fbutnw-ulr6bg1rg4nbg.png"><br><img align="left" width="218" height="90" src="https://habrastorage.org/webt/ah/eu/wi/aheuwi2kiu2l361frutx_qpvawq.png"><br clear="right">  <em>Auf sch√∂ner Sakura</em> <em><br></em>  <em>Nicht genug Bl√ºtenblatt:</em> <em><br></em>  <em>Ein bin√§rer Baum von Dutzenden.</em> <br><br>  Das Problem der unausgeglichenen B√§ume wird durch Inversionssortierung gel√∂st, bei der eine spezielle Art von bin√§rem Suchbaum verwendet wird - der Spreizbaum.  Dies ist ein wunderbarer Transformatorbaum, der nach jeder Operation in einem ausgeglichenen Zustand wiederhergestellt wird.  Dar√ºber wird ein separater Artikel sein.  Bis dahin werde ich Python-Implementierungen sowohl f√ºr die Baumsortierung als auch f√ºr die Splay-Sortierung vorbereiten. <br><br>  Nun, wir haben kurz die beliebtesten Sortiereins√§tze durchgesehen.  Einfache Einf√ºgungen, Shell und Bin√§rbaum, die wir alle aus der Schule kennen.  Betrachten Sie nun andere Vertreter dieser Klasse, die nicht so bekannt sind. <br><br>  <b>Wiki / Wiki</b> - <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einf√ºgen</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Shell</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Shell</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Baum</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Baum</a></nobr> <br><br><h3>  Serienartikel: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Excel-Anwendung AlgoLab.xlsm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sorte austauschen</a> </li><li>  <b>Insertion Sorts</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothekar Sort</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solitaire Sort</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sortieren Sie "Turm von Hanoi"</a> </li><li>  Junge Tischsortierung </li><li>  Sortierung umkehren </li><li>  Sortiervergleich einf√ºgen </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nach Auswahl sortieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sortierungen zusammenf√ºhren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nach Verteilung sortieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hybridsortierung</a> </li></ul><br>  Wer AlgoLab verwendet - Ich empfehle, die Datei zu aktualisieren.  Ich habe dieser Anwendung einfache bin√§re Sucheinf√ºgungen und gepaarte Einf√ºgungen hinzugef√ºgt.  Er hat auch die Visualisierung f√ºr Shell komplett neu geschrieben (in der vorherigen Version gab es nichts zu verstehen) und dem √ºbergeordneten Zweig beim Einf√ºgen eines Elements in den Bin√§rbaum Hervorhebungen hinzugef√ºgt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415935/">https://habr.com/ru/post/de415935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415923/index.html">Ist die Einheit langsam? Achtung LINQ</a></li>
<li><a href="../de415925/index.html">MasterCard patentierte anonyme Blockchain-Technologie</a></li>
<li><a href="../de415927/index.html">Industrielampe Breeze 50</a></li>
<li><a href="../de415929/index.html">Optimierung der Architektur der k√ºnstlichen Intelligenz: Das Rennen beginnt</a></li>
<li><a href="../de415933/index.html">So erstellen Sie eine IIoT-Architektur zum Selbermachen</a></li>
<li><a href="../de415937/index.html">Die japanische Privatrakete MOMO-2 explodierte auf der Startrampe</a></li>
<li><a href="../de415939/index.html">Verteilte Grafikverarbeitung mit Spark GraphX</a></li>
<li><a href="../de415941/index.html">Wie wir versucht haben, Barcodes herauszufinden und nichts verstanden haben</a></li>
<li><a href="../de415943/index.html">"Spieleentwicklung und Unterhaltungstheorie": Wichtige Punkte aus Raff Costers Buch</a></li>
<li><a href="../de415945/index.html">Neue chinesische SPS mit Aliexpress: Wecon LX3VP / LX3VE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>