<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„Ä∞Ô∏è üëû üòÆ So gehen Sie schneller mit Fehlern in der JVM um üë®üèΩ‚Äç‚öñÔ∏è üë®üèø‚Äçüî¨ üëèüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt verschiedene M√∂glichkeiten, Fehler in Programmiersprachen zu behandeln: 


- Standardausnahmen f√ºr viele Sprachen (Java, Scala und andere JVMs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So gehen Sie schneller mit Fehlern in der JVM um</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431586/"><p>  Es gibt verschiedene M√∂glichkeiten, Fehler in Programmiersprachen zu behandeln: </p><br><ul><li>  Standardausnahmen f√ºr viele Sprachen (Java, Scala und andere JVMs, Python und viele andere) </li><li>  Statuscodes oder Flags (Go, Bash) </li><li>  verschiedene algebraische Datenstrukturen, deren Werte sowohl erfolgreiche Ergebnisse als auch Fehlerbeschreibungen sein k√∂nnen (Scala, Haskell und andere funktionale Sprachen) </li></ul><br><p>  Ausnahmen werden sehr h√§ufig verwendet, andererseits werden sie oft als langsam bezeichnet.  Gegner eines funktionalen Ansatzes appellieren jedoch h√§ufig an die Leistung. </p><br><p>  Vor kurzem habe ich mit Scala gearbeitet, wo ich sowohl Ausnahmen als auch verschiedene Datentypen f√ºr die Fehlerbehandlung gleicherma√üen verwenden kann. Daher frage ich mich, welcher Ansatz bequemer und schneller sein wird. </p><br><p> Wir werden die Verwendung von Codes und Flags sofort verwerfen, da dieser Ansatz in den JVM-Sprachen nicht akzeptiert wird und meiner Meinung nach zu fehleranf√§llig ist (das Wortspiel tut mir leid).  Daher werden wir Ausnahmen und verschiedene Arten von ADT vergleichen.  Dar√ºber hinaus kann das ADT als Verwendung von Fehlercodes in einem funktionalen Stil betrachtet werden. </p><br><p>  <strong>UPDATE</strong> : Ausnahmen ohne Stack-Traces werden zum Vergleich hinzugef√ºgt </p><a name="habracut"></a><br><h3 id="konkursanty">  Teilnehmer </h3><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen mehr √ºber algebraische Datentypen</b> <div class="spoiler_text"><p>  F√ºr diejenigen, die mit ADT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ADT</a> ) nicht allzu vertraut sind - ein algebraischer Typ besteht aus mehreren m√∂glichen Werten, von denen jeder ein zusammengesetzter Wert sein kann (Struktur, Datensatz). </p><br><p> Ein Beispiel ist der Typ <code>Option[T] = Some(value: T) | None</code>  <code>Option[T] = Some(value: T) | None</code> , die anstelle von Nullen verwendet wird: Ein Wert dieses Typs kann entweder <code>Some(t)</code> wenn es einen Wert gibt, oder <code>None</code> wenn dies nicht der Fall ist. </p><br><p>  Ein anderes Beispiel w√§re <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> , der das Ergebnis einer Berechnung beschreibt, die erfolgreich oder mit einem Fehler abgeschlossen werden konnte. </p><br><p>  Also unsere Teilnehmer: </p></div></div><br><ul><li>  <em>Gute</em> alte Ausnahmen </li><li>  Ausnahmen ohne Stack-Trace, da das F√ºllen eines Stack-Trace sehr langsam ist </li><li> <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> - dieselben Ausnahmen, jedoch in einem funktionalen Wrapper </li><li> <code>Either[String, T] = Left(error: String) | Right(value: T)</code>  <code>Either[String, T] = Left(error: String) | Right(value: T)</code> - Ein Typ, der entweder das Ergebnis oder eine Beschreibung des Fehlers enth√§lt </li><li> <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code>  <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code> - Ein Typ aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Cats-Bibliothek</a> , der im Fehlerfall mehrere Meldungen zu verschiedenen Fehlern enthalten kann (dort wird nicht ganz <code>List</code> verwendet, aber das spielt keine Rolle). </li></ul><br><p>  <strong>HINWEIS</strong> Im Wesentlichen werden Ausnahmen mit der Stapelverfolgung ohne und ADT verglichen, es werden jedoch mehrere Typen ausgew√§hlt, da Scala keinen einzigen Ansatz hat und es interessant ist, mehrere zu vergleichen. </p><br><p>  Zus√§tzlich zu Ausnahmen werden Zeichenfolgen verwendet, um Fehler zu beschreiben, aber mit dem gleichen Erfolg in einer realen Situation w√ºrden verschiedene Klassen verwendet ( <code>Either[Failure, T]</code> ). </p><br><h3 id="problema">  Das Problem </h3><br><p>  Zum Testen der Fehlerbehandlung nehmen wir das Problem der Analyse und Datenvalidierung: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, isMale: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] }</code> </pre> <br><p>  d.h.  Mit Rohdaten <code>Map[String, String]</code> m√ºssen Sie <code>Person</code> oder einen Fehler erhalten, wenn die Daten ung√ºltig sind. </p><br><h4 id="throw">  Werfen </h4><br><p>  Eine L√∂sung <em>f√ºr die Stirn</em> mit Ausnahmen (im Folgenden werde ich nur die <code>person</code> , Sie k√∂nnen den vollst√§ndigen Code auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github sehen</a> ): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Throwparser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Person</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = string(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age = integer(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"age"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale = boolean(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale) }</code> </pre> <br><p>  Hier validieren <code>string</code> , <code>integer</code> und <code>boolean</code> das Vorhandensein und Format einfacher Typen und f√ºhren die Konvertierung durch. <br>  Im Allgemeinen ist es ganz einfach und klar. </p><br><h4 id="thrownst-no-stack-trace">  ThrowNST (No Stack Trace) </h4><br><p>  Der Code ist der gleiche wie im vorherigen Fall, jedoch werden Ausnahmen nach M√∂glichkeit ohne Stack-Trace verwendet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ThrowNSTParser.scala</a> </p><br><h4 id="try">  Versuchen Sie es </h4><br><p>  Die L√∂sung f√§ngt Ausnahmen fr√ºher ab und erm√∂glicht das Kombinieren der Ergebnisse √ºber <code>for</code> (nicht zu verwechseln mit Schleifen in anderen Sprachen): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TryParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  etwas ungew√∂hnlicher f√ºr ein zerbrechliches Auge, aber aufgrund der Verwendung von <code>for</code> ist es der Version mit Ausnahmen sehr √§hnlich. Au√üerdem erfolgt die Validierung des Vorhandenseins eines Feldes und das Parsen des gew√ºnschten Typs separat ( <code>flatMap</code> kann hier ab <code>and then</code> zu gelesen werden). </p><br><h4 id="either">  Entweder </h4><br><p>  Hier ist der Typ "Beide" hinter dem Alias ‚Äã‚Äã" <code>Result</code> verborgen, da der Fehlertyp behoben ist: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EntwederParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  Da der Standard <code>Either</code> wie <code>Try</code> in Scala eine Monade bildet, wurde der Code genau gleich ausgegeben. Der Unterschied besteht darin, dass die Zeichenfolge hier als Fehler angezeigt wird und die Ausnahmen nur minimal verwendet werden (nur um Fehler beim Parsen einer Zahl zu behandeln). </p><br><h4 id="validated">  Validiert </h4><br><p>  Hier wird die Cats-Bibliothek verwendet, um nicht das erste zu erhalten, was passiert ist, sondern so viel wie m√∂glich (wenn beispielsweise mehrere Felder nicht g√ºltig waren, enth√§lt das Ergebnis Analysefehler f√ºr alle diese Felder). <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ValidatedParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) .ensure(one(<span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>))(_.nonEmpty) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) .andThen(integer) .ensure(one(<span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>))(_ &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Boolean</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) .andThen(boolean) (name, age, isMale).mapN(<span class="hljs-type"><span class="hljs-type">Person</span></span>) }</code> </pre> <br><p>  Dieser Code ist mit Ausnahmen der Originalversion bereits weniger √§hnlich, aber die √úberpr√ºfung zus√§tzlicher Einschr√§nkungen ist nicht von der Analyse von Feldern getrennt, und es werden immer noch mehrere Fehler anstelle von einem angezeigt. Es lohnt sich! </p><br><h3 id="testirovanie">  Testen </h3><br><p>  Zum Testen wurde ein Datensatz mit einem unterschiedlichen Prozentsatz an Fehlern generiert und auf jede der Arten analysiert. </p><br><p>  Ergebnis bei allen Prozents√§tzen der Fehler: <br><img src="https://habrastorage.org/webt/hj/la/-8/hjla-8vnb-pa7jgyiwghmhwwhxk.png"></p><br><p>  Genauer gesagt, bei einem geringen Prozentsatz an Fehlern (die Zeit ist hier anders, da <em>eine</em> gr√∂√üere Stichprobe verwendet wurde): <br><img src="https://habrastorage.org/webt/4s/8r/ca/4s8rcaqkm4gke5o_2fim1dxx9y0.png"></p><br><p>  Wenn ein Teil der Fehler immer noch eine Ausnahme bei der Stapelverfolgung darstellt (in unserem Fall ist der Fehler beim Parsen der Nummer eine Ausnahme, die wir nicht kontrollieren), wird sich die Leistung der "schnellen" Fehlerbehandlungsmethoden nat√ºrlich erheblich verschlechtern.  <code>Validated</code> besonders betroffen, da es alle Fehler sammelt und daher mehr als andere eine langsame Ausnahme erh√§lt: <br><img src="https://habrastorage.org/webt/gy/x-/ve/gyx-veyf2w3kexn4oa56vrbfuvw.png"></p><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p>  Wie das Experiment gezeigt hat, sind Ausnahmen mit Stapelspuren sehr langsam (100% Fehler sind der Unterschied zwischen <code>Throw</code> und <code>Either</code> mehr als 50 Mal!). Und wenn es praktisch keine Ausnahmen gibt, hat die Verwendung von ADT seinen Preis.  Die Verwendung von Ausnahmen ohne Stack-Traces ist jedoch genauso schnell (und mit einem geringen Prozentsatz an Fehlern schneller) wie ADT. Wenn solche Ausnahmen jedoch die Grenzen derselben Validierung √ºberschreiten, ist die Verfolgung ihrer Quelle nicht einfach. </p><br><p>  Wenn die Wahrscheinlichkeit einer Ausnahme mehr als 1% betr√§gt, funktionieren Ausnahmen ohne Stack-Traces insgesamt am schnellsten. <code>Validated</code> oder regelm√§√üig. <code>Either</code> fast genauso schnell.  Bei einer gro√üen Anzahl von Fehlern kann <code>Either</code> nur aufgrund der ausfallsicheren Semantik etwas schneller als <code>Validated</code> . </p><br><p>  Die Verwendung von ADT zur Fehlerbehandlung bietet einen weiteren Vorteil gegen√ºber Ausnahmen: Die M√∂glichkeit eines Fehlers ist mit dem Typ selbst verbunden und es ist schwieriger zu √ºbersehen, als wenn <code>Option</code> anstelle von Nullen verwendet wird. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431586/">https://habr.com/ru/post/de431586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431572/index.html">So schreiben Sie funktionale Anforderungen</a></li>
<li><a href="../de431574/index.html">Neuro-Schnittstellen heute</a></li>
<li><a href="../de431576/index.html">Hintergrund: Kepler Space Observatory - Eisen, Kommunikation mit der Erde, Software und Ergebnisse</a></li>
<li><a href="../de431582/index.html">Geschichte des Schutzes personenbezogener Daten: Wie kam es zur DSGVO?</a></li>
<li><a href="../de431584/index.html">Platz und Test: mischen, aber nicht sch√ºtteln</a></li>
<li><a href="../de431588/index.html">Selbstst√§ndiges Gesetz. Informationen zur Pr√ºfung</a></li>
<li><a href="../de431590/index.html">Die Modernisierung veralteter britischer Windparks wird die Energieerzeugung um 171% steigern</a></li>
<li><a href="../de431596/index.html">Testen der Veeam-Sicherungs- und Replikationslast</a></li>
<li><a href="../de431598/index.html">Wir bringen eine √∂ffentliche virtuelle QEMU-Maschine ohne Netzwerkkarte ins Internet und versuchen, sie abzubauen</a></li>
<li><a href="../de431600/index.html">Erh√∂hen Sie IDS / NMS: Mikrotik und Suricata mit einem Webinterface</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>