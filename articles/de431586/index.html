<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>〰️ 👞 😮 So gehen Sie schneller mit Fehlern in der JVM um 👨🏽‍⚖️ 👨🏿‍🔬 👏🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt verschiedene Möglichkeiten, Fehler in Programmiersprachen zu behandeln: 


- Standardausnahmen für viele Sprachen (Java, Scala und andere JVMs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So gehen Sie schneller mit Fehlern in der JVM um</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431586/"><p>  Es gibt verschiedene Möglichkeiten, Fehler in Programmiersprachen zu behandeln: </p><br><ul><li>  Standardausnahmen für viele Sprachen (Java, Scala und andere JVMs, Python und viele andere) </li><li>  Statuscodes oder Flags (Go, Bash) </li><li>  verschiedene algebraische Datenstrukturen, deren Werte sowohl erfolgreiche Ergebnisse als auch Fehlerbeschreibungen sein können (Scala, Haskell und andere funktionale Sprachen) </li></ul><br><p>  Ausnahmen werden sehr häufig verwendet, andererseits werden sie oft als langsam bezeichnet.  Gegner eines funktionalen Ansatzes appellieren jedoch häufig an die Leistung. </p><br><p>  Vor kurzem habe ich mit Scala gearbeitet, wo ich sowohl Ausnahmen als auch verschiedene Datentypen für die Fehlerbehandlung gleichermaßen verwenden kann. Daher frage ich mich, welcher Ansatz bequemer und schneller sein wird. </p><br><p> Wir werden die Verwendung von Codes und Flags sofort verwerfen, da dieser Ansatz in den JVM-Sprachen nicht akzeptiert wird und meiner Meinung nach zu fehleranfällig ist (das Wortspiel tut mir leid).  Daher werden wir Ausnahmen und verschiedene Arten von ADT vergleichen.  Darüber hinaus kann das ADT als Verwendung von Fehlercodes in einem funktionalen Stil betrachtet werden. </p><br><p>  <strong>UPDATE</strong> : Ausnahmen ohne Stack-Traces werden zum Vergleich hinzugefügt </p><a name="habracut"></a><br><h3 id="konkursanty">  Teilnehmer </h3><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen mehr über algebraische Datentypen</b> <div class="spoiler_text"><p>  Für diejenigen, die mit ADT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ADT</a> ) nicht allzu vertraut sind - ein algebraischer Typ besteht aus mehreren möglichen Werten, von denen jeder ein zusammengesetzter Wert sein kann (Struktur, Datensatz). </p><br><p> Ein Beispiel ist der Typ <code>Option[T] = Some(value: T) | None</code>  <code>Option[T] = Some(value: T) | None</code> , die anstelle von Nullen verwendet wird: Ein Wert dieses Typs kann entweder <code>Some(t)</code> wenn es einen Wert gibt, oder <code>None</code> wenn dies nicht der Fall ist. </p><br><p>  Ein anderes Beispiel wäre <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> , der das Ergebnis einer Berechnung beschreibt, die erfolgreich oder mit einem Fehler abgeschlossen werden konnte. </p><br><p>  Also unsere Teilnehmer: </p></div></div><br><ul><li>  <em>Gute</em> alte Ausnahmen </li><li>  Ausnahmen ohne Stack-Trace, da das Füllen eines Stack-Trace sehr langsam ist </li><li> <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> - dieselben Ausnahmen, jedoch in einem funktionalen Wrapper </li><li> <code>Either[String, T] = Left(error: String) | Right(value: T)</code>  <code>Either[String, T] = Left(error: String) | Right(value: T)</code> - Ein Typ, der entweder das Ergebnis oder eine Beschreibung des Fehlers enthält </li><li> <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code>  <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code> - Ein Typ aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Cats-Bibliothek</a> , der im Fehlerfall mehrere Meldungen zu verschiedenen Fehlern enthalten kann (dort wird nicht ganz <code>List</code> verwendet, aber das spielt keine Rolle). </li></ul><br><p>  <strong>HINWEIS</strong> Im Wesentlichen werden Ausnahmen mit der Stapelverfolgung ohne und ADT verglichen, es werden jedoch mehrere Typen ausgewählt, da Scala keinen einzigen Ansatz hat und es interessant ist, mehrere zu vergleichen. </p><br><p>  Zusätzlich zu Ausnahmen werden Zeichenfolgen verwendet, um Fehler zu beschreiben, aber mit dem gleichen Erfolg in einer realen Situation würden verschiedene Klassen verwendet ( <code>Either[Failure, T]</code> ). </p><br><h3 id="problema">  Das Problem </h3><br><p>  Zum Testen der Fehlerbehandlung nehmen wir das Problem der Analyse und Datenvalidierung: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, isMale: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] }</code> </pre> <br><p>  d.h.  Mit Rohdaten <code>Map[String, String]</code> müssen Sie <code>Person</code> oder einen Fehler erhalten, wenn die Daten ungültig sind. </p><br><h4 id="throw">  Werfen </h4><br><p>  Eine Lösung <em>für die Stirn</em> mit Ausnahmen (im Folgenden werde ich nur die <code>person</code> , Sie können den vollständigen Code auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github sehen</a> ): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Throwparser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Person</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = string(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age = integer(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"age"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale = boolean(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale) }</code> </pre> <br><p>  Hier validieren <code>string</code> , <code>integer</code> und <code>boolean</code> das Vorhandensein und Format einfacher Typen und führen die Konvertierung durch. <br>  Im Allgemeinen ist es ganz einfach und klar. </p><br><h4 id="thrownst-no-stack-trace">  ThrowNST (No Stack Trace) </h4><br><p>  Der Code ist der gleiche wie im vorherigen Fall, jedoch werden Ausnahmen nach Möglichkeit ohne Stack-Trace verwendet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ThrowNSTParser.scala</a> </p><br><h4 id="try">  Versuchen Sie es </h4><br><p>  Die Lösung fängt Ausnahmen früher ab und ermöglicht das Kombinieren der Ergebnisse über <code>for</code> (nicht zu verwechseln mit Schleifen in anderen Sprachen): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TryParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  etwas ungewöhnlicher für ein zerbrechliches Auge, aber aufgrund der Verwendung von <code>for</code> ist es der Version mit Ausnahmen sehr ähnlich. Außerdem erfolgt die Validierung des Vorhandenseins eines Feldes und das Parsen des gewünschten Typs separat ( <code>flatMap</code> kann hier ab <code>and then</code> zu gelesen werden). </p><br><h4 id="either">  Entweder </h4><br><p>  Hier ist der Typ "Beide" hinter dem Alias ​​" <code>Result</code> verborgen, da der Fehlertyp behoben ist: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EntwederParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  Da der Standard <code>Either</code> wie <code>Try</code> in Scala eine Monade bildet, wurde der Code genau gleich ausgegeben. Der Unterschied besteht darin, dass die Zeichenfolge hier als Fehler angezeigt wird und die Ausnahmen nur minimal verwendet werden (nur um Fehler beim Parsen einer Zahl zu behandeln). </p><br><h4 id="validated">  Validiert </h4><br><p>  Hier wird die Cats-Bibliothek verwendet, um nicht das erste zu erhalten, was passiert ist, sondern so viel wie möglich (wenn beispielsweise mehrere Felder nicht gültig waren, enthält das Ergebnis Analysefehler für alle diese Felder). <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ValidatedParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) .ensure(one(<span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>))(_.nonEmpty) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) .andThen(integer) .ensure(one(<span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>))(_ &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Boolean</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) .andThen(boolean) (name, age, isMale).mapN(<span class="hljs-type"><span class="hljs-type">Person</span></span>) }</code> </pre> <br><p>  Dieser Code ist mit Ausnahmen der Originalversion bereits weniger ähnlich, aber die Überprüfung zusätzlicher Einschränkungen ist nicht von der Analyse von Feldern getrennt, und es werden immer noch mehrere Fehler anstelle von einem angezeigt. Es lohnt sich! </p><br><h3 id="testirovanie">  Testen </h3><br><p>  Zum Testen wurde ein Datensatz mit einem unterschiedlichen Prozentsatz an Fehlern generiert und auf jede der Arten analysiert. </p><br><p>  Ergebnis bei allen Prozentsätzen der Fehler: <br><img src="https://habrastorage.org/webt/hj/la/-8/hjla-8vnb-pa7jgyiwghmhwwhxk.png"></p><br><p>  Genauer gesagt, bei einem geringen Prozentsatz an Fehlern (die Zeit ist hier anders, da <em>eine</em> größere Stichprobe verwendet wurde): <br><img src="https://habrastorage.org/webt/4s/8r/ca/4s8rcaqkm4gke5o_2fim1dxx9y0.png"></p><br><p>  Wenn ein Teil der Fehler immer noch eine Ausnahme bei der Stapelverfolgung darstellt (in unserem Fall ist der Fehler beim Parsen der Nummer eine Ausnahme, die wir nicht kontrollieren), wird sich die Leistung der "schnellen" Fehlerbehandlungsmethoden natürlich erheblich verschlechtern.  <code>Validated</code> besonders betroffen, da es alle Fehler sammelt und daher mehr als andere eine langsame Ausnahme erhält: <br><img src="https://habrastorage.org/webt/gy/x-/ve/gyx-veyf2w3kexn4oa56vrbfuvw.png"></p><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p>  Wie das Experiment gezeigt hat, sind Ausnahmen mit Stapelspuren sehr langsam (100% Fehler sind der Unterschied zwischen <code>Throw</code> und <code>Either</code> mehr als 50 Mal!). Und wenn es praktisch keine Ausnahmen gibt, hat die Verwendung von ADT seinen Preis.  Die Verwendung von Ausnahmen ohne Stack-Traces ist jedoch genauso schnell (und mit einem geringen Prozentsatz an Fehlern schneller) wie ADT. Wenn solche Ausnahmen jedoch die Grenzen derselben Validierung überschreiten, ist die Verfolgung ihrer Quelle nicht einfach. </p><br><p>  Wenn die Wahrscheinlichkeit einer Ausnahme mehr als 1% beträgt, funktionieren Ausnahmen ohne Stack-Traces insgesamt am schnellsten. <code>Validated</code> oder regelmäßig. <code>Either</code> fast genauso schnell.  Bei einer großen Anzahl von Fehlern kann <code>Either</code> nur aufgrund der ausfallsicheren Semantik etwas schneller als <code>Validated</code> . </p><br><p>  Die Verwendung von ADT zur Fehlerbehandlung bietet einen weiteren Vorteil gegenüber Ausnahmen: Die Möglichkeit eines Fehlers ist mit dem Typ selbst verbunden und es ist schwieriger zu übersehen, als wenn <code>Option</code> anstelle von Nullen verwendet wird. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431586/">https://habr.com/ru/post/de431586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431572/index.html">So schreiben Sie funktionale Anforderungen</a></li>
<li><a href="../de431574/index.html">Neuro-Schnittstellen heute</a></li>
<li><a href="../de431576/index.html">Hintergrund: Kepler Space Observatory - Eisen, Kommunikation mit der Erde, Software und Ergebnisse</a></li>
<li><a href="../de431582/index.html">Geschichte des Schutzes personenbezogener Daten: Wie kam es zur DSGVO?</a></li>
<li><a href="../de431584/index.html">Platz und Test: mischen, aber nicht schütteln</a></li>
<li><a href="../de431588/index.html">Selbstständiges Gesetz. Informationen zur Prüfung</a></li>
<li><a href="../de431590/index.html">Die Modernisierung veralteter britischer Windparks wird die Energieerzeugung um 171% steigern</a></li>
<li><a href="../de431596/index.html">Testen der Veeam-Sicherungs- und Replikationslast</a></li>
<li><a href="../de431598/index.html">Wir bringen eine öffentliche virtuelle QEMU-Maschine ohne Netzwerkkarte ins Internet und versuchen, sie abzubauen</a></li>
<li><a href="../de431600/index.html">Erhöhen Sie IDS / NMS: Mikrotik und Suricata mit einem Webinterface</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>