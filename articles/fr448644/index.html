<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>㊙️ 🧑🏾‍🤝‍🧑🏽 👲🏽 Expressions régulières applicatives en tant que foncteur alternatif gratuit 😫 🤷🏼 😡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'attire votre attention sur la traduction d'un merveilleux article frais de Justin Le. Dans son blog dans Code, cet auteur parle dans un langage asse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Expressions régulières applicatives en tant que foncteur alternatif gratuit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448644/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zn/lx/ku/znlxkuzq-mdn9op_dfy7enlrwsy.png" width="90%"></div><br><p>  <em>J'attire votre attention sur la traduction d'un merveilleux article frais de Justin Le.</em>  <em>Dans son blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans Code,</a> cet auteur parle dans un langage assez simple de l'essence mathématique de solutions fonctionnelles belles et élégantes pour des problèmes pratiques.</em>  <em>Cet article examine en détail un exemple de la manière dont le transfert de la structure mathématique que forment les données d'un domaine à un système de types de programmes peut immédiatement, comme l'écrivirent "et automatiquement" Gerald et Sassman, aboutir à une solution de travail.</em> </p><br><p> <em>Le code montré dans l'image est une implémentation autonome complète et extensible de l'analyseur d'expressions régulières, écrit à partir de zéro.</em>  <em>De la magie de première classe et de vrai type!</em> </p><a name="habracut"></a><br><p>  Aujourd'hui, nous implémentons des expressions régulières et des analyseurs applicatifs (dans l'esprit de la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">applicative regex</a> ) en utilisant des structures algébriques libres!  Les structures libres sont l'un de mes outils préférés à Haskell et j'ai écrit plus tôt sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les groupes libres</a> , les variations sur le thème des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">monades libres</a> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">foncteur applicatif «libre» sur les monoïdes</a> . </p><br><p>  Les expressions régulières (et leurs analyseurs) sont omniprésentes en programmation et en informatique, j'espère donc qu'en démontrant à quel point elles sont faciles à implémenter en utilisant des structures libres, j'aiderai le lecteur à apprécier les mérites de cette approche sans craindre de se perdre dans des détails inutiles. </p><br><p> Tout le code de l'article est <a href="">disponible en</a> ligne sous la forme d'un «exécutable de pile».  Si vous l'exécutez ( <code>./regexp.hs</code> ), la session GHCi commencera avec toutes les définitions, vous aurez donc la possibilité de jouer avec les fonctions et leurs types. </p><br><p>  Cet article sera parfaitement compréhensible pour le "débutant avancé", ou le "spécialiste débutant" à Haskell.  Il nécessite la connaissance des concepts de base d'un langage: correspondance de motifs, types de données algébriques et abstractions telles que les monoides, les foncteurs et les notations. </p><br><h1 id="regulyarnye-yazyki">  Langues régulières </h1><br><p>  Une expression régulière est un moyen de définir un langage régulier.  Formellement, une telle expression est constituée de trois éléments de base: </p><br><ol><li>  Un ensemble vide est un élément qui ne correspond à rien. </li><li>  Une chaîne vide est un élément neutre qui correspond trivialement à une chaîne vide. </li><li>  Un littéral est un symbole qui lui correspond.  Beaucoup d'un élément. </li></ol><br><p>  Et aussi de trois opérations: </p><br><ol><li>  Concaténation: <code>RS</code> , séquence d'expressions.  Le produit des ensembles (cartésiens). </li><li>  Alternative: <code>R|S</code> , choix entre les expressions.  L'union des ensembles. </li><li>  Wedge Star: <code>R*</code> , répétition d'une expression un nombre arbitraire de fois (y compris zéro). </li></ol><br><p>  Et c'est tout ce qui compose les expressions régulières, ni plus, ni moins.  A partir de ces composants de base, vous pouvez construire toutes les autres opérations connues sur des expressions régulières - par exemple, <code>a+</code> peut être exprimé en <code>aa*</code> et des catégories comme <code>\w</code> peuvent être représentées comme une alternative aux caractères appropriés. </p><br><div class="spoiler">  <b class="spoiler_title">Note du traducteur</b> <div class="spoiler_text"><p>  La définition minimale ci-dessus d'une langue régulière est assez complète pour un mathématicien, mais peu pratique.  Par exemple, l'opération de négation ou d'addition ("n'importe quel caractère sauf le spécifié") peut être écrite dans le cadre de la définition de base, mais son application directe entraînera une augmentation exponentielle des ressources utilisées. </p></div></div><br><h1 id="alternativnyy-funktor">  Foncteur alternatif </h1><br><p>  Lorsque vous regardez la structure des expressions régulières, cela ne vous semble-t-il pas familier?  Cela me rappelle beaucoup la classe de type <code>Alternative</code> .  Si un foncteur appartient à cette classe, cela signifie que les éléments suivants sont définis pour lui: </p><br><ol><li>  Un élément vide correspondant à une défaillance ou une erreur de calcul. </li><li>  <code>pure x</code> - un seul élément (de la classe <code>Applicative</code> ). </li><li>  Opération <code>&lt;*&gt;</code> , organisation de calculs séquentiels. </li><li>  Opération <code>&lt;|&gt;</code> , organisation de calculs alternatifs. </li><li>  La fonction <code>many</code> consiste à répéter les calculs zéro ou plusieurs fois. </li></ol><br><p>  Tout cela est très similaire à la construction d'une langue régulière, non?  Peut-être que le foncteur alternatif est presque ce dont nous avons besoin, la seule chose qui manque est la primitive correspondant au caractère littéral. </p><br><p>  Toute personne nouvelle dans la classe <code>Alternative</code> peut trouver une bonne introduction à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Typeclassopedia</a> .  Mais dans le cadre de notre article, cette classe représente simplement un «double monoïde» avec deux façons de combiner <code>&lt;*&gt;</code> et <code>&lt;|&gt;</code> , qui, en un sens, peuvent être comparées aux opérations <code>*</code> et <code>+</code> pour les nombres.  En général, pour déterminer un foncteur alternatif, les cinq points ci-dessus et quelques lois supplémentaires de commutativité et de distributivité sont suffisants. </p><br><div class="spoiler">  <b class="spoiler_title">Note du traducteur (ennuyeux)</b> <div class="spoiler_text"><p>  Pour être précis, l'auteur s'est un peu excité avec le «double monoïde».  La classe <code>Alternative</code> étend le foncteur applicatif, qui (sous certaines restrictions) est un semigroupe, à un semiring, où l'opération d'addition <code>&lt;|&gt;</code> avec l'élément neutre <code>empty</code> joue le rôle d'un monoïde commutatif.  Opérateur d'application </p><br><pre> <code class="haskell hljs">(&lt;*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; f (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  ne peut pas agir comme un analogue de l'opération de multiplication dans un semirage, car il ne forme même pas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">magma</a> .  Cependant, avec l'opérateur <code>&lt;*&gt;</code> , les opérateurs "unilatéraux" <code>*&gt;</code> et <code>&lt;*</code> définis dans le package <code>Control.Applicative</code> .  Chacun d'eux ignore le résultat de l'opérande que le "coin" n'affiche pas: </p><br><pre> <code class="haskell hljs">(&lt;*) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fa (*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fb</code> </pre> <br><p>  Si les types <code>a</code> et <code>b</code> coïncident, alors avec ces opérations on obtient un semi-groupe (l'associativité découle des propriétés de la composition).  On peut vérifier que pour un foncteur alternatif, la multiplication est distributive par rapport à l'addition, à droite comme à gauche, et, de plus, l'élément neutre à additionner (analogique de zéro) est un élément absorbant pour l'opération de multiplication. </p><br><p>  Les semi-anneaux forment également des nombres, des ensembles, des matrices de demi-anneaux, des types algébriques et ... des expressions régulières, donc, vraiment, nous parlons de la même structure algébrique. </p></div></div><br><p>  Ainsi, nous pouvons considérer les expressions régulières comme un foncteur alternatif, plus une primitive pour un caractère littéral.  Mais, il y a une autre façon de les regarder, et cela nous conduit directement à des structures libres.  Au lieu du "foncteur alternatif avec des littéraux", nous pouvons transformer le littéral en une instance de la classe <code>Alternative</code> . </p><br><h1 id="svoboda">  La liberté </h1><br><p>  Écrivons comme ça.  Type pour littéral primitif: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span></span></code> </pre> <br><p>  Notez que puisque nous travaillons avec des foncteurs (applicatifs, alternatifs), alors avec toutes nos expressions régulières un certain «résultat» sera associé.  En effet, lors de la définition d'une instance pour les <code>Functor</code> , <code>Applicative</code> et <code>Alternative</code> , nous devons avoir un type de paramètre. </p><br><p>  D'une part, vous pouvez ignorer ce type, mais d'autre part, vous devez utiliser cette valeur en raison de la correspondance avec une expression régulière, comme cela se fait dans les applications industrielles qui fonctionnent avec des expressions régulières. </p><br><p>  Dans notre cas, <code>Prim 'a' 1 :: Prim Int</code> représentera une primitive qui correspond au caractère <code>'a'</code> et est immédiatement interprétée, résultant en une unité. </p><br><p>  Eh bien, maintenant ... donnons à notre primitive la structure mathématique souhaitée en utilisant le foncteur alternatif gratuit de la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>free</code></a> : </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free type RegExp = Alt Prim</code> </pre> <br><p>  C'est tout!  C'est notre type complet pour les expressions régulières!  Après avoir déclaré le type <code>Alt</code> une instance de la classe <code>Functor</code> , nous avons obtenu toutes les opérations des classes <code>Applicative</code> et <code>Alternative</code> , car dans ce cas, il existe des instances d' <code>Applicative (Alt f)</code> et <code>Alternative (Alt f)</code> .  Maintenant, nous avons: </p><br><ul><li>  Jeu vide trivial - <code>empty</code> de la classe <code>Alternative</code> </li><li>  Chaîne vide - <code>pure</code> de la classe <code>Applicative</code> </li><li>  Caractère littéral - Basic <code>Prim</code> </li><li>  Concaténation - <code>&lt;*&gt;</code> de la classe <code>Applicative</code> </li><li>  Alternative - <code>&lt;|&gt;</code> de la classe <code>Alternative</code> </li><li>  Kleene Star - <code>many</code> de la classe <code>Alternative</code> </li></ul><br><p>  Et tout cela, nous avons été complètement "gratuits", c'est-à-dire "gratuitement"! </p><br><p>  Essentiellement, une structure libre ne nous fournit automatiquement qu'une abstraction pour le type de base et rien de plus.  Mais les expressions régulières, en elles-mêmes, ne représentent également qu'une structure: des éléments de base et un ensemble d'opérations, ni plus ni moins, de sorte que le foncteur alternatif gratuit nous fournit exactement ce dont nous avons besoin.  Pas plus, mais pas moins. </p><br><p>  Après avoir ajouté quelques fonctions pratiques de wrapper ... le travail sur le type est terminé! </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | charAs:   ,    charAs :: Char -&gt; a -&gt; RegExp a charAs cx = liftAlt (Prim cx) -- liftAlt :: fa -&gt; Alt fa   --   Prim   RegExp -- | char:         char :: Char -&gt; RegExp Char char c = charAs cc -- | string:         string :: String -&gt; RegExp String string = traverse char -- , ?</span></span></code> </pre> <br><h1 id="primery">  Des exemples </h1><br><p>  Eh bien, essayons?  Construisons l'expression <code>(a|b)(cd)*e</code> , qui retourne, en cas de correspondance réussie, le type d'unité <code>()</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp_</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> () testRegExp_ = void $ (char 'a' &lt;|&gt; char 'b') *&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) *&gt; char 'e'</code> </pre> <br><p>  La fonction <code>void :: Functor f =&gt; fa -&gt; f ()</code> du package <code>Data.Functor</code> supprime le résultat, nous l'utilisons, car nous ne sommes intéressés que par le succès de la comparaison.  Mais les opérateurs <code>&lt;|&gt;</code> , <code>*&gt;</code> et <code>many</code> sont utilisés par nous exactement comme cela est supposé lors de la concaténation ou du choix d'une des options. </p><br><p>  Voici un exemple intéressant plus compliqué, définissons la même expression régulière, mais maintenant, à la suite de la correspondance, nous calculons le nombre de répétitions de la sous-chaîne <code>cd</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExp = (char 'a' &lt;|&gt; char 'b') *&gt; (length &lt;$&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>)) &lt;* char 'e'</code> </pre> <br><p>  Il y a une subtilité dans le fonctionnement des opérateurs <code>*&gt;</code> et <code>&lt;*</code> : les flèches indiquent le résultat à enregistrer.  Et comme <code>many (string "cd") :: RegExp [String]</code> renvoie une liste d'éléments répétitifs, nous pouvons, en restant à l'intérieur du foncteur, calculer la longueur de cette liste en obtenant le nombre de répétitions. </p><br><p>  De plus, l' <code>-XApplicativeDo</code> compilateur GHC <code>-XApplicativeDo</code> permet d'écrire notre expression en utilisant la notation do, ce qui est probablement plus facile à comprendre: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExpDo</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExpDo = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> char 'a' &lt;|&gt; char 'b' cds &lt;- many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) char 'e' pure (length cds)</code> </pre> <br><p>  Tout cela est quelque peu similaire à la façon dont nous «capturons» le résultat de l'analyse d'une chaîne à l'aide d'une expression régulière, pour y accéder.  Voici un exemple en Ruby: </p><br><pre> <code class="ruby hljs">irb&gt; <span class="hljs-regexp"><span class="hljs-regexp">/(a|b)((cd)*)e/</span></span>.match(<span class="hljs-string"><span class="hljs-string">"acdcdcdcde"</span></span>)[<span class="hljs-number"><span class="hljs-number">2</span></span>] =&gt; <span class="hljs-string"><span class="hljs-string">"cdcdcdcd"</span></span></code> </pre> <br><p>  la seule différence est que nous avons ajouté du post-traitement pour calculer le nombre de répétitions. </p><br><p>  Voici un autre <code>\d</code> qui correspond à un nombre de 0 à 9 et renvoie un nombre: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">digit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> digit = asum [ charAs (intToDigit i) i | i &lt;- [<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.9</span></span>] ]</code> </pre> <br><p>  Ici, la fonction <code>asum</code> du package <code>Control.Applicative.Alternative</code> représente une sélection parmi les éléments de la liste <code>asum [x,y,z] = x &lt;|&gt; y &lt;|&gt; z</code> , et la fonction <code>intToDigit</code> définie dans le package <code>Data.Char</code> .  Et, encore une fois, nous pouvons créer des choses assez élégantes, par exemple, l'expression <code>\[\d\]</code> , correspondant au nombre entre crochets: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bracketDigit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> bracketDigit = char '[' *&gt; digit &lt;* char ']'</code> </pre> <br><h1 id="parsing">  Analyse </h1><br><p>  Eh bien, tout ce que nous avons fait était de décrire le type de données pour un littéral avec concaténation, sélection et répétition.  Super!  Mais ce dont nous avons vraiment besoin, c'est de faire correspondre une chaîne avec une expression régulière, non?  Comment un foncteur alternatif gratuit peut-il nous aider?  En fait, cela aidera beaucoup.  Examinons deux façons de procéder! </p><br><h2 id="razgruzhaem-alternativnyy-funktor">  Déchargez le foncteur alternatif </h2><br><p>  <strong>Qu'est-ce que la liberté?</strong> </p><br><p>  La manière canonique d'utiliser une structure libre consiste à la plier en une structure en béton à l'aide d'une algèbre appropriée.  Par exemple, la transformation <code>foldMap</code> transforme un monoïde libre (liste) en valeur de n'importe quelle instance de la classe <code>Monoid</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldMap</span></span> :: <span class="hljs-type"><span class="hljs-type">Monoid</span></span> m =&gt; (a -&gt; m) -&gt; ([a] -&gt; m)</code> </pre> <br><p>  La fonction <code>foldMap</code> transforme la transformation <code>a -&gt; m</code> en transformation <code>[a] -&gt; m</code> (ou <code>FreeMonoid a -&gt; m</code> ), avec un monoïde spécifique <code>m</code> .  L'idée générale est que l'utilisation d'une structure libre vous permet de reporter son utilisation spécifique "pour plus tard", en séparant le moment de la création et le temps d'utilisation de la structure. </p><br><p>  Par exemple, nous pouvons construire un monoïde gratuit à partir de nombres: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- |  "" `Int`     `Int`,  `liftAlt`. liftFM :: Int -&gt; [Int] liftFM x = [x] myMon :: [Int] myMon = liftFM 1 &lt;&gt; liftFM 2 &lt;&gt; liftFM 3 &lt;&gt; liftFM 4</span></span></code> </pre> <br><p>  Et maintenant, nous pouvons décider comment nous voulons interpréter l'opération <code>&lt;&gt;</code> : <br>  Peut-être cet ajout? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Sum</span></span> myMon <span class="hljs-type"><span class="hljs-type">Sum</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 + 2 + 3 + 4</span></span></code> </pre> <br><p>  Ou la multiplication? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Product</span></span> myMon <span class="hljs-type"><span class="hljs-type">Product</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 * 2 * 3 * 4</span></span></code> </pre> <br><p>  Ou peut-être le calcul du nombre maximum? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Max</span></span> myMon <span class="hljs-type"><span class="hljs-type">Max</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 `max` 2 `max` 3 `max` 4</span></span></code> </pre> <br><p>  L'idée est de reporter la sélection d'un monoïde particulier en créant d'abord une collection gratuite de numéros 1, 2, 3 et 4. Un monoïde libre sur les nombres détermine la structure au-dessus d'eux, ni plus ni moins.  Pour utiliser <code>foldMap</code> nous <code>foldMap</code> "comment percevoir le type de base" en passant l'opérateur <code>&lt;&gt;</code> à un monoïde particulier. </p><br><p>  <strong>Interprétation dans un fonctionnaire d' <code>State</code></strong> </p><br><p>  En pratique, obtenir un résultat à partir d'une structure libre consiste à trouver (ou créer) un foncteur adapté qui nous fournira le comportement souhaité.  Dans notre cas, nous avons de la chance qu'il existe une implémentation spécifique de la classe <code>Alternative</code> qui fonctionne exactement comme nous en avons besoin: <code>StateT String Maybe</code> . </p><br><p>  Le produit <code>&lt;*&gt;</code> de ce foncteur consiste à organiser une séquence de changements d'état.  Dans notre cas, sous l'état, nous considérerons le reste de la chaîne analysée, de sorte que l'analyse séquentielle soit la meilleure correspondance pour l'opération <code>&lt;*&gt;</code> . </p><br><p>  Et sa somme <code>&lt;|&gt;</code> fonctionne comme un retour en arrière, une recherche avec retour à l'alternative en cas d'échec.  Il conserve son état depuis la dernière exécution réussie de l'analyse et y revient si l'alternative est sélectionnée sans succès.  C'est exactement le comportement que l'on attend de l'expression <code>R|S</code> </p><br><p>  Enfin, une transformation naturelle pour un foncteur alternatif gratuit est appelée <code>runAlt</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. pb -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">Alt</span></span> pa -&gt; fa</code> </pre> <br><p>  Ou, pour le type RegExp: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. <span class="hljs-type"><span class="hljs-type">Prim</span></span> b -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; fa</code> </pre> <br><p>  Si vous n'êtes pas familier avec les types <code>RankN</code> (avec <code>forall b.</code> Construction), vous pouvez voir une bonne introduction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Le point ici est que vous devez fournir une fonction <code>runAlt</code> qui fonctionne avec <code>Prim b</code> pour absolument n'importe quel <code>b</code> , et pas de type particulier, comme <code>Int</code> et <code>Bool</code> , par exemple.  Autrement dit, comme avec <code>foldMap</code> nous n'avons qu'à spécifier ce qu'il faut faire avec le type de base.  Dans notre cas, répondez à la question: "Que faut-il faire avec le type <code>Prim</code> ?" </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">processPrim</span></span> :: <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> d:ds &lt;- get guard (c == d) put ds pure x</code> </pre> <br><p>  Il s'agit d'une interprétation de <code>Prim</code> comme une action dans le contexte de la <code>StateT String Maybe</code> - <code>StateT String Maybe</code> , où l'état est une chaîne <code>StateT String Maybe</code> .  Permettez-moi de vous rappeler que <code>Prim</code> contient des informations sur le caractère correspondant <code>c</code> et son interprétation sous la forme d'une valeur de <code>x</code> .  <code>Prim</code> traitement <code>Prim</code> compose des étapes suivantes: </p><br><ul><li>  En utilisant <code>get</code> état (pas encore une partie analysée de la chaîne) et imprimons immédiatement son premier caractère et le reste.  Si la ligne est vide, une alternative reviendra.  ( <em>Le transformateur <code>StateT</code> agit à l'intérieur du foncteur Maybe, et s'il est impossible de faire correspondre le motif sur le côté droit de l'opérateur <code>&lt;-</code> à l'intérieur du bloc do, les calculs se termineront avec le résultat <code>empty</code> , c'est-à-dire <code>Nothing</code> . Env. Trans.</em> ). </li><li>  Nous utilisons l'expression de garde pour faire correspondre le caractère actuel avec le caractère donné.  En cas d'échec, le <code>empty</code> retourné, et nous passons à l'option alternative. </li><li>  Nous changeons l'état en remplaçant la chaîne analysée par sa «queue», car à ce moment le caractère actuel peut déjà être considéré comme analysé avec succès. </li><li>  Nous retournons ce que la primitive <code>Prim</code> devrait retourner. </li></ul><br><p>  Vous pouvez déjà utiliser cette fonction pour mapper RegEx à un préfixe de chaîne.  Pour ce faire, vous devez démarrer les calculs à l'aide de <code>runAlt</code> et <code>runStateT</code> , en passant la chaîne analysée à la dernière fonction comme argument: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchPrefix</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchPrefix re = evalStateT (runAlt processPrim re)</code> </pre> <br><p>  C'est tout!  Voyons comment fonctionne notre première solution: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchPrefix digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchPrefix bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchPrefix (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchPrefix (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><p>  <strong>Attendez, c'était quoi?</strong> </p><br><p>  Il semble que tout s'est passé un peu plus vite que prévu.  Il y a une minute, nous avons écrit notre primitive, et puis encore!  et l'analyseur de travail est prêt.  Voici, en fait, tout le code clé, quelques lignes en Haskell: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Trans.State (<span class="hljs-title"><span class="hljs-title">evalStateT</span></span>, <span class="hljs-title"><span class="hljs-title">put</span></span>, <span class="hljs-title"><span class="hljs-title">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free (<span class="hljs-title"><span class="hljs-title">runAlt</span></span>, <span class="hljs-type"><span class="hljs-type">Alt</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Applicative <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">guard</span></span>) data Prim a = Prim Char a deriving Functor type RegExp = Alt Prim matchPrefix :: RegExp a -&gt; String -&gt; Maybe a matchPrefix re = evalStateT (<span class="hljs-title"><span class="hljs-title">runAlt</span></span> <span class="hljs-title"><span class="hljs-title">processPrim</span></span> <span class="hljs-title"><span class="hljs-title">re</span></span>) where processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> <span class="hljs-title"><span class="hljs-title">cx</span></span>) = do d:ds &lt;- get guard (<span class="hljs-title"><span class="hljs-title">c</span></span> == <span class="hljs-title"><span class="hljs-title">d</span></span>) put ds pure x</code> </pre> <br><p>  Et avons-nous un analyseur d'expressions régulières entièrement fonctionnel?  Qu'est-il arrivé? </p><br><p>  Rappelons qu'à un niveau d'abstraction élevé, <code>Alt Prim</code> contient déjà <code>pure</code> , <code>empty</code> , <code>Prim</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> , et <code>many</code> dans sa structure (il y a une subtilité désagréable avec cet opérateur, mais plus sur cela plus tard).  <code>runAlt</code> utilise le comportement d'un foncteur alternatif particulier (dans notre cas, <code>StateT String Maybe</code> ) pour contrôler le comportement des opérateurs <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> et de <code>many</code> opérateurs.  Cependant, <code>StateT</code> n'a pas d'opérateur intégré similaire à <code>Prim</code> , et pour cela, nous avions besoin d'écrire <code>processPrim</code> . </p><br><p>  Ainsi, pour le type <code>Prim</code> , la fonction <code>runAlt</code> utilise <code>runAlt</code> , et pour <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> et <code>many</code> , une instance appropriée de la classe <code>Alternative</code> est utilisée.  Ainsi, 83% du travail est effectué pour nous par le foncteur <code>StateT</code> , et les 17% restants sont effectués par <code>StateT</code> .  En vérité, c'est quelque peu décevant.  On peut se demander: pourquoi était-il même nécessaire de commencer avec le wrapper <code>Alt</code> ?  Pourquoi ne pas définir immédiatement le type <code>RegExp = StateT String Maybe</code> et le <code>char :: Char -&gt; StateT String Maybe Char</code> primitif approprié <code>char :: Char -&gt; StateT String Maybe Char</code> ?  Si tout est fait dans le <code>StateT</code> StateT, alors pourquoi s'embêter avec <code>Alt</code> - un foncteur alternatif gratuit? </p><br><p>  <code>Alt</code> principal avantage d' <code>Alt</code> sur <code>StateT</code> est que <code>StateT</code> est ... un outil assez puissant.  Mais en fait, il est puissant, au point d'absurdité.  Il peut être utilisé pour représenter un grand nombre des calculs et des structures les plus divers, et, désagréablement, il est facile d'imaginer quelque chose qui n'est pas une expression régulière.  Disons quelque chose de basique comme <code>put "hello" :: StateT String Maybe ()</code> ne correspond à aucune expression régulière valide, mais il est du même type que <code>RegExp ()</code> .  Ainsi, alors que nous disons que <code>Alt Prim</code> correspond à une expression régulière, ni plus, ni moins, nous ne pouvons pas en dire <code>StateT String Maybe</code> avec <code>StateT String Maybe</code> .  Le type <code>Alt Prim</code> est la représentation parfaite d'une expression régulière.  Tout ce qui peut être exprimé avec son aide est une expression régulière, mais tout ce qui n'est pas une telle expression ne peut pas être exprimé avec son aide.  Ici, cependant, il y a aussi quelques subtilités désagréables associées à la paresse de Haskell, plus à ce sujet plus tard. </p><br><p>  Ici, nous ne pouvons considérer <code>StateT</code> que comme un contexte utilisé pour un <br>  interprétations d'expressions régulières - en tant qu'analyseur.  Mais vous pouvez imaginer d'autres façons d'utiliser <code>RegExp</code> .  Par exemple, nous pouvons avoir besoin de sa représentation textuelle, ce que <code>StateT</code> ne permettra pas. </p><br><p>  Nous ne pouvons pas dire que <code>StateT String Maybe</code> est une expression régulière, mais seulement que ce foncteur peut représenter un analyseur basé sur des grammaires régulières.  Mais à propos d' <code>Alt Prim</code> nous pouvons dire avec certitude qu'il s'agit d'une expression régulière ( <em>comme disent les mathématiciens, ils sont égaux à l'isomorphisme, environ Trans.</em> ). </p><br><h2 id="neposredstvennoe-ispolzovanie-svobodnoy-struktury">  Utilisation directe de la structure libre </h2><br><p>  Tout cela, bien sûr, est très bon, mais que se passe-t-il si nous ne voulons pas déplacer 83% du travail en code pour un type qui a été écrit par quelqu'un pour nous.  Est-il possible d'utiliser directement la structure <code>Alt</code> gratuite pour écrire un analyseur?  Cette question est similaire à celle-ci: comment écrire une fonction qui traite les listes (en faisant correspondre les constructeurs <code>(:)</code> et <code>[]</code> ) au lieu d'utiliser uniquement <code>foldMap</code> ?  Comment opérer directement avec cette structure au lieu de déléguer le travail à un monoïde spécifique? </p><br><p>  Heureux que vous ayez demandé!  Jetons un coup d'œil à la définition d'un foncteur alternatif gratuit: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> fa = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alternatives</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fa</span></span></span><span class="hljs-class">] } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> fa = forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ap</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fr</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a</span></span></code> </pre> <br><p>  Il s'agit d'un type inhabituel défini par récursivité mutuelle, il peut donc sembler très déroutant.  Une façon de le comprendre est d'imaginer que <code>Alt xs</code> contient une chaîne d'alternatives formée en utilisant l'opérateur <code>&lt;|&gt;</code> .       <code>AltF</code> ,     <code>f</code> ,     <code>&lt;*&gt;</code> (   ). </p><br><p>   <code>AltF fa</code>    <code>[fr]</code> ,   <code>r</code>   . <code>Ap</code>   <code>(:)</code> ,  <code>fr</code> ,  <code>Pure</code> —   <code>[]</code> .  <code>forall r.</code>       <code>-XExistentialQuantification</code>         . </p><br><p>   , <code>Alt f</code>   ,      .     ,      ( )  <code>&lt;*&gt;</code>  <code>&lt;|&gt;</code> ,  ,   <code>[a]</code>      <code>&lt;&gt;</code> . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>       ,     : </p><br><ul><li>   () — ,   <code>&lt;&gt;</code> : <br><pre> <code class="haskell hljs">[a,b,c,d] = [a]&lt;&gt;[b]&lt;&gt;[c]&lt;&gt;[d]</code> </pre> </li><li>   () —  ,   <code>+</code> ,   — ,   <code>*</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span>*(b+c)+d*(x+y+z)*h</code> </pre> </li><li>    (Alt f) —  ,   <code>&lt;|&gt;</code> ,   — ,   <code>&lt;*&gt;</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fa</span></span> &lt;*&gt; (fb &lt;|&gt; fc) &lt;|&gt; fd &lt;*&gt; (fx &lt;|&gt; fy &lt;|&gt; fz) &lt;*&gt; fh</code> </pre> </li></ul></div></div><br><p>   ,       <code>RegExp a -&gt; String -&gt; Maybe a</code> ,   ,     .          :         . </p><br><p>  ,   <code>Alt</code> .   ,           ,     . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchAlts</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchAlts (<span class="hljs-type"><span class="hljs-type">Alt</span></span> res) xs = asum [ matchChain re xs | re &lt;- res ]</code> </pre> <br><p>   <code>asum :: [Maybe a] -&gt; Maybe a</code>   ,   <code>Just</code> . ( <em>   ,   <code>Maybe a</code>       <code>Alternative</code> —   <code>Nothing</code> ,   <code>&lt;|&gt;</code>    . . .</em> ) </p><br><p>     .       <code>AltF</code> ,   <code>Ap</code>  <code>Pure</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = _ matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) cs = _</code> </pre> <br><p>      "  ":     GHC   "",   ,    ,   . ( <em> Haskell "" (holes)     ,   <code>_</code> ,      . . .</em> )        : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cs <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [] -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> d:ds | c == d -&gt; matchAlts (($ x) &lt;$&gt; next) ds | otherwise -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) _ = <span class="hljs-type"><span class="hljs-type">Just</span></span> x</code> </pre><br><p>   <code>Ap</code> (  <code>(:)</code> ),  ,  -    .         ,       .    <code>Prim r</code> ,   ,           <code>next :: RegExp (r -&gt; a)</code> .    ,       <code>next</code> .   , ""  ,  <code>Nothing</code> . ,     <code>Pure x</code> (   <code>[]</code> ), ,  ,      . </p><br><p> ,        ,    .  ,  ,  " "    <code>Ap</code> , <code>Pure</code> , <code>AltF</code>  ..,            . </p><br><p>          : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchAlts digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchAlts bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchAlts (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchAlts (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>              . ,      () ,            .    ,  ,   . </p></div></div><br><h1 id="chto-zhe-imenno-my-sdelali">     ? </h1><br><p>                <code>foldMap</code>     .    ,   ,         foldMap,     ,     ,    ,   ! ,   —    ,           —    <code>(:)</code>  <code>[]</code> . </p><br><p>  ,   ,    : ,   ,    ,  <code>(:)</code> ,  <code>[]</code> .  ,     .  ,  <code>[1,2,3] &lt;&gt; [4]</code>      ,   <code>[1] &lt;&gt; [2,3] &lt;&gt; [4]</code> .  ,    ,      . </p><br><p>        .  ,     : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Empty</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a | forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Seq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Union</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Many</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>       <code>RegExp</code> ,        .      . ,      <code>RegExp</code>       : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | a|(b|c) abc1 :: RegExp Int abc1 = Prim 'a' 1 `Union` (Prim 'b' 2 `Union` Prim 'c' 3) -- | (a|b)|c abc2 :: RegExp Int abc2 = (Prim 'a' 1 `Union` Prim 'b' 2) `Union` Prim 'c' 3</span></span></code> </pre> <br><p>  ,             . </p><br><p>    <code>Alt Prim</code> ,       ,        ,       .  ,       <code>matchAlts</code> ,            .     <code>(a|b)|c</code>  <code>a|(b|c)</code> .     <code>Alt</code>        . ,     ,    . </p><br><p>    ,    ,       <code>(a|b)|c</code>  ,  <code>(a|b)|c</code> , , ,       <code>RegExp</code> .  <code>Alt</code>       ,       . </p><br><p> ,  ,    <code>Alt</code>    , <code>Alt Prim</code>       . , <code>Alt Prim</code>       <code>a|a</code>  <code>a</code> .    ,   <code>Alt f</code>       <code>f</code> .        ,   :      .        , ,  ,     . </p><br><h1 id="nekotorye-dosadnye-tonkosti">    </h1><br><p>     ,     .      ,      ,            .        <code>RegExp</code>  ,            ,    — . </p><br><p>    ,          Haskell. ,  -  <code>[a]</code>      . ( <em>       ,       -  ,   "" </em> <math> </math><em><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi" id="MJXp-Span-2">⊥</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.808ex" height="1.937ex" viewBox="0 -728.2 778.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/448644/&amp;usg=ALkJrhhlclEhYL4BBEjn6_gbRWW2VsJawA#MJMAIN-22A5" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1">\bot</script></em>  <em>,      - "" . .</em>  <em>trans.</em>  ) </p><br><p>       : <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,              ( <em>,    ,       ,      . . .</em> ).  ,  Haskell     .   ,    <code>Alt</code>   <code>many</code> .  , <code>a*</code>   <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,             .     -    <code>many (char 'a')</code> ,    . Haskell       <code>Alt</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,      . </p><br><p>  ,    ,   ,      ,           (),         .        ,     <code>many</code>    . </p><br><p> ,   !    ""   <code>Alt</code> ,    <code>Control.Alternative.Free.Final</code> ,     <code>many</code> (,    ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ). </p><br><p>           ,    ,  <code>runAlt</code> . ,        <code>Alternative</code> ,     <code>many</code> (  <code>RE</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">regex-applicative</a> )       .      ,  Haskell      , ,   , <code>many</code>       . </p><br><p>    ,   .          (       ),          ( <em>,        , . .</em> ).    <code>matchPrefix</code> ,        ,   ,        .  ,   ,    ,      ,       .      ,   GHC        . </p><br><h1 id="poslednie-shtrihi">   </h1><br><p>         ,       ,   <code>tails</code> (   )  <code>mapMaybe</code> (           ).    ,     ,    <code>listToMaybe</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matches</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [a] matches re = mapMaybe (matchPrefix re) . tails firstMatch :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a firstMatch re = listToMaybe . matches re</code> </pre> <br><p>    ,   ,   <code>matchPrefix</code>   <code>Nothing</code>      ,  <code>listToMaybe</code>      ,   <code>Nothing</code> ( <em>      ,      . . .</em> ). </p><br><p> ,        .    ,       ,     —  ,    .       ,         .    ,     ,    ,      . </p><br><p>        <code>Alt Prim</code>         ,    :   ,  ,  ,    . </p><br><p>       ?        .      : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Only</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--    | Letter a --     | Digit (Int -&gt; a) --    , | Wildcard (Char -&gt; a) --    , | Satisfy (Char -&gt; Maybe a) --    , --  </span></span></span></span></code> </pre> <br><p>       ,      .      . </p><br><p>      ,   ,   .      <code>runAlt</code>      <code>Alt</code> . </p><br><p>                (). ,    ,        ,    ,    .       <code>|</code>      . ( <em>         ,        . . .</em> ).     ,  -     .  ,   <code>MonadPlus</code>     -   ,        ,     .     ,      . </p><br><p> ,   ,         .  ,   ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448644/">https://habr.com/ru/post/fr448644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448634/index.html">Cours d'ukrainien</a></li>
<li><a href="../fr448636/index.html">Hackaday Retro Computer Case</a></li>
<li><a href="../fr448638/index.html">Buildroot - Partie 1. Informations générales, construction d'un système minimal, configuration via le menu</a></li>
<li><a href="../fr448640/index.html">SSD GIGABYTE Aorus RGB M.2: petite télécommande uniforme pour LED RGB (2 parties)</a></li>
<li><a href="../fr448642/index.html">Modèle de distribution obligatoire des droits dans FreeBSD</a></li>
<li><a href="../fr448648/index.html">Comment asseoir tout le monde dans la science et ne pas transformer le bureau en foyer de haine</a></li>
<li><a href="../fr448652/index.html">Mozilla WebThings sur Raspberry Pi - pour commencer</a></li>
<li><a href="../fr448654/index.html">Mozilla WebThings - Configuration de la passerelle</a></li>
<li><a href="../fr448656/index.html">Big Brother regarde ... lui-même ou une carte avec l'historique des mouvements dans HomeAssistant</a></li>
<li><a href="../fr448658/index.html">Que peut-on faire via le connecteur OBD dans la voiture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>