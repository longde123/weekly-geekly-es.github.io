<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëü üõÇ üö∏ Syst√®me d'emploi. Vue d'ensemble de l'autre c√¥t√© üì∂ üíÜüèø üåà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la nouvelle version unitaire de 2018, ils ont finalement officiellement ajout√© le nouveau syst√®me de composants d'entit√©, ou ECS pour faire court...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Syst√®me d'emploi. Vue d'ensemble de l'autre c√¥t√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420829/">  Dans la nouvelle version <b>unitaire</b> de 2018, ils ont finalement officiellement ajout√© le nouveau <b>syst√®me de composants d'entit√©,</b> ou <b>ECS pour faire</b> court, qui vous permet de travailler uniquement avec leurs donn√©es au lieu du travail habituel avec les composants d'objet. <br><br>  Un syst√®me de t√¢ches suppl√©mentaire vous propose d'utiliser la puissance de calcul parall√®le pour am√©liorer les performances de votre code. <br><a name="habracut"></a><br>  Ensemble, ces deux nouveaux syst√®mes ( <b>ECS</b> et <b>Job System</b> ) offrent un nouveau niveau de traitement des donn√©es. <br><br>  Plus pr√©cis√©ment, dans cet article, je n'analyserai pas l'ensemble du syst√®me <b>ECS</b> , qui est actuellement disponible sous la forme d'un ensemble d'outils t√©l√©charg√©s s√©par√©ment dans l' <b>unit√©</b> , mais je ne consid√©rerai que le syst√®me de t√¢ches et comment il peut √™tre utilis√© en dehors du package <b>ECS</b> . <br><br><h3>  Nouveau syst√®me </h3><br>  Initialement, l' <b>unit√©</b> pouvait utiliser l'informatique multithread, mais tout cela devait √™tre cr√©√© par le d√©veloppeur lui-m√™me, pour r√©soudre les probl√®mes lui-m√™me et contourner les pi√®ges.  Et si auparavant, il √©tait n√©cessaire de travailler directement avec des choses telles que la cr√©ation de threads, la fermeture de threads, les pools, la synchronisation, maintenant tout ce travail tombait sur les √©paules du moteur, et le d√©veloppeur lui-m√™me n'avait plus qu'√† cr√©er des t√¢ches et les terminer. <br><br><h3>  Les t√¢ches </h3><br>  Pour effectuer des calculs dans le nouveau syst√®me, il est n√©cessaire d'utiliser des t√¢ches qui sont des objets compos√©s de m√©thodes et de donn√©es pour le calcul. <br><br>  Comme toutes les autres donn√©es du syst√®me <b>ECS</b> , les t√¢ches du <b>Job System sont</b> √©galement repr√©sent√©es comme des structures h√©ritant de l'une des trois interfaces. <br><br><h4>  Ijob </h4><br>  L'interface de t√¢che la plus simple contenant une m√©thode <b>Execute</b> qui ne prend rien sous forme de param√®tres et ne renvoie rien. <br><br>  La t√¢che elle-m√™me ressemble √† ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Ijob</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Dans la m√©thode <b>Execute</b> , vous pouvez effectuer les calculs n√©cessaires. <br><br><h4>  IJobParallelFor </h4><br>  Une autre interface avec la m√™me m√©thode <b>Execute</b> , qui √† son tour accepte d√©j√† l' <b>index des</b> param√®tres num√©riques. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelFor</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Cette interface <b>IJobParallelFor</b> , contrairement √† l'interface <b>IJob</b> , propose d'ex√©cuter une t√¢che plusieurs fois et pas seulement de l'ex√©cuter, mais de diviser cette ex√©cution en blocs qui seront r√©partis entre les threads. <br><br>  <i>Pas clair</i>  <i>Ne vous en faites pas, je vous en dirai plus.</i> <br><br><h4>  IJobParallelForTransform </h4><br>  Et la derni√®re interface sp√©ciale, qui, comme son nom l'indique, est con√ßue pour fonctionner avec ces transformations de l'objet.  Il contient √©galement la m√©thode <b>Execute</b> , avec l' <b>index des</b> param√®tres num√©riques et le param√®tre <b>TransformAccess</b> o√π se trouvent la position, la taille et la rotation de la transformation. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelForTransform</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelForTransform { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index, TransformAccess transform) {} }</code> </pre> <br></div></div><br>  √âtant donn√© que vous ne pouvez pas travailler avec des objets d' <b>unit√©</b> directement dans la t√¢che, cette interface ne peut traiter les donn√©es de transformation qu'en tant que structure <b>TransformAccess</b> distincte. <br><br>  Termin√©, maintenant que vous savez comment les structures de t√¢ches sont cr√©√©es, vous pouvez proc√©der √† la pratique. <br><br><h3>  Ach√®vement de la t√¢che </h3><br>  Cr√©ons une t√¢che simple h√©rit√©e de l'interface <b>IJob</b> et <b>terminons-la</b> .  Pour cela, nous avons besoin d'un simple script <b>MonoBehaviour</b> et de la structure de la t√¢che elle-m√™me. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() {} }</code> </pre> <br></div></div><br>  D√©posez maintenant ce script sur un objet de la sc√®ne.  Dans le m√™me script ( <b>TestJob</b> ) ci-dessous, nous √©crirons la structure de la t√¢che et n'oubliez pas d'importer les biblioth√®ques n√©cessaires. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Hello parallel world!"</span></span>); } }</code> </pre> <br></div></div><br>  Dans la m√©thode <b>Execute</b> , par exemple, imprimez une ligne simple sur la console. <br><br>  Passons maintenant √† la m√©thode <b>Start</b> du script <b>TestJob</b> , o√π nous allons cr√©er une instance de la t√¢che, puis l'ex√©cuter. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.Schedule().Complete(); } }</code> </pre> <br></div></div><br>  Si vous avez tout fait comme dans l'exemple, apr√®s avoir commenc√© le jeu, vous obtiendrez un message simple √† la console comme dans l'image. <br><br><img src="https://lh6.googleusercontent.com/QQeMBMeZy0HVw0r_D5Q_cH4k6Zzt-HAC6uev1O4pR--mOh96C2TQvw5DTH1X3ZPE7LORJ4wdV5kyKjGiJzVWLFm-HBi8HzSP4-DlbrYa65eRV1RF672uwsLsZvrCKtF5CdaGJ5tj" alt="image"><br><br>  Ce qui se passe ici: apr√®s avoir appel√© la m√©thode <b>Schedule</b> , le planificateur place la t√¢che dans le handle et maintenant elle peut √™tre termin√©e en appelant la m√©thode <b>Complete</b> . <br><br>  Il s'agit d'un exemple de t√¢che qui a simplement imprim√© du texte sur la console.  Pour qu'une t√¢che effectue des calculs parall√®les, il est n√©cessaire de la remplir de donn√©es. <br><br><h3>  Donn√©es dans la t√¢che </h3><br>  Comme dans le syst√®me <b>ECS</b> , dans les t√¢ches, il n'y a pas d'acc√®s aux objets d' <b>unit√©</b> , vous ne pouvez pas mettre le <b>GameObject</b> dans la t√¢che et y changer son nom.  Tout ce que vous pouvez faire est de transf√©rer certains param√®tres d'objet distincts √† la t√¢che, de modifier ces param√®tres et, une fois la t√¢che termin√©e, de r√©appliquer ces modifications √† l'objet. <br><br>  Il existe plusieurs limitations aux donn√©es dans la t√¢che elle-m√™me: premi√®rement, il doit s'agir de structures et, deuxi√®mement, il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne</a> doit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas</a> s'agir de types de donn√©es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">convertibles</a> , c'est-√†-dire que vous ne pouvez pas transmettre le m√™me <b>bool√©en</b> ou la m√™me <b>cha√Æne</b> √† la t√¢che. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float a, b; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { float result = a + b; Debug.Log(result); } }</code> </pre> <br></div></div><br>  Et la condition principale: les donn√©es non enferm√©es dans un conteneur ne sont accessibles qu'√† l'int√©rieur de la t√¢che! <br><br><h3>  Conteneurs </h3><br>  Lorsque vous travaillez avec l'informatique multithread, il est n√©cessaire d'√©changer en quelque sorte des donn√©es entre les threads.  Afin de pouvoir y transf√©rer des donn√©es et les relire dans le syst√®me de t√¢ches, il existe √† ces fins des conteneurs.  Ces conteneurs se pr√©sentent sous forme de structures ordinaires et je travaille sur le principe d'un pont par lequel les donn√©es √©l√©mentaires sont synchronis√©es entre les flux. <br><br>  Il existe plusieurs types de conteneurs: <br>  <b>NativeArray</b> .  Le type de conteneur le plus simple et le plus utilis√© est pr√©sent√© comme un tableau simple avec une taille fixe. <br>  <b>NativeSlice</b> .  Un autre conteneur - un tableau, comme il ressort de la traduction, est con√ßu pour couper le NativeArray en morceaux. <br><br>  Ce sont les deux principaux conteneurs disponibles sans connecter de syst√®me <b>ECS</b> .  Dans une version plus avanc√©e, il existe plusieurs autres types de conteneurs. <br><br>  <b>NativeList</b> .  Il s'agit d'une liste r√©guli√®re de donn√©es. <br>  <b>NativeHashMap</b> .  Un analogue d'un dictionnaire avec une cl√© et une valeur. <br>  <b>NativeMultiHashMap</b> .  Le m√™me <b>NativeHashMap</b> avec seulement quelques valeurs sous une seule cl√©. <br>  <b>NativeQueue</b>  Liste des files d'attente de donn√©es. <br><br>  Puisque nous travaillons sans connecter de syst√®me <b>ECS</b> , seuls <b>NativeArray</b> et <b>NativeSlice</b> sont √† <b>notre disposition</b> . <br><br>  Avant de passer √† la partie pratique, il est n√©cessaire d'analyser le point le plus important - la cr√©ation d'instances. <br><br><h3>  Cr√©er des conteneurs </h3><br>  Comme je l'ai dit pr√©c√©demment, ces conteneurs repr√©sentent un pont sur lequel les donn√©es sont synchronis√©es entre les threads.  Le syst√®me de t√¢ches ouvre ce pont avant de commencer le travail et le ferme apr√®s son ach√®vement.  Le processus d'ouverture est appel√© ¬´ <i>allocation</i> ¬ª ( <b>Allocation</b> ) ou <i>¬´allocation de m√©moire¬ª</i> , le processus de fermeture est appel√© ¬´ <i>lib√©ration des ressources</i> ¬ª ( <b>Dispose</b> ). <br><br>  C'est l'allocation qui d√©termine la dur√©e pendant laquelle la t√¢che peut utiliser les donn√©es dans le conteneur - en d'autres termes, la dur√©e pendant laquelle le pont sera ouvert. <br><br>  Afin de mieux comprendre ces deux processus, jetons un ≈ìil √† l'image ci-dessous. <br><br><img src="https://lh4.googleusercontent.com/6yL2x_ynGZj1C1ukkQlfDZuYKzlvJ4ceAYU9Zyb40xwDzuASeUNB__Od067_3xZkYANEOPl84JoKLyqTPn4hrvQNogbksb7akoQvcWjDLg2yyUJY9eF37uj7TO0YkOL3cQyMsXPu" alt="image"><br><br>  La partie inf√©rieure montre le cycle de vie du thread principal (thread <b>principal</b> ), qui est calcul√© en nombre d'images; dans la premi√®re image, nous cr√©ons un autre thread parall√®le ( <b>nouveau thread)</b> qui existe pour un certain nombre d'images, puis se ferme en toute s√©curit√©. <br>  Dans le m√™me <b>nouveau thread, la</b> t√¢che avec le conteneur arrive. <br><br>  Jetez maintenant un coup d'≈ìil en haut de l'image. <br><br><img src="https://lh5.googleusercontent.com/1IZ_CMZhX4JfBWBLEuAijf1st_6e7p96EncPomR_jLNhQVbJDvS_o_-gf1emw3glwEGt8y3xXARp4xJJ9qu0WjYTH4asrblwul2rHa_SqQiLzrTTOoDJ5DlomcPBP8qkfCI3w9R8" alt="image"><br><br>  L' <b>allocation de la</b> barre blanche indique la dur√©e de vie du conteneur.  Dans le premier cadre, le conteneur est <i>allou√©</i> - le pont est ouvert jusqu'√† ce que le conteneur n'existe pas, une fois tous les calculs de la t√¢che termin√©s, le conteneur est lib√©r√© de la m√©moire et dans le 9e cadre, le pont est ferm√©. <br><br>  Sur cette bande ( <b>Allocation</b> ), il y a √©galement des segments temporels ( <b>Temp</b> , <b>TempJob</b> et <b>Presistent</b> ), chacun de ce segment affiche la dur√©e de vie estim√©e du conteneur. <br><br>  Pourquoi ces segments sont-ils n√©cessaires!?  Le fait est que l'ex√©cution d'une t√¢che par dur√©e peut √™tre diff√©rente, nous pouvons les ex√©cuter directement dans la m√™me m√©thode que celle o√π nous l'avons cr√©√©e, ou nous pouvons prolonger le temps d'ex√©cution de la t√¢che si elle est assez compliqu√©e, et ces segments montrent l'urgence et la dur√©e pendant laquelle la t√¢che peut utiliser les donn√©es dans le r√©cipient. <br><br>  <i>Si ce n'est toujours pas clair, j'analyserai chaque type d'allocation √† l'aide d'un exemple.</i> <br><br>  Nous pouvons maintenant passer √† la partie pratique de la cr√©ation de conteneurs, pour cela, nous revenons √† la m√©thode <b>Start</b> du script <b>TestJob</b> et cr√©ons une nouvelle instance du conteneur <b>NativeArray</b> et n'oubliez pas de connecter les biblioth√®ques n√©cessaires. <br><br><h3>  Temp </h3><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; using Unity.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); } }</code> </pre> <br></div></div><br>  Pour cr√©er une nouvelle instance de conteneur, vous devez sp√©cifier la taille et le type d'allocation dans son constructeur.  Cet exemple utilise le type <b>Temp</b> , car la t√¢che sera ex√©cut√©e uniquement dans la m√©thode <b>Start</b> . <br><br>  Maintenant, initialisez la m√™me variable de tableau exacte dans la structure de la t√¢che <b>SimpleJob</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  C'est fait.  Vous pouvez maintenant cr√©er la t√¢che elle-m√™me et lui passer une instance de tableau. <br><br><div class="spoiler">  <b class="spoiler_title">Commencer</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; }</code> </pre> <br></div></div><br>  Pour ex√©cuter la t√¢che cette fois, nous utiliserons son handle <b>JobHandle</b> pour l'obtenir en appelant la m√™me m√©thode <b>Schedule</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Commencer</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); }</code> </pre> <br></div></div><br>  Vous pouvez maintenant appeler la m√©thode <b>Complete</b> sur sa poign√©e et v√©rifier si la t√¢che est termin√©e pour afficher le texte dans la console. <br><br><div class="spoiler">  <b class="spoiler_title">Commencer</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">" "</span></span>); }</code> </pre> <br></div></div><br>  Si vous ex√©cutez la t√¢che sous cette forme, apr√®s avoir d√©marr√© le jeu, vous obtiendrez une grosse erreur rouge indiquant que vous n'avez pas lib√©r√© le conteneur de tableau des ressources une fois la t√¢che termin√©e. <br><br>  Quelque chose comme √ßa. <br><br><img src="https://lh3.googleusercontent.com/EewKhLiPm0_qidpB0-YnlUfbTcIlzOhPw_OXgJqcmm-m9MpAaq96PHSc-FlN7GNArl9JkThBUZEGM9YFIHR5BkkMRUBwTAM6awQAEYGOw45i31irFlXtkT7peTOmjFfoEq_ASONA" alt="image"><br><br>  Pour √©viter cela, appelez la m√©thode <b>Dispose</b> sur le conteneur apr√®s avoir termin√© la t√¢che. <br><br><div class="spoiler">  <b class="spoiler_title">Commencer</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">"Complete"</span></span>); array.Dispose(); }</code> </pre> <br></div></div><br>  Ensuite, vous pouvez le red√©marrer en toute s√©curit√©. <br>  Mais la t√¢che ne fait rien!  - puis ajoutez-y quelques actions. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length; i++) { array[i] = i * i; } } }</code> </pre> <br></div></div><br>  Dans la m√©thode <b>Execute</b> , je multiplie l'index de chaque √©l√©ment du tableau par moi-m√™me et l'√©cris dans le <b>tableau</b> pour imprimer le r√©sultat sur la console dans la m√©thode <b>Start</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Commencer</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(job.array[job.array.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>]); array.Dispose(); }</code> </pre> <br></div></div><br><blockquote>  Quel sera le r√©sultat dans la console si nous imprimons le dernier √©l√©ment du tableau au carr√©? </blockquote><br>  C'est ainsi que vous pouvez cr√©er des conteneurs, les placer dans des t√¢ches et effectuer des actions dessus. <br><br>  Il s'agit d'un exemple utilisant le type d'allocation <b>Temp</b> , ce qui implique de terminer une t√¢che dans un cadre.  Ce type est mieux utilis√© lorsque vous devez effectuer rapidement des calculs sans charger le thread principal, mais vous devez √™tre prudent si la t√¢che est trop compliqu√©e ou s'il y en aura beaucoup, l'affaissement peut se produire, dans ce cas, il est pr√©f√©rable d'utiliser le type <b>TempJob,</b> que <b>j'analyserai</b> plus tard. <br><br><h3>  Tempjob </h3><br>  Dans cet exemple, je <b>modifierai</b> l√©g√®rement <b>la</b> structure de la t√¢che <b>SimpleJob</b> et l'h√©riterai d'une autre interface <b>IJobParallelFor</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  De plus, comme la t√¢che durera plus d'une image, nous ex√©cuterons et collecterons les r√©sultats de la t√¢che dans diff√©rentes m√©thodes <b>Awake</b> et <b>Start</b> pr√©sent√©es sous la forme d'une coroutine.  Pour ce faire, modifiez un peu l'apparence de la classe <b>TestJob</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() {} IEnumerator Start() {} }</code> </pre> <br></div></div><br>  Dans la m√©thode <b>Awake</b> , nous allons cr√©er une t√¢che et un conteneur de vecteurs, et dans la m√©thode <b>Start</b> , sortir les donn√©es re√ßues et lib√©rer les ressources. <br><br><div class="spoiler">  <b class="spoiler_title">√âveill√©</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; }</code> </pre> <br></div></div><br>  L√† encore, un conteneur de <b>tableau</b> est cr√©√© avec le type d'allocation <b>TempJob</b> , apr√®s quoi nous cr√©ons une t√¢che et obtenons son handle en appelant la m√©thode <b>Schedule</b> avec des modifications mineures. <br><br><div class="spoiler">  <b class="spoiler_title">√âveill√©</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) }</code> </pre> <br></div></div><br>  Le premier param√®tre de la m√©thode <b>Schedule</b> indique combien de fois la t√¢che sera ex√©cut√©e, voici le m√™me nombre que la taille du <b>tableau</b> . <br>  Le deuxi√®me param√®tre indique le nombre de blocs √† partager la t√¢che. <br><br>  <i>Quels autres blocs?</i> <br>  Auparavant, pour terminer une t√¢che, un thread appelait simplement la m√©thode <b>Execute</b> une fois, maintenant il est n√©cessaire d'appeler cette m√©thode 100 fois, de sorte que le planificateur divise ces 100 fois de r√©p√©titions en blocs qu'il distribue entre les threads afin de ne pas charger de thread s√©par√©.  Dans l'exemple, une centaine de r√©p√©titions sera divis√©e en 5 blocs de 20 r√©p√©titions chacun, c'est-√†-dire que le planificateur distribuera vraisemblablement ces 5 blocs en 5 threads, o√π chaque thread appellera 20 fois la m√©thode <b>Execute</b> .  En pratique, bien s√ªr, ce n'est pas un fait que le planificateur fera exactement cela, tout d√©pend de la charge de travail du syst√®me, donc peut-√™tre que les 100 r√©p√©titions se produiront dans un seul thread. <br><br>  Vous pouvez maintenant appeler la m√©thode <b>Complete</b> sur le descripteur de t√¢che. <br><br><div class="spoiler">  <b class="spoiler_title">√âveill√©</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  Dans la coroutine <b>D√©marrer</b> , nous v√©rifierons l'ex√©cution de la t√¢che puis nous nettoierons le conteneur. <br><br><div class="spoiler">  <b class="spoiler_title">Commencer</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.isCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Passons maintenant aux actions de la t√¢che elle-m√™me. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) { float x = index; float y = index; Vector2 vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x * x, y * y / (y * <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array[index] = vector; } }</code> </pre> <br></div></div><br>  Apr√®s avoir termin√© la t√¢che dans la m√©thode <b>Start</b> , affichez tous les √©l√©ments du tableau dans la console. <br><br><div class="spoiler">  <b class="spoiler_title">Commencer</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } foreach(Vector2 vector <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array) { print(vector); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Termin√©, vous pouvez ex√©cuter et regarder le r√©sultat. <br><br>  Pour comprendre la diff√©rence entre <b>IJob</b> et <b>IJobParallelFor,</b> jetez un ≈ìil aux images ci-dessous. <br>  Par exemple, dans <b>IJob,</b> vous <b>pouvez</b> utiliser une boucle <b>for</b> simple <b>pour</b> effectuer plusieurs fois les calculs, mais dans tous les cas, un thread ne peut appeler la m√©thode <b>Execute</b> qu'une seule fois pendant toute la dur√©e de la t√¢che - c'est ainsi qu'une seule personne peut effectuer des centaines d'actions identiques dans une rang√©e. <br><br><img src="https://lh3.googleusercontent.com/qUadSqRojz1W8kiqtm-xgi-TYeJ9IlVh38o0MrG0mTWnU3j0qTjtTOWa8pkPc0kjPQcTKoqOJtNl6E4Olb5MKCNgUhrsAXGujN0flm_YVoFfEVS9kCCjFOucANAw74Kjq2W_Zzho" alt="image"><br><br>  <b>IJobParallelFor</b> propose non seulement d'ex√©cuter plusieurs fois une t√¢che dans un thread, mais √©galement de r√©partir ces r√©p√©titions entre d'autres threads. <br><br><img src="https://lh5.googleusercontent.com/-5ggH4tUKWvhz6I8UUi2eGzqY_B_QqA1PA_298vp89xg4v2yC3wn3N9D8TlVOMwWuDM593H_Aw9WZOU-_esyT7vyL4MM17bZaevfiOiYSEUb0I1oT2Fi3cXbBtoc9SuMYIhVnMc7" alt="image"><br><br>  En g√©n√©ral, le type d'allocation <b>TempJob est</b> parfait pour la plupart des t√¢ches qui sont effectu√©es sur plusieurs trames. <br><br>  Mais que se passe-t-il si vous devez stocker des donn√©es m√™me apr√®s avoir termin√© une t√¢che, et si apr√®s avoir re√ßu le r√©sultat, vous n'avez pas besoin de les d√©truire imm√©diatement.  Pour cela, il faut utiliser le type d'allocation <b>Persistant</b> , ce qui implique la lib√©ration des ressources puis ¬´ <i>quand c'est n√©cessaire!¬ª</i>  . <br><br><h3>  Persistant </h3><br>  <b>Revenons</b> √† la classe <b>TestJob</b> et changeons-la.  Nous allons maintenant cr√©er des t√¢ches dans la m√©thode <b>OnEnable</b> , v√©rifier leur ex√©cution dans la m√©thode <b>Update</b> et nettoyer les ressources dans la m√©thode <b>OnDisable</b> . <br>  Dans l'exemple, nous d√©placerons l'objet dans la m√©thode <b>Update</b> , pour calculer la trajectoire, nous utiliserons deux conteneurs vectoriels - <b>inputArray</b> dans lequel nous mettrons la position actuelle et <b>outputArray</b> d'o√π nous recevrons les r√©sultats. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; inputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() {} }</code> </pre> <br></div></div><br>  <b>Nous allons</b> √©galement <b>modifier</b> l√©g√®rement <b>la</b> structure de la t√¢che <b>SimpleJob</b> en l'h√©ritant de l'interface <b>IJob</b> pour l'ex√©cuter une fois. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Dans la t√¢che elle-m√™me, nous trahirons √©galement deux conteneurs vectoriels, un vecteur position et un delta num√©rique, qui d√©placeront l'objet vers la cible. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; inputArray; [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float delta; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Les attributs <b>ReadOnly</b> et <b>WriteOnly</b> affichent les restrictions de flux sur les actions associ√©es aux donn√©es √† l'int√©rieur des conteneurs.  <b>ReadOnly</b> propose le flux uniquement pour lire les donn√©es du conteneur, l'attribut <b>WriteOnly</b> , au contraire, permet au flux d'√©crire uniquement des donn√©es dans le conteneur.  Si vous devez effectuer ces deux actions √† la fois avec un seul conteneur, vous n'avez pas du tout besoin de le marquer avec un attribut. <br><br>  Passons √† la m√©thode <b>OnEnable</b> de la classe <b>TestJob</b> o√π les conteneurs seront initialis√©s. <br><br><div class="spoiler">  <b class="spoiler_title">Onenable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); }</code> </pre> <br></div></div><br>  Les dimensions des conteneurs seront uniques car il n'est n√©cessaire de transmettre et de recevoir des param√®tres qu'une seule fois.  Le type d'allocation sera <b>Persistant</b> . <br>  Dans la m√©thode <b>OnDisable</b> , <b>nous lib√©rerons</b> les ressources des conteneurs. <br><br><div class="spoiler">  <b class="spoiler_title">Ondisable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray.Dispose(); }</code> </pre> <br></div></div><br>  Cr√©ons une m√©thode <b>CreateJob</b> distincte o√π nous allons cr√©er une t√¢che avec son handle et l√† nous la remplirons de donn√©es. <br><br><div class="spoiler">  <b class="spoiler_title">CreateJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateJob() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.delta = Time.deltaTime; Vector2 position = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position; job.position = position; Vector2 newPosition = position + Vector2.right; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; job.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray; job.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  <i>En fait, <b>inputArray</b> n'est pas vraiment n√©cessaire ici, car il est possible de transf√©rer un vecteur de direction uniquement √† la t√¢che, mais je pense qu'il sera pr√©f√©rable de comprendre pourquoi ces attributs <b>ReadOnly</b> et <b>WriteOnly</b> sont n√©cessaires.</i> <br><br>  Dans la m√©thode <b>Update</b> , nous v√©rifierons si la t√¢che est termin√©e, apr√®s quoi nous appliquons le r√©sultat obtenu √† la transformation d'objet et la r√©ex√©cutons. <br><br><div class="spoiler">  <b class="spoiler_title">Mettre √† jour</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position = newPosition; CreateJob(); } }</code> </pre> <br></div></div><br>  Avant de commencer, nous <b>ajusterons</b> l√©g√®rement la m√©thode <b>OnEnable</b> afin que la t√¢che soit cr√©√©e imm√©diatement apr√®s l'initialisation des conteneurs. <br><br><div class="spoiler">  <b class="spoiler_title">Onenable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); CreateJob(); }</code> </pre> <br></div></div><br>  Termin√©, vous pouvez maintenant acc√©der √† la t√¢che elle-m√™me et effectuer les calculs n√©cessaires dans la m√©thode <b>Execute</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Ex√©cuter</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; newPosition = Vector2.Lerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position, newPosition, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.delta); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; }</code> </pre> <br></div></div><br>  Pour voir le r√©sultat du travail, vous pouvez lancer le script <b>TestJob</b> sur un objet et lancer le jeu. <br><br>  Par exemple, mon sprite se d√©place progressivement vers la droite. <br><br><div class="spoiler">  <b class="spoiler_title">L'animation</b> <div class="spoiler_text"><img src="https://lh3.googleusercontent.com/YCf68msYSI0w6ARjOAeAWsPPhpPOrXC-3jWTfqtlnu1pS1xa9m6FCjTD3DdvcvWi5KSEh_-q6X2yUf62j1FOgSU6d0plX603FOQiydF-yLRQFvbd2YBY-mp8I5p5V4cQH9t7SKPR" alt="image"><br></div></div><br>  En g√©n√©ral, le type d'allocation <b>Persistant est</b> id√©al pour les conteneurs r√©utilisables qui n'ont pas besoin d'√™tre d√©truits et recr√©√©s √† chaque fois. <br><br>  <i>Alors quel type utiliser!?</i> <br>  Le type <b>Temp</b> est mieux utilis√© pour effectuer rapidement des calculs, mais si la t√¢che est trop complexe et trop importante, un jeu peut se produire. <br>  Le type <b>TempJob est</b> id√©al pour travailler avec des objets <b>unitaires</b> , vous pouvez donc modifier les param√®tres des objets et les appliquer, par exemple, dans le cadre suivant. <br>  Le type <b>Persistant</b> peut √™tre utilis√© lorsque la vitesse n'est pas importante pour vous, mais vous avez juste besoin de calculer constamment une sorte de donn√©es sur le c√¥t√©, par exemple, traiter des donn√©es sur un r√©seau ou le travail d'une IA. <br><br><div class="spoiler">  <b class="spoiler_title">Invalide et aucun</b> <div class="spoiler_text">  <i>Il existe deux autres types d'allocation <b>Invalid</b> et <b>None</b> , mais ils sont plus n√©cessaires pour le d√©bogage et ne participent pas au travail.</i> <br></div></div><br><br><h3>  Jobhandle </h3><br>  S√©par√©ment, il vaut la peine d'analyser les capacit√©s du descripteur de t√¢che, car en plus de v√©rifier le processus d'ex√©cution des t√¢ches, ce petit descripteur peut toujours cr√©er des r√©seaux entiers de t√¢ches via des d√©pendances (bien que je pr√©f√®re les appeler davantage files d'attente). <br><br>  Par exemple, si vous devez effectuer deux t√¢ches dans une certaine s√©quence, il vous suffit pour cela d'attacher le handle d'une t√¢che au handle d'une autre. <br><br>  Cela ressemble √† ceci. <br><br><img src="https://lh3.googleusercontent.com/K62BSMljveR8lED8wCuCUCuLN6zyNlXS8RQybQuztrT_FMalHHSP7oMGIDf6xUcjXAMqRG3njvHIJ4FPL_tU1uSZr5XQDmCOPyM_YJye2i_z58lIPAkflcia511L2ILI72In61aT" alt="image"><br><br>  Chaque poign√©e individuelle contient initialement sa propre t√¢che, mais lorsqu'elle est combin√©e, nous obtenons une nouvelle poign√©e avec deux t√¢ches. <br><br><div class="spoiler">  <b class="spoiler_title">Commencer</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { Job jobA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleA = jobA.Schedule(); Job jobB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleB = jobB.Schedule(); JobHandle result = JobHandle.CombineDependecies(handleA, handleB); result.Complete(); }</code> </pre> <br></div></div><br>  Ou alors. <br><br><div class="spoiler">  <b class="spoiler_title">Commencer</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); handle = job.Schedule(handle); } handle.Complete(); }</code> </pre> <br></div></div><br>  La s√©quence d'ex√©cution est enregistr√©e et le planificateur ne d√©marrera pas la t√¢che suivante tant qu'il ne sera pas convaincu de la pr√©c√©dente, mais il est important de se rappeler que la propri√©t√© de <b>handle</b> IsCompleted attendra que toutes les t√¢ches soient termin√©es. <br><br><h2>  Conclusion </h2><br><h3>  Conteneurs </h3><br><ol><li>  Lorsque vous travaillez avec des donn√©es dans des conteneurs, n'oubliez pas qu'il s'agit de structures, donc tout √©crasement de donn√©es dans le conteneur ne les modifie pas, mais les cr√©e √† nouveau. </li><li>  <i>Que se passe-t-il si vous d√©finissez le type d'allocation Temp et n'effacez pas les ressources une fois la t√¢che termin√©e?</i>  L'erreur. </li><li>  <i>Puis-je cr√©er mes propres conteneurs?</i>  Il est possible que les unit√©s d√©crivent en d√©tail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le</a> processus de cr√©ation de conteneurs personnalis√©s ici, mais il vaut mieux r√©fl√©chir √† quelques reprises: cela vaut-il la peine, peut-√™tre qu'il y aura suffisamment de conteneurs ordinaires!? </li></ol><br><h4>  La s√©curit√©! </h4><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donn√©es statiques.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N'essayez pas d'utiliser des donn√©es statiques dans une t√¢che ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al√©atoire</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et autres), tout acc√®s aux donn√©es statiques violera la s√©curit√© du syst√®me. En fait, pour le moment, vous pouvez acc√©der aux donn√©es statiques, mais uniquement si vous √™tes s√ªr qu'elles ne changent pas pendant le travail - c'est-√†-dire qu'elles sont compl√®tement statiques et en lecture seule. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quand utiliser le syst√®me de t√¢ches?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tous ces exemples qui sont donn√©s ici dans l'article ne sont que conditionnels et montrent comment travailler avec ce syst√®me, et non quand l'utiliser. Le syst√®me de t√¢ches peut √™tre utilis√© sans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous devez comprendre que le syst√®me consomme √©galement des ressources au travail et que pour une raison quelconque, √©crire imm√©diatement des t√¢ches, cr√©er des tas de conteneurs est tout simplement inutile - tout va encore empirer. Par exemple, recalculer un tableau de 10000 √©l√©ments de taille ne sera pas correct - cela vous prendra plus de temps pour travailler avec le planificateur, mais recalculer tous les polygones d'une √©norme terrane ou m√™me le g√©n√©rer est la bonne solution, vous pouvez diviser la terrane en t√¢ches et les traiter chacune dans un flux s√©par√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En g√©n√©ral, si vous √™tes constamment impliqu√© dans des calculs complexes dans des projets et recherchez constamment de nouvelles opportunit√©s pour rendre ce processus moins gourmand en ressources, alors </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job System</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est exactement ce dont vous avez besoin. </font><font style="vertical-align: inherit;">Si vous travaillez constamment avec des calculs complexes ins√©parables des objets et que vous voulez que votre code fonctionne plus rapidement et soit pris en charge sur la plupart des plates-formes, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous aidera certainement. </font><font style="vertical-align: inherit;">Si vous cr√©ez des projets uniquement pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebGL,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ce n'est pas pour vous, pour le moment le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job System</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne prend pas en charge le travail dans les navigateurs, bien que ce ne soit pas un probl√®me pour les unitecs, mais pour les d√©veloppeurs de navigateurs eux-m√™mes. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://www.google.com/url%3Fq%3D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source avec tous les exemples</font></font></a> <cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420829/">https://habr.com/ru/post/fr420829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420815/index.html">Comment le "d√©codage du monde num√©rique" a explos√©: les 10 meilleurs rapports de DotNext 2018 Piter</a></li>
<li><a href="../fr420819/index.html">Top 10 des outils Python pour l'apprentissage automatique et la science des donn√©es</a></li>
<li><a href="../fr420821/index.html">R√®gle 10: 1 en programmation et en √©criture</a></li>
<li><a href="../fr420825/index.html">Aujourd'hui sera le premier match entre OpenAI et Dota 2 professionnels (personnes gagn√©es). Nous comprenons comment fonctionne le bot</a></li>
<li><a href="../fr420827/index.html">Cr√©ez un projet maven simple √† l'aide de Java EE + WildFly10 + JPA (Hibernate) + Postgresql + EJB + IntelliJ IDEA</a></li>
<li><a href="../fr420831/index.html">Le dispositif pour l'√©mission de cookies "Cook 3000"</a></li>
<li><a href="../fr420833/index.html">Erreurs majeures de mon√©tisation d'applications [et comment les corriger]</a></li>
<li><a href="../fr420837/index.html">Test de matrices RAID logicielles pour les p√©riph√©riques NVMe √† l'aide de la m√©thodologie SNIA</a></li>
<li><a href="../fr420841/index.html">Correctif pr√©-hospitalier ou ¬´Hey Swagger! O√π sont mes erreurs? "</a></li>
<li><a href="../fr420843/index.html">7 septembre, Iekaterinbourg - une r√©union pour les d√©veloppeurs .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>