<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤£ ğŸ’ƒğŸ» ğŸ—ºï¸ C ++ vs C # ğŸ‘‰ ğŸš£ğŸ¿ ğŸ“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout le monde sait qu'il n'y a rien de plus stupide que de discuter Â«quelle langue est meilleureÂ». Par exemple, mieux pour quoi? DiffÃ©rentes langues r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ vs C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469467/"><img src="https://habrastorage.org/webt/ud/4s/-_/ud4s-_jhcan8lv7ei9kfabnsszo.jpeg"><br><br>  Tout le monde sait qu'il n'y a rien de plus stupide que de discuter Â«quelle langue est meilleureÂ».  Par exemple, mieux pour quoi?  DiffÃ©rentes langues rÃ©ussissent dans des crÃ©neaux diffÃ©rents - et il est inutile de tirer des conclusions dÃ©finitives sans en tenir compte. <br><br>  Mais que se passe-t-il si vous vous adressez Ã  des spÃ©cialistes expÃ©rimentÃ©s qui comprennent eux-mÃªmes tout cela et leur demandez d'organiser l'holivar C ++ vs C #?  Il s'avÃ¨re que vous pouvez dÃ©couvrir de nombreux dÃ©tails intÃ©ressants.  Le mot Â«multiplateformeÂ» peut Ãªtre appliquÃ© dans les deux sens aux deux langues, mais qu'est-ce que cela signifie dans la pratique?  Le C ++ se dÃ©veloppe-t-il activement maintenant?  C # a-t-il dÃ©jÃ  rompu la compatibilitÃ© descendante?  Les rÃ©ponses peuvent Ãªtre Ã©videntes pour ceux qui sont dÃ©jÃ  profondÃ©ment immergÃ©s dans les deux langues Ã  la fois, mais il y en a peu - et tout le monde apprendra quelque chose de nouveau. <br><br>  Du C ++, <b>Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">sermp</a> Platonov</b> , prÃ©sident du comitÃ© de programme de la confÃ©rence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ Russie</a> , a participÃ©.  Le cÃ´tÃ© C # Ã©tait reprÃ©sentÃ© par <b>Anatoly Kulakov</b> - il est inclus dans le PC de la confÃ©rence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DotNext</a> , et parmi les dirigeants de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DotNetRu</a> .  Et le leader de la discussion, dans la vie de laquelle ces deux mondes coexistent, Ã©tait <b>Dmitry <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">mezastel</a> Nesteruk</b> . <br><br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/sn/rb/_i/snrb_ie2-dnmplhnbfnl_klnvca.jpeg"><br><br>  <b>Dmitry:</b> Bonjour, chers collÃ¨gues.  Bienvenue aux rencontres informelles sur le thÃ¨me des langages de programmation.  Sur Internet, il nous est constamment rappelÃ© que les langues ne sont pas comparables.  Et aujourd'hui, nous ferons exactement ce que vous ne pouvez pas faire: comparer C ++ avec C # et .NET, leurs avantages et leurs inconvÃ©nients.  PrÃ©sentez-vous s'il vous plaÃ®t. <br><br>  <b>Anatoly:</b> Je m'appelle Anatoly, et aujourd'hui je vais me noyer pour C #, car j'ai Ã©tudiÃ© ce langage depuis ses premiÃ¨res versions et, semble-t-il, je sais tout Ã  son sujet. <br><br>  <b>Sergey:</b> Salut, je m'appelle Sergey, je vais me noyer pour C ++ aujourd'hui.  Dima a correctement dit que nous comparerons les avantages et les inconvÃ©nients.  Tout le monde l'appelle "Pros", on sait que, il s'avÃ¨re que C # dans cette discussion sera un inconvÃ©nient.  Est-ce vrai, Anatoly? <br><br>  <b>Anatoly:</b> C # a deux autres avantages!  Par consÃ©quent, je pense qu'il s'agit d'un dÃ©veloppement Ã©volutif des avantages qui sont dÃ©jÃ  obsolÃ¨tes et ne sont pas en mesure de rivaliser presque partout. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/wy/sj/_pwysj2lxe1ncg6lmuzqxfs2dg0.jpeg"></div><br><br><h2>  L'Ã©ducation </h2><br>  <b>Dmitry:</b> J'ai le premier sujet de notre discussion.  Imaginez que de nouveaux Ã©tudiants viennent Ã  l'universitÃ©, ils ont besoin de la premiÃ¨re langue.  Selon vous, quel devrait Ãªtre le premier langage que les gens obtiennent au cours de leur premiÃ¨re annÃ©e: C ++, C # ou assembleur en gÃ©nÃ©ral? <br><br>  <b>Sergey:</b> J'ai enseignÃ© pendant un certain temps, donc j'ai une opinion bien Ã©tablie.  Je comprends qu'ici nous allons discuter du langage qui est le meilleur, et je reprÃ©sente C ++ ... Mais pour apprendre le C ++, vous devez comprendre l'architecture de l'ordinateur.  Et avec cela, le gros problÃ¨me de l'enseignement aux Ã©tudiants (du moins dans l'universitÃ© oÃ¹ j'ai enseignÃ©).  Et pour enseigner les algorithmes et autres choses, vous avez probablement besoin de quelque chose qui ne se concentre pas sur l'infrastructure, dans le langage lui-mÃªme.  Ici, Eiffel a tentÃ© de le faire, mais il y a aussi beaucoup de magie.  Par consÃ©quent, je dirais qu'aucune de nos deux langues ne convient. <br><br>  La programmation est diffÃ©rente, et ce n'est pas la Â«programmationÂ» qui enseigne, mais les algorithmes, les structures de donnÃ©es, etc.  Il est possible qu'il soit judicieux de choisir votre propre instrument sur chaque sujet.  Comprendre une sorte de structures de donnÃ©es Lisp.  Et le C ++, en consÃ©quence, devrait Ãªtre donnÃ© aprÃ¨s que les Ã©tudiants ont compris quelque chose sur l'architecture.  Et puis il sera possible de comprendre pourquoi toute cette douleur et cette souffrance.  Je ne dirai mÃªme pas que les avantages concernent la douleur. <br><br>  <b>Anatoly:</b> Oui, je suis tout Ã  fait d'accord pour dire qu'il faut sÃ©parer les objets, ne pas les mettre en Â«programmationÂ» et tout marteler dans une langue.  Mais si vous arrivez au point oÃ¹ vous avez appris les bases, les principes de base, les algorithmes et commencez Ã  choisir une sorte de langage industriel, alors, bien sÃ»r, C # sera bien meilleur.  Parce que cela ne vous oblige pas Ã  apprendre toutes ces lies au niveau des architectures, des octets de mÃ©moire et autres Â«couchers de soleil Ã  la mainÂ».  Il donne un langage immÃ©diatement comprÃ©hensible, une syntaxe simple, et dans cette langue dÃ¨s la premiÃ¨re ou la deuxiÃ¨me annÃ©e, vous pouvez gagner de l'argent assez tangible. <br><br>  <b>Dmitry:</b> Il y a un argument selon lequel ne pas donner aux Ã©tudiants dÃ©butants des choses comme des pointeurs est une sorte de sacrilÃ¨ge.  Ils auront un Ã©norme trou si une personne ne comprend pas que, par exemple, un lien n'est en fait que l'adresse d'une variable en mÃ©moire.  Qu'en pensez-vous? <br><br>  <b>Anatoly:</b> il y a 20 ans, c'Ã©tait vrai lorsque les ordinateurs n'avaient pas assez de mÃ©moire, pas assez de disques et d'autres choses.  Regardez maintenant ces javascripts, ils font glisser 500 mÃ©gaoctets de bibliothÃ¨ques dans chaque "bonjour".  Combien prennent-ils en mÃ©moire?  Quelle est leur performance?  Quels sont les liens lÃ -bas?  Oui, personne ne s'en soucie.  L'essentiel est de rouler rapidement et de sortir quelque chose en production.  Je ne prÃ©tends pas que c'est une bonne ou une bonne faÃ§on, je soutiens qu'il est nÃ©cessaire de changer avec les rÃ©alitÃ©s.  Peut-Ãªtre que maintenant, le montant de votre lien n'est plus si important. <br><br>  <b>Sergey:</b> Probablement selon oÃ¹.  Autant que je sache, Dmitry Ã©tait intÃ©ressÃ© par le trading algorithmique - je peux imaginer clairement comment il rÃ©cupÃ¨re les bibliothÃ¨ques sur JS pour envoyer une commande Ã  la bourse. <br><br>  <b>Dmitry:</b> Eh bien, oui, bien sÃ»r, dans la pratique, personne n'y utilise des langues de ce type.  Bien que cela soit thÃ©oriquement possible: n'oublions pas que de l'argent non faible est injectÃ© dans l'infrastructure JS.  Des moteurs qui font de la compilation JS n'importe quoi et n'importe quoi.  Beaucoup considÃ¨rent cette langue comme la langue de premiÃ¨re classe pour tout en gÃ©nÃ©ral. <br><br>  Naturellement, le trading algo est dÃ©sormais une discipline Ã©loignÃ©e d'une telle discipline, mais le trading algo et les mathÃ©matiques financiÃ¨res dans leur ensemble sont gÃ©nÃ©ralement un domaine spÃ©cifique.  Il prÃ©domine juste en C ++.  Et il prÃ©domine en partie Ã  cause de l'inertie, simplement pour des raisons historiques: au dÃ©but, tout le monde Ã©tait en C ++, et ce domaine est conservateur. <br><br>  <b>Sergey:</b> Je ne suis pas d'accord.  Je travaille maintenant dans la fintech, et des collÃ¨gues qui sont ici depuis le tout dÃ©but du trading algorithmique parlent des grandes entreprises qui ont Ã©crit pour la premiÃ¨re fois en Java.  Au dÃ©but, Java a fait face au trading algorithmique, mais lorsque le marchÃ© a commencÃ© Ã  croÃ®tre et que les concurrents avec C ++ sont apparus, Ã  un moment donnÃ©, ils ne pouvaient tout simplement pas le faire, ils n'ont pas rÃ©ussi Ã  tout faire efficacement ... Donc, tout le monde dans le trading algorithmique n'a pas commencÃ© avec C ++.  Seuls ceux qui n'y ont pas Ã©crit sont morts.  Une telle sÃ©lection naturelle. <br><br>  <b>Dmitry:</b> En fait, vous pouvez l'Ã©largir.  Il existe de nombreux exemples oÃ¹ mÃªme les grandes banques conservent leurs algorithmes dans un document Excel.  Ils utilisent ensuite Excel Ã©galement comme serveur pour calculer tout cela.  Il y a des freins infernaux, mais tout dÃ©pend si vous faites du trading Ã  haute frÃ©quence (ou gÃ©nÃ©ralement quelque chose de haute frÃ©quence).  Si vous Ãªtes un market maker, il est naturel que vous ayez besoin de hautes performances, et lÃ -bas, l'entreprise ne se limite mÃªme pas au C ++, on passe au matÃ©riel et aux langages HDL. <br><br>  Mais notre discussion ne porte pas seulement sur le trading algorithmique, mais aussi sur des choses simples.  Ici, je donne un exemple.  Dans le cadre de la construction, j'avais besoin d'Ã©crire plusieurs petites applications calculant diffÃ©rentes choses: par exemple, comment poser des briques autour du contour d'une maison.  Et je peux Ã  peine imaginer comment faire de telles choses en C ++, car tout ce qui concerne l'interface utilisateur y est plus faible.  Il n'y a qu'un seul framework, Qt, et mÃªme Ã©crire dessus est trÃ¨s difficile.  Et si je m'assois pour C #, pour WinForms, alors je fais juste instantanÃ©ment l'application. <br><br>  <b>Anatoly:</b> Eh bien, la partie visuelle a toujours Ã©tÃ© une force de C #.  Microsoft a beaucoup investi dans les moules, et mÃªme dans les moules multiplateformes, et en gÃ©nÃ©ral dans la visualisation.  Par consÃ©quent, si nous parlons d'applications de bureau visuelles, il me semble que les avantages sont gÃ©nÃ©ralement loin derriÃ¨re. <br><br>  <b>Sergey:</b> Eh bien, cela dÃ©pend, comme toujours.  Je n'aime vraiment pas l'interface utilisateur, mais sur les points positifs, je dois constamment le faire.  Il semblerait apporter JS et simplement interagir avec les pros.  Mais j'ai travaillÃ© avec embarquÃ©, et lÃ  c'est difficile.  Les gens ont achetÃ© une sorte de moteur rapide et cher, mais il ne pouvait toujours pas faire face au rendu normal de l'interface utilisateur Ã©crite en JS.  Et aprÃ¨s avoir rÃ©Ã©crit tout cela sur Qt, il s'est avÃ©rÃ© overclocker.  Histoire ordinaire. <br><br><img src="https://habrastorage.org/webt/kc/9t/uf/kc9tufwhjjwnla-uga_j8abdwqg.jpeg"><br><br><h2>  Multiplateforme vs multiplateforme </h2><br>  <b>Sergey:</b> Je voulais clarifier ici.  Je ne connais pas grand-chose au C #, je l'ai touchÃ© moi-mÃªme il y a trÃ¨s longtemps, dans les toutes premiÃ¨res versions (Ã  l'Ã©poque j'Ã©tais en rupture de compatibilitÃ© descendante).  La question est donc la suivante: est-il toujours dÃ©veloppÃ© uniquement par Microsoft? <br><br>  <b>Anatoly:</b> Non, il est maintenant multiplateforme, ouvert et vÃ©rifiÃ© sous ISO (ECMA-334 et ISO / IEC 23270).  Soit dit en passant, pour autant que je sache, C ++ n'a toujours pas de spÃ©cification ISO ouverte, seulement payÃ©.  Et C #, en revanche, est complÃ¨tement ouvert.  DÃ©veloppÃ© par de nombreuses entreprises (dont Google, Amazon et Samsung), nous avons la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fondation .NET</a> .  Je ne connais mÃªme plus de langage plus ouvert que C # et sa plate-forme .NET. <br><br>  <b>Sergey:</b> Eh bien, Haskell. <br><br>  <b>Anatoly:</b> Au fait, l'auteur de Haskell travaille chez Microsoft Research et a fait beaucoup d'efforts pour faire apparaÃ®tre toutes sortes de choses sympas en C # - par exemple, un contrÃ´le statique, une sorte de rÃ©flexion, dont vous ne pouvez probablement mÃªme pas rÃªver. <br><br>  <b>Sergey:</b> Ils peuvent rÃªver, et mÃªme le travail se poursuit dans ce sens.  Mais il est clair que tout a son propre prix.  En C ++, ils refusent simplement de payer ce prix. <br><br>  <b>Anatoly:</b> Lequel?  Ils sont compilÃ©s pendant deux heures, quel pourrait Ãªtre le prix d'autre? <br><br>  <b>Sergey:</b> En C ++, le principe de l'abstraction Ã  coÃ»t nul.  Eh bien, c'est-Ã -dire qu'une machine virtuelle n'est pas une abstraction Ã  coÃ»t nul, non?  Nous devons accepter cela. <br><br>  <b>Dmitry:</b> Eh bien, mais une machine virtuelle peut, par exemple, masquer du code pour une architecture particuliÃ¨re.  Alors qu'en C ++, si j'utilise l'instruction AVX sur un ordinateur sans AVX, mon processus s'arrÃªte simplement.  Je dirais que cet argument n'est pas tout Ã  fait correct, car thÃ©oriquement - j'insiste, thÃ©oriquement - JIT peut faire ce que le C ++ n'est pas disponible.  A savoir, l'optimisation au moment du lancement. <br><br>  <b>Sergey:</b> Mais en C ++, lors de la compilation, vous pouvez contrÃ´ler complÃ¨tement les instructions dont vous avez besoin.  Dans ce cas, vous ne le contrÃ´lez pas avec vos mains, mais vous abandonnez l'instrument (compilateur).  Regardez, quelles instructions sont sur cette architecture, quel ensemble d'instructions ... <br><br>  <b>Dmitry:</b> C'est comprÃ©hensible.  Mais vous pouvez le formuler de cette faÃ§on: puisqu'il y a un million de plateformes, nous n'obtiendrons jamais aucune sorte d'idÃ©al, car nous ne pouvons pas publier un million de versions avec des drapeaux de compilation diffÃ©rents.  Non?  Nous publions gÃ©nÃ©ralement x86 et x64, mais ne les dÃ©composons pas tous en certains sous-groupes. <br><br>  <b>Sergey:</b> Pourquoi ne pouvons-nous pas?  XXI siÃ¨cle.  Tenez Docker avec diffÃ©rents paramÃ¨tres, c'est tout. <br><br>  <b>Dmitry:</b> Quand nous avons un client final qui tÃ©lÃ©charge notre application, il veut tÃ©lÃ©charger un binaire spÃ©cifique.  Et dans ce binaire, le mieux que nous puissions faire est de rester partout si.  Comme "si cpuid est tel ou tel et que le support avx est tel ou tel, alors nous utilisons l'algorithme version 25".  Par consÃ©quent, nous avons besoin de 25 versions diffÃ©rentes du mÃªme algorithme, car l'accÃ©lÃ©ration dÃ©pend des plates-formes, elle dÃ©pend de la plate-forme. <br><br>  <b>Sergey:</b> Je suis probablement d'accord.  C'est juste que, pour Ãªtre honnÃªte, je n'ai jamais crÃ©Ã© de produit non interne.  Je travaille principalement dans des entreprises qui utilisent elles-mÃªmes leur produit. <br><br>  <b>Dmitry:</b> Eh bien, bien sÃ»r, la meilleure option est lorsque vous connaissez de faÃ§on prÃ©visible l'architecture.  Dans ce cas, Ã  strictement parler, personne ne vous oblige Ã  utiliser des instructions x86 du tout.  Vous pouvez prendre une carte spÃ©cifique (par exemple, Nvidia Tesla) et faire ce que vous voulez.  C'est aussi mon approche, je contrÃ´le mon architecture.  Mais lorsque vous prenez des dÃ©cisions de marchÃ© de masse pour l'utilisateur ... Si vous prenez du ReSharper conditionnel, il ne peut pas simplement prendre et utiliser l'accÃ©lÃ©ration GPU pour des indices arbitraires.  Parce que l'accÃ©lÃ©ration GPU n'est pas une chose portable. <br><br>  <b>Sergey:</b> En fait, il y a des approches (maintenant vous n'avez probablement pas besoin d'entrer dans les dÃ©tails), il y a des gars intÃ©ressants (l'auteur de l'approche, semble-t-il, est maintenant Ã©galement passÃ© Ã  Microsoft).  Lors de notre confÃ©rence de l'annÃ©e derniÃ¨re, il y avait un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> sur la faÃ§on d'Ã©crire un tel programme, qui lui-mÃªme comprendra oÃ¹ il se trouve (relativement facile, encore une fois, des abstractions Ã  coÃ»t nul).  Pour que vous puissiez choisir Ã  la volÃ©e et, le cas Ã©chÃ©ant, reconstruire correctement le code dans un style CUDA ... <br><br>  <b>Dmitry:</b> En fait, CUDA lui-mÃªme essaie de rÃ©soudre ce problÃ¨me, car dans CUDA, il existe une certaine couche intermÃ©diaire de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PTX</a> qui s'occupe de cela.  Mais cela reste trÃ¨s difficile, car le fer change radicalement Ã©volutivement, et il est trÃ¨s difficile de le suivre du tout.  Et si nous examinons l'utilisation de l'accÃ©lÃ©ration GPU, par exemple, dans les produits Adobe, ils utilisent une section trÃ¨s Ã©troite des technologies disponibles.  Si votre carte est correcte - alors oui, tout le sera.  Mais si c'est un peu exotique, rien n'est garanti Ã  cet Ã©gard. <br><br>  <b>Anatoly:</b> Dans cette discussion, nous avons abordÃ© un sujet assez important, un tel mythe: C ++ a Ã©tÃ© dÃ©clarÃ© il y a de nombreuses annÃ©es comme un langage multiplateforme, mais pour le moment, la multiplateforme est beaucoup plus en C #.  Un seul et unique binaire fonctionne partout oÃ¹ .NET est pris en charge, et c'est presque partout. <br><br>  <b>Sergey:</b> Eh bien, c'est aussi assez infondÃ©.  En tant que personne qui a passÃ© la majeure partie de ma vie dans le domaine de l'intÃ©gration, j'ai rarement vu .NET Ãªtre pris en charge par la chaÃ®ne d'outils du fabricant de matÃ©riel.  Les entreprises qui produisent du fer prennent le mÃªme G ++ ou Clang ou lui font commencer Ã  gÃ©nÃ©rer du code pour leur plate-forme. <br><br>  <b>Dmitry:</b> Oui, mais le problÃ¨me est que chaque fois qu'ils font cela, ils perdent quelque chose de C ++.  Par exemple, Nokia a utilisÃ© une variante de C ++, mais leur C ++ Ã©tait avec des rebondissements et des API folles qui ont rendu tout le monde furieux.  Autrement dit, ce n'est pas seulement C ++, mais C ++ pour l'une ou l'autre plate-forme.  Et puis les problÃ¨mes commencent.  Par exemple, prenez le mÃªme CUDA.  C'est comme si elle devait simplement laisser passer les pros elle-mÃªme; ce n'est pas du tout un compilateur, mais juste un pilote.  Mais malgrÃ© cela, elle a des problÃ¨mes avec le fait qu'elle utilise toujours une sorte de cadre pour dÃ©chirer les fichiers CUDA en parties GPU et CPU.  Et parfois, elle ne rÃ©ussit pas. <br><br>  <b>Sergey:</b> Je ne voulais pas dire Ã§a un peu.  C'est juste que lorsque j'entends Â«.NET s'exÃ©cute partoutÂ», la plupart de ma biographie de travail se dÃ©tend.  Lorsque vous achetez un matÃ©riel avec un processeur personnalisÃ©, il est livrÃ© avec la livraison G ++.  Et il y a le C ++ ordinaire, que G ++ peut convertir de la chaÃ®ne d'outils en code machine pris en charge par ce processeur particulier. <br><br>  <b>Dmitry:</b> Mais encore une fois, cela doit Ãªtre remontÃ© ... <br><br>  <b>Sergey:</b> Bien sÃ»r. <br><br>  <b>Dmitry:</b> Et l'idÃ©e que nous prenons un code plus existant et le faisons glisser sur un morceau de fer - cette idÃ©e ne fonctionne pas non plus, car tout Ã  coup, vous avez fait glisser votre x86 normal quelque part, oÃ¹ vous avez 8 gigaoctets de mÃ©moire pour tout sur tout, et ce n'est pas dÃ©velopper: par exemple, il n'y a pas d'Ã©change sur le disque, car il n'y a pas de disque et n'y accÃ©dez pas.  C'est si nous parlons de portabilitÃ©.  Cela dÃ©pend des objectifs, naturellement. <br><br>  <b>Anatoly: les</b> pros travaillent sur plus d'appareils et, bien sÃ»r, l'embarquÃ© est l'une des parties les plus solides.  Mais gÃ©nÃ©ralement, vous devez en quelque sorte adapter votre code Ã  la plate-forme.  C'est mauvais.  Je peux couvrir un grand nombre de plateformes, architectures, modÃ¨les avec un seul code.  Sur les points positifs, je devais penser Ã  chaque plate-forme individuelle: oÃ¹ elle commencerait lÃ , et dans quelles conditions.  Et c'est trÃ¨s mauvais, c'est trÃ¨s retenu. <br><br><img src="https://habrastorage.org/webt/f1/wn/1z/f1wn1zxi80gplsj3bpidl9fpr1i.jpeg"><br><br><h2>  StabilitÃ©, compatibilitÃ©, dÃ©veloppement du langage </h2><br>  <b>Dmitry: Des</b> abstractions Ã  coÃ»t nul ont Ã©galement Ã©tÃ© mentionnÃ©es, mais le problÃ¨me est que cela a un prix Ã©norme.  Par exemple, dans .NET, il existe un concept de type Ã©numÃ©rÃ© et une interface IEnumerable.  Et pour chaque type, par exemple, un tableau, vous pouvez prendre et parcourir un itÃ©rateur.  Mais en C ++, une telle idÃ©e n'existe pas.  En raison de l'abstraction Ã  coÃ»t nul, pour contourner la collection, il y a un couple de dÃ©but () et de fin (), il y a des rÃ¨gles pour leur travail, et tout cela est beaucoup plus compliquÃ© (surtout pour ceux qui commencent Ã  programmer).  C'est un problÃ¨me direct: comment contourner un tableau de A Ã  Z. <br><br>  <b>Sergey:</b> Si je comprends bien de quoi vous parlez ... Si vous avez juste besoin de faire le tour d'un conteneur du dÃ©but Ã  la fin, il vous suffit maintenant d'Ã©crire, comme dans certains Python. <br><br>  <b>Dmitry:</b> Tout cela est merveilleux.  Mais vous, par exemple, n'utilisez pas le polymorphisme pour cela.  On ne peut pas dire qu'ici j'ai une fonction qui reÃ§oit une certaine valeur, qui est Ã©numÃ©rÃ©e a priori.  Vous ne pouvez pas dire que j'ai une valeur qui implÃ©mente l'interface, et cette interface a un itÃ©rateur, par exemple. <br><br>  <b>Sergey:</b> Nous parlons de quel C ++?  Ã€ propos de C ++ en gÃ©nÃ©ral, C ++ du futur, C ++, qui sont maintenant acceptÃ©s comme standard? <br><br>  <b>Dmitry:</b> Eh bien, si dans le futur, ce sera ... <br><br>  <b>Sergey:</b> En C ++ 20, c'est dÃ©jÃ  lÃ .  Vous pouvez dÃ©jÃ  dire, vous pouvez mÃªme vous dÃ©clarer.  Ce ne sont pas des interfaces, mais, comment le dire correctement ... En gÃ©nÃ©ral, vous pouvez dÃ©clarer que votre type doit remplir telle ou telle condition.  Par exemple, il a dÃ©but et fin, qui renvoient un itÃ©rateur.  Et un itÃ©rateur est un tel concept prÃ©parÃ© dans la bibliothÃ¨que standard.  Il dit ce que c'est, dÃ©crit.  Les itÃ©rateurs sont Ã©galement diffÃ©rents.  En gÃ©nÃ©ral, nous essayons, nous le rendons plus pratique pour les gens. <br><br>  <b>Dmitry:</b> Il me semble que cela est nÃ© du fait que les gens viennent de rÃ©aliser qu'il est difficile de vivre sans les concepts d'itÃ©rable d'un objet.  Parce qu'il n'est pas clair comment Ã©crire des choses gÃ©nÃ©ralisÃ©es.  Oui, l'abstraction Ã  coÃ»t nul signifie que nous n'avons pas le coÃ»t de parcourir la v-table lors de la recherche ... Dans .NET, il n'y a qu'une mÃ©thode spÃ©cifique, par exemple.  Et nous, pour le trouver, naturellement, devons dÃ©penser des efforts, ce que les avantages refusent.  Mais du point de vue de l'utilisabilitÃ©, le rÃ©sultat final n'est pas si bon, je dirais. <br><br>  <b>Sergey:</b> Naturellement, il doit y avoir un Ã©quilibre.  Vous ne pouvez pas tout avoir Ã  la fois. <br><br>  <b>Anatoly:</b> Cela vous fait vous demander combien d'annÃ©es se sont Ã©coulÃ©es.  Les langages alternatifs Ã©voluent, et en eux de telles choses fondamentales apparaissent dÃ¨s le dÃ©but.  Maintenant, ils rattrapent quelque chose de plus substantiel et intÃ©ressant.  Et les avantages reposent pendant dix ans avec la mÃªme syntaxe incomprÃ©hensible, des abstractions obscures, des bÃ©quilles incomprÃ©hensibles et sous-dÃ©veloppÃ©es.  Vous pouvez mettre cela comme l'un des inconvÃ©nients. <br><br>  <b>Sergey:</b> Eh bien, allez!  Que signifie Â«peu dÃ©veloppÃ©Â»? <br><br>  Vous avez mentionnÃ© un comitÃ© - C ++ a Ã©galement un comitÃ© ISO qui le dÃ©veloppe.  Il y a des reprÃ©sentants, y compris Microsoft, qui se noient fortement du fait que "vous ne pouvez pas faire cela, car nous avons beaucoup d'hÃ©ritage que nous devons soutenir."  Seul C ++ est le langage dÃ©jÃ  utilisÃ©.  Et, bien sÃ»r, il marche trÃ¨s prudemment.  L'une des tÃ¢ches principales (qui avait dÃ©jÃ  Ã©tÃ© dÃ©clarÃ©e par Straustrup lors de la crÃ©ation) est la compatibilitÃ© avec C. Mais maintenant C a mÃªme Ã©voluÃ© assez loin, vous devez dÃ©signer avec quel C est compatible. <br><br>  Et Ã  mon avis, maintenant C ++ se dÃ©veloppe Ã  un rythme formidable.  En ce qui concerne les concepts et ainsi de suite - en fait, tout naÃ®t, bien sÃ»r, pas de l'itÃ©rabilitÃ©.  En fait, le dÃ©veloppement suit ce que Alexander Stepanov a Ã©galement dÃ©crit - l'un des auteurs de ce que nous appelons maintenant la Â«programmation gÃ©nÃ©ralisÃ©eÂ», la personne qui a rÃ©ellement fait glisser des modÃ¨les, des gÃ©nÃ©riques, etc. en C ++.  Pour Ãªtre honnÃªte, je ne sais pas Ã  quel point le comitÃ© sâ€™inspire de ces idÃ©es, mais il me semble quâ€™il y a certainement une certaine intersection avec elles. <br><br>  <b>Anatoly:</b> Il semble que toutes ces mÃ©taclasses, itÃ©rateurs sont vraiment une inspiration, ce qui Ã©tait dÃ©jÃ  il y a plusieurs dÃ©cennies.  MÃªme si vous prenez la mÃ©taprogrammation, les modÃ¨les, les macros - toutes ces personnes ont longtemps expÃ©rimentÃ©, moudre, et il existe des concepts beaucoup plus simples, Ã©vidents et comprÃ©hensibles.  Dans d'autres langues, tout cela est fait un million de fois mieux et plus rapidement, avec la sÃ©curitÃ© des types, la vÃ©rification du temps de compilation, etc. <br><br>  <b>Sergey:</b> Attendez, vous parlez dÃ©jÃ  de quelque chose que tout le monde n'est pas prÃªt Ã  payer.  Je ne veux pas que mon programme vÃ©rifie quelque chose lors de la compilation Ã  mon insu.  Tu comprends? <br><br>  <b>Anatoly:</b> Je pense que tout cela avec des drapeaux peut Ãªtre configurÃ©.  Vous dÃ©finissez le niveau d'optimisation et il vous vÃ©rifie ou non.  Ce n'est pas un problÃ¨me. <br><br>  <b>Sergey:</b> Souvent, vous devez tout contrÃ´ler avec vos mains.  Sachez exactement ce qui se passe.  Parce que les outils - enfin, Ã§a. <br><br>  <b>Dmitry:</b> Il ne s'agit mÃªme pas d'outils.  Voici le fait que des langages comme D et Rust, disent, disent: eh bien, oui, il y a une telle chose que lorsque vous accÃ©dez Ã  un Ã©lÃ©ment de tableau, vous pouvez le vÃ©rifier, mais vous ne pouvez pas le vÃ©rifier.  Et ils le donnent juste Ã  l'utilisateur, c'est-Ã -dire que vous pouvez dire Â«mais dÃ©sactivons les vÃ©rifications de tableauÂ», Â«mais activons-leÂ».  Autrement dit, une sorte de contrÃ´le Ã  cet Ã©gard. <br><br>  <b>Sergey:</b> Ce n'est pas clair quand vous avez dangereux et dangereux, comme dans Rust, je ne vois pas la diffÃ©rence avec C, par exemple, dans ce cas. <br><br>  <b>Anatoly:</b> La diffÃ©rence est que vous pouvez Ã©crire en toute sÃ©curitÃ© et que vous pouvez Ã©crire rapidement.  Et en C, vous devez Ã©crire dangereusement.  Eh bien, oui, peut-Ãªtre vite.  La stabilitÃ© est parfois plus importante que la vitesse. <br><br>  <b>Dmitry:</b> En fait, si nous commenÃ§ons Ã  creuser ce sujet avec de nouveaux langages, en C ++ il y a des choses qui sont gÃ©nÃ©ralement trÃ¨s difficiles Ã  transmettre aux gens.  Une question simple: quelle taille est int?  Dans la plupart des langues, vous connaissez la rÃ©ponse Ã  cette question.  Vous dites: int est 32 bits.  Mais vous ne connaissez pas les pros.  Vous connaissez la taille de votre ordinateur en particulier parce que vous vous en souvenez, mais Ã  strictement parler, vous ne voulez mÃªme pas utiliser les types de base car ils ne sont pas dÃ©terministes.  Et de telles choses me rendent furieux quand il existe un ensemble d'approches hÃ©ritÃ©es comme l'int. Sera diffÃ©rent sur diffÃ©rentes plates-formes.  Et maintenant, nous comprenons dÃ©jÃ  que cela ne peut pas Ãªtre fait.  Pourquoi ne pas aller plus loin et rÃ©soudre ce problÃ¨me? <br><br>  <b>Sergey:</b> Eh bien, c'est dÃ©cidÃ©.  Il existe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MST</a> , les types requis avec une longueur fixe.  Maintenant, le reprÃ©sentant de la Russie au comitÃ© fait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">glisser un</a> entier de longueur variable (enfin, encore une fois, avec une abstraction Ã  coÃ»t nul). <br><br>  <b>Anatoly:</b> Est-ce que je me souviens bien qu'il existe mÃªme une taille non dÃ©terministe d'un pointeur vers une mÃ©thode?  Autrement dit, sous diffÃ©rents compilateurs et diffÃ©rentes plates-formes, les pointeurs sont diffÃ©rents? <br><br>  <b>Sergey:</b> Naturellement, c'est de l'architecture.  Lorsque vous Ãªtes proche du matÃ©riel, comment pouvez-vous garantir la taille du pointeur, si vous Ãªtes sur 8 bits, puis sur 64 bits? <br><br>  <b>Anatoly:</b> Et comment peut-on faire de l'arithmÃ©tique sur des pointeurs aprÃ¨s Ã§a?  C'est fou. <br><br>  <b>Sergey: Je</b> veux dire?  Eh bien, soigneusement. <br><br>  <b>Anatoly:</b> Je vois.  L'approche est claire partout, contrÃ´lant soigneusement tout avec des poignÃ©es. <br><br>  <b>Sergey:</b> Eh bien, oui.  Encore une fois, dans les normes C ++ modernes, des approches sont dÃ©veloppÃ©es ... Si nous parlons du choix, alors dans les avantages modernes, en fait, il y a le choix d'utiliser le garbage collector.  C'est juste que GC est construit lÃ -bas sur des compteurs de rÃ©fÃ©rence. <br><br>  En gÃ©nÃ©ral, selon vos mots, chers collÃ¨gues, je pense, dÃ©solÃ©, que vous n'avez pas mis Ã  jour vos connaissances sur les avantages modernes depuis longtemps. <br><br>  Maintenant, des gens comme Straustrup, qui font partie du panthÃ©on des dieux plus, viennent avec beaucoup d'appels pour comprendre comment enseigner le C ++ moderne.  Le problÃ¨me est ce que les gens pensent dans les catÃ©gories C ++ 2003 et enseignent dans les mÃªmes catÃ©gories.  Et en relation avec cela, il y a de nouveaux projets et approches intÃ©ressants, il y a des cours modernes - disons que les gars de Yandex ont fait un merveilleux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cours</a> .  Et maintenant, dans les avantages, il est considÃ©rÃ© comme une mauvaise faÃ§on, par exemple, d'utiliser purement nouveau et supprimer. <br><br>  <b>Dmitry:</b> Quant Ã  votre commentaire sur la mise Ã  jour des connaissances ... La nuance est que mon approche, par exemple, est d'utiliser le petit delta C ++, qui est garanti de fonctionner pour moi et avec lequel je suis "ami".  Vous voyez, C ++ est Ã©tendu.  Il y a une mÃ©taprogrammation de modÃ¨le, et tout irait bien, il y a beaucoup de magie, mais, malheureusement, cette magie est illisible.  Il s'agit d'un code dans lequel un non-auteur ne peut pas le comprendre sans aucune connaissance particuliÃ¨re, dans un sens une boÃ®te noire.  Et il y a beaucoup de ces boÃ®tes noires chez les pros, des zones d'obscuritÃ© qui ne peuvent pas Ãªtre digÃ©rÃ©es ... J'aimerais, je ne sais pas, que votre option soit calculÃ©e de maniÃ¨re prÃ©visible, bien et sans astuces. <br><br>  L'exemple le plus simple parle de plages ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">range-v3</a> et tout ce sujet).  D'une part, tout cela est gÃ©nial: il y a des choses qui sont en C # depuis plusieurs annÃ©es, permettant, par exemple, de construire un calendrier par toutes les transformations de la collection standard.  En revanche, la faÃ§on dont il est implÃ©mentÃ© en C ++ est tout simplement dÃ©sagrÃ©able par rapport Ã  C #: il est lourd, non lisible. <br><br>  <b>Sergey:</b> C'est de l'arÃ´me.  Moi, au contraire, j'aime Ã§a.  Si je comprends bien, vous en Ãªtes au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> Nibler et Ã  sa prÃ©sentation ... <br><br>  <b>Dmitry:</b> Vous voyez, lorsque l'opÃ©rateur Â«ouÂ» est utilisÃ© pour filtrer une collection, j'ai immÃ©diatement des questions Ã  ce sujet.  C # et Java ont tout fait via le point, selon les mÃ©thodes habituelles. <br><br>  <b>Sergey:</b> Et il me semble que cela est inspirÃ© par Bash.  Autrement dit, ce n'est qu'un tuyau. <br><br>  <b>Dmitry:</b> Eh bien, oui, cela explique probablement quelque chose dans cette approche. <br><br>  <b>Sergey: Cela</b> explique beaucoup de choses!  Parlons de PowerShell, puisque nous parlons de Bash.  Qui a vu PowerShell? <br><br>  <b>Anatoly:</b> j'Ã©cris en PowerShell, un super langage.  Mais encore une fois, le tuyau doit Ãªtre insÃ©rÃ© lÃ  oÃ¹ il est en place, lÃ  oÃ¹ toute l'architecture en est imprÃ©gnÃ©e.  Pas lÃ  oÃ¹ vous devez faire une seule action, et c'est ici une syntaxe idiomatiquement mauvaise. <br><br>  <b>Sergey:</b> Dans la gamme pipe, c'est juste trÃ¨s ... <br><br>  <b>Dmitry:</b> Dans la gamme, ils sont utilisÃ©s, Ã  mon avis, pour la raison suivante ... Je dirai ceci: si en C ++ il y avait des mÃ©thodes d'extension ou des fonctions d'extension, vous les utiliseriez, bien sÃ»r.  Parce que la chose la plus naturelle si vous avez besoin de trier une collection est d'Ã©crire Â«collection. Filter ()Â».  Et non Â«collectionÂ» |  view :: filter () ". <br><br>  <b>Anatoly:</b> J'ai Ã©galement eu l'impression que vous vous Ãªtes fait tirer dans les jambes pendant 20 ans, vous avez frappÃ© au visage, vous vous Ãªtes cognÃ© la tÃªte contre le mur, puis vous avez finalement dit: Â«Eh bien, maintenant, nous avons tout fait Ã  merveille dans le 20e standard, maintenant apprenons les pros ont raison.  Oui, personne ne veut leur enseigner correctement!  Autrement dit, c'est une douleur Ã  long terme. <br><br>  <b>Sergey:</b> Veuillez ne pas enseigner.  Quel est le problÃ¨me?  Ã‰crivez en C # - Ã©changez dessus, Ã©crivez intÃ©grÃ©.  Cela ne me dÃ©range pas. <br><br>  <b>Anatoly:</b> Eh bien, il y a des niches Ã©troites oÃ¹ les pros sont toujours lÃ . <br><br>  <b>Sergey:</b> Embedded est une Â«niche Ã©troiteÂ» ... En ce moment, en regardant autour de moi dans ma cuisine, je vois un tas d'ordinateurs. <br><br>  <b>Dmitry:</b> Chaque fois que je prends l'avion, je pense: "Merde, j'espÃ¨re que ces avantages ont bien tout Ã©crit lÃ -bas." <br><br>  <b>Sergey: Au</b> fait, il y a principalement Ada, pour autant que je m'en souvienne. <br><br>  <b>Dmitry:</b> Ada y domine, oui. <br><br>  <b>Anatoly:</b> Au fait, j'ai rÃ©cemment trouvÃ© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un excellent article</a> oÃ¹ l'auteur dans diffÃ©rentes langues (environ 10) a Ã©crit un pilote de bas niveau - un pilote rÃ©seau pour une carte Intel 10 gigabits.  De C Ã  Swift, JS, Python et naturellement C #.  Si nous regardons ces graphiques, qu'il a obtenus, alors C # sur de gros lots (lorsque les coÃ»ts de lancement sont nivelÃ©s) va de pair avec C et Rust. <br><br><img src="https://habrastorage.org/webt/bk/bp/ur/bkbpuriesi98tzgy1eon4cek8vs.png"><br><br>  Autrement dit, si nous parlons de performances, il peut Ãªtre faux de penser que C # est trÃ¨s infÃ©rieur quelque part.  Il y a aussi un rapport gÃ©nial de Federico Luis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scratched Metal</a> , oÃ¹ il a montrÃ© comment il a optimisÃ© le code C # pour les profileurs de processeur. <br><br>  <b>Sergey:</b> Eh bien, Ã§a recommence.  Le fait est que lorsque vous commencez Ã  optimiser Java, C #, il devient difficile de savoir pourquoi ne pas Ã©crire sur les avantages.  Parce que vous avez besoin de connaissances spÃ©cifiques.  Et, comme il me semble, l'avantage de langages comme C # et Java est nivelÃ© - pas un seuil d'entrÃ©e trÃ¨s Ã©levÃ©.  Autant que je sache, juste ce dont Dmitry parlait: lisibilitÃ© du code, beaucoup d'apprentissage, difficile d'expliquer certains concepts, etc. <br><br>  <b>Anatoly:</b> Je travaille 99% de mon temps Ã  Ã©crire en C # Â«normalÂ» - sÃ»r, stable et travaillant tout le temps.  Et 1% du temps, je veux Ã©crire une sorte de code rapide et de bas niveau.  Et ce C # me le permet aussi.  Mais mon outil principal est toujours stable, lisible, sans erreur ... <br><br>  <b>Dmitry:</b> Tolya, permettez-moi de vous donner un exemple simple: la vectorisation.  Avec la vectorisation en .NET, tout va trÃ¨s mal, malgrÃ© le fait que System.Numerics.Vectors se scie lentement.  Et Ã  quoi cela mÃ¨ne-t-il, pour ma part, par exemple?  Au fait que si vous vous promenez sur le marchÃ© et achetez une bibliothÃ¨que mathÃ©matique pour .NET, elle est Ã©crite sur les pros (avec un wrapper complet).  Parce qu'en .NET, il n'y a pratiquement pas d'accÃ¨s Ã  l'accÃ©lÃ©ration matÃ©rielle (AVX, etc.), il est maintenant Ã  un stade embryonnaire. <br><br>  <b>Anatoly:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intrinsics est</a> publiÃ© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">.NET Core 3</a> oÃ¹ vous pouvez accÃ©der directement Ã  AVX.  Ils sont vraiment lÃ  Ã  leurs balbutiements, mais il y a des choses basiques, et le reste est assez Ã©mouvant. <br><br>  <b>Dmitry:</b> Vous comprenez, nous avons 2019 dans la cour.  En tant qu'utilisateur de tout ce bien mathÃ©matique accÃ©lÃ©rÃ©, je n'ai pas attendu cela.  Et par consÃ©quent, pour moi, si je veux considÃ©rer rapidement quelque chose, C # n'est plus un candidat.  Parce que les bibliothÃ¨ques C ++ existent dÃ©jÃ .  Peut-Ãªtre que du temps a dÃ©jÃ  Ã©tÃ© perdu pour cela. <br><br>  <b>Anatoly:</b> Il me semble que C # Ã©volue dans le sens des avantages, il essaie de gagner leur marchÃ©.  Mais les avantages ne bougent plus nulle part. <br><br>  <b>Sergey:</b> D'oÃ¹ cela vient-il?  Que signifie Â«les avantages ne vont nulle partÂ»? <br><br>  <b>Anatoly:</b> Quand ils me disent en 2019 qu'il y aura des itÃ©rateurs dans la norme, il y aura des progrÃ¨s sur les lambdas, il me semble que ... <br><br>  <b>Sergey:</b> Je ne sais pas pourquoi vous parlez d'itÃ©rateurs et de lambdas, je ne comprends pas de quelle faÃ§on Ã©tait la pierre ... <br><br>  <b>Anatoly:</b> Pas sur les itÃ©rateurs, je me trompe, je voulais dire les conteneurs Ã©numÃ©rables dont nous avons discutÃ© auparavant.  Et en attendant, nous avons obtenu la correspondance de motifs. <br><br>  <b>Sergey:</b> Tout dÃ©pend si c'est nÃ©cessaire ou non.  Nous discutons de la correspondance de motifs.  Mais jusqu'Ã  prÃ©sent, il n'y a aucun argument quant Ã  savoir si cela est nÃ©cessaire chez les pros. <br><br>  <b>Dmitry:</b> J'entends beaucoup de commentaires similaires des avantages, qui disent que "bien qu'il y ait dÃ©jÃ  une prÃ©sence Ã©vidente de telle ou telle approche dans d'autres langues, elle a dÃ©jÃ  Ã©tÃ© Ã©laborÃ©e, les gens l'adorent et y construisent des solutions, nous ne voulons toujours pas cela en plus, car ce ne sont pas des atouts idiomatiques. "  Et il me semble que Java est tombÃ© dans le mÃªme trou.  Java a dit "pas de gars, nous n'aurons pas de dÃ©lÃ©guÃ©s".  Et en Java, il n'y a toujours pas de concept de dÃ©lÃ©guÃ©s, mais en .NET tout cela fonctionne bien. <br><br>  <b>Sergey:</b> Ã‰coutez, les pros sont trÃ¨s simples.  Encore une fois, je reviens au comitÃ©.  Il y a une astuce - ce sont des gens qui dÃ©veloppent des compilateurs.  Et pour eux, les mots Â«abstraction Ã  coÃ»t nulÂ» sont exactement ce sur quoi ils devraient Ãªtre guidÃ©s.  Et le mot Â«hÃ©ritageÂ», malheureusement. <br><br>  <b>Dmitry:</b> Eh bien, l'abstraction Ã  coÃ»t nul est un assembleur.  Si nous voulons une abstraction Ã  coÃ»t nul en gÃ©nÃ©ral, nous devons tout Ã©crire dans l'assembleur. <br><br>  <b>Sergey:</b> Il n'y a pas d'abstraction. <br><br>  <b>Dmitry:</b> Assembler est une abstraction sur du code binaire.  Ce n'est que la deuxiÃ¨me gÃ©nÃ©ration, pas la troisiÃ¨me. <br><br>  <b>Sergey:</b> Donc, Ã  propos de toutes sortes de Â«choses pratiquesÂ», il s'avÃ¨re qu'il n'est pas clair comment les faire fonctionner rapidement. <br><br>  <b>Dmitry:</b> Laissez-les travailler plus lentement.  L'idÃ©e avec les itÃ©rateurs asynchrones, les coroutines, tout cela - dans .NET avec C #, le mot-clÃ© yield ne sait plus combien de versions fonctionnent trÃ¨s bien.  Oui, d'Ã©normes machines d'Ã©tat sont en train d'Ãªtre construites dans les coulisses, juste de la magie.  Mais async / wait crÃ©e Ã©galement de la magie et des itÃ©rateurs.  Mais tout le monde l'utilise, et c'est vraiment pratique. <br><br>  <b>Sergey:</b> Coroutines ajouter aux avantages, bonjour. <br><br>  <b>Dmitry:</b> Eh bien, oui, des progrÃ¨s sont en cours.  Mais les coroutines apparaissent maintenant, il n'y a pas 10 ans. <br><br>  <b>Sergey:</b> Encore une fois.  Les avantages sont plus anciens, et Ã  mon avis, la vitesse de dÃ©veloppement diminue avec l'accumulation de la base de code.  De toute Ã©vidence, tout dÃ©pend de la volontÃ© de maintenir le support Legacy.  Pour les pros, c'est une position de principe.  Autrement dit, le code que vous avez Ã©crit dans les annÃ©es 80 est maintenant compilÃ© par un compilateur moderne. <br><br>  <b>Dmitry:</b> Oui, mais vous compilez le code que vous avez Ã©crit en C # 1.0 avec un compilateur moderne. <br><br>  <b>Sergey:</b> Ce n'est pas vrai.  Au tout dÃ©but de la discussion, j'ai dit qu'une mise Ã  jour Ã©tait arrivÃ©e sur mes premiÃ¨res versions de .NET, et tout Ã  coup tous les programmes ont cessÃ© de fonctionner. <br><br>  <b>Dmitry:</b> Peut-Ãªtre que les API que vous avez utilisÃ©es viennent de changer.  Ici, vous devez sÃ©parer la bibliothÃ¨que et le langage de programmation. <br><br>  <b>Sergey:</b> Je n'avais rien, juste C #.  J'Ã©tais jeune, c'Ã©tait les premiÃ¨res annÃ©es. <br><br>  <b>Dmitry:</b> Je me souviens d'un seul changement de rupture, en C # 4 - un petit changement dans le comportement de foreach.  Bien sÃ»r, dans les versions 1.x, tout pourrait Ãªtre plus turbulent, mais maintenant nous ne sommes dÃ©finitivement pas dans la phase oÃ¹ quelqu'un casse soudainement quelque chose. <br><br>  <b>Anatoly:</b> Eh bien, officiellement Microsoft adhÃ¨re Ã  la position qui surveille strictement la compatibilitÃ© descendante, ils testent de nouvelles versions sur un grand nombre de machines et de bases de code.  Vous avez peut-Ãªtre eu un bug ou quelque chose comme Ã§a. <br><br>  <b>Dmitry:</b> En gÃ©nÃ©ral, .NET surveille Ã©galement la compatibilitÃ© descendante, mais la vitesse de progression a bondi Ã  la fois en C ++ et en Java. <br><br>  <b>Sergey:</b> Il me semble que cela a jouÃ© un grand rÃ´le, qu'au dÃ©but tout cela Ã©tait menÃ© par une seule entreprise.  Parce que C ++ Ã©tait Ã  l'origine au comitÃ© - et c'est de la politique, tout le monde essaie de pousser sa dÃ©cision, et c'est comme une rÃ©union du SÃ©nat dans Star Wars. <br><br>  <b>Dmitry:</b> Votre argument est donc que nous sommes tous les otages des comitÃ©s qui ne sont pas motivÃ©s par l'innovation? <br><br>  <b>Sergey:</b> Le problÃ¨me est que vous ne choisissez pas une solution qui satisfera tout le monde.  L'outil est si largement distribuÃ© qu'il est utilisÃ© par de nombreuses entreprises.  Vous vous souvenez des mÃªmes coroutines: pourquoi les ont-elles reÃ§ues tard?  Parce que Microsoft, semble-t-il, ne pouvait pas Ãªtre d'accord avec Google.  Il y avait deux implÃ©mentations - je ne me souviens pas qui Ã©tait derriÃ¨re stackful et qui Ã©tait derriÃ¨re stackless, mais je ne pouvais pas Ãªtre d'accord.  Parce que les deux sociÃ©tÃ©s sont grandes, elles ont d'Ã©normes bases de code qui contiennent dÃ©jÃ  une solution et refusent de la rÃ©Ã©crire. <br><br>  <b>Dmitry:</b> Du point de vue du lecteur, on aura l'impression qu'ils lui ont crachÃ© dessus depuis un haut clocher, car il y a des intÃ©rÃªts corporatifs, ils sont engagÃ©s dans des entrelacs, et tout cela ne semble pas vous concerner - allez, laquais, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Â«laissez-les manger du gÃ¢teauÂ»</a> . <br><br>  <b>Sergey:</b> Bien au contraire.  Le comitÃ© essaie de choisir pour qu'une personne ordinaire n'ait pas Ã  souffrir.  Et souvent c'est difficile. <br><br>  <b>Dmitry:</b> Eh bien, je peux dire par moi-mÃªme que je ne souffrirai pas si le coÃ»t zÃ©ro va directement quelque part, mais il y aura une sorte de possibilitÃ© flexible de marcher le long de l'arbre binaire et d'itÃ©rer de diffÃ©rentes maniÃ¨res sans variables de temps.      yield,     -   - â€”    ,   ,      ,  ,     - . <br><br> <b>:</b> , ,           ,        ,      - . <br><br> <b>:</b>    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boost</a> . <br><br> <b>:</b> ,  . Boost , ,   , â€¦  -        .    std::string,  ,    .    size(),  length(),      :  ,    -  ?    -  ,    ,     .   , .  ,  , ,       .      ,    ,        ,   -  . <br><br><img src="https://habrastorage.org/webt/nh/k7/cd/nhk7cdikdhqxbdfj52qibe_pybo.jpeg"><br><br><h2>  </h2><br> <b>:</b>            , , ,    .       ? <br><br> <b>:</b>      , ,      Â«Â»,    . <br><br> <b>:</b>  . <br><br> <b>:</b>    embedded-,      include,  ? <br><br> <b>:</b>       .   embedded  -. <br><br> ,     , -  ?   ,    ,     .     ? <br><br> <b>:</b>  .   150 .   -     ,   .  . <br><br> <b>:</b>      ,    ! <br><br> <b>:</b>   ,     Steam, , , 64 . ,  150   ? <br><br> <b>:</b> , , . <br><br> <b>:</b>       ,        -.         ?     ,  ,      ,   â€”  ,    zero cost abstractions  .       -? <br><br> <b>:</b>       ,  ,       ,   , ? <br><br> <b>:</b>    ,     .      ,    ,    . <br><br> <b>:</b> ,      ,    ,   .     â€” ,     .     ,    .     ,   ,  .     ,  .    -.      C. <br><br> <b>:</b>   .      Â«Â».       : ,            .  ,    ,   ,     .      .  ,       . <br><br> <b>:</b> ,   .     . ,  .      proposal.    . <br><br> <b>:</b>   ,    proposal.      ,       Â« Â»: ,  STL  ,    . ,  -   ,      . <br><br> <b>:</b> STL        . STL  .  ,    ,   STL  â€”  ,    ,      . <br><br> <b>:</b>  ,   â€”   ,    ?   ,     greenfield.    brownfield development,   .   â€” ,  .   â€”  .   ? <br><br> <b>:</b>  ,  .   ,   ,    .   ,   .      ,   ,     . G++  , Clang  .   . <br><br> <b>:</b>  , ,      ,     .  Â«    ,   A,  BÂ».     ,      .NET,         .  ,  ,     ,         ,       ,       ? <br><br> <b>:</b>  ,  ,     . ,    C++ 2.0.  ++C++.      ,     C. <br><br> <b>:</b>  ,    .          ,   ,  . ,  , ,   ,  #include  #import  -    â€”   .  ,           . ,   ,    ,           , . <br><br>     .    ,       .    , ,       ,      C#  C++,             . <br><br> <b>:</b>    ,      ,     10  .     ,  ,   ,     ,    ,       ,   .         Â« Â»,      .      ,        . <br><br> C# ,      C++.   ,     C#     .       ,   ,   .      ,  ,     , ,  JIT' â€”  ,   ,         -   (    int).  ,     ,   ,     ,    . <br><br> <b>:</b> ,  ,   ,   C#       â€”     .  ,    ,   C++  .  ,     .  ( ,   ) â€”   cutting edge.    ,     UI-  C++,      ,   .   C# â€” .  C++   ,   . <br><br>       ,   . ,     ,       ,    C++   ,  ,   , . ,     . <br><br>         ,  C#     Microsoft.   ,    .NET Foundation,      ,   ,   Microsoft.   ,             . <br><br><hr><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C++ Russia</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DotNext</a> .  :    ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469467/">https://habr.com/ru/post/fr469467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469457/index.html">OÃ¹ Extravaganza mÃ¨ne</a></li>
<li><a href="../fr469459/index.html">Connecter des appareils IoT dans la Smart City</a></li>
<li><a href="../fr469461/index.html">Â«Vers les Ã©toilesÂ»: Â«Apocalypse aujourd'huiÂ» anti-cosmique</a></li>
<li><a href="../fr469463/index.html">Tendances et prÃ©visions dans le traitement du langage naturel</a></li>
<li><a href="../fr469465/index.html">Initialisation en C ++ moderne</a></li>
<li><a href="../fr469471/index.html">"5 cents" pour parler de Sorts</a></li>
<li><a href="../fr469475/index.html">L'ascension et la chute de Flash, le plugin ennuyeux qui a faÃ§onnÃ© le web moderne</a></li>
<li><a href="../fr469477/index.html">Il est temps pour Apple d'arrÃªter de comparer l'iPad au PC</a></li>
<li><a href="../fr469479/index.html">D'oÃ¹ vient la probabilitÃ© quantique</a></li>
<li><a href="../fr469487/index.html">Configurer top dans GNU / Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>