<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìä üßòüèæ üôáüèª Techniques de programmation g√©n√©ralis√©es dans Rust: comment nous avons traduit Exonum de Iron en actix-web üíú üèçÔ∏è üë©üèø‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'√©cosyst√®me de Rust n'est pas encore compl√®tement install√©. De nouvelles biblioth√®ques y apparaissent souvent, qui sont nettement meilleures que leur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Techniques de programmation g√©n√©ralis√©es dans Rust: comment nous avons traduit Exonum de Iron en actix-web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bitfury/blog/429450/"> L'√©cosyst√®me de Rust n'est pas encore compl√®tement install√©.  De nouvelles biblioth√®ques y apparaissent souvent, qui sont nettement meilleures que leurs pr√©d√©cesseurs, et les frameworks pr√©c√©demment populaires deviennent obsol√®tes.  C'est exactement ce qui s'est produit avec le framework web Iron que nous avons utilis√© lors du d√©veloppement d'Exonum. <br><br>  Actix-web a √©t√© choisi pour remplacer Iron.  De plus, je dirai comment nous avons port√© le code existant vers une nouvelle solution en utilisant des techniques de programmation g√©n√©ralis√©es. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/c1/e0/un/c1e0unbkgiazhkhwcm7m5yt5v24.jpeg"></a> <a name="habracut"></a><br>  <font color="#A9A9A9"><i>Image de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ulleo</a> PD</i></font> <br><br><h2>  Comment nous avons utilis√© le fer </h2><br>  Chez Exonum, le framework Iron a √©t√© utilis√© sans aucune abstraction.  Nous avons install√© des gestionnaires sur certaines ressources, re√ßu des param√®tres de requ√™te en analysant les URL √† l'aide de m√©thodes auxiliaires et renvoy√© le r√©sultat simplement sous forme de cha√Æne. <br><br>  Tout ressemblait √† ceci: <br><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_blocks_response</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, router: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Router) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> blocks = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| -&gt; IronResult&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.required_param(req, <span class="hljs-string"><span class="hljs-string">"count"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> latest: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"latest"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> skip_empty_blocks: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"skip_empty_blocks"</span></span>)? .unwrap_or(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.blocks(count, latest.map(Height), skip_empty_blocks)?; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ok_response(&amp;::serde_json::to_value(info).unwrap()) }; router.get(<span class="hljs-string"><span class="hljs-string">"/v1/blocks"</span></span>, blocks, <span class="hljs-string"><span class="hljs-string">"blocks"</span></span>); }</code> </pre> <br>  De plus, certains modules compl√©mentaires de middleware sous la forme d'en-t√™tes CORS ont √©t√© utilis√©s.  Pour combiner tous les gestionnaires en une seule API, nous avons utilis√© mount. <br><br><h2>  Pourquoi as-tu d√ª l'abandonner </h2><br>  Le fer √©tait un bon cheval de bataille avec de nombreux ajouts.  Cependant, il a √©t√© √©crit dans ces temps lointains, lorsque des projets tels que les futurs et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tokio</a> n'existaient pas. <br><br>  L'architecture en fer permet un traitement synchrone des demandes, de sorte qu'il s'adapte facilement sur les omoplates avec un grand nombre de connexions ouvertes simultan√©ment.  Pour qu'Iron devienne √©volutif, il doit √™tre rendu asynchrone.  Pour ce faire, il a fallu repenser et r√©√©crire l'int√©gralit√© du framework, mais les d√©veloppeurs ont progressivement abandonn√© le travail sur celui-ci. <br><br><h2>  Pourquoi nous sommes pass√©s √† Actix-Web </h2><br>  Il s'agit d'un framework populaire qui occupe une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">place de choix dans les benchmarks TechEmpower</a> .  Dans le m√™me temps, contrairement √† Iron, il se d√©veloppe activement.  Actix-web poss√®de une API bien con√ßue et une impl√©mentation de haute qualit√© bas√©e sur le framework d'actix actix.  Les demandes sont trait√©es de mani√®re asynchrone par le pool de threads, et si le traitement conduit √† la panique, l'acteur red√©marre automatiquement. <br><br>  Bien s√ªr, actix-web avait des d√©fauts, par exemple, il contenait une grande quantit√© de code dangereux.  Mais plus tard, il a √©t√© r√©√©crit dans Safe Rust, ce qui a r√©solu ce probl√®me. <br><br><blockquote>  Le passage √† actix a r√©solu le probl√®me de stabilit√©.  Iron-backend pourrait √™tre abandonn√© par un grand nombre de connexions.  En g√©n√©ral, la nouvelle API est une solution plus simple, plus productive et unifi√©e.  Il deviendra plus facile pour les utilisateurs et les d√©veloppeurs d'utiliser l'interface logicielle, et sa vitesse augmentera. </blockquote><br><h2>  Ce que nous voulons d'un framework web </h2><br>  Il √©tait important pour nous non seulement de changer Iron en actix-web, mais de jeter les bases de l'avenir - d'√©laborer une nouvelle architecture d'API pour l'abstrait d'un cadre Web sp√©cifique.  Cela vous permettra de cr√©er des gestionnaires, presque sans penser aux sp√©cificit√©s du Web et de les transf√©rer vers n'importe quel backend.  Cela peut √™tre fait en √©crivant une interface qui fonctionnerait sur les types et types de base. <br><br>  Pour comprendre √† quoi ressemble cette interface, d√©finissons ce qu'est une API HTTP: <br><br><ul><li>  Les demandes sont faites exclusivement par les clients et le serveur n'y r√©pond que (il n'agit pas en tant qu'initiateur). </li><li>  Les demandes sont lues et modifi√©es. </li><li>  √Ä la suite de la requ√™te, le serveur renvoie une r√©ponse qui contient les donn√©es souhait√©es en cas de succ√®s et, en cas d'erreur, des informations √† ce sujet. </li></ul><br>  Si nous analysons toutes les couches d'abstraction, il s'av√®re que toute requ√™te HTTP n'est qu'un appel de fonction: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span></span>(context: &amp;ServiceContext, query: Query) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Response, ServiceError&gt;</code> </pre> <br>  Tout le reste peut √™tre consid√©r√© comme une extension de cette entit√© de base.  Ainsi, afin d'ignorer l'impl√©mentation sp√©cifique du framework web, nous devons √©crire des gestionnaires dans un style similaire √† l'exemple ci-dessus. <br><br><h5>  Caract√©ristique de point de terminaison pour le traitement g√©n√©ralis√© des requ√™tes HTTP </h5><br>  Vous pouvez suivre la voie la plus simple et la plus directe et d√©clarer un trait de point final, <br>  d√©crivant l'impl√©mentation de requ√™tes sp√©cifiques: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// ,   GET .      //    ,      . //         . trait Endpoint: Sync + Send + 'static { type Request: DeserializeOwned + 'static; type Response: Serialize + 'static; fn handle(&amp;self, context: &amp;Context, request: Self::Request) -&gt; Result&lt;Self::Response, io::Error&gt;; }</span></span></code> </pre><br>  Apr√®s cela, vous devrez impl√©menter ce gestionnaire dans un cadre sp√©cifique.  Disons que pour actix-web, cela ressemble √† ceci: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//    actix-web.  ,   , //  `Endpoint`   . type FutureResponse = actix_web::FutureResponse&lt;HttpResponse, actix_web::Error&gt;; // ¬´¬ª    actix-web.      //   .     , //     . type RawHandler = dyn Fn(HttpRequest&lt;Context&gt;) -&gt; FutureResponse + 'static + Send + Sync; //   ,     ,     . #[derive(Clone)] struct RequestHandler { ///  . pub name: String, /// HTTP . pub method: actix_web::http::Method, ///  .  ,       . pub inner: Arc&lt;RawHandler&gt;, }</span></span></code> </pre><br>  Vous pouvez utiliser des structures pour passer des param√®tres de demande dans le contexte.  Actix-web peut d√©s√©rialiser automatiquement les param√®tres √† l'aide de serde.  Par exemple, a = 15 &amp; b = hello est d√©s√©rialis√© en une structure de la forme suivante: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleQuery</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre><br>  Ceci est coh√©rent avec le type de demande associ√© de la caract√©ristique Endpoint. <br><br>  √âcrivons maintenant un adaptateur qui encapsule une impl√©mentation Endpoint sp√©cifique dans RequstHandler pour actix-web.  Veuillez noter que les informations sur les types de demande et de r√©ponse sont perdues au cours du processus.  Cette technique est appel√©e effacement de type.  Sa t√¢che consiste √† transformer la planification statique en dynamique. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> RequestHandler { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_endpoint</span></span></span></span>&lt;E: Endpoint&gt;(name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, endpoint: E) -&gt; RequestHandler { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |request: HttpRequest&lt;Context&gt;| -&gt; FutureResponse { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = request.state(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;E::Request&gt;| query.into_inner()) .and_then(|query| endpoint.handle(context, query).map_err(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from)) .and_then(|value| <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(HttpResponse::<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>().json(value))) .into_future(); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(future) }; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { name: name.to_owned(), method: actix_web::http::Method::GET, inner: Arc::from(index) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Arc&lt;RawHandler&gt;, } } }</code> </pre><br>  √Ä ce stade, vous pouvez ajouter des gestionnaires pour les requ√™tes POST et arr√™ter, car nous avons cr√©√© un trait qui est abstrait des d√©tails de l'impl√©mentation.  Cependant, il n'est toujours pas trop ergonomique. <br><br><h5>  Probl√®mes de type </h5><br>  Lors de l'√©criture d'un gestionnaire, beaucoup de code auxiliaire est g√©n√©r√©: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//    . struct ElementCountEndpoint { elements: Rc&lt;RefCell&lt;Vec&lt;Something&gt;&gt;&gt;, } //   Endpoint. impl Endpoint for ElementCountEndpoint { type Request = (); type Result = usize; fn handle(&amp;self, context: &amp;Context, _request: ()) -&gt; Result&lt;usize, io::Error&gt; { Ok(self.elements.borrow().len()) } } //    . let endpoint = ElementCountEndpoint::new(elements.clone()); let handler = RequestHandler::from_endpoint("/v1/element_count", endpoint); actix_backend.endpoint(handler);</span></span></code> </pre><br>  Id√©alement, j'aimerais pouvoir passer une fermeture normale en tant que gestionnaire, en r√©duisant la quantit√© de bruit de syntaxe d'un ordre de grandeur: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> elements = elements.clone(); actix_backend.endpoint(<span class="hljs-string"><span class="hljs-string">"/v1/elements_count"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || {   <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(elements.borrow().len()) });</code> </pre><br>  Je parlerai de la fa√ßon de proc√©der plus tard. <br><br><h2>  Immersion facile dans la programmation g√©n√©rale </h2><br>  Nous devons r√©aliser la capacit√© de g√©n√©rer automatiquement un adaptateur qui impl√©mente Endpoint avec les types associ√©s corrects.  Dans ce cas, seule une fermeture avec le gestionnaire de requ√™tes HTTP sera envoy√©e √† l'entr√©e. <br><br>  Les arguments et le r√©sultat de la fermeture peuvent √™tre de diff√©rents types, vous devez donc ici travailler avec une surcharge de m√©thode.  Rust ne prend pas directement en charge la surcharge, mais permet de l'√©muler en utilisant les traits Into et From. <br><br>  En outre, le type de valeur de retour de la fermeture ne doit pas n√©cessairement correspondre √† la valeur de retour de l'impl√©mentation du point de terminaison.  Pour manipuler ce type, il doit √™tre extrait du type de fermeture re√ßu. <br><br><h5>  Extraction de types √† partir du type Fn </h5><br>  Dans Rust, chaque fermeture a son propre type unique, qui ne peut pas √™tre explicitement √©crit dans le programme.  Pour manipuler les fermetures, il existe un type Fn.  Il contient une signature de fonction avec des types d'arguments et une valeur de retour, cependant, les extraire individuellement n'est pas si simple. <br><br>  L'id√©e principale est d'utiliser une structure auxiliaire de la forme suivante: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///       F: Fn(A) -&gt; B. struct SimpleExtractor&lt;A, B, F&gt; {   //   .   inner: F,   _a: PhantomData&lt;A&gt;,   _b: PhantomData&lt;B&gt;, }</span></span></code> </pre><br>  Nous sommes oblig√©s d'utiliser PhantomData car Rust n√©cessite que tous les param√®tres de g√©n√©ralisation soient dans la d√©finition de la structure.  Cependant, le type sp√©cifique de fermeture ou de fonction F n'est pas g√©n√©ralis√© (bien qu'il impl√©mente le type g√©n√©ralis√© Fn).  Les param√®tres de type A et B n'y sont pas directement utilis√©s. <br><br>  C'est cette limitation du syst√®me de type Rust qui ne permet pas l'utilisation d'une strat√©gie plus simple - pour impl√©menter directement le trait Endpoint pour les fermetures: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span></span> = A; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span></span> = B; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, context: &amp;Context, request: A) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;B, io::Error&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br>  Dans ce cas, le compilateur renvoie une erreur: <br><br><pre> <code class="rust hljs">error[E0207]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span> `A` is not constrained by the <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">or</span></span></span></span> predicates --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span> | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { | ^ unconstrained <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span></code> </pre><br>  La structure d'aide de SimpleExtractor permet de d√©crire la transformation From.  Il vous permet d'enregistrer n'importe quelle fonction et d'extraire les types de ses arguments: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SimpleExtractor&lt;A, B, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B, A: DeserializeOwned, B: Serialize, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(inner: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { SimpleExtractor { inner, _a: PhantomData, _b: PhantomData, } } }</code> </pre><br>  Le code suivant se compile avec succ√®s: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Query</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">//   . fn my_handler(_: &amp;Context, q: Query) -&gt; String { format!("{} has {} apples.", qb, qa) } let fn_extractor = SimpleExtractor::from(my_handler); //  . let c = 15; let my_closure = |_: &amp;Context, q: Query| -&gt; String { format!("{} has {} apples, but Alice has {}", qb, qa, c) }; let closure_extractor = SimpleExtractor::from(my_closure);</span></span></code> </pre><br><h5>  Sp√©cialisation et types de marqueurs </h5><br>  Nous avons maintenant une fonction avec des types d'arguments explicitement param√©tr√©s, pouvant √™tre utilis√©s √† la place du trait Endpoint.  Par exemple, nous pouvons facilement impl√©menter la conversion de SimpleExtractor en RequestHandler.  Mais encore, ce n'est pas une solution compl√®te.  Nous devons √©galement faire la distinction entre les gestionnaires de requ√™tes GET et les requ√™tes POST au niveau du type (et les gestionnaires synchrones des gestionnaires asynchrones).  Les soi-disant types de marqueurs nous y aideront. <br><br>  Tout d'abord, nous r√©√©crivons SimpleExtractor afin qu'il puisse faire la distinction entre les r√©sultats synchrones et asynchrones.  Dans le m√™me temps, nous impl√©mentons le trait From pour chacun des cas.  Notez que les traits peuvent √™tre impl√©ment√©s pour des variantes sp√©cifiques de structures g√©n√©ralis√©es. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///   HTTP-. pub struct With&lt;Q, I, R, F&gt; { ///  -. pub handler: F, ///     . _query_type: PhantomData&lt;Q&gt;, ///   . _item_type: PhantomData&lt;I&gt;, ///  ,  . ///  ,       . _result_type: PhantomData&lt;R&gt;, } //   ,   . impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, Result&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } } //     . impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, FutureResult&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</span></span></code> </pre><br>  Maintenant, nous devons d√©clarer une structure dans laquelle combiner le gestionnaire de requ√™tes avec son nom et sa vari√©t√©: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedWith</span></span></span></span>&lt;Q, I, R, F, K&gt; {   <span class="hljs-comment"><span class="hljs-comment">///  .   pub name: String,   ///    .   pub inner: With&lt;Q, I, R, F&gt;,   ///  .   _kind: PhantomData&lt;K&gt;, }</span></span></code> </pre><br>  Apr√®s, vous pouvez d√©clarer plusieurs structures vides qui agiront comme types de marqueurs.  Les marqueurs vous permettent d'impl√©menter pour chacun des gestionnaires son propre code de conversion vers le RequestHandler d√©crit pr√©c√©demment. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// ,    .  HTTP   GET-. pub struct Immutable; /// ,   .  HTTP   POST, PUT, UPDATE ///    ,        POST. pub struct Mutable;</span></span></code> </pre><br>  Nous pouvons maintenant d√©finir quatre impl√©mentations diff√©rentes du type From pour toutes les combinaisons des param√®tres de mod√®le R et K (valeur de retour du gestionnaire et type de demande). <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//     get . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state(); let future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;Q&gt;| query.into_inner()) .and_then(|query| handler(context, query).map_err(From::from)) .and_then(|value| Ok(HttpResponse::Ok().json(value))) .into_future(); Box::new(future) }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     post . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     get . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state().clone(); let handler = handler.clone(); Query::from_request(&amp;request, &amp;()) .map(move |query: Query&lt;Q&gt;| query.into_inner()) .into_future() .and_then(move |query| handler(&amp;context, query).map_err(From::from)) .map(|value| HttpResponse::Ok().json(value)) .responder() }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     post . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } }</span></span></code> </pre><br><h5>  "Fa√ßade" pour le backend </h5><br>  Maintenant, pour tout cela, il reste √† √©crire une ¬´fa√ßade¬ª, qui prendrait des fermetures et les ajouterait au backend correspondant.  Dans notre cas, il n'y a qu'un seul backend - actix-web - mais derri√®re la fa√ßade, vous pouvez masquer toutes les impl√©mentations suppl√©mentaires que vous aimez, par exemple, un g√©n√©rateur de sp√©cifications Swagger. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceApiScope</span></span></span></span> { actix_backend: actix::ApiBuilder, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ServiceApiScope { <span class="hljs-comment"><span class="hljs-comment">///    Immutable    . pub fn endpoint&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where //     ,      : Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, //  ,          //  NamedWith  RequestHandler. RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Immutable&gt;&gt;, { self.actix_backend.endpoint(name, endpoint); self } ///    Mutable . pub fn endpoint_mut&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Mutable&gt;&gt;, { self.actix_backend.endpoint_mut(name, endpoint); self }</span></span></code> </pre><br>  Notez comment les types de param√®tres de requ√™te, le type de son r√©sultat, ainsi que le synchronisme / asynchronie du gestionnaire sont automatiquement d√©riv√©s de sa signature.  De plus, vous devez sp√©cifier explicitement le nom de la demande, ainsi que son type. <br><br><h2>  Inconv√©nients de l'approche </h2><br>  Cette approche a encore ses inconv√©nients.  En particulier, <i>endpoint et endpoint_mut doivent conna√Ætre les sp√©cificit√©s de l'impl√©mentation de backends sp√©cifiques</i> .  Cela ne nous permet pas d'ajouter des backends √† la vol√©e, mais de telles fonctionnalit√©s sont rarement n√©cessaires. <br><br>  Un autre probl√®me est que <i>vous ne pouvez pas d√©finir de sp√©cialisation pour un gestionnaire sans arguments suppl√©mentaires.</i>  En d'autres termes, si nous √©crivons le code suivant, il ne sera pas compil√©, car il entre en conflit avec l'impl√©mentation g√©n√©ralis√©e existante: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;(), I, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> With&lt;(), I, <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;ServiceApiState) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(handler: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</code> </pre> <br>  Par cons√©quent, les demandes qui n'ont aucun param√®tre doivent toujours accepter une cha√Æne JSON nulle, qui est d√©s√©rialis√©e en ().  Ce probl√®me pourrait √™tre r√©solu par une sp√©cialisation dans le style de C ++, mais jusqu'√† pr√©sent, il n'est disponible que dans la version nocturne du compilateur et on ne sait pas quand il "se stabilise". <br><br>  <i>De m√™me, vous ne pouvez pas sp√©cialiser le type de la valeur de retour.</i>  M√™me si la demande ne l'implique pas, elle renverra toujours JSON avec null. <br><br>  <i>Le d√©codage des requ√™tes URL dans les requ√™tes GET impose √©galement des restrictions non √©videntes sur le type de param√®tres,</i> mais ce sont d√©j√† des fonctionnalit√©s de l'impl√©mentation de serde-urlencoded. <br><br><h2>  Conclusion </h2><br>  Ainsi, nous avons impl√©ment√© une API qui vous permet de cr√©er facilement et facilement des gestionnaires, presque sans penser aux sp√©cificit√©s du Web.  Plus tard, ils peuvent √™tre transf√©r√©s vers n'importe quel backend ou m√™me utiliser plusieurs backends en m√™me temps. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429450/">https://habr.com/ru/post/fr429450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429420/index.html">La PlayStation Classic utilise l'√©mulateur PCSX ReARMed pour le fonctionnement, pas de solutions propri√©taires</a></li>
<li><a href="../fr429422/index.html">UHCI, ou le tout premier USB</a></li>
<li><a href="../fr429424/index.html">Robotaxi de Daimler et Bosch appara√Ætra en Californie</a></li>
<li><a href="../fr429426/index.html">Exportation de QGIS et de tuiles</a></li>
<li><a href="../fr429448/index.html">Nous √©crivons le chargeur FPGA dans LabVIEW. 2e partie</a></li>
<li><a href="../fr429452/index.html">Le Pentagone a commenc√© √† d√©classifier les logiciels malveillants d'autres personnes</a></li>
<li><a href="../fr429456/index.html">D√©j√† une histoire: o√π la culture startup a-t-elle commenc√© dans les ann√©es 30</a></li>
<li><a href="../fr429458/index.html">Comment j'ai fait des animations du syst√®me solaire pour un fils de deuxi√®me ann√©e</a></li>
<li><a href="../fr429460/index.html">R√©sum√© du rapport ¬´Que savons-nous des microservices¬ª (HL2018, Avito, Vadim Madison)</a></li>
<li><a href="../fr429464/index.html">Ces blocs de 35 tonnes peuvent-ils r√©soudre le gigantesque probl√®me des √©nergies renouvelables?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>