<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📊 🧘🏾 🙇🏻 Techniques de programmation généralisées dans Rust: comment nous avons traduit Exonum de Iron en actix-web 💜 🏍️ 👩🏿‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'écosystème de Rust n'est pas encore complètement installé. De nouvelles bibliothèques y apparaissent souvent, qui sont nettement meilleures que leur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Techniques de programmation généralisées dans Rust: comment nous avons traduit Exonum de Iron en actix-web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bitfury/blog/429450/"> L'écosystème de Rust n'est pas encore complètement installé.  De nouvelles bibliothèques y apparaissent souvent, qui sont nettement meilleures que leurs prédécesseurs, et les frameworks précédemment populaires deviennent obsolètes.  C'est exactement ce qui s'est produit avec le framework web Iron que nous avons utilisé lors du développement d'Exonum. <br><br>  Actix-web a été choisi pour remplacer Iron.  De plus, je dirai comment nous avons porté le code existant vers une nouvelle solution en utilisant des techniques de programmation généralisées. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/c1/e0/un/c1e0unbkgiazhkhwcm7m5yt5v24.jpeg"></a> <a name="habracut"></a><br>  <font color="#A9A9A9"><i>Image de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ulleo</a> PD</i></font> <br><br><h2>  Comment nous avons utilisé le fer </h2><br>  Chez Exonum, le framework Iron a été utilisé sans aucune abstraction.  Nous avons installé des gestionnaires sur certaines ressources, reçu des paramètres de requête en analysant les URL à l'aide de méthodes auxiliaires et renvoyé le résultat simplement sous forme de chaîne. <br><br>  Tout ressemblait à ceci: <br><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_blocks_response</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, router: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Router) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> blocks = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| -&gt; IronResult&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.required_param(req, <span class="hljs-string"><span class="hljs-string">"count"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> latest: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"latest"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> skip_empty_blocks: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"skip_empty_blocks"</span></span>)? .unwrap_or(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.blocks(count, latest.map(Height), skip_empty_blocks)?; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ok_response(&amp;::serde_json::to_value(info).unwrap()) }; router.get(<span class="hljs-string"><span class="hljs-string">"/v1/blocks"</span></span>, blocks, <span class="hljs-string"><span class="hljs-string">"blocks"</span></span>); }</code> </pre> <br>  De plus, certains modules complémentaires de middleware sous la forme d'en-têtes CORS ont été utilisés.  Pour combiner tous les gestionnaires en une seule API, nous avons utilisé mount. <br><br><h2>  Pourquoi as-tu dû l'abandonner </h2><br>  Le fer était un bon cheval de bataille avec de nombreux ajouts.  Cependant, il a été écrit dans ces temps lointains, lorsque des projets tels que les futurs et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tokio</a> n'existaient pas. <br><br>  L'architecture en fer permet un traitement synchrone des demandes, de sorte qu'il s'adapte facilement sur les omoplates avec un grand nombre de connexions ouvertes simultanément.  Pour qu'Iron devienne évolutif, il doit être rendu asynchrone.  Pour ce faire, il a fallu repenser et réécrire l'intégralité du framework, mais les développeurs ont progressivement abandonné le travail sur celui-ci. <br><br><h2>  Pourquoi nous sommes passés à Actix-Web </h2><br>  Il s'agit d'un framework populaire qui occupe une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">place de choix dans les benchmarks TechEmpower</a> .  Dans le même temps, contrairement à Iron, il se développe activement.  Actix-web possède une API bien conçue et une implémentation de haute qualité basée sur le framework d'actix actix.  Les demandes sont traitées de manière asynchrone par le pool de threads, et si le traitement conduit à la panique, l'acteur redémarre automatiquement. <br><br>  Bien sûr, actix-web avait des défauts, par exemple, il contenait une grande quantité de code dangereux.  Mais plus tard, il a été réécrit dans Safe Rust, ce qui a résolu ce problème. <br><br><blockquote>  Le passage à actix a résolu le problème de stabilité.  Iron-backend pourrait être abandonné par un grand nombre de connexions.  En général, la nouvelle API est une solution plus simple, plus productive et unifiée.  Il deviendra plus facile pour les utilisateurs et les développeurs d'utiliser l'interface logicielle, et sa vitesse augmentera. </blockquote><br><h2>  Ce que nous voulons d'un framework web </h2><br>  Il était important pour nous non seulement de changer Iron en actix-web, mais de jeter les bases de l'avenir - d'élaborer une nouvelle architecture d'API pour l'abstrait d'un cadre Web spécifique.  Cela vous permettra de créer des gestionnaires, presque sans penser aux spécificités du Web et de les transférer vers n'importe quel backend.  Cela peut être fait en écrivant une interface qui fonctionnerait sur les types et types de base. <br><br>  Pour comprendre à quoi ressemble cette interface, définissons ce qu'est une API HTTP: <br><br><ul><li>  Les demandes sont faites exclusivement par les clients et le serveur n'y répond que (il n'agit pas en tant qu'initiateur). </li><li>  Les demandes sont lues et modifiées. </li><li>  À la suite de la requête, le serveur renvoie une réponse qui contient les données souhaitées en cas de succès et, en cas d'erreur, des informations à ce sujet. </li></ul><br>  Si nous analysons toutes les couches d'abstraction, il s'avère que toute requête HTTP n'est qu'un appel de fonction: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span></span>(context: &amp;ServiceContext, query: Query) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Response, ServiceError&gt;</code> </pre> <br>  Tout le reste peut être considéré comme une extension de cette entité de base.  Ainsi, afin d'ignorer l'implémentation spécifique du framework web, nous devons écrire des gestionnaires dans un style similaire à l'exemple ci-dessus. <br><br><h5>  Caractéristique de point de terminaison pour le traitement généralisé des requêtes HTTP </h5><br>  Vous pouvez suivre la voie la plus simple et la plus directe et déclarer un trait de point final, <br>  décrivant l'implémentation de requêtes spécifiques: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// ,   GET .      //    ,      . //         . trait Endpoint: Sync + Send + 'static { type Request: DeserializeOwned + 'static; type Response: Serialize + 'static; fn handle(&amp;self, context: &amp;Context, request: Self::Request) -&gt; Result&lt;Self::Response, io::Error&gt;; }</span></span></code> </pre><br>  Après cela, vous devrez implémenter ce gestionnaire dans un cadre spécifique.  Disons que pour actix-web, cela ressemble à ceci: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//    actix-web.  ,   , //  `Endpoint`   . type FutureResponse = actix_web::FutureResponse&lt;HttpResponse, actix_web::Error&gt;; // «»    actix-web.      //   .     , //     . type RawHandler = dyn Fn(HttpRequest&lt;Context&gt;) -&gt; FutureResponse + 'static + Send + Sync; //   ,     ,     . #[derive(Clone)] struct RequestHandler { ///  . pub name: String, /// HTTP . pub method: actix_web::http::Method, ///  .  ,       . pub inner: Arc&lt;RawHandler&gt;, }</span></span></code> </pre><br>  Vous pouvez utiliser des structures pour passer des paramètres de demande dans le contexte.  Actix-web peut désérialiser automatiquement les paramètres à l'aide de serde.  Par exemple, a = 15 &amp; b = hello est désérialisé en une structure de la forme suivante: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleQuery</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre><br>  Ceci est cohérent avec le type de demande associé de la caractéristique Endpoint. <br><br>  Écrivons maintenant un adaptateur qui encapsule une implémentation Endpoint spécifique dans RequstHandler pour actix-web.  Veuillez noter que les informations sur les types de demande et de réponse sont perdues au cours du processus.  Cette technique est appelée effacement de type.  Sa tâche consiste à transformer la planification statique en dynamique. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> RequestHandler { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_endpoint</span></span></span></span>&lt;E: Endpoint&gt;(name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, endpoint: E) -&gt; RequestHandler { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |request: HttpRequest&lt;Context&gt;| -&gt; FutureResponse { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = request.state(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;E::Request&gt;| query.into_inner()) .and_then(|query| endpoint.handle(context, query).map_err(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from)) .and_then(|value| <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(HttpResponse::<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>().json(value))) .into_future(); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(future) }; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { name: name.to_owned(), method: actix_web::http::Method::GET, inner: Arc::from(index) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Arc&lt;RawHandler&gt;, } } }</code> </pre><br>  À ce stade, vous pouvez ajouter des gestionnaires pour les requêtes POST et arrêter, car nous avons créé un trait qui est abstrait des détails de l'implémentation.  Cependant, il n'est toujours pas trop ergonomique. <br><br><h5>  Problèmes de type </h5><br>  Lors de l'écriture d'un gestionnaire, beaucoup de code auxiliaire est généré: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//    . struct ElementCountEndpoint { elements: Rc&lt;RefCell&lt;Vec&lt;Something&gt;&gt;&gt;, } //   Endpoint. impl Endpoint for ElementCountEndpoint { type Request = (); type Result = usize; fn handle(&amp;self, context: &amp;Context, _request: ()) -&gt; Result&lt;usize, io::Error&gt; { Ok(self.elements.borrow().len()) } } //    . let endpoint = ElementCountEndpoint::new(elements.clone()); let handler = RequestHandler::from_endpoint("/v1/element_count", endpoint); actix_backend.endpoint(handler);</span></span></code> </pre><br>  Idéalement, j'aimerais pouvoir passer une fermeture normale en tant que gestionnaire, en réduisant la quantité de bruit de syntaxe d'un ordre de grandeur: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> elements = elements.clone(); actix_backend.endpoint(<span class="hljs-string"><span class="hljs-string">"/v1/elements_count"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || {   <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(elements.borrow().len()) });</code> </pre><br>  Je parlerai de la façon de procéder plus tard. <br><br><h2>  Immersion facile dans la programmation générale </h2><br>  Nous devons réaliser la capacité de générer automatiquement un adaptateur qui implémente Endpoint avec les types associés corrects.  Dans ce cas, seule une fermeture avec le gestionnaire de requêtes HTTP sera envoyée à l'entrée. <br><br>  Les arguments et le résultat de la fermeture peuvent être de différents types, vous devez donc ici travailler avec une surcharge de méthode.  Rust ne prend pas directement en charge la surcharge, mais permet de l'émuler en utilisant les traits Into et From. <br><br>  En outre, le type de valeur de retour de la fermeture ne doit pas nécessairement correspondre à la valeur de retour de l'implémentation du point de terminaison.  Pour manipuler ce type, il doit être extrait du type de fermeture reçu. <br><br><h5>  Extraction de types à partir du type Fn </h5><br>  Dans Rust, chaque fermeture a son propre type unique, qui ne peut pas être explicitement écrit dans le programme.  Pour manipuler les fermetures, il existe un type Fn.  Il contient une signature de fonction avec des types d'arguments et une valeur de retour, cependant, les extraire individuellement n'est pas si simple. <br><br>  L'idée principale est d'utiliser une structure auxiliaire de la forme suivante: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///       F: Fn(A) -&gt; B. struct SimpleExtractor&lt;A, B, F&gt; {   //   .   inner: F,   _a: PhantomData&lt;A&gt;,   _b: PhantomData&lt;B&gt;, }</span></span></code> </pre><br>  Nous sommes obligés d'utiliser PhantomData car Rust nécessite que tous les paramètres de généralisation soient dans la définition de la structure.  Cependant, le type spécifique de fermeture ou de fonction F n'est pas généralisé (bien qu'il implémente le type généralisé Fn).  Les paramètres de type A et B n'y sont pas directement utilisés. <br><br>  C'est cette limitation du système de type Rust qui ne permet pas l'utilisation d'une stratégie plus simple - pour implémenter directement le trait Endpoint pour les fermetures: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span></span> = A; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span></span> = B; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, context: &amp;Context, request: A) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;B, io::Error&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br>  Dans ce cas, le compilateur renvoie une erreur: <br><br><pre> <code class="rust hljs">error[E0207]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span> `A` is not constrained by the <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">or</span></span></span></span> predicates --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span> | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { | ^ unconstrained <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span></code> </pre><br>  La structure d'aide de SimpleExtractor permet de décrire la transformation From.  Il vous permet d'enregistrer n'importe quelle fonction et d'extraire les types de ses arguments: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SimpleExtractor&lt;A, B, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B, A: DeserializeOwned, B: Serialize, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(inner: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { SimpleExtractor { inner, _a: PhantomData, _b: PhantomData, } } }</code> </pre><br>  Le code suivant se compile avec succès: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Query</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">//   . fn my_handler(_: &amp;Context, q: Query) -&gt; String { format!("{} has {} apples.", qb, qa) } let fn_extractor = SimpleExtractor::from(my_handler); //  . let c = 15; let my_closure = |_: &amp;Context, q: Query| -&gt; String { format!("{} has {} apples, but Alice has {}", qb, qa, c) }; let closure_extractor = SimpleExtractor::from(my_closure);</span></span></code> </pre><br><h5>  Spécialisation et types de marqueurs </h5><br>  Nous avons maintenant une fonction avec des types d'arguments explicitement paramétrés, pouvant être utilisés à la place du trait Endpoint.  Par exemple, nous pouvons facilement implémenter la conversion de SimpleExtractor en RequestHandler.  Mais encore, ce n'est pas une solution complète.  Nous devons également faire la distinction entre les gestionnaires de requêtes GET et les requêtes POST au niveau du type (et les gestionnaires synchrones des gestionnaires asynchrones).  Les soi-disant types de marqueurs nous y aideront. <br><br>  Tout d'abord, nous réécrivons SimpleExtractor afin qu'il puisse faire la distinction entre les résultats synchrones et asynchrones.  Dans le même temps, nous implémentons le trait From pour chacun des cas.  Notez que les traits peuvent être implémentés pour des variantes spécifiques de structures généralisées. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///   HTTP-. pub struct With&lt;Q, I, R, F&gt; { ///  -. pub handler: F, ///     . _query_type: PhantomData&lt;Q&gt;, ///   . _item_type: PhantomData&lt;I&gt;, ///  ,  . ///  ,       . _result_type: PhantomData&lt;R&gt;, } //   ,   . impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, Result&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } } //     . impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, FutureResult&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</span></span></code> </pre><br>  Maintenant, nous devons déclarer une structure dans laquelle combiner le gestionnaire de requêtes avec son nom et sa variété: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedWith</span></span></span></span>&lt;Q, I, R, F, K&gt; {   <span class="hljs-comment"><span class="hljs-comment">///  .   pub name: String,   ///    .   pub inner: With&lt;Q, I, R, F&gt;,   ///  .   _kind: PhantomData&lt;K&gt;, }</span></span></code> </pre><br>  Après, vous pouvez déclarer plusieurs structures vides qui agiront comme types de marqueurs.  Les marqueurs vous permettent d'implémenter pour chacun des gestionnaires son propre code de conversion vers le RequestHandler décrit précédemment. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// ,    .  HTTP   GET-. pub struct Immutable; /// ,   .  HTTP   POST, PUT, UPDATE ///    ,        POST. pub struct Mutable;</span></span></code> </pre><br>  Nous pouvons maintenant définir quatre implémentations différentes du type From pour toutes les combinaisons des paramètres de modèle R et K (valeur de retour du gestionnaire et type de demande). <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//     get . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state(); let future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;Q&gt;| query.into_inner()) .and_then(|query| handler(context, query).map_err(From::from)) .and_then(|value| Ok(HttpResponse::Ok().json(value))) .into_future(); Box::new(future) }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     post . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     get . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state().clone(); let handler = handler.clone(); Query::from_request(&amp;request, &amp;()) .map(move |query: Query&lt;Q&gt;| query.into_inner()) .into_future() .and_then(move |query| handler(&amp;context, query).map_err(From::from)) .map(|value| HttpResponse::Ok().json(value)) .responder() }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } //     post . impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } }</span></span></code> </pre><br><h5>  "Façade" pour le backend </h5><br>  Maintenant, pour tout cela, il reste à écrire une «façade», qui prendrait des fermetures et les ajouterait au backend correspondant.  Dans notre cas, il n'y a qu'un seul backend - actix-web - mais derrière la façade, vous pouvez masquer toutes les implémentations supplémentaires que vous aimez, par exemple, un générateur de spécifications Swagger. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceApiScope</span></span></span></span> { actix_backend: actix::ApiBuilder, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ServiceApiScope { <span class="hljs-comment"><span class="hljs-comment">///    Immutable    . pub fn endpoint&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where //     ,      : Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, //  ,          //  NamedWith  RequestHandler. RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Immutable&gt;&gt;, { self.actix_backend.endpoint(name, endpoint); self } ///    Mutable . pub fn endpoint_mut&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Mutable&gt;&gt;, { self.actix_backend.endpoint_mut(name, endpoint); self }</span></span></code> </pre><br>  Notez comment les types de paramètres de requête, le type de son résultat, ainsi que le synchronisme / asynchronie du gestionnaire sont automatiquement dérivés de sa signature.  De plus, vous devez spécifier explicitement le nom de la demande, ainsi que son type. <br><br><h2>  Inconvénients de l'approche </h2><br>  Cette approche a encore ses inconvénients.  En particulier, <i>endpoint et endpoint_mut doivent connaître les spécificités de l'implémentation de backends spécifiques</i> .  Cela ne nous permet pas d'ajouter des backends à la volée, mais de telles fonctionnalités sont rarement nécessaires. <br><br>  Un autre problème est que <i>vous ne pouvez pas définir de spécialisation pour un gestionnaire sans arguments supplémentaires.</i>  En d'autres termes, si nous écrivons le code suivant, il ne sera pas compilé, car il entre en conflit avec l'implémentation généralisée existante: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;(), I, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> With&lt;(), I, <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;ServiceApiState) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(handler: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</code> </pre> <br>  Par conséquent, les demandes qui n'ont aucun paramètre doivent toujours accepter une chaîne JSON nulle, qui est désérialisée en ().  Ce problème pourrait être résolu par une spécialisation dans le style de C ++, mais jusqu'à présent, il n'est disponible que dans la version nocturne du compilateur et on ne sait pas quand il "se stabilise". <br><br>  <i>De même, vous ne pouvez pas spécialiser le type de la valeur de retour.</i>  Même si la demande ne l'implique pas, elle renverra toujours JSON avec null. <br><br>  <i>Le décodage des requêtes URL dans les requêtes GET impose également des restrictions non évidentes sur le type de paramètres,</i> mais ce sont déjà des fonctionnalités de l'implémentation de serde-urlencoded. <br><br><h2>  Conclusion </h2><br>  Ainsi, nous avons implémenté une API qui vous permet de créer facilement et facilement des gestionnaires, presque sans penser aux spécificités du Web.  Plus tard, ils peuvent être transférés vers n'importe quel backend ou même utiliser plusieurs backends en même temps. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429450/">https://habr.com/ru/post/fr429450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429420/index.html">La PlayStation Classic utilise l'émulateur PCSX ReARMed pour le fonctionnement, pas de solutions propriétaires</a></li>
<li><a href="../fr429422/index.html">UHCI, ou le tout premier USB</a></li>
<li><a href="../fr429424/index.html">Robotaxi de Daimler et Bosch apparaîtra en Californie</a></li>
<li><a href="../fr429426/index.html">Exportation de QGIS et de tuiles</a></li>
<li><a href="../fr429448/index.html">Nous écrivons le chargeur FPGA dans LabVIEW. 2e partie</a></li>
<li><a href="../fr429452/index.html">Le Pentagone a commencé à déclassifier les logiciels malveillants d'autres personnes</a></li>
<li><a href="../fr429456/index.html">Déjà une histoire: où la culture startup a-t-elle commencé dans les années 30</a></li>
<li><a href="../fr429458/index.html">Comment j'ai fait des animations du système solaire pour un fils de deuxième année</a></li>
<li><a href="../fr429460/index.html">Résumé du rapport «Que savons-nous des microservices» (HL2018, Avito, Vadim Madison)</a></li>
<li><a href="../fr429464/index.html">Ces blocs de 35 tonnes peuvent-ils résoudre le gigantesque problème des énergies renouvelables?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>