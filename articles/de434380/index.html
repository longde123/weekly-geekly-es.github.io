<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèΩ üí™ üñáÔ∏è Grundlagen der Abh√§ngigkeitsinjektion üë©üèΩ‚Äçüåæ üë∂üèΩ ‚ò¢Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich in einer einfachen Sprache √ºber die Grundlagen der Abh√§ngigkeitsinjektion (Eng. Dependency Injection, DI ) und auch √ºber d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen der Abh√§ngigkeitsinjektion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434380/"><p><img src="https://habrastorage.org/getpro/habr/post_images/741/7ce/850/7417ce8508eb0e9c8dbd12b14d37f383.jpg" alt="Grundlagen der Wahrnehmungsinjektion"></p><br><p>  In diesem Artikel werde ich in einer einfachen Sprache √ºber die Grundlagen der Abh√§ngigkeitsinjektion (Eng. <em>Dependency Injection, DI</em> ) und auch √ºber die Gr√ºnde f√ºr die Verwendung dieses Ansatzes sprechen.  Dieser Artikel richtet sich an Personen, die nicht wissen, was Abh√§ngigkeitsinjektion ist, oder die Zweifel an der Notwendigkeit dieser Technik haben.  Also fangen wir an. </p><a name="habracut"></a><br><h2 id="chto-takoe-zavisimost">  Was ist Sucht? </h2><br><p> Schauen wir uns zuerst ein Beispiel an.  Wir haben <code>ClassA</code> , <code>ClassB</code> und <code>ClassC</code> wie unten gezeigt: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Sie k√∂nnen sehen, dass die <code>ClassA</code> Klasse eine Instanz der <code>ClassA</code> Klasse enth√§lt. Wir k√∂nnen also sagen, dass die <code>ClassA</code> Klasse von der <code>ClassA</code> Klasse abh√§ngt.  Warum?  Weil <code>ClassA</code> ben√∂tigt, um korrekt zu funktionieren.  Wir k√∂nnen auch sagen, dass die <code>ClassB</code> Klasse eine Abh√§ngigkeit von der <code>ClassA</code> Klasse ist. </p><br><p>  Bevor ich fortfahre, m√∂chte ich klarstellen, dass eine solche Beziehung gut ist, da wir nicht eine Klasse ben√∂tigen, um die gesamte Arbeit in der Anwendung zu erledigen.  Wir m√ºssen die Logik in verschiedene Klassen unterteilen, von denen jede f√ºr eine bestimmte Funktion verantwortlich ist.  In diesem Fall k√∂nnen die Klassen effektiv interagieren. </p><br><h2 id="kak-rabotat-s-zavisimostyami">  Wie arbeite ich mit Abh√§ngigkeiten? </h2><br><p>  Schauen wir uns drei Methoden an, mit denen Abh√§ngigkeitsinjektionsaufgaben ausgef√ºhrt werden: </p><br><h3 id="pervyy-sposob-sozdavat-zavisimosti-v-zavisimom-klasse">  Erster Weg: Erstellen Sie Abh√§ngigkeiten in einer abh√§ngigen Klasse </h3><br><p>  Einfach ausgedr√ºckt, wir k√∂nnen Objekte erstellen, wann immer wir sie ben√∂tigen.  Schauen Sie sich das folgende Beispiel an: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someMethodOrConstructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { classB = ClassB() classB.doSomething() } }</code> </pre> <br><p>  Es ist sehr einfach!  Wir erstellen eine Klasse, wenn wir sie brauchen. </p><br><p>  <strong>Die Vorteile</strong> </p><br><ul><li>  Es ist leicht und einfach. </li><li>  Die abh√§ngige Klasse (in unserem Fall <code>ClassA</code> ) steuert vollst√§ndig, wie und wann die Abh√§ngigkeiten erstellt werden sollen. </li></ul><br><p>  <strong>Nachteile</strong> </p><br><ul><li>  <code>ClassA</code> und <code>ClassA</code> <code>ClassB</code> eng miteinander verwandt.  Wenn wir <code>ClassA</code> verwenden <code>ClassA</code> , m√ºssen wir daher <code>ClassA</code> verwenden, und <strong>es ist unm√∂glich, <code>ClassB</code> durch etwas anderes zu ersetzen</strong> . </li><li>  Bei jeder √Ñnderung der Initialisierung der <code>ClassB</code> Klasse m√ºssen Sie den Code innerhalb der <code>ClassA</code> Klasse (und aller anderen von <code>ClassA</code> abh√§ngigen Klassen) anpassen.  Dies erschwert den Prozess des √Ñnderns der Abh√§ngigkeit. </li><li>  <strong><code>ClassA</code> kann nicht getestet werden.</strong>  Wenn Sie eine Klasse testen m√ºssen und dies dennoch einer der wichtigsten Aspekte der Softwareentwicklung ist, m√ºssen Sie die Unit-Tests f√ºr jede Klasse separat durchf√ºhren.  Dies bedeutet, dass Sie, wenn Sie <code>ClassA</code> die korrekte Funktionsweise der <code>ClassA</code> Klasse √ºberpr√ºfen und mehrere <code>ClassA</code> erstellen m√∂chten, wie im Beispiel gezeigt, auf jeden Fall eine Instanz der <code>ClassB</code> Klasse erstellen, auch wenn dies f√ºr Sie nicht von Interesse ist.  Wenn beim Testen ein Fehler auftritt, k√∂nnen Sie nicht verstehen, wo er sich befindet - in <code>ClassA</code> oder <code>ClassA</code>  Schlie√ülich besteht die M√∂glichkeit, dass ein Teil des Codes in <code>ClassB</code> zu einem Fehler gef√ºhrt hat, w√§hrend <code>ClassA</code> ordnungsgem√§√ü funktioniert.  Mit anderen Worten, Unit-Tests sind nicht m√∂glich, da Module (Klassen) nicht voneinander getrennt werden k√∂nnen. </li><li>  <code>ClassA</code> muss so konfiguriert sein, dass Abh√§ngigkeiten <code>ClassA</code> werden k√∂nnen.  In unserem Beispiel muss er wissen, wie man eine <code>ClassC</code> und daraus eine <code>ClassC</code> erstellt.  Es w√§re besser, wenn er nichts davon w√ºsste.  Warum?  Aufgrund des <strong>Prinzips der Einzelverantwortung</strong> . </li></ul><br><blockquote>  <em>Jede Klasse sollte nur ihren Job machen.</em> </blockquote><p>  Daher m√∂chten wir nicht, dass Klassen f√ºr etwas anderes als ihre eigenen Aufgaben verantwortlich sind.  Die Implementierung von Abh√§ngigkeiten ist eine zus√§tzliche Aufgabe, die wir f√ºr sie festlegen. </p><br><h3 id="vtoroy-sposob-vnedryat-zavisimosti-cherez-polzovatelskiy-klass">  Zweiter Weg: Abh√§ngigkeiten √ºber eine benutzerdefinierte Klasse einf√ºgen </h3><br><p>  Um zu verstehen, dass das Einf√ºgen von Abh√§ngigkeiten in eine abh√§ngige Klasse keine gute Idee ist, wollen wir einen alternativen Weg untersuchen.  Hier definiert die abh√§ngige Klasse alle Abh√§ngigkeiten, die sie im Konstruktor ben√∂tigt, und erm√∂glicht es der Benutzerklasse, sie bereitzustellen.  Ist das eine L√∂sung f√ºr unser Problem?  Wir werden es etwas sp√§ter herausfinden. </p><br><p>  Schauen Sie sich den folgenden Beispielcode an: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserClass</span></span></span></span>(){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classC = ClassC(); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classB = ClassB(classC); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classA = ClassA(classB); classA.someMethod(); } } view rawDI Example In Medium -</code> </pre> <br><p>  Jetzt erh√§lt <code>ClassA</code> alle Abh√§ngigkeiten im Konstruktor und kann einfach die Methoden der <code>ClassB</code> Klasse aufrufen, ohne etwas zu initialisieren. </p><br><p>  <strong>Die Vorteile</strong> </p><br><ul><li>  <code>ClassA</code> und <code>ClassB</code> jetzt lose miteinander verbunden, und wir k√∂nnen <code>ClassA</code> ersetzen, ohne den Code in <code>ClassA</code> .  Anstatt beispielsweise <code>AssumeClassB</code> , k√∂nnen wir <code>AssumeClassB</code> , eine Unterklasse von <code>ClassB</code> , und unser Programm funktioniert ordnungsgem√§√ü. </li><li>  <code>ClassA</code> kann jetzt getestet werden.  Beim Schreiben eines <code>ClassA</code> k√∂nnen wir eine eigene Version von <code>ClassB</code> (Testobjekt) erstellen und an <code>ClassA</code> .  Wenn beim Bestehen des Tests ein Fehler auftritt, wissen wir jetzt mit Sicherheit, dass dies definitiv ein Fehler in <code>ClassA</code> . </li><li>  <code>ClassB</code> von der Arbeit mit Abh√§ngigkeiten befreit und kann sich auf seine Aufgaben konzentrieren. </li></ul><br><p>  <strong>Nachteile</strong> </p><br><ul><li>  Diese Methode √§hnelt einem Kettenmechanismus, und irgendwann sollte die Kette unterbrochen werden.  Mit anderen Worten, der Benutzer der Klasse <code>ClassA</code> muss alles √ºber die Initialisierung von <code>ClassA</code> wissen, was wiederum Kenntnisse √ºber die Initialisierung von <code>ClassC</code> usw. erfordert.  Sie sehen also, dass jede √Ñnderung im Konstruktor einer dieser Klassen zu einer √Ñnderung in der aufrufenden Klasse f√ºhren kann, ganz zu schweigen davon, dass <code>ClassA</code> mehr als einen Benutzer haben kann, sodass die Logik zum Erstellen von Objekten wiederholt wird. </li><li>  Trotz der Tatsache, dass unsere Abh√§ngigkeiten klar und leicht zu verstehen sind, ist Benutzercode nicht trivial und schwer zu verwalten.  Daher ist nicht alles so einfach.  Dar√ºber hinaus verst√∂√üt der Code gegen das Prinzip der Einzelverantwortung, da er nicht nur f√ºr seine Arbeit, sondern auch f√ºr die Implementierung von Abh√§ngigkeiten in abh√§ngigen Klassen verantwortlich ist. </li></ul><br><p>  Die zweite Methode funktioniert offensichtlich besser als die erste, hat aber immer noch ihre M√§ngel.  Ist es m√∂glich, eine geeignetere L√∂sung zu finden?  Bevor wir den dritten Weg betrachten, wollen wir zun√§chst √ºber das Konzept der Abh√§ngigkeitsinjektion sprechen. </p><br><h3 id="chto-takoe-vnedrenie-zavisimostey">  Was ist Abh√§ngigkeitsinjektion? </h3><br><blockquote>  Die Abh√§ngigkeitsinjektion ist eine M√∂glichkeit, Abh√§ngigkeiten au√üerhalb der abh√§ngigen Klasse zu behandeln, wenn die abh√§ngige Klasse nichts tun muss. </blockquote><p>  Basierend auf dieser Definition verwendet unsere erste L√∂sung offensichtlich nicht die Idee der Abh√§ngigkeitsinjektion, und der zweite Weg besteht darin, dass die abh√§ngige Klasse nichts unternimmt, um die Abh√§ngigkeiten bereitzustellen.  Aber wir denken immer noch, dass die zweite L√∂sung schlecht ist.  WARUM ?! </p><br><p>  Da die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition der Abh√§ngigkeitsinjektion</a> nichts dar√ºber aussagt, wo die Arbeit mit Abh√§ngigkeiten stattfinden soll (au√üer au√üerhalb der abh√§ngigen Klasse), muss der Entwickler einen geeigneten Ort f√ºr die Abh√§ngigkeitsinjektion ausw√§hlen.  Wie Sie dem zweiten Beispiel entnehmen k√∂nnen, ist die Benutzerklasse nicht ganz der richtige Ort. </p><br><p>  Wie kann man es besser machen?  Schauen wir uns einen dritten Weg an, um mit Abh√§ngigkeiten umzugehen. </p><br><h3 id="tretiy-sposob-pust-kto-nibud-eschyo-obrabatyvaet-zavisimosti-vmesto-nas">  Dritter Weg: Lassen Sie jemanden anstelle von uns mit Abh√§ngigkeiten umgehen </h3><br><p>  Nach dem ersten Ansatz sind abh√§ngige Klassen daf√ºr verantwortlich, ihre eigenen Abh√§ngigkeiten zu erhalten, und nach dem zweiten Ansatz haben wir die Verarbeitung von Abh√§ngigkeiten von der abh√§ngigen Klasse in die Benutzerklasse verschoben.  Stellen wir uns vor, es gibt jemanden, der mit den Abh√§ngigkeiten umgehen kann, wodurch weder die abh√§ngigen noch die Benutzerklassen den Job erledigen w√ºrden.  Mit dieser Methode k√∂nnen Sie direkt mit Abh√§ngigkeiten in der Anwendung arbeiten. </p><br><blockquote>  <strong><em>Eine "saubere" Implementierung der Abh√§ngigkeitsinjektion (meiner pers√∂nlichen Meinung nach)</em></strong> <br><br>  <em>Die Verantwortung f√ºr den Umgang mit Abh√§ngigkeiten liegt bei einem Dritten, sodass kein Teil der Anwendung mit diesen interagiert.</em> </blockquote><p>  Die Abh√§ngigkeitsinjektion ist keine Technologie, kein Framework, keine Bibliothek oder √§hnliches.  Dies ist nur eine Idee.  Die Idee ist, mit Abh√§ngigkeiten au√üerhalb der abh√§ngigen Klasse zu arbeiten (vorzugsweise in einem speziell zugewiesenen Teil).  Sie k√∂nnen diese Idee anwenden, ohne Bibliotheken oder Frameworks zu verwenden.  Normalerweise wenden wir uns jedoch Frameworks zur Implementierung von Abh√§ngigkeiten zu, da dies die Arbeit vereinfacht und das Schreiben von Vorlagencode vermeidet. </p><br><p>  Jedes Abh√§ngigkeitsinjektions-Framework weist zwei inh√§rente Merkmale auf.  M√∂glicherweise stehen Ihnen weitere Zusatzfunktionen zur Verf√ºgung, diese beiden Funktionen sind jedoch immer vorhanden: </p><br><p>  Erstens bieten diese Frameworks eine M√∂glichkeit, die Felder (Objekte) zu bestimmen, die implementiert werden sollen.  Einige Frameworks tun dies, indem sie ein Feld oder einen Konstruktor mit der Annotation <code>@Inject</code> Anmerkungen versehen. Es gibt jedoch auch andere Methoden.  Beispielsweise verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koin</a> die in Kotlin integrierten Sprachfunktionen, um die Implementierung zu bestimmen.  <code>Inject</code> bedeutet, dass die Abh√§ngigkeit vom DI-Framework behandelt werden muss.  Der Code sieht ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } }</code> </pre> <br><p>  Zweitens k√∂nnen Sie mithilfe von Frameworks festlegen, wie die einzelnen Abh√§ngigkeiten bereitgestellt werden sollen. Dies geschieht in separaten Dateien.  Ungef√§hr so ‚Äã‚Äãsieht es aus (denken Sie daran, dass dies nur ein Beispiel ist und von Framework zu Framework unterschiedlich sein kann): </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OurThirdPartyGuy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ClassC() <span class="hljs-comment"><span class="hljs-comment">//just creating an instance of the object and return it. } fun provideClassB(classC: ClassC){ return ClassB(classC) } fun provideClassA(classB: ClassB){ return ClassA(classB) } }</span></span></code> </pre> <br><p>  Wie Sie sehen, ist jede Funktion f√ºr die Verarbeitung einer Abh√§ngigkeit verantwortlich.  Wenn wir <code>ClassA</code> irgendwo in der Anwendung <code>ClassA</code> m√ºssen, <code>ClassA</code> Folgendes: Unser DI-Framework erstellt eine Instanz der <code>ClassC</code> Klasse, indem es <code>provideClassB</code> <code>provideClassC</code> , an <code>provideClassB</code> und eine Instanz von <code>provideClassB</code> empf√§ngt, die an <code>provideClassA</code> wird. Als Ergebnis wird <code>ClassA</code> erstellt.  Das ist fast magisch.  Lassen Sie uns nun die Vor- und Nachteile der dritten Methode untersuchen. </p><br><p>  <strong>Die Vorteile</strong> </p><br><ul><li>  Alles ist so einfach wie m√∂glich.  Sowohl die abh√§ngige Klasse als auch die Klasse, die die Abh√§ngigkeiten bereitstellt, sind klar und einfach. </li><li>  Klassen sind lose gekoppelt und k√∂nnen leicht durch andere Klassen ersetzt werden.  Angenommen, wir m√∂chten <code>ClassC</code> durch <code>AssumeClassC</code> ersetzen, eine Unterklasse von <code>ClassC</code> .  Dazu m√ºssen Sie nur den Provider-Code wie folgt √§ndern. Wo immer <code>ClassC</code> verwendet wird, wird die neue Version jetzt automatisch verwendet: </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AssumeClassC() }</code> </pre> <br><p>  Bitte beachten Sie, dass sich kein Code in der Anwendung √§ndert, sondern nur die Anbietermethode.  Es scheint, dass nichts noch einfacher und flexibler sein k√∂nnte. </p><br><ul><li>  Unglaubliche Testbarkeit.  Sie k√∂nnen Abh√§ngigkeiten w√§hrend des Tests problemlos durch Testversionen ersetzen.  In der Tat ist die Abh√§ngigkeitsinjektion Ihr Haupthelfer beim Testen. </li><li>  Verbesserung der Codestruktur, as  Die Anwendung verf√ºgt √ºber einen separaten Ort f√ºr die Abh√§ngigkeitsverarbeitung.  Infolgedessen kann sich der Rest der Anwendung ausschlie√ülich auf ihre Funktionen konzentrieren und darf sich nicht mit Abh√§ngigkeiten √ºberschneiden. </li></ul><br><p>  <strong>Nachteile</strong> </p><br><ul><li>  DI-Frameworks haben eine bestimmte Einstiegsschwelle, daher muss das Projektteam Zeit aufwenden und diese studieren, bevor sie effektiv eingesetzt werden k√∂nnen. </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><ul><li>  Abh√§ngigkeitsbehandlung ohne DI ist m√∂glich, kann jedoch zu Anwendungsabst√ºrzen f√ºhren. </li><li>  DI ist nur eine effektive Idee, nach der es m√∂glich ist, Abh√§ngigkeiten au√üerhalb der abh√§ngigen Klasse zu behandeln. </li><li>  Es ist am effektivsten, DI in bestimmten Teilen der Anwendung zu verwenden.  Viele Frameworks tragen dazu bei. </li><li>  Frameworks und Bibliotheken werden f√ºr DI nicht ben√∂tigt, k√∂nnen aber sehr hilfreich sein. </li></ul><br><p>  In diesem Artikel habe ich versucht, die Grundlagen der Arbeit mit dem Konzept der Abh√§ngigkeitsinjektion zu erl√§utern, und auch die Gr√ºnde f√ºr die Verwendung dieser Idee aufgelistet.  Es gibt viele weitere Ressourcen, die Sie erkunden k√∂nnen, um mehr √ºber die Verwendung von DI in Ihren eigenen Anwendungen zu erfahren.  Ein separater Abschnitt im fortgeschrittenen Teil unseres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Android-Berufskurses ist</a> diesem Thema gewidmet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434380/">https://habr.com/ru/post/de434380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434362/index.html">NICHT f√ºr 2019 prognostiziert</a></li>
<li><a href="../de434364/index.html">Hangfire Queue-Unterst√ºtzung</a></li>
<li><a href="../de434368/index.html">Maschinelles Lernen zum Auffinden von Fehlern im Code: Wie ich bei JetBrains Research interniert habe</a></li>
<li><a href="../de434370/index.html">Ein weiterer Schatteneroberer in Phaser oder die Verwendung von Fahrr√§dern</a></li>
<li><a href="../de434374/index.html">RBAC in Kubernetes √ºberpr√ºfen</a></li>
<li><a href="../de434382/index.html">Portierung von Alpine Linux auf RISC-V</a></li>
<li><a href="../de434384/index.html">Auf die Verantwortung der Darsteller</a></li>
<li><a href="../de434386/index.html">Douglas Engelbart: ‚ÄûErweiterung des menschlichen Intellekts: Ein konzeptioneller Rahmen‚Äú</a></li>
<li><a href="../de434394/index.html">Bugatti Automobiles testet erfolgreich den 3D-gedruckten Bremssattel</a></li>
<li><a href="../de434398/index.html">Vanivar Bush: "Wie wir vielleicht denken". Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>