<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏿 📞 👼🏼 Les avantages de la frappe forte en C ++: expérience pratique 👩🏽‍🤝‍👩🏼 ☺️ 🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Notre programme traite les paquets réseau, en particulier les en-têtes TCP / IP / etc. Dans ceux-ci, les valeurs numériques - décalages, compteurs, ad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les avantages de la frappe forte en C ++: expérience pratique</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471272/"> Notre programme traite les paquets réseau, en particulier les en-têtes TCP / IP / etc.  Dans ceux-ci, les valeurs numériques - décalages, compteurs, adresses - sont présentées dans l'ordre des octets du réseau (big-endian);  nous travaillons sur x86 (little-endian).  Dans les structures standard décrivant les en-têtes, ces champs sont représentés par des types entiers simples ( <code>uint32_t</code> , <code>uint16_t</code> ).  Après plusieurs bugs dus au fait que nous avons oublié de convertir l'ordre des octets, nous avons décidé de remplacer les types de champs par des classes qui interdisent les conversions implicites et les opérations atypiques.  Sous la coupe se trouve un code utilitaire et des exemples spécifiques d'erreurs que le typage strict a révélé. <br><a name="habracut"></a><br><h2>  Ordre des octets </h2><br>  Likbez pour ceux qui ne connaissent pas l'ordre des octets (endianness, ordre des octets).  Plus en détail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">était déjà sur "Habré"</a> . <br><br>  Dans la notation habituelle des nombres, ils vont du plus ancien (gauche) au plus jeune (droite) à gauche: 432 <sub>10</sub> = 4 × 10 <sup>2</sup> + 3 × 10 <sup>1</sup> + 2 × 10 <sup>0</sup> .  Les types de données entiers ont une taille fixe, par exemple 16 bits (nombres de 0 à 65535).  Ils sont stockés en mémoire sous la forme de deux octets, par exemple, 432 <sub>10</sub> = 01b0 <sub>16</sub> , c'est-à-dire les octets 01 et b0. <br><br>  Imprimez les octets de ce numéro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdio&gt; // printf() #include &lt;cstdint&gt; // uint8_t, uint16_t int main() { uint16_t value = 0x01b0; printf("%04x\n", value); const auto bytes = reinterpret_cast&lt;const uint8_t*&gt;(&amp;value); for (auto i = 0; i &lt; sizeof(value); i++) { printf("%02x ", bytes[i]); } }</span></span></span></span></code> </pre><br>  Sur les processeurs Intel ou AMD (x86) ordinaires, nous obtenons ce qui suit: <br><br><pre> <code class="plaintext hljs">01b0 b0 01</code> </pre><br>  Les octets en mémoire sont situés du plus jeune au plus ancien, et non comme lors de l'écriture de nombres.  Cet ordre est appelé <i>little-endian (LE).</i>  Il en va de même pour les nombres à 4 octets.  L'ordre des octets est déterminé par l'architecture du processeur.  L'ordre «natif» du processeur est également appelé <i>ordre du CPU ou de l'hôte (ordre des octets CPU / hôte).</i>  Dans notre cas, l'ordre des octets de l'hôte est petit-endien. <br><br>  Cependant, Internet n'est pas né sur x86, et l'ordre des octets était différent - <i>du plus ancien au plus jeune (big-endian, BE).</i>  Ils ont commencé à l'utiliser dans les en-têtes des protocoles réseau (IP, TCP, UDP), donc le big-endian est également appelé l' <i>ordre des octets</i> du <i>réseau.</i> <br><br>  Exemple: le port 443 (1bb <sub>16</sub> ), qui utilise HTTPS, est écrit dans les en-têtes TCP octets bb 01, qui en lecture donneront bb01 <sub>16</sub> = 47873. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  uint16_t  uint32_t     . struct tcp_hdr { uint16_t th_sport; uint16_t th_dport; uint32_t th_seq; uint32_t th_ack; uint32_t th_flags2 : 4; uint32_t th_off : 4; uint8_t th_flags; uint16_t th_win; uint16_t th_sum; uint16_t th_urp; } __attribute__((__packed__)); tcp_hdr* tcp = ...; //      // : dst_port  BE,  443  LE. if (tcp-&gt;dst_port == 443) { ... } // : ++  LE,  sent_seq  BE. tcp-&gt;sent_seq++;</span></span></code> </pre><br>  L'ordre des octets d'un nombre peut être converti.  Par exemple, pour <code>uint16_t</code> il existe une fonction standard <code>htons()</code> ( <b>h</b> ost <b>to</b> <b>n</b> etwork for <b>s</b> hort integer - from host order to network order for short integers) and the reverse <code>ntohs()</code> .  De même, pour <code>uint32_t</code> il y a <code>htonl()</code> et <code>ntohl()</code> (long est un entier long). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// :  BE    BE . if (tcp-&gt;dst_port == htons(443)) { ... } //   BE     LE,   1, //   LE    BE. tcp-&gt;sent_seq = htonl(ntohl(tcp-&gt;sent_seq) + 1);</span></span></code> </pre><br>  Malheureusement, le compilateur ne sait pas d'où provient la valeur spécifique d'une variable de type <code>uint32_t</code> et ne vous avertit pas si vous mélangez des valeurs avec des ordres d'octets différents et obtenez un résultat incorrect. <br><br><h2>  Typage fort </h2><br>  Le risque de confondre l'ordre des octets est évident, comment y faire face? <br><br><ul><li>  <b>Révision du code.</b>  Il s'agit d'une procédure obligatoire dans notre projet.  Malheureusement, les testeurs veulent surtout se plonger dans le code qui manipule les octets: "Je vois <code>htons()</code> - probablement, l'auteur a pensé à tout". </li><li>  <b>Discipline,</b> règles comme: BE uniquement dans les packages, toutes les variables dans LE.  Il n'est pas toujours raisonnable, par exemple, si vous devez vérifier les ports par rapport à une table de hachage, il est plus efficace de les stocker dans l'ordre des octets du réseau et de rechercher «tels quels». </li><li>  <b>Tests.</b>  Comme vous le savez, ils ne garantissent pas l'absence d'erreurs.  Les données peuvent être mal appariées (1.1.1.1 ne change pas lors de la conversion de l'ordre des octets) ou ajustées au résultat. </li></ul><br>  Lorsque vous travaillez avec un réseau, vous ne pouvez pas ignorer l'ordre des octets, donc je voudrais qu'il soit impossible de l'ignorer lors de l'écriture de code.  De plus, nous n'avons pas seulement un numéro en BE - c'est un numéro de port, une adresse IP, un numéro de séquence TCP, une somme de contrôle.  Un ne peut pas être affecté à un autre, même si le nombre de bits correspond. <br><br>  La solution est connue - typage strict, c'est-à-dire types distincts pour les ports, les adresses et les numéros.  De plus, ces types doivent prendre en charge la conversion BE / LE.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boost.Endian</a> ne nous convient pas, car il n'y a pas de Boost dans le projet. <br><br>  La taille du projet est d'environ 40 000 lignes en C ++ 17.  Si vous créez des types d'encapsuleurs sûrs et écrasez les structures d'en-tête dessus, tous les endroits où il y a du travail avec BE arrêteront automatiquement la compilation.  Vous devrez les parcourir tous une fois, mais le nouveau code ne sera sûr. <br><br><div class="spoiler">  <b class="spoiler_title">Numéro de classe big-endian</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdint&gt; #include &lt;iosfwd&gt; #define PACKED __attribute__((packed)) constexpr auto bswap(uint16_t value) noexcept { return __builtin_bswap16(value); } constexpr auto bswap(uint32_t value) noexcept { return __builtin_bswap32(value); } template&lt;typename T&gt; struct Raw { T value; }; template&lt;typename T&gt; Raw(T) -&gt; Raw&lt;T&gt;; template&lt;typename T&gt; struct BigEndian { using Underlying = T; using Native = T; constexpr BigEndian() noexcept = default; constexpr explicit BigEndian(Native value) noexcept : _value{bswap(value)} {} constexpr BigEndian(Raw&lt;Underlying&gt; raw) noexcept : _value{raw.value} {} constexpr Underlying raw() const { return _value; } constexpr Native native() const { return bswap(_value); } explicit operator bool() const { return static_cast&lt;bool&gt;(_value); } bool operator==(const BigEndian&amp; other) const { return raw() == other.raw(); } bool operator!=(const BigEndian&amp; other) const { return raw() != other.raw(); } friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const BigEndian&amp; value) { return out &lt;&lt; value.native(); } private: Underlying _value{}; } PACKED;</span></span></span></span></code> </pre><br></div></div><br><ul><li>  Un fichier d'en-tête avec ce type sera inclus partout, donc au lieu d'un <code>&lt;iostream&gt;</code> lourd, un <code>&lt;iosfwd&gt;</code> léger <code>&lt;iosfwd&gt;</code> . </li><li>  Au lieu de <code>htons()</code> , etc. - intrinsèque rapide du compilateur.  En particulier, ils sont <code>constexpr</code> une propagation constante, donc des constructeurs <code>constexpr</code> . </li><li>  Parfois, il existe déjà une valeur <code>uint16_t</code> / <code>uint32_t</code> située dans BE.  La structure <code>Raw&lt;T&gt;</code> avec le guide de déduction vous permet de créer facilement un <code>BigEndian&lt;T&gt;</code> partir de celle-ci. </li></ul><br>  Le point controversé ici est <code>PACKED</code> : les structures packagées sont considérées comme moins optimisables.  La seule réponse est de mesurer.  Nos benchmarks de code n'ont révélé aucun ralentissement.  De plus, dans le cas des paquets réseau, la position des champs dans l'en-tête est toujours fixe. <br><br>  Dans la plupart des cas, BE n'a besoin d'aucune opération autre que la comparaison.  Les numéros de séquence doivent être pliés correctement avec LE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE16 = BigEndian&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE32 = BigEndian&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Seqnum</span></span></span><span class="hljs-class"> :</span></span> BE32 { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE32::BE32; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Integral&gt; Seqnum <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Integral increment) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_integral_v&lt;Integral&gt;); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Seqnum{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(native() + increment)}; } } PACKED; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IP</span></span></span><span class="hljs-class"> :</span></span> BE32 { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE32::BE32; } PACKED; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">L4Port</span></span></span><span class="hljs-class"> :</span></span> BE16 { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE16::BE16; } PACKED;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Structure d'en-tête TCP sécurisée</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TCPFlag : <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> { TH_FIN = <span class="hljs-number"><span class="hljs-number">0x01</span></span>, TH_SYN = <span class="hljs-number"><span class="hljs-number">0x02</span></span>, TH_RST = <span class="hljs-number"><span class="hljs-number">0x04</span></span>, TH_PUSH = <span class="hljs-number"><span class="hljs-number">0x08</span></span>, TH_ACK = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, TH_URG = <span class="hljs-number"><span class="hljs-number">0x20</span></span>, TH_ECE = <span class="hljs-number"><span class="hljs-number">0x40</span></span>, TH_CWR = <span class="hljs-number"><span class="hljs-number">0x80</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCPFlags = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">underlying_type_t</span></span>&lt;TCPFlag&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCPHeader</span></span></span><span class="hljs-class"> {</span></span> L4Port th_sport; L4Port th_dport; Seqnum th_seq; Seqnum th_ack; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> th_flags2 : <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> th_off : <span class="hljs-number"><span class="hljs-number">4</span></span>; TCPFlags th_flags; BE16 th_win; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> th_sum; BE16 th_urp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> header_length() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> th_off &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_header_length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ th_off = len &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* payload() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) + header_length(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> uint8_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) + header_length(); } }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TCPHeader) == <span class="hljs-number"><span class="hljs-number">20</span></span>);</code> </pre></div></div><br><ul><li>  <code>TCPFlag</code> pourrait être transformé en <code>enum class</code> , mais en pratique, seules deux opérations sont effectuées sur les indicateurs: vérifier l'entrée ( <code>&amp;</code> ) ou remplacer les indicateurs par une combinaison ( <code>|</code> ) - il n'y a pas de confusion. </li><li>  Les champs de bits restent primitifs, mais des méthodes d'accès sécurisées sont créées. </li><li>  Les noms de champs restent classiques. </li></ul><br><h2>  Résultats </h2><br>  La plupart des modifications ont été triviales.  Le code est plus propre: <br><br><pre> <code class="diff hljs"> auto tcp = packet-&gt;tcp_header(); - return make_response(packet, - cookie_make(packet, rte_be_to_cpu_32(tcp-&gt;th_seq)), - rte_cpu_to_be_32(rte_be_to_cpu_32(tcp-&gt;th_seq) + 1), - TH_SYN | TH_ACK); + return make_response(packet, cookie_make(packet, tcp-&gt;th_seq.native()), + tcp-&gt;th_seq + 1, TH_SYN | TH_ACK); }</code> </pre><br>  En partie, les types ont documenté le code: <br><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- void check_packet(int64_t, int64_t, uint8_t, bool); + void check_packet(std::optional&lt;Seqnum&gt;, std::optional&lt;Seqnum&gt;, TCPFlags, bool);</span></span></code> </pre><br>  Du coup, il s'est avéré que vous ne pouviez pas lire correctement la taille de la fenêtre TCP, alors que les tests unitaires passeraient et même le trafic serait poursuivi: <br><br><pre> <code class="diff hljs"> //  window size auto wscale_ratio = options().wscale_dst - options().wscale_src; if (wscale_ratio &lt; 0) { - auto window_size = header.window_size() / (1 &lt;&lt; (-wscale_ratio)); + auto window_size = header.window_size().native() / (1 &lt;&lt; (-wscale_ratio)); if (header.window_size() &amp;&amp; window_size &lt; 1) { window_size = WINDOW_SIZE_MIN; } header_out.window_size(window_size); } else { - auto window_size = header.window_size() * (1 &lt;&lt; (wscale_ratio)); + auto window_size = header.window_size().native() * (1 &lt;&lt; (wscale_ratio)); if (window_size &gt; WINDOW_SIZE_MAX) { window_size = WINDOW_SIZE_MAX; }</code> </pre><br>  Exemple d'erreur logique: le développeur du code d'origine pensait que la fonction acceptait BE, bien qu'en fait ce ne soit pas le cas.  Lorsque vous essayez d'utiliser <code>Raw{}</code> au lieu de <code>0</code> programme n'a tout simplement pas compilé (heureusement, ce n'est qu'un test unitaire).  On voit immédiatement un choix de données infructueux: l'erreur aurait été trouvée plus tôt si elle n'avait pas été utilisée 0, ce qui est le même dans n'importe quel ordre d'octets. <br><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- auto cookie = cookie_make_inner(tuple, rte_be_to_cpu_32(0)); + auto cookie = cookie_make_inner(tuple, 0);</span></span></code> </pre><br>  Un exemple similaire: tout d'abord, le compilateur a souligné l'inadéquation entre les types <code>def_seq</code> et <code>cookie</code> , puis il est devenu clair pourquoi le test a réussi plus tôt - de telles constantes. <br><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- const uint32_t def_seq = 0xA7A7A7A7; - const uint32_t def_ack = 0xA8A8A8A8; + const Seqnum def_seq{0x12345678}; + const Seqnum def_ack{0x90abcdef}; ... - auto cookie = rte_be_to_cpu_32(_tcph-&gt;th_ack); + auto cookie = _tcph-&gt;th_ack; ASSERT_NE(def_seq, cookie);</span></span></code> </pre><br><h2>  Résumé </h2><br>  L'essentiel est: <br><br><ul><li>  Trouvé un bogue et plusieurs erreurs logiques dans les tests unitaires. </li><li>  Le refactoring m'a fait trier les endroits douteux, la lisibilité a augmenté. </li><li>  Les performances ont été préservées, mais auraient pu diminuer - des repères sont nécessaires. </li></ul><br>  Les trois points sont importants pour nous, nous pensons donc que le refactoring en valait la peine. <br><br>  Vous assurez-vous contre les erreurs de types stricts? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471272/">https://habr.com/ru/post/fr471272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471262/index.html">Holivar. Histoire de Runet. Partie 5. Trolls: apprendre, imprimante frénétique, cuivre</a></li>
<li><a href="../fr471264/index.html">Choisir une alternative à Mailchimp: pourquoi changer et quel produit choisir</a></li>
<li><a href="../fr471266/index.html">L'avenir est ici ou encodé directement dans le navigateur</a></li>
<li><a href="../fr471268/index.html">Comprendre les courtiers de messages. Apprentissage de la mécanique de la messagerie via ActiveMQ et Kafka. Chapitre 2. ActiveMQ</a></li>
<li><a href="../fr471270/index.html">Nous automatisons la réception de données sur la vitesse de chargement d'un site à partir de Google PageSpeed ​​Insights [modèle]</a></li>
<li><a href="../fr471278/index.html">Génération de texte en russe par des modèles</a></li>
<li><a href="../fr471282/index.html">Recherche de pneumonie aux rayons X avec Fast.ai</a></li>
<li><a href="../fr471288/index.html">Création du visage d'un personnage pour le jeu "OnAir"</a></li>
<li><a href="../fr471294/index.html">Poèmes sur Haskell, C ++ et les programmeurs</a></li>
<li><a href="../fr471296/index.html">Lean Manufacturing - Un outil pour l'efficacité</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>