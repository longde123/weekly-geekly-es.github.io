<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪 🚣🏻 🖕 Como criar formas personalizadas usando MaterialShapeDrawable 🏮 👩🏽‍🤝‍👨🏻 🙌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Material Design 2.0 introduziu vários novos conceitos. Uma delas é a atenção especial às formas geométricas dos elementos da interface. E existe uma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como criar formas personalizadas usando MaterialShapeDrawable</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/426997/"><img src="https://habrastorage.org/getpro/habr/post_images/585/f26/743/585f267433530ce6e9add3c7de072e35.jpg" alt="imagem"><br><br><p>  O Material Design 2.0 introduziu vários novos conceitos.  Uma delas é a atenção especial às formas geométricas dos elementos da interface.  E existe uma maneira fácil de criar belas formas personalizadas.  É chamado de MaterialShapeDrawable.  Vamos ver como é útil e fácil de usar. </p><a name="habracut"></a><br><p>  Existem várias maneiras de adicionar elementos gráficos à tela de um aplicativo Android.  O mais simples é importar bitmaps no formato webp ou png.  Outra opção é usar o VectorDrawable, que permite esticar a imagem para o tamanho necessário.  Outra maneira de adicionar gráficos à tela é usar o ShapeDrawable.  Esta última é a maneira mais fácil de adicionar um plano de fundo simples ou até criar um ícone.  As imagens criadas com o ShapeDrawable são independentes da densidade de pixels na tela.  Eles podem ser descritos em um arquivo xml, fazer parte de outro recurso gráfico (por exemplo, StateListDrawable) e estão presentes no Android SDK, iniciando na API v.1. </p><br><p>  Para alterar a aparência de uma figura, podemos alterar várias propriedades ShapeDrawable: o nome da figura, a cor de preenchimento (ou gradiente) e a cor da borda da figura.  Para retângulos, você também pode definir o raio dos cantos.  Usando essas propriedades, você pode criar gráficos que serão usados ​​como imagens individuais na tela, divisores, planos de fundo de botões ou para qualquer outra finalidade.  Se o aplicativo usar a API v.21 + e ShapeDrawable como plano de fundo para elementos com elevação, a sombra abaixo desses elementos também terá a forma correta: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/456/6b3/fd7/4566b3fd778a1edfdcce710510d1a2c4.png" alt="imagem"></p><br><p>  O ShapeDrawable é uma ferramenta útil que quase sempre faz seu trabalho bem, mas com o advento do Material Design 2.0, os desenvolvedores precisam de algo mais flexível.  O novo sistema de design incentiva o uso de diferentes formas para enfatizar seu significado, condição e estilo de aplicação individual.  Eu escrevi acima que existem várias maneiras de fazer o desejado, mas a mais simples delas não é mais relevante.  Isso significa que precisamos começar a usar gráficos vetoriais e, assim, perder a capacidade de "libertar" criar sombras para elementos de interface com elevação?  Ou vale a pena voltar a usar imagens raster e criar recursos gráficos para seis possíveis densidades de pixels na tela?  Felizmente, com o advento do Material Design 2.0, uma biblioteca de componentes completamente nova apareceu. </p><br><p> Essa biblioteca foi criada para unificar a aparência e o comportamento dos componentes da interface do usuário do Material Design em todas as versões do Android e outras plataformas (existem versões dessa biblioteca para iOS, Web e Flutter).  A biblioteca de componentes implementa muitos recursos para o novo Design de materiais.  Por exemplo, inclui o componente BottomAppBar com o comportamento esperado.  Entre outros componentes e utilitários, há a classe MaterialShapeDrawable.  Na minha opinião, essa é uma ferramenta necessária para resolver as tarefas que o novo sistema de design apresenta para os desenvolvedores. </p><br><p>  Embora o MaterialShapeDrawable ainda seja considerado experimental na versão 1.0.0 da biblioteca, ele pode ser usado para criar efeitos interessantes no aplicativo.  Na classe MaterialShapeDrawable, você pode descrever uma forma especificando a aparência de seus lados e cada um de seus ângulos.  Essas propriedades especificadas podem ser controladas por um interpolador, o que lhes permite animar. </p><br><p>  Para criar seu próprio MaterialShapeDrawable, você pode usar o construtor para o qual precisa passar um objeto do tipo ShapePathModel nos parâmetros.  Ele armazena informações sobre cada lado e cada canto da figura nas classes EdgeTreatment e CornerTreatment, respectivamente (sempre existem exatamente quatro lados e ângulos, mas isso não interfere na descrição de quase qualquer figura com a ajuda deles).  Você pode especificar as descrições pessoalmente para cada lado e canto, ou defini-las imediatamente para a figura inteira, chamando um método. </p><br><p>  Já existem várias descrições prontas para uso (tratamento) dos lados e ângulos da biblioteca, que incluem a maioria das inovações relacionadas ao formato dos componentes introduzidos no Material Design 2.0.  Já está presente: RoundedCornerTreatment - para cantos arredondados, CutCornerTreatment - para cantos cortados, TriangleEdgeTreatment - para cortar ou adicionar um triângulo ao lado.  Para demonstrar seu trabalho, há um exemplo simples: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> shapePathModel = ShapePathModel().apply { setAllCorners(CutCornerTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat())) setAllEdges(TriangleEdgeTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundDrawable = MaterialShapeDrawable(shapePathModel).apply { setTint(ContextCompat.getColor(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MainActivity</span></span>, R.color.colorPrimary)) paintStyle = Paint.Style.FILL } textView.background = backgroundDrawable</code> </pre> <br><p>  Ficará assim: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/02b/b43/168/02bb431689af8046223fd77e58fd0f2a.png" alt="imagem"></p><br><p>  Obviamente, você pode simplesmente criar suas próprias descrições de rostos e ângulos.  A forma é sempre definida para o elemento superior esquerdo, e o Drawable realiza as operações de rotação / reflexão para obter a forma final.  Há um pequeno exemplo para demonstrar isso: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CutoutCornersTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : CornerTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCornerPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(angle: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.reset(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, size * interpolation) shapePath.lineTo(size * interpolation, size * interpolation) shapePath.lineTo(size * interpolation, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurvedEdgeTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : EdgeTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEdgePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(length: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.quadToPoint(length / <span class="hljs-number"><span class="hljs-number">2f</span></span>, size * interpolation, length, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } }</code> </pre> <br><p>  Se este MaterialShapeDrawable for usado como plano de fundo, o resultado será o seguinte: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/98a/5b5/671/98a5b56711a7a3cec44ed62c459deaf2.png" alt="imagem"></p><br><p>  O pacote bottomappbar da nova Biblioteca de componentes de material possui um BottomAppBarTopEdgeTreatment.  Ele descreve o recorte no BottomAppBar para o botão FloatingActionButton.  Seu lado superior pode ser animado, dependendo da posição e tamanho do botão.  Aconselho que você leia o código dessas classes para ver com seus próprios olhos que o MaterialShapeDrawable é muito flexível de usar e quase tudo pode ser feito com ele. </p><br><p>  Se falamos sobre o ShapeDrawable usual, há outro detalhe que vale a pena mencionar - a capacidade de projetar uma sombra da forma correspondente ao contorno.  Como agora você pode criar contornos de formas muito incomuns usando MaterialShapeDrawable, seria uma decepção não trazer a forma da sombra para a forma da imagem, especialmente quando essas sombras podem ser vistas em todos os lugares no Matarial Design 2.0.  MaterialShapeDrawable também calcula a aparência da sombra.  Usando a propriedade shadowEnabled, você pode ativar a sombra, que seguirá exatamente o contorno da figura, também é possível determinar o raio, a elevação e a cor da sombra.  Parece bom demais para ser verdade?  Infelizmente sim.  Se você usar a sombra de MaterialShapeDrawable, obtém uma sombra normal (desenhada pelo método setShadowLayer () da classe Paint, criada para desenhar sombras no texto), mas cortada nas bordas do componente de interface do usuário no qual o resultado é exibido: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5aa/e8b/134/5aae8b1341f9adabf86daaefeccb09fa.png" alt="imagem"></p><br><p>  Lembre-se de que o MaterialShapeDrawable ainda é considerado experimental, como sua API, e pode mudar no futuro.  Também é importante notar que o código para a nova biblioteca de Componentes de materiais está aberto; portanto, é muito bem-vindo a criação de tickets em um rastreador de bugs ou até mesmo solicitações pull com a correção de problemas conhecidos.  De fato, quando você lê essas linhas, a API já é um pouco diferente na ramificação principal da biblioteca (por exemplo, ShapeAppearanceModel será usado em vez de ShapePathModel), o que indica trabalho ativo.  Um dos recursos promissores no próximo release pode ser a capacidade de determinar os lados / ângulos padrão para todo o tema do aplicativo.  Você pode aprender mais sobre isso na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação oficial</a> ou nas fontes da biblioteca. </p><br><blockquote>  <em>Do tradutor:</em> <br>  <em>É legal que existem ferramentas que adicionam novos recursos ao ShapeDrawable usual e ajudam a criar gráficos não mais simples.</em>  <em>Isso permite que o desenvolvedor não convide o designer para todas as pequenas coisas, mas resolva o problema ele mesmo, e requer significativamente menos tempo.</em>  <em>Estamos aguardando as próximas versões da biblioteca Componentes de materiais para tentar, na prática, novas maneiras de resolver problemas existentes.</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426997/">https://habr.com/ru/post/pt426997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426985/index.html">kubebox e outras conchas do console para o Kubernetes</a></li>
<li><a href="../pt426987/index.html">Aprenda o OpenGL. Lição 6.3 - Iluminação Baseada em Imagem. Irradiação difusa</a></li>
<li><a href="../pt426991/index.html">Startup Digest: 10 próximos eventos de TI em Moscou</a></li>
<li><a href="../pt426993/index.html">Preciso aprender C para entender como um computador funciona?</a></li>
<li><a href="../pt426995/index.html">A reciclagem prejudica produtos e funcionários</a></li>
<li><a href="../pt426999/index.html">Seguindo as tendências ou avançando para o RxJava e o LiveData</a></li>
<li><a href="../pt427003/index.html">Mapas hexagonais em Unity: neblina da guerra, pesquisa de mapas, geração de procedimentos</a></li>
<li><a href="../pt427005/index.html">Desenvolvedores de IA - a profissão de milionários?</a></li>
<li><a href="../pt427009/index.html">"Andar" de um elétron: manipulações com uma carga dentro da estrutura de ligações não saturadas</a></li>
<li><a href="../pt427011/index.html">Meu "Olá Mundo!" no FPGA ou na próxima versão do UART</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>