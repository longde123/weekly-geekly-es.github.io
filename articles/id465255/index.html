<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏽 🚷 🤟🏼 Implementasi Pool Connection WCF untuk .Net Core Menggunakan HttpClientFactory ☝️ 👨🏽‍🎤 🌠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Produk kami dikembangkan pada platform .Net Core 2.2 menggunakan WCF 4.5 untuk berinteraksi dengan layanan klien SOAP. Selama layanan, pengembang bus ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi Pool Connection WCF untuk .Net Core Menggunakan HttpClientFactory</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/465255/">  Produk kami dikembangkan pada platform .Net Core 2.2 menggunakan WCF 4.5 untuk berinteraksi dengan layanan klien SOAP.  Selama layanan, pengembang bus data melihat beban tinggi di server.  Selanjutnya, masalah dengan akses ke layanan mulai muncul.  Akibatnya, ditemukan bahwa alasannya terletak pada jumlah senyawa aktif. <br><br>  Ada masalah seperti koneksi habis.  Mungkin timbul karena kurangnya port yang tersedia ketika membuat koneksi atau membatasi jumlah koneksi ke layanan eksternal atau internal.  Ada dua solusi: <br><br>  • Meningkatkan sumber daya yang tersedia, <br>  • Mengurangi jumlah koneksi. <br><br>  Opsi pertama tidak tersedia bagi kami, karena peningkatan sumber daya hanya dapat dilakukan di sisi penyedia layanan.  Oleh karena itu, kami memutuskan untuk mencari opsi untuk mengoptimalkan jumlah senyawa.  Pada artikel ini kita akan membahas tentang solusi yang ditemukan. <br><br><img src="https://habrastorage.org/webt/pp/zw/sq/ppzwsq2l98gcj1dkq5enfnbsslk.jpeg"><br><a name="habracut"></a><br><h2>  Ide </h2><br>  Ternyata, masalahnya adalah bahwa untuk setiap permintaan kami membuat contoh baru dari klien WCF.  Ini membuatnya tidak mungkin untuk menggunakan kumpulan koneksi yang sudah diterapkan di WCF, karena kumpulan dibuat untuk setiap saluran, dan kami membuat saluran baru untuk setiap permintaan.  Tentu saja, Anda dapat menulis ulang layanan yang bertanggung jawab untuk berinteraksi dengan WCF menggunakan klien WCF statis.  Tetapi dalam kasus ini, kumpulan juga akan statis, yang dapat menyebabkan masalah dengan perubahan DNS, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibahas dalam artikel ini</a> .  Ini juga berbicara tentang solusinya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://docs.microsoft.com/ru-ru/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-">HttpClientFactory</a> .  Inti dari solusinya adalah bahwa pabrik dapat bekerja dengan kelompoknya sendiri, di mana koneksi diperbarui secara berkala.  Periode pembaruan default adalah dua menit, tetapi dapat diubah. <br><br>  Dalam produk kami, kami telah menggunakan HttpClientFactory untuk berinteraksi dengan layanan lain, dan menggunakan pabrik di WCF tampak seperti alternatif yang baik untuk klien WCF statis.  Dalam hal ini, kami tidak perlu melakukan perubahan pada implementasi layanan WCF.  Tapi mereka bisa menggunakan kolam yang bisa digunakan pabrik.  Selain itu, ini memungkinkan kami untuk menyelesaikan masalah dengan otentikasi NTLM di Linux, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan dalam artikel ini</a> , karena ketika mengkonfigurasi klien http, Anda dapat mengatur skema otentikasi untuk penangan pesan. <br><br><h3>  Implementasi </h3><br>  Untuk bekerja dengan HttpClientFactory, cukup tambahkan deskripsi konfigurasi klien ke ConfigureServices.  Di sana Anda dapat menambahkan beberapa klien bernama atau mengetik dengan konfigurasi Anda sendiri.  Dalam hal ini, setiap klien akan menggunakan kumpulan koneksi sendiri.  Dalam contoh, kami menggunakan klien bernama. <br><br><pre><code class="plaintext hljs">services.AddHttpClient("ClientName");</code> </pre> <br>  Di WCF, Anda dapat menambahkan penangan pesan Anda sendiri untuk klien http.  Untuk melakukan ini, tambahkan delegasi diinisialisasi oleh metode ke parameter yang mengikat.  Di sana, sebagai parameter input, kita mendapatkan handler yang dibuat di sisi WCF dan mengembalikan handler kita sendiri.  Akibatnya, pawang yang diperoleh dari metode delegasi akan diteruskan ke desainer http klien di sisi WCF. <br><br>  Jadi, mengembalikan handler dari pool pabrik, kami akan mengganti handler yang masuk dengannya.  Untuk mendapatkan pawang dari kumpulan pabrik, kami menggunakan HttpMessageHandlerFactory.  Dan untuk mendapatkan akses ke parameter yang mengikat, perlu untuk mengimplementasikan kelas yang diwarisi dari IEndpointBehavior.  Dan kemudian menambahkannya ke klien WCF kami. <br><br>  Secara skematis, algoritma untuk membuat klien baru di sisi WCF terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/wu/3j/eo/wu3jeomxr57pctuyf327lf56rua.png"><br><br>  Kami menerapkan CustomEndpointBehaviour. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomEndpointBehavior</span></span></span><span class="hljs-class"> :</span></span> IEndpointBehavior { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly Func&lt;HttpMessageHandler&gt; _httpHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomEndpointBehavior</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IHttpMessageHandlerFactory factory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       _httpHandler = () =&gt; factory.CreateHandler("ClientName"); } public void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters) { //      bindingParameters.Add(new Func&lt;HttpClientHandler, HttpMessageHandler&gt;(handler =&gt; _httpHandler())); } public void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime) { } public void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher) { } public void Validate(ServiceEndpoint endpoint) { } }</span></span></code> </pre> <br>  Selanjutnya, tambahkan EndpointBehavior kami ke klien WCF. <br><br><pre> <code class="cpp hljs">var httpMessageHandler = serviceProvider.GetRequiredService&lt;IHttpMessageHandlerFactory&gt;(); var client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WcfClient(); client.Endpoint.EndpointBehaviors.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomEndpointBehavior(httpMessageHandler));</code> </pre><br>  Sekarang ketika membuat koneksi melalui WCF, bila memungkinkan, instance handler dari pool akan digunakan.  Ini akan mengurangi jumlah senyawa aktif. <br><br><h3>  Tes </h3><br>  Untuk verifikasi, kami mengirim 100 permintaan yang identik.  Akibatnya, tanpa kolam, puncak senyawa mencapai 53, dan dengan kolam itu tidak melebihi 7. <br><br>  Memantau koneksi tanpa kolam: <br><br><img src="https://habrastorage.org/webt/oi/wq/-m/oiwq-mdsy5lw0ex3axsdb9umuvs.png"><br><br>  Pemantauan koneksi kolam: <br><br><img src="https://habrastorage.org/webt/2z/ai/o5/2zaio5zart9ocfkomqlyf77ingc.png"><br><br><h3>  Kesimpulan </h3><br>  Kami di True Engineering menerapkan kumpulan koneksi di WCF, yang tidak tergantung pada implementasi bekerja dengan klien WCF.  Ini juga secara efektif menghemat sumber daya di sisi server tempat aplikasi berjalan, dan di sisi penyedia layanan. <br><br>  Kami menghabiskan banyak waktu mencari opsi pengoptimalan, tetapi solusinya sendiri ternyata singkat dan sederhana.  Ambillah selagi panas) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465255/">https://habr.com/ru/post/id465255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465241/index.html">Hari ketujuh saya dengan Haiku: daftar, pemindaian, jaringan</a></li>
<li><a href="../id465245/index.html">Lihat antarmuka "melalui mata desainer": tentang interaksi front-end dengan desainer</a></li>
<li><a href="../id465247/index.html">Sudut Memahami @Input, @Output, dan EventEmitter</a></li>
<li><a href="../id465249/index.html">Kuliah oleh Richard Stallman di Politeknik Moskow. Agustus 2019</a></li>
<li><a href="../id465251/index.html">Musim panas hampir berakhir. Hampir tidak ada data yang bocor</a></li>
<li><a href="../id465257/index.html">"Waspadalah, FAS!": Trik McDonald's, shawarma ilahi, Clooney palsu dan beberapa sihir jalanan</a></li>
<li><a href="../id465259/index.html">ValueTask <TResult> - mengapa, mengapa dan bagaimana?</a></li>
<li><a href="../id465261/index.html">Kekuatan sihir makro, atau cara membuat hidup lebih mudah bagi programmer assembler AVR</a></li>
<li><a href="../id465263/index.html">Locks in PostgreSQL: 3. Mengunci objek lain</a></li>
<li><a href="../id465267/index.html">TypeScript Sihir Ekspresi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>