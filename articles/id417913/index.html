<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏼 🛀🏻 🕴🏻 Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 3 🔐 🈯️ 🚸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan melihat dua tempat lagi di mana pbrt menghabiskan banyak waktu mengurai adegan dari kartun Disney "Moana" . Mari kita lihat apakah ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417913/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/025/729/0d7025729325723a1c454f795c17af39.jpg" alt="gambar"></div><br>  Hari ini kita akan melihat dua tempat lagi di mana pbrt menghabiskan banyak waktu mengurai adegan dari kartun Disney <em>"Moana"</em> .  Mari kita lihat apakah mungkin untuk meningkatkan produktivitas di sini.  Ini diakhiri dengan apa yang bijaksana untuk dilakukan di pbrt-v3.  Di pos lain, saya akan membahas seberapa jauh kita bisa melangkah jika kita meninggalkan larangan perubahan.  Dalam hal ini, kode sumber akan terlalu berbeda dari sistem yang dijelaskan dalam buku <em>Rendering Berbasis Fisik</em> . <br><br><h2>  Optimasi Parser </h2><br>  Setelah peningkatan kinerja yang diperkenalkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> , proporsi waktu yang dihabiskan di pbrt parser, dan sangat signifikan dari awal, secara alami meningkat bahkan lebih.  Saat ini, parser saat startup dihabiskan sebagian besar waktu. <br><br>  Saya akhirnya mengumpulkan kekuatan saya dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengimplementasikan tokenizer dan parser yang ditulis secara manual</a> untuk adegan pbrt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Format file adegan pbrt</a> cukup sederhana untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diurai</a> : jika Anda tidak memperhitungkan garis yang dikutip, token dipisahkan oleh spasi, dan tata bahasanya sangat mudah (tidak pernah ada kebutuhan untuk melihat lebih dari satu token), tetapi parser Anda sendiri masih seribu baris kode yang Anda butuhkan tulis dan debug.  Itu membantu saya bahwa itu dapat diuji pada banyak adegan;  setelah memperbaiki gangguan yang jelas, saya terus bekerja sampai saya berhasil membuat gambar yang persis sama seperti sebelumnya: seharusnya tidak ada perbedaan dalam piksel karena mengganti parser.  Pada tahap ini, saya benar-benar yakin bahwa semuanya dilakukan dengan benar. <br><a name="habracut"></a><br>  Saya mencoba membuat versi baru seefisien mungkin, menundukkan file input ke <code>mmap()</code> sebanyak mungkin dan menggunakan implementasi baru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>std::string_view</code></a> dari C ++ 17 untuk meminimalkan pembuatan salinan string dari isi file.  Selain itu, karena <code>strtod()</code> membutuhkan banyak waktu di jejak sebelumnya, saya menulis <a href=""><code> parseNumber()</code></a> dengan perawatan khusus: bilangan bulat tunggal dan bilangan bulat biasa diproses secara terpisah, dan dalam kasus standar ketika pbrt dikompilasi untuk menggunakan pelampung 32-bit , menggunakan <code>strtof()</code> bukannya <code>strtod()</code> <sup>1</sup> . <br><br>  Dalam proses membuat implementasi parser baru, saya agak takut parser lama akan lebih cepat: pada akhirnya, flex dan bison telah dikembangkan dan dioptimalkan selama bertahun-tahun.  Saya tidak bisa mengetahui sebelumnya apakah sepanjang waktu menulis versi baru akan sia-sia sampai saya menyelesaikannya dan membuatnya berfungsi dengan benar. <br><br>  Yang menggembirakan saya, pengurai kita sendiri ternyata merupakan kemenangan besar: generalisasi dari flex dan bison mengurangi kinerja sehingga versi baru dengan mudah mengambil alih mereka.  Berkat parser baru, waktu peluncuran menurun menjadi 13 menit 21 detik, artinya, ia mempercepat 1,5 kali lagi!  Bonus tambahan adalah bahwa sekarang mungkin untuk menghapus semua dukungan flex dan bison dari sistem pbrt build.  Selalu sakit kepala, terutama di Windows, di mana kebanyakan orang tidak menginstalnya secara default. <br><br><h2>  Manajemen Status Grafik </h2><br>  Setelah mempercepat pengurai secara signifikan, muncul detail baru yang menjengkelkan: pada tahap ini, sekitar 10% dari waktu pengaturan dihabiskan untuk fungsi <code>pbrtAttributeBegin()</code> dan <code>pbrtAttributeEnd()</code> , dan sebagian besar waktu ini dialokasikan dan dirilis memori dinamis.  Selama menjalankan pertama, yang memakan waktu 35 menit, fungsi-fungsi ini hanya memakan waktu sekitar 3% dari waktu eksekusi, sehingga mereka dapat diabaikan.  Tetapi dengan optimasi selalu seperti ini: ketika Anda mulai menyingkirkan masalah besar, masalah kecil menjadi lebih penting. <br><br>  Deskripsi adegan pbrt didasarkan pada status hierarkis grafik, yang menunjukkan transformasi saat ini, materi saat ini, dan sebagainya.  Di dalamnya, Anda dapat mengambil snapshot dari kondisi saat ini ( <code>pbrtAttributeBegin()</code> ), membuat perubahan sebelum menambahkan geometri baru ke adegan, dan kemudian kembali ke keadaan semula ( <code>pbrtAttributeEnd()</code> ). <br><br>  Keadaan grafik disimpan dalam struktur dengan nama yang tidak terduga ... <code>GraphicsState</code> .  Untuk menyimpan salinan objek <code>GraphicsState</code> dalam tumpukan status grafik yang disimpan, <code>std::vector</code> .  Melihat anggota <code>GraphicsState</code> , kita dapat mengasumsikan sumber masalah - three <code>std::map</code> , dari nama hingga contoh tekstur dan bahan: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphicsState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... std::map&lt;std::string, std::shared_ptr&lt;Texture&lt;Float&gt;&gt;&gt; floatTextures; std::map&lt;std::string, std::shared_ptr&lt;Texture&lt;Spectrum&gt;&gt;&gt; spectrumTextures; std::map&lt;std::string, std::shared_ptr&lt;MaterialInstance&gt;&gt; namedMaterials; };</span></span></code> </pre> <br>  Meneliti file adegan ini, saya menemukan bahwa sebagian besar kasus penyimpanan dan pengembalian status grafis dilakukan dalam baris berikut: <br><br><pre> <code class="cpp hljs">AttributeBegin ConcatTransform [<span class="hljs-number"><span class="hljs-number">0.981262</span></span> <span class="hljs-number"><span class="hljs-number">0.133695</span></span> <span class="hljs-number"><span class="hljs-number">-0.138749</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">-0.067901</span></span> <span class="hljs-number"><span class="hljs-number">0.913846</span></span> <span class="hljs-number"><span class="hljs-number">0.400343</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">0.180319</span></span> <span class="hljs-number"><span class="hljs-number">-0.383420</span></span> <span class="hljs-number"><span class="hljs-number">0.905800</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">11.095301</span></span> <span class="hljs-number"><span class="hljs-number">18.852249</span></span> <span class="hljs-number"><span class="hljs-number">9.481399</span></span> <span class="hljs-number"><span class="hljs-number">1.000000</span></span>] ObjectInstance <span class="hljs-string"><span class="hljs-string">"archivebaycedar0001_mod"</span></span> AttributeEnd</code> </pre> <br>  Dengan kata lain, itu memperbarui transformasi saat ini dan instantiate objek;  tidak ada perubahan pada isi <code>std::map</code> .  Membuat salinan lengkap dari mereka - mengalokasikan node pohon merah-hitam, meningkatkan jumlah referensi untuk pointer umum, mengalokasikan ruang dan menyalin string - hampir selalu buang-buang waktu.  Semua ini dibebaskan ketika mengembalikan keadaan grafis sebelumnya. <br><br>  Saya mengganti masing-masing peta ini dengan pointer <code>std::shared_ptr</code> untuk memetakan dan menerapkan pendekatan copy-on-write, di mana penyalinan di dalam blok awal / akhir atribut hanya terjadi ketika isinya perlu diubah.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perubahan</a> itu tidak terlalu sulit, tetapi mengurangi waktu peluncuran lebih dari satu menit, yang memberi kami 12 menit 20 detik pemrosesan sebelum dimulainya rendering - lagi akselerasi 1,08 kali. <br><br><h2>  Bagaimana dengan rendering time? </h2><br>  Pembaca yang penuh perhatian akan memperhatikan bahwa sejauh ini saya belum mengatakan apa-apa tentang waktu render.  Yang mengejutkan saya, ternyata cukup lumayan bahkan di luar kotak: pbrt dapat membuat gambar adegan dengan kualitas sinematik dengan beberapa ratus sampel per piksel pada dua belas inti prosesor untuk jangka waktu dua hingga tiga jam.  Misalnya, gambar ini, salah satu yang paling lambat, ditampilkan dalam 2 jam 51 menit 36 ​​detik: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/025/729/0d7025729325723a1c454f795c17af39.jpg"></div><br>  <i>Bukit pasir dari Moana disajikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pbrt-v3</a> dengan resolusi 2048x858 pada 256 sampel per piksel.</i>  <i>Total waktu rendering pada mesin Google Compute Engine dengan 12 core / 24 thread dengan frekuensi 2 GHz dan versi terbaru dari pbrt-v3 adalah 2 jam 51 menit 36 ​​detik.</i> <br><br>  Menurut pendapat saya, ini sepertinya indikator yang masuk akal.  Saya yakin bahwa perbaikan masih mungkin dilakukan, dan studi yang cermat terhadap tempat-tempat di mana sebagian besar waktu dihabiskan akan mengungkapkan banyak hal yang "menarik", tetapi sejauh ini tidak ada alasan khusus untuk itu. <br><br>  Ketika profiling, ternyata sekitar 60% dari waktu rendering dihabiskan di persimpangan sinar dengan objek (sebagian besar operasi dilakukan melewati BVH), dan 25% dihabiskan mencari tekstur ptex.  Rasio ini mirip dengan indikator adegan yang lebih sederhana, jadi pada pandangan pertama tidak ada yang jelas bermasalah di sini.  (Namun, saya yakin Embree akan dapat melacak sinar ini dalam waktu yang lebih singkat.) <br><br>  Sayangnya, skalabilitas paralel tidak begitu baik.  Saya biasanya melihat bahwa 1400% sumber daya CPU dihabiskan untuk rendering, dibandingkan dengan ideal 2400% (pada 24 CPU virtual di Google Compute Engine).  Tampaknya masalah ini terkait dengan konflik saat mengunci di ptex, tetapi saya belum menyelidiki secara lebih rinci.  Sangat mungkin bahwa pbrt-v3 tidak menghitung perbedaan sinar untuk sinar tidak langsung pada pelacak sinar;  pada gilirannya, balok seperti itu selalu mendapatkan akses ke tingkat tekstur MIP yang paling terperinci, yang tidak terlalu berguna untuk caching tekstur. <br><br><h2>  Kesimpulan (untuk pbrt-v3) </h2><br>  Setelah mengoreksi manajemen keadaan grafik, saya berlari ke batas, setelah itu kemajuan lebih lanjut tanpa membuat perubahan signifikan pada sistem menjadi tidak jelas;  semua yang lain membutuhkan banyak waktu dan tidak ada hubungannya dengan optimasi.  Karena itu, saya akan membahas hal ini, setidaknya berkaitan dengan pbrt-v3. <br><br>  Secara umum, progresnya serius: waktu peluncuran sebelum rendering berkurang dari 35 menit menjadi 12 menit 20 detik, artinya, total akselerasi adalah 2,83 kali.  Selain itu, berkat kerja yang cerdas dengan cache konversi, penggunaan memori telah menurun dari 80 GB menjadi 69 GB.  Semua perubahan ini tersedia sekarang jika Anda menyinkronkan dengan versi terbaru dari pbrt-v3 (atau jika Anda telah melakukan ini selama beberapa bulan terakhir). Dan kita mulai memahami betapa sampah memori <code>Primitive</code> untuk adegan ini;  kami menemukan cara untuk menghemat memori 18 GB lainnya, tetapi tidak menerapkannya di pbrt-v3. <br><br>  Inilah yang menghabiskan 12 menit 20 detik setelah semua optimasi kami: <br><br><table><thead><tr><th>  Fungsi / Operasi </th><th>  Persentase Runtime </th></tr></thead><tbody><tr><td>  Bangun BVH </td><td>  34% </td></tr><tr><td>  Parsing (kecuali <code>strtof()</code> ) </td><td>  21% </td></tr><tr><td> <code>strtof()</code> </td> <td>  20% </td></tr><tr><td>  Tembolok konversi </td><td>  7% </td></tr><tr><td>  Membaca File PLY </td><td>  6% </td></tr><tr><td>  Alokasi memori dinamis </td><td>  5% </td></tr><tr><td>  Pembalikan konversi </td><td>  2% </td></tr><tr><td>  Manajemen Status Grafik </td><td>  2% </td></tr><tr><td>  Lainnya </td><td>  3% </td></tr></tbody></table><br>  Di masa depan, opsi terbaik untuk meningkatkan kinerja akan menjadi multithreading yang lebih besar dari tahap peluncuran: hampir semuanya selama penguraian adegan adalah single-threaded;  tujuan pertama kami yang paling alami adalah membangun BVH.  Ini juga akan menarik untuk menganalisis hal-hal seperti membaca file PLY dan menghasilkan BVH untuk setiap instance objek dan mengeksekusi mereka secara tidak sinkron di latar belakang, sementara parsing akan dilakukan di utas utama. <br><br>  Pada titik tertentu, saya akan melihat apakah ada implementasi <code>strtof()</code> yang lebih cepat;  pbrt hanya menggunakan apa yang disediakan sistem.  Namun, Anda harus berhati-hati dengan pilihan penggantian yang tidak diuji secara menyeluruh: parsing float values ​​adalah salah satu aspek yang harus benar-benar dipastikan oleh programmer. <br><br>  Ini juga terlihat menarik untuk lebih mengurangi beban pada parser: kami masih memiliki 17 GB file input teks untuk parsing.  Kita dapat menambahkan dukungan penyandian biner untuk file input pbrt (mungkin mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pendekatan RenderMan</a> ), tetapi saya memiliki perasaan campur aduk tentang ide ini;  kemampuan untuk membuka dan memodifikasi file deskripsi adegan dalam editor teks cukup berguna, dan saya khawatir bahwa kadang-kadang kode biner akan membingungkan siswa menggunakan pbrt dalam proses pembelajaran.  Ini adalah salah satu kasus di mana solusi yang tepat untuk pbrt mungkin berbeda dari solusi untuk render komersial tingkat produksi. <br><br>  Sangat menarik untuk melacak semua optimasi ini dan untuk lebih memahami berbagai solusi.  Ternyata pbrt memiliki asumsi tak terduga yang mengganggu adegan tingkat kerumitan ini.  Semua ini adalah contoh yang bagus tentang betapa pentingnya bagi komunitas luas yang memberikan peneliti untuk memiliki akses ke adegan produksi nyata dengan tingkat kompleksitas yang tinggi;  Saya sekali lagi mengucapkan banyak terima kasih kepada Disney untuk waktu yang dihabiskan untuk memproses adegan ini dan meletakkannya di domain publik. <br><br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel selanjutnya</a> , kita akan melihat aspek-aspek yang dapat lebih meningkatkan kinerja jika kita mengizinkan pbrt untuk membuat perubahan yang lebih radikal. <br><br><h2>  Catatan </h2><br><ol><li>  Pada sistem Linux yang saya uji, <code>strtof()</code> tidak lebih cepat dari <code>strtod()</code> .  Perlu dicatat bahwa pada OS X <code>strtod()</code> sekitar dua kali lebih cepat, yang sama sekali tidak masuk akal.  Untuk alasan praktis, saya terus menggunakan <code>strtof()</code> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417913/">https://habr.com/ru/post/id417913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417901/index.html">Bagaimana kami mulai membuat pertemuan panjang yang luar biasa, dan mengapa ini bukan lagi kejahatan universal</a></li>
<li><a href="../id417903/index.html">Kasus Peninjauan Kode 1</a></li>
<li><a href="../id417905/index.html">11 cara (tidak) untuk menjadi korban peretasan di Kubernetes</a></li>
<li><a href="../id417909/index.html">Mengapa Anda perlu Splunk? Analisis aplikasi</a></li>
<li><a href="../id417911/index.html">Desain berkelanjutan dalam pengembangan: metodologi dan prinsip</a></li>
<li><a href="../id417915/index.html">Cara bermain teman sekamar</a></li>
<li><a href="../id417917/index.html">ASC'18: Kegigihan dan pelatihan reguler sebagai cara untuk mencapai tujuan</a></li>
<li><a href="../id417919/index.html">Pemodelan getaran dan kebisingan di gearbox mobil</a></li>
<li><a href="../id417927/index.html">Pertarungan Dunia Maya di PHDays, atau Cara Meretas Infrastruktur Kota dalam 30 Jam</a></li>
<li><a href="../id417929/index.html">Kutipan dari buku “One Day in the Life of the Brain. Neurobiologi kesadaran dari fajar hingga senja ”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>