<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õàÔ∏è ü¶ó ‚ù£Ô∏è P√©dalez jusqu'au sol: cr√©ez un autre manipulateur de pied pour PC üôÖüèø üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ ‚õèÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a tout juste un mois, je suis tomb√© sur cet article, qui raconte comment p√©daler Vim. Un peu plus tard, apr√®s ma longue √©tude de trois minutes, j...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>P√©dalez jusqu'au sol: cr√©ez un autre manipulateur de pied pour PC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462263/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/y3/4b/ju/y34bjuvl5jcdfxml6kgtlpgkdy4.png"></div><br>  Il y a tout juste un mois, je suis tomb√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet</a> article, qui raconte comment p√©daler Vim.  Un peu plus tard, apr√®s ma longue √©tude de trois minutes, j'ai d√©couvert que ce sujet n'√©tait plus nouveau et assez populaire.  Je n'utilise moi-m√™me Vim qu'en cas d'urgence (si je dois travailler dans la console, je pr√©f√®re Nano), mais vous pouvez faire de m√™me pour d'autres applications. <br><a name="habracut"></a><br>  Au d√©part, je voulais faire un petit article, mais j'ai eu un tutoriel complet sur la cr√©ation de cet appareil avec l'√©criture de code √©tape par √©tape et une explication de quoi et comment.  Afin de ne pas gonfler l'article, sous les spoilers il y aura diverses informations qui semblaient int√©ressantes et dignes de l'attention des nouveaux arrivants √† Arduino, les utilisateurs avanc√©s et surtout h√¢tifs ne perdront pas de temps √† ce sujet.  Le code source complet est √©galement pr√©sent√© √† la fin de l'article. <br><br><h2>  Pourquoi en ai-je besoin? </h2><br>  Si vous n'avez aucun doute sur la n√©cessit√© et l'utilit√© de cet appareil, vous pouvez ignorer cet √©l√©ment.  Pour le reste, je voudrais d'abord parler des conditions pr√©alables √† la cr√©ation de cet appareil. <br><br>  √Ä tout moment, les programmeurs et les concepteurs ont essay√© de cr√©er une interface pratique et conviviale afin que l'utilisateur puisse travailler avec l'application √† l'aide de la souris et du clavier sans probl√®mes inutiles, alors pourquoi avons-nous besoin d'un autre manipulateur?  Eh bien, regardons un peu l'histoire, ou plut√¥t, au d√©but du XVIIIe si√®cle, quand un instrument de musique comme le piano a √©t√© invent√©.  Comme vous le savez, ce mot se traduit litt√©ralement par ¬´fort et silencieux¬ª, mais peu de gens pensent qu'un ma√Ætre italien intelligent a re√ßu un tel instrument en ¬´√©crasant¬ª le clavecin qui existait alors, ce qui a permis de contr√¥ler le volume sonore dans une certaine mesure, sans enlever les mains des cl√©s. <br><br>  Il existe de nombreux exemples.  La voiture a des p√©dales pour ne pas lancer le volant si vous devez ajouter de l'essence.  Le kit de batterie a √©galement des p√©dales pour frapper la grosse caisse et les cymbales.  Et que peuvent donner les p√©dales lors de l'utilisation d'un ordinateur?  Eh bien, par exemple, vous pouvez d√©finir une combinaison de touches de raccourci, ou m√™me ajouter une touche qui n'est pas l√†, comme activer et d√©sactiver le son.  Les p√©dales peuvent aider si vos mains sont occup√©es: je joue de la guitare moi-m√™me, et parfois √† l'accompagnement, il serait tr√®s pratique pour moi de rouler le backing sans essayer d'atteindre constamment le clavier.  Et enfin, les contr√¥leurs peuvent donner des possibilit√©s compl√®tement inhumaines dans les jeux: ce serait cool de construire votre base enti√®re dans une strat√©gie en un clic ou de d√©truire les ennemis √† une vitesse d'une douzaine de battements par seconde dans les tireurs, non? <br><br>  En g√©n√©ral, j'esp√®re vous avoir convaincu, ce qui signifie qu'il est temps de commencer directement le d√©veloppement lui-m√™me. <br><br><h2>  Ressources n√©cessaires </h2><br><ul><li>  <b>En fait, les p√©dales.</b>  Des difficult√©s ont imm√©diatement surgi du fait que je ne pouvais pas penser √† un nom pour une telle p√©dale.  Je savais seulement que de telles choses sont utilis√©es dans les machines √† coudre.  En g√©n√©ral, √† la demande de <b>p√©dale √©lectrique,</b> j'ai quand m√™me r√©ussi √† trouver ce dont j'avais besoin sur Aliexpress, et sans y r√©fl√©chir √† deux fois, j'ai command√© 3 pi√®ces. <br></li><li>  <b>Contr√¥leur</b>  Le p√©dalier doit √©muler le clavier et, √©ventuellement, la souris pour pouvoir se connecter √† un PC sans pilotes inutiles.  Pour cela, la carte Arduino Pro Micro est parfaite, qui, bien qu'elle n'ait pas de conclusions, est aussi compacte que possible.  Nous allons au m√™me Aliexpress et achetons la version chinoise de ce miracle. <br></li><li>  <b>Fils.</b>  Pour placer 3 p√©dales sous la table, vous avez besoin d'au moins un fil √† quatre fils d'une longueur d'au moins un m√®tre.  Ici, je pense que les probl√®mes ne devraient pas se poser. <br></li><li>  <b>LED RGB et bouton.</b>  Le premier est n√©cessaire pour indiquer les modes, et le second est de les changer. <br></li><li>  Eh bien, bien s√ªr, nous avons besoin d'un IDE Arduino, d'un fer √† souder et de bras droits. <br></li></ul><br><h2>  Diagramme de l'appareil </h2><br>  Avant m√™me l'arriv√©e des colis, j'ai commenc√© √† cr√©er un diagramme de p√©riph√©rique.  Bien que cela en soit dit beaucoup, puisque je n'avais qu'√† brancher les p√©dales, la diode et le bouton.  Il s'est av√©r√© en quelque sorte comme ceci: <br><br><img src="https://habrastorage.org/webt/7m/o8/yw/7mo8ywvzsfwlefxt7f-4ijqtejm.jpeg"><br><br>  Pour les p√©dales, j'ai d√©cid√© d'allouer 4 ports PB1-PB4 √† la fois, c'est-√†-dire deux pour la gauche et deux pour la jambe droite, bien que jusqu'√† pr√©sent je n'ai que 3 p√©dales. De plus, elles sont toutes dans le m√™me groupe et sont situ√©es au m√™me endroit.  Sous la LED, j'ai pris les sorties PD0, PD1 et PD4, sous le bouton - PD7. <br>  Dans ce cas, nous n'avons pas besoin de r√©sistances de rappel, si vous utilisez celles qui sont int√©gr√©es dans le contr√¥leur.  Il est vrai que lorsque vous appuyez sur un bouton ou une p√©dale, l'entr√©e sera faible et lorsqu'elle sera rel√¢ch√©e, elle sera √©lev√©e, c'est-√†-dire que les pressions seront invers√©es, et vous ne devriez pas oublier cela. <br><br><h2>  √âcriture de code </h2><br>  Cette √©tape a √©t√© la plus difficile: en raison de quelques erreurs dans les pointeurs, j'ai effac√© le chargeur de d√©marrage plusieurs fois et, par cons√©quent, j'ai failli faire √©chouer la carte au niveau du logiciel.  Ci-dessous, toutes les √©tapes de cr√©ation du firmware sont d√©crites en d√©tail, pour ceux qui veulent juste obtenir un code de travail, ce sera √† la fin de l'article. <br><br><h3>  La pr√©paration </h3><br>  Nous devons d'abord comprendre ce qu'est la p√©dale en termes de programme.  J'ai d√©cid√© de permettre de r√©gler les p√©dales de l'un des deux modes - temps r√©el et d√©clenchement.  En m√™me temps, chaque p√©dale a deux programmes: le premier est ex√©cut√© lorsque la p√©dale est maintenue en temps r√©el ou avec des pressions impaires en mode de d√©clenchement, la seconde est lorsque la p√©dale est rel√¢ch√©e en temps r√©el ou lorsque les p√©dales sont enfonc√©es uniform√©ment en mode de d√©clenchement.  La p√©dale a √©galement un port, un √©tat et deux variables - les positions actuelles dans les programmes 1 et 2. J'ai obtenu cette structure: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> port; <span class="hljs-comment"><span class="hljs-comment">//   char state; //  ,   char oldState; //  ,   char pos1; //  1 char pos2; //  2 unsigned char type; //0 ‚Äî   , 1 ‚Äî  ; unsigned char act1[16]; // 1 unsigned char act2[16]; // 2 };</span></span></code> </pre> <br>  Arduino a un peu de m√©moire et est √©galement 8 bits, il est donc pr√©f√©rable d'essayer d'utiliser char plut√¥t que int dans la mesure du possible. <br><br>  Nous avons √©galement besoin de la biblioth√®que de claviers standard pour fonctionner comme un clavier. <br><br><h3>  Cliquez sur Traitement </h3><br>  Nous devons maintenant cr√©er un interpr√©teur qui lira les donn√©es du tableau et les enverra sous forme de touches √† la machine, ainsi que s√©lectionner plusieurs valeurs pour diverses commandes internes.  Nous ouvrons la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page</a> avec les codes cl√©s, et voyons quoi et comment nous pouvons cliquer.  Je n'ai pas creus√© profond√©ment et √©tudi√© toutes sortes de normes de clavier, car les informations ici me semblaient assez suffisantes pour un tel projet.  La premi√®re moiti√© est r√©serv√©e aux caract√®res ASCII standard (bien que certains d'entre eux ne soient pas imprimables ou non utilis√©s), la seconde moiti√© est destin√©e √† diverses touches de modification.  Il y a m√™me des codes s√©par√©s pour les touches gauche et droite, ce qui √©tait tr√®s agr√©able, mais je n'ai pas vu de codes sp√©ciaux pour les num√©ros du nampad, bien que, pour autant que je sache, ils sont per√ßus d'une mani√®re sp√©ciale dans le syst√®me que les num√©ros ordinaires.  Peut-√™tre que leurs codes se trouvent quelque part dans les ¬´trous¬ª, entre les plages, mais ce n'est plus le cas.  Donc, le plus gros code est la touche haut - 218, ce qui signifie que la plage 219-255 peut √™tre consid√©r√©e comme libre, enfin, ou du moins il n'y a pas de cl√©s importantes. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pedalAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//255  ,     if (pedal1-&gt;type == 255) return; //     unsigned char *prg; //     char *pos; if (pedal1-&gt;type) { //       int current; if ((current = digitalRead(ports[num])) != oldState[num]) { if (!current) state[num] = !state[num]; oldState[num] = current; } if (!state[num]) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } else { //        if (!digitalRead(ports[num])) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } while (1) { if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos&gt;=16) pos = 0; } }</span></span></code> </pre><br>  Je pense que m√™me une personne n'ayant pas le plus haut niveau de connaissance de C n'aura pas de questions sur ce qui se passe ici.  Tout d'abord, la fonction s√©lectionne la p√©dale souhait√©e et d√©termine, en fonction du mode et de l'√©tat de la p√©dale, le programme √† ex√©cuter.  Lors de la lecture de chaque √©l√©ment du tableau, s'il ne s'agit pas d'un caract√®re de contr√¥le, la fonction Keyboard.write () est appel√©e, qui √©mule en appuyant et en rel√¢chant une touche.  Les caract√®res de contr√¥le sont trait√©s s√©par√©ment et sont n√©cessaires pour bloquer les combinaisons de touches et naviguer dans le programme. <br><br><div class="spoiler">  <b class="spoiler_title">Quelques fonctionnalit√©s du mode clavier</b> <div class="spoiler_text">  Keyboard.write () a des nuances simples, mais pas √©videntes pour les d√©butants, bas√©es sur le fait que nous envoyons des donn√©es non pas sous forme brute, mais sous forme de touches.  Tout d'abord, √©trangement, sans pilotes suppl√©mentaires, l'ordinateur ne peut accepter que les caract√®res du clavier qui se trouvent sur le clavier, ce qui signifie que nous ne pourrons pas envoyer de 0x03 (signal d'interruption) ou 0x1B (d√©but de la s√©quence ESCAPE).  Deuxi√®mement, nous pouvons ajuster les lettres majuscules telles qu'elles sont dans le tableau ASCII, mais la machine obtiendra la combinaison de touches Maj + &lt;lettre minuscule&gt;.  Cela peut devenir un probl√®me si nous avons activ√© le verrouillage des majuscules et que nous recevrons "de fa√ßon inattendue" des petites lettres au lieu de grandes lettres et vice versa.  Troisi√®mement, nous ne pouvons pas utiliser la langue russe, ni dans aucune autre langue.  Cela se produit √† nouveau en raison de choses ennuyeuses telles que <b>les codes cl√©s</b> .  Bien que Keyboard.write () l'accepte comme argument, le code correspondant √† la cl√© sur laquelle il se trouve dans la disposition standard en anglais est toujours envoy√© via USB, et si nous essayons d'envoyer l'alphabet cyrillique, nous ne saurons pas quoi.  Par cons√©quent, si nous voulons dire bonjour √† nos amis russophones via Arduino, alors dans le code, nous devons √©crire "Ghbdtn", puis l'envoyer, apr√®s avoir s√©lectionn√© la mise en page russe.  Une telle ¬´salutation¬ª fonctionnera dans la mise en page ukrainienne, mais en bulgare, malgr√© le fait qu'il existe √©galement un alphabet cyrillique, rien n'en sortira, car les lettres y sont √† des endroits compl√®tement diff√©rents.  (J'ai entendu une fois l'opinion que pour de nombreux d√©veloppeurs am√©ricains et anglais, il est incompr√©hensible que quelqu'un puisse m√™me avoir besoin d'utiliser plusieurs mises en page, mais aussi de les changer.) <br></div></div><br>  Nous avons donc un interpr√®te et une compr√©hension approximative de la fa√ßon dont notre p√©dalier interagit avec un ordinateur.  Maintenant, nous devons mettre tout cela √† l'√©tat de firmware complet et v√©rifier les performances sur une seule p√©dale.  Si vous cr√©ez une instance de la p√©dale et appelez cycliquement pedalAction (), alors en th√©orie nous ex√©cuterons le programme sp√©cifi√© dans la structure. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = {</span></span><span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2 - INPUT_PULLUP,        Keyboard.begin(); } void loop() { pedalAction(); }</span></span></code> </pre><br>  Soit dit en passant, n'oubliez jamais les terminateurs nuls dans ces "programmes" si leur longueur est inf√©rieure √† la taille du tableau et s'ils ne sont pas cycliques, car Arduino tentera non seulement d'interpr√©ter les donn√©es qui ne sont pas d√©finies, mais les enverra √©galement √† la machine √† grande vitesse, et c'est la m√™me chose que de donner un clavier √† un singe. <br><br><h3>  Une p√©dale c'est bien, et deux c'est mieux </h3><br>  Il est maintenant temps de traiter le traitement des signaux de plusieurs p√©dales, ainsi que d'ajouter des modes de commutation.  Au d√©but de l'article, 4 ports ont √©t√© allou√©s aux p√©dales, chacun devant pouvoir fonctionner en sept modes.  Pourquoi 7?  Parce que sans utiliser PWM, notre LED ne peut donner que 7 couleurs, et la huiti√®me - √©teinte.  Ce montant est tout √† fait suffisant pour l'utilisateur moyen, mais dans les cas extr√™mes, il peut facilement √™tre augment√©.  Nous allons donc stocker les p√©dales dans un tableau bidimensionnel de 7 x 4. Afin de ne pas obstruer la m√©moire, les valeurs communes √† plusieurs structures, telles que le num√©ro de port, peuvent √™tre extraites dans des tableaux s√©par√©s.  En cons√©quence, nous obtenons quelque chose comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act1[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act2[<span class="hljs-number"><span class="hljs-number">16</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[7][4] = {</span></span> { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} } }; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ports[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos1[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos2[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> state[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> oldState[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  char curPedal = 0; //  </span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">La magie du num√©ro 255</b> <div class="spoiler_text">  Vous avez probablement remarqu√© que dans l'article le num√©ro 255 appara√Æt souvent, o√π il serait plus logique de mettre 0. √Ä l'avenir, je dirai que cela est n√©cessaire pour la commodit√© du stockage des p√©dales en EEPROM, car de l'usine, chacune de ses cellules ne contient pas 0, mais juste 255, ce qui signifie que ce nombre sera beaucoup plus pratique √† utiliser pour indiquer des variables non d√©finies que 0, de sorte que vous n'√©crasez pas la m√©moire √† chaque fois. <br></div></div><br>  Il est important pour nous de ne conna√Ætre que le type de p√©dale et deux programmes, donc nous ne les laisserons que directement dans la structure, laisser l'automatisation faire le reste.  Les m√©thodes prepare et loop ressembleront maintenant √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : ports) pinMode(i, <span class="hljs-number"><span class="hljs-number">2</span></span>); Keyboard.begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((current = digitalRead(modeButton)) != last) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pedals[mode][<span class="hljs-number"><span class="hljs-number">0</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">1</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">2</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">3</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) { mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } last = current; digitalWrite(<span class="hljs-number"><span class="hljs-number">2</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b001</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">3</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b010</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">4</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { pos1[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos2[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; state[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; oldState[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } delay(<span class="hljs-number"><span class="hljs-number">50</span></span>); } curPedal = i; pedalAction } } }</code> </pre><br>  Le contr√¥leur consid√©rera le mode inutilis√© si aucune p√©dale n'y est d√©clar√©e (mode = 255), ce qui signifie que lorsqu'il le frappera, il passera imm√©diatement au suivant, mais le premier mode existera toujours.  Lors du changement de mode, toutes les valeurs dans les tableaux sont annul√©es, car nous n'avons pas besoin de les enregistrer pour chaque mode (non?), Et puis la boucle contourne toutes les p√©dales et appelle PedalAction pour elles. <br><br>  De plus, au d√©but de la m√©thode pedalAction (), vous devez ajouter la ligne suivante afin qu'elle comprenne laquelle des structures traiter: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mode</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curPedal</span></span></span><span class="hljs-class">];</span></span></code> </pre><br>  La structure existante de la p√©dale1 peut √™tre supprim√©e car inutile. <br><br>  Tout cela fonctionne √©galement tr√®s bien, cependant, j'ai rencontr√© un probl√®me: certains programmes n'ont pas le temps de recevoir des clics √† la vitesse √† laquelle Arduino les envoie.  La solution la plus √©vidente consiste √† ajouter la possibilit√© de d√©finir des d√©lais entre les actions si n√©cessaire.  Ce n'est que lorsque nous nous asseyons pour √©crire des programmes pour microcontr√¥leurs que toutes les puces, comme le multithreading mat√©riel, sont rest√©es quelque part, dans les ordinateurs de haut niveau, lorsque nous ajoutons un retard, le programme entier s'arr√™te jusqu'√† ce que le contr√¥leur compte le bon nombre de cycles.  Comme nous n'avons pas de multithreading, nous devrons le cr√©er. <br><br><h3>  Difficile √† dire oui facile √† faire </h3><br>  Je n'ai pas invent√© de v√©lo, mais j'ai pris la biblioth√®que ArduinoThread termin√©e.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez lire un peu comment cela fonctionne et le t√©l√©charger.  Vous pouvez t√©l√©charger la biblioth√®que √† partir de l'IDE Arduino lui-m√™me.  En bref, il vous permet d'effectuer p√©riodiquement une fonction avec un certain intervalle, tout en ne vous permettant pas d'entrer dans une boucle infinie si l'ex√©cution prend plus de temps que l'intervalle.  Ce dont vous avez besoin.  Cr√©ez un autre tableau avec des threads pour chaque p√©dale: <br><br><pre> <code class="cpp hljs">Thread pedalThreads[<span class="hljs-number"><span class="hljs-number">6</span></span>] = {Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>)};</code> </pre><br>  Nous avons maintenant 6 threads virtuels identiques, mais en m√™me temps, ce sont des objets diff√©rents. <br><br>  R√©√©crivons le cycle de contournement de la p√©dale pour travailler avec la nouvelle fonctionnalit√©: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } ...</code> </pre><br>  Maintenant, la valeur 252 dans le tableau des programmes, qui correspond √† ¬´ne rien faire¬ª, donnera un d√©lai de 10 millisecondes (bien qu'en fait un peu plus, car l'ex√©cution du code prend √©galement du temps).  L'ajout de quelques lignes √† l'interpr√©teur permettra de r√©gler le retard dans plusieurs de ces "quanta", en ne d√©pensant que 2 octets du tableau: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait[num]) { wait[num]--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prg[*pos] == <span class="hljs-number"><span class="hljs-number">250</span></span>) { wait[num] = prg[++*pos]; } ...</code> </pre><br>  Contrairement √† d'autres commandes, cette instruction doit √™tre ajout√©e exactement au d√©but de l'interpr√©teur, c'est-√†-dire imm√©diatement apr√®s ¬´while (1) {¬ª, car le d√©lai doit √™tre trait√© avant que l'interpr√®te ne poursuive la lecture du programme.  Le tableau d'attente doit √™tre d√©clar√© de la m√™me mani√®re que pour les ports, l'√©tat, etc.  et √©galement r√©initialiser ses cellules lors du changement de mode, afin que le retard ne passe pas √† un autre programme. <br><br>  D√©sormais, avec la possibilit√© de d√©finir un d√©lai pouvant aller jusqu'√† 2,55 secondes, aucun probl√®me de d√©finition des cl√©s par programme ne devrait se poser. <br><br><h3>  Programmation en d√©placement </h3><br>  En principe, ici, il serait possible de terminer avec le code et de commencer √† assembler l'appareil, mais dans ce cas, si quelqu'un veut soudainement reprogrammer les p√©dales, il devra ouvrir l'Arduino IDE, modifier le code et t√©l√©charger √† nouveau le firmware.  Naturellement, cette option n'est pas la meilleure, j'ai donc d√©cid√© d'ajouter la possibilit√© de changer le programme √† partir du port s√©rie Arduino et de stocker les programmes eux-m√™mes dans l'EEPROM.  Pour travailler avec de la m√©moire non volatile, vous devez connecter la biblioth√®que standard EEPROM.h.  Le code du mode de programmation est le suivant: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!digitalRead(modeButton)) { <span class="hljs-comment"><span class="hljs-comment">//  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } ...</span></span></code> </pre><br>  Ce que fait ce code est expliqu√© par l'aide qu'il contient: un num√©ro d'espace est entr√© pour le num√©ro de mode, le num√©ro de p√©dale et une commande, dont il existe 3 - lecture, √©criture et <s>ex√©cution d'une</s> suppression de programme.  Toutes les donn√©es sur les p√©dales sont stock√©es l'une apr√®s l'autre dans une s√©quence de 33 octets, c'est-√†-dire le type de p√©dale et deux programmes, et que nous occupons 7 * 4 * 33 = 924 de 1024 octets d'EEPROM.  J'ai abandonn√© la possibilit√© d'utiliser la taille dynamique des p√©dales dans la m√©moire, car dans ce cas, lors de la reprogrammation d'une p√©dale, vous devrez √©craser presque toutes les cellules, et il existe un nombre fini de cycles de r√©√©criture, nous vous recommandons donc de le faire le moins possible. <br><br><div class="spoiler">  <b class="spoiler_title">Caract√©ristiques du travail avec EEPROM</b> <div class="spoiler_text">  Je voudrais √©galement attirer l'attention sur les lignes du formulaire: <br><pre> <code class="cpp hljs"> PORTD = <span class="hljs-number"><span class="hljs-number">0b00000010</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>); ... PORTD = <span class="hljs-number"><span class="hljs-number">0b00000001</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>);</code> </pre><br>  Gr√¢ce √† cette biblioth√®que, du point de vue du programmeur, la m√©moire non volatile est un tableau de caract√®res ordinaire, mais, en tant que ¬´arduino¬ª, nous devons comprendre que l'√©criture sur ROM est une op√©ration tr√®s difficile, qui prend jusqu'√† ~ 3 secondes au contr√¥leur, et il est conseill√© de ne pas l'interrompre. processus.  Cette conception fait briller la diode rouge pendant de telles op√©rations, puis renvoie la couleur verte ¬´s√ªre¬ª. <br></div></div><br>  Dans le mode d'enregistrement de programme, l'entr√©e est effectu√©e directement par les valeurs d'octets dans le syst√®me de nombres d√©cimaux avec un espace.  Cela s'av√®re assez s√©v√®re, mais vous n'avez pas besoin d'√©crire un analyseur complexe.  De plus, la reprogrammation ne se produit pas si souvent, et dans ces cas, il est tout √† fait possible de consulter la table ASCII. <br><br>  Avec la pr√©servation des structures tri√©es, nous devons maintenant en quelque sorte extraire nos donn√©es de l√† et les convertir en vue "p√©dale": <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; j++) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginAddress = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct pedal) * (i * <span class="hljs-number"><span class="hljs-number">6</span></span> + j); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curAddress = beginAddress; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type = EEPROM[curAddress++]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == <span class="hljs-number"><span class="hljs-number">0</span></span> || type == <span class="hljs-number"><span class="hljs-number">1</span></span>) { p-&gt;type = type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } ...</code> </pre><br>  Rien de surnaturel ne se produit ici non plus: le contr√¥leur lit les donn√©es de la m√©moire et en remplit les structures existantes. <br><br>  L'avantage de la programmation via UART est que nous n'avons √† nouveau pas besoin de pilotes sp√©ciaux, vous pouvez donc d√©finir le comportement du manipulateur m√™me √† partir du t√©l√©phone. <br><br><h2>  D√©monstration </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pkjtRLlNZnU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Code source complet </h2><br><div class="spoiler">  <b class="spoiler_title">Il est l√†</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Keyboard.h&gt; #include &lt;Thread.h&gt; #include &lt;EEPROM.h&gt; #define modeButton 6 struct pedal { unsigned char type; //0 ‚Äî   , 1 ‚Äî  , 255 ‚Äî    unsigned char act1[16]; unsigned char act2[16]; }; struct pedal pedals[7][4] = { { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} } }; char ports[4] = {8, 16, 15, 14}; char pos1[4] = {0, 0, 0, 0}; char pos2[4] = {0, 0, 0, 0}; char state[4] = {0, 0, 0, 0}; char oldState[4] = {0, 0, 0, 0}; char wait[4] = {0, 0, 0, 0}; void pedalAction(); char mode = 0; char curPedal; Thread pedalThreads[6] = {Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10)}; void setup() { pinMode(2, 1); pinMode(3, 1); pinMode(4, 1); pinMode(modeButton, 2); if (!digitalRead(modeButton)) { //  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } for (int i : ports) pinMode(i, 2); pinMode(17, 1); for (int i = 0; i &lt; 7; i++) { for (int j = 0; j &lt; 4; j++) { struct pedal *p = &amp;pedals[i][j]; int beginAddress = sizeof(struct pedal) * (i * 6 + j); int curAddress = beginAddress; unsigned char type = EEPROM[curAddress++]; if (type == 0 || type == 1) { p-&gt;type = type; for (int k = 0 ; k &lt; 16; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } for (int k = 0 ; k &lt; 16; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } Keyboard.begin(); } int last = 0; void loop() { int current; if ((current = digitalRead(modeButton)) != last) { if (!current) { if (++mode &gt;= 7) mode = 0; while (pedals[mode][0].type == 255 &amp;&amp; pedals[mode][1].type == 255 &amp;&amp; pedals[mode][2].type == 255 &amp;&amp; pedals[mode][3].type == 255) if (++mode &gt;= 7) { mode = 0; break; } } last = current; digitalWrite(2, (mode + 1) &amp; 0b001); digitalWrite(3, (mode + 1) &amp; 0b010); digitalWrite(4, (mode + 1) &amp; 0b100); for (int i = 0; i &lt; 4; i++) { pos1[i] = 0; pos2[i] = 0; state[i] = 0; oldState[i] = 0; wait[i] = 0; } delay(50); } for (int i = 0; i &lt; 4; i++) { if (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } } void pedalAction() { struct pedal *pedal1 = &amp;pedals[mode][curPedal]; if (pedal1-&gt;type == 255) return; unsigned char *prg; char *pos; if (pedal1-&gt;type) { int current; if ((current = digitalRead(ports[curPedal])) != oldState[curPedal]) { if (!current) state[curPedal] = !state[curPedal]; oldState[curPedal] = current; } if (!state[curPedal]) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } else { if (!digitalRead(ports[curPedal])) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } while (1) { if (wait[curPedal]) { wait[curPedal]--; return; } else if (prg[*pos] == 250) { wait[curPedal] = prg[++*pos]; } else if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { delay(10); //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos &gt;= 16) pos = 0; } }</span></span></span></span></code> </pre><br></div></div><br><h2>  Postface </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien qu'au d√©part j'ai fait un p√©dalier pour la possibilit√© de faire d√©filer l'enregistrement tout en jouant de la guitare, cependant, personnellement, j'ai trouv√© pratique d'utiliser les p√©dales dans des t√¢ches ordinaires, l'essentiel est de s'habituer un peu √† un manipulateur aussi inhabituel. </font><font style="vertical-align: inherit;">Et l√† r√©side encore un autre probl√®me: d√©j√† sans vos p√©dales pr√©f√©r√©es, travailler au contraire devient plus difficile, car il faut se rappeler quoi, o√π et pourquoi appuyer. </font><font style="vertical-align: inherit;">Si les p√©dales peuvent toujours √™tre port√©es et connect√©es au bureau, alors √† l'institut, il est plus difficile de courir avec elles dans les salles de classe. </font><font style="vertical-align: inherit;">Donc, utiliser cet appareil pour autre chose que son objectif d'origine est √† vos risques et p√©rils. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P√©dalier assembl√©:</font></font><br><br><img src="https://habrastorage.org/webt/rw/p9/-v/rwp9-vaul_zvd9awymeb1qexlqi.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462263/">https://habr.com/ru/post/fr462263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462245/index.html">auto git bisect comme exemple du noyau Linux</a></li>
<li><a href="../fr462251/index.html">Le mode navigation priv√©e dans le navigateur est-il une fiction?</a></li>
<li><a href="../fr462253/index.html">Les premi√®res exp√©riences utilisant le protocole de streaming sur l'exemple de communication CPU et processeur dans le FPGA Redd</a></li>
<li><a href="../fr462257/index.html">Kafka sur Kubernetes - est-ce bien?</a></li>
<li><a href="../fr462259/index.html">Faire un contr√¥leur pour une maison intelligente</a></li>
<li><a href="../fr462265/index.html">Python et cubes</a></li>
<li><a href="../fr462267/index.html">Apprenez √† conna√Ætre l'analyseur statique PVS-Studio pour Java</a></li>
<li><a href="../fr462269/index.html">John Romero √† Doom: 80s Game Dev</a></li>
<li><a href="../fr462271/index.html">Code de verrouillage dans iOS: comment Apple est pass√© de la d√©fense en d√©fense √† la protection d'une seule fronti√®re</a></li>
<li><a href="../fr462273/index.html">G√©rez votre support d'ordinateur portable avec digispark</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>