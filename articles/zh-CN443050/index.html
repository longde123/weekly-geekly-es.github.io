<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏽 👩🏻‍✈️ 😫 当今对称加密算法工作原理的最简单解释 🗺️ 👨🏻‍⚕️ 👩🏾‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="（我在Twitter上找到了一个关于对称密码的非常酷的解释的主题。它是由Apache的主要贡献者之一ColmMacCárthaigh撰写的。他表示同意，我要求Colm进行翻译）。 


 我将以通俗易懂的语言向您说明加密数据后会发生什么。 我希望没有密码学家发明的神秘主义和复杂事物。 


 因此，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>当今对称加密算法工作原理的最简单解释</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443050/"><p>  <em>（我在Twitter上找到了一个关于对称密码的非常酷的解释的主题。它是由Apache的主要贡献者之一ColmMacCárthaigh撰写的。他表示同意，我要求Colm进行翻译）。</em> </p><br><p> 我将以通俗易懂的语言向您说明加密数据后会发生什么。 我希望没有密码学家发明的神秘主义和复杂事物。 </p><br><p> 因此，对称加密正是我们在大多数情况下要加密一堆数据时使用的加密方式。 您的浏览器使用对称加密发送和接收数据。 如果您加密文件或磁盘，则在这种情况下也可以使用对称加密。  iMessage，Signal，WhatsApp-所有这些都使用对称加密来确保通信的安全性。 </p><br><p>如果您认为加密时混合了数据，以至没有人没有密钥就无法读取它，那么它实际上就是发生的方式。 </p><br><p> 这是一个简单的例子。 假设我有一个Ovaltine字符串，想要对其进行加密。 我可以使用rot13-凯撒（Caesar）非常简单的老式密码，它在a和z握手的情况下进行字母的绕舞，然后将每个字母替换为另一个字母，该字母是替换字母的13个字符。 因此，“ O”变成“ B”，“ v”变成“ i”，结果，“椭圆形”变成“ Binygvar”。 当然，这不是很安全。 这是一个幼稚的示例，非常容易破解，因为攻击者可以找出最常找到的字母（通常在原始文本中为“ e”），并以此方式查找剩余的字母。 </p><a name="habracut"></a><br><p> 现在，您可以想象应该有更复杂的方式来“混合”字母。 例如，某些复杂的方案，其中“ a”变为“ p”，但是在重新加密后变为“ f”。 甚至有时该方案开始用两个字母（例如“ jd”或其他字母）加密“ a”。 因此，这种复杂的方案可以将“ Ovaltine”加密为字符串“ FGyswDmweeRq”（请注意，它变得更长了）。 过去出现的加密算法以类似的方式起作用，但这完全不是现代加密的工作原理。 </p><br><p> 现代加密代替“改组”字母，而是采用您的秘密字符串，并将其与随机数据巧妙地结合在一起。 这仅在两个方面与rot13相似：加密和解密本质上是相同的操作，并且所有操作均“就地”进行。 确实，您是否注意到rot13既是加密算法又是解密算法？  rot13（椭圆形）-&gt; Binygvar，rot13（Binygvar）-&gt;椭圆形。 我相信这是对称加密中非常漂亮的对称性。 但是回到我们的话题。 诀窍是我们使用按位XOR运算。 在加密，形式逻辑和代码中，可以对XOR程序进行不同的定义，但是我将使用一种您很可能熟悉的符号。 看起来像这样：^。 </p><br><p>  XOR代表“异或”。 这是一个运算符（或函数，如果您愿意的话），它接受两个参数并返回结果。  A ^ B =C。此运算符称为“按位”，因为它适用于彼此对应的位。 如果A和B是字节，那么我们可以假设A ^ B = C本质上是8个同时发生的不同操作。  ^比较第一位A和第一位B，然后将结果放入第一位C。它对其余位重复相同的7次。 规则很简单：如果A中的位为“ 1”或B中的位为“ 1”，则将相应的C设置为“ 1”，但前提是“ A”和“ B”不同时为“ 1”。 这是排他的部分。 这是一个老式的真值表： </p><br><pre><code class="plaintext hljs">A|B|C 0|0|0 1|0|1 0|1|1 1|1|0</code> </pre> <br><p> 关于XOR的最酷的事情是它看起来像rot13。 我们可以将其用于加密和解密。 我将用一个简单的例子来说明这一点。 假设我们要加密常规数字“ 3”，而加密密钥是另一个数字“ 7”。 因此，3 ^ 7 =4。即，加密结果为“ 4”。 现在让我们解密数字。 我将再次做同样的事情：4 ^ 7 =3。取您喜欢的任何数字或任何数据，它将始终有效-XOR始终能够对其进行解密。 </p><br><p> 一点一点-这就是我们实际上加密和解密数据的方式，没有混合，只有XOR运算。 困难的部分是寻找可以应用异或的数据。 一种方法是获取大量秘密数据，并将其用作XOR的第二个参数。 在这种情况下，传输加密数据的过程中的所有参与者都必须使用同一组秘密数据进行加密和解密。 它将起作用。 没错，有几个问题。 </p><br><p> 第一个问题。 秘密数据似乎是随机的。 您不能从书本或类似的书本上取文字。 任何模式都将出现在加密数据中。 这正是使盟军在第二次世界大战中占上风的原因。 </p><br><p> 第二个问题。 您无法重复使用敏感数据，因为模式会重新出现。 因此，您必须以某种方式为需要它的每个人提供大量的秘密数据，例如一次性垫。 这太难了。 </p><br><p> 在现代加密中，我们从小密钥“生成”所需的秘密数据。 这些钥匙更容易携带和保护。 这就是对称加密算法的真正含义-用于确定性地从密钥生成随机数据的方案。 关于“确定性”的部分非常重要：具有相同密钥的两个人必须生成绝对相同的数据集，否则他们将无法彼此理解。 您可能已经听说过这样的算法：AES，3DES，DES，RC4，ChaCha20。 他们都这样做。 </p><br><p> 事实证明，使用密钥生成随机数据流（其中没有任何可预测形式的模式）的数学问题非常困难。 在此列表中，只有AES和ChaCha20今天被认为是安全的。 其他算法被黑客入侵：人们能够预测它们。 此外，AES的声誉略有下降，因为密码学家说以下话： </p><br><blockquote>  AES是主要且分析最多的加密算法。 绝对是金标准！  ：dark_sunglasses： </blockquote><p> 但同时，他们添加： </p><br><blockquote> 用软件（而不是用硬件）中的AES实现不安全或缓慢，有时不安全且缓慢。 它在设计时并未考虑到可以使用缓存分析对其进行黑客攻击的事实。  ：facepalm： </blockquote><p> 如果您不清楚，不要太害怕。 主要思想是这样的：从数学的角度来看，AES非常出色，但是在软件实现方面却非常复杂。 但请放心-我们几乎总是在硬件级别获得AES支持（所有具有AES硬件支持的处理器的列表都可以在此处找到，译者注<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">：https:</a> //en.wikipedia.org/wiki/AES_instruction_set）。 </p><br><p> 不管怎样，我们继续...这些算法实际上是如何工作的？ 我们如何获取密钥并安全地生成随机数据流？ 我将在这里稍微简化一下，并从块开始。 </p><br><p> 这些算法在输入处接收三个参数，并在输出处给出密文。 输入参数-密钥，加密的文本和...惊喜-一种奇怪的东西，称为“初始化向量”（初始化向量，IV）。 </p><br><pre> <code class="plaintext hljs">AES(key, IV, plaintext) -&gt; encrypted_data.</code> </pre> <br><p> 键和IV相互组合以创建算法的一组“开始条件”； 这类似于Scrabble游戏中瓷砖的初始交换或改组。 键和IV的相同组合将始终创建相同的起始条件集。 你问，那为什么我们还要静脉注射呢？ 我们需要一个IV，以便我们可以使用同一密钥来加密多个消息。 没有IV，每个生成的数据流将是相同的，这很不好。 这将违反我们之前讨论的规则之一：我们不能将相同的数据重新用于加密。 因此，我们需要IV来混合结果。 但是与密钥IV不同，它可以是公开的。 </p><br><p> 因此，当您加密一条消息并将其发送给某人时，您还可以添加：“嘿，这是我使用的IV。” 至关重要的是，我们不要重复使用键和IV的组合，因为它们会给我们重复的随机数据。 有两种方法可以达到此条件：1）IV是一种计数器，随着每个新消息的增加，计数器都会增加。  2）IV是随机生成的，尽管它具有相当大的值，所以我们不必担心碰撞。 尽管如此，我提到我将谈论块。 </p><br><p> 键和IV以创建一组起始条件的方式“混合”或组合在一起……这些条件实际上是随机数据的初始“块”。 对于AES128，此块的长度为128位，对于AES256，此块的长度为256位，对于ChaCha20，则为512位。 此处体现了特定加密算法的真正魔力和独特性。 实际上，它们的本质在于如何生成块序列以及每个块如何与其邻居关联。 即使对于没有密钥的人，这些块之间的关系仍然可以预测。 </p><br><p> 我不会深入研究这些算法的工作原理，但是如果您想了解更多信息，我建议您开始使用线性同余生成器（LCG）探索这个主题。  LCG是一种以随机且非重复的方式创建“圆形”数据块的功能。 然后看一下Feistel网络，这是LCG发展的下一个阶段。 然后处理S-Box，然后查看Salsa20如何在ChaCha20算法中创建隔行扫描。 所有这些都比您想象的要便宜得多！ </p><br><p> 因此，我们现在知道了如何将随机数据流与文本组合在一起以对其进行加密和解密，并且在如何创建这些随机数据流方面我们已经有些了解了。 那不是我们所需要的吗？ 对于磁盘加密，这几乎就是全部。 我们可以使用一个密钥和IV对存储的每个块或扇区进行加密，这可以从磁盘上的“位置”获得。 因此，只要有密钥，我们就可以随时解密磁盘上任何位置的任何数据块。 但是有一个问题……有人可以破坏我们的加密数据。 如果我更改任何字节的值，即使我没有密钥，那么最后我们将无法解密该块。 并且没有针对这种干扰的保护措施。 在通过网络发送消息和数据的情况下，这变得更加重要。 我们不希望任何人破坏我们传输的数据。 因此，我们需要添加完整性检查！ 为此，有几种方案。 </p><br><p>  HMAC，GCM和Poly1305是最常见的现代完整性检查方案。 这些算法基本上是这样工作的：它们被提供了数据和另一个密钥（所谓的完整性密钥）。 计算之后，他们给出MAC（消息验证码）或标签，而MAC或标签又是充当签名的另一段数据。 </p><br><p> 因此，对于加密和保护，我们的方案可能如下所示： </p><br><pre> <code class="plaintext hljs">AES(key, IV, "Ovaltine") -&gt; encrypted_output HMAC(key, encrypted_output) -&gt; MAC</code> </pre> <br><p> 然后通过电汇发送： </p><br><pre> <code class="plaintext hljs">IV | encrypted_output | MAC</code> </pre> <br><p> 对于解密，我们检查MAC，再次生成它，并将结果与​​接收到的MAC进行比较，然后解密数据。  HMAC，GCM和Poly1305生成这些签名的方式存在内部差异，但是您不必为此担心。 迄今为止，这种操作组合通常包装在称为“ AEAD”（带有附加数据的经过身份验证的加密）的函数中。 在幕后，她做了我之前谈到的所有事情： </p><br><pre> <code class="plaintext hljs">AEAD(key, IV, plaintext, additional_data) -&gt; IV_encrypted_data_MAC</code> </pre> <br><p> 一块称为“ additional_data”的数据只是可以用来确保发送方拥有此数据的数据，尽管它没有发送给他们。 就像设置访问权限的元数据一样。 通常，此字段为空。 </p><br><p> 但是，如果使用相同的IV，您可能会遇到AEAD问题。 不好 我们正在尝试改善这种情况：我的同事名叫Shay，正在研究一个很酷的SIV方案，该方案为防止该问题增加了一层保护。 但是，如果您使用独特的IV，则现代加密非常安全。 也就是说，您可以在《纽约时报》上发布密文，没有人能破解它。 即使知道文本的“某些”部分，密码也仍然无法访问。 例如，在因特网协议中，已知大量文本。  HTTP服务器始终响应相同，并且头字节始终是已知的。 但是，这个事实一点都不重要-不会帮助攻击者找出剩余的数据中的一个……自第二次世界大战以来，我们已经走了很长一段路。 </p><br><p> 但是有些攻击有效！ 如果您通过网络发送数据，并且有人跟踪消息的时间和大小，则可以使用流量分析来破解加密的数据。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0f3/159/f21/0f3159f21f88bfaa15fb4e2b7399792c.gif" alt="图片"></p><br><p> 让我们先弄清楚长度。 显然，长度不是隐藏的特征。 如果您尝试在消息中间的某个地方保护密码或信用卡号，这是正常的。 没什么大问题。 但这意味着潜在的任何人都可以确定您提交的内容的类型。 一个简单的例子：如果您使用信使发送gif，并且此图像的大小是唯一的，则拦截您数据的攻击者可能会建议刚发送了哪个GIF。 对于Google Maps，Netflix，Wikipedia等，此攻击有更棘手的版本。 为了防止这种攻击，您可以用其他字节“整理”已发送的消息，以便无论任何情况，所有已发送的消息都具有相同的长度。 军事网络中使用的加密总是会用额外的数据“完成”流量，也就是说，对于拦截器来说，它总是看起来一样！ 与长度相关的另一个问题是，如果您使用压缩并赋予攻击者更改用户看到的页面内容的任何部分的能力，这将使攻击者甚至可以找出最小的秘密。 搜索称为CRIME的攻击。 她是美丽而恐怖的。 </p><br><p> 我还说过，另一个问题是时间安排。 显然，每条消息的发送时间都是公开信息。 这可能是个问题吗？ 也许吧！ 例如，如果您每次按某个键都发送一条消息，那么使用时间分析来找出要打印的内容是很简单的。 好酷！ 另一个例子是VOIP。 如果您的呼叫应用程序仅在人们说话时才发送数据，而在沉默时才发送数据，那么这足以恢复70％的英语语音。 只是保持沉默。 可怕的酷。 </p><br><p> 这些例子只是冰山一角。 即使您使用已改进80年的加密算法和方案，仍然存在可以用来破解安全性的漏洞。 这就是为什么了解它很有价值！ </p><br><p> 顺便说一下，这就是我现在要详细说明的水平，但是我们已经考虑了最需要了解的事情。 如果您读到这一点-谢谢！ 您现在应该对加密过程中发生的事情以及需要注意的事情有更深入的了解。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">随时提出问题。</a> </p><br><p>  <em>翻译根据CC BY-NC-SA 4.0许可证发布</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN443050/">https://habr.com/ru/post/zh-CN443050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN443034/index.html">新的Tesla充电站：在5分钟内为120公里的电池充电</a></li>
<li><a href="../zh-CN443038/index.html">如果强力胶进入眼睛</a></li>
<li><a href="../zh-CN443040/index.html">在Google Play和AppStore上阻止应用程序的7个主要原因</a></li>
<li><a href="../zh-CN443042/index.html">在GLSL上发布了61.9万个俄罗斯方块，它们的渲染和一个简单的机器人</a></li>
<li><a href="../zh-CN443046/index.html">安全研究人员如何访问iOS代码的受保护站点</a></li>
<li><a href="../zh-CN443052/index.html">来自旧智能手机的精美精准手表</a></li>
<li><a href="../zh-CN443054/index.html">Linux下程序员的实用程序选择</a></li>
<li><a href="../zh-CN443056/index.html">第二名艾滋病患者达到缓解</a></li>
<li><a href="../zh-CN443058/index.html">干净的架构。 第一部分-简介</a></li>
<li><a href="../zh-CN443060/index.html">星际飞船会到达火星吗？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>