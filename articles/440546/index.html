<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏻 🚀 👩🏻‍🤝‍👨🏿 Chat distribuido en Node.JS y Redis 🧑🏿‍🤝‍🧑🏾 ⬜️ 🌹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una pequeña pregunta / respuesta: 


 ¿Para quién es? Personas que tienen poca o ninguna experiencia con sistemas distribuidos, y que están interesada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chat distribuido en Node.JS y Redis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440546/"><p><img src="https://cs4.pikabu.ru/post_img/2015/10/04/5/1443945163_2102700146.jpg" alt="El resultado es una imagen de broma para lavar el &quot;correo de paloma&quot;"></p><br><p>  Una pequeña pregunta / respuesta: </p><br><p> <em>¿Para quién es?</em>  Personas que tienen poca o ninguna experiencia con sistemas distribuidos, y que están interesadas en ver cómo se pueden construir, qué patrones y soluciones existen. </p><br><p>  <em>¿Por qué es esto?</em>  Él mismo se interesó en qué y cómo.  Recogí información de varias fuentes, decidí publicarla de forma concentrada, porque en algún momento me gustaría ver un trabajo similar.  De hecho, esta es una declaración textual de mi arrojo y pensamiento personales.  Además, seguramente habrá muchas correcciones en los comentarios de personas conocedoras, y este es en parte el propósito de escribir todo esto en forma de artículo. </p><br><h2 id="postanovka-zadachi">  Declaración del problema. </h2><br><p>  ¿Cómo hacer un chat?  Esta debería ser una tarea trivial, probablemente cada segundo Beckender aserra la suya propia, al igual que los desarrolladores de juegos hacen sus tetris / serpientes, etc. usuarios activos y en general fue increíblemente genial.  La clara necesidad de una arquitectura distribuida proviene de esto, porque no es realista tener la capacidad actual para adaptarse a la cantidad imaginaria de clientes en una máquina.  En lugar de simplemente sentarme y esperar la aparición de las computadoras cuánticas, decidí estudiar el tema de los sistemas distribuidos. </p><br><p>  Vale la pena señalar que una respuesta rápida es muy importante, la notoria en tiempo real, ¡es un <strong>chat</strong> !  No entrega de correo de paloma. </p><br><p>  % <em>broma aleatoria sobre la publicación rusa</em> % </p><br><p>  Usaremos Node.JS, es ideal para la creación de prototipos.  Para enchufes, tome Socket.IO.  Escribe en TypeScript. </p><br><p>  Y entonces, ¿qué queremos? </p><br><ol><li>  Para que los usuarios puedan enviarse mensajes entre ellos </li><li>  Sepa quién está conectado / desconectado </li></ol><br><p>  ¿Cómo lo queremos? </p><a name="habracut"></a><br><h2 id="singl-server">  Servidor único </h2><br><p>  No hay nada que decir especialmente, directamente al código.  Declare la interfaz del mensaje: </p><br><pre><code class="plaintext hljs">interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  En el servidor: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //    //         sock.on('message', (data:Message)=&gt; io.to(data.roomId).emit('message', data)) })</code> </pre> <br><p>  En el cliente, algo como: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const roomId = 'some room' //      sock.on('message', (data:Message)=&gt; console.log(`Message ${data.message} from ${data.roomId}`)) //   sock.emit('join', roomId) //    sock.emit('message', &lt;Message&gt;{roomId: roomId, message: 'Halo!'}) })</code> </pre> <br><p>  Puede trabajar con un estado en línea como este: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //         // ,        - //      sock.on('auth', (uid:string)=&gt; sock.join(uid)) //,     , //          //   sock.on('isOnline', (uid:string, resp)=&gt; resp(io.sockets.clients(uid).length &gt; 0)) })</code> </pre> <br><p>  Y en el cliente: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const uid = 'im uid, rly' //  sock.emit('auth', uid) //     sock.emit('isOnline', uid, (isOnline:boolean)=&gt; console.log(`User online status is ${isOnline}`)) })</code> </pre> <br><blockquote>  Nota: el código no se ejecutó, escribo de memoria solo por ejemplo </blockquote><p>  Al igual que la leña, hacemos girar la autorización real de syudy, la gestión de la sala (historial de mensajes, agregar / eliminar participantes) y las ganancias. </p><br><p>  PERO!  Pero vamos a tomar el control de la paz mundial, lo que significa que no es el momento de parar, estamos avanzando rápidamente: </p><br><h2 id="nodejs-klaster">  Clúster Node.JS </h2><br><p>  Los ejemplos del uso de Socket.IO en muchos nodos están <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web oficial</a> .  Incluyendo también hay un clúster Node.JS nativo, que me pareció inaplicable a mi tarea: nos permite expandir nuestra aplicación en toda la máquina, PERO no más allá de su alcance, por lo que definitivamente lo extrañamos.  ¡Necesitamos finalmente ir más allá de los límites de una sola pieza de hierro! </p><br><h2 id="raspredelyay-i-velosiped">  Distribuir y andar en bicicleta </h2><br><p>  Como hacerlo  Obviamente, debe conectar de alguna manera nuestras instancias, lanzadas no solo en casa en el sótano, sino también en el sótano vecino.  Lo primero que viene a la mente: hacemos algún tipo de enlace intermedio que servirá como un bus entre todos nuestros nodos: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140775997.png" alt="1549140775997"></p><br><p>  Cuando un nodo quiere enviar un mensaje a otro, realiza una solicitud al Bus y, a su vez, lo reenvía a donde sea necesario, todo es simple.  ¡Nuestra red está lista! </p><br><p>  <strong>FIN.</strong> </p><br><p>  ... pero no es tan simple?) </p><br><p>  Con este enfoque, nos encontramos con el rendimiento de este enlace intermedio y, de hecho, nos gustaría contactar directamente con los nodos necesarios, porque ¿qué puede ser más rápido que la comunicación directa?  ¡Entonces, avancemos en esta dirección! </p><br><p>  ¿Qué se necesita primero?  En realidad, legitimar una instancia a otra.  Pero, ¿cómo aprende el primero sobre la existencia del segundo?  Pero queremos tener un número infinito de ellos, ¡aumentar / eliminar arbitrariamente!  Necesitamos un servidor maestro cuya dirección sea conocida, todos se conectan a ella, por lo que conoce todos los nodos existentes en la red y comparte amablemente esta información con todos. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549048945334.png" alt="1549048945334"></p><br><p>  El nodo se eleva, le dice al maestro sobre su despertar, le da una lista de otros nodos activos, nos conectamos a ellos y eso es todo, la red está lista.  El maestro puede ser cónsul o algo así, pero como estamos en bicicleta, el maestro debe ser hecho a sí mismo. </p><br><p>  ¡Genial, ahora tenemos nuestra propia Skynet!  Pero la implementación actual del chat ya no es adecuada.  Vamos a presentar los requisitos: </p><br><ol><li>  Cuando un usuario envía un mensaje, necesitamos saber a quién se lo envía, es decir, tener acceso a los participantes en la sala. </li><li>  Cuando recibimos a los participantes, debemos entregarles mensajes. </li><li>  Necesitamos saber qué usuario está en línea ahora. </li><li>  Para mayor comodidad: brinde a los usuarios la oportunidad de suscribirse al estado en línea de otros usuarios, para que en tiempo real se enteren de su cambio </li></ol><br><p>  Tratemos con los usuarios.  Por ejemplo, puede hacer que el maestro sepa qué nodo está conectado a qué nodo.  La situación es la siguiente: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549237952673.png" alt="1549237952673"></p><br><p>  Dos usuarios están conectados a diferentes nodos.  El maestro sabe esto, los nodos saben lo que sabe el maestro.  Cuando el usuario B inicia sesión, el nodo 2 notifica al maestro, que "recuerda" que el usuario B está conectado al nodo 2.  Cuando el usuario A quiere enviar un mensaje de usuario B, obtiene la siguiente imagen: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140491881.png" alt="1549140491881"></p><br><p>  En principio, todo funciona, pero me gustaría evitar una ronda adicional de viaje en forma de interrogar al maestro, sería más económico contactar inmediatamente al nodo correcto directamente, porque es por eso que todo comenzó.  Esto se puede hacer si le dicen a todos los usuarios que están conectados a ellos, cada uno de ellos se convierte en un análogo autosuficiente del asistente y el asistente en sí mismo se vuelve innecesario, porque la lista de la proporción "Usuario =&gt; Nodo" está duplicada para todos.  Al comienzo de un nodo, es suficiente para conectarse a cualquiera que ya se esté ejecutando, extraer su lista y listo, también está listo para la batalla. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139768940.png" alt="1549139768940"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139882747.png" alt="1549139882747"></p><br><p>  Pero como compensación, obtenemos una duplicación de la lista, que, aunque es una relación de "ID de usuario -&gt; [conexiones de host]", pero con un número suficiente de usuarios resultará ser bastante grande en la memoria.  Y, en general, cortarlo usted mismo: claramente huele a la industria de la bicicleta.  Cuanto más código, más errores potenciales.  Quizás congelemos esta opción y echemos un vistazo a lo que ya está listo: </p><br><h2 id="brokery-soobscheniy">  Corredores de mensajes </h2><br><p>  La entidad que implementa el mismo "Bus", el "enlace intermedio" mencionado anteriormente.  Su tarea es recibir y entregar mensajes.  Nosotros, como usuarios, podemos suscribirnos a ellos y enviar los nuestros.  Todo es simple </p><br><p>  Hay RabbitMQ y Kafka probados: simplemente hacen lo que entregan mensajes: este es su propósito, repleto de todas las funcionalidades necesarias para el cuello.  En su mundo, un mensaje debe ser entregado pase lo que pase. </p><br><p>  Al mismo tiempo, está Redis y su pub / sub, lo mismo que los chicos antes mencionados, pero más dudoso: simplemente recibe el mensaje estúpidamente y lo entrega al suscriptor, sin colas ni otros gastos generales.  No le importan los mensajes en sí mismos, desaparecerán si el suscriptor cuelga; lo tirará y tomará uno nuevo, como si le arrojaran un póker candente en sus manos del que desea deshacerse más rápido.  Además, si cae repentinamente, todos los mensajes también se hundirán junto con él.  En otras palabras, no se trata de ninguna garantía de entrega. </p><br><p>  ... y esto es lo que necesitas! </p><br><p>  Bueno, de verdad, solo chateamos.  No es algún tipo de servicio de dinero crítico o centro de control de vuelo espacial, sino ... solo una charla.  El riesgo es que Pete condicional una vez al año no reciba un mensaje de cada mil; puede ser descuidado si a cambio conseguimos un crecimiento de la productividad y establecemos con él el número de usuarios para los mismos días, intercambiamos en todo su esplendor.  Además, al mismo tiempo, puede mantener un historial de mensajes en algún tipo de repositorio persistente, lo que significa que Petya aún verá ese mensaje perdido al volver a cargar la página / aplicación.  Es por eso que nos centraremos en Redis pub / sub, o más bien: mire el adaptador existente para SocketIO, que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se menciona en el artículo en la oficina.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio</a> . </p><br><p>  Entonces que es esto? </p><br><h2 id="redis-adapter">  Adaptador Redis </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/socketio/socket.io-redis</a> </p><br><p>  Con su ayuda, una aplicación ordinaria a través de unas pocas líneas y un número mínimo de gestos se convierte en un chat distribuido real.  Pero como?  <a href="">Si miras dentro</a> , resulta que solo hay un archivo por medio centenar de líneas. </p><br><p>  En el caso cuando emitimos un mensaje </p><br><pre> <code class="plaintext hljs">io.emit("everyone", "hello")</code> </pre> <br><p>  se inserta en rábanos, se transmite a todas las demás instancias de nuestro chat, que a su vez ya lo emiten localmente en sockets </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549232309776.png" alt="1549232309776"></p><br><p>  El mensaje se distribuirá en todos los nodos, incluso si lo emitimos a un usuario específico.  Es decir, cada nodo acepta todos los mensajes y ya comprende si lo necesita. </p><br><p>  Además, se implementó un simple rpc (llamada a procedimientos remotos), que permite no solo enviar sino también recibir respuestas.  Por ejemplo, puede controlar los zócalos de forma remota, como "quién está en la sala especificada", "ordenar que el zócalo se una a la sala", etc. </p><br><p>  ¿Qué se puede hacer con esto?  Por ejemplo, use la ID de usuario como el nombre de la sala (ID de usuario == ID de la sala).  Al autorizar, para conectar el zócalo y cuando queremos enviar un mensaje al usuario, solo un casco en él.  Además, podemos averiguar si el usuario está en línea, simplemente mirando si hay enchufes en la habitación especificada. </p><br><p>  En principio, podemos parar aquí, pero como siempre, no es suficiente para nosotros: </p><br><ol><li>  Cuello de botella en una sola instancia de rábano </li><li>  Redundancia, me gustaría que los nodos reciban solo los mensajes que necesitan </li></ol><br><p>  A expensas del párrafo uno, mire algo como: </p><br><h2 id="redis-cluster">  Redis cluster </h2><br><p>  Conecta varias instancias de rábano, después de lo cual funcionan como un todo.  ¿Pero cómo lo hace?  Sí, así: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549233023980.png" alt="1549233023980"></p><br><p>  ... y vemos que el mensaje está duplicado para todos los miembros del clúster.  Es decir, no está destinado a aumentar la productividad, sino a aumentar la confiabilidad, que sin duda es buena y necesaria, pero para nuestro caso no tiene valor y no salva la situación con un cuello de botella de ninguna manera, además, en suma, es aún más desperdicio de recursos. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549231953897.png" alt="1549231953897"></p><br><p>  Soy un principiante, no sé mucho, a veces tengo que volver al pitchforking, lo que haremos.  No, dejemos el rábano para que no se deslice en absoluto, pero debes pensar en algo con la arquitectura porque el actual no es bueno. </p><br><h2 id="povorot-ne-tuda">  Gire por el camino equivocado </h2><br><p>  Que necesitamos  Aumentar el rendimiento general.  Por ejemplo, tratemos de generar estúpidamente otra instancia.  Imagine que socket.io-redis puede conectarse a varios, al enviar un mensaje, selecciona al azar y se suscribe a todo.  Resulta así: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239818663.png" alt="1549239818663"></p><br><p>  Voila!  En general, el problema está resuelto, los rábanos ya no son un cuello de botella, ¡puedes generar cualquier cantidad de copias!  Pero se convirtieron en nodos.  Sí, sí, nuestras instancias de chat aún digieren TODOS los mensajes, a los que no estaban destinados. </p><br><p>  Puede viceversa: suscribirse a uno aleatorio, lo que reducirá la carga en los nodos y empujará todo: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239361416.png" alt="1549239361416"></p><br><p>  Vemos que se ha vuelto al revés: los nodos se sienten más tranquilos, pero la carga en la instancia de rábano ha aumentado.  Esto tampoco es bueno.  Necesitas andar en bicicleta un poco. </p><br><p>  Para bombear nuestro sistema, dejaremos solo el paquete socket.io-redis, aunque es genial, necesitamos más libertad.  Y así, conectamos el rábano: </p><br><pre> <code class="plaintext hljs">//  : const pub = new RedisClient({host: 'localhost', port: 6379})//  const sub = new RedisClient({host: 'localhost', port: 6379})//   //    interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Configure nuestro sistema de mensajería: </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, dataRaw:string)=&gt; { const data = &lt;Message&gt;JSON.parse(dataRaw) io.to(data.roomId).emit('message', data)) }) //   sub.subscribe("messagesChannel") //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //   sock.on('message', (data:Message)=&gt; { //   pub.publish("messagesChannel", JSON.stringify(data)) })</code> </pre> <br><p>  Por el momento, resulta como en socket.io-redis: escuchamos todos los mensajes.  Ahora lo arreglaremos. </p><br><p>  Organizamos las suscripciones de la siguiente manera: recuerde el concepto con "id de usuario == id de sala", y cuando aparezca el usuario, nos suscribiremos al canal del mismo nombre en el rábano.  Por lo tanto, nuestros nodos solo recibirán mensajes destinados a ellos y no escucharán la "transmisión completa". </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, message:string)=&gt; { io.to(channel).emit('message', message)) }) let UID:string|null = null; sock.on('auth', (uid:string)=&gt; { UID = uid //   -   //  UID  sub.subscribe(UID) //   sock.join(UID) }) sock.on('writeYourself', (message:string)=&gt; { //  ,        UID if (UID) pub.publish(UID, message) })</code> </pre> <br><p>  Impresionante, ahora estamos seguros de que los nodos solo reciben mensajes destinados a ellos, ¡nada más!  Sin embargo, debe tenerse en cuenta que las suscripciones en sí son ahora mucho, mucho más grandes, lo que significa que se comerán la memoria del año a año, + más operaciones de suscripción / cancelación de suscripción, que son relativamente caras.  Pero, en cualquier caso, esto nos da cierta flexibilidad, incluso puede detenerse en este momento y volver a visitar todas las opciones anteriores, ya teniendo en cuenta nuestra nueva propiedad de nodos en forma de mensajes de recepción más selectivos y castas.  Por ejemplo, los nodos pueden suscribirse a una de varias instancias de rábano y, al presionar, enviar un mensaje a todas las instancias: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174595491.png" alt="1550174595491"></p><br><p>  ... pero, digan lo que uno diga, todavía no ofrecen una extensibilidad infinita con una sobrecarga razonable, es necesario dar a luz a otras opciones.  En un momento, me vino a la mente el siguiente esquema: qué pasa si las instancias de rábano se dividen en grupos, digamos A y B, dos instancias en cada una.  Al suscribirse, los nodos son firmados por una instancia de cada grupo, y al enviar, envían un mensaje a todas las instancias de un solo grupo aleatorio. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174092066.png" alt="1550174092066"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174943313.png" alt="1550174943313"></p><br><p>  Por lo tanto, obtenemos una estructura operativa con un potencial de capacidad de expansión infinito en tiempo real, la carga en un nodo individual en cualquier punto no depende del tamaño del sistema, porque: </p><br><ol><li>  El ancho de banda total se divide entre grupos, es decir, con un aumento de usuarios / actividad, simplemente comparamos grupos adicionales. </li><li>  La gestión de usuarios (suscripciones) se divide dentro de los propios grupos, es decir, al aumentar los usuarios / suscripciones, simplemente aumentamos el número de instancias dentro de los grupos. </li></ol><br><p>  ... y como siempre hay un "PERO": cuanto más se obtiene, más recursos se necesitan para la próxima ganancia, me parece una compensación exorbitante. </p><br><p>  En general, si lo piensa, los enchufes antes mencionados provienen de no saber qué usuario está en qué nodo.  Bueno, de hecho, si tuviéramos esta información, podríamos enviar los mensajes justo donde lo necesitan, sin duplicaciones innecesarias.  ¿Qué hemos intentado hacer todo este tiempo?  Intentaron hacer que el sistema fuera infinitamente escalable, sin tener un mecanismo de direccionamiento claro, que inevitablemente se topaba con un callejón sin salida o una redundancia injustificada.  Por ejemplo, puede recordar que el asistente actúa como una "libreta de direcciones": </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550233610561.png" alt="1550233610561"></p><br><blockquote>  Algo similar le dice a este tipo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6G22a5Iooqk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></blockquote><p>  Para obtener la ubicación del usuario, hacemos un viaje de ida y vuelta adicional, que en principio está bien, pero no en nuestro caso.  Parece que estamos cavando en la dirección equivocada, necesitamos algo más ... </p><br><h2 id="sila-hesha">  Fuerza de hash </h2><br><p>  Existe un hash.  Tiene un rango finito de valores.  Puede obtenerlo de cualquier dato.  Pero, ¿qué pasa si divide este rango entre instancias de rábano?  Bueno, tomamos la ID de usuario, producimos un hash y, dependiendo del rango en el que resultó suscribirse / empujar a una instancia específica.  Es decir, no sabemos de antemano dónde existe qué usuario, pero después de haberlo recibido, podemos decir con confianza que es en n instancia, inf 100. Ahora lo mismo, pero con el código: </p><br><pre> <code class="plaintext hljs">function hash(val:string):number{/**/}// -,   const clients:RedisClient[] = []//   const uid = "some uid"//  //,            //      const selectedClient = clients[hash(uid) % clients.length]</code> </pre> <br><p>  Voila!  Ahora que no dependemos del número de instancias de la palabra en general, ¡podemos escalar todo lo que queramos sin gastos generales!  Bueno, en serio, esta es una opción brillante, la única desventaja es la necesidad de reiniciar completamente el sistema al actualizar el número de instancias de rábano.  Existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anillo estándar y un anillo de partición</a> que le permiten superar esto, pero no son aplicables en un sistema de mensajería.  Bueno, puede hacer la lógica de migrar suscripciones entre instancias, pero esto todavía cuesta un código adicional de tamaño incomprensible y, como sabemos, cuanto más código, más errores, no necesitamos esto, gracias.  Y en nuestro caso, el tiempo de inactividad es una compensación bastante aceptable. </p><br><p>  También puede ver RabbitMQ con su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complemento</a> , que nos permite hacer lo mismo que nosotros, y + proporciona la migración de suscripciones (como dije anteriormente, está vinculado con la funcionalidad de la cabeza a los pies).  En principio, puede tomarlo y dormir tranquilo, pero si alguien se equivoca en su afinación para llevar el modo a tiempo real, dejando solo una función con un anillo de hash. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Inundó el repositorio en github.</a> </p><br><p>  Implementa la versión final a la que hemos llegado.  Además, existe una lógica adicional para trabajar con salas (diálogos). </p><br><p>  En general, estoy satisfecho y se puede redondear. </p><br><h2 id="itogo">  Total </h2><br><p>  Puede hacer cualquier cosa, pero existen recursos, y son finitos, por lo que debe retorcerse. </p><br><p>  Comenzamos con un completo desconocimiento de cómo los sistemas distribuidos pueden funcionar con patrones concretos más o menos tangibles, y eso es bueno. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440546/">https://habr.com/ru/post/440546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440534/index.html">Traducción de vocabulario políticamente correcto del inglés al ruso</a></li>
<li><a href="../440536/index.html">Cómo Facebook Project Infer ayuda a encontrar errores en las aplicaciones móviles antes de la implementación</a></li>
<li><a href="../440540/index.html">La capitalización de Reddit alcanzó los $ 3 mil millones después de atraer una inversión de $ 300 millones</a></li>
<li><a href="../440542/index.html">Vuex: uso excesivo de captadores en la aplicación. Error al analizar</a></li>
<li><a href="../440544/index.html">La versión experimental de Blazor 0.8.0 ya está disponible</a></li>
<li><a href="../440548/index.html">"No se puede simplemente tomar y paralelizar fuentes de voltaje"</a></li>
<li><a href="../440550/index.html">El triángulo de color no tiene dos, sino una esquina.</a></li>
<li><a href="../440552/index.html">Romper cierres e inyectar inyección de dependencia en JavaScript</a></li>
<li><a href="../440554/index.html">BEM conveniente</a></li>
<li><a href="../440556/index.html">Aprendiendo el diseño de diagramas de relación de entidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>