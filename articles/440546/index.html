<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèª üöÄ üë©üèª‚Äçü§ù‚Äçüë®üèø Chat distribuido en Node.JS y Redis üßëüèø‚Äçü§ù‚Äçüßëüèæ ‚¨úÔ∏è üåπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una peque√±a pregunta / respuesta: 


 ¬øPara qui√©n es? Personas que tienen poca o ninguna experiencia con sistemas distribuidos, y que est√°n interesada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chat distribuido en Node.JS y Redis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440546/"><p><img src="https://cs4.pikabu.ru/post_img/2015/10/04/5/1443945163_2102700146.jpg" alt="El resultado es una imagen de broma para lavar el &quot;correo de paloma&quot;"></p><br><p>  Una peque√±a pregunta / respuesta: </p><br><p> <em>¬øPara qui√©n es?</em>  Personas que tienen poca o ninguna experiencia con sistemas distribuidos, y que est√°n interesadas en ver c√≥mo se pueden construir, qu√© patrones y soluciones existen. </p><br><p>  <em>¬øPor qu√© es esto?</em>  √âl mismo se interes√≥ en qu√© y c√≥mo.  Recog√≠ informaci√≥n de varias fuentes, decid√≠ publicarla de forma concentrada, porque en alg√∫n momento me gustar√≠a ver un trabajo similar.  De hecho, esta es una declaraci√≥n textual de mi arrojo y pensamiento personales.  Adem√°s, seguramente habr√° muchas correcciones en los comentarios de personas conocedoras, y este es en parte el prop√≥sito de escribir todo esto en forma de art√≠culo. </p><br><h2 id="postanovka-zadachi">  Declaraci√≥n del problema. </h2><br><p>  ¬øC√≥mo hacer un chat?  Esta deber√≠a ser una tarea trivial, probablemente cada segundo Beckender aserra la suya propia, al igual que los desarrolladores de juegos hacen sus tetris / serpientes, etc. usuarios activos y en general fue incre√≠blemente genial.  La clara necesidad de una arquitectura distribuida proviene de esto, porque no es realista tener la capacidad actual para adaptarse a la cantidad imaginaria de clientes en una m√°quina.  En lugar de simplemente sentarme y esperar la aparici√≥n de las computadoras cu√°nticas, decid√≠ estudiar el tema de los sistemas distribuidos. </p><br><p>  Vale la pena se√±alar que una respuesta r√°pida es muy importante, la notoria en tiempo real, ¬°es un <strong>chat</strong> !  No entrega de correo de paloma. </p><br><p>  % <em>broma aleatoria sobre la publicaci√≥n rusa</em> % </p><br><p>  Usaremos Node.JS, es ideal para la creaci√≥n de prototipos.  Para enchufes, tome Socket.IO.  Escribe en TypeScript. </p><br><p>  Y entonces, ¬øqu√© queremos? </p><br><ol><li>  Para que los usuarios puedan enviarse mensajes entre ellos </li><li>  Sepa qui√©n est√° conectado / desconectado </li></ol><br><p>  ¬øC√≥mo lo queremos? </p><a name="habracut"></a><br><h2 id="singl-server">  Servidor √∫nico </h2><br><p>  No hay nada que decir especialmente, directamente al c√≥digo.  Declare la interfaz del mensaje: </p><br><pre><code class="plaintext hljs">interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  En el servidor: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //    //         sock.on('message', (data:Message)=&gt; io.to(data.roomId).emit('message', data)) })</code> </pre> <br><p>  En el cliente, algo como: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const roomId = 'some room' //      sock.on('message', (data:Message)=&gt; console.log(`Message ${data.message} from ${data.roomId}`)) //   sock.emit('join', roomId) //    sock.emit('message', &lt;Message&gt;{roomId: roomId, message: 'Halo!'}) })</code> </pre> <br><p>  Puede trabajar con un estado en l√≠nea como este: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //         // ,        - //      sock.on('auth', (uid:string)=&gt; sock.join(uid)) //,     , //          //   sock.on('isOnline', (uid:string, resp)=&gt; resp(io.sockets.clients(uid).length &gt; 0)) })</code> </pre> <br><p>  Y en el cliente: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const uid = 'im uid, rly' //  sock.emit('auth', uid) //     sock.emit('isOnline', uid, (isOnline:boolean)=&gt; console.log(`User online status is ${isOnline}`)) })</code> </pre> <br><blockquote>  Nota: el c√≥digo no se ejecut√≥, escribo de memoria solo por ejemplo </blockquote><p>  Al igual que la le√±a, hacemos girar la autorizaci√≥n real de syudy, la gesti√≥n de la sala (historial de mensajes, agregar / eliminar participantes) y las ganancias. </p><br><p>  PERO!  Pero vamos a tomar el control de la paz mundial, lo que significa que no es el momento de parar, estamos avanzando r√°pidamente: </p><br><h2 id="nodejs-klaster">  Cl√∫ster Node.JS </h2><br><p>  Los ejemplos del uso de Socket.IO en muchos nodos est√°n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web oficial</a> .  Incluyendo tambi√©n hay un cl√∫ster Node.JS nativo, que me pareci√≥ inaplicable a mi tarea: nos permite expandir nuestra aplicaci√≥n en toda la m√°quina, PERO no m√°s all√° de su alcance, por lo que definitivamente lo extra√±amos.  ¬°Necesitamos finalmente ir m√°s all√° de los l√≠mites de una sola pieza de hierro! </p><br><h2 id="raspredelyay-i-velosiped">  Distribuir y andar en bicicleta </h2><br><p>  Como hacerlo  Obviamente, debe conectar de alguna manera nuestras instancias, lanzadas no solo en casa en el s√≥tano, sino tambi√©n en el s√≥tano vecino.  Lo primero que viene a la mente: hacemos alg√∫n tipo de enlace intermedio que servir√° como un bus entre todos nuestros nodos: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140775997.png" alt="1549140775997"></p><br><p>  Cuando un nodo quiere enviar un mensaje a otro, realiza una solicitud al Bus y, a su vez, lo reenv√≠a a donde sea necesario, todo es simple.  ¬°Nuestra red est√° lista! </p><br><p>  <strong>FIN.</strong> </p><br><p>  ... pero no es tan simple?) </p><br><p>  Con este enfoque, nos encontramos con el rendimiento de este enlace intermedio y, de hecho, nos gustar√≠a contactar directamente con los nodos necesarios, porque ¬øqu√© puede ser m√°s r√°pido que la comunicaci√≥n directa?  ¬°Entonces, avancemos en esta direcci√≥n! </p><br><p>  ¬øQu√© se necesita primero?  En realidad, legitimar una instancia a otra.  Pero, ¬øc√≥mo aprende el primero sobre la existencia del segundo?  Pero queremos tener un n√∫mero infinito de ellos, ¬°aumentar / eliminar arbitrariamente!  Necesitamos un servidor maestro cuya direcci√≥n sea conocida, todos se conectan a ella, por lo que conoce todos los nodos existentes en la red y comparte amablemente esta informaci√≥n con todos. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549048945334.png" alt="1549048945334"></p><br><p>  El nodo se eleva, le dice al maestro sobre su despertar, le da una lista de otros nodos activos, nos conectamos a ellos y eso es todo, la red est√° lista.  El maestro puede ser c√≥nsul o algo as√≠, pero como estamos en bicicleta, el maestro debe ser hecho a s√≠ mismo. </p><br><p>  ¬°Genial, ahora tenemos nuestra propia Skynet!  Pero la implementaci√≥n actual del chat ya no es adecuada.  Vamos a presentar los requisitos: </p><br><ol><li>  Cuando un usuario env√≠a un mensaje, necesitamos saber a qui√©n se lo env√≠a, es decir, tener acceso a los participantes en la sala. </li><li>  Cuando recibimos a los participantes, debemos entregarles mensajes. </li><li>  Necesitamos saber qu√© usuario est√° en l√≠nea ahora. </li><li>  Para mayor comodidad: brinde a los usuarios la oportunidad de suscribirse al estado en l√≠nea de otros usuarios, para que en tiempo real se enteren de su cambio </li></ol><br><p>  Tratemos con los usuarios.  Por ejemplo, puede hacer que el maestro sepa qu√© nodo est√° conectado a qu√© nodo.  La situaci√≥n es la siguiente: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549237952673.png" alt="1549237952673"></p><br><p>  Dos usuarios est√°n conectados a diferentes nodos.  El maestro sabe esto, los nodos saben lo que sabe el maestro.  Cuando el usuario B inicia sesi√≥n, el nodo 2 notifica al maestro, que "recuerda" que el usuario B est√° conectado al nodo 2.  Cuando el usuario A quiere enviar un mensaje de usuario B, obtiene la siguiente imagen: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140491881.png" alt="1549140491881"></p><br><p>  En principio, todo funciona, pero me gustar√≠a evitar una ronda adicional de viaje en forma de interrogar al maestro, ser√≠a m√°s econ√≥mico contactar inmediatamente al nodo correcto directamente, porque es por eso que todo comenz√≥.  Esto se puede hacer si le dicen a todos los usuarios que est√°n conectados a ellos, cada uno de ellos se convierte en un an√°logo autosuficiente del asistente y el asistente en s√≠ mismo se vuelve innecesario, porque la lista de la proporci√≥n "Usuario =&gt; Nodo" est√° duplicada para todos.  Al comienzo de un nodo, es suficiente para conectarse a cualquiera que ya se est√© ejecutando, extraer su lista y listo, tambi√©n est√° listo para la batalla. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139768940.png" alt="1549139768940"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139882747.png" alt="1549139882747"></p><br><p>  Pero como compensaci√≥n, obtenemos una duplicaci√≥n de la lista, que, aunque es una relaci√≥n de "ID de usuario -&gt; [conexiones de host]", pero con un n√∫mero suficiente de usuarios resultar√° ser bastante grande en la memoria.  Y, en general, cortarlo usted mismo: claramente huele a la industria de la bicicleta.  Cuanto m√°s c√≥digo, m√°s errores potenciales.  Quiz√°s congelemos esta opci√≥n y echemos un vistazo a lo que ya est√° listo: </p><br><h2 id="brokery-soobscheniy">  Corredores de mensajes </h2><br><p>  La entidad que implementa el mismo "Bus", el "enlace intermedio" mencionado anteriormente.  Su tarea es recibir y entregar mensajes.  Nosotros, como usuarios, podemos suscribirnos a ellos y enviar los nuestros.  Todo es simple </p><br><p>  Hay RabbitMQ y Kafka probados: simplemente hacen lo que entregan mensajes: este es su prop√≥sito, repleto de todas las funcionalidades necesarias para el cuello.  En su mundo, un mensaje debe ser entregado pase lo que pase. </p><br><p>  Al mismo tiempo, est√° Redis y su pub / sub, lo mismo que los chicos antes mencionados, pero m√°s dudoso: simplemente recibe el mensaje est√∫pidamente y lo entrega al suscriptor, sin colas ni otros gastos generales.  No le importan los mensajes en s√≠ mismos, desaparecer√°n si el suscriptor cuelga; lo tirar√° y tomar√° uno nuevo, como si le arrojaran un p√≥ker candente en sus manos del que desea deshacerse m√°s r√°pido.  Adem√°s, si cae repentinamente, todos los mensajes tambi√©n se hundir√°n junto con √©l.  En otras palabras, no se trata de ninguna garant√≠a de entrega. </p><br><p>  ... y esto es lo que necesitas! </p><br><p>  Bueno, de verdad, solo chateamos.  No es alg√∫n tipo de servicio de dinero cr√≠tico o centro de control de vuelo espacial, sino ... solo una charla.  El riesgo es que Pete condicional una vez al a√±o no reciba un mensaje de cada mil; puede ser descuidado si a cambio conseguimos un crecimiento de la productividad y establecemos con √©l el n√∫mero de usuarios para los mismos d√≠as, intercambiamos en todo su esplendor.  Adem√°s, al mismo tiempo, puede mantener un historial de mensajes en alg√∫n tipo de repositorio persistente, lo que significa que Petya a√∫n ver√° ese mensaje perdido al volver a cargar la p√°gina / aplicaci√≥n.  Es por eso que nos centraremos en Redis pub / sub, o m√°s bien: mire el adaptador existente para SocketIO, que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se menciona en el art√≠culo en la oficina.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio</a> . </p><br><p>  Entonces que es esto? </p><br><h2 id="redis-adapter">  Adaptador Redis </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/socketio/socket.io-redis</a> </p><br><p>  Con su ayuda, una aplicaci√≥n ordinaria a trav√©s de unas pocas l√≠neas y un n√∫mero m√≠nimo de gestos se convierte en un chat distribuido real.  Pero como?  <a href="">Si miras dentro</a> , resulta que solo hay un archivo por medio centenar de l√≠neas. </p><br><p>  En el caso cuando emitimos un mensaje </p><br><pre> <code class="plaintext hljs">io.emit("everyone", "hello")</code> </pre> <br><p>  se inserta en r√°banos, se transmite a todas las dem√°s instancias de nuestro chat, que a su vez ya lo emiten localmente en sockets </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549232309776.png" alt="1549232309776"></p><br><p>  El mensaje se distribuir√° en todos los nodos, incluso si lo emitimos a un usuario espec√≠fico.  Es decir, cada nodo acepta todos los mensajes y ya comprende si lo necesita. </p><br><p>  Adem√°s, se implement√≥ un simple rpc (llamada a procedimientos remotos), que permite no solo enviar sino tambi√©n recibir respuestas.  Por ejemplo, puede controlar los z√≥calos de forma remota, como "qui√©n est√° en la sala especificada", "ordenar que el z√≥calo se una a la sala", etc. </p><br><p>  ¬øQu√© se puede hacer con esto?  Por ejemplo, use la ID de usuario como el nombre de la sala (ID de usuario == ID de la sala).  Al autorizar, para conectar el z√≥calo y cuando queremos enviar un mensaje al usuario, solo un casco en √©l.  Adem√°s, podemos averiguar si el usuario est√° en l√≠nea, simplemente mirando si hay enchufes en la habitaci√≥n especificada. </p><br><p>  En principio, podemos parar aqu√≠, pero como siempre, no es suficiente para nosotros: </p><br><ol><li>  Cuello de botella en una sola instancia de r√°bano </li><li>  Redundancia, me gustar√≠a que los nodos reciban solo los mensajes que necesitan </li></ol><br><p>  A expensas del p√°rrafo uno, mire algo como: </p><br><h2 id="redis-cluster">  Redis cluster </h2><br><p>  Conecta varias instancias de r√°bano, despu√©s de lo cual funcionan como un todo.  ¬øPero c√≥mo lo hace?  S√≠, as√≠: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549233023980.png" alt="1549233023980"></p><br><p>  ... y vemos que el mensaje est√° duplicado para todos los miembros del cl√∫ster.  Es decir, no est√° destinado a aumentar la productividad, sino a aumentar la confiabilidad, que sin duda es buena y necesaria, pero para nuestro caso no tiene valor y no salva la situaci√≥n con un cuello de botella de ninguna manera, adem√°s, en suma, es a√∫n m√°s desperdicio de recursos. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549231953897.png" alt="1549231953897"></p><br><p>  Soy un principiante, no s√© mucho, a veces tengo que volver al pitchforking, lo que haremos.  No, dejemos el r√°bano para que no se deslice en absoluto, pero debes pensar en algo con la arquitectura porque el actual no es bueno. </p><br><h2 id="povorot-ne-tuda">  Gire por el camino equivocado </h2><br><p>  Que necesitamos  Aumentar el rendimiento general.  Por ejemplo, tratemos de generar est√∫pidamente otra instancia.  Imagine que socket.io-redis puede conectarse a varios, al enviar un mensaje, selecciona al azar y se suscribe a todo.  Resulta as√≠: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239818663.png" alt="1549239818663"></p><br><p>  Voila!  En general, el problema est√° resuelto, los r√°banos ya no son un cuello de botella, ¬°puedes generar cualquier cantidad de copias!  Pero se convirtieron en nodos.  S√≠, s√≠, nuestras instancias de chat a√∫n digieren TODOS los mensajes, a los que no estaban destinados. </p><br><p>  Puede viceversa: suscribirse a uno aleatorio, lo que reducir√° la carga en los nodos y empujar√° todo: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239361416.png" alt="1549239361416"></p><br><p>  Vemos que se ha vuelto al rev√©s: los nodos se sienten m√°s tranquilos, pero la carga en la instancia de r√°bano ha aumentado.  Esto tampoco es bueno.  Necesitas andar en bicicleta un poco. </p><br><p>  Para bombear nuestro sistema, dejaremos solo el paquete socket.io-redis, aunque es genial, necesitamos m√°s libertad.  Y as√≠, conectamos el r√°bano: </p><br><pre> <code class="plaintext hljs">//  : const pub = new RedisClient({host: 'localhost', port: 6379})//  const sub = new RedisClient({host: 'localhost', port: 6379})//   //    interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Configure nuestro sistema de mensajer√≠a: </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, dataRaw:string)=&gt; { const data = &lt;Message&gt;JSON.parse(dataRaw) io.to(data.roomId).emit('message', data)) }) //   sub.subscribe("messagesChannel") //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //   sock.on('message', (data:Message)=&gt; { //   pub.publish("messagesChannel", JSON.stringify(data)) })</code> </pre> <br><p>  Por el momento, resulta como en socket.io-redis: escuchamos todos los mensajes.  Ahora lo arreglaremos. </p><br><p>  Organizamos las suscripciones de la siguiente manera: recuerde el concepto con "id de usuario == id de sala", y cuando aparezca el usuario, nos suscribiremos al canal del mismo nombre en el r√°bano.  Por lo tanto, nuestros nodos solo recibir√°n mensajes destinados a ellos y no escuchar√°n la "transmisi√≥n completa". </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, message:string)=&gt; { io.to(channel).emit('message', message)) }) let UID:string|null = null; sock.on('auth', (uid:string)=&gt; { UID = uid //   -   //  UID  sub.subscribe(UID) //   sock.join(UID) }) sock.on('writeYourself', (message:string)=&gt; { //  ,        UID if (UID) pub.publish(UID, message) })</code> </pre> <br><p>  Impresionante, ahora estamos seguros de que los nodos solo reciben mensajes destinados a ellos, ¬°nada m√°s!  Sin embargo, debe tenerse en cuenta que las suscripciones en s√≠ son ahora mucho, mucho m√°s grandes, lo que significa que se comer√°n la memoria del a√±o a a√±o, + m√°s operaciones de suscripci√≥n / cancelaci√≥n de suscripci√≥n, que son relativamente caras.  Pero, en cualquier caso, esto nos da cierta flexibilidad, incluso puede detenerse en este momento y volver a visitar todas las opciones anteriores, ya teniendo en cuenta nuestra nueva propiedad de nodos en forma de mensajes de recepci√≥n m√°s selectivos y castas.  Por ejemplo, los nodos pueden suscribirse a una de varias instancias de r√°bano y, al presionar, enviar un mensaje a todas las instancias: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174595491.png" alt="1550174595491"></p><br><p>  ... pero, digan lo que uno diga, todav√≠a no ofrecen una extensibilidad infinita con una sobrecarga razonable, es necesario dar a luz a otras opciones.  En un momento, me vino a la mente el siguiente esquema: qu√© pasa si las instancias de r√°bano se dividen en grupos, digamos A y B, dos instancias en cada una.  Al suscribirse, los nodos son firmados por una instancia de cada grupo, y al enviar, env√≠an un mensaje a todas las instancias de un solo grupo aleatorio. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174092066.png" alt="1550174092066"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174943313.png" alt="1550174943313"></p><br><p>  Por lo tanto, obtenemos una estructura operativa con un potencial de capacidad de expansi√≥n infinito en tiempo real, la carga en un nodo individual en cualquier punto no depende del tama√±o del sistema, porque: </p><br><ol><li>  El ancho de banda total se divide entre grupos, es decir, con un aumento de usuarios / actividad, simplemente comparamos grupos adicionales. </li><li>  La gesti√≥n de usuarios (suscripciones) se divide dentro de los propios grupos, es decir, al aumentar los usuarios / suscripciones, simplemente aumentamos el n√∫mero de instancias dentro de los grupos. </li></ol><br><p>  ... y como siempre hay un "PERO": cuanto m√°s se obtiene, m√°s recursos se necesitan para la pr√≥xima ganancia, me parece una compensaci√≥n exorbitante. </p><br><p>  En general, si lo piensa, los enchufes antes mencionados provienen de no saber qu√© usuario est√° en qu√© nodo.  Bueno, de hecho, si tuvi√©ramos esta informaci√≥n, podr√≠amos enviar los mensajes justo donde lo necesitan, sin duplicaciones innecesarias.  ¬øQu√© hemos intentado hacer todo este tiempo?  Intentaron hacer que el sistema fuera infinitamente escalable, sin tener un mecanismo de direccionamiento claro, que inevitablemente se topaba con un callej√≥n sin salida o una redundancia injustificada.  Por ejemplo, puede recordar que el asistente act√∫a como una "libreta de direcciones": </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550233610561.png" alt="1550233610561"></p><br><blockquote>  Algo similar le dice a este tipo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6G22a5Iooqk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></blockquote><p>  Para obtener la ubicaci√≥n del usuario, hacemos un viaje de ida y vuelta adicional, que en principio est√° bien, pero no en nuestro caso.  Parece que estamos cavando en la direcci√≥n equivocada, necesitamos algo m√°s ... </p><br><h2 id="sila-hesha">  Fuerza de hash </h2><br><p>  Existe un hash.  Tiene un rango finito de valores.  Puede obtenerlo de cualquier dato.  Pero, ¬øqu√© pasa si divide este rango entre instancias de r√°bano?  Bueno, tomamos la ID de usuario, producimos un hash y, dependiendo del rango en el que result√≥ suscribirse / empujar a una instancia espec√≠fica.  Es decir, no sabemos de antemano d√≥nde existe qu√© usuario, pero despu√©s de haberlo recibido, podemos decir con confianza que es en n instancia, inf 100. Ahora lo mismo, pero con el c√≥digo: </p><br><pre> <code class="plaintext hljs">function hash(val:string):number{/**/}// -,   const clients:RedisClient[] = []//   const uid = "some uid"//  //,            //      const selectedClient = clients[hash(uid) % clients.length]</code> </pre> <br><p>  Voila!  Ahora que no dependemos del n√∫mero de instancias de la palabra en general, ¬°podemos escalar todo lo que queramos sin gastos generales!  Bueno, en serio, esta es una opci√≥n brillante, la √∫nica desventaja es la necesidad de reiniciar completamente el sistema al actualizar el n√∫mero de instancias de r√°bano.  Existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anillo est√°ndar y un anillo de partici√≥n</a> que le permiten superar esto, pero no son aplicables en un sistema de mensajer√≠a.  Bueno, puede hacer la l√≥gica de migrar suscripciones entre instancias, pero esto todav√≠a cuesta un c√≥digo adicional de tama√±o incomprensible y, como sabemos, cuanto m√°s c√≥digo, m√°s errores, no necesitamos esto, gracias.  Y en nuestro caso, el tiempo de inactividad es una compensaci√≥n bastante aceptable. </p><br><p>  Tambi√©n puede ver RabbitMQ con su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complemento</a> , que nos permite hacer lo mismo que nosotros, y + proporciona la migraci√≥n de suscripciones (como dije anteriormente, est√° vinculado con la funcionalidad de la cabeza a los pies).  En principio, puede tomarlo y dormir tranquilo, pero si alguien se equivoca en su afinaci√≥n para llevar el modo a tiempo real, dejando solo una funci√≥n con un anillo de hash. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Inund√≥ el repositorio en github.</a> </p><br><p>  Implementa la versi√≥n final a la que hemos llegado.  Adem√°s, existe una l√≥gica adicional para trabajar con salas (di√°logos). </p><br><p>  En general, estoy satisfecho y se puede redondear. </p><br><h2 id="itogo">  Total </h2><br><p>  Puede hacer cualquier cosa, pero existen recursos, y son finitos, por lo que debe retorcerse. </p><br><p>  Comenzamos con un completo desconocimiento de c√≥mo los sistemas distribuidos pueden funcionar con patrones concretos m√°s o menos tangibles, y eso es bueno. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440546/">https://habr.com/ru/post/440546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440534/index.html">Traducci√≥n de vocabulario pol√≠ticamente correcto del ingl√©s al ruso</a></li>
<li><a href="../440536/index.html">C√≥mo Facebook Project Infer ayuda a encontrar errores en las aplicaciones m√≥viles antes de la implementaci√≥n</a></li>
<li><a href="../440540/index.html">La capitalizaci√≥n de Reddit alcanz√≥ los $ 3 mil millones despu√©s de atraer una inversi√≥n de $ 300 millones</a></li>
<li><a href="../440542/index.html">Vuex: uso excesivo de captadores en la aplicaci√≥n. Error al analizar</a></li>
<li><a href="../440544/index.html">La versi√≥n experimental de Blazor 0.8.0 ya est√° disponible</a></li>
<li><a href="../440548/index.html">"No se puede simplemente tomar y paralelizar fuentes de voltaje"</a></li>
<li><a href="../440550/index.html">El tri√°ngulo de color no tiene dos, sino una esquina.</a></li>
<li><a href="../440552/index.html">Romper cierres e inyectar inyecci√≥n de dependencia en JavaScript</a></li>
<li><a href="../440554/index.html">BEM conveniente</a></li>
<li><a href="../440556/index.html">Aprendiendo el dise√±o de diagramas de relaci√≥n de entidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>