<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏻 💅🏼 🤹 Java中禁止的重载或桥接方法 🛤️ 🔤 👨🏾‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我在技术职位上的大多数面试都有一项任务，即应聘者需要在同一班上实现2个非常相似的界面： 


 如果可能，在一个类中实现两个接口。 解释为什么这是可能的。 


interface WithPrimitiveInt { void m(int i); } interface WithInteger {...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java中禁止的重载或桥接方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/426419/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/hs/hb/ihhshbtkwuq00zlpb7envgpgkk0.jpeg"></div><br><p> 我在技术职位上的大多数面试都有一项任务，即应聘者需要在同一班上实现2个非常相似的界面： </p><br><p>  <em>如果可能，在一个类中实现两个接口。</em>  <em>解释为什么这是可能的。</em> </p><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithPrimitiveInt</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithInteger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer i)</span></span></span></span>; }</code> </pre> <br><p>  <em>来自翻译：</em>本文不鼓励您在面试中提出相同的问题。 但是，如果您想在提出这个问题时做好充分准备，那么欢迎您。 </p><a name="habracut"></a><br><p> 有时，对答案不太确定的申请人更喜欢以以下条件解决此问题（无论如何，我要求您解决此问题）： </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span></span>; }</code> </pre> <br><p> 实际上，第二项任务似乎要简单得多，大多数候选人都回答说不可能将两个方法都包含在同一个类中，因为签名<code>Sm(int)</code>和<code>Vm(int)</code>相同，而返回值的类型却不同。 这是绝对正确的。 </p><br><p> 但是，有时我会问另一个与此主题相关的问题： </p><br><p>  <em>您认为允许在同一类中实现具有相同签名但具有不同类型的方法是否有意义？</em>  <em>例如，使用某种基于JVM的假设语言还是至少在JVM级别？</em> </p><br><p> 这个问题的答案是模棱两可的。 但是，尽管我不期望对此有任何答案，但仍然存在正确的答案。 经常使用反射API，操纵字节码或熟悉JVM规范的人可以回答它。 </p><br><h2 id="signatura-metoda-java-i-deskriptor-metoda-jvm">  Java方法签名和JVM方法句柄 </h2><br><p>  Java方法签名（即方法名称和参数类型）仅在编译时由Java编译器使用。 反过来，JVM使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">非限定的方法名称</a> （即方法名称）和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">方法handle</a> （即，描述符参数列表和一个返回描述符）来分隔类中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">方法</a> 。 </p><br><p> 例如，如果我们想直接在<code>foo.Bar</code>类上调用<code>String m(int i)</code>方法，则需要以下字节码： </p><br><pre> <code class="hljs julia">INVOKEVIRTUAL foo/Bar.m (<span class="hljs-literal"><span class="hljs-literal">I</span></span>)Ljava/lang/<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>;</code> </pre> <br><p> 对于无效的<code>m(int i)</code>以下内容： </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> foo/Bar.m (I)V</code> </pre> <br><p> 因此，JVM对同一类中的<code>String m(int i)</code>和<code>void m(int i)</code>非常满意。 所需要做的就是生成相应的字节码。 </p><br><h2 id="kung-fu-s-bayt-kodom"> 功夫与字节码 </h2><br><p> 我们有S和V接口，现在我们将创建一个包含两个接口的SV类。 在Java中，如果允许，则应如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SV</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"void m(int i)"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"String m(int i)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre> <br><p> 为了生成字节码，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Objectweb ASM库</a> ，这是一个足以了解字节码JVM的底层库。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完整的源代码已</a>上传到GitHub，在这里我将仅给出和解释最重要的片段。 </p><br><pre> <code class="java hljs">ClassWriter cw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassWriter(ClassWriter.COMPUTE_FRAMES); <span class="hljs-comment"><span class="hljs-comment">// package edio.java.experiments // public class SV implements S, V cw.visit(V1_7, ACC_PUBLIC, "edio/java/experiments/SV", null, "java/lang/Object", new String[]{ "edio/java/experiments/S", "edio/java/experiments/V" }); // constructor MethodVisitor constructor = cw.visitMethod(ACC_PUBLIC, "&lt;init&gt;", "()V", null, null); constructor.visitCode(); constructor.visitVarInsn(Opcodes.ALOAD, 0); constructor.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "&lt;init&gt;", "()V"); constructor.visitInsn(Opcodes.RETURN); constructor.visitMaxs(1, 1); constructor.visitEnd(); // public String m(int i) MethodVisitor mString = cw.visitMethod(ACC_PUBLIC, "m", "(I)Ljava/lang/String;", null, null); mString.visitCode(); mString.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;"); mString.visitLdcInsn("String"); mString.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V"); mString.visitInsn(Opcodes.ACONST_NULL); mString.visitInsn(Opcodes.ARETURN); mString.visitMaxs(2, 2); mString.visitEnd(); // public void m(int i) MethodVisitor mVoid = cw.visitMethod(ACC_PUBLIC, "m", "(I)V", null, null); mVoid.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;"); mVoid.visitLdcInsn("void"); mVoid.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V"); mVoid.visitInsn(Opcodes.RETURN); mVoid.visitMaxs(2, 2); mVoid.visitEnd(); cw.visitEnd();</span></span></code> </pre> <br><p> 让我们开始创建一个<code>ClassWriter</code>来生成字节码。 </p><br><p> 现在，我们将声明一个包含接口S和V的类。 </p><br><p> 尽管我们的SV参考伪Java代码没有构造函数，但仍需要为其生成代码。 如果我们不使用Java描述构造函数，则编译器会隐式生成一个空的构造函数。 </p><br><p> 在方法的主体中，我们首先获取类型为<code>java.io.PrintStream</code>的<code>System.out</code>字段，并将其添加到操作数堆栈中。 然后，将常量（ <code>String</code>或<code>void</code> ）加载到堆栈上，并在<code>out</code>变量中以字符串常量作为参数调用<code>println</code>命令。 </p><br><p> 最后，对于<code>String m(int i)</code>将引用类型的常量（其值为<code>null</code>到堆栈中，并使用对应类型的<code>return</code>即<code>ARETURN</code>将值返回给方法调用的发起者。 对于<code>void m(int i)</code>您只需要使用无类型的<code>RETURN</code>即可返回到方法调用的发起者，而无需返回任何值。 为了确保字节码正确（我经常这样做，多次纠正错误），我们将生成的类写入磁盘。 </p><br><pre> <code class="java hljs">Files.write(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(<span class="hljs-string"><span class="hljs-string">"/tmp/SV.class"</span></span>).toPath(), cw.toByteArray());</code> </pre> <br><p> 并使用<code>jad</code> （Java反编译器）将字节码转换回Java源代码： </p><br><pre> <code class="java hljs">$ jad -p /tmp/SV.class The <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">version</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> 51.0 (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">only</span></span></span><span class="hljs-class"> 45.3, 46.0 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">and</span></span></span><span class="hljs-class"> 47.0 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">are</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">supported</span></span></span><span class="hljs-class">) // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decompiled</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Jad</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v1</span></span></span><span class="hljs-class">.5.8</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Copyright</span></span></span><span class="hljs-class"> 2001 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pavel</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kouznetsov</span></span></span><span class="hljs-class">. // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Jad</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">home</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http</span></span></span><span class="hljs-class">://</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">www</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geocities</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kpdus</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jad</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">html</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decompiler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">options</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">packimports</span></span></span><span class="hljs-class">(3) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">package</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">edio</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">experiments</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.PrintStream; <span class="hljs-comment"><span class="hljs-comment">// Referenced classes of package edio.java.experiments: // S, V public class SV implements S, V { public SV() { } public String m(int i) { System.out.println("String"); return null; } public void m(int i) { System.out.println("void"); } }</span></span></code> </pre> <br><p> 我认为还不错。 </p><br><h2 id="ispolzovanie-sgenerirovannogo-klassa"> 使用生成的类 </h2><br><p> 对<code>jad</code>成功反编译本质上对我们没有任何保证。  <code>jad</code>实用程序仅向您警告字节码中的常见问题，从帧大小到局部变量不匹配或缺少返回语句。 </p><br><p> 要在运行时使用生成的类，我们需要以某种方式将其加载到JVM中，然后实例化它。 </p><br><p> 让我们实现自己的<code>AsmClassLoader</code> 。 这只是<code>ClassLoader.defineClass</code>一个方便包装<code>ClassLoader.defineClass</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsmClassLoader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassLoader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defineAsmClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, ClassWriter classWriter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = classWriter.toByteArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defineClass(name, bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytes.length); } }</code> </pre> <br><p> 现在使用此类加载器并实例化该类： </p><br><pre> <code class="java hljs">ClassWriter cw = SVGenerator.generateClass(); AsmClassLoader classLoader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsmClassLoader(); Class&lt;?&gt; generatedClazz = classLoader.defineAsmClass(SVGenerator.SV_FQCN, cw); Object o = generatedClazz.newInstance();</code> </pre> <br><p> 由于我们的类是在运行时生成的，因此我们无法在源代码中使用它。 但是我们可以将其类型转换为已实现的接口。 可以这样进行无反射的呼叫： </p><br><pre> <code class="java hljs">((S)o).m(<span class="hljs-number"><span class="hljs-number">1</span></span>); ((V)o).m(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p> 执行代码时，我们得到以下输出： </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span></code> </pre> <br><p> 在某些情况下，这个结论似乎是出乎意料的：我们在类中引用了相同的方法（从Java的角度来看），但是结果取决于将对象带到的接口而有所不同。 令人惊叹吧？ </p><br><p> 如果我们考虑底层字节码，一切将变得清晰。 对于我们的调用，编译器生成一个INVOKEINTERFACE语句，并且方法句柄不是来自类，而是来自接口。 </p><br><p> 因此，我们得到的第一个电话是： </p><br><pre> <code class="hljs lisp">INVOKEINTERFACE edio/java/experiments/Sm (<span class="hljs-name"><span class="hljs-name">I</span></span>)Ljava/lang/String<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p> 在第二个中： </p><br><pre> <code class="hljs lisp">INVOKEINTERFACE edio/java/experiments/Vm (<span class="hljs-name"><span class="hljs-name">I</span></span>)V</code> </pre> <br><p> 可以从堆栈中获取进行调用的对象。 这就是Java固有的多态性的力量。 </p><br><h2 id="imya-emu---bridge-metod"> 他叫桥法 </h2><br><p> 有人会问：“那么这一切的意义何在？它会派上用场吗？” </p><br><p> 关键是在编写常规Java代码时，我们（隐式）使用了相同的东西。 例如，协变返回类型，泛型以及从内部类对私有字段的访问是使用相同<em>的</em>字节码<em>魔术实现的</em> 。 </p><br><p> 看一下这个界面： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Number </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p> 及其实现，并返回协变量类型： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegerZero</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><p> 现在让我们考虑以下代码： </p><br><pre> <code class="java hljs">IntegerZero iz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntegerZero(); iz.getZero(); ZeroProvider zp = iz; zp.getZero();</code> </pre> <br><p> 对于<code>iz.getZero()</code> ，调用编译器将使用handle方法<code>()Ljava/lang/Integer;</code>生成<code>INVOKEVIRTUAL</code> <code>()Ljava/lang/Integer;</code>  ，而对于<code>zp.getZero()</code> ，它将使用方法描述符<code>()Ljava/lang/Number;</code>生成INVOKEINTERFACE <code>()Ljava/lang/Number;</code>  。 我们已经知道JVM使用名称和方法描述符调度对象调用。 由于描述符不同，因此这两个调用不能路由到<code>IntegerZero</code>实例中的相同方法。 </p><br><p> 实际上，编译器会生成一个附加方法，该方法充当类中指定的实际方法与通过接口调用时使用的方法之间的桥梁。 因此，该名称是桥接方法。 如果在Java中可行，则最终代码如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegerZero</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// This is a synthetic bridge method, which is present only in bytecode. // Java compiler wouldn't permit it. public Number getZero() { return this.getZero(); } }</span></span></code> </pre> <br><h2 id="posleslovie"> 后记 </h2><br><p>  Java编程语言和Java虚拟机不是一回事：尽管它们的名称具有相同的词，并且Java是JVM的主要语言，但是它们的功能和局限性并非始终相同。 了解JVM可以帮助您更好地理解Java或任何其他基于JVM的语言，但是，另一方面，了解Java及其历史有助于了解JVM设计中的某些决策。 </p><br><h3 id="ot-perevodchika"> 来自翻译 </h3><br><p> 兼容性问题迟早会开始让任何开发人员担心。 原始文章谈到了Java编译器的隐式行为及其魔术对应用程序的影响这一重要问题，作为CUBA Platform框架的开发人员，我们非常关心Java编译器的隐含行为，这直接影响了库的兼容性。 最近，我们在叶卡捷琳堡JUG的报告中谈到了“现实应用中的兼容性”，报告“ API不会在交叉口发生变化-如何构建稳定的API”，可以在此处找到会议视频。 </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JLGh08KXN08" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426419/">https://habr.com/ru/post/zh-CN426419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426409/index.html">未经所有者许可保护MikroTik路由器的黑客Alexei已成名</a></li>
<li><a href="../zh-CN426411/index.html">开发C ++ / CLI描述符类</a></li>
<li><a href="../zh-CN426413/index.html">每个开发人员都应了解的SOLID原则</a></li>
<li><a href="../zh-CN426415/index.html">金融科技摘要：中央银行的数字化控制，加密货币工资，手镯和钥匙圈形式的Mir卡</a></li>
<li><a href="../zh-CN426417/index.html">Pavel 2.0：JS，带有套接字和电话的node.js上的复制顾问</a></li>
<li><a href="../zh-CN426421/index.html">EHCI人为俄语</a></li>
<li><a href="../zh-CN426423/index.html">mmWave在智能手机上：高通如何使不可能变为可能</a></li>
<li><a href="../zh-CN426425/index.html">关于RTOS的全部真相。 第十四条 内存部分：简介和基本服务</a></li>
<li><a href="../zh-CN426427/index.html">对“东西”有用的东西：少量低价选择</a></li>
<li><a href="../zh-CN426429/index.html">在Debian 9上安装FreeSWITCH 1.8（Raspbian Stretch，Rasbperri Pi上MajorDoMo智能家庭系统的基本映像）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>