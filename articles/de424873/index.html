<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏻 👩‍⚖️ ✝️ Fallstricke von HttpClient in .NET 🏞️ 👩🏿‍🌾 🤶🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fortsetzung einer Reihe von Artikeln über "Fallstricke" Ich kann System.Net.HttpClient nicht ignorieren, das in der Praxis sehr häufig verwendet wird,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fallstricke von HttpClient in .NET</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424873/">  Fortsetzung einer Reihe von Artikeln über "Fallstricke" Ich kann System.Net.HttpClient nicht ignorieren, das in der Praxis sehr häufig verwendet wird, aber es gibt einige schwerwiegende Probleme, die möglicherweise nicht sofort sichtbar sind. <br><br>  Ein ziemlich häufiges Problem bei der Programmierung besteht darin, dass sich Entwickler nur auf die Funktionalität einer bestimmten Komponente konzentrieren und eine sehr wichtige nicht funktionierende Komponente vollständig ignorieren, was die Leistung, Skalierbarkeit, die einfache Wiederherstellung bei Fehlern, die Sicherheit usw. beeinträchtigen kann.  Zum Beispiel ist derselbe HttpClient anscheinend eine elementare Komponente, aber es gibt mehrere Fragen: Wie oft werden parallele Verbindungen zum Server hergestellt, wie lange leben sie, wie verhält es sich, wenn der DNS-Name, auf den zuvor zugegriffen wurde, auf eine andere IP-Adresse umgeschaltet wird ?  Versuchen wir, diese Fragen im Artikel zu beantworten. <br><a name="habracut"></a><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verbindungsleck</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Begrenzen Sie gleichzeitige Serververbindungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Langlebige Verbindungen und DNS-Caching</a> </li></ol><br><a name="1"></a>  Das erste Problem mit HttpClient ist das nicht offensichtliche <b>Verbindungsleck</b> .  Sehr oft musste ich Code treffen, in dem er erstellt wurde, um jede Anforderung auszuführen: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid textId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">$"http://someservice.com/api/v1/some-text/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{textId}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br>  Leider führt dieser Ansatz zu einer großen Verschwendung von Ressourcen und einer hohen Wahrscheinlichkeit, dass die Liste der offenen Verbindungen überläuft.  Um das Problem klar darzustellen, reicht es aus, den folgenden Code auszuführen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); } } }</code> </pre><br>  Schauen Sie sich am Ende die Liste der offenen Verbindungen über netstat an: <br><br><pre> PS C: \ Entwicklung \ Übungen&gt; netstat -n |  select-string -pattern "178.248.237.68"<font></font>
<font></font>
   TCP 192.168.1.13:43684 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43685 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43686 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43687 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43689 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003690 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003691 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003692 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003693 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003695 178.248.237.68-00-0043 TIME_WAIT
</pre><br>  <i>Hier wird der Schalter -n verwendet, um die Ausgabe zu beschleunigen, da andernfalls netstat für jede IP nach dem Domänennamen sucht und 178.248.237.68 zum Zeitpunkt dieses Schreibens nach der habr.com-IP-Adresse sucht.</i> <br><br>  Insgesamt sehen wir, dass trotz des using-Konstrukts und obwohl das Programm vollständig abgeschlossen war, die Verbindungen zum Server "hängen" blieben.  Und sie bleiben so lange hängen, wie im Registrierungsschlüssel HKEY_LOCAL_MACHINE \ SYSTEM \ CurrentControlSet \ Services \ Tcpip \ Parameters \ TcpTimedWaitDelay angegeben. <br><br>  Es kann sich sofort die Frage stellen, wie sich .NET Core in solchen Fällen verhält.  Was ist unter Windows, was ist unter Linux - genau das gleiche, weil eine solche Verbindungsaufbewahrung auf Systemebene und nicht auf Anwendungsebene erfolgt.  Der Status TIME_WAIT ist ein spezieller Status des Sockets, nachdem er von der Anwendung geschlossen wurde. Dies ist erforderlich, um Pakete zu verarbeiten, die noch über das Netzwerk übertragen werden können.  Unter Linux wird die Dauer dieses Status in / proc / sys / net / ipv4 / tcp_fin_timeout in Sekunden angegeben und kann bei Bedarf natürlich geändert werden. <br><br><a name="2"></a>  Das zweite Problem von HttpClient ist die nicht offensichtliche <b>Grenze gleichzeitiger Verbindungen zum Server</b> .  Angenommen, Sie verwenden das vertraute .NET Framework 4.7, mit dessen Hilfe Sie einen hoch geladenen Dienst entwickeln, bei dem andere Dienste über HTTP aufgerufen werden.  Das potenzielle Problem mit Verbindungslecks wurde behoben, sodass für alle Anforderungen dieselbe HttpClient-Instanz verwendet wird.  Was könnte falsch sein? <br><br>  Das Problem kann leicht erkannt werden, indem der folgende Code ausgeführt wird: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  <i>Mit der im Link angegebenen Ressource können Sie die Antwort des Servers um die angegebene Zeit verzögern, in diesem Fall um 5 Sekunden.</i> <br><br>  Wie nach Ausführung des obigen Codes leicht zu bemerken ist, kommen alle 5 Sekunden nur 2 Antworten an, obwohl 10 gleichzeitige Anforderungen erstellt wurden.  Dies liegt daran, dass die Interaktion mit HTTP in einem regulären .NET-Framework unter anderem eine spezielle Klasse System.Net.ServicePointManager durchläuft, die verschiedene Aspekte von HTTP-Verbindungen steuert.  Diese Klasse verfügt über eine DefaultConnectionLimit-Eigenschaft, die angibt, wie viele gleichzeitige Verbindungen für jede Domäne erstellt werden können.  Historisch gesehen ist der Standardwert einer Eigenschaft 2. <br><br>  Wenn Sie das obige Codebeispiel ganz am Anfang hinzufügen <br><br><pre> <code class="cs hljs">ServicePointManager.DefaultConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  dann wird die Ausführung des Beispiels merklich beschleunigt, da die Anforderungen in Stapeln von 5 ausgeführt werden. <br><br>  Bevor Sie fortfahren, wie dies in .NET Core funktioniert, sollten Sie noch etwas mehr über ServicePointManager sagen.  Die oben beschriebene Eigenschaft gibt die Standardanzahl der Verbindungen an, die für nachfolgende Verbindungen zu einer beliebigen Domäne verwendet werden.  Gleichzeitig ist es jedoch möglich, die Parameter für jeden Domänennamen einzeln zu steuern. Dies erfolgt über die ServicePoint-Klasse: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk"</span></span>)); delayServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  Nach dem Ausführen dieses Codes werden für jede Interaktion mit Habr über dieselbe HttpClient-Instanz 5 gleichzeitige Verbindungen und 3 Verbindungen mit der "slowwly" -Site verwendet. <br><br>  Hier gibt es noch eine weitere interessante Nuance: Die maximale Anzahl von Verbindungen für lokale Adressen (localhost) ist standardmäßig int.MaxValue.  Schauen Sie sich einfach die Ergebnisse der Ausführung dieses Codes an, ohne zuerst das DefaultConnectionLimit festzulegen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); Console.WriteLine(habrServicePoint.ConnectionLimit); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>)); Console.WriteLine(localServicePoint.ConnectionLimit);</code> </pre><br>  Fahren wir nun mit .NET Core fort.  Obwohl ServicePointManager noch im System.Net-Namespace vorhanden ist, hat dies keine Auswirkungen auf das Verhalten von HttpClient in .NET Core.  Stattdessen können die HTTP-Verbindungsparameter mit dem HttpClientHandler (oder SocketsHttpHandler, über den wir später sprechen werden) gesteuert werden: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClientHandler(); handler.MaxConnectionsPerServer = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  Das obige Beispiel verhält sich genauso wie das ursprüngliche Beispiel für das reguläre .NET Framework, um jeweils nur zwei Verbindungen herzustellen.  Wenn Sie jedoch die Zeile mit dem Eigenschaftssatz MaxConnectionsPerServer entfernen, ist die Anzahl der gleichzeitigen Verbindungen viel höher, da der Wert dieser Eigenschaft in .NET Core standardmäßig int.MaxValue ist. <br><br><a name="3"></a>  Und jetzt schauen wir uns das dritte nicht offensichtliche Problem mit den Standardeinstellungen an, das nicht weniger kritisch sein kann als die beiden vorherigen - <b>langlebige Verbindungen und DNS-Caching</b> .  Beim Herstellen einer Verbindung mit einem Remote-Server wird der Domänenname zuerst in die entsprechende IP-Adresse aufgelöst und anschließend die empfangene Adresse für einige Zeit in den Cache gestellt, um nachfolgende Verbindungen zu beschleunigen.  Um Ressourcen zu sparen, wird die Verbindung häufig nicht nach jeder Anforderung geschlossen, sondern lange offen gehalten. <br><br>  Stellen Sie sich vor, das von uns entwickelte System sollte normal funktionieren, ohne einen Neustart zu erzwingen, wenn der Server, mit dem es interagiert, auf eine andere IP-Adresse geändert wurde.  Zum Beispiel, wenn Sie aufgrund eines Fehlers im aktuellen zu einem anderen Rechenzentrum wechseln.  Selbst wenn eine permanente Verbindung aufgrund eines Fehlers im ersten Rechenzentrum unterbrochen wird (was auch schnell passieren kann), kann unser System im DNS-Cache nicht schnell auf eine solche Änderung reagieren.  Gleiches gilt für Anrufe an die Adresse, an der der Lastausgleich über DNS-Round-Robin erfolgt. <br><br>  Im Fall eines „normalen“ .NET-Frameworks kann dieses Verhalten über ServicePointManager und ServicePoint gesteuert werden (alle unten aufgeführten Parameter nehmen Werte in Millisekunden an): <br><br><ul><li>  ServicePointManager.DnsRefreshTimeout - Gibt an, wie lange die empfangene IP-Adresse für jeden Domänennamen zwischengespeichert wird. Der Standardwert beträgt 2 Minuten (120000). </li><li>  ServicePoint.ConnectionLeaseTimeout - Gibt an, wie lange die Verbindung geöffnet bleiben kann.  Standardmäßig gibt es keine zeitliche Begrenzung für Verbindungen. Jede Verbindung kann beliebig lange gehalten werden, da dieser Parameter -1 ist.  Wenn Sie den Wert auf 0 setzen, wird jede Verbindung sofort nach Abschluss der Anforderung geschlossen. </li><li>  ServicePoint.MaxIdleTime - Gibt an, nach welchem ​​Zeitpunkt der Inaktivität die Verbindung geschlossen wird.  Untätigkeit bedeutet keine Datenübertragung über die Verbindung.  Standardmäßig beträgt der Wert dieses Parameters 100 Sekunden (100000). </li></ul><br>  Um das Verständnis dieser Parameter zu verbessern, werden wir sie alle in einem Szenario kombinieren.  Angenommen, niemand hat DnsRefreshTimeout und MaxIdleTime geändert und sie sind 120 bzw. 100 Sekunden.  Damit wurde ConnectionLeaseTimeout auf 60 Sekunden gesetzt.  Die Anwendung stellt nur eine Verbindung her, über die alle 10 Sekunden Anforderungen gesendet werden. <br><br>  Mit diesen Einstellungen wird die Verbindung alle 60 Sekunden geschlossen (ConnectionLeaseTimeout), obwohl regelmäßig Daten übertragen werden.  Das Schließen und Neuerstellen erfolgt so, dass die korrekte Ausführung von Anforderungen nicht beeinträchtigt wird. Wenn die Zeit abgelaufen ist und die Anforderung noch ausgeführt wird, wird die Verbindung nach Abschluss der Anforderung geschlossen.  Jedes Mal, wenn eine Verbindung neu erstellt wird, wird zuerst die entsprechende IP-Adresse aus dem Cache entnommen. Erst wenn die Auflösung abgelaufen ist (120 Sekunden), sendet das System eine Anforderung an den DNS-Server. <br><br>  Der Parameter MaxIdleTime spielt in diesem Szenario keine Rolle, da die Verbindung nicht länger als 10 Sekunden inaktiv war. <br><br>  Das optimale Verhältnis dieser Parameter hängt stark von der spezifischen Situation und den nicht funktionalen Anforderungen ab: <br><br><ul><li>  Wenn Sie nicht beabsichtigen, die IP-Adressen hinter dem Domänennamen, auf den Ihre Anwendung zugreift, transparent zu wechseln, und gleichzeitig die Kosten für Netzwerkverbindungen minimieren müssen, sind die Standardeinstellungen eine gute Option. </li><li>  Wenn bei Fehlern zwischen IP-Adressen gewechselt werden muss, können Sie DnsRefreshTimeout auf 0 und ConnectionLeaseTimeout auf den für Sie geeigneten nicht negativen Wert setzen.  Welche davon speziell davon abhängt, wie schnell Sie zu einer anderen IP wechseln müssen.  Natürlich möchten Sie die schnellstmögliche Reaktion auf einen Fehler haben, aber hier müssen Sie den optimalen Wert finden, der einerseits eine akzeptable Schaltzeit bietet, andererseits den Durchsatz und die Reaktionszeit des Systems nicht beeinträchtigt, indem Verbindungen häufig neu erstellt werden. <br></li><li>  Wenn Sie die schnellstmögliche Reaktion auf das Ändern der IP-Adresse benötigen, z. B. beim Ausgleichen über DNS-Round-Robin, können Sie versuchen, DnsRefreshTimeout und ConnectionLeaseTimeout auf 0 zu setzen. Dies ist jedoch äußerst verschwenderisch: Für jede Anforderung wird zuerst der DNS-Server abgefragt Die Verbindung zum Zielknoten wird wiederhergestellt. <br></li><li>  Es kann Situationen geben, in denen das Setzen von ConnectionLeaseTimeout auf 0 mit einem DnsRefreshTimeout ungleich Null nützlich sein kann, aber ich kann nicht sofort ein geeignetes Skript erstellen.  Dies bedeutet logischerweise, dass für jede Anforderung Verbindungen neu erstellt werden, IP-Adressen jedoch nach Möglichkeit aus dem Cache entnommen werden. </li></ul><br>  Das Folgende ist ein Beispiel für Code, mit dem das Verhalten der oben beschriebenen Parameter beobachtet werden kann: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); ServicePointManager.DnsRefreshTimeout = <span class="hljs-number"><span class="hljs-number">120000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.MaxIdleTime = <span class="hljs-number"><span class="hljs-number">100000</span></span>; habrServicePoint.ConnectionLeaseTimeout = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { client.GetAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">10000</span></span>); }</code> </pre><br>  <i>Während das Testprogramm ausgeführt wird, können Sie netstat in einer Schleife über PowerShell ausführen, um die hergestellten Verbindungen zu überwachen.</i> <br><br>  Es sollte sofort gesagt werden, wie die beschriebenen Parameter in .NET Core verwaltet werden.  Einstellungen von ServicePointManager, wie im Fall von ConnectionLimit, funktionieren nicht.  Core verfügt über einen speziellen Typ von HTTP-Handler, der zwei der drei oben beschriebenen Parameter implementiert - SocketsHttpHandler: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SocketsHttpHandler(); handler.PooledConnectionLifetime = TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">60</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ConnectionLeaseTimeout handler.PooledConnectionIdleTimeout = TimeSpan.FromSeconds(100); // MaxIdleTime var client = new HttpClient(handler);</span></span></code> </pre><br>  Es gibt keinen Parameter, der die Caching-Zeit von DNS-Einträgen in .NET Core steuert.  Testfälle zeigen, dass das Caching nicht funktioniert. Beim Erstellen einer neuen DNS-Verbindung wird die Auflösung erneut ausgeführt. Für den normalen Betrieb unter Bedingungen, unter denen der angeforderte Domänenname zwischen verschiedenen IP-Adressen wechseln kann, setzen Sie PooledConnectionLifetime einfach auf den gewünschten Wert. <br><br>  Darüber hinaus muss gesagt werden, dass all diese Probleme von den Entwicklern von Microsoft nicht unbemerkt bleiben konnten. Daher wurde ab .NET Core 2.1 eine Factory von HTTP-Clients angezeigt, mit der einige von ihnen gelöst werden können - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-">https://docs.microsoft.com/en- us / dotnet / standard / microservices-architektur / implementieren-ausfallsichere-anwendungen / benutze-httpclientfactory-um-ausfallsichere-http-anfragen zu implementieren</a> .  Zusätzlich zur Verwaltung der Lebensdauer von Verbindungen bietet die neue Komponente die Möglichkeit, typisierte Clients zu erstellen, sowie einige andere nützliche Dinge.  In diesem Artikel und den darin enthaltenen Links finden Sie genügend Informationen und Beispiele zur Verwendung von HttpClientFactory. Daher werde ich die damit verbundenen Details in diesem Artikel nicht berücksichtigen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424873/">https://habr.com/ru/post/de424873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424861/index.html">Eine Schlange in der Mailbox und was macht F #</a></li>
<li><a href="../de424865/index.html">Elementare Designpartikel entdeckt</a></li>
<li><a href="../de424867/index.html">Hexapod-Entwicklung von Grund auf neu (Teil 1) - Design</a></li>
<li><a href="../de424869/index.html">Wie mich die neue iOS 12-Funktion daran erinnerte, dass es Zeit ist, zu heilen</a></li>
<li><a href="../de424871/index.html">Elon Musk und Tesla lösen Rechtsstreitigkeiten mit der US-amerikanischen Börsenaufsichtsbehörde</a></li>
<li><a href="../de424877/index.html">Kühlsystem für flüssige Bremsen</a></li>
<li><a href="../de424879/index.html">Schnittstellenverfügbarkeit Yandex Vortrag</a></li>
<li><a href="../de424881/index.html">Newtoo - 2018 eine vollwertige Browser-Engine von Grund auf neu entwickeln?</a></li>
<li><a href="../de424887/index.html">Worüber Lida schweigt: Der Beginn der Karriere eines Entwicklers. Prinzipien oder wie man ein Middl wird</a></li>
<li><a href="../de424889/index.html">Blick in den Intel 8087 Coprozessor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>