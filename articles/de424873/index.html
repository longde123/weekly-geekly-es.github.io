<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèª üë©‚Äç‚öñÔ∏è ‚úùÔ∏è Fallstricke von HttpClient in .NET üèûÔ∏è üë©üèø‚Äçüåæ ü§∂üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fortsetzung einer Reihe von Artikeln √ºber "Fallstricke" Ich kann System.Net.HttpClient nicht ignorieren, das in der Praxis sehr h√§ufig verwendet wird,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fallstricke von HttpClient in .NET</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424873/">  Fortsetzung einer Reihe von Artikeln √ºber "Fallstricke" Ich kann System.Net.HttpClient nicht ignorieren, das in der Praxis sehr h√§ufig verwendet wird, aber es gibt einige schwerwiegende Probleme, die m√∂glicherweise nicht sofort sichtbar sind. <br><br>  Ein ziemlich h√§ufiges Problem bei der Programmierung besteht darin, dass sich Entwickler nur auf die Funktionalit√§t einer bestimmten Komponente konzentrieren und eine sehr wichtige nicht funktionierende Komponente vollst√§ndig ignorieren, was die Leistung, Skalierbarkeit, die einfache Wiederherstellung bei Fehlern, die Sicherheit usw. beeintr√§chtigen kann.  Zum Beispiel ist derselbe HttpClient anscheinend eine elementare Komponente, aber es gibt mehrere Fragen: Wie oft werden parallele Verbindungen zum Server hergestellt, wie lange leben sie, wie verh√§lt es sich, wenn der DNS-Name, auf den zuvor zugegriffen wurde, auf eine andere IP-Adresse umgeschaltet wird ?  Versuchen wir, diese Fragen im Artikel zu beantworten. <br><a name="habracut"></a><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verbindungsleck</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Begrenzen Sie gleichzeitige Serververbindungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Langlebige Verbindungen und DNS-Caching</a> </li></ol><br><a name="1"></a>  Das erste Problem mit HttpClient ist das nicht offensichtliche <b>Verbindungsleck</b> .  Sehr oft musste ich Code treffen, in dem er erstellt wurde, um jede Anforderung auszuf√ºhren: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid textId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">$"http://someservice.com/api/v1/some-text/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{textId}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br>  Leider f√ºhrt dieser Ansatz zu einer gro√üen Verschwendung von Ressourcen und einer hohen Wahrscheinlichkeit, dass die Liste der offenen Verbindungen √ºberl√§uft.  Um das Problem klar darzustellen, reicht es aus, den folgenden Code auszuf√ºhren: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); } } }</code> </pre><br>  Schauen Sie sich am Ende die Liste der offenen Verbindungen √ºber netstat an: <br><br><pre> PS C: \ Entwicklung \ √úbungen&gt; netstat -n |  select-string -pattern "178.248.237.68"<font></font>
<font></font>
   TCP 192.168.1.13:43684 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43685 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43686 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43687 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43689 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003690 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003691 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003692 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003693 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003695 178.248.237.68-00-0043 TIME_WAIT
</pre><br>  <i>Hier wird der Schalter -n verwendet, um die Ausgabe zu beschleunigen, da andernfalls netstat f√ºr jede IP nach dem Dom√§nennamen sucht und 178.248.237.68 zum Zeitpunkt dieses Schreibens nach der habr.com-IP-Adresse sucht.</i> <br><br>  Insgesamt sehen wir, dass trotz des using-Konstrukts und obwohl das Programm vollst√§ndig abgeschlossen war, die Verbindungen zum Server "h√§ngen" blieben.  Und sie bleiben so lange h√§ngen, wie im Registrierungsschl√ºssel HKEY_LOCAL_MACHINE \ SYSTEM \ CurrentControlSet \ Services \ Tcpip \ Parameters \ TcpTimedWaitDelay angegeben. <br><br>  Es kann sich sofort die Frage stellen, wie sich .NET Core in solchen F√§llen verh√§lt.  Was ist unter Windows, was ist unter Linux - genau das gleiche, weil eine solche Verbindungsaufbewahrung auf Systemebene und nicht auf Anwendungsebene erfolgt.  Der Status TIME_WAIT ist ein spezieller Status des Sockets, nachdem er von der Anwendung geschlossen wurde. Dies ist erforderlich, um Pakete zu verarbeiten, die noch √ºber das Netzwerk √ºbertragen werden k√∂nnen.  Unter Linux wird die Dauer dieses Status in / proc / sys / net / ipv4 / tcp_fin_timeout in Sekunden angegeben und kann bei Bedarf nat√ºrlich ge√§ndert werden. <br><br><a name="2"></a>  Das zweite Problem von HttpClient ist die nicht offensichtliche <b>Grenze gleichzeitiger Verbindungen zum Server</b> .  Angenommen, Sie verwenden das vertraute .NET Framework 4.7, mit dessen Hilfe Sie einen hoch geladenen Dienst entwickeln, bei dem andere Dienste √ºber HTTP aufgerufen werden.  Das potenzielle Problem mit Verbindungslecks wurde behoben, sodass f√ºr alle Anforderungen dieselbe HttpClient-Instanz verwendet wird.  Was k√∂nnte falsch sein? <br><br>  Das Problem kann leicht erkannt werden, indem der folgende Code ausgef√ºhrt wird: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  <i>Mit der im Link angegebenen Ressource k√∂nnen Sie die Antwort des Servers um die angegebene Zeit verz√∂gern, in diesem Fall um 5 Sekunden.</i> <br><br>  Wie nach Ausf√ºhrung des obigen Codes leicht zu bemerken ist, kommen alle 5 Sekunden nur 2 Antworten an, obwohl 10 gleichzeitige Anforderungen erstellt wurden.  Dies liegt daran, dass die Interaktion mit HTTP in einem regul√§ren .NET-Framework unter anderem eine spezielle Klasse System.Net.ServicePointManager durchl√§uft, die verschiedene Aspekte von HTTP-Verbindungen steuert.  Diese Klasse verf√ºgt √ºber eine DefaultConnectionLimit-Eigenschaft, die angibt, wie viele gleichzeitige Verbindungen f√ºr jede Dom√§ne erstellt werden k√∂nnen.  Historisch gesehen ist der Standardwert einer Eigenschaft 2. <br><br>  Wenn Sie das obige Codebeispiel ganz am Anfang hinzuf√ºgen <br><br><pre> <code class="cs hljs">ServicePointManager.DefaultConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  dann wird die Ausf√ºhrung des Beispiels merklich beschleunigt, da die Anforderungen in Stapeln von 5 ausgef√ºhrt werden. <br><br>  Bevor Sie fortfahren, wie dies in .NET Core funktioniert, sollten Sie noch etwas mehr √ºber ServicePointManager sagen.  Die oben beschriebene Eigenschaft gibt die Standardanzahl der Verbindungen an, die f√ºr nachfolgende Verbindungen zu einer beliebigen Dom√§ne verwendet werden.  Gleichzeitig ist es jedoch m√∂glich, die Parameter f√ºr jeden Dom√§nennamen einzeln zu steuern. Dies erfolgt √ºber die ServicePoint-Klasse: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk"</span></span>)); delayServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  Nach dem Ausf√ºhren dieses Codes werden f√ºr jede Interaktion mit Habr √ºber dieselbe HttpClient-Instanz 5 gleichzeitige Verbindungen und 3 Verbindungen mit der "slowwly" -Site verwendet. <br><br>  Hier gibt es noch eine weitere interessante Nuance: Die maximale Anzahl von Verbindungen f√ºr lokale Adressen (localhost) ist standardm√§√üig int.MaxValue.  Schauen Sie sich einfach die Ergebnisse der Ausf√ºhrung dieses Codes an, ohne zuerst das DefaultConnectionLimit festzulegen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); Console.WriteLine(habrServicePoint.ConnectionLimit); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>)); Console.WriteLine(localServicePoint.ConnectionLimit);</code> </pre><br>  Fahren wir nun mit .NET Core fort.  Obwohl ServicePointManager noch im System.Net-Namespace vorhanden ist, hat dies keine Auswirkungen auf das Verhalten von HttpClient in .NET Core.  Stattdessen k√∂nnen die HTTP-Verbindungsparameter mit dem HttpClientHandler (oder SocketsHttpHandler, √ºber den wir sp√§ter sprechen werden) gesteuert werden: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClientHandler(); handler.MaxConnectionsPerServer = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  Das obige Beispiel verh√§lt sich genauso wie das urspr√ºngliche Beispiel f√ºr das regul√§re .NET Framework, um jeweils nur zwei Verbindungen herzustellen.  Wenn Sie jedoch die Zeile mit dem Eigenschaftssatz MaxConnectionsPerServer entfernen, ist die Anzahl der gleichzeitigen Verbindungen viel h√∂her, da der Wert dieser Eigenschaft in .NET Core standardm√§√üig int.MaxValue ist. <br><br><a name="3"></a>  Und jetzt schauen wir uns das dritte nicht offensichtliche Problem mit den Standardeinstellungen an, das nicht weniger kritisch sein kann als die beiden vorherigen - <b>langlebige Verbindungen und DNS-Caching</b> .  Beim Herstellen einer Verbindung mit einem Remote-Server wird der Dom√§nenname zuerst in die entsprechende IP-Adresse aufgel√∂st und anschlie√üend die empfangene Adresse f√ºr einige Zeit in den Cache gestellt, um nachfolgende Verbindungen zu beschleunigen.  Um Ressourcen zu sparen, wird die Verbindung h√§ufig nicht nach jeder Anforderung geschlossen, sondern lange offen gehalten. <br><br>  Stellen Sie sich vor, das von uns entwickelte System sollte normal funktionieren, ohne einen Neustart zu erzwingen, wenn der Server, mit dem es interagiert, auf eine andere IP-Adresse ge√§ndert wurde.  Zum Beispiel, wenn Sie aufgrund eines Fehlers im aktuellen zu einem anderen Rechenzentrum wechseln.  Selbst wenn eine permanente Verbindung aufgrund eines Fehlers im ersten Rechenzentrum unterbrochen wird (was auch schnell passieren kann), kann unser System im DNS-Cache nicht schnell auf eine solche √Ñnderung reagieren.  Gleiches gilt f√ºr Anrufe an die Adresse, an der der Lastausgleich √ºber DNS-Round-Robin erfolgt. <br><br>  Im Fall eines ‚Äûnormalen‚Äú .NET-Frameworks kann dieses Verhalten √ºber ServicePointManager und ServicePoint gesteuert werden (alle unten aufgef√ºhrten Parameter nehmen Werte in Millisekunden an): <br><br><ul><li>  ServicePointManager.DnsRefreshTimeout - Gibt an, wie lange die empfangene IP-Adresse f√ºr jeden Dom√§nennamen zwischengespeichert wird. Der Standardwert betr√§gt 2 Minuten (120000). </li><li>  ServicePoint.ConnectionLeaseTimeout - Gibt an, wie lange die Verbindung ge√∂ffnet bleiben kann.  Standardm√§√üig gibt es keine zeitliche Begrenzung f√ºr Verbindungen. Jede Verbindung kann beliebig lange gehalten werden, da dieser Parameter -1 ist.  Wenn Sie den Wert auf 0 setzen, wird jede Verbindung sofort nach Abschluss der Anforderung geschlossen. </li><li>  ServicePoint.MaxIdleTime - Gibt an, nach welchem ‚Äã‚ÄãZeitpunkt der Inaktivit√§t die Verbindung geschlossen wird.  Unt√§tigkeit bedeutet keine Daten√ºbertragung √ºber die Verbindung.  Standardm√§√üig betr√§gt der Wert dieses Parameters 100 Sekunden (100000). </li></ul><br>  Um das Verst√§ndnis dieser Parameter zu verbessern, werden wir sie alle in einem Szenario kombinieren.  Angenommen, niemand hat DnsRefreshTimeout und MaxIdleTime ge√§ndert und sie sind 120 bzw. 100 Sekunden.  Damit wurde ConnectionLeaseTimeout auf 60 Sekunden gesetzt.  Die Anwendung stellt nur eine Verbindung her, √ºber die alle 10 Sekunden Anforderungen gesendet werden. <br><br>  Mit diesen Einstellungen wird die Verbindung alle 60 Sekunden geschlossen (ConnectionLeaseTimeout), obwohl regelm√§√üig Daten √ºbertragen werden.  Das Schlie√üen und Neuerstellen erfolgt so, dass die korrekte Ausf√ºhrung von Anforderungen nicht beeintr√§chtigt wird. Wenn die Zeit abgelaufen ist und die Anforderung noch ausgef√ºhrt wird, wird die Verbindung nach Abschluss der Anforderung geschlossen.  Jedes Mal, wenn eine Verbindung neu erstellt wird, wird zuerst die entsprechende IP-Adresse aus dem Cache entnommen. Erst wenn die Aufl√∂sung abgelaufen ist (120 Sekunden), sendet das System eine Anforderung an den DNS-Server. <br><br>  Der Parameter MaxIdleTime spielt in diesem Szenario keine Rolle, da die Verbindung nicht l√§nger als 10 Sekunden inaktiv war. <br><br>  Das optimale Verh√§ltnis dieser Parameter h√§ngt stark von der spezifischen Situation und den nicht funktionalen Anforderungen ab: <br><br><ul><li>  Wenn Sie nicht beabsichtigen, die IP-Adressen hinter dem Dom√§nennamen, auf den Ihre Anwendung zugreift, transparent zu wechseln, und gleichzeitig die Kosten f√ºr Netzwerkverbindungen minimieren m√ºssen, sind die Standardeinstellungen eine gute Option. </li><li>  Wenn bei Fehlern zwischen IP-Adressen gewechselt werden muss, k√∂nnen Sie DnsRefreshTimeout auf 0 und ConnectionLeaseTimeout auf den f√ºr Sie geeigneten nicht negativen Wert setzen.  Welche davon speziell davon abh√§ngt, wie schnell Sie zu einer anderen IP wechseln m√ºssen.  Nat√ºrlich m√∂chten Sie die schnellstm√∂gliche Reaktion auf einen Fehler haben, aber hier m√ºssen Sie den optimalen Wert finden, der einerseits eine akzeptable Schaltzeit bietet, andererseits den Durchsatz und die Reaktionszeit des Systems nicht beeintr√§chtigt, indem Verbindungen h√§ufig neu erstellt werden. <br></li><li>  Wenn Sie die schnellstm√∂gliche Reaktion auf das √Ñndern der IP-Adresse ben√∂tigen, z. B. beim Ausgleichen √ºber DNS-Round-Robin, k√∂nnen Sie versuchen, DnsRefreshTimeout und ConnectionLeaseTimeout auf 0 zu setzen. Dies ist jedoch √§u√üerst verschwenderisch: F√ºr jede Anforderung wird zuerst der DNS-Server abgefragt Die Verbindung zum Zielknoten wird wiederhergestellt. <br></li><li>  Es kann Situationen geben, in denen das Setzen von ConnectionLeaseTimeout auf 0 mit einem DnsRefreshTimeout ungleich Null n√ºtzlich sein kann, aber ich kann nicht sofort ein geeignetes Skript erstellen.  Dies bedeutet logischerweise, dass f√ºr jede Anforderung Verbindungen neu erstellt werden, IP-Adressen jedoch nach M√∂glichkeit aus dem Cache entnommen werden. </li></ul><br>  Das Folgende ist ein Beispiel f√ºr Code, mit dem das Verhalten der oben beschriebenen Parameter beobachtet werden kann: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); ServicePointManager.DnsRefreshTimeout = <span class="hljs-number"><span class="hljs-number">120000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.MaxIdleTime = <span class="hljs-number"><span class="hljs-number">100000</span></span>; habrServicePoint.ConnectionLeaseTimeout = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { client.GetAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">10000</span></span>); }</code> </pre><br>  <i>W√§hrend das Testprogramm ausgef√ºhrt wird, k√∂nnen Sie netstat in einer Schleife √ºber PowerShell ausf√ºhren, um die hergestellten Verbindungen zu √ºberwachen.</i> <br><br>  Es sollte sofort gesagt werden, wie die beschriebenen Parameter in .NET Core verwaltet werden.  Einstellungen von ServicePointManager, wie im Fall von ConnectionLimit, funktionieren nicht.  Core verf√ºgt √ºber einen speziellen Typ von HTTP-Handler, der zwei der drei oben beschriebenen Parameter implementiert - SocketsHttpHandler: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SocketsHttpHandler(); handler.PooledConnectionLifetime = TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">60</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ConnectionLeaseTimeout handler.PooledConnectionIdleTimeout = TimeSpan.FromSeconds(100); // MaxIdleTime var client = new HttpClient(handler);</span></span></code> </pre><br>  Es gibt keinen Parameter, der die Caching-Zeit von DNS-Eintr√§gen in .NET Core steuert.  Testf√§lle zeigen, dass das Caching nicht funktioniert. Beim Erstellen einer neuen DNS-Verbindung wird die Aufl√∂sung erneut ausgef√ºhrt. F√ºr den normalen Betrieb unter Bedingungen, unter denen der angeforderte Dom√§nenname zwischen verschiedenen IP-Adressen wechseln kann, setzen Sie PooledConnectionLifetime einfach auf den gew√ºnschten Wert. <br><br>  Dar√ºber hinaus muss gesagt werden, dass all diese Probleme von den Entwicklern von Microsoft nicht unbemerkt bleiben konnten. Daher wurde ab .NET Core 2.1 eine Factory von HTTP-Clients angezeigt, mit der einige von ihnen gel√∂st werden k√∂nnen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-">https://docs.microsoft.com/en- us / dotnet / standard / microservices-architektur / implementieren-ausfallsichere-anwendungen / benutze-httpclientfactory-um-ausfallsichere-http-anfragen zu implementieren</a> .  Zus√§tzlich zur Verwaltung der Lebensdauer von Verbindungen bietet die neue Komponente die M√∂glichkeit, typisierte Clients zu erstellen, sowie einige andere n√ºtzliche Dinge.  In diesem Artikel und den darin enthaltenen Links finden Sie gen√ºgend Informationen und Beispiele zur Verwendung von HttpClientFactory. Daher werde ich die damit verbundenen Details in diesem Artikel nicht ber√ºcksichtigen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424873/">https://habr.com/ru/post/de424873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424861/index.html">Eine Schlange in der Mailbox und was macht F #</a></li>
<li><a href="../de424865/index.html">Elementare Designpartikel entdeckt</a></li>
<li><a href="../de424867/index.html">Hexapod-Entwicklung von Grund auf neu (Teil 1) - Design</a></li>
<li><a href="../de424869/index.html">Wie mich die neue iOS 12-Funktion daran erinnerte, dass es Zeit ist, zu heilen</a></li>
<li><a href="../de424871/index.html">Elon Musk und Tesla l√∂sen Rechtsstreitigkeiten mit der US-amerikanischen B√∂rsenaufsichtsbeh√∂rde</a></li>
<li><a href="../de424877/index.html">K√ºhlsystem f√ºr fl√ºssige Bremsen</a></li>
<li><a href="../de424879/index.html">Schnittstellenverf√ºgbarkeit Yandex Vortrag</a></li>
<li><a href="../de424881/index.html">Newtoo - 2018 eine vollwertige Browser-Engine von Grund auf neu entwickeln?</a></li>
<li><a href="../de424887/index.html">Wor√ºber Lida schweigt: Der Beginn der Karriere eines Entwicklers. Prinzipien oder wie man ein Middl wird</a></li>
<li><a href="../de424889/index.html">Blick in den Intel 8087 Coprozessor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>