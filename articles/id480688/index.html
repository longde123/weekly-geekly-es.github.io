<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎚️ 🚪 📱 Dari mana datangnya Mojibakes? Esensi penyandian 👩‍👩‍👧‍👦 👩🏿‍🏫 🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini mengeksplorasi konsep dasar di balik pengkodean karakter dan kemudian menyelam lebih dalam ke rincian teknis sistem pengkodean. 


 Jika A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dari mana datangnya Mojibakes? Esensi penyandian</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alconost/blog/480688/"><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/6b/fx/u8/6bfxu80gx8ygam-qemhdptmtsvc.jpeg"></a> </p><br><p>  Artikel ini mengeksplorasi konsep dasar di balik pengkodean karakter dan kemudian menyelam lebih dalam ke rincian teknis sistem pengkodean. </p><br><p>  Jika Anda hanya memiliki pengetahuan dasar tentang pengkodean karakter dan ingin lebih memahami esensi, perbedaan antara sistem pengkodean, mengapa kita terkadang berakhir dengan teks yang tidak masuk akal, dan prinsip-prinsip di balik arsitektur sistem pengkodean yang berbeda, kemudian baca terus. </p><br><p>  Untuk memahami pengkodean karakter secara detail membutuhkan beberapa bacaan yang luas dan banyak waktu.  Saya telah mencoba untuk menyelamatkan Anda dari upaya itu dengan menyatukan semuanya di satu tempat sambil memberikan apa yang saya yakini sebagai latar belakang topik yang cukup menyeluruh. </p><br><p>  Saya akan membahas bagaimana pengkodean byte tunggal (ASCII, Windows-1251 dll) bekerja, sejarah bagaimana Unicode menjadi, pengkodean berbasis Unicode UTF-8, UTF-16 dan bagaimana perbedaannya, fitur spesifik, kompatibilitas, dan ketiadaan di antara berbagai pengkodean, prinsip pengkodean karakter, dan panduan praktis tentang bagaimana karakter dikodekan dan didekodekan. </p><a name="habracut"></a><br><p>  Meskipun pengodean karakter mungkin bukan topik yang canggih, penting untuk memahami cara kerjanya sekarang dan bagaimana cara kerjanya di masa lalu tanpa menghabiskan banyak waktu. </p><br><h3 id="history-of-unicode">  Sejarah unicode </h3><br><p>  Saya pikir yang terbaik adalah memulai cerita kami dari waktu ketika komputer berada di tempat yang tidak semaju atau biasa dalam kehidupan kita seperti sekarang.  Pengembang dan insinyur yang mencoba untuk menghasilkan standar pada saat itu tidak tahu bahwa komputer dan internet akan sangat populer dan meresap seperti yang mereka lakukan.  Ketika itu terjadi, dunia membutuhkan pengkodean karakter. </p><br><p>  Tetapi bagaimana Anda bisa memiliki komputer menyimpan karakter atau huruf ketika hanya mengerti satu dan nol?  Dari kebutuhan ini muncul pengkodean ASCII 1-byte pertama, yang walaupun belum tentu pengkodean pertama, adalah yang paling banyak digunakan dan menetapkan tolok ukur.  Jadi ini standar yang baik untuk digunakan. </p><br><p>  Tapi apa itu ASCII?  Kode ASCII terdiri dari 8 bit.  Beberapa aritmatika mudah menunjukkan bahwa rangkaian karakter ini berisi 256 simbol (delapan bit, nol dan yang 2⁸ = 256). </p><br><p>  7-bit pertama - 128 simbol (2⁷ = 128) dalam himpunan digunakan untuk huruf Latin, karakter kontrol (seperti jeda garis keras, tab dan sebagainya) dan simbol gramatikal.  Bit lainnya adalah untuk bahasa nasional.  Dengan cara ini, 128 karakter pertama selalu sama, dan jika Anda ingin menyandikan bahasa asli Anda, bantu diri Anda dengan simbol yang tersisa. </p><br><p>  Ini memunculkan banyak sekali pengkodean nasional.  Anda berakhir dengan situasi seperti ini: misalkan Anda di Rusia membuat file teks yang secara default akan menggunakan Windows-1251 (pengodean Rusia yang digunakan di Windows).  Dan Anda mengirim dokumen Anda ke seseorang di luar Rusia, katakanlah di AS.  Bahkan jika penerima tahu bahasa Rusia, mereka akan kurang beruntung ketika mereka membuka dokumen di komputer mereka (dengan perangkat lunak pengolah kata menggunakan ASCII sebagai kode default) karena mereka akan melihat karakter kacau yang aneh (mojibake) alih-alih huruf Rusia. .  Lebih tepatnya, setiap huruf bahasa Inggris akan muncul dengan baik, karena 128 simbol pertama di Windows-1251 dan ASCII adalah identik, tetapi di mana pun ada teks Rusia, perangkat lunak pengolah kata penerima kami akan menggunakan pengkodean yang salah kecuali jika pengguna telah secara manual menetapkan karakter yang tepat pengkodean. </p><br><p>  Masalah dengan standar kode karakter nasional sudah jelas.  Dan akhirnya, kode-kode nasional ini mulai berlipat ganda, internet mulai meledak, dan semua orang ingin menulis dalam bahasa nasionalnya tanpa membuat mojibake yang tidak dapat dipahami ini. </p><br><p>  Ada dua opsi pada saat ini - gunakan pengkodean untuk setiap negara atau buat peta karakter universal untuk mewakili semua karakter di planet ini. </p><br><h3 id="a-short-primer-on-ascii">  A Primer Pendek Pada ASCII </h3><br><p>  Ini mungkin terlihat terlalu dasar, tetapi jika kita harus teliti kita harus membahas semua pangkalan. </p><br><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/az/bt/mw/azbtmwjfkdtsfbvqd_ju-fibbwe.png"></a> </p><br><p>  Ada 3 grup kolom dalam tabel ASCII: </p><br><ul><li>  nilai desimal karakter </li><li>  nilai heksadesimal karakter </li><li>  mesin terbang untuk karakter itu sendiri </li></ul><br><p> Katakanlah kita ingin menyandikan kata "ok" di ASCII.  Huruf "o" memiliki nilai desimal 111 dan 6F dalam heksadesimal.  Dalam biner, yaitu - 01101111. Huruf "k" adalah posisi 107 dalam desimal dan 6B dalam hex, atau - 01101011 dalam biner.  Jadi kata "OK" di ASCII akan terlihat seperti 01101111 01101011. Proses decoding akan sebaliknya.  Kita mulai dengan 8 bit, menerjemahkannya menjadi pengkodean desimal dan berakhir dengan nomor karakter, dan mencari tabel untuk simbol yang sesuai. </p><br><h3 id="unicode">  Unicode </h3><br><p>  Dari penjelasan di atas, seharusnya sudah cukup jelas mengapa diperlukan satu peta karakter umum.  Tapi seperti apa bentuknya?  Jawabannya adalah Unicode yang sebenarnya bukan encoding, tetapi set karakter.  Terdiri dari 1.114.112 posisi, atau titik kode, yang sebagian besar masih kosong, jadi tidak mungkin set perlu diperluas. </p><br><p>  Standar Unicode terdiri dari 17 pesawat dengan masing-masing 65.536 poin kode.  Setiap bidang berisi sekelompok simbol.  Pesawat nol adalah bidang multibahasa dasar di mana kami menemukan karakter yang paling umum digunakan dalam semua huruf modern.  Pesawat kedua berisi karakter dari bahasa yang mati.  Bahkan ada dua pesawat yang disediakan untuk penggunaan pribadi.  Sebagian besar pesawat masih kosong. </p><br><p>  Unicode memiliki poin kode untuk 0 hingga 10FFFF (dalam heksadesimal). </p><br><p>  Karakter dikodekan dalam format heksadesimal yang diawali dengan "U +".  Jadi, misalnya, bidang dasar pertama mencakup karakter U + 0000 ke U + FFFF (0 hingga 65.535), dan blok 17 berisi U + 100000 hingga U + 10FFFF (1.048.576 hingga 1.114.111). </p><br><p>  Jadi sekarang alih-alih menagerie dari banyak pengkodean, kami memiliki tabel semua yang mencakup semua simbol dan karakter yang mungkin kita butuhkan.  Tetapi ini bukan tanpa kesalahannya.  Sementara setiap karakter sebelumnya dikodekan oleh satu byte, sekarang dapat dikodekan menggunakan jumlah byte yang berbeda.  Misalnya, Anda hanya perlu satu byte untuk mengkodekan semua huruf dalam alfabet bahasa Inggris.  Misalnya, huruf Latin "o" di Unicode adalah U + 006F.  Dengan kata lain, angka yang sama dengan ASCII - 6F dalam heksadesimal dan 111 dalam biner.  Tetapi untuk menyandikan simbol "U + 103D5" (angka Persia "100"), kita membutuhkan 103D5 dalam hex dan 66.517 dalam desimal, dan sekarang kita membutuhkan tiga byte. </p><br><p>  Kompleksitas ini harus diatasi dengan pengkodean Unicode seperti UTF-8 dan UTF-16.  Dan selanjutnya kita akan melihat mereka. </p><br><h3 id="utf-8">  Utf-8 </h3><br><p>  UTF-8 adalah pengkodean Unicode dari sistem pengodean lebar variabel yang dapat digunakan untuk menampilkan simbol Unicode. </p><br><p>  Apa yang kita maksudkan ketika berbicara tentang lebar variabel?  Pertama-tama, kita perlu memahami bahwa unit struktural (atom) dalam pengkodean adalah byte.  Pengodean lebar variabel berarti satu karakter dapat dikodekan menggunakan jumlah unit atau byte yang berbeda.  Misalnya, huruf Latin dikodekan dengan satu byte, dan huruf Cyrillic dengan dua. </p><br><p>  Sebelum kita melanjutkan, sedikit menyinggung tentang kompatibilitas antara ASCII dan UTF. </p><br><p>  Fakta bahwa huruf Latin dan karakter kontrol kunci seperti jeda baris, tab berhenti, dll.  berisi satu byte membuat pengkodean-UTF kompatibel dengan ASCII.  Dengan kata lain, skrip Latin dan karakter kontrol ditemukan dalam titik kode yang sama persis di ASCII dan UTF dan dikodekan menggunakan satu byte di keduanya, dan karenanya kompatibel ke belakang. </p><br><p>  Mari kita gunakan huruf "o" dari contoh ASCII kami sebelumnya.  Ingatlah bahwa posisinya dalam tabel ASCII adalah 111, atau 01101111 dalam biner.  Dalam tabel Unicode, ini adalah U + 006F, atau 01101111. Dan sekarang karena UTF adalah sistem pengkodean dengan lebar variabel “o” akan menjadi satu byte.  Dengan kata lain, "o" akan diwakili dengan cara yang sama di keduanya.  Dan hal yang sama untuk karakter 0 - 128. Jadi, jika dokumen Anda berisi huruf-huruf bahasa Inggris Anda tidak akan melihat perbedaan jika Anda membukanya menggunakan UTF-8, UTF-16, atau ASCII, dan hanya akan melihat perbedaan jika Anda mulai bekerja dengan pengkodean nasional. </p><br><p>  Mari kita lihat bagaimana ungkapan bahasa Inggris / Rusia “Hello World” akan muncul dalam tiga sistem pengkodean yang berbeda: Windows-1251 (pengodean Rusia), ISO-8859-1 (sistem pengodean untuk bahasa Eropa Barat), UTF-8 (Unicode) .  Contoh ini memberi tahu karena kami memiliki frasa dalam dua bahasa yang berbeda. </p><br><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/3c/xa/rk/3cxarky4ifw35kpwa2fhcoslen8.jpeg"></a> </p><br><p>  Sekarang mari kita pertimbangkan bagaimana sistem pengkodean ini bekerja dan bagaimana kita dapat menerjemahkan satu baris teks dari satu pengkodean ke yang lain, dan apa yang terjadi jika karakter ditampilkan dengan tidak tepat, atau jika kita tidak dapat melakukan ini karena perbedaan dalam sistem. </p><br><p>  Mari kita asumsikan bahwa frasa asli kami ditulis dengan penyandian Windows-1251.  Ketika kita melihat tabel di atas kita bisa melihat dengan menerjemahkan dari desimal atau hex ke desimal bahwa kita mendapatkan pengkodean di bawah dalam biner menggunakan Windows-1251. </p><br><p>  01001000 01100101 01101100 01101100 01101111 00100000 11101100 11101000 11110000 </p><br><p>  Jadi sekarang kita memiliki frasa "Hello World" di Windows-1251 encoding. </p><br><p>  Sekarang bayangkan bahwa kita memiliki file teks tetapi kita tidak tahu sistem pengkodean teks yang menyimpannya.  Kami menganggap itu disandikan dalam ISO-8859-1 dan membukanya di pengolah kata kami menggunakan sistem penyandian ini.  Seperti yang kita lihat sebelumnya, beberapa karakter tampak baik-baik saja, seperti yang ada di sistem pengkodean ini, dan bahkan ada di titik kode yang sama, tetapi karakter dalam kata Rusia "dunia" tidak bekerja dengan baik juga.  Karakter-karakter ini tidak ada dalam sistem pengkodean, dan di tempat mereka, atau titik kode, di ISO-8859-1 kami menemukan karakter yang sama sekali berbeda.  Jadi "m" adalah titik kode 236, "dan" adalah 232, dan "p" adalah 240. Tetapi dalam ISO-8859-1 titik kode ini sesuai dengan "ì" (236), "è" (232), dan " ð ”(240). </p><br><p>  Jadi, frasa bahasa campuran kami "Hello World" yang disandikan di Windows-1251 dan dibaca di ISO-8859-1 akan terlihat seperti "Hello ìèð".  Kami memiliki kompatibilitas sebagian dan kami tidak dapat menampilkan frasa yang dikodekan dalam satu sistem dengan benar di sistem lain, karena simbol yang kami butuhkan tidak ada dalam pengkodean kedua. </p><br><p>  Kami membutuhkan pengkodean Unicode - dalam kasus kami, kami akan menggunakan UTF-8 sebagai contoh.  Kita telah membahas bahwa karakter dapat mengambil antara 1 hingga 4 byte di UTF-8, tetapi keuntungan lain adalah bahwa UTF, tidak seperti dua sistem pengkodean sebelumnya, tidak dibatasi hingga 256 simbol, tetapi berisi semua simbol dalam rangkaian karakter Unicode . </p><br><p>  Ia bekerja seperti ini: bit pertama dari setiap karakter yang dikodekan tidak sesuai dengan mesin terbang atau simbol itu sendiri, tetapi dengan byte tertentu.  Jadi, jika bit pertama adalah nol, kita tahu bahwa simbol yang dikodekan hanya menggunakan satu byte - yang membuat set kompatibel dengan ASCII.  Jika kita melihat lebih dekat pada tabel simbol ASCII kita melihat bahwa 128 simbol pertama (alfabet Inggris, karakter kontrol, dan tanda baca) dinyatakan dalam biner, semuanya dimulai dengan nilai bit 0 (perhatikan bahwa jika Anda menerjemahkan karakter ke dalam biner menggunakan konverter online atau yang serupa bit nol orde tinggi pertama dapat dibuang, yang dapat sedikit membingungkan). </p><br><p>  01001000 - nilai bit pertama adalah 0, jadi 1 byte mengkodekan 1 karakter -&gt; "H". </p><br><p>  01100101 - nilai bit pertama adalah 0, jadi 1 byte mengkodekan 1 karakter-&gt; "e". </p><br><p>  Jika nilai bit pertama bukan nol, simbol akan dikodekan dalam beberapa byte. </p><br><p>  Pengkodean dua byte akan memiliki 110 untuk tiga nilai bit pertama. </p><br><p>  11010000 10111100 - bit penanda adalah 110 dan 10, jadi kami menggunakan 2 byte untuk menyandikan 1 karakter.  Byte kedua dalam kasus ini selalu dimulai dengan "10." Jadi kami menghilangkan bit kontrol (bit utama yang disorot dalam warna merah dan hijau) dan melihat sisa kode (10000111100), dan mengkonversi ke hex (043) -&gt; U + 043C yang memberi kita "m" dalam bahasa Unicode. </p><br><p>  Bit awal untuk karakter tiga byte adalah 1110. </p><br><p>  11101000 10000111 101010101 - kami menjumlahkan semua bit kecuali bit kontrol dan kami menemukan bahwa dalam hex kami memiliki 103B5, U + 103D5 - nomor Persia kuno seratus (10000001111010101). </p><br><p>  Pengkodean karakter empat byte dimulai dengan bit-bit memimpin 11110. </p><br><p>  11110100 10001111 10111111 10111111 - U + 10FFFF yang merupakan karakter terakhir yang tersedia di set Unicode (1000011111111111111111111). </p><br><p>  Sekarang, kita dapat dengan mudah menulis frase multi-bahasa dalam pengkodean UTF-8. </p><br><h3 id="utf-16">  Utf-16 </h3><br><p>  UTF-16 adalah pengodean lebar variabel lainnya.  Perbedaan utama antara UTF-16 dan UTF-8 adalah bahwa UTF-16 menggunakan 2 byte (16 bit) per unit kode alih-alih 1 bye (8 bit).  Dengan kata lain, setiap karakter Unicode yang dikodekan dalam UTF-16 dapat berupa dua atau empat byte.  Untuk menjaga hal-hal sederhana, saya akan merujuk pada dua byte ini sebagai unit kode.  Jadi, dalam UTF-16 karakter apa pun dapat direpresentasikan menggunakan salah satu atau dua unit kode. </p><br><p>  Mari kita mulai dengan simbol yang dikodekan menggunakan satu unit kode.  Kita dapat dengan mudah menghitung bahwa ada 65.535 (216) karakter dengan satu unit kode, yang sejajar dengan bidang multibahasa dasar Unicode.  Semua karakter di pesawat ini akan diwakili oleh satu unit kode (dua byte) di UTF-16. </p><br><p>  Huruf latin "o" - 00000000 01101111. </p><br><p>  Huruf Cyrillic "M" - 00000100 00011100. </p><br><p>  Sekarang mari kita pertimbangkan karakter di luar bidang multibahasa dasar.  Ini membutuhkan dua unit kode (4 byte) dan dikodekan dengan cara yang sedikit lebih rumit. </p><br><p>  Pertama, kita perlu mendefinisikan konsep pasangan pengganti.  Pasangan pengganti adalah dua unit kode yang digunakan untuk menyandikan satu karakter (total 4 byte).  Set karakter Unicode menyimpan kisaran khusus D800 ke DFFF untuk pasangan pengganti.  Ini berarti bahwa ketika mengonversi pasangan pengganti menjadi byte dalam heksadesimal, kita berakhir dengan titik kode dalam rentang ini yang merupakan pasangan pengganti daripada karakter yang terpisah. </p><br><p>  Untuk menyandikan simbol dalam rentang 10000 - 10FFFF (mis., Karakter yang memerlukan lebih dari satu unit kode) kami memproses sebagai berikut: </p><br><ol><li><p>  Kurangi 10.000 (hex) dari titik kode (ini adalah titik kode terendah di kisaran 10.000 - 10FFFF). </p><br></li><li><p>  Kami berakhir dengan angka 20-bit tidak lebih besar dari FFFF. </p><br></li><li><p>  10 bit orde tinggi yang akhirnya kita tambahkan ke D800 (titik kode terendah dalam kisaran pasangan pengganti di Unicode). </p><br></li><li><p>  10 bit berikutnya ditambahkan ke DC00 (juga dari kisaran pasangan pengganti). </p><br></li><li><p>  Selanjutnya, kita berakhir dengan 2 unit kode 16-bit pengganti, 6 bit pertama yang mendefinisikan unit sebagai bagian dari pasangan pengganti. </p><br></li><li><p>  Bit kesepuluh di setiap pengganti mendefinisikan urutan pasangan.  Jika kita memiliki "1" itu adalah pengganti atau yang tinggi, dan jika kita memiliki "0" itu adalah pengganti atau rendah pengganti. </p><br></li></ol><br><p>  Ini akan lebih masuk akal ketika diilustrasikan dengan contoh di bawah ini. </p><br><p>  Mari kita encode dan kemudian decode angka Persia seratus (U + 103D5): </p><br><ol><li><p>  103D5 - 10.000 = 3D5. </p><br></li><li><p>  3D5 = 0000000000 1111010101 (10 bit tinggi adalah nol, dan ketika dikonversi ke heksadesimal kita berakhir dengan "0" (sepuluh yang pertama), dan 3D5 (sepuluh yang kedua)). </p><br></li><li><p>  0 + D800 = D800 (1101100000000000) 6 bit pertama memberitahu kita bahwa titik kode ini jatuh dalam kisaran pasangan pengganti, bit kesepuluh (dari kanan) memiliki nilai "0", jadi ini adalah pengganti tinggi. </p><br></li><li><p>  3D5 + DC00 = DFD5 (1101111111010101) 6 bit pertama memberi tahu kami bahwa titik kode ini jatuh dalam kisaran pasangan pengganti, bit kesepuluh (dari kanan) adalah "1", jadi kami tahu ini adalah pengganti rendah. </p><br></li><li><p>  Karakter yang dihasilkan dikodekan dalam UTF-16 terlihat seperti - 1101100000000000 1101111111010101. </p><br></li></ol><br><p>  Sekarang mari kita decode karakternya.  Katakanlah kita memiliki titik kode berikut - 1101100000100010 1101111010001000: </p><br><ol><li><p>  Kami mengonversi ke heksadesimal = D822 DE88 (kedua titik kode berada dalam kisaran pasangan pengganti, jadi kami tahu bahwa kami sedang berurusan dengan pasangan pengganti). </p><br></li><li><p>  1101100000100010 - bit kesepuluh (dari kanan) adalah "0", jadi ini adalah pengganti tinggi. </p><br></li><li><p>  1101111010001000 - bit kesepuluh (dari kanan) adalah "1", jadi ini adalah pengganti rendah. </p><br></li><li><p>  Kami mengabaikan 6 bit yang mengidentifikasi ini sebagai pengganti dan dibiarkan dengan 0000100010 1010001000 (8A88). </p><br></li><li><p>  Kami menambahkan 10.000 (titik kode terendah dalam kisaran pengganti) 8A88 + 10000 = 18A88. </p><br></li><li><p>  Kami melihat tabel Unicode untuk U + 18A88 = Tangut Component-649. </p><br></li></ol><br><p>  Kudos untuk semua orang yang membaca sejauh ini! </p><br><p>  Saya harap ini informatif tanpa membuat Anda bosan. </p><br><p>  <strong>Anda mungkin juga menemukan berguna:</strong> <strong><br></strong> <br>  <a href="https://unicode-table.com/en/">Set karakter unicode</a> </p><br><p>  <a href="https://habr.com/ru/company/alconost/blog/473960/">Strategi untuk pelokalan konten: berbasis IP atau browser</a> <a href="https://habr.com/ru/company/alconost/blog/473960/"><br></a> </p><br><h3 id="about-the-translator">  Tentang penerjemah </h3><br><p>  <a href="https://alconost.com/en%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">Alconost</a> adalah penyedia global layanan <a href="https://alconost.com/en/services/software-localization%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">pelokalan untuk aplikasi</a> , <a href="https://alconost.com/en/services/game-localization%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">game</a> , video, dan <a href="https://alconost.com/en/services/website-translation%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">situs web</a> dalam 70+ bahasa.  Kami menawarkan terjemahan oleh ahli bahasa penutur asli, pengujian linguistik, alur kerja berbasis cloud, pelokalan berkelanjutan, manajemen proyek 24/7, dan bekerja dengan format sumber daya string apa pun.  Kami juga membuat <a href="https://alconost.com/en/services/video-production%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">video</a> dan gambar iklan dan pendidikan, permainan asah, penjelas, dan trailer untuk Google Play dan App Store. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480688/">https://habr.com/ru/post/id480688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480674/index.html">Menguji server virtual dari DigitalOcean, Vultr, Linode dan Hetzner. Korban manusia: 0,0</a></li>
<li><a href="../id480680/index.html">Strategi pertahanan NGINX dan permintaan ke Igor Sysoev</a></li>
<li><a href="../id480682/index.html">Intel RealSense LiDAR L515 - RealSense Baru Lainnya</a></li>
<li><a href="../id480684/index.html">Kepingan Salju StarWars DIY (pembaruan 2019)</a></li>
<li><a href="../id480686/index.html">Mengapa saya menolak solusi lintas platform dalam pengembangan ponsel</a></li>
<li><a href="../id480690/index.html">Kami mengelola blind inch dengan murah</a></li>
<li><a href="../id480692/index.html">MobX atau Redux: Mana yang Lebih Baik Untuk Bereaksi Manajemen Negara?</a></li>
<li><a href="../id480694/index.html">Bisakah kita berhenti memanggil aksesibilitas dan kegunaan UX?</a></li>
<li><a href="../id480700/index.html">Kami menggunakan console.log () di Chrome hingga penuh</a></li>
<li><a href="../id480702/index.html">SDM dan talenta, pakar dan kreatif: bagaimana Habraseminar yang kedelapan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>