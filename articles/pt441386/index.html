<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèª üé≠ üë©üèæ‚Äç‚öñÔ∏è Spring Data JPA: o que √© bom e o que √© ruim üè® üò¢ üßëüèæ‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Filho veio ao pai 
 E perguntou ao beb√™ 
 - o que √© bom 
 e o que √© ruim 
 
 Vladimir Mayakovsky 


 Este artigo √© sobre o Spring Data JPA, especifica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Data JPA: o que √© bom e o que √© ruim</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441386/"><p> <em>Filho veio ao pai</em> <em><br></em>  <em>E perguntou ao beb√™</em> <em><br></em>  <em>- o que √© bom</em> <em><br></em>  <em>e o que √© ruim</em> <em><br></em> <br>  Vladimir Mayakovsky </p><br><p>  Este artigo √© sobre o Spring Data JPA, especificamente no rake subaqu√°tico que conheci no caminho e, √© claro, um pouco sobre desempenho. </p><a name="habracut"></a><br><p>  Os exemplos descritos no artigo podem ser executados no ambiente de teste, acess√≠vel por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">refer√™ncia</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Nota para aqueles que ainda n√£o se mudaram para o Spring Boot 2</b> <div class="spoiler_text"><p> Nas vers√µes do Spring Data JPA 2. *, a interface principal para trabalhar com reposit√≥rios, nomeadamente <code>CrudRepository</code> , da qual o <code>JpaRepository</code> √© herdado, <code>JpaRepository</code> .  Nas vers√µes 1. *, os principais m√©todos eram assim: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span></span>; }</code> </pre> <br><p>  Em novas vers√µes: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Optional&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span></span>; }</code> </pre> </div></div><br><p>  Ent√£o, vamos come√ßar. </p><br><h4 id="select-t-from-t-where-tid-in-">  selecione t. * de t onde t.id (...) </h4><br><p>  Uma das consultas mais comuns √© uma consulta no formato "selecione todos os registros para os quais a chave se enquadra no conjunto transmitido".  Tenho certeza que quase todos voc√™s escreveram ou viram algo como </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> List&lt;Long&gt; ids)</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Set&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Esses pedidos est√£o funcionando, s√£o adequados, n√£o h√° problemas de captura ou desempenho, mas h√° uma pequena desvantagem completamente discreta. </p><br><div class="spoiler">  <b class="spoiler_title">Antes de abrir o revestimento, tente pensar por si mesmo.</b> <div class="spoiler_text"><p>  A desvantagem √© que a interface √© muito estreita para transmitir chaves.  "Ent√£o o que?"  voc√™ diz.  "Bem, a lista, bem o conjunto, n√£o vejo nenhum problema aqui."  No entanto, se observarmos os m√©todos da interface raiz que recebem muitos valores, em todos os lugares vemos <code>Iterable</code> : </p><br><p>  "E da√≠? E eu quero uma lista. Por que √© pior?" <br>  N√£o √© pior, apenas esteja preparado para a apar√™ncia de c√≥digo semelhante em um n√≠vel mais alto no seu aplicativo: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Long&gt; userIds)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;Long&gt; ids = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(userIds); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.findByUserIds(ids); } <span class="hljs-comment"><span class="hljs-comment">// public List&lt;BankAccount&gt; findByUserIds(Set&lt;Long&gt; userIds) { List&lt;Long&gt; ids = new ArrayList&lt;&gt;(userIds); return repository.findByUserIds(ids); }</span></span></code> </pre> <br><p>  Esse c√≥digo n√£o faz nada al√©m de reverter as cole√ß√µes.  Pode acontecer que o argumento para o m√©todo seja uma lista, e o m√©todo do reposit√≥rio aceite o conjunto (ou vice-versa), e voc√™ apenas precisar√° reorden√°-lo para passar na compila√ß√£o.  Obviamente, isso n√£o se tornar√° um problema no contexto dos custos indiretos da pr√≥pria solicita√ß√£o, trata-se mais de gestos desnecess√°rios. </p><br><p>  Portanto, √© uma boa pr√°tica usar o <code>Iterable</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Z.Y.  Se estamos falando de um m√©todo de <code>*RepositoryCustom</code> , faz sentido usar <code>Collection</code> para simplificar o c√°lculo do tamanho dentro da implementa√ß√£o: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccountRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMoneyAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Long&gt; accountIds)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccountRepositoryImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMoneyAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Long&gt; accountIds)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ids.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre> </div></div><br><h4 id="lishniy-kod-nepovtoryayuschiesya-klyuchi">  C√≥digo extra: chaves n√£o duplicadas </h4><br><p>  Na continua√ß√£o da √∫ltima se√ß√£o, quero chamar a aten√ß√£o para um equ√≠voco comum: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Set&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Outras manifesta√ß√µes do mesmo erro: </p><br><pre> <code class="java hljs">Set&lt;Long&gt; ids = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(notUniqueIds); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids); List&lt;Long&gt; ids = ts.stream().map(T::id).distinct().collect(toList()); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids); Set&lt;Long&gt; ids = ts.stream().map(T::id).collect(toSet()); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids);</code> </pre> <br><p>  √Ä primeira vista, nada de anormal, certo? </p><br><div class="spoiler">  <b class="spoiler_title">Leve o seu tempo, pense por si mesmo;)</b> <div class="spoiler_text"><p>  As consultas HQL / JPQL do formul√°rio <code>select t from t where t.field in ...</code> acabar√° por se transformar em uma consulta </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> b.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> BankAccount b <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b.user_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (?, ?, ?, ?, ?, ‚Ä¶)</code> </pre> <br><p>  que sempre retornar√° a mesma coisa, independentemente da presen√ßa de repeti√ß√µes no argumento.  Portanto, para garantir a exclusividade das chaves n√£o √© necess√°rio.  H√° um caso especial - Oracle, em que pressionar mais de 1000 chaves leva a um erro.  Mas se voc√™ est√° tentando reduzir o n√∫mero de chaves eliminando repeti√ß√µes, deve pensar na raz√£o de sua ocorr√™ncia.  Provavelmente o erro est√° em algum lugar acima. </p><br><p>  Portanto, em bom c√≥digo, use <code>Iterable</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> </div></div><br><h4 id="samopis">  Samopis </h4><br><p>  D√™ uma olhada neste c√≥digo e encontre aqui tr√™s falhas e um poss√≠vel erro: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"from User u where u.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;User&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Pense um pouco mais</b> <div class="spoiler_text"><ul><li>  tudo j√° est√° implementado no <code>SimpleJpaRepository::findAllById</code> </li><li>  solicita√ß√£o inativa ao passar uma lista vazia (em <code>SimpleJpaRepository::findAllById</code> h√° uma verifica√ß√£o correspondente) </li><li>  todas as consultas descritas usando <code>@Query</code> s√£o verificadas no est√°gio de aumentar o contexto, o que leva tempo (diferente de <code>SimpleJpaRepository::findAllById</code> ) </li><li>  se o Oracle for usado, quando a cole√ß√£o de chaves estiver vazia, obteremos o erro <code>ORA-00936: missing expression</code> (o que n√£o acontecer√° ao usar <code>SimpleJpaRepository::findAllById</code> , consulte o ponto 2) </li></ul></div></div><br><h4 id="garri-potter-i-sostavnoy-klyuch">  Harry potter e chave composta </h4><br><p>  D√™ uma olhada em dois exemplos e escolha o seu preferido: </p><br><p>  N√∫mero do m√©todo vezes </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ Long key1; Long key2; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKeyEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@EmbeddedId</span></span> CompositeKey key; }</code> </pre> <br><p>  M√©todo n√∫mero dois </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ Long key1; Long key2; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@IdClass</span></span>(value = CompositeKey.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKeyEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long key1; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long key2; }</code> </pre> <br><p>  √Ä primeira vista, n√£o h√° diferen√ßa.  Agora tente o primeiro m√©todo e execute um teste simples: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//case for @EmbeddedId @Test public void findAll() { int size = entityWithCompositeKeyRepository.findAllById(compositeKeys).size(); assertEquals(size, 5); }</span></span></code> </pre> <br><p>  No log de consulta (voc√™ mant√©m, certo?) Veremos isso: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ?</code> </pre> <br><p>  Agora segundo exemplo </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//case for @Id @Id @Test public void _findAll() { int size = anotherEntityWithCompositeKeyRepository.findAllById(compositeKeys).size(); assertEquals(size, 5); }</span></span></code> </pre> <br><p>  O log de consulta parece diferente: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=?</code> </pre> <br><p>  Essa √© toda a diferen√ßa: no primeiro caso, sempre recebemos 1 solicita√ß√£o, no segundo - n pedidos. <br>  O motivo desse comportamento est√° em <code>SimpleJpaRepository::findAllById</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ... if (entityInfo.hasCompositeId()) { List&lt;T&gt; results = new ArrayList&lt;&gt;(); for (ID id : ids) { findById(id).ifPresent(results::add); } return results; } // ...</span></span></code> </pre> <br><p>  Qual m√©todo √© o melhor para voc√™ determinar com base na import√¢ncia do n√∫mero de solicita√ß√µes. </p><br><h4 id="lishniy-crudrepositorysave">  CrudRepository extra :: salvar </h4><br><p>  Freq√ºentemente no c√≥digo existe um antipadr√£o: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, BigDecimal rate)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setRate(rate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repo.save(account); }</code> </pre> <br><p>  O leitor est√° perplexo: onde est√° o antipadr√£o?  Este c√≥digo parece muito l√≥gico: obtemos a entidade - atualiza√ß√£o - salvamento.  Tudo √© como nas melhores casas de S√£o Petersburgo.  Ouso dizer que chamar <code>CrudRepository::save</code> √© sup√©rfluo aqui. </p><br><p>  Primeiro: o m√©todo <code>updateRate</code> transacional; portanto, todas as altera√ß√µes na entidade gerenciada s√£o rastreadas pelo Hibernate e se transformam em uma solicita√ß√£o quando o <code>Session::flush</code> executado, o que nesse c√≥digo ocorre quando o m√©todo termina. </p><br><p>  Em segundo lugar, <code>CrudRepository::save</code> dar uma olhada no m√©todo <code>CrudRepository::save</code> .  Como voc√™ sabe, todos os reposit√≥rios s√£o baseados no <code>SimpleJpaRepository</code> .  Aqui est√° a implementa√ß√£o do <code>CrudRepository::save</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInformation.isNew(entity)) { em.persist(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.merge(entity); } }</code> </pre> <br><p>  H√° uma sutileza que nem todos se lembram: o Hibernate funciona atrav√©s de eventos.  Em outras palavras, cada a√ß√£o do usu√°rio gera um evento na fila e processado, levando em considera√ß√£o outros eventos na mesma fila.  Nesse caso, uma chamada para <code>EntityManager::merge</code> gera um <code>MergeEvent</code> , que √© processado por padr√£o no <code>DefaultMergeEventListener::onMerge</code> .  Ele cont√©m uma l√≥gica bastante ramificada, mas simples, para cada um dos estados do argumento da entidade.  Em nosso caso, a entidade √© obtida do reposit√≥rio dentro do m√©todo transacional e est√° no estado PERSISTENT (ou seja, essencialmente controlado pela estrutura): </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entityIsPersistent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MergeEvent event, Map copyCache)</span></span></span><span class="hljs-function"> </span></span>{ LOG.trace(<span class="hljs-string"><span class="hljs-string">"Ignoring persistent instance"</span></span>); Object entity = event.getEntity(); EventSource source = event.getSession(); EntityPersister persister = source.getEntityPersister(event.getEntityName(), entity); ((MergeContext)copyCache).put(entity, entity, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cascadeOnMerge(source, persister, entity, copyCache); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- this.copyValues(persister, entity, entity, source, copyCache); //&lt;---- event.setResult(entity); }</span></span></code> </pre> <br><p>  O diabo est√° nos detalhes, nomeadamente nos m√©todos <code>DefaultMergeEventListener::cascadeOnMerge</code> e <code>DefaultMergeEventListener::copyValues</code> .  Vamos ouvir o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discurso direto de Vlad Mikhalche</a> , um dos principais desenvolvedores do Hibernate: </p><br><blockquote>  Na chamada do m√©todo copyValues, o estado hidratado √© copiado novamente, para que uma nova matriz seja criada de forma redundante, desperdi√ßando assim ciclos de CPU.  Se a entidade tiver associa√ß√µes filhas e a opera√ß√£o de mesclagem tamb√©m for cascateada de pai para filho, a sobrecarga ser√° ainda maior porque cada entidade filho propagar√° um MergeEvent e o ciclo continuar√°. </blockquote><p>  Em outras palavras, est√° sendo feito um trabalho que voc√™ n√£o pode fazer.  Como resultado, nosso c√≥digo pode ser simplificado enquanto aprimora seu desempenho: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, BigDecimal rate)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setRate(rate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> account; }</code> </pre> <br><p>  Obviamente, √© inconveniente ter isso em mente ao desenvolver e revisar o c√≥digo de outra pessoa, portanto, gostar√≠amos de fazer altera√ß√µes no n√≠vel da estrutura de arame para que o m√©todo <code>JpaRepository::save</code> perca suas propriedades nocivas.  Isso √© poss√≠vel? </p><br><div class="spoiler">  <b class="spoiler_title">Sim talvez</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// @Transactional public &lt;S extends T&gt; S save(S entity) { if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else { return em.merge(entity); } } // @Transactional public &lt;S extends T&gt; S save(S entity) { if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else if (!em.contains(entity)) { return em.merge(entity); } return entity; }</span></span></code> </pre> <br><p>  Essas mudan√ßas foram realmente feitas em dezembro de 2017: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://jira.spring.io/browse/DATAJPA-931</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/spring-projects/spring-data-jpa/pull/237</a> </p></div></div><br><p>  No entanto, o leitor sofisticado provavelmente j√° sentiu que algo estava errado.  De fato, essa mudan√ßa n√£o quebrar√° nada, mas apenas no caso simples quando n√£o houver entidades filhas: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> BigDecimal rate = BigDecimal.ZERO; }</code> </pre> <br><p>  Agora, suponha que seu propriet√°rio esteja vinculado √† conta: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> BigDecimal rate = BigDecimal.ZERO; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>) User user; }</code> </pre> <br><p>  Existe um m√©todo que permite desconectar o usu√°rio da conta e transferi-lo para o novo usu√°rio: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, User newUser)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setUser(newUser); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repo.save(account); }</code> </pre> <br><p>  O que vai acontecer agora?  A verifica√ß√£o de <code>em.contains(entity)</code> retornar√° true, o que significa que <code>em.merge(entity)</code> n√£o ser√° chamado.  Se a chave da entidade <code>User</code> for criada com base na sequ√™ncia (um dos casos mais comuns), ela n√£o ser√° criada at√© que a transa√ß√£o seja conclu√≠da (ou <code>Session::flush</code> chamada manualmente), ou seja, o usu√°rio estar√° no estado DETACHED e sua entidade pai ( conta) - no estado PERSISTENTE.  Em alguns casos, isso pode quebrar a l√≥gica do aplicativo, e foi o que aconteceu: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">02/03/2018 DATAJPA-931 interrompe a fus√£o com o RepositoryItemWriter</a> </p><br><p>  Nesse sentido, a tarefa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reverter otimiza√ß√µes feitas para entidades existentes no CrudRepository :: save foi criada</a> e as altera√ß√µes foram feitas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reverter DATAJPA-931</a> . </p><br><h4 id="slepoy-crudrepositoryfindbyid">  Blind CrudRepository :: findById </h4><br><p>  Continuamos a considerar o mesmo modelo de dados: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-comment"><span class="hljs-comment">// ... } @Entity public class BankAccount { @Id Long id; @ManyToOne @JoinColumn(name = "user_id") User user; }</span></span></code> </pre> <br><p>  O aplicativo possui um m√©todo que cria uma nova conta para o usu√°rio especificado: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); userRepository.findById(userId).ifPresent(account::setUser); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><p>  Com a vers√£o 2. * o antipadr√£o indicado pela seta n√£o √© t√£o impressionante - √© mais claramente visto nas vers√µes mais antigas: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); account.setUser(userRepository.findOne(userId)); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Se voc√™ n√£o v√™ a falha "a olho nu", d√™ uma olhada nas consultas:</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u.id, u.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.id = ? <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hibernate_sequence <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> bank_account (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span> user_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span>)</code> </pre> </div></div><br><p>  A primeira solicita√ß√£o, obtemos o usu√°rio por chave.  Em seguida, obtemos a chave da conta do rec√©m-nascido no banco de dados e a inserimos na tabela.  E a √∫nica coisa que extra√≠mos do usu√°rio √© a chave, que j√° temos como argumento de m√©todo.  Por outro lado, <code>BankAccount</code> cont√©m o campo "user" e n√£o podemos deix√°-lo vazio (como pessoas decentes, definimos uma restri√ß√£o no esquema).  Desenvolvedores experientes provavelmente j√° veem uma maneira <del>  e comer um peixe, e andar a cavalo </del>  fa√ßa com que o usu√°rio e a solicita√ß√£o n√£o: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); account.setUser(userRepository.getOne(userId)); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><p>  <code>JpaRepository::getOne</code> retorna um wrapper sobre a chave que tem o mesmo tipo da "entidade" viva.  Este c√≥digo fornece apenas duas solicita√ß√µes: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hibernate_sequence <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> bank_account (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span> user_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span>)</code> </pre> <br><p>  Quando uma entidade que est√° sendo criada cont√©m muitos campos com um relacionamento muitos-para-um / um-para-um, essa t√©cnica ajuda a acelerar a economia e reduzir a carga no banco de dados. </p><br><h4 id="ispolnenie-hql-zaprosov">  Executando consultas HQL </h4><br><p>  Este √© um t√≥pico separado e interessante :).  O modelo de dom√≠nio √© o mesmo e existe uma solicita√ß√£o: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select count(ba) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from BankAccount ba "</span></span> + <span class="hljs-string"><span class="hljs-string">" join ba.user user "</span></span> + <span class="hljs-string"><span class="hljs-string">" where user.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUserAccounts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  Considere o HQL "puro": </p><br><pre> <code class="plaintext hljs">select count(ba) from BankAccount ba join ba.user user where user.id = :id</code> </pre> <br><p>  Quando √© executada, a seguinte consulta SQL ser√° criada: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ba.user_id = u.id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.id = ?</code> </pre> <br><p>  O problema aqui n√£o √© imediatamente evidente, mesmo com uma vida s√°bia e um bom entendimento dos desenvolvedores SQL: <code>inner join</code> por chave de usu√°rio excluir√° as contas com <code>user_id</code> ausente da sele√ß√£o (e, de uma maneira boa, a inser√ß√£o delas deve ser proibida no n√≠vel do esquema), o que significa que n√£o √© <code>user_id</code> ingressar na tabela do <code>user</code> . preciso.  A solicita√ß√£o pode ser simplificada (e acelerada): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ba.user_id = ?</code> </pre> <br><p>  Existe uma maneira de obter esse comportamento facilmente em c usando o HQL: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select count(ba) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from BankAccount ba "</span></span> + <span class="hljs-string"><span class="hljs-string">" where ba.user.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUserAccounts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  Este m√©todo cria uma solicita√ß√£o "Lite". </p><br><h4 id="annotaciya-query-protiv-metoda">  Resumo de consulta vs. m√©todo </h4><br><p>  Um dos principais recursos do Spring Data √© a capacidade de criar uma consulta a partir do nome do m√©todo, o que √© muito conveniente, especialmente em combina√ß√£o com o complemento inteligente do IntelliJ IDEA.  A consulta descrita no exemplo anterior pode ser facilmente reescrita: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// @Query("select count(ba) " + " from BankAccount ba " + " where ba.user.id = :id") long countUserAccounts(@Param("id") Long id); // long countByUserAccount_Id(Long id);</span></span></code> </pre> <br><p>  Parece ser mais simples, mais curto, mais leg√≠vel e mais importante - voc√™ n√£o precisa examinar a pr√≥pria solicita√ß√£o.  Li o nome do m√©todo - e j√° est√° claro o que ele escolhe e como.  Mas o diabo est√° aqui nos detalhes.  A consulta final para o m√©todo marcado com <code>@Query</code> j√° vimos.  O que acontecer√° no segundo caso? </p><br><div class="spoiler">  <b class="spoiler_title">Babah!</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> // &lt;<span class="hljs-comment"><span class="hljs-comment">--- !!!!!!! user u on ba.user_id = u.id where u.id = ?</span></span></code> </pre> </div></div><br><p>  "Que diabos!?"  - o desenvolvedor exclama.  Afinal, j√° vimos isso <del>  violinista </del>  <code>join</code> n√£o <code>join</code> necess√°ria. </p><br><p>  O motivo √© prosaico: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JPADATAJPA-729 JUN√á√ÉO EXTERNA desnecess√°ria √© gerada para contar uma √∫nica tabela</a> </li><li><del>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DATAJPA-1238 JUNTA EXTERIOR ESQUERDA desnecess√°ria quando um WHERE poderia ter sido usado</a> </del></li></ul><br><p>  Se voc√™ ainda n√£o fez o upgrade para as vers√µes corrigidas e a uni√£o da tabela diminui a solicita√ß√£o aqui e agora, n√£o se desespere: existem duas maneiras de aliviar a dor: </p><br><ul><li><p>  uma boa maneira √© adicionar <code>optional = false</code> (se o circuito permitir): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, optional = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) User user; }</code> </pre> <br></li><li><p>  A maneira mais importante √© adicionar uma coluna do mesmo tipo que a chave da entidade <code>User</code> e us√°-la em consultas em vez do campo do <code>user</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>) User user; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) Long userId; }</code> </pre> <br><p>  Agora, o request-from-method ser√° melhor: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countByUserId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span></span>;</code> </pre> <br><p>  d√° </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ba.user_id = ?</code> </pre> <br><p>  o que conseguimos? </p><br></li></ul><br><h4 id="ogranichenie-vyborki">  Limite de amostragem </h4><br><p>  Para nossos prop√≥sitos, precisamos limitar a sele√ß√£o (por exemplo, queremos retornar <code>Optional</code> do m√©todo <code>*RepositoryCustom</code> ): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ba.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ba.rate <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> ?</code> </pre> <br><p>  Agora Java: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithHighestRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select b from BankAccount b order by b.rate"</span></span>; BankAccount account = em .createQuery(query, BankAccount.class) .setFirstResult(<span class="hljs-number"><span class="hljs-number">0</span></span>) .setMaxResults(<span class="hljs-number"><span class="hljs-number">1</span></span>) .getSingleResult(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Optional.ofNullable(bankAccount); }</code> </pre> <br><p>  O c√≥digo especificado possui um recurso desagrad√°vel: no caso em que a solicita√ß√£o retornou uma sele√ß√£o vazia, uma exce√ß√£o ser√° lan√ßada </p><br><pre> <code class="plaintext hljs">Caused by: javax.persistence.NoResultException: No entity found for query</code> </pre> <br><p>  Nos projetos que vi, isso foi resolvido de duas maneiras principais: </p><br><ul><li>  try-catch com varia√ß√µes de <code>Optonal.empty()</code> sem exce√ß√£o <code>Optonal.empty()</code> exce√ß√£o e retornar <code>Optonal.empty()</code> para maneiras mais avan√ßadas, como passar um lambda com uma solicita√ß√£o para um m√©todo utilit√°rio </li><li>  aspecto no qual os m√©todos de reposit√≥rio retornam <code>Optional</code> </li></ul><br><p>  E muito raramente, vi a solu√ß√£o certa: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithHighestRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select b from BankAccount b order by b.rate"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.unwrap(Session.class) .createQuery(query, BankAccount.class) .setFirstResult(<span class="hljs-number"><span class="hljs-number">0</span></span>) .setMaxResults(<span class="hljs-number"><span class="hljs-number">1</span></span>) .uniqueResultOptional(); }</code> </pre> <br><p>  <code>EntityManager</code> faz parte do padr√£o JPA, enquanto a <code>Session</code> pertence ao Hibernate e √© IMHO uma ferramenta mais avan√ßada, que geralmente √© esquecida. </p><br><h4 id="inogda-vrednoe-uluchshenie">  [√Äs vezes] melhoria prejudicial </h4><br><p>  Quando voc√™ precisa obter um pequeno campo de uma entidade "grossa", fazemos o seguinte: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select a.available from BankAccount a where a.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findIfAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  A solicita√ß√£o permite que voc√™ obtenha um campo do tipo <code>boolean</code> sem carregar toda a entidade (com a adi√ß√£o de um cache de primeiro n√≠vel, verificando altera√ß√µes no final da sess√£o e outras despesas).  √Äs vezes, isso n√£o apenas n√£o melhora o desempenho, mas vice-versa - ele cria consultas desnecess√°rias do zero.  Imagine um c√≥digo que execute algumas verifica√ß√µes: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount acc = repository.findById(id).orElseThow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return repository.findIfAvailable(id); }</span></span></code> </pre> <br><p>  Esse c√≥digo faz pelo menos 2 solicita√ß√µes, embora a segunda possa ser evitada: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount acc = repository.findById(id).orElseThow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return repository.findById(id) //    .map(BankAccount::isAvailable) .orElseThrow(IllegalStateException::new); }</span></span></code> </pre> <br><p>  A conclus√£o √© simples: n√£o negligencie o cache do primeiro n√≠vel, dentro da estrutura de uma transa√ß√£o, apenas o primeiro <code>JpaRepository::findById</code> se refere ao banco de dados, <code>JpaRepository::findById</code> cache do primeiro n√≠vel est√° sempre <code>JpaRepository::findById</code> e est√° vinculado a uma sess√£o, que geralmente est√° vinculada √† transa√ß√£o atual. </p><br><p>  Testes para jogar (o link para o reposit√≥rio √© fornecido no in√≠cio do artigo): </p><br><ul><li>  teste de interface estreita: <code>InterfaceNarrowingTest</code> </li><li>  teste para um exemplo com uma chave composta: <code>EntityWithCompositeKeyRepositoryTest</code> </li><li>  testar excesso <code>CrudRepository::save</code> : <code>ModifierTest.java</code> </li><li>  teste cego <code>CrudRepository::findById</code> <code>ChildServiceImplTest</code> : <code>ChildServiceImplTest</code> </li><li>  teste de <code>left join</code> desnecess√°rio: <code>BankAccountControlRepositoryTest</code> </li></ul><br><p>  O custo de uma chamada extra para <code>CrudRepository::save</code> pode ser calculado usando <code>RedundantSaveBenchmark</code> .  √â lan√ßado usando a classe <code>BenchmarkRunner</code> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441386/">https://habr.com/ru/post/pt441386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441376/index.html">Al√©m da pureza: o que pode e o que n√£o pode reverter a membrana de osmose</a></li>
<li><a href="../pt441378/index.html">Pesquisadores do Google: para se proteger contra o Spectre requer uma altera√ß√£o na arquitetura do processador, os patches de software n√£o ajudar√£o</a></li>
<li><a href="../pt441380/index.html">7 pontos de crescimento da convers√£o ou como aumentar a clicabilidade dos bot√µes</a></li>
<li><a href="../pt441382/index.html">Cientistas chineses desenvolveram um gerador piezoel√©trico para marcapasso</a></li>
<li><a href="../pt441384/index.html">Impress√£o em massa no Windows</a></li>
<li><a href="../pt441388/index.html">Listras de zebra - √© uma zona de exclus√£o a√©rea para mosquitos</a></li>
<li><a href="../pt441390/index.html">N√£o √© apenas um telefone dobr√°vel: a Samsung atualizou toda a sua linha de dispositivos port√°teis</a></li>
<li><a href="../pt441392/index.html">Fun√ß√µes de CPU RDRAND e RDSEED agora dispon√≠veis</a></li>
<li><a href="../pt441394/index.html">Arte ASCII "aplicada"</a></li>
<li><a href="../pt441398/index.html">Cruzeiro abre c√≥digo fonte da cosmovis√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>