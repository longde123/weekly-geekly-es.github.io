<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüé§ üíÖ üèïÔ∏è Fantas√≠as sobre el tema de las metaclases en C # ‚õµÔ∏è üçì üëù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los programadores como yo, que vinimos a C # con una amplia experiencia en Delphi, a menudo carecen de lo que Delphi se llama referencia de clase y, e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fantas√≠as sobre el tema de las metaclases en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464141/">  Los programadores como yo, que vinimos a C # con una amplia experiencia en Delphi, a menudo carecen de lo que Delphi se llama referencia de clase y, en el trabajo te√≥rico, metaclase.  Varias veces en varios foros me encontr√© con una discusi√≥n que tuvo lugar en la misma l√≠nea.  Comienza con una pregunta de un ex delf√≠n sobre c√≥mo hacer una metaclase en C #.  Los agudos simplemente no entienden el problema, tratando de aclarar qu√© tipo de bestia es esta: una metaclase, los delfines como pueden explicar, pero las explicaciones son cortas e incompletas, y como resultado, los m√°s agudos no saben por qu√© se necesita todo esto.  Despu√©s de todo, se puede hacer lo mismo con la ayuda de f√°bricas de reflexi√≥n y clase. <br><br>  En este art√≠culo, intentar√© decirle qu√© metaclases son para aquellos que nunca los han encontrado.  Adem√°s, que cada uno decida por s√≠ mismo si ser√≠a bueno tener algo as√≠ en el idioma, o si es suficiente reflexi√≥n.  Todo lo que escribo aqu√≠ son solo fantas√≠as sobre c√≥mo podr√≠a haber sido si las metaclases realmente existieran en C #.  Todos los ejemplos en el art√≠culo est√°n escritos en esta versi√≥n hipot√©tica de C #, ni un solo compilador existente en este momento puede compilarlos. <br><a name="habracut"></a><br><h2>  ¬øQu√© es una metaclase? </h2><br>  Entonces, ¬øqu√© es una metaclase?  Este es un tipo especial que sirve para describir otros tipos.  Hay algo muy similar en C #: el tipo Tipo.  Pero solo similar.  Un valor de tipo Tipo puede describir cualquier tipo, una metaclase solo puede describir a los herederos de la clase especificada cuando se declar√≥ la metaclase. <br><br>  Para hacer esto, nuestra versi√≥n hipot√©tica de C # adquiere el tipo Type &lt;T&gt;, que es el sucesor de Type.  Pero el Tipo &lt;T&gt; solo es adecuado para describir el tipo T o sus descendientes. <br>  Explicar√© esto con un ejemplo: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A2</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); <span class="hljs-comment"><span class="hljs-comment">//   ta = typeof(A2); //    ta = typeof(B); //   ‚Äì Type&lt;B&gt;   Type&lt;A&gt; ta = (Type&lt;A&gt;)typeof(B); //      -   Type tx = typeof(A); ta = tx; //   ‚Äì    Type  Type&lt;A&gt; ta = (Type&lt;A&gt;)tx; //    Type&lt;B&gt; tb = (Type&lt;B&gt;)tx; //  } }</span></span></code> </pre> <br>  El ejemplo anterior es el primer paso para la aparici√≥n de metaclases.  Tipo Tipo &lt;T&gt; le permite restringir qu√© tipos pueden ser descritos por los valores correspondientes.  Esta caracter√≠stica puede resultar √∫til en s√≠ misma, pero las posibilidades de las metaclases no se limitan a esto. <br><br><h2>  Metaclases y miembros de clase est√°tica </h2><br>  Si alguna clase X tiene miembros est√°ticos, la metaclase Tipo &lt;X&gt; obtiene miembros similares, ya no est√°ticos, a trav√©s de los cuales puede acceder a los miembros est√°ticos de X. Expliquemos esta frase confusa con un ejemplo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.DoSomething(); <span class="hljs-comment"><span class="hljs-comment">//   ,     X.DoSomething(); } }</span></span></code> </pre><br>  <i>Aqu√≠, en t√©rminos generales, surge la pregunta: ¬øqu√© sucede si en la clase X se declara un m√©todo est√°tico, cuyo nombre y conjunto de par√°metros coincide con el nombre y el conjunto de par√°metros de uno de los m√©todos de la clase Type, cuyo heredero es Type &lt;X&gt;?</i>  <i>Hay varias opciones bastante simples para resolver este problema, pero no me detendr√© en ellas: por simplicidad, creemos que en nuestro lenguaje fant√°stico de conflictos no hay nombres m√°gicos.</i> <br><br>  El c√≥digo anterior para cualquier persona normal deber√≠a ser desconcertante: ¬øpor qu√© necesitamos una variable para llamar a un m√©todo si podemos llamar a este m√©todo directamente?  De hecho, en esta forma, esta oportunidad es in√∫til.  Pero el beneficio viene cuando le agregas m√©todos de clase. <br><br><h2>  M√©todos de clase </h2><br>  Los m√©todos de clase son otra construcci√≥n que tiene Delphi, pero falta en C #.  Cuando se declaran, estos m√©todos se marcan con la clase de palabra y son un cruce entre los m√©todos est√°ticos y los m√©todos de instancia.  Al igual que los m√©todos est√°ticos, no est√°n vinculados a una instancia espec√≠fica y pueden llamarse a trav√©s del nombre de la clase sin crear una instancia.  Pero, a diferencia de los m√©todos est√°ticos, tienen un par√°metro impl√≠cito esto.  Solo esto en este caso no es una instancia de la clase, sino una metaclase, es decir  si el m√©todo de clase se describe en la clase X, entonces este par√°metro ser√° del tipo Tipo &lt;X&gt;.  Y puedes usarlo as√≠: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> class </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine($‚Äù    {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name}‚Äù); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : ¬´    X¬ª Y.Report() // : ¬´    Y¬ª } }</span></span></code> </pre><br>  Esta caracter√≠stica no es muy impresionante hasta ahora.  Pero gracias a √©l, los m√©todos de clase, a diferencia de los m√©todos est√°ticos, pueden ser virtuales.  M√°s precisamente, los m√©todos est√°ticos tambi√©n podr√≠an hacerse virtuales, pero no est√° claro qu√© hacer a continuaci√≥n con esta virtualidad.  Pero con los m√©todos de clase, tales problemas no surgen.  Considere esto con un ejemplo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(‚Äú!‚Äù); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DoReport(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(‚Äú!‚Äù); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : ¬´!¬ª Y.Report() // : ??? } }</span></span></code> </pre><br>  Por la l√≥gica de las cosas, cuando se llama Y.Report, se debe mostrar "Bye!".  Pero el m√©todo X.Report no tiene informaci√≥n sobre la clase desde la que se llam√≥, por lo que no puede elegir din√°micamente entre X.DoReport e Y.DoReport.  Como resultado, X.Report siempre llamar√° a X.DoReport, incluso si se llam√≥ a Report a trav√©s de Y. No tiene sentido hacer que el m√©todo DoReport sea virtual.  Por lo tanto, C # no permite que los m√©todos est√°ticos sean virtuales: ser√≠a posible hacerlo virtual, pero no podr√° beneficiarse de su virtualidad. <br><br>  Otra cosa son los m√©todos de clase.  Si Informe en el ejemplo anterior no fuera est√°tico, sino de clase, "sabr√≠a" cu√°ndo se llam√≥ a trav√©s de X y cu√°ndo a trav√©s de Y. En consecuencia, el compilador podr√≠a generar c√≥digo que seleccionar√≠a el DoReport deseado, y se generar√≠a una llamada a Y.Report a la conclusi√≥n "¬°Adi√≥s!". <br><br>  Esta caracter√≠stica es √∫til en s√≠ misma, pero se vuelve a√∫n m√°s √∫til si le agrega la capacidad de llamar a las variables de clase a trav√©s de metaclases.  Algo como esto: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(‚Äú!‚Äù); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(‚Äú!‚Äù); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.Report() <span class="hljs-comment"><span class="hljs-comment">// : ¬´!¬ª tx = typeof(Y); tx.Report() // : ¬´!¬ª } }</span></span></code> </pre><br>  Para lograr tal polimorfismo sin metaclases y m√©todos de clase virtual, para la clase X y cada uno de sus descendientes tendr√≠a que escribir una clase auxiliar con el m√©todo virtual habitual.  Esto requiere un esfuerzo significativamente mayor, y el control por parte del compilador no ser√° tan completo, lo que aumenta la probabilidad de cometer un error en alguna parte.  Mientras tanto, se encuentran situaciones en las que se necesita polimorfismo a nivel de tipo, y no a nivel de instancia, y si el lenguaje admite dicho polimorfismo, esta es una propiedad muy √∫til. <br><br><h2>  Constructores virtuales </h2><br>  Si las metaclases aparecieron en el lenguaje, entonces se les debe agregar constructores virtuales.  Si un constructor virtual se declara en una clase, todos sus descendientes deben superponerse, es decir,  tener su propio constructor con el mismo conjunto de par√°metros, por ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ... } }</code> </pre><br>  En este c√≥digo, la clase C no debe compilarse, ya que no tiene un constructor con par√°metros int x, int y, pero la clase B se compila sin errores. <br><br>  <i>Otra opci√≥n es posible: si el constructor virtual del antepasado no se superpone en el heredero, el compilador se superpone autom√°ticamente, al igual que ahora crea autom√°ticamente el constructor predeterminado.</i>  <i>Ambos enfoques tienen ventajas y desventajas obvias, pero esto no es importante para el panorama general.</i> <br><br>  Se puede usar un constructor virtual donde sea que se pueda usar un constructor regular.  Adem√°s, si la clase tiene un constructor virtual, su metaclase tiene un m√©todo CreateInstance con el mismo conjunto de par√°metros que el constructor, y este m√©todo crear√° una instancia de la clase, como se muestra en el siguiente ejemplo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); A a1 = ta.CreateInstance(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    A ta = typeof(B); A a2 = ta.CreateInstance(2, 7); //    B } }</span></span></code> </pre><br>  En otras palabras, tenemos la oportunidad de crear objetos cuyo tipo se determina en tiempo de ejecuci√≥n.  Ahora esto tambi√©n se puede hacer usando Activator.CreateInstance.  Pero este m√©todo funciona a trav√©s de la reflexi√≥n, por lo que la correcci√≥n del conjunto de par√°metros se verifica solo en la etapa de ejecuci√≥n.  Pero si tenemos metaclases, entonces el c√≥digo con los par√°metros incorrectos simplemente no se compilar√°.  Adem√°s, cuando se usa la reflexi√≥n, la velocidad del trabajo deja mucho que desear, y las metaclases le permiten minimizar los costos. <br><br><h2>  Conclusi√≥n </h2><br>  Siempre me sorprendi√≥ por qu√© Halesberg, que es el desarrollador principal de Delphi y C #, no hizo metaclases en C #, aunque demostraron ser tan buenos en Delphi.  Quiz√°s el punto es que en Delphi (en esas versiones que hizo Halesberg) casi no hay reflexi√≥n, y simplemente no hay alternativa a las metaclases, lo que no se puede decir sobre C #.  De hecho, todos los ejemplos de este art√≠culo no son tan dif√≠ciles de rehacer, utilizando solo aquellas herramientas que ya est√°n en el idioma.  Pero todo esto funcionar√° notablemente m√°s lento de lo que podr√≠a hacerlo con metaclases, y la correcci√≥n de las llamadas se verificar√° en tiempo de ejecuci√≥n, no en compilaci√≥n.  Entonces, mi opini√≥n personal es que C # se beneficiar√≠a enormemente si aparecieran metaclases en √©l. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464141/">https://habr.com/ru/post/464141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464127/index.html">Desarrollo de favicons animados.</a></li>
<li><a href="../464129/index.html">Innovaciones de JavaScript: resultados de Google I / O 2019. Parte 1</a></li>
<li><a href="../464131/index.html">Innovaciones de JavaScript: resultados de Google I / O 2019. Parte 2</a></li>
<li><a href="../464133/index.html">El rendimiento no se trata solo de CPU: crear sus propios perfiladores para Python</a></li>
<li><a href="../464137/index.html">Soporte t√©cnico Miran: c√≥mo funciona</a></li>
<li><a href="../464143/index.html">Cura personal contra el c√°ncer. C√≥mo los genes del paciente afectan el √©xito del tratamiento</a></li>
<li><a href="../464145/index.html">CMake: el caso cuando la calidad del proyecto es imperdonable</a></li>
<li><a href="../464147/index.html">CMake: el caso cuando el proyecto es imperdonable la calidad de su c√≥digo</a></li>
<li><a href="../464149/index.html">La historia de un monolito.</a></li>
<li><a href="../464151/index.html">Victor Vyalichkin: "Libertad, igualdad, fraternidad est√°n solo en OpenStreetMap, donde todo est√° siempre a la vista"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>