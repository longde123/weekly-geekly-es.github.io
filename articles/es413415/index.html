<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游깷 游낗 游닖 L칤mites de concurrencia adaptativa en Netflix 游늳 游낇 咎왪잺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Netflix est치 obsesionado con la disponibilidad del servicio. Ya lo hemos revisado en nuestro blog m치s de una vez y contamos c칩mo logramos alcanzar nue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L칤mites de concurrencia adaptativa en Netflix</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/413415/"><img src="https://habrastorage.org/webt/1f/9m/do/1f9mdoden4f5g0saek8572vqzk8.png"><br><br>  Netflix est치 obsesionado con la disponibilidad del servicio.  Ya lo hemos revisado en nuestro blog m치s de una vez y contamos c칩mo logramos alcanzar nuestros objetivos.  Utilizamos disyuntores, l칤mites de concurrencia, pruebas de caos y m치s.  Hoy le presentamos otro enfoque innovador que aumenta significativamente la estabilidad de la aplicaci칩n bajo cargas extremas y evita fallas en el servicio en cascada: l칤mites adaptativos para conexiones paralelas.  No se necesita m치s esfuerzo para determinar los l칤mites de las conexiones paralelas, lo que permite que el sistema mantenga un tiempo de respuesta corto.  Como parte de este anuncio, tambi칠n publicaremos en el dominio p칰blico una biblioteca Java simple con capacidades de integraci칩n para servlets, programas de control y gRPC. <br><a name="habracut"></a><br><h4>  Comencemos con lo b치sico </h4><br>  El l칤mite de conexiones paralelas es el n칰mero m치ximo de solicitudes que el sistema puede procesar en un determinado momento.  Por lo general, esta cantidad depende de un recurso limitado, como la potencia de procesamiento del procesador central.  Por lo general, el l칤mite de conexiones paralelas del sistema se calcula de acuerdo con la ley de Little, que suena as칤: para un sistema estable, el n칰mero m치ximo de conexiones paralelas es igual al producto del tiempo promedio dedicado a procesar la solicitud y la intensidad promedio de las solicitudes entrantes (L = 풭W).  Cualquier solicitud que exceda el l칤mite de conexi칩n paralela no puede ser procesada inmediatamente por el sistema, por lo que ser치 puesta en cola o rechazada.  La puesta en cola es una funci칩n importante que le permite utilizar completamente el sistema en los casos en que las solicitudes se reciben de manera desigual y requieren un tiempo diferente para procesar. <br><br><img src="https://habrastorage.org/webt/rt/xg/jc/rtxgjcvizrzpe0rffihujn_tfxq.png"><br><br>  Si no hay l칤mite para la cola, se puede producir un bloqueo del sistema, por ejemplo, si durante mucho tiempo la intensidad de las solicitudes es mayor que la velocidad de su procesamiento.  A medida que crece la cola, tambi칠n lo hace el retraso, lo que lleva a exceder el tiempo de espera para las solicitudes.  Esto contin칰a hasta que se agote la memoria libre, despu칠s de lo cual el sistema se bloquea.  Si no realiza un seguimiento del creciente tiempo de retraso, comenzar치 a afectar negativamente a los servicios de llamadas y provocar치 fallas en el sistema en cascada. <br><br><img src="https://habrastorage.org/webt/so/wn/io/sowniojbjfektwb7esft-yaqham.png"><br><br>  El uso de l칤mites de conexi칩n en paralelo es una pr치ctica est치ndar, pero la dificultad radica en determinarlos para grandes sistemas din치micos distribuidos, donde par치metros tales como el tiempo de retardo y la posible cantidad de conexiones en paralelo cambian constantemente.  La esencia de nuestra soluci칩n es la capacidad de determinar din치micamente el l칤mite de las conexiones paralelas.  Este l칤mite puede representarse como el n칰mero de solicitudes entrantes (ejecutadas en paralelo y en cola) que el sistema puede procesar hasta que su rendimiento comience a disminuir (y aumente el tiempo de retraso). <br><br><h4>  Soluci칩n </h4><br>  Anteriormente, los empleados de Netflix determinaron los l칤mites de conexi칩n simult치nea manual a trav칠s de pruebas de rendimiento y perfiles que requieren mucho tiempo.  El n칰mero resultante fue correcto para un per칤odo de tiempo espec칤fico, pero pronto la topolog칤a del sistema comenz칩 a cambiar debido a fallas parciales, escalado autom치tico o la introducci칩n de c칩digo adicional que afect칩 el tiempo de retraso.  Como resultado, el l칤mite est치 desactualizado.  Sab칤amos que 칠ramos capaces de m치s, que ya no nos bastaba con determinar los l칤mites de conexi칩n de forma est치tica.  Necesit치bamos una forma de determinar autom치ticamente los l칤mites inherentes al sistema mismo.  Al mismo tiempo, quer칤amos este m칠todo: <br><br><ol><li>  no requiri칩 trabajo manual; <br></li><li>  no requiri칩 coordinaci칩n central; <br></li><li>  podr칤a determinar el l칤mite sin ninguna informaci칩n sobre el hardware o la topolog칤a del sistema; <br></li><li>  Adaptado a los cambios en la topolog칤a del sistema; <br></li><li>  fue simple en t칠rminos de implementaci칩n y los c치lculos necesarios. <br></li></ol><br>  Para resolver este problema, recurrimos al probado algoritmo de seguimiento de congesti칩n TCP.  Este algoritmo determina la cantidad de paquetes de datos que se pueden transmitir en paralelo (es decir, el tama침o de la ventana de desbordamiento) sin aumentar el tiempo de retraso o exceder el tiempo de espera.  Estos algoritmos utilizan varios indicadores para determinar el l칤mite de paquetes transmitidos simult치neamente y para cambiar el tama침o de la ventana de desbordamiento en consecuencia. <br><br><img src="https://habrastorage.org/webt/f-/ox/jo/f-oxjo0ds0ieqwv7flct4g5ntb8.png"><br><br>  El color azul en la imagen muestra el l칤mite desconocido para conexiones paralelas al sistema.  Primero, el cliente env칤a una peque침a cantidad de solicitudes concurrentes, y luego comienza a verificar peri칩dicamente el sistema para ver si puede manejar m치s solicitudes aumentando la ventana de desbordamiento hasta que esto provoque un aumento en el retraso.  Cuando el retraso a칰n aumenta, el remitente decide que ha alcanzado el l칤mite y nuevamente reduce el tama침o de la ventana de desbordamiento.  Dicha prueba continua del l칤mite se refleja en el gr치fico que ve arriba. <br><br>  Nuestro algoritmo se basa en el algoritmo de seguimiento de congesti칩n en el protocolo TCP, que considera la relaci칩n entre el tiempo de retraso m칤nimo (el mejor escenario posible en el que no se utiliza la cola) y el tiempo de retraso, que se mide peri칩dicamente a medida que se ejecutan las solicitudes.  Esta relaci칩n permite determinar que se ha formado una cola que provoca un aumento en el retraso.  Esta relaci칩n nos da el gradiente o la magnitud del cambio de tiempo de retraso: <i>gradiente = (RTTnoload / RTTactual)</i> .  Si el valor es igual a uno, entendemos que no hay cola y el l칤mite puede aumentarse.  Un valor menor que uno indica que la cola est치 llena y que el l칤mite debe reducirse.  Con cada nueva medici칩n del tiempo de retraso, el l칤mite se ajusta en funci칩n de la relaci칩n anterior, y con ello el tama침o de cola permitido cambia de acuerdo con esta f칩rmula simple: <br><br><pre><code class="hljs">_ = _ 칑  + _</code> </pre> <br>  Para varias iteraciones, el algoritmo calcula un l칤mite que permite no solo mantener el tiempo de retraso en un nivel bajo, sino tambi칠n formar la cola de solicitudes necesaria en caso de brotes de actividad.  El tama침o de cola v치lido se puede configurar.  Se utiliza para determinar qu칠 tan r치pido puede aumentar el l칤mite de concurrencia.  Como tama침o predeterminado, elegimos la ra칤z cuadrada del valor l칤mite actual.  Esta elecci칩n se debe a la propiedad 칰til de la ra칤z cuadrada: a valores peque침os, ser치 lo suficientemente grande en comparaci칩n con el l칤mite para garantizar un crecimiento r치pido, pero a valores grandes, por el contrario, su valor relativo ser치 menor, lo que aumentar치 la estabilidad del sistema. <br><br><h4>  L칤mites adaptativos en acci칩n </h4><br>  Los l칤mites adaptativos en el lado del servidor rechazan las solicitudes excesivas y mantienen una latencia baja, lo que permite que la instancia del sistema se proteja a s칤 misma y a los servicios de los que depende.  Anteriormente, cuando no era posible rechazar solicitudes excesivas, cualquier aumento constante en el n칰mero de solicitudes por segundo o el tiempo de retraso conduc칤a a un aumento a칰n mayor en este tiempo y, en 칰ltima instancia, a la ca칤da de todo el sistema.  Hoy en d칤a, los servicios pueden eliminar cargas de trabajo innecesarias y mantener una baja latencia mientras trabajan con otras herramientas de estabilizaci칩n, como el escalado autom치tico. <br><br><img src="https://habrastorage.org/webt/zh/vp/zx/zhvpzxo9x0fp_pb_ckdcf9plhks.png"><br><br>  Es importante recordar que los l칤mites se establecen a nivel del servidor (y sin ninguna coordinaci칩n), que el tr치fico a cada servidor puede caer y aumentar considerablemente.  Por lo tanto, no es sorprendente que el l칤mite detectado y el n칰mero de conexiones concurrentes puedan ser diferentes seg칰n el servidor.  Esto es especialmente cierto en un entorno de nube multicliente.  Como resultado, puede surgir una situaci칩n cuando un servidor est치 sobrecargado, aunque el resto ser치 gratuito.  Al mismo tiempo, al equilibrar la carga en el lado del cliente, solo una solicitud repetida llegar치 al servidor con recursos gratuitos en casi el 100% de los casos.  Y eso no es todo: no hay m치s motivos para preocuparse de que las solicitudes repetidas provoquen un ataque DDOS, ya que los servicios pueden rechazar r치pidamente (en menos de un milisegundo) el tr치fico con un impacto m칤nimo en el rendimiento. <br><br><h4>  Conclusi칩n </h4><br>  El uso de l칤mites adaptativos para conexiones paralelas elimina la necesidad de determinar manualmente c칩mo y en qu칠 casos nuestros servicios deber칤an rechazar el tr치fico.  Adem치s, tambi칠n aumenta la fiabilidad general y la disponibilidad de todo nuestro ecosistema de microservicios. <br><br>  Nos complace compartir con usted nuestros m칠todos de implementaci칩n y la integraci칩n general de esta soluci칩n, que puede encontrar en la biblioteca p칰blica en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/Netflix/concurrency-limits</a> .  Esperamos que nuestro c칩digo ayude a los usuarios a proteger sus servicios de fallas en cascada y problemas con el aumento de la latencia, as칤 como a aumentar su disponibilidad. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413415/">https://habr.com/ru/post/es413415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413405/index.html">Los mejores libros, art칤culos y recursos para productos para principiantes: los autores de los canales de productos Telegram aconsejan</a></li>
<li><a href="../es413407/index.html">M칠todos de atribuci칩n en rastreadores populares: coincidencia de ID de dispositivo, referencia de instalaci칩n y huella digital</a></li>
<li><a href="../es413409/index.html">Kubernetes de Amazon (EKS) hecho p칰blico</a></li>
<li><a href="../es413411/index.html">Monitoreamos sesiones activas de PostgreSQL 10, como en Oracle</a></li>
<li><a href="../es413413/index.html">Descripci칩n general del componente Symfony: Config</a></li>
<li><a href="../es413417/index.html">Eficiencia energ칠tica: los enfoques que probamos en Rusia</a></li>
<li><a href="../es413419/index.html">Resumen de noticias de PostgreSQL. Edici칩n No. 7</a></li>
<li><a href="../es413421/index.html">Posibles incertidumbres en la carrera de un programador</a></li>
<li><a href="../es413423/index.html">Soluciones de acceso remoto en Mars IS</a></li>
<li><a href="../es413427/index.html">Programaci칩n para ingenieros de redes: trabajar con la configuraci칩n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>