<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏾 ⌚️ 🌵 Plus de fonctionnalités avec des modèles dans C # 8.0 🎿 👃🏾 👩🏿‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Plus récemment, Visual Studio 2019 Preview 2 est sorti et avec lui, quelques fonctionnalités supplémentaires de C # 8.0 sont prêtes à être essayées. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plus de fonctionnalités avec des modèles dans C # 8.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/440530/"><p>  Plus récemment, Visual Studio 2019 Preview 2 est sorti et avec lui, quelques fonctionnalités supplémentaires de C # 8.0 sont prêtes à être essayées.  Il s'agit principalement d'une comparaison avec l'échantillon, bien qu'à la fin je vais aborder quelques autres nouvelles et modifications. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cet article est en anglais.</a> </p><br><img src="https://habrastorage.org/webt/_p/dm/49/_pdm493ww_lspasjjtw5abi-eoa.jpeg"><a name="habracut"></a><br><br>  Merci d'avoir traduit notre MSP, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lev Bulanov</a> . <br><br><h2></h2><p>  Plus de modèles dans plus d'endroits </p><br><p>  Lorsque la correspondance de modèles est apparue dans C # 7.0, nous avons noté qu'une augmentation du nombre de modèles dans plus d'endroits était attendue à l'avenir.  Cette fois est venue!  Nous ajoutons ce que nous appelons des modèles récursifs, ainsi qu'une forme plus compacte d'expressions de <strong>commutateur</strong> appelées (vous l'avez deviné) des expressions de commutateur. </p><br><p>  Pour commencer, voici un exemple simple de modèles C # 7.0: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Point</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; (X, Y) = (x, y); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; (x, y) = (X, Y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>; } }</code> </pre> <br><p></p><h2>  Changer d'expressions </h2><br><p>  Tout d'abord, notez que de nombreuses expressions de <strong>commutateur</strong> , en fait, ne font pas beaucoup de travail intéressant dans les corps de <strong>cas</strong> .  Souvent, tous créent simplement une valeur, soit en l'affectant à une variable, soit en la renvoyant (comme indiqué ci-dessus).  Dans toutes ces situations, l'interrupteur semble être hors de propos.  Ceci est similaire à une fonction de langue vieille de cinquante ans. </p><br><p>  Nous avons décidé qu'il était temps d'ajouter un formulaire de <strong>déclaration de changement</strong> .  Cela s'applique à l'exemple ci-dessous: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> }; }</code> </pre> <br><p>  Il y a quelques choses qui ont changé par rapport aux instructions switch.  Énumérons-les: </p><br><ul><li>  Le mot-clé <strong>switch</strong> est "infixe" entre la valeur testée et la liste des <strong>{...}</strong> cas.  Cela le rend plus compositionnel avec d'autres expressions, et aussi plus facile à distinguer visuellement de l'instruction switch. </li><li>  Le mot clé et le symbole <strong>case</strong> : ont été remplacés par la flèche lambda <strong>=&gt;</strong> pour faire court. </li><li>  <strong>La valeur par défaut</strong> pour la brièveté a été remplacée par le modèle de réinitialisation <strong>_</strong> . </li><li>  Les corps sont des expressions.  Le résultat du corps sélectionné devient le résultat de l'instruction switch. </li></ul><br><p>  Parce que l'expression doit compter ou lever une exception, une expression de sélection qui se termine sans correspondance lèvera une exception.  Le compilateur vous avertira lorsque cela peut se produire, mais il ne vous forcera pas à terminer toutes les instructions select avec la fonction catch-all. </p><br><p>  Puisque notre méthode <strong>Display</strong> consiste désormais en une seule instruction return, nous pouvons la simplifier pour l'expression: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  Quelles que soient les recommandations de mise en forme, elles doivent être extrêmement claires et concises.  Brevity vous permet de formater le commutateur de manière "tabulaire", comme décrit ci-dessus, avec des motifs et un corps sur la même ligne, et <strong>=&gt;</strong> alignés les uns sous les autres. </p><br><p>  Soit dit en passant, nous prévoyons d'autoriser l'utilisation d'une virgule après le dernier cas conformément à toutes les autres "listes séparées par des virgules entre crochets" en C #, mais cela n'est pas encore autorisé dans l'aperçu 2. </p><br><h2></h2><p>  Propriétés du motif </p><br><p>  En parlant de brièveté, les motifs deviennent soudain les éléments les plus difficiles des expressions de choix.  Faisons quelque chose. </p><br><p>  Notez que l'expression de sélection utilise un modèle de type <strong>Point p</strong> (deux fois), ainsi que <strong>quand</strong> ajouter des conditions supplémentaires dans le premier <strong>cas</strong> . </p><br><p>  Dans C # 8.0, nous ajoutons des éléments facultatifs supplémentaires au type de modèles, ce qui permet au modèle lui-même d'aller plus loin dans la valeur qui correspond au modèle.  Vous pouvez en faire un modèle de propriété en ajoutant <strong>{...}</strong> contenant des modèles imbriqués, en appliquant des valeurs aux propriétés ou aux champs disponibles.  Cela nous permet de réécrire l'expression du commutateur comme suit: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } p =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, Y: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y } p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  Les deux cas vérifient toujours que <strong>o</strong> est <strong>Point</strong> .  Dans le premier cas, le motif de la constante <strong>0 est</strong> récursivement appliqué aux propriétés <strong>X</strong> et <strong>Y de la</strong> variable <strong>p</strong> , vérifiant si elles ont cette valeur.  Ainsi, nous pouvons éliminer la condition <strong>quand</strong> dans ce cas et dans d'autres cas similaires. </p><br><p>  Dans le second cas, le motif <strong>var</strong> est appliqué à chacun de <strong>X</strong> et <strong>Y.</strong>  Rappelez-vous que le modèle <strong>var</strong> en C # 7.0 réussit toujours et déclare simplement une nouvelle variable pour contenir la valeur.  Donc, <strong>x</strong> et <strong>y</strong> contiennent des valeurs int pour <strong>pX</strong> et <strong>pY</strong> . </p><br><p>  Nous n'utilisons jamais <strong>p</strong> et pouvons le sauter ici: </p><br><pre> <code class="cs hljs"> Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, Y: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y } =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span></code> </pre> <br><p>  Une chose reste la même pour tous les types de modèles, y compris les modèles de propriété, c'est une exigence que la valeur soit non nulle.  Cela ouvre la possibilité d'utiliser le modèle de propriétés "vide" <strong>{}</strong> comme un modèle compact "non nul".  Par exemple.  nous pourrions remplacer la solution de repli par les deux cas suivants: </p><br><pre> <code class="cs hljs"> {} =&gt; o.ToString(), <span class="hljs-literal"><span class="hljs-literal">null</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"null"</span></span></code> </pre> <br><p>  <strong>{}</strong> Traite les autres objets non nuls et <strong>null</strong> obtient des zéros, donc le commutateur est exhaustif et le compilateur ne se plaindra pas des valeurs manquantes. </p><br><h2></h2><p>  Modèles de position </p><br><p>  Le modèle de propriété ne raccourcit pas le deuxième cas de <strong>point.</strong>  Vous n'avez pas à vous en préoccuper, vous pouvez faire encore plus. </p><br><p>  Notez que la classe <strong>Point</strong> a une méthode <strong>Deconstruct</strong> , le soi-disant déconstructeur.  Dans C # 7.0, les déconstructeurs vous permettent de "déconstruire" une valeur lorsqu'ils sont attribués, vous pouvez donc écrire, par exemple: </p><br><pre> <code class="cs hljs">(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">// split up the Point according to its deconstructor</span></span></code> </pre> <br><p>  C # 7.0 n'a pas intégré la déconstruction aux motifs.  Cela change avec les modèles de position, qui sont un moyen supplémentaire d'étendre les types de modèles dans C # 8.0.  Si le type correspondant est un type de tuple ou a un déconstructeur, nous pouvons utiliser des modèles de position comme un moyen compact d'appliquer des modèles récursifs sans avoir à nommer les propriétés: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y) =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  Après avoir fait correspondre l'objet à <strong>Point</strong> , le déconstructeur est appliqué et les motifs imbriqués sont appliqués aux valeurs résultantes. </p><br><p>  Les déconstructeurs ne sont pas toujours appropriés.  Ils doivent être ajoutés uniquement aux types où il est vraiment clair laquelle des valeurs est laquelle.  Par exemple, pour la classe <strong>Point</strong> , vous pouvez supposer que la première valeur est <strong>X</strong> et la seconde est <strong>Y</strong> , de sorte que l'expression de commutateur ci-dessus est claire et facile à lire. </p><br><h2></h2><p>  Modèles de tuple </p><br><p>  Un cas particulier très utile des modèles de position est leur application aux tuples.  Si l'instruction switch est appliquée directement à l'expression de tuple, nous permettons même d'omettre l'ensemble supplémentaire de parenthèses, comme dans <strong>switch (x, y, z)</strong> au lieu de <strong>switch ((x, y, z))</strong> . </p><br><p>  Les modèles de tuple sont parfaits pour tester plusieurs entrées en même temps.  Voici une implémentation simple de la machine d'état: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey</span></span></span><span class="hljs-function">)</span></span> =&gt; (current, transition) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close) =&gt; Closed, (Closed, Open) =&gt; Opened, (Closed, Lock) when hasKey =&gt; Locked, (Locked, Unlock) when hasKey =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"Invalid transition"</span></span>) };</code> </pre> <br><p>  Bien sûr, nous pourrions inclure <strong>hasKey</strong> dans le tuple au lieu d'utiliser des clauses <strong>when</strong> - c'est une question de goût: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey</span></span></span><span class="hljs-function">)</span></span> =&gt; (current, transition, hasKey) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close, _) =&gt; Closed, (Closed, Open, _) =&gt; Opened, (Closed, Lock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Locked, (Locked, Unlock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"Invalid transition"</span></span>) };</code> </pre> <br><p>  En général, vous voyez que les modèles récursifs et les expressions de commutateur peuvent conduire à une logique de programme plus claire et plus déclarative. </p><br><h2></h2><p>  Autres fonctionnalités de C # 8.0 dans l'aperçu 2 </p><br><p>  Malgré le fait que dans VS 2019 Preview 2, les fonctions principales pour travailler avec des motifs sont les plus importantes, il y en a plusieurs plus petites que j'espère que vous trouverez également utiles et intéressantes.  Je n'entrerai pas dans les détails, donnez juste une brève description de chacun. </p><br><h4></h4><p>  Utilisation d'annonces </p><br><p>  En <strong>utilisant</strong> C # <strong>, les</strong> opérateurs augmentent toujours le niveau d'imbrication, ce qui peut être très ennuyeux et de mauvaise lisibilité.  Dans les cas simples, lorsque vous avez juste besoin d'effacer la ressource à la fin de la portée, des déclarations sont utilisées.  Les déclarations <strong>using</strong> sont simplement des déclarations de variables locales avec le mot-clé <strong>using</strong> devant elles, et leur contenu est placé à la fin du bloc d'instructions en cours.  Par conséquent, au lieu de: </p><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = Parse(args)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } ... } <span class="hljs-comment"><span class="hljs-comment">// options disposed here }</span></span></code> </pre> <br><p>  Vous pouvez simplement écrire </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = Parse(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">// options disposed here</span></span></code> </pre> <br><h4></h4><p>  Structures de référence jetables </p><br><p>  Les structures de référence ont été introduites dans C # 7.2, et il ne semble pas y avoir de place pour les répéter ici.  Mais tout de même, il convient de noter quelque chose: ils ont certaines limites, comme l'impossibilité d'implémenter des interfaces.  Les structures de référence peuvent désormais être utilisées sans implémenter l'interface <strong>IDisposable</strong> , en utilisant simplement la méthode <strong>Dispose</strong> . </p><br><h4></h4><p>  Fonctions locales statiques </p><br><p>  Si vous voulez vous assurer que votre fonction locale n'entraîne pas de coûts d'exécution associés à la «capture» (référencement) des variables de la portée, vous pouvez la déclarer statique.  Ensuite, le compilateur empêchera le lien vers tout ce qui est déclaré dans les fonctions englobantes - à l'exception des autres fonctions locales statiques! </p><br><h4></h4><p>  Modifications de l'aperçu 1 </p><br><p>  Les principales fonctions de l'aperçu 1 étaient des types de référence annulables et des flux asynchrones.  Les deux fonctionnalités ont un peu changé dans l'aperçu 2, donc si vous avez commencé à les utiliser, il est utile de connaître les éléments suivants. </p><br><h4></h4><p>  Types de référence nullables </p><br><p>  Nous avons ajouté plus d'options pour gérer les avertissements annulables à la fois à la source (via les directives d' <strong>avertissement</strong> <strong>#nullable</strong> et <strong>#pragma</strong> ) et au niveau du projet.  Nous avons également changé l'abonnement au fichier de projet en <strong>&lt;NullableContextOptions&gt; activer &lt;/ NullableContextOptions&gt;</strong> . </p><br><h4></h4><p>  Threads asynchrones </p><br><p>  Nous avons changé la forme de l' <strong>interface IAsyncEnumerable &lt;T&gt; que le</strong> compilateur attend.  Cela conduit au fait que le compilateur ne se synchronise pas avec l'interface fournie dans .NET Core 3.0 Preview 1, ce qui peut provoquer certains problèmes.  Cependant, .NET Core 3.0 Preview 2 sera bientôt publié et cela renverra la synchronisation. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440530/">https://habr.com/ru/post/fr440530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440520/index.html">Comment obtenir la certification Google Developers: spécialiste Web mobile</a></li>
<li><a href="../fr440522/index.html">Expérience dans la mise en œuvre d'un PBX virtuel. Communication et logiciels dans différents paniers</a></li>
<li><a href="../fr440524/index.html">Écrasement ou réducteurs de niveau 80: le chemin du switch-case aux classes</a></li>
<li><a href="../fr440526/index.html">Une ville japonaise se tourne vers la technologie numérique après une importante dérive de neige</a></li>
<li><a href="../fr440528/index.html">"Montrez-moi vos baskets et je vous dirai qui vous êtes": nouveau podcast sur des projets médiatiques thématiques</a></li>
<li><a href="../fr440534/index.html">Traduction d'un vocabulaire politiquement correct de l'anglais vers le russe</a></li>
<li><a href="../fr440536/index.html">Comment Facebook Project Infer aide à trouver des bogues dans les applications mobiles avant le déploiement</a></li>
<li><a href="../fr440540/index.html">La capitalisation de Reddit a atteint 3 milliards de dollars après avoir attiré des investissements de 300 millions de dollars</a></li>
<li><a href="../fr440542/index.html">Vuex - utilisation excessive de getters dans l'application. Erreur d'analyse</a></li>
<li><a href="../fr440544/index.html">La version expérimentale de Blazor 0.8.0 est maintenant disponible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>