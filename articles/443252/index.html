<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèª üßù üöò Hormigas modulares con memoria üë©üèº‚Äçüíº üïã üë®üèæ‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uno de los proyectos que siempre hab√≠a so√±ado implementar era los bots de tareas modulares con memoria. El objetivo final del proyecto era crear un mu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hormigas modulares con memoria</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443252/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/nt/w1/te/ntw1telvkd_gywv-7drpcook6ua.gif"></div><br>  Uno de los proyectos que siempre hab√≠a so√±ado implementar era los bots de tareas modulares con memoria.  El objetivo final del proyecto era crear un mundo con criaturas capaces de actuar de forma independiente y colectiva. <br><br>  Sol√≠a ‚Äã‚Äãprogramar generadores mundiales, as√≠ que quer√≠a poblar el mundo con bots simples que usan IA para determinar su comportamiento e interacciones.  Por lo tanto, gracias a la influencia de los actores en el mundo, fue posible aumentar sus detalles. <br><br>  Ya implement√© el sistema b√°sico de canalizaci√≥n de tareas de Javascript (porque simplific√≥ mi vida), pero quer√≠a algo m√°s confiable y escalable, as√≠ que escrib√≠ este proyecto en C ++.  La competencia por la implementaci√≥n del jard√≠n de procedimientos en el subreddit / r / proceduralgeneration me llev√≥ a esto (de ah√≠ el tema correspondiente). <br><br>  En mi sistema, la simulaci√≥n consta de tres componentes: el mundo, la poblaci√≥n y un conjunto de acciones que los conectan.  Por lo tanto, necesitaba crear tres modelos, que analizar√© en este art√≠culo. <br><br>  Para aumentar la dificultad, quer√≠a que los actores mantuvieran informaci√≥n sobre experiencias previas con el mundo y usaran el conocimiento sobre estas interacciones en acciones futuras. <br><a name="habracut"></a><br>  Al crear un modelo del mundo, eleg√≠ un camino simple y us√© el ruido de Perlin para colocarlo en la superficie del agua.  Todos los dem√°s objetos en el mundo se ubicaron absolutamente al azar. <br><br>  Para el modelo de poblaci√≥n (y su "memoria"), simplemente cre√© una clase con varias caracter√≠sticas y coordenadas.  Se supon√≠a que esto era una simulaci√≥n de baja resoluci√≥n.  La memoria es una cola, los robots se miran a su alrededor, guardan informaci√≥n sobre su entorno, escriben en la cola y administran esta cola como una interpretaci√≥n de su memoria. <br><br>  Para conectar estos dos sistemas de acciones, quer√≠a crear un marco de tareas primitivas dentro de un sistema jer√°rquico de colas de tareas para que las entidades individuales pudieran implementar comportamientos complejos en el mundo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/571/a8c/77b/571a8c77bb291d6802fe9c87b8aa8986.png"></div><br>  <i>Mapa de muestra</i>  <i>El agua tom√≥ la forma de un r√≠o completamente sin querer.</i>  <i>Todos los dem√°s elementos se ubican al azar, incluido el hormiguero, que en esta semilla se desplaza demasiado hacia el borde (pero el r√≠o se ve hermoso).</i> <br><br>  Decid√≠ que un mont√≥n de hormigas en el pasto recolectando hojas ser√° un buen modelo de prueba que garantiza la confiabilidad de la implementaci√≥n de funciones b√°sicas (y el sistema de colas de tareas en su conjunto) y evita p√©rdidas de memoria (hab√≠a muchas). <br><br>  Quiero describir con m√°s detalle la estructura de los sistemas de tareas y la memoria, y tambi√©n mostrar c√≥mo se cre√≥ la complejidad a partir de (principalmente) funciones b√°sicas primitivas.  Tambi√©n quiero mostrar algunas divertidas "fugas de memoria de las hormigas" que puede encontrar cuando las hormigas comienzan a correr locamente en c√≠rculos en busca de hierba o se detienen y hacen que el programa se ralentice. <br><br><h3>  Estructura general </h3><br>  Escrib√≠ esta simulaci√≥n en C ++ y us√© SDL2 para renderizar (ya escrib√≠ una peque√±a clase de presentaci√≥n para SLD2 antes).  Tambi√©n us√© la implementaci√≥n A * (ligeramente modificada) que encontr√© en github porque <em>mi implementaci√≥n</em> fue irremediablemente lenta y no pod√≠a entender por qu√©. <br><br>  Un mapa es solo una cuadr√≠cula de 100 √ó 100 con dos capas: una capa de suelo (utilizada para buscar rutas) y una capa de relleno (para completar la interacci√≥n y buscar rutas).  La clase mundial tambi√©n maneja varias funciones cosm√©ticas, como el crecimiento de hierba y vegetaci√≥n.  Estoy hablando de esto ahora porque estas son las √∫nicas partes que no se describir√°n en el art√≠culo. <br><br><h2>  La poblaci√≥n </h2><br>  Los bots estaban en una clase con propiedades que describ√≠an una sola criatura.  Algunos de ellos eran cosm√©ticos, otros influyeron en la ejecuci√≥n de acciones (por ejemplo, la capacidad de volar, el rango de visi√≥n, lo que come y lo que la criatura puede usar). <br><br>  Los m√°s importantes aqu√≠ fueron los valores auxiliares que determinan el comportamiento.  A saber: un vector que contiene su ruta actual A *, de modo que no es necesario contarlo en cada ciclo de reloj (esto ahorra tiempo de c√°lculo y le permite simular m√°s bots), y una cola de memoria que define la interpretaci√≥n de las criaturas de su entorno. <br><br><h3>  Cola de memoria </h3><br>  Una cola de memoria es una cola simple que contiene un conjunto de objetos de memoria de tama√±o limitado por una propiedad bot.  Cada vez que se agregaban nuevos recuerdos, se avanzaban y todo lo que iba m√°s all√° de las fronteras se cortaba.  Gracias a esto, algunos recuerdos podr√≠an ser m√°s "frescos" que otros. <br><br>  Si el bot quer√≠a recuperar informaci√≥n de la memoria, entonces cre√≥ un objeto de memoria (solicitud) y lo compar√≥ con lo que hab√≠a en la memoria.  Luego, la funci√≥n de recuperaci√≥n devolvi√≥ un vector de memorias que coinciden con cualquiera o todos los criterios especificados en la consulta. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Memory</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Recall Score int recallScore = 1; //Memory Queryable? Array bool queryable[4] = {false, false, false, false}; //Memory Attributes std::string object; std::string task; Point location; bool reachable;</span></span></code> </pre> <br>  Los recuerdos consisten en un objeto simple que contiene varias propiedades.  Estas propiedades de memoria se consideran "asociadas" entre s√≠.  A cada memoria tambi√©n se le asigna un valor de "recordar puntaje", que se repite cada vez que la memoria recuerda la memoria.  Cada vez que el bot recuerda los recuerdos, realiza una clasificaci√≥n de una sola pasada, comenzando desde atr√°s, cambiando el orden de los recuerdos si el puntaje de memoria de una memoria anterior es mayor que el de una nueva.  Gracias a esto, algunos recuerdos pueden ser m√°s "importantes" (con grandes tama√±os de memoria) y almacenarse m√°s tiempo en la cola.  Con el tiempo, ser√°n reemplazados por otros nuevos. <br><br><h3>  Colas de memoria </h3><br>  Tambi√©n agregu√© varios operadores sobrecargados a esta clase para que se puedan realizar comparaciones directas entre la cola de memoria y la consulta, comparando las propiedades "cualquiera" o "todas", de modo que solo se sobrescriban las propiedades especificadas cuando se sobrescribe la memoria.  Gracias a esto, podemos tener la memoria del objeto asociada a alg√∫n lugar, pero si miramos este lugar nuevamente y el objeto no est√° all√≠, podemos actualizar la memoria sobrescribi√©ndola con la memoria que contiene un nuevo mosaico de relleno, utilizando la consulta correspondiente a este lugar . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Bot::updateMemory(Memory &amp;query, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> all, Memory &amp;memory){ <span class="hljs-comment"><span class="hljs-comment">//Loop through all existing Memories //"memories" queue is a member of Bot for(unsigned int i = 0; i &lt; memories.size(); i++){ //If all matches are required and we have all matches if(all &amp;&amp; (memories[i] == query)){ //We have a memory that needs to be updated memories[i] = memory; continue; } //If not all matches are required and any query elements are contained else if(!all &amp;&amp; (memories[i] || query)){ //When overwriting, only overwrite specified quantities memories[i] = memory; continue; } } }</span></span></code> </pre> <br>  En el proceso de creaci√≥n del c√≥digo para este sistema, aprend√≠ mucho. <br><br><h2>  Sistema de tareas </h2><br>  La naturaleza del bucle o representaci√≥n del juego es que las mismas funciones se repiten en cada medida, sin embargo, quer√≠a implementar un comportamiento no c√≠clico en mis bots. <br><br>  En esta secci√≥n, explicar√© dos puntos de vista sobre la estructura del sistema de tareas dise√±ado para contrarrestar este efecto. <br><br><h3>  Estructura de abajo hacia arriba </h3><br>  Decid√≠ moverme de abajo hacia arriba y crear un conjunto de "acciones primitivas" que los bots deber√≠an realizar.  Cada una de estas acciones dura solo un latido.  Con una buena biblioteca de funciones primitivas, podemos combinarlas en acciones complejas que consisten en varias funciones primitivas. <br><br>  Ejemplos de tales acciones primitivas: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Primitives bool wait(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool look(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool step(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool swap(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool store(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool consume(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool move(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Continue with secondaries here...</span></span></code> </pre> <br>  Tenga en cuenta que estas acciones contienen referencias tanto al mundo como a la poblaci√≥n, lo que le permite cambiarlas. <br><br><ul><li>  Esperar hace que la criatura no haga nada en este bucle. </li><li>  Look analiza el entorno y pone en cola nuevos recuerdos. </li><li>  Swap toma un objeto en la mano de la criatura y lo reemplaza con uno que yace en el suelo. </li><li>  El consumo destruye el objeto en la mano de la criatura. </li><li>  El paso lleva la ruta calculada actual al destino y realiza un paso (con un mont√≥n de comprobaciones de error). </li><li>  ... y as√≠ sucesivamente. </li></ul><br>  Todas las funciones de tareas son miembros de mi clase de tarea;  Despu√©s de pruebas rigurosas, han demostrado su fiabilidad y capacidad para combinarse en tareas m√°s complejas. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Secondaries bool walk(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool idle(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool search(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool forage(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool take(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Species Masters bool Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool Bee(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); };</span></span></code> </pre> <br>  En estas funciones secundarias, construimos funciones simplemente encadenando otras tareas: <br><br><ul><li>  La tarea de caminar es solo unos pocos pasos (con manejo de errores) </li><li>  La tarea de toma es la tarea de mirar e intercambiar (es necesaria debido al procesamiento de memoria de hormigas, que explicar√© m√°s adelante) </li><li>  La tarea inactiva es seleccionar un lugar aleatorio y moverse all√≠ (usando caminar), esperar varios ciclos (usar esperar) y repetir este ciclo un n√∫mero determinado de veces </li><li>  ... y as√≠ sucesivamente </li></ul><br>  Otras tareas son m√°s complicadas.  La tarea de b√∫squeda ejecuta una consulta de memoria para buscar cualquier recuerdo de los lugares que contienen el objeto "comida" (comestible para este tipo de bot).  Ella descarga estos recuerdos y los recorre a todos, "buscando" comida (en el caso de las hormigas, esto es hierba).  Si no hay recuerdos de comida, la tarea hace que la criatura deambule aleatoriamente por el mundo y mire a su alrededor.  Al observar y estudiar (haciendo una "mirada" con viewRadius = 1; es decir, mirando solo el mosaico debajo), la criatura puede actualizar su memoria con informaci√≥n sobre su entorno, buscando comida de manera inteligente y decidida. <br><br>  Una tarea de forraje m√°s generalizada consiste en encontrar comida, recoger comida, inspeccionar (para actualizar la memoria y encontrar comida en el vecindario), regresar a casa y almacenar comida. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c90/df8/2d8/c90df82d8de8bcf8a9d0de594d2c2e89.gif"></div><br>  <i>Puede notar que las hormigas salen del hormiguero y buscan alimento a prop√≥sito.</i>  <i>Debido a la inicializaci√≥n, la ruta inicial de las hormigas se dirige a un punto aleatorio, porque su memoria en t = 0 est√° vac√≠a.</i>  <i>Luego se les da la orden de recoger comida en la tarea de forraje, y tambi√©n miran a su alrededor, asegur√°ndose de que no haya m√°s comida.</i>  <i>De vez en cuando comienzan a vagar, porque se quedan sin lugares en los que vieron comida (miop√≠a ominosa).</i> <br><br>  Y finalmente, el bot tiene una "vista" que determina el tipo de IA que se le asigna.  Cada vista est√° asociada con una tarea de control que define todo su comportamiento: consiste en una cascada de tareas cada vez m√°s peque√±as, determinadas f√°cilmente por un conjunto de colas de memoria y tareas primitivas.  Estas son tareas como Ant and Bee. <br><br><h3>  Estructura de arriba hacia abajo </h3><br>  Si observa de arriba a abajo, el sistema consiste en una clase maestra de tareas que coordina las tareas de control y su ejecuci√≥n para cada bot individual en el mapa. <br><br>  Taskmaster tiene un vector de tareas de control, cada una de las cuales est√° asociada con un bot.  Cada tarea de control, a su vez, tiene una cola de subtareas que se cargan durante la primera inicializaci√≥n del objeto de tarea con la funci√≥n de tarea asociada. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Members std::stack&lt;Task&gt; queue; bool initFlag = true; int args[10]; bool (Task::*handle)(Garden&amp;, Population&amp;, int (&amp;)[10]); int botID; std::string name; //Constructor Task(std::string taskName, int taskBotID, bool (Task::*taskHandle)(Garden&amp;, Population&amp;, int (&amp;)[10])){ name = taskName; botID = taskBotID; handle = taskHandle; } //Launch a Task bool perform(Garden &amp;garden, Population &amp;population); //Continue with primitives here...</span></span></code> </pre> <br>  Cada objeto de tarea en la cola almacena una matriz de argumentos, que pasa al manejador de funciones asociado.  Estos argumentos determinan el comportamiento de estas tareas primitivas creadas de la manera m√°s general posible.  Los argumentos se pasan por referencia, por lo que el objeto de tarea en la cola puede almacenar sus argumentos y permitir que se modifiquen sus subfunciones, por lo que puede implementar cosas como iteraciones para esperar un cierto n√∫mero de ticks o solicitudes para recopilar un cierto n√∫mero de elementos, etc.  Las subfunciones cambian el valor del iterador (argumento [n]) de la funci√≥n padre por referencia y hacen que su condici√≥n de √©xito dependa de su valor. <br><br>  En cada medida, el administrador de tareas revisa la lista de tareas de control y las ejecuta llamando a su m√©todo de ejecuci√≥n.  El m√©todo de ejecuci√≥n, a su vez, mira el elemento superior de la cola dentro de la tarea y lo ejecuta con argumentos de la tarea.  Por lo tanto, puede descender en la cola de tareas, siempre realizando la tarea m√°s alta.  Luego, el valor de retorno de la tarea determina la finalizaci√≥n de la tarea. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Execute Task Function bool Task::perform(Garden &amp;garden, Population &amp;population){ //Debug Message if(debug){std::cout&lt;&lt;"Bot with ID: "&lt;&lt;botID&lt;&lt;" performing task: "&lt;&lt;name&lt;&lt;std::endl;} //Change the Name and Execute the Task population.bots[botID].task = name; return (*this.*handle)(garden, population, args); }</span></span></code> </pre> <br>  Cuando una tarea primitiva devuelve verdadero, ha alcanzado su punto estable, o al menos no debe repetirse (por ejemplo, el paso devuelve verdadero cuando la criatura ha alcanzado el punto final).  Es decir, se cumple su condici√≥n de devoluci√≥n y se elimina de la cola para que la siguiente tarea se pueda completar en la siguiente medida. <br><br>  Una tarea que contiene una cola de tareas devuelve verdadero despu√©s de que la cola est√© vac√≠a.  Debido a esto, es posible crear tareas complejas con la estructura de colas y subcolas en las que se llaman constantemente las mismas funciones, pero cada llamada itera el estado del juego y el estado de la tarea en un paso. <br><br>  Finalmente, las tareas de control usan una estructura simple: se llaman en cada ciclo, cargan la tarea solo si est√°n vac√≠as y, de lo contrario, realizan tareas cargadas en su cola. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Species Functions bool Task::Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]){ //Initial Condition if(initFlag){ Task forage("Search for Food", botID, &amp;Task::forage); forage.args[0] = population.bots[botID].forage; //What are we looking for? queue.push(forage); initFlag = false; } //Queue Loop if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ queue.push(newtask); return false; } //If it was successful, we leave it off return false; } //Return Case for Mastertask initFlag = true; return false; }</span></span></code> </pre> <br>  Con la ayuda de mi bucle de cola (ver c√≥digo), puedo ejecutar repetidamente una funci√≥n y cada vez ejecutar el elemento superior en su cola, empujando elementos fuera de √©l si llamar a su m√©todo de ejecuci√≥n devuelve verdadero. <br><br><h2>  Resultados </h2><br>  Todo esto est√° envuelto en libconfig, por lo que los par√°metros de simulaci√≥n son muy f√°ciles de cambiar.  Puede codificar muchas tareas de control sin problemas (cre√© hormigas y abejas), y definir y cargar nuevas especies usando libconfig es sorprendentemente simple. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Anthill General Configuration File debug = true; //World Generation Parameters seed = 15; water = true; //Species that the simulation recognizes Species: { //Ant Species Ant: { masterTask = "Ant"; color = (0, 0, 0); viewDistance = 2; memorySize = 5; forage = 2; trail = true; fly = false; } Bee: { masterTask = "Bee"; color = (240, 210, 30); viewDistance = 4; memorySize = 30; forage = 4; trail = false; fly = true; } Worm: { masterTask = "Bee"; color = (255, 154, 171); viewDistance = 1; memorySize = 5; forage = 3; trail = true; fly = false; } } Population: ( {species = "Ant"; number = 40;}//, //{species = "Bee"; number = 12;}, //{species = "Worm"; number = 5;} )</span></span></code> </pre> <br>  Fueron elegantemente cargados en la simulaci√≥n.  Gracias a una nueva b√∫squeda mejorada de rutas, puedo simular una gran cantidad de robots activos individuales que recolectan alimentos en un plano bidimensional. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c30/991/682/c309916821a8538a0dd92db88caf6b6b.gif"></div><br>  <i>Simulaci√≥n de 40 hormigas recolectando pasto al mismo tiempo.</i>  <i>Los caminos que crean en la arena se deben al mayor peso asignado a la tierra "virgen".</i>  <i>Esto lleva a la creaci√≥n de "carreteras de hormigas" caracter√≠sticas.</i>  <i>Tambi√©n se pueden interpretar como feromonas, pero ser√≠a m√°s como la verdad si las hormigas realmente intercambiaran recuerdos.</i> <br><br>  La modularidad de este sistema asegura la creaci√≥n r√°pida de nuevas especies cuyo comportamiento est√° determinado por una simple tarea de control.  En el c√≥digo anterior, puede ver que cre√© gusanos y abejas IA simplemente cambiando su color, las restricciones de b√∫squeda de ruta (no pueden volar), el rango de visibilidad y el tama√±o de la memoria.  Al mismo tiempo, cambi√© su comportamiento general, porque todos estos par√°metros son utilizados por funciones de tareas primitivas. <br><br><h3>  Depuraci√≥n de recuerdos de hormigas </h3><br>  La estructura de tareas complejas y memoria ha llevado a dificultades imprevistas y la necesidad de manejar excepciones. <br><br>  Aqu√≠ hay tres errores de memoria particularmente complejos que me hicieron rehacer los subsistemas: <br><br><h4>  Hormigas corriendo en c√≠rculo </h4><br>  Uno de los primeros errores que tuve que enfrentar: las hormigas corr√≠an locamente a lo largo del patr√≥n encerrado en la plaza en busca de hierba en el suelo desnudo.  Este problema surgi√≥ porque en ese momento a√∫n no hab√≠a implementado una actualizaci√≥n de memoria.  Las hormigas ten√≠an recuerdos de la ubicaci√≥n de la comida, y tan pronto como recogieron la hierba y volvieron a mirar a su alrededor, se formaron nuevos recuerdos. <br><br>  El problema era que la nueva memoria estaba en el mismo punto, pero la antigua estaba preservada.  Esto signific√≥ que en el proceso de b√∫squeda de alimentos, las hormigas recordaron y mantuvieron la ubicaci√≥n de los alimentos que ya no eran v√°lidos, pero estos viejos recuerdos se conservaron y suplantaron a otros nuevos (recordaron esta deliciosa hierba). <br><br>  Lo arregl√© de la siguiente manera: los datos del objeto simplemente se sobrescriben en viejos recuerdos, si vemos el mismo lugar y el objeto ha cambiado (por ejemplo, la criatura ve que no hay m√°s hierba all√≠, pero no recuerda que sol√≠a haber hierba).  Quiz√°s en el futuro simplemente agregue la propiedad "no v√°lida" a mis recuerdos para que los bots puedan recordar informaci√≥n antigua que puede ser importante, pero la informaci√≥n que ya no es v√°lida "apareci√≥" ("Vi un oso aqu√≠, pero ahora no est√°"). <br><br><h4>  Las hormigas recogen objetos debajo de otras hormigas </h4><br>  De vez en cuando (especialmente con una gran cantidad de hormigas y una alta densidad de hierba), dos hormigas pueden subirse a una baldosa de hierba en una medida e intentar recogerla.  Esto signific√≥ que la primera hormiga entr√≥ en el azulejo, mir√≥ a su alrededor y tom√≥ el art√≠culo en 3 pasos.  A su vez, la segunda hormiga hizo lo mismo, solo justo antes de levantar el objeto, otra hormiga se lo arrebat√≥ debajo de la nariz.  Continu√≥ tranquilamente sus tareas, examinando el mismo entorno que la otra hormiga en la medida anterior, y proces√≥ su l√≠nea de memoria de la misma manera (porque en esta etapa sus recuerdos son id√©nticos).  Esto llev√≥ a que la segunda hormiga copiara la primera, nunca recogiera objetos y siguiera a la primera, que realmente hizo todo el trabajo.  Me di cuenta de esto porque en la simulaci√≥n de las cinco hormigas, solo tres eran visibles.  Me llev√≥ mucho tiempo encontrar la causa. <br><br>  Resolv√≠ este problema haciendo que la tarea de intercambio sea primitiva y creando la tarea de toma, que primero mira al suelo para ver si hay un objeto all√≠.  Si es as√≠, "intercambia", y si no, "espera" dos movimientos para que la otra hormiga definitivamente se vaya.  En un caso, esta acci√≥n es para dos medidas, en el otro, para una medida. <br><br><h4>  Ubicaciones inalcanzables </h4><br>  Otro error desagradable que me oblig√≥ a rehacer el procesamiento de la memoria fue que algunos lugares que la hormiga pod√≠a ver eran inalcanzables para √©l.  Surgieron debido a mi colocaci√≥n perezosa de "cruces de hierba" en tierra, que a veces colgaba sobre el agua.  Esto me hizo generalizar la tarea paso. <br><br>  Al transmitir una solicitud de b√∫squeda de alimentos, las hormigas a menudo ten√≠an recuerdos de lugares a los que realmente no pod√≠an llegar (vieron hierba sobre el agua y quer√≠an <em>locamente</em> recogerla).  Si no estaba marcado en su memoria (por ejemplo, la variable booleana "accesible"), continuaron recordando esto y escribiendo en la cola hasta que esta acci√≥n fue la √∫nica.  Esto caus√≥ una inhibici√≥n severa, porque <em>constantemente realizaron operaciones de b√∫squeda de ruta en cada medida, tratando de llegar all√≠, y fallaron</em> . <br><br>  La soluci√≥n fue actualizar la memoria en la tarea de pasos si no puede encontrar la ruta al lugar, marc√°ndola en la memoria como inalcanzable.  Adem√°s, la tarea de b√∫squeda solo consulta lugares con comida para obtener recuerdos accesibles. <br><br><h2>  Sistema en general </h2><br>  En general, quiero decir: s√≠, lamento haber pasado una semana de mi vida en un marat√≥n de programaci√≥n, porque me inspir√≥ para crear bots que hagan lo que les digo (¬°y tambi√©n lo que quieren hacer!).  Tuve que hacer algunos trucos y aprend√≠ mucho. <br><br>  El sistema que cre√© no es 100% confiable, y todav√≠a noto algunos artefactos.  Por ejemplo, como la direcci√≥n para analizar el aspecto, la acci√≥n se usa de arriba hacia abajo y de izquierda a derecha, es decir, el √∫ltimo recuerdo est√° en la esquina inferior derecha.  Al recuperar informaci√≥n para buscar elementos, esto significa que las criaturas tender√°n a moverse hacia el sureste.  Esto es especialmente notable en simulaciones grandes, cuando la hierba crece r√°pidamente y se dobla ligeramente hacia el sureste, independientemente de la semilla. <br><br><h3>  Mejoras </h3><br>  Creo que se necesitan mejoras significativas para simular recuerdos m√°s complejos de criaturas m√°s complejas. <br><br>  Esto incluye aumentar la confiabilidad de las funciones de procesamiento de memoria, as√≠ como agregar nuevas primitivas, como "pensar", y derivados de tareas de alto nivel, como "decidir" o "so√±ar".  "Pensar" puede ser una acci√≥n primitiva de una solicitud de memoria.  Un "sue√±o", a su vez, puede consistir en varias llamadas de "pensar": elegir una memoria aleatoria, obtener una propiedad aleatoria y repetirla repetidamente para reforzar temas comunes o asociaciones importantes. <br><br>  Para el futuro, planeo tres adiciones espec√≠ficas: <br><br><ul><li>  Agregue manejo de interrupciones y priorizaci√≥n de tareas </li><li>  Agregar comunicaci√≥n entre entidades </li><li>  Agregue una estructura de grupo para que las entidades puedan identificarse formalmente </li></ul><br>  La interrupci√≥n del procesamiento y la priorizaci√≥n de tareas pueden ser necesarias para la interacci√≥n entre entidades, porque el bot no puede continuar ciegamente sus actividades cuando se comunican con √©l (de alguna manera debe "escuchar") o es atacado ("huir" o "pelear" ) <br><br>  La comunicaci√≥n entre entidades probablemente consiste en una o dos tareas primitivas para intercambiar recuerdos o hacer solicitudes a los recuerdos de otros bots (por ejemplo, "decir" o "preguntar").  De esta manera, se puede transmitir informaci√≥n como la ubicaci√≥n de los alimentos u otros recursos. <br><br>  Espero implementar estas tareas y elaborar un gr√°fico de la tasa de acumulaci√≥n de recursos por un grupo grande con y sin comunicaci√≥n.  La poblaci√≥n ya est√° rastreando la cantidad de alimentos recolectados en cada medida.  Ser√≠a interesante mostrar que compartir recuerdos puede afectar la eficiencia. <br><br><h3>  El futuro </h3><br>  La funci√≥n m√°s importante para simular comunidades ser√° agregar estructuras grupales y dotar a estos grupos de propiedades de nivel macro, por ejemplo, sus "objetivos y responsabilidades" comunes.  Esto nos da una especie de "semilla" de la que podemos obtener tareas de alto nivel que se delegan en la jerarqu√≠a de las estructuras de grupo para "bajar" las tareas de alto nivel que afectan directamente al mundo.  Tambi√©n ayuda a crear una forma de estructura pol√≠tica. <br><br>  Tal sistema es bastante autosuficiente, y la visualizaci√≥n simplemente se superpone encima.  Ser√° muy sencillo reemplazar los insectos con humanoides, recolectar recursos y almacenarlos en alg√∫n lugar, para que crezca en tama√±o.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La naturaleza del crecimiento de su hogar puede, por ejemplo, ser muy dependiente o completamente independiente de las acciones de los bots. </font><font style="vertical-align: inherit;">Diferentes especies pueden tener diferentes tribus con diferentes caracter√≠sticas y tendencias. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, puedo combinar este sistema con generadores de mapas creados previamente (expandiendo la clase mundial) para hacer que el mundo sea m√°s real.</font></font><br><br><h2>  En conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un futuro pr√≥ximo, planeo reemplazar a las criaturas con personas e implementar algunas de las √∫ltimas funciones. </font><font style="vertical-align: inherit;">Quiz√°s publique el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥digo fuente completo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cuando mejore la calidad del sistema (en algunos lugares el c√≥digo es bastante ca√≥tico). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espera el pr√≥ximo art√≠culo. </font><font style="vertical-align: inherit;">Mientras tanto, aqu√≠ hay un video con abejas buscando polen en flores; </font><font style="vertical-align: inherit;">est√°n codificados usando el mismo marco.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/b31/7d5/332b317d547edc53f2b2ffee6c3d4861.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eleg√≠ esta semilla porque el punto de partida se encuentra en una peque√±a isla. </font><font style="vertical-align: inherit;">Sin embargo, las abejas no est√°n programadas para regresar a la colmena, sino que simplemente recolectan polen constantemente. </font><font style="vertical-align: inherit;">Puede notar que su rango de visi√≥n es mayor y, a veces, se mueven intencionalmente a la flor que acaban de ver. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... y aqu√≠ est√° la funci√≥n miembro de Bee Task:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Task::Bee(Garden &amp;garden, Population &amp;population, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (&amp;arguments)[<span class="hljs-number"><span class="hljs-number">10</span></span>]){ <span class="hljs-comment"><span class="hljs-comment">//Just Search for Flowers if(initFlag){ //Define our Tasks Task take("Take Food", botID, &amp;Task::take); Task eat("Eat Food", botID, &amp;Task::consume); Task search("Locate Food", botID, &amp;Task::search); search.args[0] = population.bots[botID].forage; queue.push(eat); queue.push(take); queue.push(search); initFlag = false; } //Work off our allocated queue. if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ //Put the Task back on queue.push(newtask); } //If it was successful, we leave it off return false; } initFlag = true; return true; }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443252/">https://habr.com/ru/post/443252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443242/index.html">Quarkus es un Java subat√≥mico supers√≥nico. Una breve descripci√≥n del marco</a></li>
<li><a href="../443244/index.html">Debriefing tareas. Beanpoisk_1</a></li>
<li><a href="../443246/index.html">C√≥mo reinventamos Askozia IP PBX despu√©s de que el desarrollador vendi√≥ y cerr√≥ el proyecto</a></li>
<li><a href="../443248/index.html">Protocolos de reserva perfecta de PRP y HSR</a></li>
<li><a href="../443250/index.html">Recolector de basura casero para OpenJDK</a></li>
<li><a href="../443254/index.html">Triton es el virus m√°s mortal</a></li>
<li><a href="../443256/index.html">PowerShell, volcado de mi experiencia</a></li>
<li><a href="../443258/index.html">Gotify: un proyecto de c√≥digo abierto para enviar notificaciones y enviar mensajes al servidor</a></li>
<li><a href="../443260/index.html">Migre a Zimbra sin arriesgar negocios con un dominio com√∫n</a></li>
<li><a href="../443262/index.html">Mal consejo: ¬øc√≥mo escribir documentaci√≥n t√©cnica? Tercera parte y √∫ltima</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>