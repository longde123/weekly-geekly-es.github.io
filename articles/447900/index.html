<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚ÄçüöÄ ü§∂ üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø Cerrar contactos ADL üëãüèæ üé™ üßû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øC√≥mo escribir tu nombre en la historia para siempre? ¬øEl primero en volar a la luna? ¬øEl primero en encontrarse con una mente extra√±a? Tenemos una ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cerrar contactos ADL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/447900/"><p><img src="https://habrastorage.org/webt/zb/i1/7h/zbi17hhfyu9_oqqmwgpzijon0d8.jpeg"></p><br><p>  ¬øC√≥mo escribir tu nombre en la historia para siempre?  ¬øEl primero en volar a la luna?  ¬øEl primero en encontrarse con una mente extra√±a?  Tenemos una manera m√°s simple: puede adaptarse al est√°ndar de lenguaje C ++. </p><br><p>  Eric Nibler, autor de C ++ Ranges, ofrece un buen ejemplo.  ‚ÄúRecuerda esto.  El 19 de febrero de 2019 es el d√≠a en que se habl√≥ por primera vez el t√©rmino "nibloide" en la reuni√≥n del WG21 ", <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escribi√≥</a> en Twitter. </p><br><p>  De hecho, si va a CppReference, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la secci√≥n cpp / algoritmo / rangoscpp / algoritmo / rangos</a> , encontrar√° muchas referencias all√≠ (niebloid).  Para esto, incluso se ha creado una plantilla wiki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dsc_niebloid</a> separada. </p><br><p>  Desafortunadamente, no encontr√© ning√∫n art√≠culo oficial completo sobre este tema y decid√≠ escribir el m√≠o.  Este es un viaje peque√±o pero fascinante hacia los abismos de la astron√°utica arquitect√≥nica, en el que podemos sumergirnos en el abismo de la locura ADL y familiarizarnos con los nibloides. </p><br><p>  Importante: no soy un soldador real, sino un javista que a veces corrige errores en el c√≥digo C ++ seg√∫n sea necesario.  Si se toma un poco de tiempo para ayudar a encontrar errores en el razonamiento, ser√≠a bueno.  "Ayuda a Dasha, el viajero, a recoger algo razonable". </p><a name="habracut"></a><br><h2 id="lookup">  Buscar </h2><br><p>  Primero debes decidir sobre los t√©rminos.  Estas son cosas bien conocidas, pero "lo expl√≠cito es mejor que lo impl√≠cito", por lo que las discutiremos por separado.  No uso terminolog√≠a real en ruso, sino que uso ingl√©s.  Esto es necesario porque incluso la palabra "restricci√≥n" en el contexto de este art√≠culo puede asociarse con al menos tres versiones en ingl√©s, cuya diferencia es importante para la comprensi√≥n. </p><br><p>  Por ejemplo, en C ++ existe el concepto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫squeda de nombres</a> o, en otras palabras, una b√∫squeda: cuando se encuentra un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nombre</a> en un programa, se compila con su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">declaraci√≥n</a> durante la compilaci√≥n. </p><br><p> Se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">calificar</a> una b√∫squeda (si el nombre est√° a la derecha del operador de permisos del √°mbito <code>::</code> :), y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no calificado</a> en otros casos.  Si la b√∫squeda es calificada, omitimos los miembros correspondientes de la clase, el espacio de nombres o la enumeraci√≥n.  Se podr√≠a llamar a esto la versi√≥n "completa" del registro (como parece hacerse en la traducci√≥n de Straustrup), pero es mejor dejar la ortograf√≠a original, porque se refiere a un tipo muy espec√≠fico de integridad. </p><br><h2 id="adl">  ADL </h2><br><p>  Si la b√∫squeda no est√° calificada, entonces debemos entender exactamente d√≥nde buscar el nombre.  Y aqu√≠ se incluye una caracter√≠stica especial llamada ADL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫squeda dependiente de argumentos</a> , o bien, la b√∫squeda de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Koenig</a> (el que acu√±√≥ el t√©rmino "antipatr√≥n", que es un poco simb√≥lico a la luz del siguiente texto).  Nicolai Josuttis en su libro "The C ++ Standard Library: A Tutorial and Reference" lo describe de la siguiente manera: "El punto es que no es necesario calificar el espacio de nombres de la funci√≥n si al menos uno de los tipos de argumentos est√° definido en el espacio de nombres de esta funci√≥n". </p><br><p>  ¬øC√≥mo deber√≠a ser? </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { //  . //   , operator&lt;&lt;    ,  ADL , //    std    std::operator&lt;&lt;(std::ostream&amp;, const char*) std::cout &lt;&lt; "Test\n"; //    .      -     . operator&lt;&lt;(std::cout, "Test\n"); // same, using function call notation //    : // Error: 'endl' is not declared in this namespace. //      endl(),  ADL  . std::cout &lt;&lt; endl; //  . //    ,       ADL. //     std,   endl      std. endl(std::cout); //    : // Error: 'endl' is not declared in this namespace. //  ,  - (endl) -     . (endl)(std::cout); }</span></span></span></span></code> </pre> <br><h2 id="spuskaemsya-v-ad-s-adl">  Vete al infierno con ADL </h2><br><p>  Parecer√≠a simple.  O no?  Primero, dependiendo del tipo de argumento, ADL funciona de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nueve maneras diferentes</a> , para matar con una escoba. </p><br><p>  En segundo lugar, puramente pr√°ctico, imagine que tenemos alg√∫n tipo de funci√≥n de intercambio.  Resulta que <code>std::swap(obj1,obj2);</code>  y <code>using std::swap; swap(obj1, obj2);</code> <code>using std::swap; swap(obj1, obj2);</code>  puede comportarse de manera completamente diferente.  Si ADL est√° habilitado, entonces de varios intercambios diferentes, ¬°el que necesita ya est√° seleccionado en funci√≥n de los espacios de nombres de los argumentos!  Dependiendo del punto de vista, este modismo puede considerarse tanto un ejemplo positivo como negativo :-) </p><br><p>  Si le parece que esto no es suficiente, puede dejar caer la le√±a en el horno del sombrero.  Esto fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrito</a> recientemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por Arthur O'Dwyer</a> .  Espero que no me castigue por usar su ejemplo. </p><br><p>  Imagine que tiene un programa de este tipo: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  Por supuesto, no se compila con un error: </p><br><pre> <code class="plaintext hljs">error: use of undeclared identifier 'call'; did you mean 'A::call'? call(f); ^~~~ A::call</code> </pre> <br><p>  Pero si agrega una <strong>sobrecarga completamente no utilizada de la</strong> funci√≥n <code>f</code> , ¬°entonces todo funcionar√°! </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } void f(A::A); // UNUSED int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  En Visual Studio todav√≠a se romper√°, pero ese es su destino, no funciona. </p><br><p>  ¬øC√≥mo sucedi√≥ esto?  Profundicemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el est√°ndar</a> (sin traducci√≥n, porque dicha traducci√≥n ser√≠a una mezcolanza de palabras de moda excepcionalmente monstruosa): </p><br><blockquote>  Si el argumento es el nombre o la direcci√≥n de un conjunto de funciones y / o plantillas de funciones sobrecargadas, sus entidades y espacios de nombres asociados son la uni√≥n de los asociados con cada uno de los miembros del conjunto, es decir, las entidades y espacios de nombres asociados con su par√°metro tipos y tipo de retorno.  [...] Adem√°s, si el conjunto de funciones sobrecargadas mencionado anteriormente se nombra con una plantilla-id, sus entidades y espacios de nombres asociados tambi√©n incluyen los de su tipo plantilla-argumentos y su plantilla plantilla-argumentos. </blockquote><p>  Ahora tome un c√≥digo como este: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace B { struct B {}; void call(void (*f)()) { f(); } } template&lt;class T&gt; void f() { puts("Hello world"); } int main() { call(f&lt;B::B&gt;); }</span></span></span></span></code> </pre> <br><p>  En ambos casos, se obtienen argumentos que no tienen tipo.  <code>f</code> y <code>f&lt;B::B&gt;</code> son los nombres de los conjuntos de funciones sobrecargadas (de la definici√≥n anterior), y dicho conjunto no tiene tipo.  Para colapsar una sobrecarga en una sola funci√≥n, debe comprender qu√© tipo de puntero de funci√≥n es m√°s adecuado para la mejor sobrecarga de <code>call</code> .  Por lo tanto, debe recopilar un conjunto de candidatos para la <code>call</code> , lo que significa iniciar una b√∫squeda de la <code>call</code> nombre.  ¬°Y para esto comenzar√° ADL! </p><br><p>  ¬°Pero generalmente para ADL debemos conocer los tipos de argumentos!  Y aqu√≠ Clang, ICC y MSVC se rompen err√≥neamente de la siguiente manera (pero GCC no): </p><br><pre> <code class="cpp hljs">[build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>): error: use of undeclared identifier <span class="hljs-string"><span class="hljs-string">'call'</span></span>; did you mean <span class="hljs-string"><span class="hljs-string">'B::call'</span></span>? [build] call(f&lt;B::B&gt;); [build] ^~~~ [build] B::call [build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>): note: <span class="hljs-string"><span class="hljs-string">'B::call'</span></span> declared here [build] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)())</span></span></span><span class="hljs-function"> </span></span>{ [build] ^</code> </pre> <br><p>  Incluso los creadores de compiladores con ADL tienen una relaci√≥n un poco tensa. </p><br><p>  Bueno, ¬øADL todav√≠a parece una buena idea?  Por un lado, ya no necesitamos escribir un c√≥digo tan servil de una manera educada: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>);</code> </pre> <br><p>  Por otro lado, intercambiamos por brevedad el hecho de que ahora hay un sistema que funciona de una manera completamente inhumana.  Una historia tr√°gica y majestuosa sobre c√≥mo la facilidad de escribir Halloworld puede afectar todo el idioma en una escala de d√©cadas. </p><br><h2 id="renzhi-i-koncepty">  Rangos y conceptos </h2><br><p>  Si abre la descripci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la biblioteca de Nibler Rangers</a> , incluso antes de mencionar los nibloides, tropezar√° con muchos otros marcadores llamados <strong>(concepto)</strong> .  Esto ya es algo bonito, pero por si acaso (para los viejos y los javists) te recordar√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lo que es</a> . </p><br><p>  Los conceptos se denominan conjuntos de restricciones con nombre que se aplican a los argumentos de plantilla para seleccionar las mejores sobrecargas de funciones y las especializaciones de plantilla m√°s adecuadas. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasStringFunc = requires(T a) { { to_string(a) } -&gt; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HasStringFunc a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; to_string(a) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Aqu√≠ hemos impuesto una restricci√≥n de que el argumento debe tener una funci√≥n <code>to_string</code> que devuelva una cadena.  Si tratamos de poner alg√∫n juego dentro de la <code>print</code> que no est√© sujeto a las restricciones, entonces dicho c√≥digo simplemente no se compilar√°. </p><br><p>  Esto simplifica enormemente el c√≥digo.  Por ejemplo, vea c√≥mo Nibler <a href="">clasific√≥ en rangos-v3</a> , que funciona en C ++ 14/11/17.  Hay un c√≥digo maravilloso como este: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT_(X, Y) X ## Y #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT(X, Y) CONCEPT_PP_CAT_(X, Y) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/// \addtogroup group-concepts /// @{ #define CONCEPT_REQUIRES_(...) \ int CONCEPT_PP_CAT(_concept_requires_, __LINE__) = 42, \ typename std::enable_if&lt; \ (CONCEPT_PP_CAT(_concept_requires_, __LINE__) == 43) || (__VA_ARGS__), \ int \ &gt;::type = 0 \ /**/</span></span></span></span></code> </pre> <br><p>  Para que luego puedas hacer: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sortable_</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> I = <span class="hljs-keyword"><span class="hljs-keyword">iterator_t</span></span>&lt;Rng&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requires_() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( concepts::valid_expr( concepts::model_of&lt;concepts::ForwardRange, Rng&gt;(), concepts::is_true(ranges::Sortable&lt;I, C, P&gt;()) )); }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Sortable = concepts::models&lt;Sortable_, Rng, C, P&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, CONCEPT_REQUIRES_(!Sortable&lt;Rng, C, P&gt;())&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(Rng &amp;&amp;, C &amp;&amp; = C{}, P &amp;&amp; = P{}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ...</code> </pre> <br><p>  Espero que ya haya querido ver todo esto y simplemente usar conceptos preparados en un compilador nuevo. </p><br><h2 id="tochki-kastomizacii">  Puntos de personalizaci√≥n </h2><br><p>  La siguiente cosa interesante que se puede encontrar en el est√°ndar es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">personalizaci√≥n.punto.objeto</a> .  Se usan activamente en la biblioteca de Nibler Ranges. </p><br><p>  El punto de personalizaci√≥n es una funci√≥n utilizada por la biblioteca est√°ndar para que se pueda sobrecargar para los tipos de usuario en el espacio de nombres del usuario, y estas sobrecargas se pueden encontrar utilizando ADL. </p><br><p>  Los puntos de personalizaci√≥n est√°n dise√±ados con los siguientes principios arquitect√≥nicos en <code>cust</code> ( <code>cust</code> es el nombre de alg√∫n punto de personalizaci√≥n imaginario): </p><br><ul><li>  El c√≥digo que llama a <code>cust</code> escribe en la forma calificada <code>std::cust(a)</code> o en la no calificada: <code>using std::cust; cust(a);</code> <code>using std::cust; cust(a);</code>  .  Ambas entradas deben comportarse de manera id√©ntica.  En particular, deben encontrar cualquier sobrecarga de usuarios en el espacio de nombres asociado con los argumentos. </li><li>  C√≥digo que usa <code>cust</code> en forma de una <code>std::cust; cust(a);</code> <code>std::cust; cust(a);</code>  no deber√≠a poder eludir las restricciones impuestas a <code>std::cust</code> . </li><li>  Las llamadas de punto personalizadas deber√≠an funcionar de manera eficiente y √≥ptima en cualquier compilador bastante moderno. </li><li>  La decisi√≥n no debe crear nuevas infracciones de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Regla de definici√≥n √∫nica (ODR)</a> . </li></ul><br><p>  Para entender de qu√© se trata, puede echar un vistazo al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N4381</a> .  A primera vista, parecen una forma de escribir sus propias versiones de <code>begin</code> , <code>swap</code> , <code>data</code> y similares, y la biblioteca est√°ndar los recoge usando ADL. </p><br><p>  La pregunta es, ¬øc√≥mo difiere esto de la pr√°ctica anterior, cuando el usuario escribe una sobrecarga para que algunos <code>begin</code> por su propio tipo y espacio de nombres?  ¬øY por qu√© son incluso objetos? </p><br><p>  De hecho, estas son instancias de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">objetos funcionales</a> en el <code>std</code> .  Su prop√≥sito es primero extraer comprobaciones de tipo (dise√±adas como conceptos) en todos los argumentos en una fila, y luego enviar la llamada a la funci√≥n correcta en el <code>std</code> o <code>std</code> a la venta en ADL. </p><br><p>  De hecho, este no es el tipo de cosa que usar√≠a en un programa regular que no sea de biblioteca.  Esta es una caracter√≠stica de la biblioteca est√°ndar, que le permitir√° agregar la verificaci√≥n de conceptos en futuros puntos de extensi√≥n, lo que a su vez conducir√° a la visualizaci√≥n de errores m√°s hermosos y comprensibles si arruina algo en las plantillas. </p><br><p>  El enfoque actual de los puntos de personalizaci√≥n tiene un par de problemas.  En primer lugar, es muy f√°cil romperlo todo.  Imagina este c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap(t1, t2); }</code> </pre> <br><p>  Si accidentalmente hacemos una llamada calificada a <code>std::swap(t1, t2)</code> entonces nuestra propia versi√≥n de <code>swap</code> nunca se iniciar√°, sin importar lo que hayamos puesto all√≠.  Pero, lo que es m√°s importante, no hay forma de adjuntar centralmente verificaciones de conceptos a tales implementaciones de funciones personalizadas.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N4381</a> escriben: </p><br><p>  ‚ÄúImagine que alg√∫n d√≠a en el futuro, <code>std::begin</code> requerir√° que su argumento se modele como un concepto <code>Range</code> .  Agregar tal restricci√≥n simplemente no tendr√° ning√∫n efecto en el c√≥digo idiom√°ticamente usando <code>std::begin</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin; begin(a);</code> </pre> <br><p>  Despu√©s de todo, si la llamada de <code>begin</code> se env√≠a a la versi√≥n sobrecargada creada por el usuario, entonces las restricciones en <code>std::begin</code> simplemente se ignoran ". </p><br><p>  La soluci√≥n descrita en el propozal resuelve ambos problemas, para esto utilizamos el enfoque de esta implementaci√≥n especulativa de <code>std::begin</code> (puede ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">godbolt</a> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;utility&gt; namespace my_std { namespace detail { struct begin_fn { /*   ,         begin(arg)  arg.begin().  -   . */ template &lt;class T&gt; auto operator()(T&amp;&amp; arg) const { return impl(arg, 1L); } template &lt;class T&gt; auto impl(T&amp;&amp; arg, int) const requires requires { begin(std::declval&lt;T&gt;()); } { return begin(arg); } // ADL template &lt;class T&gt; auto impl(T&amp;&amp; arg, long) const requires requires { std::declval&lt;T&gt;().begin(); } { return arg.begin(); } // ... }; } //        inline constexpr detail::begin_fn begin{}; }</span></span></span></span></code> </pre> <br><p>  Una llamada calificada de algunos <code>my_std::begin(someObject)</code> siempre pasa por <code>my_std::detail::begin_fn</code> , y eso es bueno.  ¬øQu√© le sucede a una llamada no calificada?  Leamos nuestro peri√≥dico nuevamente: </p><br><p>  ‚ÄúEn el caso de que se llame a begin sin calificaci√≥n inmediatamente despu√©s de la aparici√≥n de <code>my_std::begin</code> dentro del alcance, la situaci√≥n cambia un poco.  En la primera etapa de la b√∫squeda, el nombre <code>begin</code> resolver√° en el objeto global <code>my_std::begin</code> .  Debido a que la b√∫squeda encontr√≥ un objeto, no una funci√≥n, la segunda fase de la b√∫squeda no se realiza.  En otras palabras, si <code>my_std::begin</code> es un objeto, entonces usando la construcci√≥n <code>my_std::detail::begin_fn begin; begin(a);</code> <code>my_std::detail::begin_fn begin; begin(a);</code>  simplemente equivalente a <code>std::begin(a);</code>  "Y como hemos visto, esto lanza ADL personalizado". </p><br><p>  Es por eso que la validaci√≥n de concepto se puede hacer en un objeto de funci√≥n en el <code>std</code> antes de que ADL llame a la funci√≥n proporcionada por el usuario.  No hay forma de enga√±ar a este comportamiento. </p><br><h2 id="kak-kastomiziruyut-tochki-kastomizacii">  ¬øC√≥mo se personalizan los puntos de personalizaci√≥n? </h2><br><p>  De hecho, "objeto de punto de personalizaci√≥n" (CPO) no es un buen nombre.  Por el nombre no est√° claro c√≥mo se expanden, qu√© mecanismos est√°n bajo el cap√≥, qu√© funciones prefieren ... </p><br><p>  Lo que nos lleva al t√©rmino "nibloide".  Un nibloide es un CPO que llama a la funci√≥n X si est√° definida en la clase; de ‚Äã‚Äãlo contrario, llama a la funci√≥n X si hay una funci√≥n libre adecuada; de lo contrario, intenta ejecutar una recuperaci√≥n de la funci√≥n X. </p><br><p>  Entonces, por ejemplo, los <code>ranges::swap</code> nibloides <code>ranges::swap</code> cuando se llaman <code>ranges::swap(a, b)</code> primero intentar√°n llamar a <code>a.swap(b)</code> .  Si no existe tal m√©todo, intentar√° llamar a <code>swap(a, b)</code> usando ADL.  Si esto no funciona, intente <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code>  <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> . </p><br><h1 id="itogi">  Resumen </h1><br><p>  Como Matt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">brome√≥</a> en Twitter, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dave</a> una vez sugiri√≥ hacer que los objetos funcionales "funcionen" con ADL al igual que las funciones normales, por razones de coherencia.  La iron√≠a es que su capacidad para desactivar ADL y ser invisible para √©l ahora se ha convertido en sus principales ventajas. </p><br><p>  Todo este art√≠culo fue una preparaci√≥n para esto. </p><br><p>  " <i><b>Simplemente entend√≠ todo, eso es todo. ¬øMe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escuchas</a> ?</b></i> </p><br><p>  <i><b>¬øAlguna vez has mirado algo, y parec√≠a una locura, y luego en una luz diferente en</b></i> <i><b><br></b></i>  <i><b>¬øLocos verlos normales?</b></i> </p><br><p><img src="https://habrastorage.org/webt/-f/us/rh/-fusrhpdssngql8nlfx2qn0gdd8.jpeg"></p><br><p>  <i><b>No tengas miedo.</b></i>  <i><b>No tengas miedo.</b></i>  <i><b>Me siento muy bien de coraz√≥n.</b></i>  <i><b>Todo estar√° bien</b></i>  <i><b>No me he sentido tan bien por muchos a√±os.</b></i>  <i><b>Todo estar√° bien</b></i> </p><br><p><img src="https://habrastorage.org/webt/pe/ca/az/pecaazhixdkr6dsdxv67ewlvte8.jpeg"></p><br><blockquote>  Minuto de publicidad.  Ya <b>esta semana</b> , del 19 al 20 de abril, se llevar√° a cabo C ++ Rusia 2019, una conferencia llena de presentaciones hardcore tanto en el lenguaje como en temas pr√°cticos como el subprocesamiento m√∫ltiple y el rendimiento.  Por cierto, la conferencia est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">abierta por</a> Nicolai Josuttis, autor de The C ++ Standard Library: A Tutorial and Reference <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> mencionado en el art√≠culo.  Puede familiarizarse con el programa y comprar boletos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web oficial</a> .  Queda muy poco tiempo, esta es la √∫ltima oportunidad. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447900/">https://habr.com/ru/post/447900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447890/index.html">Gracias a Dios no soy gerente</a></li>
<li><a href="../447892/index.html">Dos nuevos concursos PHDays: bypass de IDS y pirater√≠a de f√°brica</a></li>
<li><a href="../447894/index.html">MODX Digest # 3 (25 de marzo - 8 de abril de 2019)</a></li>
<li><a href="../447896/index.html">Im√°genes de bocetos: exactamente c√≥mo funciona la red neuronal GauGAN de NVIDIA</a></li>
<li><a href="../447898/index.html">Fil√≥sofos bien alimentados o programaci√≥n competitiva .NET</a></li>
<li><a href="../447902/index.html">GitHub "elimin√≥" por completo el repositorio de la utilidad del repositorio de bloqueo y toda la cuenta del creador</a></li>
<li><a href="../447904/index.html">Expertos en tecnolog√≠as positivas identifican intentos de explotar en masa la vulnerabilidad cr√≠tica en Confluence</a></li>
<li><a href="../447906/index.html">Innovaciones reales: ¬øqu√© esperar del mercado de centros de datos en 2019?</a></li>
<li><a href="../447908/index.html">Deben funcionar dos formas de obtener recompensas por publicidad en juegos m√≥viles o robots</a></li>
<li><a href="../447910/index.html">El "petr√≥leo" de la econom√≠a moderna y la guerra por el personal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>