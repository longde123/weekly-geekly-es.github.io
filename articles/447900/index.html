<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>锯 ざ 大Ⅲ丑ｓ大 Cerrar contactos ADL   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="驴C贸mo escribir tu nombre en la historia para siempre? 驴El primero en volar a la luna? 驴El primero en encontrarse con una mente extra帽a? Tenemos una ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cerrar contactos ADL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/447900/"><p><img src="https://habrastorage.org/webt/zb/i1/7h/zbi17hhfyu9_oqqmwgpzijon0d8.jpeg"></p><br><p>  驴C贸mo escribir tu nombre en la historia para siempre?  驴El primero en volar a la luna?  驴El primero en encontrarse con una mente extra帽a?  Tenemos una manera m谩s simple: puede adaptarse al est谩ndar de lenguaje C ++. </p><br><p>  Eric Nibler, autor de C ++ Ranges, ofrece un buen ejemplo.  Recuerda esto.  El 19 de febrero de 2019 es el d铆a en que se habl贸 por primera vez el t茅rmino "nibloide" en la reuni贸n del WG21 ", <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escribi贸</a> en Twitter. </p><br><p>  De hecho, si va a CppReference, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la secci贸n cpp / algoritmo / rangoscpp / algoritmo / rangos</a> , encontrar谩 muchas referencias all铆 (niebloid).  Para esto, incluso se ha creado una plantilla wiki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dsc_niebloid</a> separada. </p><br><p>  Desafortunadamente, no encontr茅 ning煤n art铆culo oficial completo sobre este tema y decid铆 escribir el m铆o.  Este es un viaje peque帽o pero fascinante hacia los abismos de la astron谩utica arquitect贸nica, en el que podemos sumergirnos en el abismo de la locura ADL y familiarizarnos con los nibloides. </p><br><p>  Importante: no soy un soldador real, sino un javista que a veces corrige errores en el c贸digo C ++ seg煤n sea necesario.  Si se toma un poco de tiempo para ayudar a encontrar errores en el razonamiento, ser铆a bueno.  "Ayuda a Dasha, el viajero, a recoger algo razonable". </p><a name="habracut"></a><br><h2 id="lookup">  Buscar </h2><br><p>  Primero debes decidir sobre los t茅rminos.  Estas son cosas bien conocidas, pero "lo expl铆cito es mejor que lo impl铆cito", por lo que las discutiremos por separado.  No uso terminolog铆a real en ruso, sino que uso ingl茅s.  Esto es necesario porque incluso la palabra "restricci贸n" en el contexto de este art铆culo puede asociarse con al menos tres versiones en ingl茅s, cuya diferencia es importante para la comprensi贸n. </p><br><p>  Por ejemplo, en C ++ existe el concepto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b煤squeda de nombres</a> o, en otras palabras, una b煤squeda: cuando se encuentra un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nombre</a> en un programa, se compila con su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">declaraci贸n</a> durante la compilaci贸n. </p><br><p> Se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">calificar</a> una b煤squeda (si el nombre est谩 a la derecha del operador de permisos del 谩mbito <code>::</code> :), y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no calificado</a> en otros casos.  Si la b煤squeda es calificada, omitimos los miembros correspondientes de la clase, el espacio de nombres o la enumeraci贸n.  Se podr铆a llamar a esto la versi贸n "completa" del registro (como parece hacerse en la traducci贸n de Straustrup), pero es mejor dejar la ortograf铆a original, porque se refiere a un tipo muy espec铆fico de integridad. </p><br><h2 id="adl">  ADL </h2><br><p>  Si la b煤squeda no est谩 calificada, entonces debemos entender exactamente d贸nde buscar el nombre.  Y aqu铆 se incluye una caracter铆stica especial llamada ADL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b煤squeda dependiente de argumentos</a> , o bien, la b煤squeda de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Koenig</a> (el que acu帽贸 el t茅rmino "antipatr贸n", que es un poco simb贸lico a la luz del siguiente texto).  Nicolai Josuttis en su libro "The C ++ Standard Library: A Tutorial and Reference" lo describe de la siguiente manera: "El punto es que no es necesario calificar el espacio de nombres de la funci贸n si al menos uno de los tipos de argumentos est谩 definido en el espacio de nombres de esta funci贸n". </p><br><p>  驴C贸mo deber铆a ser? </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { //  . //   , operator&lt;&lt;    ,  ADL , //    std    std::operator&lt;&lt;(std::ostream&amp;, const char*) std::cout &lt;&lt; "Test\n"; //    .      -     . operator&lt;&lt;(std::cout, "Test\n"); // same, using function call notation //    : // Error: 'endl' is not declared in this namespace. //      endl(),  ADL  . std::cout &lt;&lt; endl; //  . //    ,       ADL. //     std,   endl      std. endl(std::cout); //    : // Error: 'endl' is not declared in this namespace. //  ,  - (endl) -     . (endl)(std::cout); }</span></span></span></span></code> </pre> <br><h2 id="spuskaemsya-v-ad-s-adl">  Vete al infierno con ADL </h2><br><p>  Parecer铆a simple.  O no?  Primero, dependiendo del tipo de argumento, ADL funciona de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nueve maneras diferentes</a> , para matar con una escoba. </p><br><p>  En segundo lugar, puramente pr谩ctico, imagine que tenemos alg煤n tipo de funci贸n de intercambio.  Resulta que <code>std::swap(obj1,obj2);</code>  y <code>using std::swap; swap(obj1, obj2);</code> <code>using std::swap; swap(obj1, obj2);</code>  puede comportarse de manera completamente diferente.  Si ADL est谩 habilitado, entonces de varios intercambios diferentes, 隆el que necesita ya est谩 seleccionado en funci贸n de los espacios de nombres de los argumentos!  Dependiendo del punto de vista, este modismo puede considerarse tanto un ejemplo positivo como negativo :-) </p><br><p>  Si le parece que esto no es suficiente, puede dejar caer la le帽a en el horno del sombrero.  Esto fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrito</a> recientemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por Arthur O'Dwyer</a> .  Espero que no me castigue por usar su ejemplo. </p><br><p>  Imagine que tiene un programa de este tipo: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  Por supuesto, no se compila con un error: </p><br><pre> <code class="plaintext hljs">error: use of undeclared identifier 'call'; did you mean 'A::call'? call(f); ^~~~ A::call</code> </pre> <br><p>  Pero si agrega una <strong>sobrecarga completamente no utilizada de la</strong> funci贸n <code>f</code> , 隆entonces todo funcionar谩! </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } void f(A::A); // UNUSED int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  En Visual Studio todav铆a se romper谩, pero ese es su destino, no funciona. </p><br><p>  驴C贸mo sucedi贸 esto?  Profundicemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el est谩ndar</a> (sin traducci贸n, porque dicha traducci贸n ser铆a una mezcolanza de palabras de moda excepcionalmente monstruosa): </p><br><blockquote>  Si el argumento es el nombre o la direcci贸n de un conjunto de funciones y / o plantillas de funciones sobrecargadas, sus entidades y espacios de nombres asociados son la uni贸n de los asociados con cada uno de los miembros del conjunto, es decir, las entidades y espacios de nombres asociados con su par谩metro tipos y tipo de retorno.  [...] Adem谩s, si el conjunto de funciones sobrecargadas mencionado anteriormente se nombra con una plantilla-id, sus entidades y espacios de nombres asociados tambi茅n incluyen los de su tipo plantilla-argumentos y su plantilla plantilla-argumentos. </blockquote><p>  Ahora tome un c贸digo como este: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace B { struct B {}; void call(void (*f)()) { f(); } } template&lt;class T&gt; void f() { puts("Hello world"); } int main() { call(f&lt;B::B&gt;); }</span></span></span></span></code> </pre> <br><p>  En ambos casos, se obtienen argumentos que no tienen tipo.  <code>f</code> y <code>f&lt;B::B&gt;</code> son los nombres de los conjuntos de funciones sobrecargadas (de la definici贸n anterior), y dicho conjunto no tiene tipo.  Para colapsar una sobrecarga en una sola funci贸n, debe comprender qu茅 tipo de puntero de funci贸n es m谩s adecuado para la mejor sobrecarga de <code>call</code> .  Por lo tanto, debe recopilar un conjunto de candidatos para la <code>call</code> , lo que significa iniciar una b煤squeda de la <code>call</code> nombre.  隆Y para esto comenzar谩 ADL! </p><br><p>  隆Pero generalmente para ADL debemos conocer los tipos de argumentos!  Y aqu铆 Clang, ICC y MSVC se rompen err贸neamente de la siguiente manera (pero GCC no): </p><br><pre> <code class="cpp hljs">[build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>): error: use of undeclared identifier <span class="hljs-string"><span class="hljs-string">'call'</span></span>; did you mean <span class="hljs-string"><span class="hljs-string">'B::call'</span></span>? [build] call(f&lt;B::B&gt;); [build] ^~~~ [build] B::call [build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>): note: <span class="hljs-string"><span class="hljs-string">'B::call'</span></span> declared here [build] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)())</span></span></span><span class="hljs-function"> </span></span>{ [build] ^</code> </pre> <br><p>  Incluso los creadores de compiladores con ADL tienen una relaci贸n un poco tensa. </p><br><p>  Bueno, 驴ADL todav铆a parece una buena idea?  Por un lado, ya no necesitamos escribir un c贸digo tan servil de una manera educada: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>);</code> </pre> <br><p>  Por otro lado, intercambiamos por brevedad el hecho de que ahora hay un sistema que funciona de una manera completamente inhumana.  Una historia tr谩gica y majestuosa sobre c贸mo la facilidad de escribir Halloworld puede afectar todo el idioma en una escala de d茅cadas. </p><br><h2 id="renzhi-i-koncepty">  Rangos y conceptos </h2><br><p>  Si abre la descripci贸n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la biblioteca de Nibler Rangers</a> , incluso antes de mencionar los nibloides, tropezar谩 con muchos otros marcadores llamados <strong>(concepto)</strong> .  Esto ya es algo bonito, pero por si acaso (para los viejos y los javists) te recordar茅 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lo que es</a> . </p><br><p>  Los conceptos se denominan conjuntos de restricciones con nombre que se aplican a los argumentos de plantilla para seleccionar las mejores sobrecargas de funciones y las especializaciones de plantilla m谩s adecuadas. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasStringFunc = requires(T a) { { to_string(a) } -&gt; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HasStringFunc a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; to_string(a) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Aqu铆 hemos impuesto una restricci贸n de que el argumento debe tener una funci贸n <code>to_string</code> que devuelva una cadena.  Si tratamos de poner alg煤n juego dentro de la <code>print</code> que no est茅 sujeto a las restricciones, entonces dicho c贸digo simplemente no se compilar谩. </p><br><p>  Esto simplifica enormemente el c贸digo.  Por ejemplo, vea c贸mo Nibler <a href="">clasific贸 en rangos-v3</a> , que funciona en C ++ 14/11/17.  Hay un c贸digo maravilloso como este: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT_(X, Y) X ## Y #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT(X, Y) CONCEPT_PP_CAT_(X, Y) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/// \addtogroup group-concepts /// @{ #define CONCEPT_REQUIRES_(...) \ int CONCEPT_PP_CAT(_concept_requires_, __LINE__) = 42, \ typename std::enable_if&lt; \ (CONCEPT_PP_CAT(_concept_requires_, __LINE__) == 43) || (__VA_ARGS__), \ int \ &gt;::type = 0 \ /**/</span></span></span></span></code> </pre> <br><p>  Para que luego puedas hacer: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sortable_</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> I = <span class="hljs-keyword"><span class="hljs-keyword">iterator_t</span></span>&lt;Rng&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requires_() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( concepts::valid_expr( concepts::model_of&lt;concepts::ForwardRange, Rng&gt;(), concepts::is_true(ranges::Sortable&lt;I, C, P&gt;()) )); }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Sortable = concepts::models&lt;Sortable_, Rng, C, P&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, CONCEPT_REQUIRES_(!Sortable&lt;Rng, C, P&gt;())&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(Rng &amp;&amp;, C &amp;&amp; = C{}, P &amp;&amp; = P{}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ...</code> </pre> <br><p>  Espero que ya haya querido ver todo esto y simplemente usar conceptos preparados en un compilador nuevo. </p><br><h2 id="tochki-kastomizacii">  Puntos de personalizaci贸n </h2><br><p>  La siguiente cosa interesante que se puede encontrar en el est谩ndar es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">personalizaci贸n.punto.objeto</a> .  Se usan activamente en la biblioteca de Nibler Ranges. </p><br><p>  El punto de personalizaci贸n es una funci贸n utilizada por la biblioteca est谩ndar para que se pueda sobrecargar para los tipos de usuario en el espacio de nombres del usuario, y estas sobrecargas se pueden encontrar utilizando ADL. </p><br><p>  Los puntos de personalizaci贸n est谩n dise帽ados con los siguientes principios arquitect贸nicos en <code>cust</code> ( <code>cust</code> es el nombre de alg煤n punto de personalizaci贸n imaginario): </p><br><ul><li>  El c贸digo que llama a <code>cust</code> escribe en la forma calificada <code>std::cust(a)</code> o en la no calificada: <code>using std::cust; cust(a);</code> <code>using std::cust; cust(a);</code>  .  Ambas entradas deben comportarse de manera id茅ntica.  En particular, deben encontrar cualquier sobrecarga de usuarios en el espacio de nombres asociado con los argumentos. </li><li>  C贸digo que usa <code>cust</code> en forma de una <code>std::cust; cust(a);</code> <code>std::cust; cust(a);</code>  no deber铆a poder eludir las restricciones impuestas a <code>std::cust</code> . </li><li>  Las llamadas de punto personalizadas deber铆an funcionar de manera eficiente y 贸ptima en cualquier compilador bastante moderno. </li><li>  La decisi贸n no debe crear nuevas infracciones de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Regla de definici贸n 煤nica (ODR)</a> . </li></ul><br><p>  Para entender de qu茅 se trata, puede echar un vistazo al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N4381</a> .  A primera vista, parecen una forma de escribir sus propias versiones de <code>begin</code> , <code>swap</code> , <code>data</code> y similares, y la biblioteca est谩ndar los recoge usando ADL. </p><br><p>  La pregunta es, 驴c贸mo difiere esto de la pr谩ctica anterior, cuando el usuario escribe una sobrecarga para que algunos <code>begin</code> por su propio tipo y espacio de nombres?  驴Y por qu茅 son incluso objetos? </p><br><p>  De hecho, estas son instancias de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">objetos funcionales</a> en el <code>std</code> .  Su prop贸sito es primero extraer comprobaciones de tipo (dise帽adas como conceptos) en todos los argumentos en una fila, y luego enviar la llamada a la funci贸n correcta en el <code>std</code> o <code>std</code> a la venta en ADL. </p><br><p>  De hecho, este no es el tipo de cosa que usar铆a en un programa regular que no sea de biblioteca.  Esta es una caracter铆stica de la biblioteca est谩ndar, que le permitir谩 agregar la verificaci贸n de conceptos en futuros puntos de extensi贸n, lo que a su vez conducir谩 a la visualizaci贸n de errores m谩s hermosos y comprensibles si arruina algo en las plantillas. </p><br><p>  El enfoque actual de los puntos de personalizaci贸n tiene un par de problemas.  En primer lugar, es muy f谩cil romperlo todo.  Imagina este c贸digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap(t1, t2); }</code> </pre> <br><p>  Si accidentalmente hacemos una llamada calificada a <code>std::swap(t1, t2)</code> entonces nuestra propia versi贸n de <code>swap</code> nunca se iniciar谩, sin importar lo que hayamos puesto all铆.  Pero, lo que es m谩s importante, no hay forma de adjuntar centralmente verificaciones de conceptos a tales implementaciones de funciones personalizadas.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N4381</a> escriben: </p><br><p>  Imagine que alg煤n d铆a en el futuro, <code>std::begin</code> requerir谩 que su argumento se modele como un concepto <code>Range</code> .  Agregar tal restricci贸n simplemente no tendr谩 ning煤n efecto en el c贸digo idiom谩ticamente usando <code>std::begin</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin; begin(a);</code> </pre> <br><p>  Despu茅s de todo, si la llamada de <code>begin</code> se env铆a a la versi贸n sobrecargada creada por el usuario, entonces las restricciones en <code>std::begin</code> simplemente se ignoran ". </p><br><p>  La soluci贸n descrita en el propozal resuelve ambos problemas, para esto utilizamos el enfoque de esta implementaci贸n especulativa de <code>std::begin</code> (puede ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">godbolt</a> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;utility&gt; namespace my_std { namespace detail { struct begin_fn { /*   ,         begin(arg)  arg.begin().  -   . */ template &lt;class T&gt; auto operator()(T&amp;&amp; arg) const { return impl(arg, 1L); } template &lt;class T&gt; auto impl(T&amp;&amp; arg, int) const requires requires { begin(std::declval&lt;T&gt;()); } { return begin(arg); } // ADL template &lt;class T&gt; auto impl(T&amp;&amp; arg, long) const requires requires { std::declval&lt;T&gt;().begin(); } { return arg.begin(); } // ... }; } //        inline constexpr detail::begin_fn begin{}; }</span></span></span></span></code> </pre> <br><p>  Una llamada calificada de algunos <code>my_std::begin(someObject)</code> siempre pasa por <code>my_std::detail::begin_fn</code> , y eso es bueno.  驴Qu茅 le sucede a una llamada no calificada?  Leamos nuestro peri贸dico nuevamente: </p><br><p>  En el caso de que se llame a begin sin calificaci贸n inmediatamente despu茅s de la aparici贸n de <code>my_std::begin</code> dentro del alcance, la situaci贸n cambia un poco.  En la primera etapa de la b煤squeda, el nombre <code>begin</code> resolver谩 en el objeto global <code>my_std::begin</code> .  Debido a que la b煤squeda encontr贸 un objeto, no una funci贸n, la segunda fase de la b煤squeda no se realiza.  En otras palabras, si <code>my_std::begin</code> es un objeto, entonces usando la construcci贸n <code>my_std::detail::begin_fn begin; begin(a);</code> <code>my_std::detail::begin_fn begin; begin(a);</code>  simplemente equivalente a <code>std::begin(a);</code>  "Y como hemos visto, esto lanza ADL personalizado". </p><br><p>  Es por eso que la validaci贸n de concepto se puede hacer en un objeto de funci贸n en el <code>std</code> antes de que ADL llame a la funci贸n proporcionada por el usuario.  No hay forma de enga帽ar a este comportamiento. </p><br><h2 id="kak-kastomiziruyut-tochki-kastomizacii">  驴C贸mo se personalizan los puntos de personalizaci贸n? </h2><br><p>  De hecho, "objeto de punto de personalizaci贸n" (CPO) no es un buen nombre.  Por el nombre no est谩 claro c贸mo se expanden, qu茅 mecanismos est谩n bajo el cap贸, qu茅 funciones prefieren ... </p><br><p>  Lo que nos lleva al t茅rmino "nibloide".  Un nibloide es un CPO que llama a la funci贸n X si est谩 definida en la clase; de lo contrario, llama a la funci贸n X si hay una funci贸n libre adecuada; de lo contrario, intenta ejecutar una recuperaci贸n de la funci贸n X. </p><br><p>  Entonces, por ejemplo, los <code>ranges::swap</code> nibloides <code>ranges::swap</code> cuando se llaman <code>ranges::swap(a, b)</code> primero intentar谩n llamar a <code>a.swap(b)</code> .  Si no existe tal m茅todo, intentar谩 llamar a <code>swap(a, b)</code> usando ADL.  Si esto no funciona, intente <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code>  <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> . </p><br><h1 id="itogi">  Resumen </h1><br><p>  Como Matt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">brome贸</a> en Twitter, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dave</a> una vez sugiri贸 hacer que los objetos funcionales "funcionen" con ADL al igual que las funciones normales, por razones de coherencia.  La iron铆a es que su capacidad para desactivar ADL y ser invisible para 茅l ahora se ha convertido en sus principales ventajas. </p><br><p>  Todo este art铆culo fue una preparaci贸n para esto. </p><br><p>  " <i><b>Simplemente entend铆 todo, eso es todo. 驴Me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escuchas</a> ?</b></i> </p><br><p>  <i><b>驴Alguna vez has mirado algo, y parec铆a una locura, y luego en una luz diferente en</b></i> <i><b><br></b></i>  <i><b>驴Locos verlos normales?</b></i> </p><br><p><img src="https://habrastorage.org/webt/-f/us/rh/-fusrhpdssngql8nlfx2qn0gdd8.jpeg"></p><br><p>  <i><b>No tengas miedo.</b></i>  <i><b>No tengas miedo.</b></i>  <i><b>Me siento muy bien de coraz贸n.</b></i>  <i><b>Todo estar谩 bien</b></i>  <i><b>No me he sentido tan bien por muchos a帽os.</b></i>  <i><b>Todo estar谩 bien</b></i> </p><br><p><img src="https://habrastorage.org/webt/pe/ca/az/pecaazhixdkr6dsdxv67ewlvte8.jpeg"></p><br><blockquote>  Minuto de publicidad.  Ya <b>esta semana</b> , del 19 al 20 de abril, se llevar谩 a cabo C ++ Rusia 2019, una conferencia llena de presentaciones hardcore tanto en el lenguaje como en temas pr谩cticos como el subprocesamiento m煤ltiple y el rendimiento.  Por cierto, la conferencia est谩 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">abierta por</a> Nicolai Josuttis, autor de The C ++ Standard Library: A Tutorial and Reference <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> mencionado en el art铆culo.  Puede familiarizarse con el programa y comprar boletos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web oficial</a> .  Queda muy poco tiempo, esta es la 煤ltima oportunidad. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447900/">https://habr.com/ru/post/447900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447890/index.html">Gracias a Dios no soy gerente</a></li>
<li><a href="../447892/index.html">Dos nuevos concursos PHDays: bypass de IDS y pirater铆a de f谩brica</a></li>
<li><a href="../447894/index.html">MODX Digest # 3 (25 de marzo - 8 de abril de 2019)</a></li>
<li><a href="../447896/index.html">Im谩genes de bocetos: exactamente c贸mo funciona la red neuronal GauGAN de NVIDIA</a></li>
<li><a href="../447898/index.html">Fil贸sofos bien alimentados o programaci贸n competitiva .NET</a></li>
<li><a href="../447902/index.html">GitHub "elimin贸" por completo el repositorio de la utilidad del repositorio de bloqueo y toda la cuenta del creador</a></li>
<li><a href="../447904/index.html">Expertos en tecnolog铆as positivas identifican intentos de explotar en masa la vulnerabilidad cr铆tica en Confluence</a></li>
<li><a href="../447906/index.html">Innovaciones reales: 驴qu茅 esperar del mercado de centros de datos en 2019?</a></li>
<li><a href="../447908/index.html">Deben funcionar dos formas de obtener recompensas por publicidad en juegos m贸viles o robots</a></li>
<li><a href="../447910/index.html">El "petr贸leo" de la econom铆a moderna y la guerra por el personal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>