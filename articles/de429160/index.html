<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ§ üö¥üèº ‚ÜòÔ∏è Nintendo DS Console GPUs und interessante Funktionen üìÄ üßúüèø üåï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich m√∂chte Sie √ºber den Betrieb der Nintendo DS-GPU-Konsole und ihre Unterschiede zu modernen GPUs informieren und meine Meinung dazu √§u√üern, warum di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nintendo DS Console GPUs und interessante Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429160/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/yy/rg/ucyyrgszova3-3kx-wpaxjbonwk.jpeg"></div><br>  Ich m√∂chte Sie √ºber den Betrieb der Nintendo DS-GPU-Konsole und ihre Unterschiede zu modernen GPUs informieren und meine Meinung dazu √§u√üern, warum die Verwendung von Vulkan anstelle von OpenGL in Emulatoren keine Vorteile bringt. <br><br>  Ich kenne Vulkan nicht wirklich, aber nach dem, was ich gelesen habe, ist mir klar, dass Vulkan sich von OpenGL dadurch unterscheidet, dass es auf einer niedrigeren Ebene funktioniert und es Programmierern erm√∂glicht, den GPU-Speicher und √§hnliche Dinge zu verwalten.  Dies kann n√ºtzlich sein, um modernere Konsolen zu emulieren, die propriet√§re grafische APIs verwenden, die Kontrollstufen bieten, die in OpenGL nicht verf√ºgbar sind. <br><a name="habracut"></a><br>  Beispiel: blargSNES-Hardware-Renderer - einer seiner Tricks besteht darin, dass bei einigen Vorg√§ngen mit unterschiedlichen Farbpuffern ein Tiefen- / Schablonenpuffer verwendet wird.  In OpenGL ist dies nicht m√∂glich. <br><br>  Dar√ºber hinaus verbleibt weniger M√ºll zwischen der Anwendung und der GPU, was bedeutet, dass bei korrekter Implementierung die Leistung h√∂her ist.  W√§hrend OpenGL-Treiber voller Optimierungen f√ºr Standardanwendungsf√§lle und sogar f√ºr bestimmte Spiele sind, sollte in Vulkan die Anwendung selbst zun√§chst gut geschrieben sein. <br><br>  Das hei√üt im Wesentlichen: "Gro√üe Verantwortung geht mit gro√üer Kraft einher." <br><br>  Ich bin kein 3D-API-Spezialist. Kommen wir also darauf zur√ºck.  Was ich gut wei√ü: GPU-Konsole DS. <br><br>  Es wurden bereits mehrere Artikel √ºber seine einzelnen Teile geschrieben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber seine ausgekl√ºgelten Quads</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber Unsinn mit Ansichtsfenster</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber die unterhaltsamen Funktionen des Rasterisierers</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber die erstaunliche Implementierung von Anti-Aliasing</a> ), aber in diesem Artikel werden wir das Ger√§t als Ganzes betrachten, aber mit all den saftigen Details.  Zumindest ist das alles, was wir wissen. <br><br>  Die GPU selbst ist eine ziemlich alte und veraltete Hardware.  Es ist auf 2048 Polygone und / oder 6144 Eckpunkte pro Frame begrenzt.  Die Aufl√∂sung betr√§gt 256x192.  Selbst wenn Sie dies vervierfachen, ist die Leistung kein Problem.  Unter optimalen Bedingungen kann DS bis zu 122880 Polygone pro Sekunde ausgeben, was nach den Standards moderner GPUs l√§cherlich ist. <br><br>  Kommen wir nun zu den Details der GPU.  Oberfl√§chlich betrachtet sieht es ziemlich normal aus, aber tief in seiner Arbeit unterscheidet es sich stark von der Arbeit moderner GPUs, was die Emulation einiger Funktionen komplizierter macht. <br><br>  Die GPU ist in zwei Teile unterteilt: eine Geometrie-Engine und eine Rendering-Engine.  Die Geometrie-Engine verarbeitet die resultierenden Scheitelpunkte, erstellt Polygone und transformiert sie, sodass Sie sie an die Rendering-Engine √ºbergeben k√∂nnen, die (Sie haben es erraten) alles auf dem Bildschirm zeichnet. <br><br><h2>  Geometrie-Engine </h2><br>  Ziemlich normaler geometrischer F√∂rderer. <br><br>  Es ist erw√§hnenswert, dass alle Arithmetik in Festkomma-Ganzzahlen ausgef√ºhrt wird, da DS keine Gleitkommazahlen unterst√ºtzt. <br><br>  Die Geometrie-Engine wird vollst√§ndig programmgesteuert emuliert (GPU3D.cpp), das hei√üt, sie gilt nicht f√ºr das, was wir zum Rendern von Grafiken verwenden, aber ich werde Ihnen trotzdem mehr dar√ºber erz√§hlen. <br><br>  1. Transformation und Beleuchtung.  Die resultierenden Eckpunkte und Texturkoordinaten werden unter Verwendung von S√§tzen von 4x4-Matrizen konvertiert.  Zus√§tzlich zu den Scheitelpunktfarben wird die Beleuchtung angewendet.  Hier ist alles ziemlich normal, der einzige Nicht-Standard ist, wie Texturkoordinaten funktionieren (1.0 = ein DS-Texel).  Erw√§hnenswert ist auch das gesamte System der Matrixstapel, bei denen es sich in gewissem Ma√üe um die Hardware-Implementierung von glPushMatrix () handelt. <br><br>  2. Polygone konfigurieren.  Die konvertierten Eckpunkte werden zu Polygonen zusammengesetzt, die Dreiecke, Vierecke (Quads), Dreiecksstreifen oder Viereckstreifen sein k√∂nnen.  Quads werden nativ verarbeitet und nicht in Dreiecke konvertiert, was ziemlich problematisch ist, da moderne GPUs nur Dreiecke unterst√ºtzen.  Es sieht jedoch so aus, als h√§tte jemand <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine L√∂sung gefunden</a> , die ich testen muss. <br><br>  3. Lassen Sie fallen.  Polygone k√∂nnen abh√§ngig von der Ausrichtung auf dem Bildschirm und dem ausgew√§hlten Keulungsmodus entsorgt werden.  Auch ziemlich Standardschema.  Ich muss jedoch herausfinden, wie dies f√ºr Quads funktioniert. <br><br>  4. K√ºrzung.  Polygone, die √ºber den Sichtbarkeitsbereich hinausgehen, werden eliminiert.  Polygone, die sich teilweise √ºber diesen Bereich hinaus erstrecken, werden abgeschnitten.  In diesem Schritt werden keine neuen Polygone erstellt, sondern vorhandene Scheitelpunkte hinzugef√ºgt.  Tats√§chlich kann jede der 6 K√ºrzungsebenen dem Polygon einen Scheitelpunkt hinzuf√ºgen, dh als Ergebnis k√∂nnen bis zu 10 Scheitelpunkte erhalten werden.  Im Abschnitt √ºber die Rendering-Engine werde ich Ihnen erkl√§ren, wie wir damit umgegangen sind. <br><br>  5. In Ansichtsfenster konvertieren.  X / Y-Koordinaten werden in Bildschirmkoordinaten konvertiert.  Z-Koordinaten werden konvertiert, um in ein 24-Bit-Tiefenpufferintervall zu passen. <br><br>  Interessant ist, wie die W-Koordinaten verarbeitet werden: Sie werden ‚Äûnormalisiert‚Äú, um in ein 16-Bit-Intervall zu passen.  Dazu wird jede W-Koordinate des Polygons genommen, und wenn sie gr√∂√üer als 0xFFFF ist, wird sie um 4 Positionen nach rechts verschoben, um in 16 Bit zu passen.  Wenn umgekehrt die Koordinate kleiner als 0x1000 ist, bewegt sie sich nach links, bis sie in das Intervall f√§llt.  Ich nehme an, dass dies notwendig ist, um gute Intervalle zu erhalten, was eine gr√∂√üere Genauigkeit w√§hrend der Interpolation bedeutet. <br><br>  6. Sortieren.  Polygone werden so sortiert, dass zuerst durchscheinende Polygone gezeichnet werden.  Dann werden sie nach ihren Y-Koordinaten (yeah) sortiert, was f√ºr undurchsichtige und optional durchscheinende Polygone erforderlich ist. <br><br>  Dies ist au√üerdem der Grund f√ºr die Einschr√§nkung von 2048 Polygonen: Zum Sortieren m√ºssen sie irgendwo gespeichert werden.  Es gibt zwei interne Speicherb√§nke zum Speichern von Polygonen und Scheitelpunkten.  Es gibt sogar ein Register, das angibt, wie viele Polygone und Eckpunkte gespeichert sind. <br><br><h2>  Motor rendern </h2><br>  Und hier beginnt der Spa√ü! <br><br>  Nachdem alle Polygone konfiguriert und sortiert wurden, funktioniert die Rendering-Engine. <br><br>  Das erste lustige ist, wie es die Polygone f√ºllt.  Dies ist v√∂llig anders als bei modernen GPUs, die das F√ºllen von Kacheln durchf√ºhren und dreieckoptimierte Algorithmen verwenden.  Ich wei√ü nicht, wie sie alle funktionieren, aber ich habe gesehen, wie dies in der 3DS-Konsolen-GPU gemacht wird, und alles basiert auf Kacheln. <br><br>  Wie auch immer, unter DS erfolgt das Rendern in Rasterzeichenfolgen.  Die Entwickler mussten dies tun, damit das Rendern parallel zu den zweidimensionalen Kachel-Engines der alten Schule durchgef√ºhrt werden konnte, die das Zeichnen auf Rasterlinien ausf√ºhren.  Es gibt einen kleinen Puffer mit 48 Rasterzeilen, mit dem einige Rasterzeilen angepasst werden k√∂nnen. <br><br>  Ein Rasterizer ist ein Renderer von konvexen Polygonen, die auf Rasterzeichenfolgen basieren.  Es kann eine beliebige Anzahl von Eckpunkten verarbeiten.  Es kann falsch gerendert werden, wenn Sie Polygone √ºbergeben, die nicht konvex sind oder sich schneidende Kanten haben, zum Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ul/ts/vd/ultsvdezpi2riupyjponrg--exq.png"></div><br>  <i>Das Polygon ist ein Schmetterling.</i>  <i>Alles ist richtig und gro√üartig.</i> <br><br>  Aber was ist, wenn wir es umdrehen? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t0/z-/48/t0z-48rfmcp8ndjpebeydxaof08.png"></div><br>  <i>Autsch.</i> <br><br>  Was ist der Fehler hier?  Zeichnen wir den Umriss des urspr√ºnglichen Polygons, um Folgendes herauszufinden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nl/mj/tx/nlmjtxlv9qeennvaulabodzsnu0.png"></div><br>  Ein Renderer kann nur eine L√ºcke pro Rasterzeile f√ºllen.  Es definiert die linken und rechten Kanten beginnend mit den h√∂chsten Spitzen und folgt diesen Kanten, bis es auf neue Spitzen trifft. <br><br>  In dem oben gezeigten Bild beginnt er am obersten Scheitelpunkt, dh oben links, und f√ºllt sich weiter, bis er das Ende des linken Randes erreicht (unterer linker Scheitelpunkt).  Er wei√ü nicht, dass sich die Kanten schneiden. <br><br>  Zu diesem Zeitpunkt sucht er nach dem n√§chsten Scheitelpunkt an seiner linken Kante.  Es ist interessant festzustellen, dass er wei√ü, dass er keine Eckpunkte nehmen muss, die h√∂her als der aktuelle sind, und dass der linke und der rechte Rand vertauscht sind.  Daher f√ºllt es sich bis zum Ende der Deponie weiter. <br><br>  Ich w√ºrde noch einige Beispiele f√ºr nicht konvexe Polygone hinzuf√ºgen, aber wir werden zu weit vom Thema abweichen. <br><br>  Lassen Sie uns besser verstehen, wie Gouraud-Schattierungen und -Texturen mit einer beliebigen Anzahl von Scheitelpunkten funktionieren.  Es gibt baryzentrische Algorithmen, die zum Interpolieren von Daten entlang eines Dreiecks verwendet werden, aber ... in unserem Fall sind sie nicht geeignet. <br><br>  Der DS-Renderer hat hier auch eine eigene Implementierung.  Noch ein paar interessante Bilder. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p0/-l/qm/p0-lqmqqcinmjrvlzjiw_fsvh5w.png"></div><br>  Die Eckpunkte des Polygons sind die Punkte 1, 2, 3 und 4. Die Zahlen entsprechen nicht der tats√§chlichen Durchquerungsreihenfolge, aber Sie verstehen die Bedeutung. <br><br>  In der aktuellen Rasterlinie definiert der Renderer die Scheitelpunkte, die die Kanten direkt umgeben (wie oben erw√§hnt, beginnt er an den obersten Scheitelpunkten und geht dann durch die Kanten, bis sie vollst√§ndig sind).  In unserem Fall sind dies die Eckpunkte 1 und 2 f√ºr den linken Rand, 3 und 4 f√ºr den rechten Rand. <br><br>  Die Steigungen der Kanten werden verwendet, um die Grenzen der L√ºcke zu bestimmen, dh die Punkte 5 und 6. An diesen Punkten werden die Attribute der Scheitelpunkte basierend auf den vertikalen Positionen in den Kanten (oder horizontalen Positionen f√ºr Kanten, deren Steigungen haupts√§chlich entlang der X-Achse liegen) interpoliert. <br><br>  Dann werden f√ºr jedes Pixel in der L√ºcke (zum Beispiel f√ºr Punkt 7) Attribute basierend auf der X-Position innerhalb der L√ºcke aus den zuvor an den Punkten 5 und 6 berechneten Attributen interpoliert. <br><br>  Hier sind alle verwendeten Koeffizienten gleich 50%, um die Arbeit zu vereinfachen, aber die Bedeutung ist klar. <br><br>  Ich werde nicht auf die Details der Attributinterpolation eingehen, obwohl es auch interessant sein wird, dar√ºber zu schreiben.  Tats√§chlich ist dies aus perspektivischer Sicht eine korrekte Interpolation, weist jedoch interessante Vereinfachungen und Merkmale auf. <br><br>  Lassen Sie uns nun dar√ºber sprechen, wie DS die Polygone f√ºllt. <br><br>  Welche F√ºllregeln verwendet er?  Hier gibt es auch viele interessante Dinge! <br><br>  Erstens gibt es unterschiedliche F√ºllregeln f√ºr undurchsichtige und durchscheinende Polygone.  Vor allem aber gelten diese Regeln <i>Pixel f√ºr Pixel</i> .  Durchscheinende Polygone k√∂nnen undurchsichtige Pixel haben und folgen denselben Regeln wie undurchsichtige Polygone.  Sie k√∂nnen davon ausgehen, dass zum Emulieren solcher Tricks auf modernen GPUs mehrere Rendering-Durchg√§nge erforderlich sind. <br><br>  Dar√ºber hinaus k√∂nnen verschiedene Polygonattribute das Rendern auf verschiedene interessante Arten beeinflussen.  Zus√§tzlich zu den Standard-Farb- und Tiefenpuffern verf√ºgt der Renderer √ºber <i>einen Attributpuffer</i> , der alle m√∂glichen interessanten Dinge verfolgt.  N√§mlich: die Polygon-ID (getrennt f√ºr undurchsichtige und durchscheinende Polygone), die Pixel-Transluzenz, die Notwendigkeit, Nebel anzuwenden, ob dieses Polygon zur oder von der Kamera gerichtet ist (ja, auch dies) und ob sich das Pixel am Rand des Polygons befindet.  Und vielleicht noch etwas. <br><br>  Die Aufgabe, ein solches System zu emulieren, wird nicht trivial sein.  Eine gew√∂hnliche moderne GPU hat einen Schablonenpuffer, der auf 8 Bit begrenzt ist, was bei weitem nicht ausreicht f√ºr alles, was einen Attributpuffer speichern kann.  Wir m√ºssen eine schwierige Problemumgehung finden. <br><br>  Lassen Sie es uns herausfinden: <br><br>  * Aktualisierung des Tiefenpuffers: Erforderlich f√ºr undurchsichtige Pixel, optional f√ºr durchscheinende Pixel. <br><br>  * Polygon-IDs: 6-Bit-IDs werden Polygonen zugewiesen, die f√ºr verschiedene Zwecke verwendet werden k√∂nnen.  Undurchsichtige Polygon-IDs werden zum Markieren von Kanten verwendet.  Die ID von durchscheinenden Polygonen kann verwendet werden, um zu steuern, wo sie gezeichnet werden: Ein durchscheinendes Pixel wird nicht gezeichnet, wenn die Polygon-ID mit der ID des durchscheinenden Polygons √ºbereinstimmt, das sich bereits im Attributpuffer befindet.  Au√üerdem werden beide Polygon-IDs in √§hnlicher Weise zur Steuerung des Schatten-Renderings verwendet.  Sie k√∂nnen beispielsweise einen Schatten erstellen, der den Boden bedeckt, nicht jedoch den Charakter. <br><br>  (Hinweis: Schatten sind nur eine Implementierung des Schablonenpuffers, hier gibt es nichts Schreckliches.) <br><br>  Es ist zu beachten, dass beim Rendern von durchscheinenden Pixeln die vorhandene ID des undurchsichtigen Polygons sowie die Kantenflags des letzten undurchsichtigen Polygons gespeichert werden. <br><br>  * Nebelflag: Legt fest, ob f√ºr dieses Pixel ein Nebelpass angewendet werden soll.  Der Aktualisierungsprozess h√§ngt davon ab, ob das eingehende Pixel undurchsichtig oder durchscheinend ist. <br><br>  * Flagge der Front: Hier gibt es Probleme damit.  Schauen Sie sich den Screenshot an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hb/8m/pb/hb8mpbdxkcher7n0xmaocay2j_4.png"></div><br>  Sands of Destruction, die Bildschirme dieses Spiels sind eine Reihe von Tricks.  Sie √§ndern nicht nur ihre Y-Koordinaten, um die Y-Sortierung zu beeinflussen.  Der in diesem Screenshot gezeigte Bildschirm ist wahrscheinlich der schlechteste. <br><br>  Es wird der Grenzfall des Tiefentests verwendet: Die Vergleichsfunktion "kleiner als" <b>nimmt gleiche Werte an,</b> wenn das Spiel <i>ein Polygon zeichnet, das die Kamera √ºber den undurchsichtigen Pixeln des von der Kamera weggerichteten Polygons betrachtet</i> .  Ja genau.  Und die Z-Werte aller Polygone sind Null.  Wenn Sie diese Funktion nicht emulieren, fehlen einige Elemente auf dem Bildschirm. <br><br>  Ich denke, dass dies so gemacht wurde, dass die Vorderseite des Objekts immer √ºber der R√ºckseite sichtbar war, selbst wenn sie so flach sind, dass die Z-Werte gleich sind.  Mit all diesen Hacks und Tricks √§hnelt der DS-Renderer der Hardwareversion der DOS-Renderer. <br><br>  Wie dem auch sei, es war schwierig, dieses Verhalten √ºber die GPU zu emulieren.  Es gibt jedoch auch andere √§hnliche Grenzf√§lle f√ºr Tiefenpr√ºfungen, die ebenfalls gepr√ºft und dokumentiert werden m√ºssen. <br><br>  * Rippenflags: Der Renderer verfolgt die Position der Kanten von Polygonen.  Sie werden in den letzten Durchg√§ngen verwendet, n√§mlich beim Markieren von Kanten und beim Anti-Aliasing.  Es gibt auch spezielle Regeln zum F√ºllen undurchsichtiger Polygone mit deaktiviertem Anti-Aliasing.  Das folgende Diagramm veranschaulicht diese Regeln: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/pu/hf/eypuhfe9rghuhobfo1r9njkt4wy.png"></div><br>  Hinweis: Drahtgitter werden gerendert, indem nur die Kanten gef√ºllt werden!  Sehr kluger Schachzug. <br><br>  Ein weiterer lustiger Hinweis zur Tiefenpufferung: <br><br>  Bei DS gibt es zwei m√∂gliche Tiefenpufferungsmodi: Z-Pufferung und W-Pufferung.  Dies scheint ziemlich normal zu sein, aber nur, wenn Sie nicht auf Details eingehen. <br><br>  * Bei der Z-Pufferung werden Z-Koordinaten verwendet, die so konvertiert wurden, dass sie in ein 24-Bit-Tiefenpufferintervall passen.  Z-Koordinaten werden linear √ºber Polygone interpoliert (mit einigen Kuriosit√§ten, aber sie sind nicht besonders wichtig).  Auch hier gibt es nichts Ungew√∂hnliches. <br><br>  * Bei der W-Pufferung werden W-Koordinaten "wie sie sind" verwendet.  Moderne GPUs verwenden normalerweise 1 / W, aber DS verwendet nur Festkomma-Arithmetik, so dass die Verwendung von reziproken Werten nicht sehr praktisch ist.  Wie auch immer, in diesem Modus werden die W-Koordinaten mit perspektivischer Korrektur interpoliert. <br><br>  So sehen die endg√ºltigen Rendering-Durchg√§nge aus: <br><br>  * Kantenmarkierung: Pixel, f√ºr die Kantenflags gesetzt sind, erhalten eine Farbe aus der Tabelle, die anhand der ID eines undurchsichtigen Polygons bestimmt wird. <br><br>  Sie sind farbige Kanten von Polygonen.  Es ist anzumerken, dass die Kanten des Polygons immer noch farbig sind, wenn ein durchscheinendes Polygon √ºber ein undurchsichtiges Polygon gezeichnet wird. <br><br>  Ein Nebeneffekt des K√ºrzungsprinzips: Die R√§nder, an denen sich Polygone mit den R√§ndern des Bildschirms schneiden, werden ebenfalls farbig.  Dies k√∂nnen Sie beispielsweise in den Screenshots von Picross 3D feststellen. <br><br>  * Nebel: Wird auf jedes Pixel angewendet, basierend auf den Tiefenwerten, die zum Indizieren der Nebeldichtetabelle verwendet werden.  Wie Sie vielleicht erraten haben, gilt dies f√ºr Pixel, f√ºr die im Attributpuffer Nebelflags gesetzt sind. <br><br>  * Antialiasing (Gl√§ttung): Wird auf die Kanten von (undurchsichtigen) Polygonen angewendet.  Basierend auf den Steigungen der Kanten beim Rendern von Polygonen werden die Pixelabdeckungswerte berechnet.  Im letzten Durchgang werden diese Pixel mit den Pixeln darunter gemischt, wobei der schwierige Mechanismus verwendet wird, den ich in einem fr√ºheren Beitrag beschrieben habe. <br><br>  Antialiasing sollte auf der GPU nicht auf diese Weise emuliert werden (und kann es auch nicht), daher ist dies hier nicht wichtig. <br><br>  Wenn Kantenmarkierung und Anti-Aliasing auf dieselben Pixel angewendet werden sollen, erhalten sie nur die Kantengr√∂√üe, jedoch mit einer Deckkraft von 50%. <br><br>  Ich habe den Renderprozess mehr oder weniger gut beschrieben.  Wir haben uns nicht mit dem Mischen von Texturen (Kombinieren von Scheitelpunkt- und Texturfarben) befasst, aber es kann in einem Fragment-Shader emuliert werden.  Gleiches gilt f√ºr Kantenmarkierung und Nebel, sofern wir mit einem Attributpuffer einen Weg um das gesamte System finden. <br><br>  Aber im Allgemeinen wollte ich Folgendes vermitteln: OpenGL oder Vulkan (sowie Direct3D oder Glide oder irgendetwas anderes) werden hier nicht helfen.  Unsere modernen GPUs haben mehr als genug Leistung, um mit rohen Polygonen zu arbeiten.  Das Problem sind die Details und Merkmale der Rasterung.  Und es geht nicht einmal um die Idealit√§t der Pixel. Schauen Sie sich zum Beispiel den Issue-Tracker des DeSmuME-Emulators an, um zu verstehen, auf welche Probleme Entwickler beim Rendern √ºber OpenGL sto√üen.  Wir m√ºssen uns auch irgendwie mit diesen Problemen auseinandersetzen. <br><br>  Ich stelle auch fest, dass wir mit OpenGL den Emulator beispielsweise auf Switch portieren k√∂nnen (weil ein Github-Benutzer namens Hydr8gon damit begonnen hat, einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Port f√ºr unseren Emulator auf Switch zu</a> erstellen). <br><br>  Also ... w√ºnsche mir viel Gl√ºck. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429160/">https://habr.com/ru/post/de429160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429150/index.html">Verwalten Ihrer Module f√ºr CMS mit Composer</a></li>
<li><a href="../de429152/index.html">Android-Navigationskomponente. Einfache Dinge, die Sie selbst tun m√ºssen</a></li>
<li><a href="../de429154/index.html">Zweitabrechnung, Marktplatz und Sandboxes f√ºr Big Data: Was k√∂nnen Testumgebungen in der Cloud tun?</a></li>
<li><a href="../de429156/index.html">Die ganze Wahrheit √ºber RTOS. Artikel Nr. 19. Semaphoren: Einf√ºhrung und Grundversorgung</a></li>
<li><a href="../de429158/index.html">Das Impostor-Syndrom betrifft M√§nner nicht weniger als Frauen ... und andere Ergebnisse aus 10.000 technischen Interviews</a></li>
<li><a href="../de429162/index.html">‚ÄûUm √Ñnderungen vorzunehmen, verstehen Sie, warum Menschen sich dagegen wehren‚Äú: Jim Holmes √ºber das Testen der Kultur</a></li>
<li><a href="../de429166/index.html">Multikristall: Von der Geschichte bis zur Spekulation √ºber die Zukunft</a></li>
<li><a href="../de429168/index.html">Durch Feuer und Wasser: die Geschichte der russischen popul√§rwissenschaftlichen Literatur</a></li>
<li><a href="../de429172/index.html">1C auf Proxmox. Allgemeine Hinweise</a></li>
<li><a href="../de429174/index.html">BlueStacks 4: Testen auf schwache Hardware + Entwicklerkommentare</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>