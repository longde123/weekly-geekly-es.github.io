<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò≠ ‚ôíÔ∏è üë° Wie man eine teure Kamera knackt, damit deine Frau dich nicht umbringt üòû üöÉ ‚úçüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haftungsausschluss: Die Studie begann im Jahr 2013. Wenn Sie also einige Methoden f√ºr dumm und gef√§hrlich halten, haben Sie Recht, das war es. Dabei h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man eine teure Kamera knackt, damit deine Frau dich nicht umbringt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438168/"> <i>Haftungsausschluss: Die Studie begann im Jahr 2013. Wenn Sie also einige Methoden f√ºr dumm und gef√§hrlich halten, haben Sie Recht, das war es.</i>  <i>Dabei habe ich jedoch viel gelernt.</i> <br><br>  <b>Eintrag</b> <br>  Alles begann einige Monate vor der Geburt meines ersten Kindes.  Meine Frau und ich wollten immer eine coole Leica-Kamera kaufen und stellten pl√∂tzlich fest, dass wir es lange Zeit nicht tun konnten, wenn wir es jetzt nicht kauften.  Deshalb haben wir die M240 Kamera bestellt und ... Boom, wir wurden f√ºr sechs Monate in die Schlange gestellt.  Bald hatte ich es satt zu warten und fing an, ihre Seite zu studieren.  Meine Aufmerksamkeit wurde sofort auf den Dateibereich gelenkt.  Nun, Sie k√∂nnen sich vorstellen, warum ... Firmware! <br><br>  Ich habe eine unverschl√ºsselte und unkomprimierte Datei ( <code>m8-2_005.upd</code> ) gesehen, die mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PWAD Magic</a> beginnt.  Erkennst du  Ja, das stimmt, das ist das Doom Patch WAD-Format.  Jungs scheinen die Klassiker zu lieben.  Das Format ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sehr gut dokumentiert</a> , so dass es nicht schwierig war, es zu analysieren. <br><a name="habracut"></a><br><h1>  Leica Firmware-Dateien </h1><br><h3>  Firmware Leica M8 </h3><br>  Das ist eigentlich sehr lustig, denn als ich sp√§ter die komprimierte Leica T-Firmware-Datei studierte, beschloss ich zun√§chst, die Komprimierungsmethoden zu testen, die id Software in der Vergangenheit verwendet hat. <br><br>  Wikipedia sagt, dass sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das LHA-Format verwendet haben</a> , das im Wesentlichen LZW ist.  Da g√§ngige LZW-Dekompressoren jedoch nicht passten, suchte ich nach einer bestimmten Implementierung der ID-Software - und voila fand ich <a href="">Catacomb Armageddon</a> in der <a href="">Quelle</a> .  Ich muss zugeben, gl√ºcklich. <br><br>  Auf jeden Fall zur√ºck zum M8.  Hier ist die Firmware-Struktur: <br><br><pre>  REGELN: 0x0000008C (3036: 0x00000BDC) - XML-Beschreibung
 LUTS: 0x00000C68 (183274: 0x0002CBEA)
  GAMMA: 0x0000007C (31760: 0x00007C10)
  GEWINN: 0x00007C8C (50344: 0x0000C4A8)
  LEICA: 0x00014134 (7000: 0x00001B58)
  BLEMISH: 0x00015C8C (250: 0x000000FA)
  WREF: 0x00015D88 (82480: 0x00014230)
  OBJ: 0x00029FB8 (11268: 0x00002C04)
  VERSION: 0x0002CBBC (46: 0x0000002E)
 PXA: 0x0002D854 (858384: 0x000D1910)
 BF: 0x000FF164 (134522: 0x00020D7A) - Blackfin-Prozessorfamilie f√ºr analoge Ger√§te
 GUI: 0x0011FEE0 (3574180: 0x003689A4)
  TRANS: 0x0000005C (59988: 0x0000EA54) - Lokalisierung
  BILDER: 0x0000EAB0 (267433: 0x000414A9)
   21_1PRT: 0x000000CC (18411: 0x000047EB) - Bild von JFIF
   21_2GRP: 0x000048B8 (23172: 0x00005A84) - Bild von JFIF
   21_3PAN: 0x0000A33C (23034: 0x000059FA) - Bild von JFIF
   24_1PRT: 0x0000FD38 (18489: 0x00004839) - Bild von JFIF
   24_2GRP: 0x00014574 (23230: 0x00005ABE) - Bild von JFIF
   24_3PAN: 0x0001A034 (22998: 0x000059D6) - Bild von JFIF
   28_1PRT: 0x0001FA0C (22605: 0x0000584D) - Bild von JFIF
   28_2GRP: 0x0002525C (23081: 0x00005A29) - Bild von JFIF
   28_3PAN: 0x0002AC88 (23282: 0x00005AF2) - Bild von JFIF
   35_1PRT: 0x0003077C (22496: 0x000057E0) - Bild von JFIF
   35_2GRP: 0x00035F5C (23532: 0x00005BEC) - Bild von JFIF
   35_3PAN: 0x0003BB48 (22881: 0x00005961) - Bild von JFIF
  FONT1: 0x0004FF5C (1522988: 0x00173D2C)
  FONT2: 0x001C3C88 (1723676: 0x001A4D1C)
  VERSION: 0x003689A4 (0: 0x00000000)
 M16C: 0x00488884 (130406: 0x0001FD66) - Renesas M16C-Familie (Motorola S-Record)
 FPGA: 0x004A85EC (131604: 0x00020214) - Xilinx Spartan 3
 FSL: 0x004C8800 (814: 0x0000032E) - der Bootloader der ersten Stufe </pre><br>  Der sofort einsatzbereite IDA unterst√ºtzt keine Blackfin-Prozessoren, es gibt jedoch ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin</a> eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drittanbieters</a> . <br><br><h3>  Firmware Leica M9 </h3><br>  Die Leica M9-Firmware-Datei ( <code>m9-1_196.upd</code> ) sieht verschl√ºsselt aus: Das Histogramm zeigt eine Verteilung von ca. 0,45%. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac1/6fc/17d/ac16fc17df9bfb0c9c63bdefaecc83d9.png"><br><br>  Das Ende der Geschichte?  Vielleicht nicht.  Tatsache ist, dass Leica eher schwache Prozessoren in den Kameras verwendete und zu dieser Zeit h√§ufig XOR-Verschl√ºsselung in der Unterhaltungselektronik verwendet wurde. Deshalb habe ich beschlossen, ein einfaches Tool f√ºr den XOR-Vorgang zu schreiben, um die Firmware mit mir selbst zu vergleichen und einige Statistiken zu berechnen. <br><br>  Die Schl√ºssell√§nge wurde durch Suchen nach dem l√§ngsten sich wiederholenden Muster bestimmt.  Dies ist sinnvoll, da jede Firmware normalerweise gro√üe Bl√∂cke sich wiederholender Daten enth√§lt, z. B. ein 0x00 / 0xFF-Pad oder Grafiken mit LUT-Pixeln.  Der Schl√ºssel selbst wird durch die H√§ufigkeit von Bytes innerhalb der L√§nge des Schl√ºssels berechnet, wobei das h√§ufigste Byte an den Schl√ºsselpuffer geht.  Das Ergebnis des Programms zeigte deutlich die XOR-Verschl√ºsselung.  Dann musste ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Tool ein</a> wenig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">modifizieren</a> , um den potenziellen Schl√ºssel zu erhalten und den Code zu entschl√ºsseln.  Dies stellte sich erneut als PWAD-Datei heraus. <br><br>  Der Inhalt von PWAD ergab die folgende Struktur: <br><br><pre>  REGELN: 0x0000007C (2788: 0x00000AE4) - XML-Beschreibung
 LUTS: 0x00000B60 (4060616: 0x003DF5C8)
  PROZESS: 0x0000004C (3900572: 0x003B849C)
   CREATE: 0x0000004C (20: 0x00000014) - Zeitstempel
   LUTS: 0x00000060 (427744: 0x000686E0)
   GAINMAP: 0x00068740 (20008: 0x00004E28)
   LENS: 0x0006D568 (3452724: 0x0034AF34)
  CCD: 0x003B84E8 (148662: 0x000244B6)
   CREATE: 0x0000004C (20: 0x00000014) - Zeitstempel
   BLEMISH: 0x00000060 (1092: 0x00000444)
   WREF: 0x000004A4 (147452: 0x00023FFC)
   LIN: 0x000244A0 (22: 0x00000016)
  ICCPROF: 0x003DC9A0 (4304: 0x000010D0)
   ECI-RGB: 0x0000003C (540: 0x0000021C)
   sRGB: 0x00000258 (3144: 0x00000C48)
   A-RGB: 0x00000EA0 (560: 0x00000230)
  WBPARAM: 0x003DDA70 (7000: 0x00001B58)
 BF561: 0x003E0128 (289128: 0x00046968) - Blackfin-Prozessorfamilie f√ºr analoge Ger√§te
  bf0: 0x0000004C (117846: 0x0001CC56) - Hauptprozessor
  bf1: 0x0001CCA4 (117826: 0x0001CC42) - Firmware des Subprozessors
  bf0.map: 0x000398E8 (27072: 0x000069C0) - Firmware-Karte des Hauptprozessors mit den folgenden Zeichen: D.
  bf1.map: 0x000402A8 (26304: 0x000066C0) - Subprozessor-Firmware-Karte mit den folgenden Zeichen: D.
 K√ñRPER: 0x00426A90 (143280: 0x00022FB0) - Renesas M16C-Familie (Motorola S-Record)
 GUI: 0x00449A40 (3647624: 0x0037A888)
  TRANS: 0x0000005C (131656: 0x00020248) - Lokalisierung
  BILDER: 0x000202A4 (267433: 0x000414A9)
   21_1PRT: 0x000000CC (18411: 0x000047EB) - Bild von JFIF
   21_2GRP: 0x000048B8 (23172: 0x00005A84) - Bild von JFIF
   21_3PAN: 0x0000A33C (23034: 0x000059FA) - Bild von JFIF
   24_1PRT: 0x0000FD38 (18489: 0x00004839) - Bild von JFIF
   24_2GRP: 0x00014574 (23230: 0x00005ABE) - Bild von JFIF
   24_3PAN: 0x0001A034 (22998: 0x000059D6) - Bild von JFIF
   28_1PRT: 0x0001FA0C (22605: 0x0000584D) - Bild von JFIF
   28_2GRP: 0x0002525C (23081: 0x00005A29) - Bild von JFIF
   28_3PAN: 0x0002AC88 (23282: 0x00005AF2) - Bild von JFIF
   35_1PRT: 0x0003077C (22496: 0x000057E0) - Bild von JFIF
   35_2GRP: 0x00035F5C (23532: 0x00005BEC) - Bild von JFIF
   35_3PAN: 0x0003BB48 (22881: 0x00005961) - Bild von JFIF
  FONT1: 0x00061750 (1522988: 0x00173D2C)
  USBLOGO: 0x001D547C (1775: 0x000006EF) - Bild von JFIF
  FONT2: 0x001D5B6C (1723676: 0x001A4D1C)
 FPGA: 0x007C42C8 (150176: 0x00024AA0) - Xilinx Spartan 3A
 BF547: 0x007E8D68 (937576: 0x000E4E68) - Blackfin-Prozessorfamilie f√ºr analoge Ger√§te (FSL?) </pre><br><br><h3>  Firmware Leica M240 </h3><br>  Ich habe mir angew√∂hnt, jeden Morgen die Download-Seite mit der Leica-Firmware zu √ºberpr√ºfen.  Bald erschien eine neue Datei: <b>FW_M240_1_1_0_2.FW</b> . <br><br>  Es sah nicht verschl√ºsselt aus, wurde aber komprimiert ... <br><br><h4>  Komprimierung </h4><br>  Das Histogramm zeigt einen gro√üen Burst bei 0x9D. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6cb/025/ef7/6cb025ef734f60b1d4104b7301798cad.png"><br><br>  Vielleicht ist dies eine Art Kompressionsmagie.  Eine Suche im Internet [9D + Komprimierung] ergab nichts, au√üer dass 0x1F9D <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">als Signatur f√ºr die LZW-Komprimierung verwendet wird</a> .  Wenn √ºberhaupt, verstehe ich die LZ-Komprimierungstypen und habe beschlossen, die Bytes nach 0x9D zu betrachten.  Und ich sah vier Optionen: <br><br><ol><li> <code>9D 70 C4</code> <br> </li><li> <code>9D 00</code> <br> </li><li> <code>9D XX YY</code> <br> </li><li> <code>9D XX 8Y YY</code> </li> </ol><br>  Was haben Sie sonst noch bemerkt: <br><br><ul><li>  Die erste Option wird nur einmal unter der Adresse 0x30 angezeigt: Sie wird wahrscheinlich als Indikator f√ºr komprimierte Daten verwendet. <br></li><li>  XX √ºberschreitet niemals 0x7F; <br></li><li>  Das letzte Byte von YY im dritten und vierten Fall √ºberschreitet niemals 0x7F </li></ul><br>  Soweit ich √ºber LZ wei√ü, ist dies LZ77 oder LZSS sehr √§hnlich, wobei YY der Einr√ºckungsschritt und XX die Anzahl der zu kopierenden Bytes ist.  Und die zweite Option ist ein Sonderfall der Ausgabe von 0x9D.  Ich habe eine einfache C-Funktion geschrieben, die diese Logik implementiert.  Sie best√§tigte, dass wir uns in die richtige Richtung bewegen, aber die vierte Option passt immer noch nicht in das Schema. <br><br>  Ich habe in jeder Hinsicht versucht, es zu interpretieren, aber es wurde nichts daraus.  Deshalb habe ich mich an meine Kameraden gewandt, um Rat zu bekommen.  Einer bemerkte, dass nach meinen eigenen Beobachtungen das vierte Byte von YY nur erscheint, wenn das h√∂chste Bit 0x8Y gesetzt ist: Dies ist nur ein zus√§tzlicher Abstand f√ºr den Einr√ºckungsschritt.  Ich sch√§mte mich, alles stellte sich als so offensichtlich heraus ... <br><br>  Schlie√ülich begann der Dekomprimierer, einen g√ºltigen Stream auszugeben ... bis er in der Mitte der Datei stecken blieb.  Dies geschah aufgrund der unbekannten L√§nge des Schiebefensters.  Zus√§tzliches Debugging und Tests haben die Situation behoben. <br><br>  Es gab also ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tool zum Parsen der Firmware M240</a> . <br><br><h4>  Firmware-Struktur </h4><br>  Um mit einem unbekannten Format zu arbeiten, habe ich mir nichts Besseres ausgedacht, als einige Offsets und Gr√∂√üen von Codeabschnitten zu messen - und zu versuchen, die n√§chstgelegenen Werte im Dateikopf zu finden.  Zum Beispiel dieser Block: <br><br> <code>0x00: 1E 1C AF 2E 01 01 00 02 07 E1 EA 5E 00 5C 1A B1 <br> 0x10: 01 29 1A 7E AE 38 73 65 9C 3D 75 B4 34 2F 44 6E <br> 0x20: 13 17 8E 6B 00 00 00 01 00 00 00 30 E1 E3 50 D1</code> <br> <br>  verwandelte sich schlie√ülich in: <br><br> <code>1E1CAF2E ‚Äî   "LEICA FILE" <br> 01010002 - 1.1.0.2 <br> 005C1AB1 ‚Äî    (big endian) <br> 01291A7E ‚Äî    (big endian) <br> AE3873659C3D75B4342F446E13178E6B ‚Äî  MD5 <br> 00000001 ‚Äî    <br> 00000030 ‚Äî    </code> <br> <br>  Als ich die Struktur der Firmware verstand, verbesserte ich mein Tool und am Ende produzierte es Folgendes: <br><br> <code>Running with options: <br> + firmware folder: M240_FIRMWARE <br> + verbose enabled <br> <br> Open firmware file: FW_M240_1_1_0_2.FW <br> File size: 6036193 | 0x005C1AE1 <br> <br> Parse container header: <br> version: 1.1.0.2 <br> packed size: 6036145 | 0x005C1AB1 <br> unpacked size: 19470974 | 0x01291A7E <br> body blocks: 1 | 0x00000001 <br> body offset: 48 | 0x00000030 <br> MD5: AE387365 9C3D75B4 342F446E 13178E6B <br> MD5 check: PASSED <br> <br> Uncompress container body: <br> 6036145 -&gt; 19470974 <br> Uncompression: DONE <br> <br> Split container: <br> Number of sections: 9 | 0x00000009 <br> Section table size: 612 | 0x00000264 <br> Section table offset: 36 | 0x00000024 <br> Section 1 <br> Section Name: "[A]IMG_LOKI-212" <br> Section offset: 0 | 0x00000000 <br> Section size: 7340032 | 0x00700000 <br> Section base: 1048576 | 0x00100000 <br> MD5: A8D55AA2 B0ACDB14 0673AD79 707674F3 <br> MD5 check: PASSED <br> Create file: M240_FIRMWARE/IMG_LOKI-212.bin <br> <br> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ <br> <br> Section 9 <br> Section Name: "[A]IMG-LENSDATA-213" <br> Section offset: 19214844 | 0x012531FC <br> Section size: 255478 | 0x0003E5F6 <br> Section base: 16252928 | 0x00F80000 <br> MD5: 39C2BEC0 27ED23F6 2C1C8513 EEE697B9 <br> MD5 check: PASSED <br> Create file: M240_FIRMWARE/IMG-LENSDATA-213.bin <br> Splitting container: DONE <br> Extraction COMPLETE!</code> <br> <br>  Die M240-Firmware enth√§lt einen Container mit neun Elementen: <br><br> <code>IMG_LOKI-212.bin -    <br> IMG_LOKI-213.bin -    <br> CTRL_SYS-11.bin -   - <br> IMG-FPGA-212.bin -     () <br> IMG-FPGA-213.bin -     () <br> IMG-DSP-212.bin -  DSP <br> IMG-DSP-213.bin -  DSP <br> IMG-LENSDATA-212.bin -    <br> IMG-LENSDATA-213.bin -   </code> <br> <br>  Wie Sie sehen k√∂nnen, gibt es in einer Firmware zwei S√§tze von Dateien.  Sp√§ter erfuhr ich, dass 212 eine Version der Bildverarbeitungs-Mikroschaltung ist und zwei Versionen der Leica M240 in Produktion gingen.  Diese Studie basiert auf Version 212. <br><br><h1>  Systemverwaltung: CTRL_SYS-11.bin </h1><br>  Der einzige gemeinsame Teil ist die Firmware f√ºr den Systemsteuerchip.  Dies ist eine wirklich gro√üe Bin√§rdatei, und der Code kann leicht erraten, wof√ºr er bestimmt ist. <br><br> <code>$ strings CTRL_SYS-11.bin | rg SH <br> -&gt; Test SH7216 data flash driver <br> -&gt; Test SH7216 SCI driver <br> -&gt; Test SH7216 I2C driver <br> -&gt; Test SH7216 MTU2 driver <br> -&gt; Test SH7216 ADC functions <br> -&gt; Test SH7216 CMT driver</code> <br> <br>  Daher haben wir den Renesas SH7216-Prozessor (SH-2A), der f√ºr die fr√ºhe Phase des Ladens, der E / A-Tests und der Firmware-Updates verantwortlich ist.  Standardm√§√üig unterst√ºtzt IDA diesen Prozessortyp.  Es blieb nur die richtige Grundlastadresse zu finden, die aus der Beschreibung der Firmware-Abschnitte bekannt ist: Dies ist <code>0x0</code> . <br><br> <code>Section Name: "[A]CTRL_SYS-11" <br> Section offset: 14680064 | 0x00E00000 <br> Section size: 917277 | 0x000DFF1D <br> Section base: 0 | 0x00000000</code> <br> <br>  Ich habe es in die IDA geladen und alle Funktionen erkannt, aber ich habe mich nicht besonders damit befasst, da die Firmware des Hauptprozessors viel interessanter ist. <br><br>  Hier kann auch angemerkt werden, dass der UART dieses Chips zum Service-Port ge√∂ffnet wird, wo er das Download-Protokoll anzeigt.  Wir werden sp√§ter darauf zur√ºckkommen. <br><br><h1>  Hauptchip: IMG_LOKI-212.bin </h1><br>  Um mit dem Reverse Engineering dieser Firmware zu beginnen, m√ºssen Sie zun√§chst einige Fragen beantworten: <br><br><ol><li>  welche Art von Prozessor <br></li><li>  Was ist die Grundlastadresse? <br></li><li>  Auf welchem ‚Äã‚ÄãBetriebssystem basiert es, falls vorhanden? </li></ol><br>  Dank unseres Tools kennen wir bereits die Adresse der Grundlast: Dies ist <code>0x100000</code> . <br><br> <code>Section Name: "[A]IMG_LOKI-212" <br> Section offset: 0 | 0x00000000 <br> Section size: 7340032 | 0x00700000 <br> Section base: 1048576 | 0x00100000</code> <br> <br>  Die Firmware speichert die verbleibenden Antworten in lesbarer Form.  Zum Beispiel diese Zeile: <br><br> <code>$ strings ./IMG_LOKI-212.bin | rg Softune <br> 6Softune REALOS/FR is Realtime OS for FR Family, based on micro-ITRON COPYRIGHT(C) FUJITSU LIMITED 1994-1999 <br> ...</code> <br> <br>  Es handelt sich also um einen benutzerdefinierten Prozessor <b>Fujitsu FR</b> (Leica nennt ihn <b>Maestro</b> ) und das Betriebssystem <b>Softune REALOS</b> .  In der Tat ist dies viel besser als Blackfin, da die IDA sofort FR unterst√ºtzt. <br><br><h2>  FR-Prozessormodul </h2><br>  Die Realit√§t sah nicht so gut aus, da das IDA-Programm nach dem Herunterladen der Firmware-Datei keine Anweisungen, externen Links usw. zeigte. <br><br>  Ich habe beschlossen, das Problem zu beheben, musste aber am Ende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige Teile der Firmware komplett neu schreiben</a> .  Hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f3/728/c76/9f3728c769d29aa02e2f405c08d8bb9a.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/2ea/81d/a082ea81d9056b07935398a19d4df294.png"><br><br>  Zus√§tzlich zu den Korrekturen in <code>ana</code> , <code>ins</code> und <code>out</code> kann ein v√∂llig neuer <code>emu</code> Code: <br><br><ul><li>  verschiedene Arten von Code und externe Links zu Daten erkennen; <br></li><li>  Switch-Anweisungen erkennen <br></li><li>  Stack-Tracing durchf√ºhren; <br></li><li>  Separate Stapelargumente und lokale Variablen <br></li><li>  Funktionen richtig erkennen. </li></ul><br>  Aber die gr√∂√üte √Ñnderung, wie Sie bemerkt haben, sind Gro√übuchstaben f√ºr Anweisungen :) <br><br>  M√∂chten Sie die vollst√§ndige Anleitung sehen?  Da ist er: <br><br><pre>  ADD ODER BTSTH LSR MOV BN LDRES EXTSH   
 ADD2 ORH MUL LSR2 JMP BP STRES EXTUH   
 ADDC ORB MULU ASR CALL BV COPOP SRCH0   
 ADDN EOR MULH ASR2 RET BNV COPLD SRCH1   
 ADDN2 EORH MULUH LDI INT BLT COPST SRCHC   
 SUB EORB DIV0S LDI INTE BGE COPSV LDM0    
 SUBC BANDL DIV0U LDI RETI BLE NOP LDM1    
 SUBN BANDH DIV1 LD BRA BGT ANDCCR STM0    
 CMP BORL DIV2 LDUH BNO BLS ORCCR STM1    
 CMP2 BORH DIV3 LDUB BEQ BHI STILM ENTER   
 UND BEORL DIV4S ST BNE DMOV ADDSP VERLASSEN   
 ANDH BEORH LSL STH BC DMOVH EXTSB XCHB    
 ANDB BTSTL LSL2 STB BNC DMOVB EXTUB </pre><br>  Also einfach und sch√∂n. <br><br>  √úbrigens haben Sie vielleicht bemerkt, dass einige Anweisungen nicht ausgerichtet sind: <br><br><pre>  BRA: D loc_xxx
     LDI: 8 # 0x64, R5 </pre><br>  Dies ist kein Fehler im Prozessormodul, sondern ein Merkmal der Fujitsu FR-Familie.  Es wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verz√∂gerungssteckplatz bezeichnet</a> und ist f√ºr RISC-Prozessoren recht typisch. <br><br>  Aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem FR80-Prozessorhandbuch</a> (Hinweis: Der Link funktioniert nicht mehr): <br><br><blockquote>  Der Befehl, der sich unmittelbar nach dem Verzweigungsbefehl befindet (sein Ort wird als "Verz√∂gerungsschlitz" bezeichnet), wird vor der Verzweigung ausgef√ºhrt, und der Befehl an der Zieladresse wird nach der Verzweigung ausgef√ºhrt.  Da der Befehl im Verz√∂gerungsschlitz vor der Verzweigungsoperation ausgef√ºhrt wird, betr√§gt die scheinbare Ausf√ºhrungsgeschwindigkeit 1 Zyklus. </blockquote><br>  Dies ist im Wesentlichen eine Optimierung der Pipeline, und es ist besser, sich daran zu erinnern, da sie √ºberall in der Leica-Firmware verwendet wird. <br><br><h2>  Softune REALOS </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aus dem Wiki</a> : <br><br><blockquote>  Softune ist die integrierte Entwicklungsumgebung von Fujitsu f√ºr die Prozessorfamilien Fujitsu FR, FR-V und F2MC.  Unterst√ºtzt von REALOS ¬µITRON Echtzeit-Kernel.  Beispielsweise wird es in Nikon DSLR-Kameras (siehe Nikon EXPEED) und einigen Pentax-Kameras mit K verwendet. </blockquote><br>  Dies ist also ein ziemlich beliebtes anst√§ndiges RTOS mit Aufgaben, Semaphoren und anderen Extras.  Ich habe mich gefragt, ob es m√∂glich ist, einige Standardbibliotheksfunktionen in der Leica-Firmware zu erkennen. <br><br>  Ich muss den ersten Teil der Studie als gro√üe Zeitverschwendung bezeichnen, und hier ist der Grund daf√ºr. <br><br>  Die Softune-IDE erwies sich als sehr schwer zu finden, aber am Ende gelang es mir, etwas zu bekommen.  Wie erwartet enthielt die IDE Bibliotheken.  Es gab vier Bin√§rdateien: <br><br><ul><li>  lib911.lib <br></li><li>  lib911e.lib <br></li><li>  lib911if.lib <br></li><li>  lib911p.lib </li></ul><br>  Ich wei√ü nicht, warum ich, vielleicht durch Tr√§gheit, als ich alles gehackt habe, was mit Leica zu tun hat, wieder mit dem Reverse Engineering des Formats begonnen habe.  Ja, ein sehr gut dokumentiertes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektmodulformat</a> .  Und ja, nat√ºrlich habe ich daf√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein spezielles Tool geschrieben</a> : <br><br> <code>Fujitsu RISC Library Tool v1.0 <br> Usage: FRLibTool [-s start] [-i imagebase] [-o output] [-f index] [-dv] FIRMWARE.BIN LIBRARY.LIB <br> <br> This tool will help you to find Softune REALOS library functions in FR (Fujitsu RISC) firmware. <br> Use following arguments: <br> -f Specify firmware image file <br> -s Specify firmware image scan offset <br> -b Specify firmware imagebase <br> -o Specify output type (exclusively) <br> list - list of functions <br> idc - IDC script <br> py - IDA python script <br> pat - FLAIR pattern file <br> -i xxx Specify index of particular function <br> -d Dump library <br> -v Be verbose</code> <br> <br>  Mithilfe dieser Funktion k√∂nnen Sie <code>*.pat</code> Dateien erstellen und diese als Eingabe in <b>IDA FLAIR verwenden</b> , um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signaturdateien</a> zu generieren. <br><br> <code>$ FRLibTool -o pat lib911.lib <br> $ FRLibTool -o pat lib911e.lib <br> $ FRLibTool -o pat lib911if.lib <br> $ FRLibTool -o pat lib911p.lib <br> ... <br> $ sigmake -n "SOFTUNE C/C++ Library" lib911.pat lib911e.pat lib911if.pat lib911p.pat softune.sig</code> <br> <br>  Nachdem ich diese Unterschrift <b>angewendet hatte,</b> sah ich endlich gl√ºcklich die Korrespondenz in <b>IMG_LOKI-212.idb</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/189/618/145/189618145ab302edfff51fa222ed89b3.png"><br><br><h4>  Layout </h4><br>  Die Anzahl der Zeilen in der Firmware f√§llt sofort auf.  Viele Funktionen sind nach ihrer Funktionalit√§t benannt.  Dies ist im Reverse Engineering-Prozess sehr n√ºtzlich, um das allgemeine Muster zu verstehen. <br><br>  Es ist auch wichtig zu beachten, dass einige Teile der Firmware-Datei im Reset-Handler an eine andere Adresse kopiert werden.  Beispielsweise wird der integrierte Loader zur Laufzeit im RAM h√∂her verschoben. <br><br>  Ich musste manuell zus√§tzliche Abschnitte erstellen, wodurch ich das folgende Layout erhielt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70f/d9d/ca3/70fd9dca36e610c7dea2e1c2fd29090c.png"><br><br><h4>  Unterbrechungen </h4><br>  Die Tabelle der Interruptvektoren kann durch Zugriff auf TBR (Table Base Register) gefunden werden: <br><br> <code>LDI:32 #int_table, R0 <br> MOV R0, TBR</code> <br> <br>  Normalerweise tritt es im Vektor-Reset-Handler ganz am Anfang der Firmware auf. <br><br>  Die Adressen der Handler in der Tabelle werden in umgekehrter Reihenfolge gem√§√ü der Formel <code>TBR + (0x3FC - 4 √ó inum)</code> gespeichert, sodass der R√ºcksetzvektor am Ende der Tabelle um <code>0x3FC</code> versetzt <code>0x3FC</code> . <br><br>  Ich fand die meisten Unterbrechungen im FR-Handbuch und schlug vor, dass Leica Maestro ein √§hnliches Layout hat.  Dann nahm er jeden Handler und versuchte, eine Zeichenfolge oder einen anderen Hinweis zu finden, der den Zweck des Interrupts enth√ºllt. <br><br>  Als Ergebnis habe ich diese Liste erstellt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd7/eb8/c29/bd7eb8c291d5368d44576466400cb34b.png"><br><br>  Viele Interrupts wie AUDIO / SDIO / VIDEO / JPEG / RAW werden erwartet, aber versuchen Sie, die mysteri√∂sesten von ihnen zu identifizieren?  Ich spreche √ºber die Unterbrechung von <code>int_uart_in</code> .  Es scheint, dass die Kamera eine Art UART CLI im Konsolenmodus unterst√ºtzt. <br><br><h4>  Systemaufrufe </h4><br>  Wie fast jedes Betriebssystem verwendet Softline REALOS Systemaufrufe.  Im Assembler sehen sie folgenderma√üen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22f/a92/9e3/22fa929e311af81f43be57bf0bbbbc74.png"><br><br>  Die tats√§chliche Adresse des Systemaufruf-Handlers wird wie folgt berechnet.  Beginnen wir mit der Suche nach dem Interrupt-Handler <code>INT #0x40</code> .  Wie oben beschrieben, dies <br><br> <code>(0x3FC - 4 √ó inum) = (0x3FC - 4 √ó 0x40) = 0x2FC = int_realos_syscall</code> <br> <br>  Im Handler ist es einfach, einen Link zum Ende der Systemaufruftabelle mit 16-Bit-W√∂rtern zu finden.  Der spezifische Datensatz in dieser Tabelle wird mit der Formel <code>syscall_table_bottom + (num * 2)</code> berechnet: <br><br> <code>[syscall_table_bottom + (-23 * 2)] = [syscall_table_bottom - 0x2E] = [0x1012EA] = 0xE68</code> <br> <br>  Dies sieht nicht wie eine Adresse aus, da die tats√§chliche Adresse des Systemaufruf- <code>syscall_table_bottom + offset</code> als <code>syscall_table_bottom + offset</code> berechnet wird.  Der gesamte Vorgang ist im Diagramm dargestellt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c5a/240/2bb/c5a2402bb00a171532dabf9ef9aa45ea.png"><br><br>  Alle Systemaufrufe und ihre Funktionalit√§t sind im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Softline REALOS / FR-Kernelhandbuch</a> angegeben. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daher</a> konnte ich alle in der Tabelle implementierten Handler wiederherstellen und die IDB ein wenig verbessern. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6a/b81/57a/c6ab8157a83a3e00613b4a000de45e54.png"><br><br>  Nat√ºrlich k√∂nnen Sie den Code noch sch√∂ner machen, indem Sie die Arten von Systemaufrufen in der IDA definieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e0/75c/099/1e075c099f1bdcb70388427705dd25c0.png"><br><br>  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Python-Skript geschrieben,</a> um automatisch nach diesen Systemaufrufen und mehr zu suchen. <br><br><h4>  Die Aufgaben </h4><br>  Beim <code>sta_tsk</code> ich festgestellt, dass nicht die Hauptfunktion als Parameter √ºbergeben wird, sondern pid.  Dies bedeutet, dass es Zeit ist, nach einer Vielzahl von Aufgabendeskriptoren zu suchen.  Und es ist sinnvoll, mit <code>sta_tsk</code> selbst zu beginnen. <br><br><pre>  ROM: 102180 sys_sta_tsk:
 ROM: 102180 ST RP, @ -R15
 ROM: 102182 LDUB @ (R14, 0x4F), R3
 ROM: 102184 LDI: 32 # word_100B80, R14 </pre><br>  Ganz am Anfang sehen wir einige Links.  Ich musste ein bisschen an Datentypen basteln, aber am Ende kamen die Teile zusammen: <br><br><pre>  ROM: 100B80 word_100B80: .word 0xF;  Anzahl der Aufgaben
 ROM: 100B82 .word 0x1C;  Taskdeskriptorgr√∂√üe<font></font>
<font></font>
 ROM: 100B84 .long 0x82A09F5C;  Aufgabe 1 Deskriptor
 ROM: 100B88 .long 0x1000D
 ROM: 100B8C .lang 0
 ROM: 100B90 .long 0x40000000
 ROM: 100B94 .long sub_1A7DB2;  Hauptaufgabe
 ROM: 100B98 .long 0x8286EEC0
 ROM: 100B9C .long 0<font></font>
<font></font>
 ROM: 100BA0 .long 0x82A09F88;  Aufgabe 2 Deskriptor
 ROM: 100BA4 .long 0x20010
 ROM: 100BA8 .long 0
 ROM: 100BAC .long 0x40000000
 ROM: 100BB0 .long sub_1A6BD2;  Hauptaufgabe
 ROM: 100BB4 .long 0x8287EEC0
 ROM: 100BB8 .lang 0
 ... </pre><br>  usw.  Nur 15 Aufgaben.  Es war eine Frage der Zeit, jede Hauptfunktion zu untersuchen, den Namen und den Zweck der Aufgabe zu bestimmen (mit Ausnahme der letzten).  Hier ist die vollst√§ndige Liste: <br><br><ol><li>  <b>SubCPU</b> <br>  Diese Aufgabe ist anscheinend f√ºr Erfassungsvorg√§nge wie Belichtung, Sichtung auf dem Bildschirm usw. verantwortlich. <br></li><li>  <b>Keymanager</b> <br>  Diese Aufgabe ist h√∂chstwahrscheinlich mit Hardwaretasten verbunden. <br></li><li>  <b>Guimanager</b> <br>  Eine ziemlich gro√üe Aufgabe, bei der die UI-Zustandsmaschine und das Interface-Rendering implementiert werden. <br></li><li>  <b>Debugmanager</b> <br>  Ja, es gibt etwas zu debuggen.  Yum Yum. <br></li><li>  <b>Filemanager</b> <br>  Bei dieser Aufgabe dreht sich alles um Dateivorg√§nge. <br></li><li>  <b>Fammanager</b> <br>  Ich w√ºrde sagen, dass die Aufgabe f√ºr die Dateien und den Speicher verantwortlich ist, da dies von den Aufgaben des Dateimanagers und des Speichermanagers abh√§ngt. <br></li><li>  <b>Memorymanager</b> <br>  Keine √úberraschungen: Speicheroperationen, Poolverwaltung usw. <br></li><li>  <b>Imagemanager</b> <br>  Diese Aufgabe verwaltet die Codierungs- / Decodierungsprozesse und andere Bildverarbeitungsprozesse. <br></li><li>  <b>Usbmanager</b> <br>  Die aktuelle Herausforderung ist die USB-Kommunikationsverarbeitung, die MassStorage, PTP und Leicas eigenes Protokoll umfasst. <br></li><li>  <b>IOManager</b> <br>  Diese Aufgabe scheint darin zu bestehen, Speicherger√§te wie SD- und CF-Karten zu verwalten (was? Welche anderen CFs? Vielleicht stammt sie vom Modell 213). <br></li><li>  <b>Systemmanager</b> <br>  Verschiedene Aufgaben wie allgemeiner Systembetrieb, Energieverwaltung usw. <br></li><li>  <b>SettingsManager</b> <br>  Behandelt den Kamerastatus und die Einstellungen. <br></li><li>  <b>Monitormanager</b> <br>  Verfolgt √Ñnderungen des Kamerastatus und informiert andere Aufgaben. <br></li><li>  <b>Peripheralmanager</b> <br>  Diese Aufgabe steuert GPS, Helligkeit und einige andere Sensoren. <br></li><li>  <b>Unbekannt</b> <br>  Leider fand ich nichts Bedeutendes f√ºr sie. </li></ol><br>  Es ist interessant festzustellen, dass es nach dem Hauptarray einen weiteren herausragenden Deskriptor gibt. <br><br> <code>ROM:100D28 dword_100D28: .long 0x82A0A1F0 <br> ROM:100D2C .long 0x21 <br> ROM:100D30 .long 0 <br> ROM:100D34 .long 0x80000000 <br> ROM:100D38 .long tid16_task <br> ROM:100D3C .long 0x8285EEC0 <br> ROM:100D40 .long 0</code> <br> <br>  Und die Funktion der Aufgabe verzweigt sich einfach von selbst. <br><br> <code>ROM:101494 sub_101494: <br> ROM:101494 BRA sub_101494 ; CODE XREF: sub_101494</code> <br> <br>  Auf diesen Deskriptor wird am Ende der <code>start</code> verwiesen, die f√ºr das Erstellen anderer Aufgaben und das Einrichten der Firmware verantwortlich ist.  Dies ist also h√∂chstwahrscheinlich die Aufgabe der Systeminaktion. <br><br><h4>  Module und Nachrichten </h4><br>  Zus√§tzlich zu Aufgaben k√∂nnen Sie einige logische Objekte definieren, z. B. E / A- und Peripheriemodule.  Module werden als Teil einer der Aufgaben als Gruppe von Nachrichtenhandlern dargestellt. <br><br>  Die IO-Gruppe scheint Folgendes zu umfassen: <br><br><ul><li>  IO-Manager </li><li>  Subprozessor </li><li>  USB-Manager </li><li>  USB PTP </li><li>  USB Leica-Protokoll </li><li>  USB-Massenspeicher </li><li>  Button Manager </li><li>  Debug-Manager </li><li>  Objektivmanager </li></ul><br>  Und in der peripheren Gruppe: <br><br><ul><li>  Peripherie-Manager </li><li>  Lichtsensor </li><li>  LEDs </li><li>  Sprecher </li><li>  Neigungssensor </li><li>  Kappenverschlusserkennung </li><li>  GPS-Modul </li><li>  3DAxis-Modul </li></ul><br>  Das Nachrichtensystem selbst verwendet die Standard-SOFTUNE-Strukturen: <br><br><pre> <code class="plaintext hljs">struct RealOS_MsgPayload { uint32_t msgID; // +0x0 uint32_t data[]; // +0x4 } struct RealOS_Message { uint32_t os_reserved1; // +0x0 uint32_t os_reserved2; // +0x4 uint32_t to; // +0x8 uint32_t from; // +0xC RealOS_MsgPayload* payload; // +0x10 }</code> </pre> <br>  Wie erwartet verf√ºgt IPC auch √ºber mehrere Nachrichtengruppen.  Da viele Nachrichten in Aufgaben und Modulen verarbeitet werden, konnte ich nur einige dieser Gruppen wiederherstellen: <br><br><pre>  0x1101xxxx - globale Systemmeldungen:
              0x11010002 = SYS_UPDATE_BOOTLOADER oder
              0x11010005 = SYS_ERASE_SETTINGS
 0x1102xxxx - Meldungen zur Bilderfassung:
              0x11020001 = CMD_CAP_CAPTURE oder
              0x11020008 = IMAGE_STATUS_CHANGED  
 0x1104xxxx - Meldungen zu Ereignissen im Zusammenhang mit der Wiedergabe:  
              0x11040002 = PLY_DISABLE_PLAY_MODE oder<font></font>
             0x11040004 = PLY_IMAGE_READY  <font></font>
0x1108xxxx -     PTP  .:<font></font>
             0x11080002 = DBG_CHANGE_LEVEL <font></font>
             0x11080012 = DBG_WRITE_ROM_DUMP_SD  <font></font>
0x2201xxxx -  USB PTP<font></font>
             0x22010108 =    <font></font>
             0x22010118 =  DebugObject  <font></font>
0x2202xxxx -     SUBCPU:<font></font>
             0x22020002 = E_SUBCPU_REQUEST_M_EXPOSURE_REQUEST  <font></font>
             0x22020015 = E_IO_SUBCPU_COMMAND_CLEANING_SENSOR  <font></font>
0x2203xxxx -    :<font></font>
             0x22030001 =   <font></font>
0x2204xxxx -   IO:<font></font>
             0x2204000C = / Mass Storage <font></font>
             0x22040012 =    <font></font>
0x330000xx -     UI:<font></font>
             0x33000001 =  <font></font>
             0x33000007 =  <font></font>
0x440000xx -   ,     <font></font>
             0x44000013 = E_IMG_CMD_CHANGE_PINFO  <font></font>
0x55xxxxxx ‚Äî   FAM:  <font></font>
             0x558800xx = - FAM <font></font>
             0x558888xx =     FAM<font></font>
0x6602xxxx ‚Äî     LED, :<font></font>
             0x66020001 -  LED  X <font></font>
             0x66020002 =   LED  <font></font>
0x6604xxxx -  :<font></font>
             0x66040001 =  <font></font>
             0x66040007 =    <font></font>
0x6611xxxx -  ,   <font></font>
0x6622xxxx -   ,   <font></font>
0x6660xxxx -   ,   :<font></font>
             0x66600006 = HISTOGRAM  <font></font>
             0x66600011 = RAWCOMP  <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0x771100xx und 0x77AA00xx - Meldungen zum Wechseln des Kameramodus </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leider sind viele andere Beitr√§ge unbekannt. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GUI </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Firmware-Datei werden auch die folgenden Abschnitte behandelt: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CTRL_SYS-11</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMG-LOKI-212</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMG-DSP-212</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMG-FPGA-212</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMG-LENSDATA-212</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was mich √ºberraschte, war der v√∂llige Mangel an GUI-Ressourcen. </font><font style="vertical-align: inherit;">Aber sie sollten irgendwo sein und sind h√∂chstwahrscheinlich in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMG-LOKI-212</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eingebaut </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einer meiner √ºblichen Ans√§tze zur Umkehrung der Firmware-Entwicklung besteht darin, alle m√∂glichen Querverweise wiederherzustellen. </font><font style="vertical-align: inherit;">Nicht nur im Code, sondern auch im Datenbereich. </font><font style="vertical-align: inherit;">Dann schaue ich sie durch und versuche, einige Muster oder Links zu bekannten Teilen des Codes zu finden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leica Firmware war keine Ausnahme. </font><font style="vertical-align: inherit;">Es gibt viele √§hnliche Datensequenzen mit Adressen zu anderen Datensequenzen, die weiter gehen usw. Als ich die Hierarchie der Links erklomm, sah ich endlich eine vertraute Funktion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel habe ich eine Datenstruktur ohne Links gefunden:</font></font><br><br><pre> <code class="plaintext hljs">g_data = { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine andere Struktur ging darauf ein: </font></font><br><br><pre> <code class="plaintext hljs">g_data_struct1 = { ... , &amp;g_data }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Worauf wiederum von einer anderen Struktur Bezug genommen wird: </font></font><br><br><pre> <code class="plaintext hljs">g_data_struct2 = { &amp;g_data, ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Datenstruktur hat eine Verkn√ºpfung vom Code und wird als Parameter an eine andere Funktion √ºbergeben: </font></font><br><br><pre> <code class="plaintext hljs">func1() ‚ï∞ func2(..., &amp;g_data_struct2, ...)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber </font></font><code>func1()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es hei√üt nicht direkt von einer anderen Funktion, und wird in einem Array gespeichert:</font></font><br><br><pre> <code class="plaintext hljs">g_func_list1[] = { ..., func1(), ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oben habe ich einen Anruf im Code gefunden </font></font><code>g_func_list1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">func3() { g_func_list1[x] }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und wieder ist diese Funktion in einem Array gespeichert: </font></font><br><br><pre> <code class="plaintext hljs">g_func_list2[] = { ..., func3(), ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein anderer Code greift auf das Array selbst zu: </font></font><br><br><pre> <code class="plaintext hljs">func4() { g_func_list2[x] }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gl√ºcklicherweise wird diesmal die Funktion von einer anderen Funktion aufgerufen und so weiter </font></font><code>gui_MADE_ApplicationRun</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="plaintext hljs">gui_Statemachine_DoStateChange() ‚ï∞ gui_MADE_ApplicationRun() ‚ï∞ func5() ‚ï∞ func4()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Zeilen weisen darauf hin, dass das GUI-Subsystem "MADE" hei√üt und Seiten√ºberg√§nge mit </font></font><code>MADE_GetSysTri</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allen Mitteln behandelt werden. </font><font style="vertical-align: inherit;">Die GUI-Zustandsmaschine ist grunds√§tzlich in einer Funktion implementiert </font></font><code>gui_Statemachine_DoStateChange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nach dem Sammeln von Informationen √ºber die GUI ergab sich ein allgemeines Bild: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d4/33e/3cf/4d433e3cf679dba11141d58d080daf5b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, ist die Hauptfunktion f√ºr GUI-Ressourcen </font></font><code>gui_CopyImageDesc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(obwohl dies kein richtiger Name ist). </font><font style="vertical-align: inherit;">Sie hat folgende Argumente:</font></font><br><br><pre> <code class="plaintext hljs">gui_CopyImageDesc( uint32_t dstAddress; // R4 - destination address UIDescType type; // R5 - description type UITarget target; // R6 - rendering target uint32_t descAddress; // R7 - description address uint8_t always0; // (SP + 0x0) - always 0 uint8_t index1; // (SP + 0x4) - index 1 uint8_t index2; // (SP + 0x8) - index 2 uint16_t x_offset; // (SP + 0xC) - x offset uint16_t y_offset; // (SP + 0x10) - y offset uint16_t unknown2; // (SP + 0x14) - uint32_t language1; // (SP + 0x18) - language id 1 uint32_t language2; // (SP + 0x1C) - language id 2 uint32_t funcAddress; // (SP + 0x20) - function address )</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt vier Arten von Ressourcenbeschreibungen: </font></font><br><br><pre> <code class="plaintext hljs">struct UIDescType0Header struct UIDescType1Header struct UIDescType2 struct UIDescType3 { { { { uint32_t address; uint32_t address; uint32_t reg; uint16_t x_offset; uint16_t entries; uint16_t entries; uint32_t address; uint16_t y_offset; uint16_t unknown; uint16_t unknown; uint16_t unknown1; uint32_t address; } } uint16_t unknown2; } uint16_t unknown3; struct UIDescType0Entry struct UIDescType1Entry uint16_t tableoff; { { } uint16_t x_offset; uint16_t x_offset; uint16_t y_offset; uint16_t y_offset; uint32_t address; uint32_t address; } uint16_t objects; uint16_t total_w; uint16_t total_h; uint16_t unknown; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Typ hat einen Header mit einem Verweis auf ein Array von Datens√§tzen. Jeder Datensatz hat Koordinaten und eine Adresse f√ºr Pixeldaten. Der aktuelle Typ scheint zustandsabh√§ngige Elemente wie Symbole zu beschreiben, die m√∂glicherweise ausgegraut sind oder in der Benutzeroberfl√§che verschwinden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der zweite Typ beginnt ebenfalls mit einer √úberschrift und wird zum Lokalisieren, Beschreiben von Zeilen oder Textbl√∂cken verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der dritte Typ beschreibt Zeichentabellen f√ºr verschiedene Sprachen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letztere Typ ist f√ºr alle anderen statischen Ressourcen wie Bilder, Hintergr√ºnde usw. verantwortlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns nun die Daten f√ºr die Bilder selbst an. </font><font style="vertical-align: inherit;">Die ersten sechs Bytes sehen aus wie ein kleiner Header, gefolgt von einem sich wiederholenden Muster, bei dem jedes zweite Byte entweder </font><font style="vertical-align: inherit;">oder ist </font><font style="vertical-align: inherit;">. Es ist logisch , </font><font style="vertical-align: inherit;">anzunehmen , </font><font style="vertical-align: inherit;">dass </font><font style="vertical-align: inherit;">und</font></font><br><br> <code>+0x00: 00 08 00 14 00 01 A2 FF 0A 04 05 FF 0C 04 03 FF <br> +0x10: 0D 04 03 FF 0E 04 02 FF 0E 04 02 FF 04 04 06 FF <br> +0x20: 04 04 02 FF 04 04 06 FF 04 04 02 FF 04 04 06 FF <br> +0x30: 04 04 02 FF 04 04 06 FF 04 04 02 FF 04 04 06 FF <br> +0x40: 04 04 02 FF 04 04 06 FF 04 04 02 FF 04 04 06 FF <br> +0x50: 04 04 02 FF 04 04 06 FF 04 04 02 FF 0E 04 02 FF <br> +0x60: 0E 04 02 FF 0D 04 03 FF 0D 04 03 FF 0C 04 04 FF <br> +0x70: 04 04 0C FF 04 04 0C FF 04 04 0C FF 04 04 0C FF <br> +0x80: 04 04 0C FF 04 04 0C FF 04 04 0C FF 04 04 0C FF <br> +0x90: 04 04 0D FF 02 04 2D FF 00 06 00 14 00 01 79 FF</code> <br> <br><font style="vertical-align: inherit;"></font><code>0xFF</code><font style="vertical-align: inherit;"></font><code>0x04</code><font style="vertical-align: inherit;"></font><code>0x0008</code><font style="vertical-align: inherit;"></font><code>0x0014</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Breite und H√∂he in einer Ansicht mit direkter Bytereihenfolge (Big Endian). Am Ende dieses Dumps sehen wir den Beginn einer anderen Sequenz </font></font><code>00 06 00 14 00 01</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist h√∂chstwahrscheinlich die n√§chste Ressource (wie durch einen Link dazu best√§tigt). Somit betr√§gt die Gr√∂√üe der tats√§chlichen Bilddaten 146 Bytes. Die Bildgr√∂√üe sollte jedoch 0x8 * 0x14 = 0xA0 = 160 sein. Es ist klar, dass die Daten keine reinen Pixel und nicht einmal eine 8-Bit-LUT sind, da sie 14 Bytes kleiner sind. Was dann? Wahrscheinlich eine Art Komprimierung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn man sich diesen hexadezimalen Speicherauszug ansieht, ist es kaum zu glauben, dass ein komplexes Schema verwendet wird. Die Benutzeroberfl√§che von Leica ist nicht sehr farbenfroh. Nach meiner Erfahrung ist es daher am besten, die LUT-Tabelle hier zu verwenden. In diesem Fall wiederholen die UI-Ressourcen die LUT-Indizes wie </font></font><code>03 03 03</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font><font style="vertical-align: inherit;">vollst√§ndig</font></font><code>1 1 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In der Regel versucht der Kompressor, Datenverdopplungen zu beseitigen und sie durch einen Link zu ersetzen. Diese Index-Arrays sind auch mit einer einfachen Methode wie RLE ideal f√ºr die Komprimierung </font></font><code>[data][number]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ein einfacher Befehl zum Schreiben </font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Wert) </font></font><code>number</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mal. </font><font style="vertical-align: inherit;">Vor </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Hintergrund schlug ich vor, dass wir h√∂chstwahrscheinlich ein einfaches Bild mit zwei LUT-Farben ( </font></font><code>0xFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>0x04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) betrachten und das Byte vor der Farbe die Anzahl der zu zeichnenden Pixel ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûUnd dann hast du ein anderes Instrument geschrieben‚Äú, denkst du. Aber nein, ich nahm einen Stift und Papier und fing an, die Zellen auszuf√ºllen. Es ist lustig, dass ich das Bild noch habe.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/743/b4a/1f3/743b4a1f3a65f485760e8a4f0584d2e6.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Irgendwann auf dem Weg wurde mir klar, dass 160 Pixel f√ºr dieses Bild nicht ausreichen, daher m√ºssen 0x8 und 0x14 mit zwei multipliziert werden. Das dritte Wort 0x0001 gibt an, ob das Bild ein ASCII-Zeichen ist. Die endg√ºltige ImageAsset-Struktur lautet also wie folgt:</font></font><br><br><pre> <code class="plaintext hljs">struct ImageAsset { uint16_t width; // /2 (big endian) uint16_t height; // /2 (big endian) uint16_t ascii; // 1,   ASCII struct image_data { uint8_t number; //     uint8_t color; //     LUT } data[]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber ein Teil fehlt noch: LUT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es war nicht so schwer zu finden, da viele Links und Strukturen bereits manuell wiederhergestellt wurden. Ich bl√§tterte langsam durch die Datenabschnitte und suchte nach einem Array von 256 Elementen aus 16-Bit- oder 32-Bit-Werten, bis ich darauf stie√ü: </font><font style="vertical-align: inherit;">Nochmals </font><font style="vertical-align: inherit;">vielen </font><font style="vertical-align: inherit;">Dank Bei meiner Arbeit mit Blackmagic Design habe ich sofort YUV-Pixel erkannt (zum Beispiel alle Werte mit den Zahlen 8080). </font><font style="vertical-align: inherit;">Ich bin kein Dummkopf, die gesamte Benutzeroberfl√§che erneut manuell auf Papier zu zeichnen, also habe ich ein anderes Tool geschrieben - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">M240UITool</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieses Tool kann nicht nur alle Image-Ressourcen aus der Firmware-Datei auf BMP / PNG zur√ºcksetzen, sondern auch IDC-Skripte in IDA erstellen, um alle UI-Ressourcen zu ermitteln.</font></font><br><br> <code>.long 0x7008080, 0x72D8080, 0x73C8080, 0x75A8080, 0x79B8080, 0x71DFF6B, 0x7BE8080, 0x7FF8080 <br> .long 0x77BBD27, 0x75B60E7, 0x7835F4A, 0x7D3089F, 0x7018080, 0x7028080, 0x7038080, 0x7048080 <br> .long 0x7058080, 0x7068080, 0x7078080, 0x7088080, 0x7098080, 0x70A8080, 0x70B8080, 0x70C8080 <br> .long 0x70D8080, 0x70E8080, 0x70F8080, 0x7108080, 0x7118080, 0x7128080, 0x7952B15, 0x7138080 <br> .long 0x7148080, 0x7158080, 0x7168080, 0x7178080, 0x7188080, 0x7198080, 0x71A8080, 0x71C8080 <br> .long 0x71D8080, 0x71E8080, 0x71F8080, 0x7338080, 0x7208080, 0x7218080, 0x7228080, 0x7238080 <br> .long 0x7248080, 0x7248080, 0x7268080, 0x7278080, 0x7288080, 0x7298080, 0x72A8080, 0x72B8080 <br> .long 0x72C8080, 0x75E8080, 0x7608080, 0x7628080, 0x7648080, 0x7678080, 0x7688080, 0x7698080 <br> .long 0x76B8080, 0x76E8080, 0x7708080, 0x7728080, 0x7758080, 0x7778080, 0x7798080, 0x77C8080 <br> .long 0x77E8080, 0x7818080, 0x7838080, 0x7868080, 0x7888080, 0x78B8080, 0x78D8080, 0x7908080 <br> .long 0x7928080, 0x7958080, 0x7978080, 0x7998080, 0x79C8080, 0x79D8080, 0x7668080, 0x79E8080 <br> .long 0x7A18080, 0x7A28080, 0x7A38080, 0x7A68080, 0x7A78080, 0x7A88080, 0x7AB8080, 0x7AC8080 <br> .long 0x7AD8080, 0x7B08080, 0x7B28080, 0x7B58080, 0x7B88080, 0x7B98080, 0x7BC8080, 0x7CC8080 <br> .long 0x7AB3BBB, 0x7E10094, 0x7E4556E, 0x4008080, 0x2922D17, 0x7B2AB00, 0x7C2A262, 0x71DFF6B <br> .long 0x768D4A2, 0x769D4EA, 0x7BD88AE, 0x705997B, 0x70BB377, 0x711CC73, 0x717E66F, 0x7238866 <br> .long 0x729A262, 0x72FBB5E, 0x735D55A, 0x7417751, 0x747914D, 0x74DAA48, 0x753C444, 0x75F663B <br> .long 0x76B9933, 0x7998080, 0x771B32F, 0x77D5526, 0x7836F22, 0x789881E, 0x78FA21A, 0x7159095 <br> .long 0x71AAA91, 0x720C38D, 0x726DD88, 0x7506F6A, 0x7568866, 0x75CA262, 0x762BB5E, 0x76E5E55 <br> .long 0x7747751, 0x77A914D, 0x780AA48, 0x78C4D3F, 0x792663B, 0x7988037, 0x79E9933, 0x7AA3C2A <br> .long 0x7B05526, 0x7B66F22, 0x7BC881E, 0x72488AE, 0x72AA1AA, 0x72FBBA6, 0x735D4A2, 0x7427799 <br> .long 0x7489095, 0x74DAA91, 0x753C38D, 0x77E556E, 0x7836F6A, 0x7898866, 0x78FA262, 0x79C4459 <br> .long 0x7A15E55, 0x7A77751, 0x7AD914D, 0x7BF4D3F, 0x7CC8080, 0x7C5663B, 0x7CB8037, 0x7337FC8 <br> .long 0x73999C4, 0x73FB2C0, 0x745CCBB, 0x7757799, 0x74C54FF, 0x77B9095, 0x780AA91, 0x7AB3C72 <br> .long 0x7B1556E, 0x7B66F6A, 0x7BC8866, 0x74277E1, 0x74890DD, 0x74EAAD9, 0x754C3D5, 0x76066CC <br> .long 0x7667FC8, 0x76C99C4, 0x772B2C0, 0x77E55B7, 0x7846EB3, 0x78A88AE, 0x790A1AA, 0x7526EFB <br> .long 0x75787F7, 0x75DA1F3, 0x763BAEE, 0x76F5DE6, 0x77577E1, 0x77B90DD, 0x781AAD9, 0x78D4CD0 <br> .long 0x79366CC, 0x79F99C4, 0x7E10094, 0x7CF44A1, 0x7DB7799, 0x7E71A90, 0x7ED338C, 0x7FF8080 <br> .long 0x7328080, 0x7DC8080, 0x7C88080, 0x7508080, 0x775CD2C, 0x76944EA, 0x7808080, 0x71A61FF <br> .long 0x7244D40, 0x7242C15, 0xFFF8080, 0xF338080, 0xF668080, 0xF998080, 0xFCC8080, 0xF008080 <br> .long 0xF4C54FF, 0xFAB3BBB, 0xFE10094, 0xFE4556E, 0xF952B15, 0xFDA7751, 0xFB2AB00, 0xFC2A262 <br> .long 0xF1DFF6B, 0xF68D4A2, 0xF69D4EA, 0xFBD88AE, 0xA922D17, 0xC6E4130, 0xE286963, 0x74C55FF <br> .long 0x768D536, 0x7FF8080, 0x7FF8080, 0x7FF8080, 0x2922D17, 0x46E4130, 0x6286963, 0x8080</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br> <code>Leica M (typ 240) UI Tool v1.0 <br> Usage: ./M240UITool [-a address] [-i imagebase] [-s script] [-d dump] [-f folder] [-l LUT] [-rbv] FIRMWARE.BIN <br> <br> This tool will help you to find UI resources in firmware. <br> Use following arguments: <br> -a Specify address of the gui_CopyImageDesc function (ex. 0x2F95E0) <br> -i Specify firmware imagebase <br> -s Specify IDC file name <br> -c Specify container file name <br> -d Specify dump image format <br> png - PNG format <br> bmp - BMP (ARGB) format <br> -f Specify folder for dumped images <br> -l Specify LUT for images (filename of address) <br> -b Specify number of bytes to display in verbose mode <br> -r Try to recover string characters <br> -v Be verbose</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wissen bereits, dass die Funktion, die eine UI-Seite erstellt, mehrmals aufgerufen wird </font></font><code>gui_CopyImageDesc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich dachte, es w√§re gro√üartig, einen UI-Ressourcenbrowser zu erstellen und alle Funktionen zum Rendern von Seiten zu definieren. </font><font style="vertical-align: inherit;">Die Option </font></font><code>-c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist daf√ºr </font><font style="vertical-align: inherit;">vorgesehen </font><font style="vertical-align: inherit;">- sie erstellt einen speziellen Container zum Anzeigen von Ressourcen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wer hat gesagt, dass ein UI-Ressourcenbrowser m√∂glicherweise nicht ungew√∂hnlich aussieht? </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b6/5f7/6c3/8b65f76c30a4d4a037719e805141573a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Tool ist interaktiv (durchscheinende Schaltfl√§chen auf dem Screenshot) und erm√∂glicht es Ihnen, nicht nur durch die Seiten des EVF / LCD-Men√ºs zu scrollen, sondern auch die Rendering-Schritte innerhalb einer Seite anzuzeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider ist der Quellcode f√ºr dieses Meisterwerk irgendwo verloren gegangen, aber die Header-Dateien befinden sich immer noch im M240UITool-Code, sodass Sie ihn technisch von Grund auf neu erstellen k√∂nnen.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debug-Men√º </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Linie suchen wir vor allem beim Reverse Engineering? Meiner Meinung nach dieses Wort </font></font><code>debug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und seine Ableitungen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gab viele interessante Zeilen in der Firmware, aber diese sind etwas Besonderes: </font><font style="vertical-align: inherit;">Es scheint, dass Sie mit einer Tastenkombination in den Debug-Modus wechseln k√∂nnen. Alle diese Zeilen werden von einer riesigen Funktion aufgerufen </font><font style="vertical-align: inherit;">, die eine Knopfscan-Zustandsmaschine implementiert. So sieht es in der IDA aus:</font></font><br><br> <code>$ strings ./IMG_LOKI-212_1.1.0.2.bin | grep "Debug Mode" <br> GUI: State: %d! Scanning for Debug Mode successful <br> GUI: Scanning for Debug Mode: State: %d, Ignore long DEL <br> GUI: Scanning for Debug Mode: State: %d <br> GUI: Scanning for Debug Mode: State: %d, Ignore long DEL <br> GUI: Scanning for Debug Mode: State: %d <br> GUI: Scanning for Debug Mode: State: %d, Ignore long DEL <br> GUI: Scanning for Debug Mode: State: %d <br> GUI: Scanning for Debug Mode: State: %d, Ignore long DEL <br> GUI: Scanning for Debug Mode: State: %d <br> GUI: Scanning for Debug Mode: State: %d, Ignore long DEL <br> GUI: Scanning for Debug Mode: State: %d <br> ... <br> GUI: ScanningForDebugWithKeyAndJoyStick(): g_GUI_CheckForDebugWithKeyAndJoyStick = %d</code> <br> <br><font style="vertical-align: inherit;"></font><code>ScanningForDebugWithKeyAndJoyStick</code><font style="vertical-align: inherit;"></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9e/525/cd2/e9e525cd2bc493e7bb8cc4b3710b1334.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde nicht l√ºgen, es hat einige Zeit gedauert, um zu verstehen, wie die Hardwaretasten in der Firmware verarbeitet werden, und dann die aufgez√§hlten Typen f√ºr die Tasten und den Joystick wiederherzustellen. Aber als ich die Kombination bekam, stellte ich mit √Ñrger fest, dass sie nichts tat. Es funktioniert wahrscheinlich nur von einer bestimmten GUI-Seite. Noch ein paar Abende mit der manuellen Verfolgung der GUI-Zustandsmaschine - und das Problem ist gel√∂st, und wir haben es auch geschafft, die Men√ºseite Zur√ºcksetzen zu finden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Willkommen im Debug-Modus. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/526/74d/068/52674d068ae127cc7b90b5b1172de325.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich dachte viel dar√ºber nach, ob ich diese Kombination ank√ºndigen sollte, entschied mich aber, mich zu enthalten. Ich respektiere die harte Arbeit, die Leica leistet, indem sie ihre einzigartigen Ger√§te herausbringt, und ich m√∂chte nicht daf√ºr verantwortlich sein, dass ihre Service-Center die kaputten Kadaver der Kameras aufgrund einer gedankenlosen Neugier f√ºllen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dennoch werde ich einige aufgez√§hlte Typen bereitstellen, um das Reverse Engineering f√ºr diejenigen zu vereinfachen, die bereit sind, diesen Weg zu gehen. </font></font><br><br><pre> <code class="plaintext hljs">enum ControlActionType { kControlAction_Idle, // 0 kControlAction_Push, // 1 kControlAction_Release, // 2 kControlAction_LongPush // 3 }; enum ControlBtnType { kControlBtn_LV, // 0 kControlBtn_PLAY, // 1 kControlBtn_DEL, // 2 kControlBtn_ISO, // 3 kControlBtn_MENU, // 4 kControlBtn_SET // 5 }; enum ControlJoystickType { kControlJoy_INFO, // 0 kControlJoy_Up, // 1 kControlJoy_Down, // 2 kControlJoy_Left, // 3 kControlJoy_Right // 4 };</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ptp </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beim Nachdenken √ºber die USB-Aufgabe habe ich drei Modi definiert (die auch im Debug-Men√º best√§tigt werden): </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ptp </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSC (Massenspeicherklasse) </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leica Brauch </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTP ist am interessantesten, weil es gut dokumentiert ist und es Ihnen erm√∂glicht, die Kamera zu steuern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist ziemlich einfach, PTP-Handler in der Firmware zu finden, da dieser Code viele Aufrufe enth√§lt. </font><font style="vertical-align: inherit;">Alle PTP-Anrufe sind in drei Gruppen unterteilt: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legacy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leica Extended (LE)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Production</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch das Debuggen von Nachrichten konnten Namen f√ºr fast den gesamten Code festgelegt werden.</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verm√§chtnis: Leica Umfang: Produktion:                           </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0x1001 - GetDeviceInfo 0x9001 - Kameraeinstellungen festlegen 0x9100 - Produktionssitzung √∂ffnen      </font></font><font></font>
0x1002 - OpenSession 0x9002 - Get Camera Settings 0x9101 - Close Production Session     <font></font>
0x1003 - CloseSession 0x9003 - Get Lens Parameter 0x9102 - UpdateFirmware               <font></font>
0x1004 - Get Storage ID 0x9004 - Release Stage 0x9103 - Open OSD Session             <font></font>
0x1005 - Get Storage Info 0x9005 - Open LE Session 0x9104 - Close OSD Session            <font></font>
0x1006 - GetNumObjects 0x9006 - Close LE Session 0x9105 - Get OSD Data                 <font></font>
0x1007 - GetObjectHandles 0x9007 - RequestObjectTransferReady 0x9106 - GetFirmwareStruct            <font></font>
0x1008 - GetObjectInfo 0x9008 - GetGeoTackingData 0x910B - GetDebugMenu                 <font></font>
0x1009 - GetObject 0x900A - Open Debug Session 0x910C - SetDebugMenu                 <font></font>
0x100A - Get Thumb 0x900B - Close Debug Session 0x910D - ODIN Message                 <font></font>
0x100B - Delete Object 0x900C - Get Debug Buffer 0x910E - GetDebugObjectHandles        <font></font>
0x100E - Initiate Capture 0x900D - Debug Command String 0x910F - GetDebugObject               <font></font>
0x1014 - GetDevicePropDesc 0x900E - Get Debug Route 0x9110 - DeleteDebugObject            <font></font>
0x1015 - GetDevicePropV 0x900F - SetIPTCData 0x9111 - GetDebugObjectInfo           <font></font>
0x101C - Initiate Open Capture 0x9010 - GetIPTCData 0x9112 - WriteDebugObject             <font></font>
                                   0x9020 - Get3DAxisData 0x9113 - CreateDebugObject            <font></font>
                                   0x9030 - OpenLiveViewSession 0x9114 - Calibrate 3Daxis             <font></font>
                                   0x9031 - CloseLiveViewSession 0x9115 - Magnetic calibration         <font></font>
                                   0x9033 - Unknown 0x9116 - Get Viewfinder Data </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Implementierung der PTP-Schnittstelle selbst scheint Standard zu sein, aber einige Befehle weisen Einschr√§nkungen auf, die ich hier absichtlich weglasse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In jedem Fall ist all das ziemlich aufregend. </font><font style="vertical-align: inherit;">Sie k√∂nnten denken: "Schlie√üen Sie einfach die Kamera √ºber USB an und beginnen Sie mit libptp zu testen."</font></font> Alles ist richtig. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verdammt ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leica M240 hat keinen USB-Anschluss.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Griffanschluss </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leica bietet nur wenige Zubeh√∂rteile f√ºr diese Kamera an, aber es gibt eines, das besonders interessant ist. </font><font style="vertical-align: inherit;">Wir sprechen √ºber den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multifunktionsgriff Leica M (14495)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es ersetzt den unteren Metallteil des Geh√§uses, bietet integriertes GPS und mehrere Anschl√ºsse wie USB, einen SCA-Flash-Anschluss, DIN / ISO-X und eine Steckdose. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fab/250/1b6/fab2501b6e69cb6caf3f62528e413bdb.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und Sie sagen noch einmal: "Gro√üartig, jetzt kaufen Sie es einfach, schlie√üen Sie es an die Kamera an, schlie√üen Sie die Kamera √ºber USB an und beginnen Sie mit libptp zu testen."</font></font> Alles ist richtig. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur verdammt ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kostet fast 900 Dollar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies sind fast neunhundert Gr√ºnde, einen eigenen Adapter zu erstellen. </font><font style="vertical-align: inherit;">F√ºr alle F√§lle habe ich jedoch eBay-Benachrichtigungen f√ºr dieses Zubeh√∂r eingerichtet.</font></font><br><br><h4>  Anschluss </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Anschluss an der Kamera lautet wie folgt: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a29/4f0/388/a294f0388ad2c5ac3d355d0838e01586.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe versucht, ihn im Internet zu finden, aber im Ernst, wie w√ºrden Sie ihn bei Google beschreiben? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzweifelt begann ich √ºber einige verr√ºckte Dinge nachzudenken, wie das Aufkleben von Folie oder Nadeln auf einen Radiergummi. Als ich bei Blackmagic Design auf die Kamera-Platine schaute, bemerkte ich, dass einer der Anschl√ºsse eine sehr vertraute Form hatte. Am n√§chsten Tag brachte ich meine Leica M240 zur Arbeit - und ja, es sah √§hnlich aus, nur viel l√§nger mit vielen Pads. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt, die Teilenummer unseres Komponentenmanagers zu erfragen und sie dann im Samtec-Katalog zu finden: </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ERM8-013-05.0-L-DV-TR</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a60/dc3/d36/a60dc3d36d12216f74690577507fc6db.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben Samtec auch gefragt, ob es m√∂glich ist, eine Probe zu bekommen, und sie haben freundlicherweise zugestimmt.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dda/752/0d6/dda7520d6691fc48f3f1aaa026e49635.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein wenig Arbeit mit L√∂tkolben, Pappe und Klebeband - und mein eigener Stecker ist fertig (Muster von 2013). </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ddd/243/fe5/ddd243fe596648709c3f9dccb76f15ea.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºnf Jahre sp√§ter, im Jahr 2018, beschloss ich, Samtec pers√∂nlich zu bitten, eine weitere Probe zu senden. </font><font style="vertical-align: inherit;">Ich wollte etwas besser machen. </font></font><br><br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ERCD-013-05.00-TTR-TTR-1-D</font></font></a></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/e1a/56a/995/e1a56a9958b1dda50aca34f0ecac8863.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wieder viel Arbeit mit einem L√∂tkolben, Fluchen, Drahtschneiden, Fluchen, wieder Arbeiten mit einem L√∂tkolben, um eine neue, attraktivere Option zu schaffen:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a5/b78/10d/1a5b7810d3a2ccea73bf4e2d75cad8cd.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pinbelegung </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Stecker enth√§lt 26 Kontakte: 13 auf jeder Seite. Noch bevor ich mein Teil verl√∂tete, untersuchte ich den Kameraanschluss mit einem Multimeter und einem Logikanalysator. √úbrigens m√ºssen Sie einen Magneten am Sensor der unteren Abdeckung anbringen, damit die Kamera ber√ºcksichtigt, dass die Abdeckung angebracht ist. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erde (Kamera aus, keine Batterie)</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich beginne immer vom Boden aus, weil es sicher und sehr leicht zu finden ist. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ead/140/15c/ead14015c97177d6717e198616c9114b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben also acht Grundlinien (dunkelgrau). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Potential (Kamera ein)</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die Kamera eingeschaltet ist, k√∂nnen Sie das Potential an jedem Pin messen und sich ein Bild von der Logik und den Leistungspegeln machen. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alexhude.github.io/assets/2019/2019-01-24-hacking-leica-m240/probe2_potential.png</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Leistung an den Pins 8‚Äì9 und 11‚Äì13 ist f√ºr Logik-Pins zu hoch, daher habe ich sie als Leistung (rot) definiert. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widerstand (Kamera ausgeschaltet, kein Akku)</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist n√ºtzlich, den Widerstand zu messen. In einigen F√§llen hilft dies, die Eingaben zu identifizieren und einige Zeilen zu gruppieren. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa7/fde/1a6/fa7fde1a623a5f13d264a5127a3083d2.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angeschlossene Ausg√§nge (Kamera ausgeschaltet, kein Akku)</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dann habe ich beschlossen, alle externen Pads am Kamerageh√§use zu √ºberpr√ºfen, um festzustellen, ob sie mit dem Service-Port verbunden sind. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f75/61e/c06/f7561ec060796fa8e39a15d533e3de03.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Blitzsynchronisationskontakt wurde direkt mit Leitung 10 verbunden. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logikanalysator (Kamera eingeschaltet) Die</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daten f√ºr jede Leitung wurden in der folgenden Reihenfolge aufgezeichnet: Einschalten, die Kamera sollte sich im LV-Modus befinden, ein Bild aufnehmen, Videoaufnahme starten.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/494/33c/27c/49433c27cf94be5cb9430e4ba518560c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Zeilen zeigen die √úbertragung einiger Daten: 01 und 21. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">01</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 115200, √úbertragung von 8 Bits, 1 Stoppbit, Parit√§tsbit, LSB zuerst. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf7/3a2/fdf/bf73a2fdfbbfeab571c354f2a6d50c9b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle 500 ms sendet es einen Z√§hler </font></font><code>C3 3C 02 81 00 01 00 82, C3 3C 02 81 01 01 00 83, C3 3C 02 81 02 01 00 80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 115200, √úbertragung von 8 Bits, 1 Stoppbit, kein Parit√§tspr√ºfbit, LSB zuerst. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f00/423/2dd/f004232dd3f1b8c8f0e665fd63f3fa9b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sendet das Bootloader-Protokoll an SH7216 (‚ÄûLeica Camera AG‚Äú im obigen Screenshot). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Markieren wir sie dunkelblau. Es ist ziemlich traurig, dass das Maestro-Protokoll auch bei den maximalen Debugging-Einstellungen im Debug-Men√º nicht gel√∂scht wird. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c44/541/bb9/c44541bb98c4388f151bdc3faffa1dfe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei diesen Kontakten betr√§gt der Widerstand ca. 310 kOhm.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wei√ü nicht warum, aber ich schlug vor, dass andere Datenleitungen einen √§hnlichen Widerstand haben oder geschlossen werden. Daher habe ich die Linien ~ 300 kOhm, ~ 200 kOhm und ~ 100 kOhm als Datenleitungen definiert (Blaut√∂ne im Bild). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen wurde das folgende Bild gezeichnet. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e7e/31f/f2c/e7e31ff2cc7da6ae304652488ca9db4c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12 Kandidaten auf der Datenleitung. Aber wie kann man sie √ºberpr√ºfen? Nach einem kurzen Gespr√§ch mit den Eisenexperten √ºber den elektrischen Schutz integrierter Schaltkreise fing ich an, Kontakte √ºber einen 4-kOhm-Widerstand zu stechen, wodurch der Strom auf einen Wert reduziert wird, den die Eing√§nge nicht verbrennen sollten.</font></font><br><br><h4>  UART </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich ging erneut davon aus, dass sich die RX-Leitung in der N√§he des TX befinden sollte. Die Leitungen 02, 03 und 20 sehen aus wie gute Kandidaten, da beide wie TX eine Spannung von 3,3 V haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangs habe ich versucht, diese Linien mit Bus Pirate zu erkunden. Leider war das Ergebnis eher schmutzig. Dann habe ich SiLabs-basierte Kabel als zuverl√§ssiger und konfliktfreier unter macOS angesehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst habe ich das TX-Kabel an Pin 20 angeschlossen und </font></font><code>help</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach dem Bootloader </font><font style="vertical-align: inherit;">mit der Eingabe begonnen </font><font style="vertical-align: inherit;">. Wie erwartet wiederholte die Kamera nach einer kurzen Verz√∂gerung die Zeichen. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a16/445/c00/a16445c00b6a22a6b37b74c97fc97ca5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kontakte 02 und 03 waren die n√§chsten Kandidaten f√ºr UART. Leider gab es keine Anzeichen daf√ºr, dass diese Leitungen abgeh√∂rt wurden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Abbildung sind die bekannten UARTs durch einen dunkleren Gr√ºnton gekennzeichnet.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/733/f68/fa1/733f68fa1950518017ad2c09971ac1f8.png"><br><br><h4>  USB </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles begann damit, ein USB-Kabel mit einem Header in der Mitte und 4 kOhm-Widerst√§nden zur Erfassung in zwei H√§lften zu schneiden. </font><font style="vertical-align: inherit;">Signalintegrit√§t eines Differentialpaares? </font><font style="vertical-align: inherit;">Nein, dann war es mir eigentlich egal.</font></font> :) :) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/891/930/5d3/8919305d35cd2525d420313c2b0e7555.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann habe ich zu Hause mehrere USB-Heimger√§te untersucht, um eine Vorstellung davon zu bekommen, wie die Kommunikation an diesem Port aussieht. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canon </font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/c49/f85/cf8/c49f85cf89650352531c83c970eb609c.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kamera Blackmagic Pocket </font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/8b7/7e5/bc8/8b77e5bc8c2fa3387083a8e8ec12c3db.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camcorder Canon </font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/17f/dd4/67a/17fdd467a6627a4129f38d6e476d4ffc.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camcorder JVC Camcorder </font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/757/80d/4c8/75780d4c8a85c55c04afe5de9209e09d.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schl√ºsselbund </font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/ad9/3a6/382/ad93a63828797eaea1f5d906367b792f.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KidiZoom Kamera</font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/32e/d73/13a/32ed7313a12ef1cef1444a87c22f3c77.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie sind alle etwas unterschiedlich, aber der anf√§ngliche D-D + Status ist niedrig. </font><font style="vertical-align: inherit;">Nun, wir werden es wissen und jetzt werden wir √ºberpr√ºfen, ob wir Folgendes haben:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - unwahrscheinlich, da D-D + ein Differentialpaar sind und ziemlich nahe beieinander liegen sollten;</font></font><br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">04/05</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - es ist unwahrscheinlich, weil sie unterschiedliche Widerst√§nde haben;</font></font><br></li><li> <b>14/15</b> ‚Äî ,      ; <br></li><li> <b>15/16</b> ‚Äî ,        . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also habe ich den USB D-D + an die 15/16 Pins angeschlossen und an den iMac angeschlossen ... </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/777/491/b7f/777491b7f4a3b4b0f8376931db78c6c8.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf dem USB PTP-Bildschirm wurde die Kamera jedoch nicht auf dem Host angezeigt. Ich habe versucht, verschiedene Optionen f√ºr das Layout der elektronischen Schaltung zu konfigurieren, aber nichts hat funktioniert. Beagle zeigte viele besch√§digte Pakete und andere Fehler. Am Ende gab ich auf und kehrte zum Reverse Engineering der Firmware zur√ºck. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist die letzte Pinbelegung. USB ist dunkelgr√ºn markiert. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ad/07d/289/2ad07d289a684e6db69a02ae9e50c294.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wer h√§tte gedacht, dass ein paar Jahre sp√§ter dieselbe eBay-Benachrichtigung bei mir eintrifft und ich das gew√ºnschte Zubeh√∂r ziemlich g√ºnstig kaufe? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich kann ich meine Annahmen √ºber PTP testen. Aber zuerst war es sehr merkw√ºrdig, wie der USB-PHY im Gadget aussieht. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/afe/0b1/afc/afe0b1afc09953f7f9c6dbc451c47c56.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Inneren befand sich der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">SMSC 2512b</font></a><font style="vertical-align: inherit;"> Hub</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direkt auf der Stra√üe von der Griffbuchse zum Mini-USB-Anschluss. Der Chip arbeitet im Standardmodus, da keine EEPROM- oder SCL / SDA-Pins vorhanden sind. Der erste Downstream-Port ist an eine Buchse am Kamerageh√§use angeschlossen, der zweite ist jedoch an nichts angeschlossen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe wahrscheinlich etwas verpasst, aber f√ºr mich macht eine solche L√∂sung nicht viel Sinn. Der technische Pass besagt, dass der Chip "voll integrierte USB-Pins sowie Widerst√§nde zum Erh√∂hen und Verringern der Spannung" hat. Vielleicht haben die Leica-Ingenieure beschlossen, kein eigenes USB-PHY zu implementieren, sondern das im Hub, das gut getestet ist und sofort funktioniert. Tats√§chlich kann ich ihnen keine Vorw√ºrfe machen, denn bevor ich dies versuchte, stellte sich heraus, dass es eine schwierige Aufgabe war. Vielleicht ist dies eine Funktion zum Schutz vor F√§lschungen, wer wei√ü.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie USB PHY verstehen und bereit sind zu helfen, z√∂gern Sie nicht, mir zu schreiben: Es sollte m√∂glich sein, √ºber einen USB-Anschluss ohne dieses Markenzubeh√∂r zu arbeiten :) </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wieder PTP </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie gesagt, es ist Zeit, mit der Leica PTP-Erweiterung herumzuspielen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gl√ºcklicherweise habe ich anstelle von libptp eine ziemlich coole C ++ - Bibliothek gefunden - es ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libEasyPTP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das Schreiben eines auf dieser Bibliothek basierenden Tools dauerte ebenfalls nicht lange: Ich kannte bereits einige Einschr√§nkungen in der Leica PTP-Oberfl√§che. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und obwohl M240PTPTool ziemlich fehlerhaft ist, eignet es sich gut f√ºr die Rolle des Proof of Concept ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmcode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur zwei Anforderungen werden √ºber PTP </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gesendet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">GetDebugBuffer (0x900C)</font></b><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DebugCommandString (0x900D)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Damit die Module das Debug-Protokoll ausf√ºllen k√∂nnen, m√ºssen Sie im Men√º die Debug-Stufe als "Debug" oder "Debug RAW" festlegen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der M240PTPTool-Oberfl√§che gibt es mehrere Optionen:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Werkzeug schlie√üen;</font></font><br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flush</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Debug-Puffer von Kamera zusammenf√ºhren:</font></font></li></ul><br> <code>M240&gt; flush <br> I:[00:11:468]|01| DATE/TIME CORRECTED by 5921 sec <br> D:[00:12:079]|00| Send message from TID 0 to TID 1 over MBX 3 - length: 4 - MesgID: 0x22020103 <br> D:[00:12:179]|00| Send message from TID 0 to TID 1 over MBX 3 - length: 4 - MesgID: 0x22020103 <br> D:[00:12:282]|11| Message received from TID 0 for TID 1 over MBX 3 <br> D:[00:12:283]|11| Message received from TID 0 for TID 1 over MBX 3 <br> D:[00:12:301]|00| Send message from TID 0 to TID 1 over MBX 3 - length: 4 - MesgID: 0x22020103 <br> D:[00:12:402]|00| Send message from TID 0 to TID 1 over MBX 3 - length: 4 - MesgID: 0x22020103 <br> D:[00:12:502]|00| Send message from TID 0 to TID 1 over MBX 3 - length: 4 - MesgID: 0x22020103 <br> ...</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder andere Text wird als Debugging-Befehl an die Kamera gesendet. </font><font style="vertical-align: inherit;">Zum Beispiel </font></font><code>help</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden alle m√∂glichen Befehle mit Argumenten angezeigt: Die </font><font style="vertical-align: inherit;">vollst√§ndige Liste ist ziemlich gro√ü, aber Sie k√∂nnen f√ºr jede Aufgabe direkte Nachrichten an Softune senden! </font><font style="vertical-align: inherit;">Was w√§re so interessant, dorthin zu senden ... </font><font style="vertical-align: inherit;">Eine andere beliebte Zeile, nach der in der Firmware h√§ufig gesucht wird, ist </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mal sehen, ob wir eine haben. </font><font style="vertical-align: inherit;">Anscheinend k√∂nnen Sie die Firmware auf die SD-Karte kopieren. </font><font style="vertical-align: inherit;">√úber den Link zur Zeile "Dateien auf Karte ausgeben" k√∂nnen Sie den daf√ºr verantwortlichen Code leicht finden. </font><font style="vertical-align: inherit;">Es befindet sich im riesigen System Task-Block (PID 11, wie wir bereits wissen) und wird von der Nachricht </font><font style="vertical-align: inherit;">ohne Argumente </font><font style="vertical-align: inherit;">aufgerufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dial </font><font style="vertical-align: inherit;">in </font><b><font style="vertical-align: inherit;">M240PTPTool</font></b><font style="vertical-align: inherit;"> , dr√ºcken Sie die </font><font style="vertical-align: inherit;">Eingabetaste und Blick auf den Bildschirm.</font></font><br><br> <code>M240&gt; help <br> ********* debug command description ******** <br> <br> exposure request <br> Description: requests a release from Sub CPU <br> Parameter 1: Exposure Time TV <br> <br> still request <br> Description: simulates the -still request- command flow of Sub CPU <br> Parameter: no <br> <br> ... <br> <br> send Message;[Parameter1];[Parameter2];[Parameter2];...;... <br> Description: Sending Message to Task <br> Parameter 1: Receiver Task ID <br> Parameter 2: Command ID <br> Parameter 3: Command Data[0] (32 Bit) <br> Parameter 4: Command Data[1] (32 Bit) <br> Parameter 5: . <br> Parameter 6: . <br> use maximum 10 Parameter <br> <br> ...</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>dump</code><font style="vertical-align: inherit;"></font><br><br> <code>$ strings IMG_LOKI-212_1.1.0.2.bin | rg -i dump <br> GUI: HEX DUMP: Address: %x, Length: %d <br> HSK: DBG_WRITE_ROM_DUMP_SD: File was properly opened, but it seems to be empty. <br> ROM_DUMP <br> HSK: DBG_WRITE_ROM_DUMP_SD: Flushing Dump to ROM. Size %d <br> SD:\ROM_DUMP.bin <br> HSK: DBG_WRITE_ROM_DUMP_SD Command received! <br> ROM_DUMP.bin <br> HSK: DUMP failed, no cards inserted! <br> HSK: DUMP FlashROM to SD card. <br> HSK: DUMP FlashROM to CF card. <br> Dumping files to card</code> <br> <br><font style="vertical-align: inherit;"></font><code>0x11080006</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>send Message;11;0x11080006</code><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4de/1cc/e2e/4de1cce2e0ee47a67645df790a7e581c.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen Sie dann die SD-Karte und √ºberpr√ºfen Sie, was sich darauf befindet. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/209/2a8/25e/2092a825e23cb93c4845b416ea11b0e4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist es ein kompletter Dump, einschlie√ülich Firmware. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies er√∂ffnet endlose M√∂glichkeiten. </font><font style="vertical-align: inherit;">Zum Beispiel k√∂nnen Sie ein winziges Ger√§t mit einer MCU, Unterst√ºtzung f√ºr einen USB-Host und Schaltfl√§chen zum Starten komplexer Nachrichtensequenzen herstellen ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und dann hatten wir ein zweites Kind.</font></font> :) :) <br><br><h1>  Nachwort </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie das Ger√§t nicht besch√§digen m√∂chten, k√∂nnen Sie es normalerweise untersuchen, ohne das Geh√§use zu √∂ffnen oder Dr√§hte an die Leiterplatte zu l√∂ten. </font><font style="vertical-align: inherit;">Unten sind meine Tipps, wenn Sie interessiert sind:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier finden Sie alle √∂ffentlichen Informationen zum Ger√§t: technische Daten, Daten zu den Komponenten, Fotos der Innenseiten, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video ab Werk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;)</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie √ºber Firmware verf√ºgen, lesen Sie diese und suchen Sie nach Tipps f√ºr externe Ausg√§nge. </font></font><br></li><li>        ,     ; <br></li><li>  GND//    ,  ; <br></li><li>     ; <br></li><li>     ,   ; <br></li><li>   ,     (, ); <br></li><li>        ,    Google   (USB/UART/SPI/I2C/1Wire); <br></li><li>      ,      ; <br></li><li>  <s></s>  ,      ; <br></li><li>  ,    . </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/18b/006/166/18b006166a4070202c1be3a9b946c3e9.png"><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/alexhude</a> <br><br> <b>  !</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438168/">https://habr.com/ru/post/de438168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438152/index.html">"Ich kann Ihnen √ºber die Schmerzen erz√§hlen, die jeder iOS-Entwickler im Arsch hat" - 10 Fragen an einen Entwickler, Folge 2</a></li>
<li><a href="../de438158/index.html">US-Datenbroker verkaufen Standortdaten ohne Zustimmung des Benutzers - ihre Arbeit wird reguliert</a></li>
<li><a href="../de438162/index.html">Das Tupel eines gesunden Menschen</a></li>
<li><a href="../de438164/index.html">Genetik und H√ºhner: menschliches CSF1-Fc-Protein in Eiprotein</a></li>
<li><a href="../de438166/index.html">Interaktion zwischen einer Site in einem Browser und einem lokal ausgef√ºhrten Programm</a></li>
<li><a href="../de438170/index.html">Preis benannt nach Ilya Segalovich. Geschichte √ºber Informatik und Ver√∂ffentlichungen</a></li>
<li><a href="../de438172/index.html">Apple kann die Produktion seiner Ger√§te nicht in die USA verlagern</a></li>
<li><a href="../de438174/index.html">Gelb - Vakuum - Wolke</a></li>
<li><a href="../de438176/index.html">IPSec √úbersicht bei Mikrotik</a></li>
<li><a href="../de438178/index.html">Erstellen Ihrer ersten ARCore-Anwendung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>