<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏽 🥃 👩🏾‍🚀 Python como o caso final de C ++. Parte 2/2 🗂️ 👨🏿‍🎨 🛌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para ser continuado. Começando em Python como o caso final de C ++. Parte 1/2 ". 
 Variáveis ​​e tipos de dados 


 Agora que finalmente descobrimos a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python como o caso final de C ++. Parte 2/2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464405/"><p>  Para ser continuado.  Começando em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Python como o caso final de C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1/2</a> ". </p><br><h1>  Variáveis ​​e tipos de dados </h1><br><p>  Agora que finalmente descobrimos a matemática, vamos decidir o que as variáveis ​​devem significar em nossa linguagem. </p><br><p>  No C ++, um programador tem uma opção: use variáveis ​​automáticas colocadas na pilha ou mantenha valores na memória de dados do programa, colocando apenas ponteiros para esses valores na pilha.  E se escolhermos apenas uma dessas opções para Python? </p><br><p>  Obviamente, nem sempre podemos usar apenas os valores das variáveis, pois grandes estruturas de dados não cabem na pilha ou seu movimento constante na pilha cria problemas de desempenho.  Portanto, usaremos apenas ponteiros no Python.  Isso simplificará conceitualmente o idioma. </p><a name="habracut"></a><br><p>  Então a expressão </p><br><pre><code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  significa que criamos um objeto “3” na memória de dados do programa (a chamada “pilha”) e fizemos do nome “a” uma referência a ele.  E a expressão </p><br><pre> <code class="python hljs">b = a</code> </pre> <br><p>  neste caso, significa que forçamos a variável "b" a se referir ao mesmo objeto na memória a que "a" se refere, ou seja, copiamos o ponteiro. </p><br><p>  Se tudo é um ponteiro, quantos tipos de lista precisamos implementar em nosso idioma?  Claro, apenas um é uma lista de indicadores!  Você pode usá-lo para armazenar números inteiros, seqüências de caracteres, outras listas, o que for - afinal, esses são indicadores. </p><br><p>  Quantos tipos de tabelas de hash precisamos implementar?  (No Python, esse tipo é chamado de "dicionário" - <code>dict</code> .) Um!  Deixe associar ponteiros às chaves e ponteiros aos valores. </p><br><p>  Portanto, não precisamos implementar em nossa linguagem uma grande parte da especificação C ++ - modelos, pois executamos todas as operações nos objetos, e os objetos sempre são acessíveis pelo ponteiro.  Obviamente, os programas escritos em Python não precisam se limitar ao trabalho com ponteiros: existem bibliotecas como o NumPy, com as quais os cientistas trabalham com matrizes de dados na memória, como faria no Fortran.  Mas a base da linguagem - expressões como "a = 3" - sempre funciona com ponteiros. </p><br><p>  O conceito de "tudo é um ponteiro" também simplifica a composição dos tipos até o limite.  Quer uma lista de dicionários?  Basta criar uma lista e colocar dicionários lá!  Você não precisa pedir permissão ao Python, não precisa declarar tipos adicionais, tudo funciona imediatamente. </p><br><p>  Mas e se quisermos usar objetos compostos como chaves?  A chave no dicionário deve ter um valor imutável; caso contrário, como procurar valores por ela?  As listas estão sujeitas a alterações, portanto, não podem ser usadas nessa capacidade.  Para tais situações, o Python possui um tipo de dados que, como uma lista, é uma sequência de objetos, mas, diferentemente de uma lista, essa sequência não muda.  Esse tipo é chamado de tupla ou <code>tuple</code> (pronunciada "tupla" ou "tupla"). </p><br><p>  As tuplas no Python resolvem um problema de longa data da linguagem de script.  Se você não está impressionado com esse recurso, provavelmente nunca tentou usar linguagens de script para trabalhos sérios com dados, nos quais é possível usar apenas cadeias ou apenas tipos primitivos como chave nas tabelas de hash. </p><br><p>  Outra possibilidade que as tuplas nos dão é retornar vários valores de uma função sem precisar declarar tipos de dados adicionais para isso, como você deve fazer em C e C ++.  Além disso, para facilitar o uso desse recurso, o operador de atribuição recebeu a capacidade de descompactar automaticamente as tuplas em variáveis ​​separadas. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host, port host, port = get_address()</code> </pre> <br><p>  A descompactação tem vários efeitos colaterais úteis, por exemplo, a troca de valores de variáveis ​​pode ser escrita da seguinte maneira: </p><br><pre> <code class="python hljs">x, y = y, x</code> </pre> <br><p>  Tudo é um ponteiro, o que significa que funções e tipos de dados podem ser usados ​​como dados.  Se você conhece o livro “Design Patterns” dos autores de “The Gang of Four”, lembre-se dos métodos complexos e confusos que ele oferece para parametrizar a escolha do tipo de objeto criado pelo seu programa em tempo de execução.  De fato, em muitas linguagens de programação isso é difícil de fazer!  No Python, todas essas dificuldades desaparecem, porque sabemos que uma função pode retornar um tipo de dados, que funções e tipos de dados são apenas links e links podem ser armazenados, por exemplo, em dicionários.  Isso simplifica a tarefa até o limite. </p><br><p>  David Wheeler disse: "Todos os problemas de programação são resolvidos criando um nível adicional de indireção".  O uso de links no Python é o nível de indireção tradicionalmente usado para resolver muitos problemas em várias linguagens, incluindo C ++.  Mas se for usado explicitamente lá, e isso complica os programas, no Python é usado implicitamente, de maneira uniforme em relação a dados de todos os tipos, e é fácil de usar. </p><br><p>  Mas se tudo é um link, a que esses links se referem?  Idiomas como C ++ têm muitos tipos.  Vamos deixar no Python apenas um tipo de dados - um objeto!  Especialistas no campo da teoria dos tipos balançam a cabeça com desaprovação, mas acredito que um tipo de dado de origem, do qual todos os outros tipos na linguagem são derivados, é uma boa idéia que garanta a uniformidade da linguagem e sua facilidade de uso. </p><br><p>  Para conteúdos específicos da memória, várias implementações do Python (PyPy, Jython ou MicroPython) podem gerenciar a memória de maneiras diferentes.  Mas, para entender melhor como a simplicidade e a uniformidade do Python são implementadas, para formar o modelo mental correto, é melhor recorrer à implementação de referência do Python em C chamada CPython, que pode ser baixada em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">python.org</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ob_type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* followed by object's data */</span></span> }</code> </pre> <br><p>  O que veremos no código fonte do CPython é uma estrutura que consiste em um ponteiro para informações sobre o tipo de uma determinada variável e uma carga útil que define o valor específico da variável. </p><br><p>  Como as informações de tipo funcionam?  Vamos nos aprofundar no código fonte do CPython novamente. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> getattrfunc tp_getattr; setattrfunc tp_setattr; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> newfunc tp_new; freefunc tp_free; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> binaryfunc nb_add; binaryfunc nb_subtract; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> richcmpfunc tp_richcompare; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Vemos indicadores de funções que fornecem todas as operações possíveis para um determinado tipo: adição, subtração, comparação, acesso a atributos, indexação, fatiamento etc. Essas operações sabem como trabalhar com a carga útil localizada na memória abaixo de um ponteiro para digitar informações, seja um número inteiro, sequência ou objeto de um tipo criado pelo usuário. </p><br><p>  Isso é radicalmente diferente de C e C ++, no qual as informações de tipo estão associadas a nomes, não a valores de variáveis.  No Python, todos os nomes estão associados aos links.  O valor por referência, por sua vez, é do tipo.  Essa é a essência das linguagens dinâmicas. </p><br><p>  Para entender todos os recursos da linguagem, basta definir duas operações nos links.  Um dos mais óbvios é copiar.  Quando atribuímos um valor a uma variável, a um slot em um dicionário ou a um atributo de um objeto, copiamos os links.  Esta é uma operação simples, rápida e completamente segura: copiar links não altera o conteúdo do objeto. </p><br><p>  A segunda operação é uma chamada de função ou método.  Como mostramos acima, um programa Python pode interagir com a memória apenas através de métodos implementados em objetos internos.  Portanto, não pode causar um erro relacionado ao acesso à memória. </p><br><p>  Você pode ter uma pergunta: se todas as variáveis ​​contêm referências, como posso proteger o valor de uma variável das alterações passando sua função como parâmetro? </p><br><pre> <code class="python hljs">n = <span class="hljs-number"><span class="hljs-number">3</span></span> some_function(n) <span class="hljs-comment"><span class="hljs-comment"># Q: I just passed a pointer! # Could some_function() have changed “3”?</span></span></code> </pre> <br><p>  A resposta é que tipos simples em Python são imutáveis: eles simplesmente não implementam o método responsável por alterar seu valor.  O imutável (imutável) <code>int</code> , <code>float</code> , <code>tuple</code> ou <code>str</code> fornece em linguagens como "tudo é um ponteiro" o mesmo efeito semântico que variáveis ​​automáticas fornecem em C. </p><br><p>  Tipos e métodos unificados simplificam o uso de programação generalizada, ou genéricos, tanto quanto possível.  As funções <code>min()</code> , <code>max()</code> , <code>sum()</code> e similares são incorporadas, não há necessidade de importá-las.  E eles funcionam com todos os tipos de dados nos quais as operações de comparação para <code>min()</code> e <code>max()</code> são implementadas, adições para <code>sum()</code> , etc. </p><br><h1>  Criar objetos </h1><br><p>  Descobrimos em termos gerais como os objetos devem se comportar.  Agora vamos determinar como vamos criá-los.  Esta é uma questão de sintaxe da linguagem.  O C ++ suporta pelo menos três maneiras de criar um objeto: </p><br><ol><li>  Automático, declarando uma variável desta classe: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">my_class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span></span>;</code> </pre> </li><li>  Usando o <code>new</code> operador: <br><pre> <code class="cpp hljs">my_class *c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_class(arg);</code> </pre> </li><li>  Factory, chamando uma função arbitrária que retorna um ponteiro: <br><pre> <code class="cpp hljs">my_class *c = my_factory(arg);</code> </pre> </li></ol><br><p>  Como você provavelmente já adivinhou, tendo estudado a maneira de pensar dos criadores de Python nos exemplos acima, agora devemos escolher um deles. </p><br><p>  Do mesmo livro, The Gangs of Four, aprendemos que uma fábrica é a maneira mais flexível e universal de criar objetos.  Portanto, apenas esse método é implementado no Python. </p><br><p>  Além da universalidade, esse método é bom, pois você não precisa sobrecarregar a linguagem com sintaxe desnecessária para garantir: uma chamada de função já está implementada em nossa linguagem e uma fábrica nada mais é do que uma função. </p><br><p>  Outra regra para criar objetos em Python é a seguinte: qualquer tipo de dados é sua própria fábrica.  Obviamente, você pode escrever qualquer número de fábricas personalizadas adicionais (que serão funções ou métodos comuns, é claro), mas a regra geral permanecerá válida: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Let's make type objects # their own type's factories! c = MyClass() i = int('7') f = float(length) s = str(bytes)</span></span></code> </pre> <br><p>  Todos os tipos são chamados objetos e todos retornam valores de seu tipo, determinados pelos argumentos transmitidos na chamada. </p><br><p>  Assim, usando apenas a sintaxe básica da linguagem, qualquer manipulação na criação de objetos, como os padrões “Arena” ou “Adaptação”, pode ser encapsulada, pois outra ótima idéia emprestada do C ++ é que o próprio tipo determina como isso acontece gerando seus objetos, como o <code>new</code> operador trabalha para ele. </p><br><h1>  E quanto a NULL? </h1><br><p>  O manuseio de um ponteiro nulo aumenta a complexidade do programa, portanto, proibimos o uso de NULL.  A sintaxe do Python torna impossível criar um ponteiro nulo.  Duas operações elementares em ponteiros, sobre as quais falamos anteriormente, são definidas de tal maneira que qualquer variável aponta para algum objeto. </p><br><p>  Como resultado, o usuário não pode usar o Python para criar um erro relacionado a um acesso à memória, como um erro de segmentação ou fora dos limites do buffer.  Em outras palavras, os programas Python não são afetados pelos dois tipos de vulnerabilidades mais perigosos que ameaçam a segurança da Internet nos últimos 20 anos. </p><br><p>  Você pode perguntar: "Se a estrutura das operações nos objetos não for alterada, como vimos anteriormente, como os usuários criarão suas próprias classes, com métodos e atributos não listados nessa estrutura?" </p><br><p>  A mágica está no fato de que, para classes personalizadas, o Python possui uma "preparação" muito simples, com um pequeno número de métodos implementados.  Aqui estão os mais importantes: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> {</span></span> getattrfunc tr_getattr; setattrfunc tr_setattr; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> newfunc tp_new; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  <code>tp_new()</code> cria uma tabela de hash para a classe de usuário, a mesma do tipo <code>dict</code> .  <code>tp_getattr()</code> extrai algo dessa tabela de hash e <code>tp_setattr()</code> , pelo contrário, coloca algo lá.  Assim, a capacidade das classes arbitrárias de armazenar quaisquer métodos e atributos é fornecida não no nível das estruturas da linguagem C, mas em um nível superior - uma tabela de hash.  (Obviamente, com exceção de alguns casos relacionados à otimização de desempenho.) </p><br><h1>  Modificadores de acesso </h1><br><p>  O que fazemos com todas as regras e conceitos criados em torno das palavras-chave C ++ <code>private</code> e <code>protected</code> ?  Python, sendo uma linguagem de script, não precisa deles.  Já temos partes "protegidas" do idioma - esses são dados de tipos internos.  Sob nenhuma circunstância o Python permitirá que um programa, por exemplo, manipule os bits de um número de ponto flutuante!  Esse nível de encapsulamento é suficiente para manter a integridade do próprio idioma.  Nós, criadores do Python, acreditamos que a integridade da linguagem é o único bom pretexto para ocultar informações.  Todas as outras estruturas e dados do programa do usuário são considerados públicos. </p><br><p>  Você pode escrever um sublinhado ( <code>_</code> ) no início de um nome de atributo de classe para avisar um colega: você não deve confiar nesse atributo.  Mas o restante do Python aprendeu as lições do início dos anos 90: então muitos acreditavam que a principal razão pela qual escrevemos programas inchados, ilegíveis e com erros é a falta de variáveis ​​privadas.  Acho que os próximos 20 anos convenceram a todos na indústria de programação: variáveis ​​privadas não são as únicas e estão longe de ser o remédio mais eficaz para programas inchados e com erros.  Portanto, os criadores do Python decidiram nem se preocupar com variáveis ​​privadas e, como você pode ver, elas não falharam. </p><br><h1>  Gerenciamento de memória </h1><br><p>  O que acontece com nossos objetos, números e seqüências de caracteres em um nível inferior?  Como exatamente eles são armazenados na memória, como o CPython fornece acesso compartilhado a eles, quando e sob quais condições eles são destruídos? </p><br><p>  E, nesse caso, escolhemos a maneira mais geral, previsível e produtiva de trabalhar com a memória: do lado do programa C, todos os nossos objetos são <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ponteiros compartilhados</a> . </p><br><p>  Com esse conhecimento em mente, as estruturas de dados que examinamos anteriormente na seção "Variáveis ​​e tipos de dados" devem ser complementadas da seguinte maneira: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Py_ssize_t ob_refcnt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ob_type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* followed by object's data */</span></span> } }</code> </pre> <br><p>  Portanto, todo objeto em Python (queremos dizer a implementação do CPython, é claro) tem seu próprio contador de referência.  Depois de zero, o objeto pode ser excluído. </p><br><p>  O mecanismo de contagem de links não depende de cálculos adicionais ou processos em segundo plano - um objeto pode ser destruído instantaneamente.  Além disso, fornece alta localidade dos dados: geralmente, a memória começa a ser usada novamente imediatamente após ser liberada.  O objeto recém-destruído provavelmente foi usado recentemente, o que significa que estava no cache do processador.  Portanto, o objeto recém-criado permanecerá no cache.  Esses dois fatores - simplicidade e localidade - tornam a contagem de links uma maneira muito produtiva de coleta de lixo. </p><br><p>  (Como objetos em programas reais geralmente se referem um ao outro, o contador de referência em certos casos não pode cair para zero, mesmo quando os objetos não são mais usados ​​no programa. Portanto, o CPython também possui um segundo mecanismo de coleta de lixo - um segundo, baseado em em gerações de objetos - <em>aproximadamente tradução</em> ) </p><br><h1>  Erros de desenvolvedor Python </h1><br><p>  Tentamos desenvolver uma linguagem que fosse simples o suficiente para iniciantes, mas também atraente o suficiente para profissionais.  Ao mesmo tempo, não fomos capazes de evitar erros no entendimento e no uso das ferramentas que nós mesmos criamos. </p><br><p>  O Python 2, devido à inércia do pensamento associado às linguagens de script, tentou converter tipos de string, como faria uma linguagem com digitação fraca.  Se você tentar combinar uma sequência de bytes com uma sequência em Unicode, o intérprete converte implicitamente a sequência de bytes em Unicode usando a tabela de códigos disponível no sistema e apresenta o resultado em Unicode: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">'byte string '</span></span> + <span class="hljs-string"><span class="hljs-string">u'unicode string'</span></span> <span class="hljs-string"><span class="hljs-string">u'byte string unicode string'</span></span></code> </pre> <br><p>  Como resultado, alguns sites funcionaram bem enquanto seus usuários usavam o inglês, mas eles produziram erros enigmáticos ao usar caracteres de outros alfabetos. </p><br><p>  Este erro de design de linguagem foi corrigido no Python 3: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">b'byte string '</span></span> + <span class="hljs-string"><span class="hljs-string">u'unicode string'</span></span> TypeError: can<span class="hljs-string"><span class="hljs-string">'t concat bytes to str</span></span></code> </pre> <br><p>  Um erro semelhante no Python 2 estava relacionado à classificação "ingênua" de listas que consistem em elementos incomparáveis: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>sorted([<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]</code> </pre> <br><p>  O Python 3, neste caso, deixa claro para o usuário que ele está tentando fazer algo não muito significativo: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>sorted([<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) TypeError: unorderable types: int() &lt; str()</code> </pre> <br><h1>  Abusos </h1><br><p>  De vez em quando, os usuários às vezes abusam da natureza dinâmica da linguagem Python e, nos anos 90, quando as práticas recomendadas ainda não eram amplamente conhecidas, isso acontecia com frequência: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, host, port)</span></span></span><span class="hljs-function">:</span></span> self.host = host self.port = port</code> </pre> <br><p>  "Mas isso não é o ideal!"  - Alguns disseram: - “E se a porta não diferir do valor padrão?  De qualquer forma, gastamos um atributo de classe inteiro em seu armazenamento! ”  E o resultado é algo como </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, host, port=None)</span></span></span><span class="hljs-function">:</span></span> self.host = host <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> port <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-comment"><span class="hljs-comment"># so terrible self.port = port</span></span></code> </pre> <br><p>  Portanto, objetos do mesmo tipo aparecem no programa, que, no entanto, não podem ser operados de maneira uniforme, pois alguns deles têm um determinado atributo, enquanto outros não!  E não podemos tocar nesse atributo sem verificar sua presença com antecedência: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># code was forced to use introspection # (terrible!) if hasattr(addr, 'port'): print(addr.port)</span></span></code> </pre> <br><p>  Atualmente, a abundância de <code>hasattr()</code> , <code>isinstance()</code> e outras introspecções é um sinal seguro de código incorreto e é considerado uma boa prática tornar atributos sempre presentes no objeto.  Isso fornece uma sintaxe mais simples ao acessá-lo: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># today's best practice: # every atribute always present if addr.port is not None: print(addr.port)</span></span></code> </pre> <br><p>  Portanto, os primeiros experimentos com atributos excluídos e adicionados dinamicamente terminaram, e agora analisamos as classes no Python da mesma maneira que no C ++. </p><br><p>  Outro mau hábito do Python inicial era o uso de funções nas quais um argumento pode ter tipos completamente diferentes.  Por exemplo, você pode pensar que pode ser muito difícil para o usuário criar uma lista de nomes de colunas a cada vez e permitir que ele os passe também como uma única linha, onde os nomes de colunas individuais são separados por, por exemplo, uma vírgula: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dataframe</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, columns)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(columns, str): columns = columns.split(<span class="hljs-string"><span class="hljs-string">','</span></span>) self.columns = columns</code> </pre> <br><p>  Mas essa abordagem pode dar origem a seus problemas.  Por exemplo, e se um usuário acidentalmente nos fornecer uma linha que não se destina a ser usada como uma lista de nomes de colunas?  Ou se o nome da coluna deve conter uma vírgula? </p><br><p>  Além disso, esse código é mais difícil de manter, depurar e especialmente testar: nos testes, apenas um dos dois tipos suportados por nós pode ser verificado, mas a cobertura ainda será 100% e não testaremos o outro tipo. </p><br><p>  Como resultado, chegamos à conclusão de que o Python permite que o usuário passe argumentos de qualquer tipo para funções, mas a maioria deles na maioria das situações usará uma função da mesma maneira que em C: passará um argumento do mesmo tipo para ela. </p><br><p>  A necessidade de usar <code>eval()</code> em um programa é considerada um erro de cálculo explícito da arquitetura.  Provavelmente, você simplesmente não descobriu como fazer o mesmo de uma maneira normal.     − ,      Jupyter notebook  -       −  <code>eval()</code>  ,      Python   ! ,     C++    . </p><br><p>     ,  ( <code>getattr()</code> , <code>hasattr()</code> , <code>isinstance()</code> )          .   ,   ,   ,      ,       : , ,  , ! </p><br><h1>   </h1><br><p>      :     ,           . 20             ,   C++  Python.   ,     ,    .         . </p><br><p>        ,    <code>shared_ptr</code>  TensorFlow   2016  2018 . </p><br><p> TensorFlow −       C++-,         Python- ( C++ −     TensorFlow, ). </p><br><p><img src="https://habrastorage.org/webt/dm/1g/zo/dm1gzovjtl2qbda7muz5wjzzjhq.png" alt="imagem"></p><br><p>         TensorFlow,  <code>shared_ptr</code> ,     .     ,     . </p><br><p>      C++?       .    ,   ?     ,     ,  C++  Python! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464405/">https://habr.com/ru/post/pt464405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464391/index.html">10 relatórios interessantes de conferências de hackers</a></li>
<li><a href="../pt464393/index.html">Como encontrar cursos de programação e quais são as garantias de emprego</a></li>
<li><a href="../pt464395/index.html">Aleatório baseado em blockchain RSA</a></li>
<li><a href="../pt464399/index.html">Raspagem da Web no R, Parte 2. Acelerando o processo com computação paralela e usando o pacote Rcrawler</a></li>
<li><a href="../pt464403/index.html">Como executar um projeto java em um shell runner ao enviar para um repositório GitLab</a></li>
<li><a href="../pt464407/index.html">Como funcionam os maiores sistemas de vigilância por vídeo do mundo</a></li>
<li><a href="../pt464409/index.html">Como a política do século XIX afetou hoje as localizações de data centers</a></li>
<li><a href="../pt464411/index.html">PVS-Studio: Motor do progresso</a></li>
<li><a href="../pt464413/index.html">PVS-Studio - mecanismo de progresso</a></li>
<li><a href="../pt464415/index.html">Novo serviço de dica para pesquisar hh.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>