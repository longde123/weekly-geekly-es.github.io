<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🔬 🔄 🤹🏻 Dropbox客户端逆向工程 😧 👩🏾‍🤝‍👩🏻 🙏🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL； DR。 本文讨论了Dropbox客户端的反向开发，用Python破解了客户端的混淆和反编译机制，以及更改了程序以激活正常模式下隐藏的调试功能。 如果您只对适当的代码和说明感兴趣，请滚动到末尾。 在撰写本文时，该代码与基于CPython 3.6解释器的最新Dropbox版本兼容。 

 引言 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dropbox客户端逆向工程</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452276/">  <i>TL； DR。</i>  <i>本文讨论了Dropbox客户端的反向开发，用Python破解了客户端的混淆和反编译机制，以及更改了程序以激活正常模式下隐藏的调试功能。</i>  <i>如果您只对适当的代码和说明感兴趣，请滚动到末尾。</i>  <i>在撰写本文时，该代码与基于CPython 3.6解释器的最新Dropbox版本兼容。</i> <br><br><h3> 引言 </h3><br>  Dropbox立即使我着迷。 这个概念看似仍然简单。 这是文件夹。 将文件放在那里。 已同步。 转到另一台设备。 再次同步。 文件夹和文件现在也在那里出现了！ <br><br> 隐藏的后台工作量真是惊人。 首先，在为主要桌面操作系统（OS X，Linux，Windows）创建和维护跨平台应用程序时必须解决的所有问题都不会消失。 除此之外，还支持各种Web浏览器，各种移动操作系统。 我们只是在谈论客户端。 我对Dropbox后端也很感兴趣，Dropbox后端使我得以实现这种可扩展性和低延迟，而十亿用户的工作量却如此之大。 <br><a name="habracut"></a><br> 出于这些原因，我一直喜欢观察Dropbox的功能以及这些年来的发展。 大约八年前，当我注意到在旅馆中广播未知流量时，我首先尝试找出Dropbox客户端的实际工作方式。 调查表明，这是Dropbox功能LanSync的一部分，该功能称为LanSync，如果同一LAN上的Dropbox主机可以访问相同的文件，则可以使您更快地进行同步。 但是，该协议没有记录在案，我想了解更多。 因此，我决定更详细地研究一下，结果，我对几乎整个程序进行了逆向工程。 这项研究从未发表过，尽管我有时会与一些人分享笔记。 <br><br> 当我们开设Anvil Ventures时，克里斯和我赞赏许多用于文档存储，共享和协作的工具。 显然，其中之一是Dropbox，对我来说，这是挖掘旧研究并在客户端的当前版本上进行检查的另一个原因。 <br><br><h3> 解密和模糊处理 </h3><br> 首先，我下载了Linux客户端，并很快发现它是用Python编写的。 由于Python许可相当宽松，因此人们可以轻松修改和分发Python解释器以及其他依赖项，例如商业软件。 然后，我开始进行逆向工程，以了解客户端的工作方式。 <br><br> 当时，具有字节码的文件位于ZIP文件中，并带有可执行二进制文件。 主要的二进制文件只是一个经过修改的Python解释器，该解释器是通过捕获Python导入机制加载的。 随后的每个导入调用都通过ZIP文件解析重定向到此二进制文件。 当然，从二进制文件中提取此ZIP很容易。 例如，有用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">binwalk</a>工具将其与所有字节编译的.pyc文件一起检索。 <br><br> 然后，我无法破坏.pyc文件的加密，但是最后，我将标准Python库的通用对象重新编译，并在内部注入了后门。 现在，Dropbox客户端正在加载该对象，我可以轻松地在工作的解释器中执行任意Python代码。 尽管我自己发现了此方法，但Florian Leda和Nicolas Raff在2012年关于Hack.lu的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示中</a>使用了相同的方法。 <br><br> 探索和操纵Dropbox中正在运行的代码的能力已经揭示了很多。 该代码使用了一些保护性技巧，使其难以转储<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码对象</a> 。 例如，在常规的CPython解释器中，很容易恢复代表函数的已编译字节码。 一个简单的例子： <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i * i ... &gt;&gt;&gt; f.__code__ &lt;code object f at <span class="hljs-number"><span class="hljs-number">0x109deb540</span></span>, file <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &gt;&gt;&gt; f.__code__.co_code <span class="hljs-string"><span class="hljs-string">b'|\x00|\x00\x14\x00S\x00'</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dis &gt;&gt;&gt; dis.dis(f) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> LOAD_FAST <span class="hljs-number"><span class="hljs-number">0</span></span> (i) <span class="hljs-number"><span class="hljs-number">2</span></span> LOAD_FAST <span class="hljs-number"><span class="hljs-number">0</span></span> (i) <span class="hljs-number"><span class="hljs-number">4</span></span> BINARY_MULTIPLY <span class="hljs-number"><span class="hljs-number">6</span></span> RETURN_VALUE &gt;&gt;&gt;</code> </pre> <br> 但是在<i>Objects / codeobject.c</i>的编译版本中<i>，co_code</i>属性已从打开列表中删除。 该成员列表通常看起来像这样： <br><br><pre> <code class="python hljs"> static PyMemberDef code_memberlist[] = { ... {<span class="hljs-string"><span class="hljs-string">"co_flags"</span></span>, T_INT, OFF(co_flags), READONLY}, {<span class="hljs-string"><span class="hljs-string">"co_code"</span></span>, T_OBJECT, OFF(co_code), READONLY}, {<span class="hljs-string"><span class="hljs-string">"co_consts"</span></span>, T_OBJECT, OFF(co_consts), READONLY}, ... };</code> </pre> <br>  <code>co_code</code>属性的消失使得无法转储这些代码对象。 <br><br> 此外，还删除了其他库，例如标准的Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反汇编程序</a> 。 最后，我仍然设法将代码对象转储到文件中，但是仍然无法反编译它们。 我花了一些时间才意识到Dropbox解释器使用的操作码与Python的标准操作码不匹配。 因此，有必要了解新的操作码，以便将代码对象改写回原始的Python字节码。 <br><br> 一种选择是操作码重新映射。 据我所知，该技术由Rich Smith开发，并在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Defcon 18上</a>引入。 在那次演讲中，他还展示了用于对内存中的Python字节码进行逆向工程的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pyREtic</a>工具。 似乎对pyREtic代码的支持不佳，该工具针对的是“旧的” Python 2.x二进制文件。 要熟悉Rich提出的技术，强烈建议观看他的表演。 <br><br> 操作码转换方法采用标准Python库的所有代码对象，并将它们与从Dropbox二进制文件中提取的对象进行比较。 例如，来自<i>hashlib.pyc</i>或<i>socket.pyc的</i>代码对象在标准库中。 假设，如果每次<code>0x43</code>操作码对应于解模糊的0x21 <code>0x21</code> ，我们就可以逐步构建一个转换表来重写代码对象。 然后，这些代码对象可以通过Python反编译器传递。 要转储，您仍然需要带有正确<code>co_code</code>对象的正确解释器。 <br><br> 另一种选择是破解序列化格式。 在Python中，序列化称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">封送处理</a> 。 以常规方式反序列化模糊处理的文件不起作用。 在IDA Pro中对二进制文件进行反向工程时，我发现了解密步骤。 据我所知，第一个对此主题进行公开发布的人是Hagen Fritch在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">他的博客上</a> 。 他在那里提到了Dropbox新版本中的更改（当Dropbox从Python 2.5切换到Python 2.7时）。 该算法的工作原理如下： <br><br><ul><li> 解压缩pyc文件时，会读取标头以确定封送处理的版本。 除了CPython本身的实现之外，没有记录此格式。 <br></li><li> 该格式定义了其中编码的类型的列表。 类型为<code>True</code> ， <code>False</code> ， <code>floats</code>等，但最重要的是上述Python <code>code object</code>的类型<code>code object</code> 。 <br></li><li> 加载<code>code object</code> ，首先从输入文件中读取两个附加值。 <br></li><li> 第一个是32位<code>random</code>值。 <br></li><li> 第二个是一个32位<code>length</code>值，指示序列化代码对象的大小。 <br></li><li> 然后，将<code>rand</code>和<code>length</code>值<code>rand</code>到一个生成<code>seed</code>的简单RNG函数。 <br></li><li> 该种子被传递到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mersenne涡旋</a> ，后者生成四个32位值。 <br></li><li> 这四个值结合在一起，为序列化数据提供了加密密钥。 然后，加密算法使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tiny Encryption Algorithm</a>解密数据。 </li></ul><br> 在我的代码中，我从头开始编写Python解组过程。 解密代码对象的部分看起来像下面的片段。 应当注意，该方法将必须递归调用。  pyc文件的顶级对象是一个代码对象，其本身包含代码对象，这些对象可以是类，函数或lambda。 反过来，它们也可以包含方法，函数或lambda。 这些都是层次结构中的所有代码对象！ <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> rand = self.r_long() length = self.r_long() seed = rng(rand, length) mt = MT19937(seed) key = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>): key.append(mt.extract_number()) <span class="hljs-comment"><span class="hljs-comment"># take care of padding for size calculation sz = (length + 15) &amp; ~0xf words = sz / 4 # convert data to list of dwords buf = self._read(sz) data = list(struct.unpack("&lt;%dL" % words, buf)) # decrypt and convert back to stream of bytes data = tea.tea_decipher(data, key) data = struct.pack("&lt;%dL" % words, *data)</span></span></code> </pre> <br> 解密代码对象的能力意味着在反序列化过程之后，您需要重写实际的字节码。 代码对象包含有关行号，常量和其他信息的信息。 实际的字节码在<code>co_code</code>对象中。 建立操作码转换表时，我们可以简单地用标准的Python 3.6等效项替换模糊的Dropbox值。 <br><br> 现在，代码对象采用通常的Python 3.6格式，并且可以将其传递给反编译器。 由于R. Bernstein的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">uncompyle6</a>项目，Python反编译器的质量得到了显着<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提高</a> 。 反编译提供了相当不错的效果，并且我能够将所有内容放到一个工具中，该工具会尽其所能反编译当前版本的Dropbox客户端。 <br><br> 如果克隆此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储库</a>并按照说明进行操作，则结果将如下所示： <br><br><pre>  ...
     __main__-信息-成功反编译了保管箱/客户端/功能/ browse_search / __初始化__。pyc
     __main__-信息-解密，修补和反编译_bootstrap_overrides.pyc
     __main__-信息-成功反编译_bootstrap_overrides.pyc
     __main__-信息-处理了3713个文件（成功反编译了3591个文件，失败了122个文件）
     opcodemap-警告-由于未设置强制覆盖，因此未写入操作码映射 </pre><br> 这意味着您现在拥有一个<code>out/</code>目录，其中包含反编译版本的Dropbox源代码。 <br><br><h3> 启用Dropbox跟踪 </h3><br> 在开源中，我开始寻找一些有趣的东西，以下片段吸引了我的注意力。 仅当程序集未冻结或在第<code>1430</code>行中未设置限制功能的魔术键或cookie时，才安装<code>out/dropbox/client/high_trace.py</code>中的跟踪处理程序。 <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">1424</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">install_global_trace_handlers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(flags=None, args=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">1425</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> _tracing_initialized <span class="hljs-number"><span class="hljs-number">1426</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _tracing_initialized: <span class="hljs-number"><span class="hljs-number">1427</span></span> TRACE(<span class="hljs-string"><span class="hljs-string">'!! Already enabled tracing system'</span></span>) <span class="hljs-number"><span class="hljs-number">1428</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1429</span></span> _tracing_initialized = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-number"><span class="hljs-number">1430</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> build_number.is_frozen() <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> magic_trace_key_is_set() <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> limited_support_cookie_is_set(): <span class="hljs-number"><span class="hljs-number">1431</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.getenv(<span class="hljs-string"><span class="hljs-string">'DBNOLOCALTRACE'</span></span>): <span class="hljs-number"><span class="hljs-number">1432</span></span> add_trace_handler(db_thread(LtraceThread)().trace) <span class="hljs-number"><span class="hljs-number">1433</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.getenv(<span class="hljs-string"><span class="hljs-string">'DBTRACEFILE'</span></span>): <span class="hljs-number"><span class="hljs-number">1434</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br> 提及冻结的构建是指Dropbox的内部调试构建。 在同一个文件中，您可以找到以下几行： <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">272</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_valid_time_limited_cookie</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cookie)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">273</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-number"><span class="hljs-number">274</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-number"><span class="hljs-number">275</span></span> t_when = int(cookie[:<span class="hljs-number"><span class="hljs-number">8</span></span>], <span class="hljs-number"><span class="hljs-number">16</span></span>) ^ <span class="hljs-number"><span class="hljs-number">1686035233</span></span> <span class="hljs-number"><span class="hljs-number">276</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError: <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-number"><span class="hljs-number">278</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-number"><span class="hljs-number">279</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> abs(time.time() - t_when) &lt; SECONDS_PER_DAY * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> md5(make_bytes(cookie[:<span class="hljs-number"><span class="hljs-number">8</span></span>]) + <span class="hljs-string"><span class="hljs-string">b'traceme'</span></span>).hexdigest()[:<span class="hljs-number"><span class="hljs-number">6</span></span>] == cookie[<span class="hljs-number"><span class="hljs-number">8</span></span>:]: <span class="hljs-number"><span class="hljs-number">280</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-number"><span class="hljs-number">281</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception: <span class="hljs-number"><span class="hljs-number">282</span></span> report_exception() <span class="hljs-number"><span class="hljs-number">283</span></span> <span class="hljs-number"><span class="hljs-number">284</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-number"><span class="hljs-number">285</span></span> <span class="hljs-number"><span class="hljs-number">286</span></span> <span class="hljs-number"><span class="hljs-number">287</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">limited_support_cookie_is_set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">288</span></span> dbdev = os.getenv(<span class="hljs-string"><span class="hljs-string">'DBDEV'</span></span>) <span class="hljs-number"><span class="hljs-number">289</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dbdev <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_valid_time_limited_cookie(dbdev) build_number/environment.py</code> </pre> <br> 从第<code>287</code>行的<code>limited_support_cookie_is_set</code>方法中可以看到，只有在名为<code>DBDEV</code>的环境变量正确设置为寿命有限的cookie时，才启用跟踪。 好吧，这很有趣！ 现在，我们知道了如何生成此类限时Cookie。 根据名称判断，Dropbox工程师可以生成此类cookie，然后在需要支持客户的某些情况下临时启用跟踪。 重新启动Dropbox或重新启动计算机后，即使指定的cookie仍然存在，它也会自动过期。 我想这应该防止例如由于连续跟踪而导致的性能下降。 这也使反向工程Dropbox变得困难。 <br><br> 但是，一个小的脚本可以简单地不断生成和设置这些cookie。 像这样： <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 def output_env(name, value): print("%s=%s; export %s" % (name, value, name)) def generate_time_cookie(): t = int(time.time()) c = 1686035233 s = "%.8x" % (t ^ c) h = md5(s.encode("utf-8?") + b"traceme").hexdigest() ret = "%s%s" % (s, h[:6]) return ret c = generate_time_cookie() output_env("DBDEV", c)</span></span></code> </pre> <br> 然后创建一个基于时间的cookie： <br><br><pre> <code class="python hljs"> $ python3 setenv.py DBDEV=<span class="hljs-number"><span class="hljs-number">38</span></span>b28b3f349714; export DBDEV;</code> </pre> <br> 然后，将该脚本的输出正确加载到环境中并运行Dropbox客户端。 <br><br><pre> <code class="python hljs"> $ eval `python3 setenv.py` $ ~/.dropbox-dist/dropbox-lnx_64<span class="hljs-number"><span class="hljs-number">-71.4</span></span><span class="hljs-number"><span class="hljs-number">.108</span></span>/dropbox</code> </pre> <br> 这包括跟踪输出，彩色格式等。 看起来像这个未注册的客户端： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e83/d0a/a4f/e83d0aa4f475709108cb1cfc0cb16d74.png"><br><br><h3> 实施新守则 </h3><br> 这一切都有些有趣。 进一步研究反编译的代码，我们找到<code>out/build_number/environment.pyc</code> 。 有一个功能可以检查是否安装了特定的魔术钥匙。 该密钥未在代码中进行硬编码，但会与SHA-256哈希进行比较。 这是相应的代码段。 <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib, os <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Optional, Text <span class="hljs-number"><span class="hljs-number">3</span></span> _MAGIC_TRACE_KEY_IS_SET = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">magic_trace_key_is_set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> _MAGIC_TRACE_KEY_IS_SET <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _MAGIC_TRACE_KEY_IS_SET <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> dbdev = os.getenv(<span class="hljs-string"><span class="hljs-string">'DBDEV'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(dbdev, Text): <span class="hljs-number"><span class="hljs-number">10</span></span> bytes_dbdev = dbdev.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>) <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> bytes_dbdev = dbdev <span class="hljs-number"><span class="hljs-number">13</span></span> dbdev_hash = hashlib.sha256(bytes_dbdev).hexdigest() <span class="hljs-number"><span class="hljs-number">14</span></span> _MAGIC_TRACE_KEY_IS_SET = dbdev_hash == <span class="hljs-string"><span class="hljs-string">'e27eae61e774b19f4053361e523c771a92e838026da42c60e6b097d9cb2bc825'</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _MAGIC_TRACE_KEY_IS_SET</code> </pre> <br> 从代码的不同位置多次调用此方法，以检查是否设置了魔术跟踪键。 我尝试使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开膛手约翰（John the Ripper）</a>蛮力破解SHA-256哈希，但是简单的蛮力花费了很长时间，并且由于无法猜测内容，我无法减少选项的数量。 在Dropbox中，开发人员可以具有特定的硬编码开发密钥，必要时可以安装该密钥，从而激活客户端的“魔术密钥”模式进行跟踪。 <br><br> 这让我很烦，因为我想找到一种快速简便的方法来启动具有这组用于跟踪的键的Dropbox。 因此，我编写了一个封送处理程序，该程序根据Dropbox加密生成加密的pyc文件。 因此，我能够输入自己的代码或简单地替换上面的哈希。  Github存储库中的此代码位于<code>patchzip.py</code>文件中。 结果，该哈希被<code>ANVILVENTURES</code>的SHA-256哈希<code>ANVILVENTURES</code> 。 然后，将代码对象重新加密并放在zip中，所有混淆后的代码都存储在其中。 这使您可以执行以下操作： <br><br><pre>  $ DBDEV = ANVILVENTURES; 导出DBDEV;
     $〜/ .dropbox-dist / dropbox-lnx_64-71.4.108 / dropbox </pre><br> 现在，在系统托盘中的Dropbox图标上单击鼠标右键时，将显示所有调试功能。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/619/c68/385/619c6838574ff7023a0dbdf27b880b2d.png"></div><br><br> 在文件<code>dropbox/webdebugger/server.py</code>文件中进一步研究了反编译的源，我发现了一个名为<code>is_enabled</code>的方法。 似乎正在检查是否启用内置的Web调试器。 首先，他检查提到的魔术钥匙。 由于我们替换了SHA-256哈希，因此我们可以简单地将值设置为<code>ANVILVENTURES</code> 。 第<code>201</code>和<code>202</code>行的第二部分检查是否存在一个名为<code>DB&lt;x&gt;</code>的环境变量，该变量的<code>x</code>等于SHA-256哈希。 正如我们已经看到的，环境的价值设置了有时间限制的cookie。 <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">191</span></span> @classmethod <span class="hljs-number"><span class="hljs-number">192</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_enabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">193</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cls._magic_key_set: <span class="hljs-number"><span class="hljs-number">194</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cls._magic_key_set <span class="hljs-number"><span class="hljs-number">195</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-number"><span class="hljs-number">196</span></span> cls._magic_key_set = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-number"><span class="hljs-number">197</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> magic_trace_key_is_set(): <span class="hljs-number"><span class="hljs-number">198</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-number"><span class="hljs-number">199</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.environ: <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.startswith(<span class="hljs-string"><span class="hljs-string">'DB'</span></span>): <span class="hljs-number"><span class="hljs-number">201</span></span> var_hash = hashlib.sha256(make_bytes(var[<span class="hljs-number"><span class="hljs-number">2</span></span>:])).hexdigest() <span class="hljs-number"><span class="hljs-number">202</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var_hash == <span class="hljs-string"><span class="hljs-string">'5df50a9c69f00ac71f873d02ff14f3b86e39600312c0b603cbb76b8b8a433d3ff0757214287b25fb01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_valid_time_limited_cookie(os.environ[var]): <span class="hljs-number"><span class="hljs-number">203</span></span> cls._magic_key_set = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-number"><span class="hljs-number">204</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-number"><span class="hljs-number">205</span></span> <span class="hljs-number"><span class="hljs-number">206</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br> 使用完全相同的技术，用以前使用的SHA-256替换此哈希，现在我们可以将以前编写的<code>setenv</code>脚本更改为以下内容： <br><br><pre> <code class="python hljs"> $ cat setenv.py … c = generate_time_cookie() output_env(<span class="hljs-string"><span class="hljs-string">"DBDEV"</span></span>, <span class="hljs-string"><span class="hljs-string">"ANVILVENTURES"</span></span>) output_env(<span class="hljs-string"><span class="hljs-string">"DBANVILVENTURES"</span></span>, c) $ python3 setenv.py DBDEV=ANVILVENTURES; export DBDEV; DBANVILVENTURES=<span class="hljs-number"><span class="hljs-number">38</span></span>b285c4034a67; export DBANVILVENTURES $ eval `python3 setenv.py` $ ~/.dropbox-dist/dropbox-lnx_64<span class="hljs-number"><span class="hljs-number">-71.4</span></span><span class="hljs-number"><span class="hljs-number">.108</span></span>/dropbox</code> </pre> <br> 如您所见，启动客户端后，将打开一个新的TCP端口以进行侦听。 如果环境变量设置不正确，它将无法打开。 <br><br><pre>  $ netstat --tcp -lnp |  grep保管箱
     tcp 0 0 127.0.0.1:4242 0.0.0.0:* LISTEN 1517 /投递箱 </pre><br> 在代码的进一步部分，您可以在<code>webpdb.pyc</code>文件中找到WebSocket接口。 这是标准python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pdb</a>实用程序的包装。 通过该端口上的HTTP服务器访问接口。 让我们安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">websocket客户端</a>并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">尝试</a>一下： <br><br><pre>  $ websocat -t ws：//127.0.0.1：4242 / pdb
     -返回-
    
     &gt; /home/gvb/dropbox/webdebugger/webpdb.pyc(101)run（）-&gt;无
     &gt;
     （Pdb）从build_number.environment导入magic_trace_key_is_set为ms
     （Pdb）毫秒（）
    是的 </pre><br> 因此，现在我们在客户端中拥有一个成熟的调试器，该调试器在所有其他方面都像以前一样工作。 我们可以执行任意的Python代码，并且能够启用内部调试菜单和跟踪功能。 所有这些将大大有助于进一步分析Dropbox客户端。 <br><br><h3> 结论 </h3><br> 我们能够对Dropbox进行反向工程，编写代码解密和注入工具，这些工具可与基于Python 3.6的当前Dropbox客户端一起使用。 我们对各个隐藏功能进行了反向工程并激活了它们。 显然，调试器将确实有助于进一步的黑客攻击。 特别是由于decompyle6的缺点，许多文件无法成功反编译。 <br><br><h3> 代号 </h3><br> 可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Github</a>上找到该代码。 那里的使用说明。 该存储库还包含我在2011年编写的旧代码。 如果有人具有基于Python 2.7的较旧版本的Dropbox，则它应该仅需进行少量修改即可使用。 <br><br> 该存储库还包含用于广播操作码的脚本，用于设置Dropbox环境变量的说明以及更改zip文件所需的一切。 <br><br><h3> 致谢 </h3><br> 感谢Anvil Ventures的Brian审核了我的代码。 这段代码的工作持续了好几年，我不时地对其进行了更新，引入了新的方法并重写了片段以使其恢复以在新版本的Dropbox上运行。 <br><br> 如前所述，Rich Smith，Florian Ledoux和Nicolas Raff以及Hagen Fritch的工作是反向工程Python应用程序的一个很好的起点。 特别是他们的工作与世界上最大的Python应用程序之一-Dropbox客户端的反向开发有关。 <br><br> 应当指出的是，由于R. Bernstein领导的uncompyle6项目，Python代码的反编译有了很大的进步。 该反编译器已经编译并改进了许多不同的Python反编译器。 <br><br> 也非常感谢Brian，Austin，Stefan和Chris的同事审阅了这篇文章。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN452276/">https://habr.com/ru/post/zh-CN452276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN452264/index.html">我们如何制作吉祥物汽车奖网站</a></li>
<li><a href="../zh-CN452266/index.html">无服务器机架</a></li>
<li><a href="../zh-CN452268/index.html">C＃WPF模拟Window.ShowDialog（）或处理DispatcherFrame</a></li>
<li><a href="../zh-CN452270/index.html">Xamarin API文档现已公开可用</a></li>
<li><a href="../zh-CN452272/index.html">瀑布下的女孩</a></li>
<li><a href="../zh-CN452278/index.html">蓝牙LE并不那么令人恐惧，或者如何轻松改善用户体验</a></li>
<li><a href="../zh-CN452280/index.html">PostgreSQL 11：分区从Postgres 9.6到Postgres 11的演变</a></li>
<li><a href="../zh-CN452282/index.html">Watson的Elementary：与Voximplant集成</a></li>
<li><a href="../zh-CN452284/index.html">使用eo-learn对土地覆盖进行分类。 第一部分</a></li>
<li><a href="../zh-CN452288/index.html">情况：美国移动运营商被指控订户地理数据非法交易</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>