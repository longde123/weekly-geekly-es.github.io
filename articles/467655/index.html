<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👹 🌳 👶🏽 Cómo pasé el verano con C # 8 🆗 🍴 🤒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un lanzamiento reciente del podcast DotNet & More Blazor, NetCore 3.0 Preview, C # 8 y no solo mencionamos casualmente un tema tan candente como C ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo pasé el verano con C # 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467655/"><p>  En un lanzamiento reciente del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">podcast</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DotNet &amp; More</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blazor, NetCore 3.0 Preview, C # 8 y no solo</a> mencionamos casualmente un tema tan candente como C # 8.  La historia sobre la experiencia con C # 8 no fue lo suficientemente grande como para dedicarle un tema por separado, por lo que se decidió compartir con ella los medios del género epistolar. </p><br><p>  En este artículo, me gustaría hablar sobre mi experiencia de usar C # 8 en producción durante 4 meses.  A continuación puede encontrar respuestas a las siguientes preguntas: </p><br><ul><li>  Cómo "deletrear" en el nuevo C # </li><li>  Qué características fueron realmente útiles </li><li>  Que decepcionado </li></ul><a name="habracut"></a><br><p>  Puede encontrar una lista completa de las características de C # 8 en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación oficial de Microsoft</a> .  En este artículo, omitiré aquellas oportunidades que no podría probar por una razón u otra, a saber: </p><br><ul><li>  Miembros de solo lectura </li><li>  Miembros de interfaz predeterminados </li><li>  Estructuras de referencia desechables </li><li>  Flujos asincrónicos </li><li>  Índices y rangos </li></ul><br><p>  Propongo comenzar con una de las posibilidades más deliciosas, como me pareció antes. </p><br><h3 id="switch-expressions">  Cambiar expresiones </h3><br><p> En nuestros sueños, presentamos esta función muy optimista: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exec</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Operation operation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; operation <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Operation.Summ =&gt; x + y, Operation.Diff =&gt; x - y, Operation.Mult =&gt; x * y, Operation.Div =&gt; x / y, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException() };</code> </pre> <br><p>  Pero, desafortunadamente, la realidad hace sus propios ajustes. <br>  En primer lugar, no hay posibilidad de combinar las condiciones: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrafficLights</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Signal signal</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (signal) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Red: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Yellow: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"stop"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Green: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"go"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  En la práctica, esto significa que en la mitad de los casos, la expresión del interruptor tendrá que convertirse en un interruptor regular para evitar copiar y pegar. </p><br><p>  En segundo lugar, la nueva sintaxis no admite declaraciones, es decir  código que no devuelve un valor.  Parecería, bueno, y no es necesario, pero yo mismo me sorprendí cuando me di cuenta de la frecuencia con la que se usa el interruptor (junto con la coincidencia de patrones) para una afirmación en las pruebas. </p><br><p>  En tercer lugar, la expresión switch, que se desprende del último párrafo, no admite manejadores de líneas múltiples.  Qué miedo entendemos al momento de agregar los registros: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecFull</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Operation operation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (operation) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Summ: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} + {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Diff: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} - {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Mult: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} * {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Div: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} / {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x / y; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  No quiero decir que el nuevo interruptor es malo.  No, él es bueno, simplemente no lo suficientemente bueno. </p><br><h3 id="property--positional-patterns">  Propiedad y patrones posicionales </h3><br><p>  Hace un año, me parecían los principales candidatos para el título de "oportunidad que cambió el desarrollo".  Y, como se esperaba, para utilizar todo el poder de los patrones posicionales y de propiedad, debe cambiar su enfoque de desarrollo.  Es decir, es necesario imitar los tipos de datos algebraicos. <br>  Parece que cuál es el problema: toma la interfaz del marcador y listo.  Desafortunadamente, este método tiene un serio inconveniente en un proyecto grande: nadie garantiza el seguimiento en tiempo de diseño de la expansión de sus tipos algebraicos.  Por lo tanto, es muy probable que con el tiempo, los cambios en el código conduzcan a muchos "fallos en el incumplimiento" en los lugares más inesperados. </p><br><h3 id="tuple-patterns">  Patrones de tuplas </h3><br><p>  Pero el "hermano menor" de las nuevas posibilidades de comparación con la muestra demostró ser realmente bien hecho.  La cuestión es que el patrón de tupla no requiere ningún cambio en la arquitectura familiar de nuestro código, simplemente simplifica algunos casos: </p><br><pre> <code class="cs hljs"> Player? Play(Gesture left, Gesture right) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (left, right) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Player.Left; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Player.Right; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  Pero la mejor parte es que esta característica, que es bastante predecible, funciona muy bien con el método Deconstruct.  Simplemente pase una clase con Deconstruct implementado para cambiar y usar las capacidades del patrón de tupla. </p><br><h3 id="using-declarations">  Usando declaraciones </h3><br><p>  Parecería una oportunidad menor, pero trae mucha alegría.  En todas las promociones, Microsoft habla sobre un aspecto como reducir la anidación.  Pero seamos honestos, no tanto lo que importa.  Pero lo realmente serio son los efectos secundarios de excluir un bloque de código: </p><br><ul><li>  A menudo, al agregar el uso, tenemos que extraer el código "dentro" del bloque usando el método de copiar y pegar.  Ahora simplemente no lo pensamos </li><li>  Las variables declaradas dentro del uso y usadas después de Eliminar el objeto que usa son un verdadero dolor de cabeza.  Un problema menos </li><li>  En las clases que requieren llamadas frecuentes de Dispose, cada método sería 2 líneas más largo.  Parecería un poco, pero en la condición de muchos métodos pequeños, este poco no permite mostrar una cantidad suficiente de estos métodos en una pantalla </li></ul><br><p>  Como resultado, algo tan simple como usar declaraciones cambia la sensación de codificación tanto que simplemente no desea volver a c # 7.3. </p><br><h3 id="static-local-functions">  Funciones locales estáticas </h3><br><p>  Para ser honesto, si no fuera por la ayuda del análisis de código, ni siquiera notaría esta posibilidad.  Sin embargo, se estableció firmemente en mi código: después de todo, las funciones locales estáticas son perfectamente adecuadas para el papel de pequeñas funciones puras, ya que no pueden soportar el cierre de las variables del método.  Como resultado, es más fácil para el corazón, porque comprende que hay un error potencial menos en su código. </p><br><h3 id="nullable-reference-types">  Tipos de referencia anulables </h3><br><p>  Y para el postre, me gustaría mencionar la característica más importante de C # 8.  En verdad, el análisis de tipos de referencia anulables merece un artículo separado.  Solo quiero describir las sensaciones. </p><br><ul><li>  En primer lugar, es maravilloso.  Podría haber descrito previamente mi intención explícita de declarar un campo o propiedad anulable, pero ahora esta función está integrada en el lenguaje. </li><li>  En segundo lugar, no guarda nada de NullReferenceException.  Y no estoy hablando de la notoria "obstrucción" en las advertencias.  Es solo que en tiempo de ejecución nadie genera ninguna comprobación de argumento nulo para usted, así que no se apresure a lanzar código como lanzar nuevo ArgumentNullException () </li><li>  En tercer lugar, hay un problema grave con el DTO.  Por ejemplo, anota una propiedad con el atributo Requerido.  En consecuencia, un objeto con una propiedad 100% no nula entrará en su controlador WebAPI.  Sin embargo, no es posible asociar este atributo y todos los atributos similares con comprobaciones de tipos de referencia anulables.  El caso es que si declaras <em>MyProperty</em> estándar <em>{get;</em>  <em>set;} una</em> propiedad con un tipo NotNull, recibirá una advertencia: <em>"[CS8618] La propiedad 'MyProperty' no anulable no está inicializada. Considere declarar la propiedad como anulable"</em> .  Lo cual es justo, ya que no puede garantizar una semántica no nula durante el proceso de inicialización.  El único resultado de esta característica es la incapacidad de usar propiedades no nulas en cualquier DTO.  Pero hay buenas noticias, hay una solución simple: simplemente inicialice su campo con el valor predeterminado: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MyProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> </li><li>  Cuarto, los atributos que manejan casos complejos, como TryGetValue, son bastante complejos.  Como resultado, es muy probable que los desarrolladores poco conscientes abusen de los operadores (!), Nivelando así las capacidades de los tipos de referencia anulables.  Una esperanza para los analizadores. </li><li>  Quinto, y lo más importante, personalmente esta oportunidad ya me ha salvado muchas veces de los errores de NullReferenceException.  Resulta un ahorro de tiempo banal: se detectan muchos errores en la etapa de compilación, y no pruebas o depuración.  Esto es especialmente cierto no solo en el proceso de desarrollar una lógica empresarial compleja, sino también en el caso de un trabajo trivial con bibliotecas externas, DTO y otras dependencias, que posiblemente contengan valores nulos. </li></ul><br><h2 id="rezyume">  Resumen </h2><br><p>  Por supuesto, las oportunidades presentadas no alcanzan una revolución completa, pero cada vez hay menos brecha entre C # y F # / Scala.  Ya sea bueno o malo, el tiempo lo dirá. </p><br><p>  En el momento del lanzamiento de este artículo, C # 8 puede que ya se haya asentado en su proyecto, por lo que me pregunto, ¿qué siente sobre la nueva versión de nuestro idioma favorito? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467655/">https://habr.com/ru/post/467655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467633/index.html">Petición: Informe automático y pago de impuestos sobre los ingresos de FLP (Ucrania)</a></li>
<li><a href="../467639/index.html">Semana de la seguridad 38: seguimiento de dispositivos móviles mediante tarjeta SIM</a></li>
<li><a href="../467645/index.html">Siguiendo a Angular Meetup # 15</a></li>
<li><a href="../467647/index.html">No cargue, no pruebe: cómo identificamos problemas con el sistema de gestión de documentos VTB</a></li>
<li><a href="../467653/index.html">Habrastatistics: análisis de comentarios de los lectores</a></li>
<li><a href="../467657/index.html">Inventario de la I a la Z. Contamos las licencias de software</a></li>
<li><a href="../467659/index.html">Acelere significativamente la ejecución de tareas con el ejemplo de configuración adicional de la memoria HyperX FURY DDR4 actualizada</a></li>
<li><a href="../467661/index.html">Dosímetro para Seryozha. Parte I. Polimaster - Nuclide Hunters</a></li>
<li><a href="../467663/index.html">Soporte para instrucciones específicas de hardware en .NET Core (ahora no solo SIMD)</a></li>
<li><a href="../467665/index.html">Carro para camiones ROS. Parte 5. Trabajando en rviz y gazebo: xacro, nuevos sensores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>