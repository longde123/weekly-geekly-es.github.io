<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游놏 游꺕 游놌游낗 C칩mo pas칠 el verano con C # 8 游 游꼾 游</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un lanzamiento reciente del podcast DotNet & More Blazor, NetCore 3.0 Preview, C # 8 y no solo mencionamos casualmente un tema tan candente como C ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C칩mo pas칠 el verano con C # 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467655/"><p>  En un lanzamiento reciente del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">podcast</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DotNet &amp; More</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blazor, NetCore 3.0 Preview, C # 8 y no solo</a> mencionamos casualmente un tema tan candente como C # 8.  La historia sobre la experiencia con C # 8 no fue lo suficientemente grande como para dedicarle un tema por separado, por lo que se decidi칩 compartir con ella los medios del g칠nero epistolar. </p><br><p>  En este art칤culo, me gustar칤a hablar sobre mi experiencia de usar C # 8 en producci칩n durante 4 meses.  A continuaci칩n puede encontrar respuestas a las siguientes preguntas: </p><br><ul><li>  C칩mo "deletrear" en el nuevo C # </li><li>  Qu칠 caracter칤sticas fueron realmente 칰tiles </li><li>  Que decepcionado </li></ul><a name="habracut"></a><br><p>  Puede encontrar una lista completa de las caracter칤sticas de C # 8 en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci칩n oficial de Microsoft</a> .  En este art칤culo, omitir칠 aquellas oportunidades que no podr칤a probar por una raz칩n u otra, a saber: </p><br><ul><li>  Miembros de solo lectura </li><li>  Miembros de interfaz predeterminados </li><li>  Estructuras de referencia desechables </li><li>  Flujos asincr칩nicos </li><li>  칈ndices y rangos </li></ul><br><p>  Propongo comenzar con una de las posibilidades m치s deliciosas, como me pareci칩 antes. </p><br><h3 id="switch-expressions">  Cambiar expresiones </h3><br><p> En nuestros sue침os, presentamos esta funci칩n muy optimista: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exec</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Operation operation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; operation <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Operation.Summ =&gt; x + y, Operation.Diff =&gt; x - y, Operation.Mult =&gt; x * y, Operation.Div =&gt; x / y, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException() };</code> </pre> <br><p>  Pero, desafortunadamente, la realidad hace sus propios ajustes. <br>  En primer lugar, no hay posibilidad de combinar las condiciones: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrafficLights</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Signal signal</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (signal) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Red: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Yellow: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"stop"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Green: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"go"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  En la pr치ctica, esto significa que en la mitad de los casos, la expresi칩n del interruptor tendr치 que convertirse en un interruptor regular para evitar copiar y pegar. </p><br><p>  En segundo lugar, la nueva sintaxis no admite declaraciones, es decir  c칩digo que no devuelve un valor.  Parecer칤a, bueno, y no es necesario, pero yo mismo me sorprend칤 cuando me di cuenta de la frecuencia con la que se usa el interruptor (junto con la coincidencia de patrones) para una afirmaci칩n en las pruebas. </p><br><p>  En tercer lugar, la expresi칩n switch, que se desprende del 칰ltimo p치rrafo, no admite manejadores de l칤neas m칰ltiples.  Qu칠 miedo entendemos al momento de agregar los registros: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecFull</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Operation operation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (operation) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Summ: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} + {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Diff: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} - {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Mult: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} * {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Div: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} / {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x / y; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  No quiero decir que el nuevo interruptor es malo.  No, 칠l es bueno, simplemente no lo suficientemente bueno. </p><br><h3 id="property--positional-patterns">  Propiedad y patrones posicionales </h3><br><p>  Hace un a침o, me parec칤an los principales candidatos para el t칤tulo de "oportunidad que cambi칩 el desarrollo".  Y, como se esperaba, para utilizar todo el poder de los patrones posicionales y de propiedad, debe cambiar su enfoque de desarrollo.  Es decir, es necesario imitar los tipos de datos algebraicos. <br>  Parece que cu치l es el problema: toma la interfaz del marcador y listo.  Desafortunadamente, este m칠todo tiene un serio inconveniente en un proyecto grande: nadie garantiza el seguimiento en tiempo de dise침o de la expansi칩n de sus tipos algebraicos.  Por lo tanto, es muy probable que con el tiempo, los cambios en el c칩digo conduzcan a muchos "fallos en el incumplimiento" en los lugares m치s inesperados. </p><br><h3 id="tuple-patterns">  Patrones de tuplas </h3><br><p>  Pero el "hermano menor" de las nuevas posibilidades de comparaci칩n con la muestra demostr칩 ser realmente bien hecho.  La cuesti칩n es que el patr칩n de tupla no requiere ning칰n cambio en la arquitectura familiar de nuestro c칩digo, simplemente simplifica algunos casos: </p><br><pre> <code class="cs hljs"> Player? Play(Gesture left, Gesture right) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (left, right) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Player.Left; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Player.Right; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  Pero la mejor parte es que esta caracter칤stica, que es bastante predecible, funciona muy bien con el m칠todo Deconstruct.  Simplemente pase una clase con Deconstruct implementado para cambiar y usar las capacidades del patr칩n de tupla. </p><br><h3 id="using-declarations">  Usando declaraciones </h3><br><p>  Parecer칤a una oportunidad menor, pero trae mucha alegr칤a.  En todas las promociones, Microsoft habla sobre un aspecto como reducir la anidaci칩n.  Pero seamos honestos, no tanto lo que importa.  Pero lo realmente serio son los efectos secundarios de excluir un bloque de c칩digo: </p><br><ul><li>  A menudo, al agregar el uso, tenemos que extraer el c칩digo "dentro" del bloque usando el m칠todo de copiar y pegar.  Ahora simplemente no lo pensamos </li><li>  Las variables declaradas dentro del uso y usadas despu칠s de Eliminar el objeto que usa son un verdadero dolor de cabeza.  Un problema menos </li><li>  En las clases que requieren llamadas frecuentes de Dispose, cada m칠todo ser칤a 2 l칤neas m치s largo.  Parecer칤a un poco, pero en la condici칩n de muchos m칠todos peque침os, este poco no permite mostrar una cantidad suficiente de estos m칠todos en una pantalla </li></ul><br><p>  Como resultado, algo tan simple como usar declaraciones cambia la sensaci칩n de codificaci칩n tanto que simplemente no desea volver a c # 7.3. </p><br><h3 id="static-local-functions">  Funciones locales est치ticas </h3><br><p>  Para ser honesto, si no fuera por la ayuda del an치lisis de c칩digo, ni siquiera notar칤a esta posibilidad.  Sin embargo, se estableci칩 firmemente en mi c칩digo: despu칠s de todo, las funciones locales est치ticas son perfectamente adecuadas para el papel de peque침as funciones puras, ya que no pueden soportar el cierre de las variables del m칠todo.  Como resultado, es m치s f치cil para el coraz칩n, porque comprende que hay un error potencial menos en su c칩digo. </p><br><h3 id="nullable-reference-types">  Tipos de referencia anulables </h3><br><p>  Y para el postre, me gustar칤a mencionar la caracter칤stica m치s importante de C # 8.  En verdad, el an치lisis de tipos de referencia anulables merece un art칤culo separado.  Solo quiero describir las sensaciones. </p><br><ul><li>  En primer lugar, es maravilloso.  Podr칤a haber descrito previamente mi intenci칩n expl칤cita de declarar un campo o propiedad anulable, pero ahora esta funci칩n est치 integrada en el lenguaje. </li><li>  En segundo lugar, no guarda nada de NullReferenceException.  Y no estoy hablando de la notoria "obstrucci칩n" en las advertencias.  Es solo que en tiempo de ejecuci칩n nadie genera ninguna comprobaci칩n de argumento nulo para usted, as칤 que no se apresure a lanzar c칩digo como lanzar nuevo ArgumentNullException () </li><li>  En tercer lugar, hay un problema grave con el DTO.  Por ejemplo, anota una propiedad con el atributo Requerido.  En consecuencia, un objeto con una propiedad 100% no nula entrar치 en su controlador WebAPI.  Sin embargo, no es posible asociar este atributo y todos los atributos similares con comprobaciones de tipos de referencia anulables.  El caso es que si declaras <em>MyProperty</em> est치ndar <em>{get;</em>  <em>set;} una</em> propiedad con un tipo NotNull, recibir치 una advertencia: <em>"[CS8618] La propiedad 'MyProperty' no anulable no est치 inicializada. Considere declarar la propiedad como anulable"</em> .  Lo cual es justo, ya que no puede garantizar una sem치ntica no nula durante el proceso de inicializaci칩n.  El 칰nico resultado de esta caracter칤stica es la incapacidad de usar propiedades no nulas en cualquier DTO.  Pero hay buenas noticias, hay una soluci칩n simple: simplemente inicialice su campo con el valor predeterminado: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MyProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> </li><li>  Cuarto, los atributos que manejan casos complejos, como TryGetValue, son bastante complejos.  Como resultado, es muy probable que los desarrolladores poco conscientes abusen de los operadores (!), Nivelando as칤 las capacidades de los tipos de referencia anulables.  Una esperanza para los analizadores. </li><li>  Quinto, y lo m치s importante, personalmente esta oportunidad ya me ha salvado muchas veces de los errores de NullReferenceException.  Resulta un ahorro de tiempo banal: se detectan muchos errores en la etapa de compilaci칩n, y no pruebas o depuraci칩n.  Esto es especialmente cierto no solo en el proceso de desarrollar una l칩gica empresarial compleja, sino tambi칠n en el caso de un trabajo trivial con bibliotecas externas, DTO y otras dependencias, que posiblemente contengan valores nulos. </li></ul><br><h2 id="rezyume">  Resumen </h2><br><p>  Por supuesto, las oportunidades presentadas no alcanzan una revoluci칩n completa, pero cada vez hay menos brecha entre C # y F # / Scala.  Ya sea bueno o malo, el tiempo lo dir치. </p><br><p>  En el momento del lanzamiento de este art칤culo, C # 8 puede que ya se haya asentado en su proyecto, por lo que me pregunto, 쯤u칠 siente sobre la nueva versi칩n de nuestro idioma favorito? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467655/">https://habr.com/ru/post/467655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467633/index.html">Petici칩n: Informe autom치tico y pago de impuestos sobre los ingresos de FLP (Ucrania)</a></li>
<li><a href="../467639/index.html">Semana de la seguridad 38: seguimiento de dispositivos m칩viles mediante tarjeta SIM</a></li>
<li><a href="../467645/index.html">Siguiendo a Angular Meetup # 15</a></li>
<li><a href="../467647/index.html">No cargue, no pruebe: c칩mo identificamos problemas con el sistema de gesti칩n de documentos VTB</a></li>
<li><a href="../467653/index.html">Habrastatistics: an치lisis de comentarios de los lectores</a></li>
<li><a href="../467657/index.html">Inventario de la I a la Z. Contamos las licencias de software</a></li>
<li><a href="../467659/index.html">Acelere significativamente la ejecuci칩n de tareas con el ejemplo de configuraci칩n adicional de la memoria HyperX FURY DDR4 actualizada</a></li>
<li><a href="../467661/index.html">Dos칤metro para Seryozha. Parte I. Polimaster - Nuclide Hunters</a></li>
<li><a href="../467663/index.html">Soporte para instrucciones espec칤ficas de hardware en .NET Core (ahora no solo SIMD)</a></li>
<li><a href="../467665/index.html">Carro para camiones ROS. Parte 5. Trabajando en rviz y gazebo: xacro, nuevos sensores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>