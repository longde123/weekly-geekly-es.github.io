<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍⚖️ 📴 🕑 Go mekanisme alokasi 👸🏼 👩🏿‍💻 🏜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika saya pertama kali mencoba memahami bagaimana alat alokasi memori di Go bekerja, apa yang ingin saya pahami tampak seperti kotak hitam yang mist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go mekanisme alokasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442648/">  Ketika saya pertama kali mencoba memahami bagaimana alat alokasi memori di Go bekerja, apa yang ingin saya pahami tampak seperti kotak hitam yang misterius.  Seperti halnya teknologi lainnya, hal terpenting di sini tersembunyi di balik banyak lapisan abstraksi, yang melaluinya Anda harus melewatinya untuk memahami sesuatu. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/tv/0k/gh/tv0kghio2zhsc-og7bjd-mtl41q.jpeg"></a> <br><br>  Penulis materi, terjemahan yang kami terbitkan, memutuskan untuk sampai ke bagian bawah alokasi memori di Go dan membicarakannya. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Memori fisik dan virtual</font> </h2><br>  Semua cara untuk mengalokasikan memori harus bekerja dengan ruang alamat memori virtual, yang dikendalikan oleh sistem operasi.  Mari kita lihat bagaimana memori bekerja, mulai dari level terendah - dengan sel-sel memori. <br>  Berikut ini cara membayangkan sel RAM. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e22/5e5/74c/e225e574c2649eb0bf9f5dd9cb1edadb.png"></div><br>  <i><font color="#999999">Tata letak sel memori</font></i> <br><br>  Jika, dengan cara yang sangat sederhana, bayangkan sel memori dan apa yang mengelilinginya, maka kita mendapatkan yang berikut: <br><br><ol><li>  Garis alamat (transistor bertindak sebagai saklar) adalah yang memberikan akses ke kapasitor (jalur data). </li><li>  Ketika sinyal muncul di garis alamat (garis merah), jalur data memungkinkan Anda untuk menulis data ke sel memori, yaitu, mengisi kapasitor, yang memungkinkan untuk menyimpan nilai logis yang sesuai dengan 1 di dalamnya. </li><li> Ketika tidak ada sinyal di garis alamat (jalur hijau), kapasitor terisolasi dan muatannya tidak berubah.  Untuk menulis ke sel 0, Anda harus memilih alamatnya dan mengirimkan 0 logis melalui jalur data, yaitu, menghubungkan jalur data dengan minus, sehingga pemakaian kapasitor. </li><li>  Ketika prosesor perlu membaca nilai dari memori, sinyal dikirim sepanjang garis alamat (sakelar ditutup).  Jika kapasitor diisi, sinyal melewati jalur data (1 dibaca), jika tidak, sinyal tidak melewati jalur data (0 dibaca). </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/33a/100/e8d33a100b5dbf94d34e794785670f24.png"></div><br>  <i><font color="#999999">Skema interaksi memori fisik dan prosesor</font></i> <br><br>  Bus data bertanggung jawab untuk mengangkut data antara prosesor dan memori fisik. <br><br>  Sekarang mari kita bicara tentang garis alamat dan byte yang bisa dialamatkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/e38/542/d24e38542de230b449750b26641f5e8c.png"></div><br>  <i><font color="#999999">Jalur alamat bus antara prosesor dan memori fisik</font></i> <br><br><ol><li>  Setiap byte dalam RAM diberikan pengenal numerik unik (alamat).  Perlu dicatat bahwa jumlah byte fisik yang ada dalam memori tidak sama dengan jumlah baris alamat. </li><li>  Setiap baris alamat dapat menentukan nilai 1-bit, jadi ini menunjukkan satu bit di alamat byte tertentu. </li><li>  Sirkuit kami memiliki 32 garis alamat.  Akibatnya, setiap byte yang dapat dialamatkan menggunakan nomor 32-bit sebagai alamatnya.  [00000000000000000000000000000000] - alamat memori terendah.  [1111111111111111111111111111111111] - alamat memori tertinggi. </li><li>  Karena setiap byte memiliki alamat 32-bit, ruang alamat kami terdiri dari 2 <sup>32</sup> byte yang dapat dialamatkan (4 GB). </li></ol><br>  Akibatnya, ternyata jumlah byte yang dapat dialamatkan bergantung pada jumlah total baris alamat.  Misalnya, jika ada 64 baris alamat (prosesor x86-64), Anda dapat mengatasi 2 <sup>64</sup> byte (16 exabytes) memori, tetapi sebagian besar arsitektur yang menggunakan pointer 64-bit sebenarnya menggunakan baris alamat 48-bit (AMD64) dan garis alamat 42-bit (Intel), yang, secara teoritis, memungkinkan komputer untuk dilengkapi dengan 256 terabyte memori fisik (Linux memungkinkan, pada arsitektur x86-64, ketika menggunakan halaman alamat level 4, untuk mengalokasikan hingga 128 TB ruang alamat ke proses, Windows memungkinkan Anda untuk mengalokasikan hingga 192 TB). <br>  Karena ukuran RAM fisik terbatas, setiap proses berjalan di "kotak pasir" sendiri - dalam apa yang disebut "ruang alamat virtual", yang disebut memori virtual. <br><br>  Alamat byte di ruang alamat virtual tidak cocok dengan alamat yang digunakan prosesor untuk mengakses memori fisik.  Akibatnya, kita membutuhkan sistem yang memungkinkan kita untuk mengubah alamat virtual ke alamat fisik.  Lihatlah seperti apa alamat memori virtual itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/09b/354/9d009b354ada519bf1280ea96e139e64.jpg"></div><br>  <i><font color="#999999">Representasi Ruang Alamat Virtual</font></i> <br><br>  Akibatnya, ketika prosesor menjalankan instruksi yang merujuk ke alamat memori, langkah pertama adalah menerjemahkan alamat logis ke alamat linier.  Konversi ini dilakukan oleh unit manajemen memori. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/330/ba9/56a330ba9d27daeb5737e013c0c15156.png"></div><br>  <i><font color="#999999">Representasi yang disederhanakan dari hubungan antara memori virtual dan fisik</font></i> <br><br>  Karena alamat logis terlalu besar untuk nyaman digunakan dengan mereka secara terpisah (ini tergantung pada berbagai faktor), memori diatur ke dalam struktur yang disebut halaman.  Dalam hal ini, ruang alamat virtual dibagi menjadi area kecil, halaman, yang dalam kebanyakan OS berukuran 4 KB, meskipun biasanya ukuran ini dapat diubah.  Ini adalah unit terkecil manajemen memori dalam memori virtual.  Memori virtual tidak menyimpan apa pun, ia hanya mengatur korespondensi antara ruang alamat program dan memori fisik. <br><br>  Proses hanya melihat alamat memori virtual.  Apa yang terjadi jika suatu program membutuhkan lebih banyak memori dinamis (juga disebut memori tumpukan, atau "tumpukan")?  Berikut adalah contoh kode assembler sederhana di mana tambahan memori yang dialokasikan secara dinamis diminta dari sistem: <br><br><pre><code class="plaintext hljs">_start:        mov $12, %rax #    brk        mov $0, %rdi # 0 -  ,            syscall b0:        mov %rax, %rsi #  rsi    ,           mov %rax, %rdi #     ...        add $4, %rdi # ..  4 ,           mov $12, %rax #    brk        syscall</code> </pre> <br>  Berikut ini cara merepresentasikannya dalam bentuk diagram. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c22/962/904/c229629041c7612e254d89d146fcc4ef.png"></div><br>  <i><font color="#999999">Tambah memori yang dialokasikan secara dinamis</font></i> <br><br>  Program meminta memori tambahan menggunakan panggilan sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">brk</a> (sbrk / mmap dan sebagainya).  Kernel memperbarui informasi tentang memori virtual, tetapi halaman baru belum disajikan dalam memori fisik, dan di sini ada perbedaan antara memori virtual dan fisik. <br><br><h2>  <font color="#3AC1EF">Pengalokasi memori</font> </h2><br>  Setelah kita, secara umum, membahas bekerja dengan ruang alamat virtual, berbicara tentang bagaimana cara meminta memori dinamis tambahan (memori pada heap), akan lebih mudah bagi kita untuk berbicara tentang cara mengalokasikan memori. <br><br>  Jika tumpukan memiliki cukup memori untuk memenuhi permintaan kode kami, maka pengalokasi memori dapat menjalankan permintaan ini tanpa mengakses kernel.  Kalau tidak, ia harus menambah ukuran tumpukan menggunakan panggilan sistem (menggunakan brk, misalnya), sambil meminta blok memori yang besar.  Dalam kasus malloc, "besar" berarti ukuran yang dijelaskan oleh parameter <code>MMAP_THRESHOLD</code> , yang, secara default, adalah 128 Kb. <br><br>  Namun, pengalokasi memori memiliki lebih banyak tanggung jawab daripada hanya mengalokasikan memori.  Salah satu tanggung jawabnya yang paling penting adalah untuk mengurangi fragmentasi memori internal dan eksternal, dan untuk mengalokasikan blok memori secepat mungkin.  Misalkan program kami secara berurutan mengeksekusi permintaan untuk mengalokasikan blok memori yang berkelanjutan menggunakan fungsi form <code>malloc(size)</code> , setelah itu memori ini dibebaskan menggunakan fungsi form <code>free(pointer)</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/8a0/779/9448a077982dfb81e4c982c1228cad15.png"></div><br>  <i><font color="#999999">Demonstrasi fragmentasi eksternal</font></i> <br><br>  Dalam diagram sebelumnya, pada langkah p4, kami tidak memiliki cukup blok memori yang ditempatkan secara berurutan untuk memenuhi permintaan alokasi enam blok seperti itu, walaupun jumlah total memori bebas memungkinkan ini.  Situasi ini menyebabkan fragmentasi memori. <br><br>  Bagaimana cara mengurangi fragmentasi memori?  Jawaban untuk pertanyaan ini tergantung pada algoritma alokasi memori tertentu, di mana pangkalan perpustakaan digunakan untuk bekerja dengan memori. <br><br>  Sekarang kita akan melihat alat alokasi memori TCMalloc, yang menjadi dasar mekanisme alokasi memori Go. <br><br><h2>  <font color="#3AC1EF">TCMalloc</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TCMalloc</a> didasarkan pada gagasan membagi memori menjadi beberapa tingkatan untuk mengurangi fragmentasi memori.  Di dalam TCMalloc, manajemen memori dibagi menjadi dua bagian: bekerja dengan memori utas dan bekerja dengan heap. <br><br><h3>  <font color="#3AC1EF">▍ Utas memori</font> </h3><br>  Setiap halaman memori dibagi menjadi urutan fragmen ukuran tertentu, dipilih sesuai dengan kelas ukuran.  Ini mengurangi fragmentasi.  Akibatnya, setiap utas memiliki cache untuk objek kecil, yang memungkinkan alokasi memori yang sangat efisien untuk objek yang lebih kecil dari atau sama dengan 32 KB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/331/901/7c8/3319017c8657e4b75a25003357d4b4f4.png"></div><br>  <i><font color="#999999">Tembolok cache</font></i> <br><br><h3>  <font color="#3AC1EF">▍Bunch</font> </h3><br>  Tumpukan terkelola TCMalloc adalah kumpulan halaman yang kumpulan halaman berurutannya dapat direpresentasikan sebagai rentang halaman (rentang).  Ketika Anda perlu mengalokasikan memori untuk objek yang lebih besar dari 32 KB, heap digunakan untuk mengalokasikan memori. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48c/f49/707/48cf497071e18b1539c18e6c2057e85d.png"></div><br>  <i><font color="#999999">Tumpukan dan bekerja dengan halaman</font></i> <br><br>  Ketika tidak ada cukup ruang untuk menempatkan benda-benda kecil dalam memori, mereka beralih ke tumpukan memori.  Jika tumpukan tidak memiliki cukup memori bebas, memori tambahan diminta dari sistem operasi. <br><br>  Hasilnya, model kerja dengan memori yang disajikan mendukung kumpulan memori ruang pengguna, penggunaannya secara signifikan meningkatkan efisiensi pengalokasian dan membebaskan memori. <br><br>  Perlu dicatat bahwa alat alokasi memori Go awalnya didasarkan pada TCMalloc, tetapi sedikit berbeda dari itu. <br><br><h2>  <font color="#3AC1EF">Buka pengalokasi memori</font> </h2><br>  Kita tahu bahwa Go runtime berencana untuk menjalankan goroutine pada prosesor logis.  Demikian pula, versi TCMalloc yang digunakan oleh Go membagi halaman memori menjadi blok-blok yang ukurannya sesuai dengan kelas ukuran tertentu yang ada. <br><br>  Jika Anda tidak terbiasa dengan penjadwal Go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> Anda dapat membacanya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/824/d5c/0df/824d5c0dfac562629662650924292583.png"></div><br>  <i><font color="#999999">Pergi kelas ukuran</font></i> <br><br>  Karena ukuran halaman minimum di Go adalah 8192 byte (8 Kb), jika halaman tersebut dibagi menjadi blok 1 KB, maka kita akan mendapatkan 8 blok seperti itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/150/865/6ba/1508656ba4a4c009624468a164d41e5b.png"></div><br>  <i><font color="#999999">Ukuran halaman 8 KB dibagi menjadi blok yang sesuai dengan ukuran kelas 1 KB</font></i> <br><br>  Urutan halaman serupa di Go dikendalikan menggunakan struktur yang disebut mspan. <br><br><h3>  <font color="#3AC1EF">Trtruktur mspan</font> </h3><br>  Struktur mspan adalah daftar tertaut ganda, objek yang berisi alamat awal halaman, informasi tentang ukuran halaman dan jumlah halaman yang termasuk di dalamnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbd/cae/fc0/dbdcaefc090a443369d33c2cde7e06ae.png"></div><br>  <i><font color="#999999">Struktur mspan</font></i> <br><br><h3>  <font color="#3AC1EF">▍ struktur mcache</font> </h3><br>  Seperti TCMalloc, Go memberikan setiap cache prosesor logis dengan thread lokal, yang dikenal sebagai mcache.  Akibatnya, jika goroutine membutuhkan memori, ia bisa mendapatkannya langsung dari mcache.  Untuk melakukan ini, Anda tidak perlu melakukan kunci, karena pada waktu tertentu hanya satu goroutin dijalankan pada satu prosesor logis. <br><br>  Struktur mcache berisi, dalam bentuk cache, struktur mspan dari berbagai kelas ukuran. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/7bb/459/4787bb4597d56f89b474189c5e86441b.png"></div><br>  <i><font color="#999999">Interaksi antara prosesor logis, mcache dan mspan di Go</font></i> <br><br>  Karena setiap prosesor logis memiliki mcache sendiri, tidak perlu kunci ketika mengalokasikan memori dari mcache. <br><br>  Setiap kelas ukuran dapat diwakili oleh salah satu objek berikut: <br><br><ul><li>  Objek pindai adalah objek yang berisi pointer. </li><li>  Objek noscan adalah objek di mana tidak ada pointer. </li></ul><br>  Salah satu kekuatan dari pendekatan ini adalah ketika pengumpulan sampah dilakukan, objek noscan tidak perlu dielakkan, karena mereka tidak mengandung objek yang dialokasikan memori. <br><br>  Apa yang masuk ke mcache?  Objek yang ukurannya tidak melebihi 32 KB langsung ke mcache menggunakan mspan dari kelas ukuran yang sesuai. <br><br>  Apa yang terjadi jika mcache tidak memiliki sel bebas?  Kemudian mereka mendapatkan mspan baru dari kelas ukuran yang diinginkan dari daftar objek mspan yang disebut mcentral. <br><br><h3>  <font color="#3AC1EF">Structure Struktur pusat</font> </h3><br>  Struktur mcentral mengumpulkan semua rentang halaman dari kelas ukuran tertentu.  Setiap objek mcentral berisi dua daftar objek mspan. <br><br><ol><li>  Daftar objek mspan di mana tidak ada objek gratis, atau orang-orang mspan yang ada di mcache. </li><li>  Daftar objek mspan yang memiliki objek gratis. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/b88/7f9/6dcb887f9c717bb1f24735daa4b50aa7.png"></div><br>  <i><font color="#999999">Struktur Mcentral</font></i> <br><br>  Setiap struktur mcentral ada di dalam struktur mheap. <br><br><h3>  <font color="#3AC1EF">He Struktur tumpukan</font> </h3><br>  Struktur mheap diwakili oleh objek yang menangani manajemen heap di Go.  Hanya ada satu objek global yang memiliki ruang alamat virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8e/b07/01b/c8eb0701bbe46523e2735e695db97115.png"></div><br>  <i><font color="#999999">Struktur tumpukan</font></i> <br><br>  Seperti yang dapat Anda lihat dari diagram di atas, struktur mheap berisi larik struktur mcentral.  Array ini mengandung struktur mcentral untuk semua kelas ukuran. <br><br><pre> <code class="plaintext hljs">central [numSpanClasses]struct { mcentral mcentral   pad     [sys.CacheLineSize unsafe.Sizeof(mcentral{})%sys.CacheLineSize]byte }</code> </pre> <br>  Karena kami memiliki struktur mcentral untuk setiap kelas ukuran, ketika mcache meminta struktur mspan dari mcentral, sebuah kunci diterapkan pada tingkat mcentral individu, sebagai akibatnya, permintaan dari mcache lain yang meminta struktur mspan dari ukuran lain dapat dilayani pada waktu yang bersamaan. <br><br>  Alignment (pad) memastikan bahwa struktur mcentral dipisahkan satu sama lain dengan jumlah byte yang sesuai dengan nilai <code>CacheLineSize</code> .  Akibatnya, setiap <code>mcentral.lock</code> memiliki garis cache sendiri, yang menghindari masalah yang terkait dengan berbagi memori palsu. <br><br>  Apa yang terjadi jika daftar mcentral kosong?  Kemudian mcentral menerima urutan halaman dari mheap untuk mengalokasikan fragmen memori dari kelas ukuran yang diperlukan. <br><br><ul><li>  <code>free[_MaxMHeapList]mSpanList</code> adalah array spanList.  Struktur mspan di setiap spanList terdiri dari 1 ~ 127 (_MaxMHeapList - 1) halaman.  Misalnya, gratis [3] adalah daftar tertaut dari struktur mspan yang berisi 3 halaman.  Kata "bebas" dalam hal ini menunjukkan bahwa kita berbicara tentang daftar kosong di mana memori tidak dialokasikan.  Daftar dapat, sebagai lawan kosong, daftar di mana memori dialokasikan (sibuk). </li><li>  <code>freelarge mSpanList</code> adalah daftar struktur mspan gratis.  Jumlah halaman per elemen (yaitu, mspan) lebih dari 127. Untuk mendukung daftar ini, struktur data mtreap digunakan.  Daftar struktur mspan yang sibuk disebut busylarge. </li></ul><br>  Objek yang lebih besar dari 32 Kb dianggap objek besar, memori untuk mereka dialokasikan langsung dari mheap.  Permintaan untuk mengalokasikan memori untuk objek tersebut dilakukan menggunakan kunci, sebagai akibatnya, pada titik waktu tertentu, permintaan serupa dapat diproses dari hanya satu prosesor logis. <br><br><h2>  <font color="#3AC1EF">Proses mengalokasikan memori untuk objek</font> </h2><br><ul><li>  Jika ukuran objek melebihi 32 Kb, itu dianggap besar, memori untuk itu dialokasikan langsung dari mheap. </li><li>  Jika ukuran objek kurang dari 16 Kb, mekanisme mcache yang disebut pengalokasi kecil digunakan. </li><li>  Jika ukuran objek berada dalam kisaran 16-32 Kb, ternyata kelas ukuran mana (sizeClass) yang akan digunakan, maka blok yang sesuai dialokasikan di mcache. </li><li>  Jika tidak ada blok yang tersedia di sizeClass yang sesuai dengan mcache, mcentral dipanggil. </li><li>  Jika mcentral tidak memiliki blok gratis, maka mereka memanggil mheap dan mencari mspan yang paling cocok.  Jika ukuran memori yang dibutuhkan oleh aplikasi ternyata lebih besar daripada yang mungkin untuk dialokasikan, ukuran memori yang diminta akan diproses sehingga akan mungkin untuk mengembalikan halaman sebanyak yang dibutuhkan oleh program, setelah membentuk struktur mspan baru. </li><li>  Jika memori virtual aplikasi masih tidak cukup, sistem operasi diakses untuk set halaman baru (minimal 1 MB memori diminta). </li></ul><br>  Bahkan, pada level sistem operasi, Go meminta alokasi memori yang lebih besar yang disebut arena.  Alokasi serentak fragmen memori yang besar memungkinkan Anda menemukan kompromi antara jumlah memori yang dialokasikan untuk aplikasi dan akses yang mahal ke sistem operasi dalam hal kinerja. <br><br>  Memori yang diminta pada heap dialokasikan dari arena.  Pertimbangkan mekanisme ini. <br><br><h2>  <font color="#3AC1EF">Memori virtual pergi</font> </h2><br>  Lihatlah penggunaan memori dengan program sederhana yang ditulis dalam Go: <br><br><pre> <code class="plaintext hljs">func main() {   for {} }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/4cd/dee/c334cddee46f32a66d3528b08deda48e.png"></div><br>  <i><font color="#999999">Informasi Proses Program</font></i> <br><br>  Ruang alamat virtual bahkan dari program yang sederhana ini adalah sekitar 100 MB, sedangkan indeks RSS hanya 696 Kb.  Pertama, mari kita cari tahu alasan perbedaan ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/2a7/f41/f342a7f41d8ff7fbf3b5f081415c5ab4.png"></div><br>  <i><font color="#999999">Memetakan dan menampar informasi</font></i> <br><br>  Di sini Anda dapat melihat area memori, yang ukurannya kira-kira sama dengan 2 MB, 64 MB, 32 MB.  Memori seperti apa ini? <br><br><h3>  <font color="#3AC1EF">RArena</font> </h3><br>  Ternyata memori virtual di Go terdiri dari seperangkat arena.  Ukuran memori awal yang dimaksudkan untuk tumpukan sesuai dengan satu arena, yaitu - 64 MB (ini relevan untuk Go 1.11.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dd/17e/ba9/9dd17eba9a4c5acf9371052d62d902d9.png"></div><br>  <i><font color="#999999">Ukuran arena saat ini dalam berbagai sistem</font></i> <br><br>  Akibatnya, memori yang dibutuhkan untuk kebutuhan program saat ini dialokasikan dalam porsi kecil.  Proses ini dimulai dengan satu arena 64 MB. <br><br>  Indikator numerik yang kita bicarakan di sini tidak boleh diambil untuk beberapa nilai absolut dan tidak berubah.  Mereka bisa berubah.  Sebelumnya, misalnya, Go mencadangkan ruang virtual terus-menerus di muka, pada sistem 64-bit ukuran arena adalah 512 GB (Sangat menarik untuk memikirkan apa yang terjadi jika permintaan memori aktual begitu besar sehingga permintaan yang sesuai akan ditolak oleh mmap?). <br><br>  Faktanya, kami menyebut banyak arena sebagai satu kesatuan.  Di Go, arena dianggap sebagai fragmen memori, dibagi menjadi blok berukuran 8192 byte (8 Kb). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/927/7e0/55b9277e0c55876b1bbf11bb1b869c9e.png"></div><br>  <i><font color="#999999">Satu arena 64 MB</font></i> <br><br>  Go memiliki beberapa rasa blok - span dan bitmap.  Memori untuk mereka dialokasikan di luar heap, mereka menyimpan arena metadata.  Mereka terutama digunakan dalam pengumpulan sampah. <br>  Berikut adalah garis besar umum tentang bagaimana mekanisme alokasi memori bekerja di Go. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/61f/13f/b0161f13f6bc905731f0bfb339fd3a10.png"></div><br>  <i><font color="#999999">Garis besar umum mekanisme alokasi memori di Go</font></i> <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Secara umum, dapat dicatat bahwa dalam materi ini kami menggambarkan subsistem untuk bekerja dengan memori Go dalam istilah yang sangat umum.  Ide utama subsistem memori di Go adalah mengalokasikan memori menggunakan berbagai struktur dan cache dari berbagai tingkatan.  Ini memperhitungkan ukuran objek yang dialokasikan memori. <br><br>  Representasi satu blok alamat memori kontinu yang diterima dari sistem operasi dalam bentuk struktur multi-level meningkatkan efisiensi mekanisme alokasi memori karena fakta bahwa pendekatan ini menghindari pemblokiran.  Alokasi sumber daya, dengan mempertimbangkan ukuran objek yang perlu disimpan dalam memori, mengurangi fragmentasi, dan, setelah membebaskan memori, memungkinkan Anda untuk mempercepat pengumpulan sampah. <br><br>  <b>Pembaca yang budiman!</b>  Pernahkah Anda mengalami masalah yang disebabkan oleh tidak berfungsinya memori dalam program yang ditulis dalam Go? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442648/">https://habr.com/ru/post/id442648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442638/index.html">Penskalaan aplikasi Kubernetes berdasarkan metrik dari Prometheus</a></li>
<li><a href="../id442640/index.html">Perfect Bug: Menggunakan Type Confusion di Flash. Bagian 1</a></li>
<li><a href="../id442642/index.html">Apa yang harus dibaca di bulan Maret: 22 buku baru untuk pemasar, manajer, pengembang, dan desainer</a></li>
<li><a href="../id442644/index.html">Sebagian besar keterampilan non-pemrograman meningkatkan nilai pengembang</a></li>
<li><a href="../id442646/index.html">Kubernetes Networks: Ingress</a></li>
<li><a href="../id442650/index.html">Analisis dan optimalisasi aplikasi Bereaksi</a></li>
<li><a href="../id442652/index.html">Menggunakan Fastify dan Preact ke Prototipe Aplikasi Web dengan Cepat</a></li>
<li><a href="../id442654/index.html">Beralih ke Next.js dan mempercepat pemuatan beranda manifold.co 7,5 kali</a></li>
<li><a href="../id442658/index.html">8 trik untuk bekerja dengan CSS: paralaks, sticky footer dan lainnya</a></li>
<li><a href="../id442660/index.html">Matematika Merekonsiliasi Newton dengan Dunia Kuantum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>