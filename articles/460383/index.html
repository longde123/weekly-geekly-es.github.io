<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçâ üëµüèæ üåØ Las transiciones de pantalla en Legend of Zelda usan las funciones no documentadas de NES üë®‚Äçüë©‚Äçüë¶ üóìÔ∏è ü§öüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para el efecto de desplazamiento vertical en la primera parte de "The Legend of Zelda", se utilizan manipulaciones gr√°ficas de "hardware" de NES, muy ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Las transiciones de pantalla en Legend of Zelda usan las funciones no documentadas de NES</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460383/">  Para el efecto de desplazamiento vertical en la primera parte de "The Legend of Zelda", se utilizan manipulaciones gr√°ficas de "hardware" de NES, muy probablemente no proporcionadas por los desarrolladores de la consola. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/466/3d0/6314663d04d4e3ed0d86c7e6d9b8611a.png" width="512"></div><br>  No tengo acceso a la documentaci√≥n oficial de la Unidad de procesamiento de im√°genes (PPU - chip gr√°fico) de la consola NES, por lo que mis declaraciones sobre "comportamiento indefinido" tienen m√°s probabilidades de ser suposiciones.  Tom√© la especificaci√≥n del hardware de gr√°ficos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NesDev Wiki</a> .  PPU se controla escribiendo en registros con mapeo de memoria.  Si usa estos registros de la forma en que fue (parece) concebida por los dise√±adores, entonces ser√≠a imposible lograr este efecto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/b0e/51c/8a5b0e51c195fb1e9ba9ca282f54e61a.gif" width="512"></div><br>  Al desplazar la pantalla verticalmente, toda la pantalla debe desplazarse a la vez.  El GIF anterior muestra un ejemplo de desplazamiento vertical parcial.  Parte de la pantalla permanece estacionaria (elementos de interfaz), y la otra parte (√°rea de juego) se desplaza verticalmente.  El desplazamiento vertical parcial es imposible de implementar con el trabajo "est√°ndar" con PPU. <br><br>  Por el contrario, el desplazamiento <em>horizontal</em> parcial est√° completamente definido y es posible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae7/c29/539/ae7c295393f6706e17e788e0a1cc39e7.gif" width="512"></div><br>  Escribir en un registro PPU separado en el momento en que se dibuja el marco puede conducir a artefactos gr√°ficos.  The Legend of Zelda intencionalmente causa un artefacto que se manifiesta como desplazamiento vertical parcial.  En esta publicaci√≥n, hablar√© un poco sobre el hardware de gr√°ficos NES y explicar√© c√≥mo funciona el truco de desplazamiento vertical. <br><a name="habracut"></a><br><h2>  Tipos de graficos </h2><br>  La consola NES tiene dos tipos de gr√°ficos: <br><br><ul><li>  Los sprites son mosaicos que se pueden colocar en lugares arbitrarios en la pantalla y mover independientemente uno del otro. </li><li>  Fondo: una cuadr√≠cula de mosaicos que se puede desplazar suavemente como una sola imagen. </li></ul><br>  Para demostrar la diferencia entre los dos, mostrar√© una escena compuesta de sprites y fondo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/f9b/138/f75f9b138db2e818cbdb9b2fb1e7b27b.gif" width="512"></div><br>  Y aqu√≠ est√° la misma escena en la que solo los sprites son visibles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/26d/817/5e826d817b637fc450046aee1473abaf.gif" width="512"></div><br>  Y aqu√≠ hay una escena en la que solo se ve el fondo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/b9c/bd7/d81b9cbd7bb5101f663d4decc5ebaef7.gif" width="512"></div><br><h2>  Desplazamiento </h2><br>  El procesador de im√°genes (NES Picture Processor) admite el desplazamiento de im√°genes de fondo.  En la memoria de gr√°ficos, el gr√°fico de fondo se almacena como una cuadr√≠cula bidimensional de mosaicos que cubren un √°rea dos veces el ancho y alto de la pantalla. <br><br>  Se muestra una "ventana" en la pantalla en esta cuadr√≠cula del tama√±o de una pantalla, y la posici√≥n de esta ventana se puede controlar con precisi√≥n.  Al mover gradualmente la ventana visible a lo largo de la cuadr√≠cula, se crea un efecto de desplazamiento suave. <br><br>  La se√±al de salida de video NES tiene un tama√±o de 256x240 p√≠xeles.  La cuadr√≠cula de mosaicos dentro de la memoria se representa como un √°rea de 512x480 p√≠xeles y se divide en cuatro rect√°ngulos del tama√±o de una pantalla llamados "tablas de nombres".  Los juegos pueden configurar la Unidad de procesamiento de im√°genes (PPU) indicando la posici√≥n de la ventana visible seleccionando la coordenada de p√≠xeles en la cuadr√≠cula de las tablas de nombres. <br><br>  Cuando selecciona la coordenada (0, 0), se mostrar√° en la pantalla toda la tabla de nombres superior izquierda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/b5d/47f/5d3b5d47f8efdfcac271a2a7e0222e57.png"></div><br>  Pasando a (125, 181), veremos un poco de cada tabla de nombres: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/78f/189/91278f1891416d9f15a69238e64d1422.png"></div><br>  La ventana visible se minimiza en la parte posterior de la cuadr√≠cula de mosaico en la memoria.  Pasando a (342, 290), colocamos la esquina superior izquierda de la pantalla visible dentro de la tabla de nombres inferior derecha, y gracias al plegado, se ver√°n partes de cada una de las tablas de nombres: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/394/c93/6e6394c9325985807a97765ebe015bcf.png"></div><br><h3>  ¬°No hay suficiente memoria! </h3><br>  Cada tabla de nombres tiene un tama√±o de 1 KB, pero NES asigna solo 2 KB de su memoria de video a estas tablas, por lo que solo dos tablas de nombres pueden caber en la memoria a la vez. <br><br>  ¬øC√≥mo puede tener cuatro tablas de nombres? <br><br><h4>  Duplicar tablas de nombres </h4><br>  La memoria de video est√° conectada a la PPU de tal manera que cuando la PPU representa un mosaico de una de las cuatro tablas de nombres aparentes, de hecho, se selecciona una de las dos tablas reales, y la lectura proviene de all√≠.  En esencia, esto significa que las cuatro tablas de nombres visibles en realidad est√°n formadas por dos pares de tablas id√©nticas. <br><br>  Esta imagen muestra una instant√°nea del contenido de las cuatro tablas.  La parte superior izquierda y la superior derecha son las mismas que las dos inferiores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/5b8/9b2/0515b89b2afcf122ce8df6e97e97a0a8.png" width="1024"></div><br>  ¬øPor qu√© entonces simplemente no mantener dos tablas de nombres? <br><br>  Afortunadamente, el enlace exacto entre las tablas aparente y real se puede configurar en tiempo de ejecuci√≥n.  Si el juego quiere realizar un desplazamiento horizontal, entonces ajusta el equipo gr√°fico para que las tablas superior izquierda y superior derecha sean diferentes, y puedan desplazarse sin duplicaci√≥n notable.  En esta configuraci√≥n, las tablas superior izquierda e inferior izquierda se referir√°n a la misma tabla de nombre real;  de manera similar para las dos tablas correctas.  Esta configuraci√≥n se llama Vertical Mirroring. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/d85/49d/1e3d8549d5427f7f7271595dc5c6f49b.png"></div><br>  Tambi√©n hay otra configuraci√≥n posible: "Espejo horizontal", que los juegos usan para el desplazamiento vertical. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/6a2/528/6506a2528cba5d758301f72c80f48e8b.png"></div><br>  Por lo general, los juegos no se desplazan en diagonal, ya que crea artefactos alrededor de los bordes de la pantalla debido a la duplicaci√≥n de las tablas de nombres. <br><br><h3>  Cartuchos </h3><br>  El cartucho de cada juego tiene hardware que te permite configurar la duplicaci√≥n de la mesa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/8ed/3dc/a448ed3dc3849ac558d39ba0bfc5309d.jpg" width="50%"></div><br>  Algunos juegos no necesitan cambiar la duplicaci√≥n, por lo que la duplicaci√≥n horizontal o vertical est√° codificada en sus cartuchos.  Otros juegos cambian din√°micamente entre estos dos modos, por lo que la duplicaci√≥n en sus cartuchos se configura mediante programaci√≥n.  The Legend of Zelda pertenece a la segunda categor√≠a.  Finalmente, los cartuchos de algunos juegos verdaderamente complejos tienen memoria de video adicional, es decir, no necesitan reflejo en absoluto: pueden desplazarse simult√°neamente vertical y horizontalmente sin artefactos de duplicaci√≥n visibles. <br><br><h3>  Ejemplo real </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/d58/80e/d0ad5880e16ce58d53ee2eb922c4da04.gif" width="512"></div><br>  <i>Un ejemplo de desplazamiento vertical que se muestra en la pantalla.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/ff0/b01/7bbff0b019dadb96e423ebc744aeb12c.gif" width="1024"></div><br>  <i>Esto muestra un registro de tablas de nombres con reflejo horizontal.</i>  <i>La ventana actualmente visible est√° resaltada.</i> <br><br>  Recuerde que el desplazamiento m√°s vertical no es inusual; lo inusual es el desplazamiento vertical con <em>pantalla dividida</em> . <br><br><h2>  Pantalla dividida </h2><br>  Cada cuadro de la se√±al de video generada por NES se representa de arriba a abajo, una fila de p√≠xeles a la vez.  En cada fila, los p√≠xeles se dibujan uno a la vez, de izquierda a derecha.  A mitad de camino al renderizar el marco, el juego puede reconfigurar el PPU, lo que afecta la visualizaci√≥n de p√≠xeles que a√∫n no se han renderizado.  Uno de los cambios m√°s comunes en el medio del marco es actualizar la posici√≥n de desplazamiento horizontal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/536/98f/87353698fa1a10a55f37d5f56ebfaefd.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/502/8e9/c645028e950b7e202815d7c4ad560fac.gif" width="1024"></div><br>  Al desplazarse horizontalmente entre habitaciones, The Legend of Zelda siempre comienza desde la posici√≥n de desplazamiento (0, 0) y muestra los elementos de la interfaz en la parte superior de la pantalla.  Despu√©s de dibujar la √∫ltima l√≠nea de p√≠xeles de la interfaz en la pantalla, el desplazamiento horizontal cambia en un valor que aumenta con cada cuadro, por lo que la c√°mara se mueve suavemente. <br><br>  La animaci√≥n de la visualizaci√≥n de las tablas de nombres muestra c√≥mo el juego cambia de la duplicaci√≥n horizontal a la vertical antes de desplazarse, y luego nuevamente a la horizontal despu√©s de que se completa la transici√≥n.  Adem√°s, mientras contin√∫a el desplazamiento, las tablas de nombres superior izquierda (e inferior izquierda) se actualizan, y se graba en ellas una copia de la sala en la que ingresa el jugador.  Una vez que se completa el desplazamiento, el juego deja de dividir la pantalla y nuevamente se representa por completo desde la tabla superior izquierda. <br><br><h3>  Medici√≥n de renderizado </h3><br>  Para dividir la pantalla en la posici√≥n deseada, el juego necesita descubrir de alguna manera qu√© parte del cuadro actual se dibuj√≥.  Las cadenas de p√≠xeles se procesan a una frecuencia conocida, por lo que el n√∫mero de cadenas de p√≠xeles procesadas se puede determinar contando el n√∫mero de ciclos de procesador que han pasado desde el comienzo del marco. <br><br>  Hay otra t√©cnica m√°s precisa llamada Sprite Zero Hit. <br><br>  NES puede renderizar hasta 64 sprites a la vez.  El primer sprite en la memoria de video se llama Sprite Zero (cero sprite).  En cada cuadro, tan pronto como un p√≠xel opaco de un sprite cero se superpone a un p√≠xel de fondo opaco, ocurre el evento Sprite Zero Hit.  Establece un bit en uno de los registros PPU con mapeo de memoria, que puede ser verificado por el procesador. <br><br>  Para usar Sprite Zero Hit para dividir la pantalla, los juegos colocan el sprite cero en una posici√≥n vertical cerca del borde dividido, y durante el renderizado comprueban constantemente para ver si ha ocurrido el evento Sprite Zero Hit.  Si es as√≠, el juego cambia del desplazamiento horizontal para implementar la separaci√≥n. <br><br>  La transici√≥n horizontal entre habitaciones con y sin fondo se muestra a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/27a/076/71b27a0768844603020981c26b3f5124.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/4c1/95d/2c44c195dfac0b6c2d6b10aaf11674aa.gif" width="512"></div><br><br>  El c√≠rculo marr√≥n que aparece al comienzo de la transici√≥n y desaparece al final es un sprite cero.  Echaremos un vistazo m√°s de cerca a la interfaz con y sin antecedentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/373/83d/39b37383d425937e8e5cdb598656bac5.png" width="322"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/6f9/ebe/c7d6f9ebeb7c7e066e6d349eb8c57914.png" width="322"></div><br>  Un sprite cero es un sprite de bomba blanqueado que combina perfectamente con el sprite de bomba normal de la interfaz del juego.  El sprite cero est√° configurado para aparecer debajo del fondo, pero dado que los p√≠xeles negros de la interfaz se consideran transparentes, la bomba de sprite cero ser√≠a visible si no se hubiera ocultado estrat√©gicamente detr√°s de la bomba desde la interfaz. <br><br>  Tenga en cuenta que Sprite Zero Hit se produce unas pocas l√≠neas de p√≠xeles antes de la l√≠nea inferior de la interfaz.  Se produce en el p√≠xel superior del fusible de la bomba, que est√° a 16 p√≠xeles desde la parte inferior de la interfaz.  Cuando ocurre Sprite Zero Hit, el juego comienza a contar los ciclos del procesador, y despu√©s de completar el n√∫mero requerido de ciclos establece el desplazamiento horizontal. <br><br><h2>  Haz en blanco </h2><br>  La mayor√≠a de las veces, la consola PPU dibuja p√≠xeles en la pantalla.  Hay un breve tiempo de inactividad entre fotogramas durante el cual no se realiza el renderizado.  Este fen√≥meno se llama supresi√≥n (vertical en blanco, o vblank).  Algunos tipos de cambios de configuraci√≥n de PPU solo se pueden realizar durante vblank. <br><br><h2>  Registro de desplazamiento </h2><br>  Los juegos cambian la posici√≥n de desplazamiento escribiendo en el registro PPU llamado <code>PPUSCROLL</code> , que se asigna a la direcci√≥n de memoria <code>0x2005</code> .  La primera operaci√≥n de escritura en <code>PPUSCROLL</code> define el componente X de la posici√≥n de desplazamiento, y la segunda operaci√≥n establece el componente Y. Del mismo modo, la grabaci√≥n alternativa se realiza m√°s. <br><br>  A continuaci√≥n se muestran todas las operaciones de escritura distintas de cero en <code>PPUSCROLL</code> durante esta reproducci√≥n (en c√°mara lenta) 16 cuadros de la pantalla con la trama del juego.  El componente de posici√≥n de desplazamiento Y se incrementa cada dos cuadros.  Todas las operaciones de escritura en <code>PPUSCROLL</code> en este ejemplo se realizan durante vblank, lo que hace que todo el fondo se desplace junto con √©l. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/0d1/003/cad0d1003d55488a17d988e6607739f2.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bc/ffb/c09/1bcffbc09db9bfe792ba85981acbe4b3.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/rz/fi/kgrzfigaydwrvo3qqth5bcmkecq.png"></div><br><h3>  Desplazamiento de pantalla dividida </h3><br>  Las operaciones de escritura en <code>PPUSCROLL</code> durante vblank surten efecto al comienzo del marco dibujado inmediatamente despu√©s de vblank.  Si la posici√≥n de desplazamiento cambia durante la representaci√≥n del marco (es decir, no durante vblank), este cambio surte efecto cuando el dibujo alcanza la siguiente fila de p√≠xeles.  El desplazamiento horizontal parcial se implementa escribiendo en <code>PPUSCROLL</code> mientras el PPU dibuja la √∫ltima fila de p√≠xeles antes del desplazamiento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/e12/b49/ddfe12b49ce180cb921243f32e77351a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/38c/0bb/4be38c0bb335a414ce99a2c8d2145009.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/uu/1t/cuuu1twsw4wbeynzisaewszsqo8.png"></div><br>  Al actualizar la posici√≥n de desplazamiento en el medio del cuadro, solo se aplica la posici√≥n X de la posici√≥n de desplazamiento.  Es decir, el componente de posici√≥n de desplazamiento Y se descarta.  Por lo tanto, si el juego quiere dividir la pantalla y cambia la posici√≥n de desplazamiento de parte del cuadro, solo puede desplazarse horizontalmente. <br><br>  Y sin embargo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br>  Lo creas o no, el valor del registro <code>PPUSCROLL</code> no <code>PPUSCROLL</code> cambiado durante esta transici√≥n. <br><br>  Puede ver un artefacto gr√°fico de un p√≠xel de altura debajo de la interfaz.  Este es un error de mi emulador causado por la falta de sincronizaci√≥n de los ciclos de reloj del procesador con la representaci√≥n p√≠xel por p√≠xel. <br><br><h3>  Intervenci√≥n en otros registros. </h3><br>  El segundo registro, llamado <code>PPUADDR</code> , asignado a la direcci√≥n de memoria <code>0x2006</code> , se usa para configurar la direcci√≥n de memoria de video actual.  Cuando un juego, por ejemplo, quiere cambiar uno de los mosaicos en la tabla de nombres, primero escribe la direcci√≥n de memoria de video del <code>PPUADDR</code> en <code>PPUADDR</code> , y luego escribe el nuevo valor del <code>PPUDATA</code> en <code>PPUDATA</code> : este es el tercer registro asignado a la direcci√≥n <code>0x2007</code> . <br><br>  Escribir en <code>PPUADDR</code> no durante vblank (es decir, cuando se procesa un marco) puede causar artefactos gr√°ficos.  Esto se debe a que la cadena PPU, que se ve afectada por la escritura en <code>PPUADDR</code> , tambi√©n est√° directamente controlada por el dispositivo PPU en el proceso de obtenci√≥n de mosaicos de la memoria de video para dibujarlos.  Dado que el proceso de renderizado en la pantalla se realiza de arriba a abajo y de izquierda a derecha dentro de la l√≠nea, el PPU esencialmente asigna a <code>PPUADDR</code> valor de la direcci√≥n del <code>PPUADDR</code> actual que se <code>PPUADDR</code> dibujando.  Cuando el renderizado se mueve de un mosaico a otro, <code>PPUADDR</code> se incrementa en el valor actual. <br><br>  Por lo tanto, escribir en <code>PPUADDR</code> en el medio del marco puede cambiar los mosaicos recibidos por el PPU de la memoria durante la duraci√≥n del marco actual. <br><br>  Llevemos <code>PPUADDR</code> operaciones de escritura a <code>PPUADDR</code> durante el salto vertical.  Dado que la tabla de nombres tambi√©n se actualiza durante la transici√≥n, el resultado de <em>todas las</em> operaciones de escritura en <code>PPUADDR</code> ser√° demasiado extenso.  Con una transici√≥n horizontal, el desplazamiento se establece durante el procesamiento de una fila de p√≠xeles 63, por lo tanto, consideraremos escribir operaciones en <code>PPUADDR</code> solo durante esta fila. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3b/w0/iw/3bw0iwoau9zl8frbuh-mgh78-ia.png"></div><br>  El patr√≥n es claramente visible.  Cada dos cuadros, la direcci√≥n registrada en la l√≠nea de p√≠xeles 63 se reduce en 32 (0x20).  Pero, ¬øc√≥mo conduce esto a una actualizaci√≥n en la posici√≥n de desplazamiento real? <br><br><h3>  Registro de desplazamiento <i>real</i> </h3><br>  Dentro de la PPU hay un registro de 15 bits no asignado a la CPU.  Se utiliza tanto como la direcci√≥n actual para acceder a la memoria de video como como una configuraci√≥n de desplazamiento en segundo plano. <br><br>  Cuando se trabaja con este valor como una direcci√≥n, el bit 14 se ignora y los bits 0-13 se tratan como una direcci√≥n en la memoria de video. <br><br>  Cuando se trabaja con este valor como una configuraci√≥n de desplazamiento, sus diferentes partes tienen diferentes significados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/ot/-q/raot-qzjvlglrxraw3kyrpskouk.png"></div><br>  <strong>La selecci√≥n de una tabla de nombres</strong> es un valor de 0 a 3 que determina la tabla de nombres actual a partir de la cual se realiza el dibujo. <br><br>  <strong>El desplazamiento grueso en X</strong> y el <strong>desplazamiento grueso en Y</strong> determinan la coordenada del mosaico dentro de la tabla de nombres seleccionada.  Este es el mosaico actual para dibujar. <br><br>  <strong>El desplazamiento exacto a lo largo de Y</strong> contiene un valor de 0 a 7, que determina el desplazamiento vertical actual de la l√≠nea de p√≠xeles dentro del mosaico actual.  Los mosaicos son cuadrados con un lado de 8 p√≠xeles. <br><br>  <strong>El desplazamiento exacto en X</strong> est√° ausente en este registro.  Hay un registro separado que contiene solo el desplazamiento horizontal del p√≠xel actual, pero no es importante para explicar c√≥mo se realiza el desplazamiento vertical en The Legend of Zelda. <br><br>  ¬øQu√© le sucede a este registro cuando un juego escribe en <code>PPUADDR</code> ?  Aqu√≠ est√°n las tres primeras operaciones de escritura de la demostraci√≥n que se muestra arriba. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/km/2b/nmkm2bpk5osxvd1ohc4kmne7ck4.png"></div><br>  Al dividir las entradas en la direcci√≥n en componentes de desplazamiento, puede comprender claramente lo que est√° sucediendo aqu√≠.  Cada dos cuadros, el valor de <strong>Desplazamiento aproximado en Y</strong> disminuye, lo que lleva al desplazamiento vertical en un mosaico u 8 p√≠xeles. <br><br>  A lo largo de cada cuadro, el desplazamiento de desplazamiento inicial es 0.0, despu√©s de lo cual la grabaci√≥n en la l√≠nea de p√≠xeles 63 se realiza en la direcci√≥n.  Esto significa que las primeras 63 l√≠neas de p√≠xeles se dibujan desde la parte superior de la tabla de nombres seleccionada que contiene el fondo de la interfaz.  Sin embargo, la fila 64 de p√≠xeles se renderiza a√∫n m√°s con el desplazamiento vertical aplicado desde esta direcci√≥n.  Dado que el desplazamiento vertical disminuye cada dos cuadros, da la sensaci√≥n de desplazamiento vertical de una parte de la pantalla. <br><br><h3>  Despl√°cese hacia abajo para desplazarse hacia arriba </h3><br>  The Legend of Zelda no puede ocultar este truco a los jugadores por completo.  Crea un artefacto visible en las transiciones verticales de la pantalla, que son notables si se mira de cerca.  Al moverse entre habitaciones, el primer cuadro de la animaci√≥n de desplazamiento se desplazar√° hacia abajo.  Aqu√≠ est√° la animaci√≥n en c√°mara muy lenta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/a8c/79d/af8a8c79d1b4c50280c31fbf1540852a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/e37/9a6/a52e379a6e5d6dd444fe115d484bb846.gif" width="1024"></div><br>  En la tabla de nombres, puede ver lo que realmente est√° sucediendo.  Aunque puede parecer a los jugadores que el √°rea visible se desplazar√° hacia arriba sin problemas, la transici√≥n de desplazamiento comienza moviendo el √°rea visible desde la tabla de nombres superior izquierda a la tabla inferior izquierda, que contiene una copia del fondo de la sala.  Esto es necesario porque la interfaz en la parte superior de la pantalla tambi√©n es parte de la tabla de nombres, y si el √°rea visible se desplaza hacia arriba desde su posici√≥n original, pasar√≠a por la interfaz. <br><br>  El desplazamiento vertical se implementa escribiendo en el registro <code>PPUADDR</code> en el medio del marco.  El primer valor que se escribir√° es <code>0x2800</code> .  Dos cuadros m√°s tarde, <code>0x23A0</code> registra <code>0x23A0</code> , y luego el valor comienza a disminuir en 32 cada segundo cuadro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/la/gh/pklagh4idqhd3jg_mfkojhfv0lq.png"></div><br>  Escribir el valor <code>0x2800</code> en el registro <code>0x2800</code> <code>PPUADDR</code> <strong>tabla de</strong> <code>PPUADDR</code> en 2, lo que representa la tabla de nombres inferior izquierda.  Dado que ambos valores de desplazamiento son 0, comenzar√° desde el mosaico superior izquierdo de esta tabla de nombres.  Sin embargo, el <strong>desplazamiento exacto en Y</strong> es 2, por lo que hay un desplazamiento vertical de dos p√≠xeles desde la parte superior de la tabla de nombres inferior izquierda.  Es por eso que en el primer fotograma de la transici√≥n, vemos una barra negra de 2 p√≠xeles de altura en la parte inferior de la pantalla.  El valor de desplazamiento inicial para la animaci√≥n de transici√≥n se desplaza 2 p√≠xeles hacia abajo para que la transici√≥n sea fluida. <br><br>  Dos cuadros m√°s tarde, el <code>PPUADDR</code> escribe en <code>0x23A0</code> .  Esto nos lleva de vuelta a la tabla de nombres superior izquierda, y representamos desde la fila 29 de mosaicos, es decir, la parte inferior.  <strong>El desplazamiento exacto en Y</strong> todav√≠a contiene 2. <br><br>  ¬øPor qu√© es necesario <strong>establecer Exact Scrolling en Y</strong> en 2?  ¬øPor qu√© el juego simplemente no escribe <code>0x0800</code> y <code>0x03A0</code> para no sufrir un desplazamiento de dos p√≠xeles? <br><br>  Cuatro tablas de nombres ocupan el √°rea de 4 KB en el espacio de direcciones PPU, de <code>0x2000</code> a <code>0x2FFF</code> .  Cada mosaico en la tabla ocupa un byte de memoria de video (de hecho, son solo √≠ndices en otra tabla), y el orden de los mosaicos y las tablas de nombres en la memoria de video es tal que al <strong>seleccionar una tabla de nombres</strong> , el <strong>desplazamiento grueso por Y</strong> y el <strong>desplazamiento grueso por X</strong> conforman el desplazamiento del mosaico dentro √°reas de memoria con tablas de nombres.  Es decir, tomando los 12 bits inferiores del registro interno de PPU y agreg√°ndolos a <code>0x2000</code> , puede encontrar la direcci√≥n del <code>0x2000</code> en la memoria de video.  ¬°Y esto no es casualidad!  As√≠ es exactamente como debe manejarse el registro: tanto como un registro de direcci√≥n como como un registro de desplazamiento. <br><br>  Pero hay un defecto. <br><br>  Cuando se procesa como un registro de direcci√≥n, los bits 12 y 13 se consideran parte de la direcci√≥n.  Durante la representaci√≥n, la PPU sobrescribe constantemente el registro con la direcci√≥n del mosaico actual.  Como los mosaicos se encuentran en las tablas de nombres y las tablas se encuentran en el √°rea de memoria de <code>0x2000</code> a <code>0x2FFF</code> , PPU asigna valores de este intervalo al registro. <br><br>  Cuando el juego escribe en <code>PPUADDR</code> en el medio del cuadro, si no escribe la direcci√≥n del mosaico en la tabla de nombres, el PPU intentar√° leer <em>desde otro lugar</em> en la memoria de video.  Cualquier byte que cuente se percibir√° como mosaicos, lo que probablemente dar√° lugar a resultados no deseados.  Por lo tanto, todos los valores registrados en el medio del cuadro en <code>PPUADDR</code> deben estar en el rango de <code>0x2000</code> a <code>0x2FFF</code> .  Tomando cada n√∫mero en este intervalo y teniendo en cuenta sus componentes de desplazamiento, el valor de <strong>desplazamiento exacto en Y</strong> siempre debe ser igual a 2. <br><br>  Esta limitaci√≥n significa que no podemos cambiar el <strong>desplazamiento exacto en la</strong> direcci√≥n <strong>Y</strong> en el medio del marco, es decir, cuando usamos este truco para implementar el desplazamiento vertical de la separaci√≥n de la pantalla, estamos limitados a desplazar 8 p√≠xeles a la vez y siempre tenemos un desplazamiento vertical de dos p√≠xeles desde el borde del mosaico.  The Legend of Zelda mueve 4 p√≠xeles por cuadro cuando se desplaza horizontalmente, pero 8 p√≠xeles por cuadro cuando se desplaza verticalmente, y ahora sabemos por qu√©. <br><br>  El artefacto tambi√©n se nota al desplazarse entre las habitaciones hacia abajo, pero en este caso ocurre al final de la animaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/13b/89a/77d13b89abce5200d348de0379f409e5.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/eb2/9c2/468eb29c2eb3a97d7e4dd2a62682f1b9.gif" width="1024"></div><br><h2>  Lectura adicional </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NesDev Wiki</a> es un recurso invaluable para aprender sobre el hardware NES.  En particular, el tema de esta publicaci√≥n son p√°ginas sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desplazamiento de PPU</a> <br>  y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registros de PPU</a> . </li><li>  Mi emulador NES a√∫n sin terminar est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </li></ul><br><h2>  Notas </h2><br>  Hasta que descubr√≠ el registro interno de PPU, mi emulador mostr√≥ el efecto de borrado durante las transiciones verticales de la pantalla de The Legend of Zelda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/2a0/a5a/9322a0a5a1522a0ae0f6fbd21080286e.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1a/078/755/d1a0787558999dd61ec2ba9dc9ba9026.gif" width="1024"></div><br>  El sprite de Link se movi√≥ hacia abajo de la pantalla, como deber√≠a ser, pero el fondo no se desplaz√≥.  El borrado fue causado por el hecho de que el juego actualizaba gradualmente la tabla de nombres para que contuviera los gr√°ficos de la nueva sala, pero no actualizaba el desplazamiento para mantener las actualizaciones fuera de la pantalla. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460383/">https://habr.com/ru/post/460383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460367/index.html">Ingenier√≠a del Caos: el arte de la destrucci√≥n intencional. Parte 1</a></li>
<li><a href="../460373/index.html">Under the Hood Turbo Pages: Arquitectura de la p√°gina web Tecnolog√≠a de descarga r√°pida</a></li>
<li><a href="../460375/index.html">Libro "Aprendizaje autom√°tico para empresas y marketing"</a></li>
<li><a href="../460377/index.html">Uso de Liquibase para administrar la estructura de la base de datos en una aplicaci√≥n Spring Boot. Parte 1</a></li>
<li><a href="../460381/index.html">¬øQu√© es la asertividad y por qu√© es necesaria?</a></li>
<li><a href="../460387/index.html">Gu√≠a para principiantes de SELinux</a></li>
<li><a href="../460393/index.html">Antecedentes: qu√© esperar de Fedora Silverblue</a></li>
<li><a href="../460395/index.html">La anal√≠tica como caracter√≠stica: el proceso de trabajar con datos en Plesk</a></li>
<li><a href="../460397/index.html">Inicio r√°pido con WebComponents</a></li>
<li><a href="../460399/index.html">Indicador de carga de SVG en Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>