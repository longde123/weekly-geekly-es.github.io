<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßû üç∫ „ÄΩÔ∏è Principios S√ìLIDOS que todo desarrollador debe conocer üë©üèº‚Äçüî¨ üë®üèΩ‚Äçüíª üë±üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La programaci√≥n orientada a objetos ha tra√≠do nuevos enfoques al dise√±o de aplicaciones en el desarrollo de software. En particular, OOP permiti√≥ a lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Principios S√ìLIDOS que todo desarrollador debe conocer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426413/">  La programaci√≥n orientada a objetos ha tra√≠do nuevos enfoques al dise√±o de aplicaciones en el desarrollo de software.  En particular, OOP permiti√≥ a los programadores combinar entidades, unidas por un objetivo o funcionalidad com√∫n, en clases separadas, dise√±adas para resolver problemas independientes e independientes de otras partes de la aplicaci√≥n.  Sin embargo, el uso de OOP solo no significa que el desarrollador est√© a salvo de la posibilidad de crear c√≥digo oscuro y confuso que sea dif√≠cil de mantener.  Robert Martin, para ayudar a todos los que desean desarrollar aplicaciones OOP de alta calidad, desarroll√≥ cinco principios de programaci√≥n y dise√±o orientado a objetos, hablando de que, con la ayuda de Michael Fazers, usan el acr√≥nimo SOLID. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/46/xx/ol/46xxolpv46av7bknmyywp3ii9vs.jpeg"></a> <br><br>  El material, cuya traducci√≥n publicamos hoy, est√° dedicado a los conceptos b√°sicos de SOLID y est√° destinado a desarrolladores principiantes. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">¬øQu√© es s√≥lido?</font> </h2><br>  As√≠ es como el acr√≥nimo SOLID significa: <br><br><ul><li>  S: Principio de responsabilidad √∫nica. </li><li>  O: Principio abierto-cerrado. </li><li>  L: Principio de sustituci√≥n de Liskov (Principio de sustituci√≥n de Barbara Liskov). </li><li>  I: Principio de segregaci√≥n de interfaz. </li><li>  D: Principio de inversi√≥n de dependencia. </li></ul><br>  Ahora consideraremos estos principios en ejemplos esquem√°ticos.  Tenga en cuenta que el objetivo principal de los ejemplos es ayudar al lector a comprender los principios de SOLID, aprender c√≥mo aplicarlos y c√≥mo seguirlos al dise√±ar aplicaciones.  El autor del material no se esforz√≥ por alcanzar un c√≥digo de trabajo que pudiera usarse en proyectos reales. <br><br><h2>  <font color="#3AC1EF">Principio de responsabilidad exclusiva</font> </h2><br>  <i><font color="#999999">‚ÄúUn recado.</font></i>  <i><font color="#999999">Solo una cosa.</font></i>  <i><font color="#999999">- Loki le dice a Skurge en la pel√≠cula Thor: Ragnarok.</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">Cada clase debe resolver solo un problema.</font></i> <br><br>  Una clase solo debe ser responsable de una cosa.  Si una clase es responsable de resolver varios problemas, sus subsistemas que implementan la soluci√≥n de estos problemas se relacionan entre s√≠.  Los cambios en uno de esos subsistemas conducen a cambios en otro. <br><br>  Tenga en cuenta que este principio se aplica no solo a las clases, sino tambi√©n a los componentes de software en un sentido m√°s amplio. <br><br>  Por ejemplo, considere este c√≥digo: <br><br><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {    constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">){ }    getAnimalName() { }    saveAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { } }</span></span></code> </pre> <br>  La clase <code>Animal</code> presentada aqu√≠ describe alg√∫n tipo de animal.  Esta clase viola el principio de responsabilidad exclusiva.  ¬øC√≥mo se viola este principio exactamente? <br><br>  De acuerdo con el principio de responsabilidad exclusiva, una clase debe resolver una sola tarea.  Resuelve los dos trabajando con el almac√©n de datos en el m√©todo <code>saveAnimal</code> y manipulando las propiedades del objeto en el constructor y en el m√©todo <code>getAnimalName</code> . <br><br>  ¬øC√≥mo puede una estructura de clase as√≠ conducir a problemas? <br><br>  Si el procedimiento para trabajar con el almac√©n de datos utilizado por la aplicaci√≥n cambia, deber√° realizar cambios en todas las clases que funcionan con el almac√©n.  Esta arquitectura no es flexible, los cambios en algunos subsistemas afectan a otros, lo que se asemeja al efecto domin√≥. <br><br>  Para alinear el c√≥digo anterior con el principio de responsabilidad exclusiva, crearemos otra clase cuya √∫nica tarea es trabajar con el repositorio, en particular, almacenar objetos de la clase <code>Animal</code> en √©l: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {   constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">){ }   getAnimalName() { } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AnimalDB</span></span></span><span class="hljs-class"> {   getAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { }   saveAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { } }</span></span></code> </pre> <br>  Esto es lo que dice Steve Fenton sobre esto: ‚ÄúAl dise√±ar clases, debemos esforzarnos por integrar componentes relacionados, es decir, aquellos en los que se producen cambios por las mismas razones.  Deber√≠amos tratar de separar los componentes, cambios en los que se producen varias razones ". <br><br>  La correcta aplicaci√≥n del principio de responsabilidad exclusiva conduce a un alto grado de conectividad de los elementos dentro del m√≥dulo, es decir, al hecho de que las tareas resueltas dentro de √©l corresponden bien a su objetivo principal. <br><br><h2>  <font color="#3AC1EF">Principio abierto-cerrado</font> </h2><br>  <i><font color="#999999">Las entidades de software (clases, m√≥dulos, funciones) deben estar abiertas para expansi√≥n, pero no para modificaci√≥n.</font></i> <br><br>  Seguimos trabajando en la clase <code>Animal</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name: string){ }   getAnimalName() { } }</code> </pre> <br>  Queremos clasificar la lista de animales, cada uno de los cuales est√° representado por un objeto de la clase <code>Animal</code> , y descubrir qu√© sonidos emiten.  Imagine que resolvemos este problema usando la funci√≥n <code>AnimalSounds</code> : <br><br><pre> <code class="hljs powershell">//... const animals: Array&lt;Animal&gt; = [   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'lion'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'mouse'</span></span>) ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'lion'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'mouse'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;   } } AnimalSound(animals);</code> </pre> <br>  El principal problema con esta arquitectura es que la funci√≥n determina qu√© tipo de sonido hace un animal al analizar objetos espec√≠ficos.  La funci√≥n <code>AnimalSound</code> no cumple con el principio de apertura-cierre, ya que, por ejemplo, cuando aparecen nuevos tipos de animales, debemos cambiarlo para poder utilizarlo y reconocer los sonidos que emiten. <br><br>  Agregue un nuevo elemento a la matriz: <br><br><pre> <code class="hljs powershell">//... const animals: Array&lt;Animal&gt; = [   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'lion'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'mouse'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'snake'</span></span>) ] //...</code> </pre> <br>  Despu√©s de eso, tenemos que cambiar el c√≥digo de la funci√≥n <code>AnimalSound</code> : <br><br><pre> <code class="hljs powershell">//... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'lion'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'mouse'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'snake'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hiss'</span></span>;   } } AnimalSound(animals);</code> </pre> <br>  Como puede ver, al agregar un nuevo animal a la matriz, tendr√° que complementar el c√≥digo de funci√≥n.  Un ejemplo es muy simple, pero si se utiliza una arquitectura similar en un proyecto real, la funci√≥n tendr√° que expandirse constantemente, agregando nuevas expresiones <code>if</code> . <br><br>  ¬øC√≥mo alinear la funci√≥n <code>AnimalSound</code> con el principio de abierto-cerrado?  Por ejemplo, as√≠: <br><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {       makeSound();       //... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;   } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Squirrel</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;   } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Snake</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hiss'</span></span>;   } } //... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       a[<span class="hljs-type"><span class="hljs-type">i</span></span>].makeSound();   } } AnimalSound(animals);</code> </pre> <br>  Puede notar que la clase <code>Animal</code> ahora tiene un m√©todo virtual <code>makeSound</code> .  Con este enfoque, es necesario que las clases dise√±adas para describir animales espec√≠ficos expandan la clase <code>Animal</code> e implementen este m√©todo. <br><br>  Como resultado, cada clase que describa un animal tendr√° su propio m√©todo <code>makeSound</code> , y al iterar sobre una matriz con animales en la funci√≥n <code>AnimalSound</code> , ser√° suficiente llamar a este m√©todo para cada elemento de la matriz. <br><br>  Si ahora agrega un objeto que describe el nuevo animal a la matriz, no tendr√° que cambiar la funci√≥n <code>AnimalSound</code> .  Lo alineamos con el principio de apertura-cercan√≠a. <br><br>  Considere otro ejemplo. <br><br>  Supongamos que tenemos una tienda.  Les damos a los clientes un 20% de descuento usando esta clase: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Discount</span></span></span><span class="hljs-class"> </span></span>{   giveDiscount() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.2</span></span>   } }</code> </pre> <br>  Ahora se decidi√≥ dividir a los clientes en dos grupos.  Los clientes favoritos ( <code>fav</code> ) reciben un descuento del 20% y los clientes VIP ( <code>vip</code> ), el doble del descuento, es decir, el 40%.  Para implementar esta l√≥gica, se decidi√≥ modificar la clase de la siguiente manera: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Discount</span></span></span><span class="hljs-class"> </span></span>{   giveDiscount() {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customer == <span class="hljs-string"><span class="hljs-string">'fav'</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.2</span></span>;       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customer == <span class="hljs-string"><span class="hljs-string">'vip'</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.4</span></span>;       }   } }</code> </pre> <br>  Este enfoque viola el principio de apertura-cercan√≠a.  Como puede ver, aqu√≠, si necesitamos otorgar un descuento especial a cierto grupo de clientes, tenemos que agregar un nuevo c√≥digo a la clase. <br><br>  Para procesar este c√≥digo de acuerdo con el principio de apertura-cercan√≠a, agregamos una nueva clase al proyecto que extiende la clase <code>Discount</code> .  En esta nueva clase, estamos implementando un nuevo mecanismo: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VIPDiscount</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Discount {   getDiscount</span></span></span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getDiscount() * <span class="hljs-number"><span class="hljs-number">2</span></span>;   } }</code> </pre> <br>  Si decide dar un descuento del 80% a los clientes "s√∫per VIP", deber√≠a verse as√≠: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperVIPDiscount</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIPDiscount {   getDiscount</span></span></span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getDiscount() * <span class="hljs-number"><span class="hljs-number">2</span></span>;   } }</code> </pre> <br>  Como puede ver, aqu√≠ se usa el empoderamiento de las clases, no su modificaci√≥n. <br><br><h2>  <font color="#3AC1EF">El principio de sustituci√≥n de Barbara Liskov</font> </h2><br>  <i><font color="#999999">Es necesario que las subclases sirvan como sustitutos de sus superclases.</font></i> <br><br>  El prop√≥sito de este principio es que las clases de herencia se pueden usar en lugar de las clases primarias a partir de las cuales se forman sin interrumpir el programa.  Si resulta que el tipo de clase est√° marcado en el c√≥digo, entonces se viola el principio de sustituci√≥n. <br><br>  Considere la aplicaci√≥n de este principio, volviendo al ejemplo con la clase <code>Animal</code> .  Escribiremos una funci√≥n dise√±ada para devolver informaci√≥n sobre el n√∫mero de extremidades de un animal. <br><br><pre> <code class="hljs powershell">//... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Lion)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LionLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Mouse)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MouseLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Snake)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SnakeLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);   } } AnimalLegCount(animals);</code> </pre> <br>  La funci√≥n viola el principio de sustituci√≥n (y el principio de apertura-cierre).  Este c√≥digo debe conocer los tipos de todos los objetos procesados ‚Äã‚Äãpor √©l y, seg√∫n el tipo, usar la funci√≥n correspondiente para calcular las extremidades de un animal en particular.  Como resultado, al crear un nuevo tipo de animal, la funci√≥n deber√° reescribirse: <br><br><pre> <code class="hljs powershell">//... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pigeon</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {      } const animals[]: Array&lt;Animal&gt; = [   //<span class="hljs-type"><span class="hljs-type">...</span></span>,   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Pigeon</span></span>(); ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Lion)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LionLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Mouse)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MouseLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Snake)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SnakeLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Pigeon)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PigeonLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);   } } AnimalLegCount(animals);</code> </pre> <br>  Para que esta funci√≥n no viole el principio de sustituci√≥n, la transformamos utilizando los requisitos formulados por Steve Fenton.  Consisten en el hecho de que los m√©todos que aceptan o devuelven valores con el tipo de una determinada superclase ( <code>Animal</code> en nuestro caso) tambi√©n deber√≠an aceptar y devolver valores cuyos tipos son sus subclases ( <code>Pigeon</code> ). <br><br>  Armados con estas consideraciones, podemos rehacer la funci√≥n <code>AnimalLegCount</code> : <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt;= a.length; i++)</span></span></span><span class="hljs-function"> {       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;   } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animals)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Ahora esta funci√≥n no est√° interesada en los tipos de objetos que se le pasan.  Ella simplemente llama a sus m√©todos <code>LegCount</code> .  Todo lo que sabe sobre los tipos es que los objetos que procesa deben pertenecer a la clase <code>Animal</code> o sus subclases. <br><br>  El m√©todo <code>LegCount</code> ahora deber√≠a aparecer en la clase <code>Animal</code> : <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//...   LegCount(); }</span></span></code> </pre> <br>  Y sus subclases necesitan implementar este m√©todo: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class">{   //...   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LegCount</span></span></span><span class="hljs-class">() {       //...   } } //...</span></span></code> </pre> <br>  Como resultado, por ejemplo, al acceder al m√©todo <code>LegCount</code> para una instancia de la clase <code>Lion</code> , se llama al m√©todo implementado en esta clase y se devuelve exactamente lo que se puede esperar al llamar a dicho m√©todo. <br><br>  Ahora la funci√≥n <code>AnimalLegCount</code> no necesita saber qu√© objeto de una subclase particular de la clase <code>Animal</code> procesa para encontrar informaci√≥n sobre el n√∫mero de extremidades en el animal representado por este objeto.  La funci√≥n simplemente llama al m√©todo <code>LegCount</code> de la clase <code>Animal</code> , ya que las subclases de esta clase deben implementar este m√©todo para que puedan usarse en su lugar, sin violar la operaci√≥n correcta del programa. <br><br><h2>  <font color="#3AC1EF">Principio de separaci√≥n de interfaz</font> </h2><br>  <i><font color="#999999">Cree interfaces altamente especializadas dise√±adas para un cliente espec√≠fico.</font></i>  <i><font color="#999999">Los clientes no deben depender de las interfaces que no usan.</font></i> <br><br>  Este principio tiene como objetivo abordar las deficiencias asociadas con la implementaci√≥n de interfaces grandes. <br><br>  Considere la interfaz de <code>Shape</code> : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Shape</span></span> {   drawCircle();   drawSquare();   drawRectangle(); }</code> </pre> <br>  Describe m√©todos para dibujar c√≠rculos ( <code>drawCircle</code> ), cuadrados ( <code>drawSquare</code> ) y rect√°ngulos ( <code>drawRectangle</code> ).  Como resultado, las clases que implementan esta interfaz y representan formas geom√©tricas individuales, como un c√≠rculo, un cuadrado y un rect√°ngulo, deben contener una implementaci√≥n de todos estos m√©todos.  Se ve as√≠: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Circle</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Square</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rectangle</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } }</span></span></code> </pre> <br>  C√≥digo extra√±o result√≥.  Por ejemplo, la clase <code>Rectangle</code> representa un rect√°ngulo implementa m√©todos ( <code>drawCircle</code> y <code>drawSquare</code> ) que no necesita en absoluto.  Lo mismo se puede ver al analizar el c√≥digo de otras dos clases. <br><br>  Supongamos que decidimos agregar otro m√©todo a la interfaz <code>Shape</code> , <code>drawTriangle</code> , dise√±ado para dibujar tri√°ngulos: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Shape</span></span> {   drawCircle();   drawSquare();   drawRectangle();   drawTriangle(); }</code> </pre> <br>  Esto dar√° como resultado que las clases que representan formas geom√©tricas espec√≠ficas tengan que implementar tambi√©n el m√©todo <code>drawTriangle</code> .  De lo contrario, se producir√° un error. <br><br>  Como puede ver, con este enfoque es imposible crear una clase que implemente un m√©todo para generar un c√≠rculo, pero no implementa m√©todos para derivar un cuadrado, un rect√°ngulo y un tri√°ngulo.  Dichos m√©todos se pueden implementar de modo que cuando se emiten, se produce un error que indica que tal operaci√≥n no se puede realizar. <br><br>  El principio de separaci√≥n de interfaz nos advierte contra la creaci√≥n de interfaces como <code>Shape</code> partir de nuestro ejemplo.  Los clientes (tenemos las clases <code>Circle</code> , <code>Square</code> y <code>Rectangle</code> ) no deben implementar m√©todos que no necesitan usar.  Adem√°s, este principio indica que la interfaz debe resolver solo una tarea en particular (en esto es similar al principio de responsabilidad exclusiva), por lo tanto, todo lo que va m√°s all√° del alcance de esta tarea debe transferirse a otra interfaz o interfaces. <br><br>  En nuestro caso, la interfaz <code>Shape</code> resuelve problemas para cuya soluci√≥n es necesario crear interfaces separadas.  Siguiendo esta idea, reelaboramos el c√≥digo creando interfaces separadas para resolver varias tareas altamente especializadas: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> </span></span>{   draw(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICircle</span></span></span><span class="hljs-class"> </span></span>{   drawCircle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISquare</span></span></span><span class="hljs-class"> </span></span>{   drawSquare(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IRectangle</span></span></span><span class="hljs-class"> </span></span>{   drawRectangle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ITriangle</span></span></span><span class="hljs-class"> </span></span>{   drawTriangle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Circle</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICircle</span></span></span><span class="hljs-class"> </span></span>{   drawCircle() {       <span class="hljs-comment"><span class="hljs-comment">//...   } } class Square implements ISquare {   drawSquare() {       //...   } } class Rectangle implements IRectangle {   drawRectangle() {       //...   } } class Triangle implements ITriangle {   drawTriangle() {       //...   } } class CustomShape implements Shape {  draw(){     //...  } }</span></span></code> </pre> <br>  Ahora la interfaz <code>ICircle</code> usa solo para dibujar c√≠rculos, as√≠ como otras interfaces especializadas para dibujar otras formas.  La interfaz <code>Shape</code> se puede utilizar como una interfaz universal. <br><br><h2>  <font color="#3AC1EF">Principio de inversi√≥n de dependencia</font> </h2><br>  <i><font color="#999999">El objeto de dependencia debe ser una abstracci√≥n, no algo espec√≠fico.</font></i> <br><br><ol><li>  Los m√≥dulos de nivel superior no deben depender de los m√≥dulos de nivel inferior.  Ambos tipos de m√≥dulos deber√≠an depender de abstracciones. </li><li>  Las abstracciones no deber√≠an depender de los detalles.  Los detalles deben depender de las abstracciones. </li></ol><br>  En el proceso de desarrollo de software, hay un momento en que la funcionalidad de la aplicaci√≥n deja de encajar en el mismo m√≥dulo.  Cuando esto sucede, tenemos que resolver el problema de las dependencias del m√≥dulo.  Como resultado, por ejemplo, puede resultar que los componentes de alto nivel dependan de los componentes de bajo nivel. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpRequestService</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http</span></span></span><span class="hljs-class"> </span></span>{   constructor(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> xmlhttpService: <span class="hljs-type"><span class="hljs-type">XMLHttpService</span></span>) { }   get(url: string , options: any) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xmlhttpService.request(url,<span class="hljs-symbol"><span class="hljs-symbol">'GE</span></span>T');   }   post() {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xmlhttpService.request(url,<span class="hljs-symbol"><span class="hljs-symbol">'POS</span></span>T');   }   <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Aqu√≠, la clase <code>Http</code> es un componente de alto nivel, y <code>XMLHttpService</code> es un componente de bajo nivel.  Tal arquitectura viola la cl√°usula A del principio de inversi√≥n de dependencia: ‚ÄúLos m√≥dulos de niveles superiores no deber√≠an depender de m√≥dulos de niveles inferiores.  Ambos tipos de m√≥dulos deber√≠an depender de abstracciones ". <br><br>  La clase <code>Http</code> se ve obligada a depender de la clase <code>XMLHttpService</code> .  Si decidimos cambiar el mecanismo utilizado por la clase <code>Http</code> para interactuar con la red, digamos que ser√° un servicio Node.js o, por ejemplo, un servicio de c√≥digo auxiliar utilizado para fines de prueba, tendremos que editar todas las instancias de la clase <code>Http</code> cambiando el c√≥digo correspondiente.  Esto viola el principio de apertura-cercan√≠a. <br><br>  La clase <code>Http</code> no debe saber qu√© se usa exactamente para establecer una conexi√≥n de red.  Por lo tanto, crearemos la interfaz de <code>Connection</code> : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Connection</span></span> {   request(url: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, opts:any); }</code> </pre> <br>  La interfaz de <code>Connection</code> contiene una descripci√≥n del m√©todo de <code>request</code> y pasamos el argumento de tipo de <code>Connection</code> a la clase <code>Http</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> httpConnection: Connection) { }   <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url: string , options: any) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpConnection.request(url,<span class="hljs-string"><span class="hljs-string">'GET'</span></span>);   }   post() {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpConnection.request(url,<span class="hljs-string"><span class="hljs-string">'POST'</span></span>);   }   <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Ahora, independientemente de lo que se use para organizar la interacci√≥n con la red, la clase <code>Http</code> puede usar lo que se le pas√≥, sin preocuparse por lo que est√° oculto detr√°s de la interfaz de <code>Connection</code> . <br><br>  Reescribimos la clase <code>XMLHttpService</code> para que implemente esta interfaz: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest();   <span class="hljs-comment"><span class="hljs-comment">//...   request(url: string, opts:any) {       xhr.open();       xhr.send();   } }</span></span></code> </pre> <br>  Como resultado, podemos crear muchas clases que implementan la interfaz de <code>Connection</code> y son adecuadas para su uso en la clase <code>Http</code> para organizar el intercambio de datos a trav√©s de la red: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class"> </span></span>{   request(url: string, opts:any) {       <span class="hljs-comment"><span class="hljs-comment">//...   } } class MockHttpService implements Connection {   request(url: string, opts:any) {       //...   } }</span></span></code> </pre> <br>  Como puede ver, aqu√≠ los m√≥dulos de alto y bajo nivel dependen de abstracciones.  La clase <code>Http</code> (m√≥dulo de alto nivel) depende de la interfaz de <code>Connection</code> (abstracci√≥n).  Las <code>XMLHttpService</code> , <code>NodeHttpService</code> y <code>MockHttpService</code> (m√≥dulos de bajo nivel) tambi√©n dependen de la interfaz de <code>Connection</code> . <br><br>  Adem√°s, vale la pena se√±alar que siguiendo el principio de inversi√≥n de dependencia, observamos el principio de sustituci√≥n Barbara Liskov.  A saber, resulta que los tipos <code>XMLHttpService</code> , <code>NodeHttpService</code> y <code>MockHttpService</code> pueden servir como un reemplazo para el tipo b√°sico <code>Connection</code> . <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Aqu√≠ observamos cinco principios S√ìLIDOS que todo desarrollador de OOP debe cumplir.  Al principio, esto puede no ser f√°cil, pero si se esfuerza por lograr esto, reforzando los deseos de pr√°ctica, estos principios se convierten en una parte natural del flujo de trabajo, lo que tiene un gran impacto positivo en la calidad de las aplicaciones y facilita enormemente su apoyo. <br><br>  <b>Estimados lectores!</b>  ¬øUtiliza principios SOLIDOS en sus proyectos? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426413/">https://habr.com/ru/post/es426413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426401/index.html">Amazon ense√±ar√° su IA para definir las emociones humanas</a></li>
<li><a href="../es426405/index.html">Hackers en el marco de las leyes de la Federaci√≥n Rusa</a></li>
<li><a href="../es426407/index.html">C√≥mo hacer que el viaje a la conferencia sea lo m√°s in√∫til posible</a></li>
<li><a href="../es426409/index.html">El hacker Alexei, que protege los enrutadores MikroTik sin el permiso de los propietarios, se ha hecho famoso.</a></li>
<li><a href="../es426411/index.html">Desarrollo de clases de descriptor C ++ / CLI</a></li>
<li><a href="../es426415/index.html">Fintech-digest: control de digitalizaci√≥n por parte del Banco Central, salario de criptomonedas, tarjeta Mir en forma de pulseras y llaveros</a></li>
<li><a href="../es426417/index.html">Pavel 2.0: consultor reptiloide en JS, node.js con sockets y telefon√≠a</a></li>
<li><a href="../es426419/index.html">M√©todos de sobrecarga o puente prohibidos en Java</a></li>
<li><a href="../es426421/index.html">EHCI humanamente en ruso</a></li>
<li><a href="../es426423/index.html">mmWave en tel√©fonos inteligentes: c√≥mo Qualcomm hizo posible lo imposible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>