<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•• ‚ùå üñºÔ∏è Mencoba Pemrograman Kontrak C ++ 20 Sekarang üíÜüèø üëÇüèø üí™üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di C ++ 20, pemrograman kontrak telah muncul. Sampai saat ini, belum ada kompiler yang mengimplementasikan dukungan untuk fitur ini. 


 Tetapi ada ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mencoba Pemrograman Kontrak C ++ 20 Sekarang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443766/"><p><img src="https://habrastorage.org/webt/ow/o1/yv/owo1yvuvpymi1w4uoa1olkjoo0g.png"></p><br><p>  Di C ++ 20, pemrograman kontrak telah muncul.  Sampai saat ini, belum ada kompiler yang mengimplementasikan dukungan untuk fitur ini. </p><br><p>  Tetapi ada cara sekarang untuk mencoba menggunakan kontrak dari C ++ 20, seperti yang dijelaskan dalam standar. </p><a name="habracut"></a><br><h3 id="tldr">  TL; DR </h3><br><p>  <em>Ada dentang garpu yang mendukung kontrak.</em>  <em>Menggunakan contohnya, saya memberi tahu Anda cara menggunakan kontrak sehingga segera setelah fitur muncul di kompiler favorit Anda, Anda dapat segera mulai menggunakannya.</em> </p><br><p>  Sudah banyak yang ditulis tentang pemrograman kontrak, tetapi singkatnya saya akan memberi tahu Anda apa itu dan untuk apa. </p><br><h2 id="logika-hoara">  Logika Hoar </h2><br><p>  Paradigma kontrak didasarkan pada logika Hoar ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> ). </p><br><p> Logika hoar adalah cara untuk secara formal membuktikan kebenaran suatu algoritma. <br>  Ini beroperasi dengan konsep-konsep seperti prasyarat, pascakondisi dan invarian. <br>  Dari sudut pandang praktis, penggunaan logika Hoar adalah, pertama, cara membuktikan secara formal kebenaran suatu program dalam kasus di mana kesalahan dapat menyebabkan bencana atau hilangnya nyawa.  Kedua, cara untuk meningkatkan keandalan program, bersama dengan analisis dan pengujian statis. </p><br><h2 id="kontraktnoe-programmirovanie">  Pemrograman kontrak </h2><br><p>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> ) </p><br><p>  Gagasan utama kontrak adalah bahwa, dengan analogi dengan kontrak dalam bisnis, perjanjian dijelaskan untuk setiap fungsi atau metode.  Pengaturan ini harus diperhatikan oleh penelepon dan penelepon. <br>  Bagian integral dari kontrak adalah setidaknya dua mode perakitan - debugging dan toko bahan makanan.  Kontrak harus berperilaku berbeda tergantung pada mode build.  Praktik yang paling umum adalah memeriksa kontrak di unit debug dan mengabaikannya di toko. </p><br><p>  Kadang-kadang kontrak juga diperiksa dalam rakitan produk dan ketidakpatuhannya dapat, misalnya, mengarah pada pembentukan pengecualian. </p><br><p>  Perbedaan utama antara penggunaan kontrak dari pendekatan "klasik" adalah bahwa penelepon harus mematuhi prasyarat callee, yang dijelaskan dalam kontrak, dan penelepon harus mematuhi postconditions dan invariannya. <br>  Oleh karena itu, pihak yang dipanggil tidak diharuskan memverifikasi kebenaran parameternya.  Kewajiban ini ditugaskan untuk penelepon oleh kontrak. </p><br><p>  Ketidakpatuhan terhadap kontrak harus dideteksi pada tahap pengujian dan melengkapi semua jenis pengujian: integrasi modular, dll. </p><br><p>  Sekilas, penggunaan kontrak membuat pengembangan lebih sulit dan menurunkan keterbacaan kode.  Faktanya, kebalikannya adalah benar.  Penganut pengetikan statis akan merasa lebih mudah untuk mengevaluasi manfaat dari kontrak, karena opsi termudah mereka adalah untuk menggambarkan jenis dalam tanda tangan metode dan fungsi. </p><br><p>  Jadi, apa manfaat dari kontrak: </p><br><ul><li>  Tingkatkan keterbacaan kode melalui dokumentasi eksplisit. </li><li>  Tingkatkan keandalan kode dengan melengkapi pengujian. </li><li>  Izinkan kompiler menggunakan optimasi tingkat rendah dan menghasilkan kode lebih cepat berdasarkan kepatuhan kontrak.  Dalam kasus yang terakhir, ketidakpatuhan terhadap kontrak dalam majelis rilis dapat menyebabkan UB. </li></ul><br><h2 id="kontraktnoe-programmirovanie-v-c">  Pemrograman kontrak dalam C ++ </h2><br><p>  Pemrograman kontrak diimplementasikan dalam banyak bahasa.  Contoh yang paling mencolok adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eiffel</a> , di mana paradigma pertama kali diterapkan, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">D</a> , dalam kontrak D adalah bagian dari bahasa tersebut. </p><br><p>  Dalam C ++, sebelum standar C ++ 20, kontrak dapat digunakan sebagai pustaka yang terpisah. </p><br><p>  Pendekatan ini memiliki beberapa kelemahan: </p><br><ul><li>  Sintaksnya sangat kikuk menggunakan macro. </li><li>  Kurangnya gaya tunggal. </li><li>  Ketidakmampuan untuk menggunakan kontrak oleh kompiler untuk mengoptimalkan kode. </li></ul><br><p>  Implementasi perpustakaan biasanya didasarkan pada penggunaan arahan lama dan preprosesor yang baik yang memeriksa flag kompilasi. </p><br><p>  Menggunakan kontrak dalam formulir ini benar-benar membuat kode jelek dan tidak dapat dibaca.  Ini adalah salah satu alasan mengapa menggunakan kontrak dalam C ++ sedikit dipraktikkan. </p><br><p>  Ke depan, saya akan menunjukkan bagaimana penggunaan kontrak akan terlihat dalam C ++ 20. <br>  Dan kemudian, kami akan menganalisis semua ini secara lebih rinci: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> [[ expects: x &gt; 0 ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// precondition [[ expects: y &gt; 0 ]] // precondition [[ ensures r: r &lt; x + y ]] // postcondition { int z = (x - x%y) / y; [[ assert: z &gt;= 0 ]]; // assertion return z + y; }</span></span></span></span></code> </pre> <br><h2 id="probuem">  Coba </h2><br><p>  Sayangnya, saat ini, tidak ada kompiler yang banyak digunakan belum menerapkan dukungan kontrak. <br>  Tapi ada jalan keluar. </p><br><p>  <em>Kelompok penelitian ARCOS</em> dari <em>Universidad Carlos III de Madrid</em> menerapkan dukungan eksperimental untuk kontrak di cabang clang ++. </p><br><p>  Agar tidak "menulis kode pada selembar kertas", tetapi untuk dapat segera mencoba peluang baru dalam bisnis, kami dapat mengumpulkan garpu ini dan menggunakannya untuk mencoba contoh di bawah ini. </p><br><p>  Instruksi perakitan dijelaskan dalam readme dari repositori github <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/arcosuc3m/clang-contracts</a> </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/arcosuc3m/clang-contracts/ mkdir -p clang-contracts/build/ &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> clang-contracts/build/ cmake -G <span class="hljs-string"><span class="hljs-string">"Unix Makefiles"</span></span> -DLLVM_USE_LINKER=gold -DBUILD_SHARED_LIBS=ON -DLLVM_USE_SPLIT_DWARF=ON -DLLVM_OPTIMIZED_TABLEGEN=ON ../ make -j8</code> </pre> <br><p>  Saya tidak punya masalah selama perakitan, tetapi mengkompilasi sumber membutuhkan waktu yang sangat lama. </p><br><p>  Untuk mengkompilasi contoh-contoh, Anda harus secara eksplisit menentukan jalur ke biner dentang ++. <br>  Sebagai contoh, ini terlihat seperti ini untuk saya </p><br><pre> <code class="bash hljs">/home/valmat/work/git/clang-contracts/build/bin/clang++ -std=c++2a -build-level=audit -g test.cpp -o test.bin</code> </pre> <br><p>  Saya telah menyiapkan contoh untuk memudahkan Anda memeriksa kontrak menggunakan contoh kode nyata.  Saya sarankan, sebelum Anda mulai membaca bagian selanjutnya, klon dan kompilasi contoh. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/valmat/cpp20-contracts-examples/ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> cpp20-contracts-examples make CPP=/path/to/clang++</code> </pre> <br><p>  Di sini <code>/path/to/clang++</code> path ke <code>clang++</code> binary dari rakitan kompiler eksperimental Anda. </p><br><p>  Selain kompiler itu sendiri, grup riset ARCOS menyiapkan versi mereka dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Compiler Explorer</a> untuk fork mereka. </p><br><h2 id="kontraktnoe-programmirovanie-v-c20">  Pemrograman kontrak dalam C ++ 20 </h2><br><p>  Sekarang tidak ada yang menghalangi kita untuk mulai meneliti kemungkinan yang ditawarkan oleh pemrograman kontrak, dan segera mencoba peluang ini dalam praktik. </p><br><p>  Seperti disebutkan di atas, kontrak dibangun dari prasyarat, postkondisi dan invarian (pernyataan). </p><br><p>  Di C ++ 20, atribut dengan sintaks berikut digunakan untuk ini </p><br><pre> <code class="cpp hljs">[[contract-attribute modifier identifier: conditional-expression]]</code> </pre> <br><p>  Di mana <code>contract-attribute</code> dapat mengambil salah satu dari nilai berikut: <br>  <strong>mengharapkan</strong> , <strong>memastikan</strong> atau <strong>menegaskan</strong> . </p><br><p>  <code>expects</code> digunakan untuk prasyarat, <code>ensures</code> pascakondisi dan pernyataan pernyataan. </p><br><p>  <code>conditional-expression</code> adalah <code>conditional-expression</code> Boolean yang divalidasi dalam predikat kontrak. <br>  <code>modifier</code> dan <code>identifier</code> dapat dihilangkan. </p><br><p>  Mengapa saya memerlukan <code>modifier</code> saya akan menulis sedikit lebih rendah. </p><br><p>  <code>identifier</code> hanya digunakan dengan <code>ensures</code> dan digunakan untuk mewakili nilai kembali. </p><br><p>  Prasyarat memiliki akses ke argumen. </p><br><p>  Postconditions memiliki akses ke nilai yang dikembalikan oleh fungsi.  Sintaks digunakan untuk ini. </p><br><pre> <code class="cpp hljs">[[ensures return_variable: expr(return_variable)]]</code> </pre> <br><p>  Di mana <code>return_variable</code> ekspresi apa pun yang valid untuk variabel. </p><br><p>  Dengan kata lain, prasyarat dimaksudkan untuk menyatakan pembatasan yang dikenakan pada argumen yang diterima oleh fungsi, dan postkondisi untuk menyatakan pembatasan yang dikenakan pada nilai yang dikembalikan oleh fungsi. </p><br><p>  Dipercayai bahwa <em>prasyarat</em> dan <em>postkondisi</em> adalah bagian dari antarmuka fungsi, sedangkan <em>pernyataan</em> adalah bagian dari implementasinya. </p><br><p>  Predikat prakondisi selalu dievaluasi segera sebelum fungsi dijalankan.  Kondisi pos terpenuhi segera setelah fungsi kontrol beralih ke kode panggilan. </p><br><p>  Jika pengecualian dilemparkan dalam suatu fungsi, maka kondisi akhir tidak akan diperiksa. <br>  Kondisi akhir diperiksa hanya jika fungsi selesai secara normal. </p><br><p>  Jika pengecualian terjadi saat memeriksa ekspresi dalam kontrak, <code>std::terminate()</code> akan dipanggil. </p><br><p>  Prasyarat dan postkondisi selalu dijelaskan di luar fungsi tubuh dan tidak dapat memiliki akses ke variabel lokal. </p><br><p>  Jika prasyarat dan postkondisi menggambarkan kontrak untuk metode kelas publik, mereka tidak dapat memiliki akses ke bidang kelas pribadi dan yang dilindungi.  Jika metode kelas dilindungi, maka ada akses ke data publik yang dilindungi dan publik, tetapi tidak untuk pribadi. <br>  Batasan terakhir sepenuhnya logis, mengingat bahwa kontrak adalah bagian dari antarmuka metode. </p><br><p>  Pernyataan (invarian) selalu dijelaskan dalam tubuh fungsi atau metode.  Secara desain, mereka adalah bagian dari implementasi.  Dan, karenanya, mereka dapat memiliki akses ke semua data yang tersedia.  Termasuk variabel fungsi lokal dan bidang kelas pribadi dan yang dilindungi. </p><br><p>  <a href="">contoh 1</a> </p><br><p>  Kami mendefinisikan dua prasyarat, satu pascakondisi dan satu invarian: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> [[ expects: x &gt; y ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// precondition #1 [[ expects: y &gt; 0 ]] // precondition #2 [[ ensures r: r &lt; x ]] // postcondition #3 { int z = (x - x%y) / y; [[ assert: z &gt;= 0 ]]; // assertion return z; } int main() { std::cout &lt;&lt; foo(117, 20) &lt;&lt; std::endl; std::cout &lt;&lt; foo(10, 20) &lt;&lt; std::endl; // &lt;-- contract violation #1 std::cout &lt;&lt; foo(100, -5) &lt;&lt; std::endl; // &lt;-- contract violation #2 return 0; }</span></span></span></span></code> </pre> <br><p>  <a href="">contoh 2</a> </p><br><p>  Prasyarat metode publik tidak dapat merujuk ke bidang yang dilindungi atau pribadi: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//protected: int m = 5; public: int foo(int n) [[expects: n &lt; m]] { return n*n; } };</span></span></code> </pre> <br><p>  Modifikasi variabel dalam ekspresi yang dijelaskan oleh atribut kontrak tidak diperbolehkan.  Jika rusak, akan ada UB. </p><br><p>  Ekspresi yang dijelaskan dalam kontrak tidak boleh memiliki efek samping.  Meskipun kompiler dapat memverifikasi ini, mereka tidak diharuskan untuk melakukannya.  Pelanggaran terhadap persyaratan ini dianggap sebagai perilaku yang tidak terdefinisi. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: n &lt; m++ ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// UB: Modifies variable m { int k = n*n; [[ assert: ++k &lt; 100 ]] // UB: Modifies variable k return n*n; } };</span></span></span></span></code> </pre> <br><p>  Persyaratan untuk tidak mengubah keadaan program dalam ekspresi kontrak akan menjadi sedikit lebih rendah ketika saya berbicara tentang tingkat pengubah kontrak dan mode pembuatan. </p><br><p>  Sekarang saya hanya mencatat bahwa program yang benar harus berfungsi seperti tidak ada kontrak sama sekali. </p><br><p>  Seperti yang saya sebutkan di atas, dalam kontrak Anda dapat menentukan sebanyak mungkin prasyarat dan kondisi akhir yang Anda inginkan. <br>  Semuanya akan diperiksa secara berurutan.  Tetapi prasyarat selalu diperiksa sebelum fungsi dijalankan, dan postkondisi segera setelah keluar. </p><br><p>  Ini berarti bahwa prasyarat selalu diperiksa terlebih dahulu, seperti diilustrasikan dalam contoh berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function"> ]] </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// # 1 [[ ensures r: expr(r) ]] // # 4 [[ expects: expr(n) ]] // # 2 [[ expects: expr(n) ]] // # 3 [[ ensures r: expr(r) ]] // # 5 {...}</span></span></span></span></code> </pre> <br><p>  Ekspresi di postconditions dapat merujuk tidak hanya pada nilai yang dikembalikan oleh fungsi, tetapi juga pada argumen fungsi. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;n)</span></span></span><span class="hljs-function"> [[ ensures: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function"> ]]</span></span>;</code> </pre> <br><p>  Dalam hal ini, Anda dapat menghilangkan pengidentifikasi nilai pengembalian. </p><br><p>  Jika postcondition merujuk pada argumen fungsi, maka argumen ini dianggap <em>pada titik keluar dari fungsi</em> , dan bukan pada titik masuk, seperti halnya dengan prasyarat. </p><br><p>  Tidak ada cara untuk merujuk ke nilai asli (pada titik masuk fungsi) di postcondition. </p><br><p>  <a href="">contoh</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;n)</span></span></span><span class="hljs-function"> [[ expects: 3 </span></span>== n ]] [[ ensures: <span class="hljs-number"><span class="hljs-number">4</span></span> == n ]] {++n;}</code> </pre> <br><p>  Predikat dalam kontrak dapat merujuk ke variabel lokal hanya jika masa pakai dari variabel-variabel ini sesuai dengan waktu perhitungan predikat. </p><br><p>  Misalnya, untuk fungsi <code>constexpr</code> , variabel lokal tidak dapat dirujuk kecuali mereka diketahui pada waktu kompilasi. </p><br><p>  <a href="">contoh</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: a &lt;</span></span>= n ]] <span class="hljs-comment"><span class="hljs-comment">// error: `a` is not constexpr [[ expects: n &lt; b ]] // OK { [[assert: n &gt; 2*a]]; // error: `a` is not constexpr [[assert: n &lt; 2*b]]; // OK return 2*n; }</span></span></code> </pre> <br><h3 id="kontrakty-dlya-ukazateley-na-funkciyu">  Kontrak untuk pointer fungsi </h3><br><p>  Anda tidak dapat menentukan kontrak untuk pointer fungsi, tetapi Anda dapat menetapkan alamat fungsi yang kontraknya didefinisikan untuk pointer fungsi. </p><br><p>  <a href="">contoh</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects: n &lt; 10]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*pfoo)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) = &amp;foo;</code> </pre> <br><p>  Memanggil <code>pfoo(100)</code> akan melanggar kontrak. </p><br><h3 id="kontrakty-pri-nasledovanii">  Kontrak Warisan </h3><br><p>  Implementasi klasik dari konsep kontrak menunjukkan bahwa prasyarat dapat dilemahkan dalam subkelas, postkondisi dan invarian dapat diperkuat dalam subkelas. </p><br><p>  Dalam implementasi C ++ 20, ini tidak terjadi. </p><br><p>  Pertama, invarian di C ++ 20 adalah bagian dari implementasi, bukan antarmuka.  Karena alasan ini, mereka dapat diperkuat dan dilemahkan.  Jika tidak ada <code>assert</code> dalam implementasi fungsi virtual, maka itu tidak akan diwarisi. </p><br><p>  Kedua, diperlukan bahwa ketika mewarisi fungsi identik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ODR</a> . <br>  Dan, karena prasyarat dan postkondisi adalah bagian dari antarmuka, maka dalam pewarisnya mereka harus sama persis. </p><br><p>  Selain itu, deskripsi prasyarat dan postkondisi selama pewarisan dapat dihilangkan.  Tetapi jika mereka dideklarasikan, maka mereka harus benar-benar cocok dengan definisi di kelas dasar. </p><br><p>  <a href="">contoh</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[ expects: n &lt; 10 ]] [[ ensures r: r &gt; 100 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived1</span></span></span><span class="hljs-class"> :</span></span> Base { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> override [[ expects: n &lt; 10 ]] [[ ensures r: r &gt; 100 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n*<span class="hljs-number"><span class="hljs-number">2</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived2</span></span></span><span class="hljs-class"> :</span></span> Base { <span class="hljs-comment"><span class="hljs-comment">// Inherits contracts from Base virtual int foo(int n) override { return n*3; } };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text"><p>  Sayangnya, contoh di atas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak berfungsi</a> di kompiler eksperimental seperti yang diharapkan. </p><br><p>  Jika <code>foo</code> dari <code>Derived2</code> kontrak, maka itu tidak akan diwarisi dari kelas dasar.  Selain itu, kompiler memungkinkan Anda untuk menentukan subkelas kontrak yang tidak cocok dengan kontrak dasar. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesalahan</a> kompilator eksperimental lain: </p><br><p>  catatan harus benar secara sintaksis </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> override [[expects: n &lt; 10]] </span></span>{...}</code> </pre> <br><p>  Namun, dalam formulir ini, saya menerima kesalahan kompilasi </p><br><pre> <code class="bash hljs">inheritance1.cpp:20:36: error: expected <span class="hljs-string"><span class="hljs-string">';'</span></span> at end of declaration list virtual int foo(int n) override ^ ;</code> </pre> <br><p>  dan harus diganti oleh </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects: n &lt; 10]] override </span></span>{...}</code> </pre> <br><p>  Saya pikir ini disebabkan oleh kekhasan kompiler eksperimental, dan kode yang benar sintaks akan bekerja di versi rilis kompiler. </p></div></div><br><h3 id="modifikatory-kontraktov">  Pengubah kontrak </h3><br><p>  Cek predikat kontrak dapat menimbulkan biaya pemrosesan tambahan. <br>  Oleh karena itu, praktik umum adalah memeriksa kontrak dalam pengembangan dan menguji build dan mengabaikannya dalam rilis build. </p><br><p>  Untuk tujuan ini, standar menawarkan tiga tingkat pengubah kontrak.  Menggunakan pengubah dan kunci kompiler, programmer dapat mengontrol kontak mana yang diperiksa dalam perakitan dan yang diabaikan. </p><br><ul><li>  <code>default</code> - pengubah ini digunakan secara default.  Diasumsikan bahwa biaya komputasi untuk memverifikasi eksekusi ekspresi dengan pengubah ini <em>kecil</em> dibandingkan dengan biaya komputasi fungsi itu sendiri. </li><li>  <code>audit</code> - pengubah ini mengasumsikan bahwa biaya komputasi untuk memverifikasi eksekusi suatu ekspresi adalah <em>signifikan</em> dibandingkan dengan biaya komputasi fungsi itu sendiri. </li><li>  <code>axiom</code> - pengubah ini digunakan jika ekspresi adalah deklaratif.  Tidak dicentang saat runtime.  Berfungsi untuk mendokumentasikan antarmuka suatu fungsi, untuk digunakan oleh analisis statis dan pengoptimal kompiler.  Ekspresi dengan pengubah <code>axiom</code> pernah dievaluasi saat runtime. </li></ul><br><p>  Contoh </p><br><pre> <code class="cpp hljs">[[expects: expr]] <span class="hljs-comment"><span class="hljs-comment">//  default [[expects default: expr]] //  default [[expects axiom : expr]] // Run-time    [[expects audit : expr]] //   </span></span></code> </pre> <br><p>  Dengan menggunakan pengubah, Anda dapat menentukan cek mana versi rakitan Anda akan digunakan dan yang akan dinonaktifkan. </p><br><p>  Perlu dicatat bahwa meskipun pemeriksaan tidak dilakukan, kompiler memiliki hak untuk menggunakan kontrak untuk optimasi tingkat rendah.  Meskipun verifikasi kontrak dapat dinonaktifkan oleh flag kompilasi, pelanggaran kontrak menyebabkan perilaku program yang tidak ditentukan. </p><br><p>  Atas kebijakan kompiler, fasilitas dapat disediakan untuk memungkinkan <code>axiom</code> ekspresi yang ditandai sebagai <code>axiom</code> . </p><br><p>  Dalam kasus kami, ini adalah opsi kompiler </p><br><pre> <code class="plaintext hljs">-axiom-mode=&lt;mode&gt;</code> </pre> <br><p>  <code>-axiom-mode=on</code> aksioma dan, karenanya, <em>mematikan</em> verifikasi klaim dengan <code>axiom</code> pengidentifikasi, </p><br><p>  <code>-axiom-mode=off</code> <em>mematikan</em> mode aksioma dan, karenanya, <em>memungkinkan</em> verifikasi pernyataan dengan <code>axiom</code> pengidentifikasi. </p><br><p>  <a href="">contoh</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> [[expects axiom: n &lt; 10]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; }</code> </pre><br><p>  Suatu program dapat dikompilasi dengan tiga tingkat verifikasi yang berbeda: </p><br><ul><li>  <code>off</code> mematikan semua pemeriksaan ekspresi dalam kontrak </li><li>  ekspresi hanya <code>default</code> dengan pengubah <code>default</code> diperiksa </li><li>  <code>audit</code> mode lanjutan saat semua pemeriksaan dilakukan dengan pengubah <code>default</code> dan <code>audit</code> </li></ul><br><p>  Bagaimana tepatnya menerapkan instalasi tingkat verifikasi adalah pada kebijaksanaan pengembang kompiler. </p><br><p>  Dalam kasus kami, opsi kompiler digunakan untuk ini </p><br><pre> <code class="bash hljs">-build-level=&lt;off|default|audit&gt;</code> </pre> <br><p>  Standarnya adalah <code>-build-level=default</code> </p><br><p>  Seperti yang telah disebutkan, kompiler dapat menggunakan kontrak untuk optimasi tingkat rendah.  Karena alasan ini, terlepas dari kenyataan bahwa pada saat pelaksanaan beberapa predikat dalam kontrak (tergantung pada tingkat verifikasi) mungkin tidak dihitung, ketidakpatuhannya mengarah pada perilaku yang tidak terdefinisi. </p><br><p>  Saya akan menunda contoh penerapan level perakitan hingga bagian berikutnya, di mana mereka dapat dibuat visual. </p><br><h3 id="perehvat-narusheniya-kontrakta">  Intersepsi pelanggaran kontrak </h3><br><p>  Bergantung pada opsi apa yang akan dilakukan oleh program, jika terjadi pelanggaran kontrak mungkin ada skenario perilaku yang berbeda. </p><br><p>  Secara default, pelanggaran kontrak menyebabkan program mogok, memanggil <code>std::terminate()</code> .  Tetapi programmer dapat mengesampingkan perilaku ini dengan menyediakan penangannya sendiri dan menunjukkan kepada kompiler bahwa perlu untuk melanjutkan program setelah pelanggaran kontrak. </p><br><p>  Pada kompilasi, Anda dapat menginstal <em>handler pelanggaran</em> , yang disebut ketika kontrak dilanggar. </p><br><p>  Cara untuk mengimplementasikan instalasi pawang adalah atas kebijaksanaan pembuat kompiler. </p><br><p>  Dalam kasus kami, ini </p><br><pre> <code class="bash hljs">-contract-violation-handler=&lt;violation_handler&gt;</code> </pre> <br><p>  Tanda tangan prosesor seharusnya </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::contract_violation&amp; info)</code> </pre> <br><p>  atau </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::contract_violation&amp; info) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span></code> </pre> <br><p>  <code>std::contract_violation</code> setara dengan definisi berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">contract_violation</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint_least32_t</span></span> line_number() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">string_view </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertion_level</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; };</code> </pre> <br><p>  Dengan demikian, pawang memungkinkan Anda untuk mendapatkan informasi yang cukup komprehensif tentang di mana dan dalam kondisi apa pelanggaran kontrak terjadi. </p><br><p>  Jika <em>handler handler pelanggaran</em> ditentukan, maka dalam kasus pelanggaran kontrak, secara default, <code>std::abort()</code> akan dipanggil segera setelah eksekusi (tanpa menentukan handler, <code>std::terminate()</code> akan dipanggil). </p><br><p>  Standar ini mengasumsikan bahwa kompiler menyediakan alat yang memungkinkan pemrogram untuk terus menjalankan suatu program setelah pelanggaran kontrak. </p><br><p>  Cara untuk mengimplementasikan alat-alat ini diserahkan kepada kebijaksanaan pengembang kompiler. <br>  Dalam kasus kami, ini adalah opsi kompiler </p><br><pre> <code class="bash hljs">-fcontinue-after-violation</code> </pre> <br><p>  Opsi <code>-fcontinue-after-violation</code> dan <code>-contract-violation-handler</code> dapat diatur secara independen satu sama lain.  Misalnya, Anda dapat mengatur <code>-fcontinue-after-violation</code> , tetapi tidak mengatur <code>-contract-violation-handler</code> .  Dalam kasus terakhir, setelah pelanggaran kontrak, program hanya akan terus bekerja. </p><br><p>  Kemampuan untuk melanjutkan program setelah pelanggaran kontrak ditentukan oleh standar, tetapi harus diperhatikan dengan fitur ini. </p><br><p>  Secara teknis, perilaku suatu program setelah pelanggaran kontrak tidak didefinisikan, bahkan jika programmer secara eksplisit menunjukkan bahwa program tersebut harus terus bekerja. </p><br><p>  Ini karena kompiler dapat melakukan optimasi tingkat rendah berdasarkan pada eksekusi kontrak. </p><br><p>  Idealnya, jika terjadi pelanggaran kontrak, Anda perlu mencatat informasi diagnostik sesegera mungkin dan menghentikan program.  Anda perlu memahami apa yang Anda lakukan dengan membiarkan program bekerja setelah pelanggaran. </p><br><p>  Tentukan <a href="">pawang Anda</a> dan gunakan untuk mencegat pelanggaran kontrak </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">violation_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::contract_violation&amp; info)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"line_number : "</span></span> &lt;&lt; info.line_number() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"file_name : "</span></span> &lt;&lt; info.file_name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"function_name : "</span></span> &lt;&lt; info.function_name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"comment : "</span></span> &lt;&lt; info.comment() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"assertion_level : "</span></span> &lt;&lt; info.assertion_level() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Dan pertimbangkan <a href="">contoh</a> pelanggaran kontrak: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"violation_handler.h"</span></span></span><span class="hljs-meta"> int foo(int n) [[expects: n &lt; 10]] { return n*n; } int main() { foo(100); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;-- contract violation return 0; }</span></span></span></span></code> </pre> <br><p>  Kami mengkompilasi program dengan opsi <code>-contract-violation-handler=violation_handler</code> dan <code>-fcontinue-after-violation</code> dan jalankan </p><br><pre> <code class="bash hljs">$ bin/example8-handling.bin line_number : 4 file_name : example8-handling.cpp function_name : foo comment : n &lt; 10 assertion_level : default</code> </pre> <br><p>  Sekarang kita dapat memberikan contoh yang menunjukkan perilaku program jika terjadi pelanggaran kontrak di berbagai tingkat perakitan dan mode kontrak. </p><br><p>  Perhatikan <a href="">contoh</a> berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"violation_handler.h"</span></span></span><span class="hljs-meta"> int foo(int n) [[ expects axiom : n &lt; 100 ]] [[ expects default : n &lt; 200 ]] [[ expects audit : n &lt; 300 ]] { return 2 * n; } int main() { foo(350); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// audit foo(250); // default return 0; }</span></span></span></span></code> </pre> <br><p>  Jika Anda membangunnya dengan opsi <code>-build-level=off</code> , maka seperti yang diharapkan, kontrak tidak akan diperiksa. </p><br><p>  Berkumpul dengan level <code>default</code> (dengan opsi <code>-build-level=default</code> ), kita mendapatkan output berikut: </p><br><pre> <code class="bash hljs">$ bin/example9-default.bin line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default</code> </pre> <br><p>  Dan majelis dengan tingkat <code>audit</code> akan memberikan: </p><br><pre> <code class="bash hljs"> $ bin/example9-audit.bin line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default line_number : 6 file_name : example9.cpp function_name : foo comment : n &lt; 300 assertion_level : audit line_number : 5 file_name : example9.cpp function_name : foo comment : n &lt; 200 assertion_level : default</code> </pre> <br><h4 id="zamechaniya">  Komentar </h4><br><p>  <code>violation_handler</code> dapat melempar pengecualian.  Dalam hal ini, Anda dapat mengonfigurasi program sehingga pelanggaran kontrak menyebabkan pelemparan pengecualian. </p><br><p>  Jika fungsi yang dijelaskan kontrak ditandai sebagai <code>noexcept</code> dan ketika memeriksa kontrak <code>violation_handler</code> dipanggil, yang melempar pengecualian, maka <code>std::terminate()</code> akan dipanggil. </p><br><p>  <a href="">Contoh</a> </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">violation_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::contract_violation&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> [[ expects: n &gt; 0 ]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n*n; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;-- std::terminate() when violation handler throws an exception return 0; }</span></span></code> </pre> <br><p>  Jika flag diteruskan ke kompiler: jangan melanjutkan menjalankan program setelah melanggar kontrak ( <code>continuation mode=off</code> ), tetapi penangan pelanggaran melempar pengecualian, maka <code>std::terminate()</code> akan dipaksa. </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Kontrak terkait dengan pemeriksaan runtime non-intrusif.  Mereka memainkan peran yang sangat penting dalam memastikan kualitas perangkat lunak yang dirilis. </p><br><p>  C ++ digunakan sangat luas.  Dan pasti akan ada jumlah klaim yang cukup untuk spesifikasi kontrak.  Menurut pendapat subjektif saya, implementasinya ternyata cukup nyaman dan visual. </p><br><p>  Kontrak C ++ 20 akan membuat program kami lebih andal, cepat, dan mudah dipahami.  Saya menantikan implementasinya dalam kompiler. </p><br><hr><br><p>  PS <br>  Dalam PM, mereka memberi tahu saya bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mungkin</a> dalam versi final dari standar <code>expects</code> dan <code>ensures</code> akan digantikan oleh masing-masing <code>pre</code> dan <code>post</code> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443766/">https://habr.com/ru/post/id443766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443752/index.html">Kotlin sebagai masa depan pengembangan aplikasi Android</a></li>
<li><a href="../id443754/index.html">Tentang kesesuaian Selenium WebDriverWait</a></li>
<li><a href="../id443756/index.html">Desain Kelas: Apa yang Baik?</a></li>
<li><a href="../id443758/index.html">Pengenalan Cepat Menggambar Doodle: Cara Mencari Teman R, C ++, dan Neural Grids</a></li>
<li><a href="../id443764/index.html">Apa yang dihisap perancang: senjata api yang tidak biasa</a></li>
<li><a href="../id443768/index.html">Monolith untuk ratusan versi klien: cara kami menulis dan memelihara tes</a></li>
<li><a href="../id443770/index.html">Desain Berbasis Domain: Objek Nilai dan Kerangka Entitas Inti dalam Praktek</a></li>
<li><a href="../id443772/index.html">Antiquities: IBM ThinkPad T40, nirkabel pertama</a></li>
<li><a href="../id443774/index.html">Bagaimana Neurobiologi Mengganggu Pemilihan Presiden AS</a></li>
<li><a href="../id443776/index.html">Tiongkok memperkenalkan sistem pengenalan wajah eksperimental saat membayar metro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>