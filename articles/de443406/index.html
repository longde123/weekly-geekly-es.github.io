<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèø üîä üèÆ Top 20 Fehler bei der Arbeit mit Multithreading in C ++ und M√∂glichkeiten, sie zu vermeiden üëÇüèª üïü üöò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich mache Sie auf eine √úbersetzung des Artikels ‚ÄûTop 20 C ++ - Multithreading-Fehler und wie man sie vermeidet‚Äú von Deb Haldar aufmerksam....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 20 Fehler bei der Arbeit mit Multithreading in C ++ und M√∂glichkeiten, sie zu vermeiden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443406/">  Hallo Habr!  Ich mache Sie auf eine √úbersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûTop 20 C ++ - Multithreading-Fehler und wie man sie vermeidet‚Äú</a> von Deb Haldar aufmerksam. <br><br><img src="https://habrastorage.org/webt/wi/a8/4v/wia84vtxrf1vqym4rwoynnvtfw0.jpeg" title="KDPV.  Szene aus dem Film ‚ÄûDie Schleife der Zeit (2012)‚Äú"><br>  <i>Szene aus dem Film ‚ÄûThe Loop of Time‚Äú (2012)</i> <br><br>  Multithreading ist einer der schwierigsten Bereiche in der Programmierung, insbesondere in C ++.  Im Laufe der Jahre der Entwicklung habe ich viele Fehler gemacht.  Gl√ºcklicherweise wurden die meisten von ihnen durch √úberpr√ºfungscode und Tests identifiziert.  Trotzdem sind einige irgendwie auf die Produktivit√§t gerutscht, und wir mussten die Betriebssysteme bearbeiten, was immer teuer ist. <br><br>  In diesem Artikel habe ich versucht, alle mir bekannten Fehler mit m√∂glichen L√∂sungen zu kategorisieren.  Wenn Sie andere Fallstricke kennen oder Vorschl√§ge zur Behebung der beschriebenen Fehler haben, hinterlassen Sie bitte Ihre Kommentare unter dem Artikel. <br><a name="habracut"></a><br><h3>  Fehler Nr. 1: Verwenden Sie join () nicht, um auf Hintergrundthreads zu warten, bevor Sie die Anwendung beenden </h3><br>  Wenn Sie vergessen, dem Stream <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beizutreten</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">join ()</a> ) oder ihn zu trennen (trennen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">()</a> ) (nicht zu verbinden), bevor das Programm beendet wird, f√ºhrt dies zum Absturz.  (Die √úbersetzung enth√§lt die W√∂rter "join" im Kontext von " <i>join")</i> und " <i>separ"</i> im Kontext von " <i>attach ()"</i> , obwohl dies nicht ganz korrekt ist. Tats√§chlich ist " <i>join ()"</i> der Punkt, an dem ein Ausf√ºhrungsthread auf den Abschluss eines anderen wartet und kein Verbinden oder Zusammenf√ºhren von Threads erfolgt [Kommentar√ºbersetzer]). <br><br>  Im folgenden Beispiel haben wir vergessen, <i>join () von</i> Thread t1 im Hauptthread auszuf√ºhren: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//t1.join(); //     join-     </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Warum ist das Programm abgest√ºrzt ?!  Da am Ende der Funktion <i>main ()</i> die Variable t1 den G√ºltigkeitsbereich verlassen hat und der Thread-Destruktor aufgerufen wurde.  Der Destruktor pr√ºft, ob der Thread t1 <i>verbunden werden kann</i> .  Ein Thread kann <i>verbunden werden,</i> wenn er nicht getrennt wurde.  In diesem Fall wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: terminate</a> in seinem Destruktor aufgerufen.  Folgendes macht beispielsweise der MSVC ++ - Compiler. <br><br> <code>~thread <font color="#008000">(</font> <font color="#008000">)</font> _NOEXCEPT <br> <font color="#008000">{</font> <font color="#666666">// clean up</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> joinable <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> XSTD terminate <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Je nach Aufgabe gibt es zwei M√∂glichkeiten, das Problem zu beheben: <br><br>  1. Rufen Sie <i>join () von</i> Thread t1 im Hauptthread auf: <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//  join  t1,        </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  2. Trennen Sie den Stream t1 vom Hauptstream und lassen Sie ihn weiterhin als "d√§monisierten" Stream arbeiten: <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   t1   </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Fehler Nr. 2: Es wurde versucht, einen zuvor gel√∂sten Thread anzuh√§ngen </h3><br>  Wenn Sie irgendwann in der Arbeit des Programms einen getrennten Stream haben, k√∂nnen Sie ihn nicht wieder an den Haupt-Stream anh√§ngen.  Dies ist ein sehr offensichtlicher Fehler.  Das Problem ist, dass Sie den Stream entfernen und dann einige hundert Codezeilen schreiben und versuchen k√∂nnen, ihn erneut anzuh√§ngen.  Wer erinnert sich denn daran, dass er 300 Zeilen zur√ºckgeschrieben hat? <br><br>  Das Problem ist, dass dies keinen Kompilierungsfehler verursacht, sondern das Programm beim Start abst√ºrzt.  Zum Beispiel: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">// CRASH !!!</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Die L√∂sung besteht darin, den Thread immer auf <i>joinable ()</i> zu √ºberpr√ºfen, bevor Sie versuchen, ihn an den aufrufenden Thread anzuh√§ngen. <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> t1. <font color="#007788">joinable</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  Fehler Nr. 3: Missverst√§ndnis, dass std :: thread :: join () den aufrufenden Ausf√ºhrungsthread blockiert </h3><br>  In realen Anwendungen m√ºssen Sie h√§ufig ‚Äûlangwierige‚Äú Vorg√§nge bei der Verarbeitung von Netzwerk-E / A trennen oder darauf warten, dass ein Benutzer auf eine Schaltfl√§che usw. klickt.  Ein Aufruf von <i>join ()</i> f√ºr solche Workflows (z. B. der UI-Rendering-Thread) kann dazu f√ºhren, dass die Benutzeroberfl√§che h√§ngen bleibt.  Es gibt geeignetere Implementierungsmethoden. <br><br>  Beispielsweise kann in GUI-Anwendungen ein Arbeitsthread nach Abschluss eine Nachricht an den UI-Thread senden.  Der UI-Stream verf√ºgt √ºber eine eigene Ereignisverarbeitungsschleife, z. B.: Bewegen der Maus, Dr√ºcken von Tasten usw.  Diese Schleife kann auch Nachrichten von Arbeitsthreads empfangen und darauf antworten, ohne die blockierende <i>join ()</i> -Methode aufrufen zu m√ºssen. <br><br>  Aus diesem Grund werden fast alle Benutzerinteraktionen in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WinRT-</a> Plattform von Microsoft asynchronisiert, und synchrone Alternativen sind nicht verf√ºgbar.  Diese Entscheidungen wurden getroffen, um sicherzustellen, dass Entwickler die API verwenden, die die bestm√∂gliche Endbenutzererfahrung bietet.  Weitere Informationen zu diesem Thema finden Sie im Handbuch ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moderne C ++ - und Windows Store-Apps</a> ‚Äú. <br><br><h3>  Fehler Nr. 4: Angenommen, Stream-Funktionsargumente werden standardm√§√üig als Referenz √ºbergeben </h3><br>  Die Argumente an die Stream-Funktion werden standardm√§√üig als Wert √ºbergeben.  Wenn Sie √Ñnderungen an den √ºbergebenen Argumenten vornehmen m√ºssen, m√ºssen Sie diese mithilfe der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: ref () als</a> Referenz √ºbergeben. <br><br>  Unter dem Spoiler finden Sie Beispiele aus einem anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ 11-Artikel zum Multithreading-Tutorial √ºber Fragen und Antworten - Grundlagen der Thread-Verwaltung (Deb Haldar)</a> , in dem die Parameter√ºbergabe [ca.  √úbersetzer]. <br><br><div class="spoiler">  <b class="spoiler_title">Weitere Details:</b> <div class="spoiler_text">  Bei der Ausf√ºhrung des Codes: <br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, targetCity <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Es wird im Terminal angezeigt: <br> <code>Changing The Target City To Metropolis <br> Current Target City is Star City</code> <br> <br>  Wie Sie sehen k√∂nnen, hat sich der Wert der <i>targetCity-</i> Variablen, die von der im Stream als Referenz aufgerufenen Funktion empfangen wurde, nicht ge√§ndert. <br><br>  Schreiben Sie den Code mit <i>std :: ref () neu</i> , um das Argument zu √ºbergeben: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, std <font color="#008080">::</font> <font color="#007788">ref</font> <font color="#008000">(</font> targetCity <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Es wird ausgegeben: <br> <code>Changing The Target City To Metropolis <br> Current Target City is Metropolis</code> <br> <br>  Im neuen Thread vorgenommene √Ñnderungen wirken sich auf den Wert der in der <i>Hauptfunktion</i> deklarierten und initialisierten <i>targetCity-</i> Variablen aus. <br></div></div><br><h3>  Fehler Nr. 5: Sch√ºtzen Sie gemeinsam genutzte Daten und Ressourcen nicht mit einem kritischen Abschnitt (z. B. einem Mutex). </h3><br>  In einer Umgebung mit mehreren Threads konkurrieren normalerweise mehr als ein Thread um Ressourcen und gemeinsam genutzte Daten.  Dies f√ºhrt h√§ufig zu einem unsicheren Zustand f√ºr Ressourcen und Daten, es sei denn, der Zugriff auf diese Ressourcen ist durch einen Mechanismus gesch√ºtzt, der es nur einem Ausf√ºhrungsthread erm√∂glicht, Operationen an ihnen gleichzeitig auszuf√ºhren. <br><br>  Im folgenden Beispiel ist <i>std :: cout</i> eine gemeinsam genutzte Ressource, mit der 6 Threads arbeiten (t1-t5 + main). <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t3 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Moon"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> CallHome <font color="#008000">(</font> <font color="#FF0000">"Hello from Main/Earth"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> thread t4 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Uranus"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t5 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Neptune"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t3. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t4. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t5. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Wenn wir dieses Programm ausf√ºhren, erhalten wir die Schlussfolgerung: <br><br> <code>Thread 0x1000fb5c0 says Hello from Main/Earth <br> Thread Thread Thread 0x700005bd20000x700005b4f000 says says Thread Thread Hello from Pluto0x700005c55000Hello from Jupiter says 0x700005d5b000Hello from Moon <br> 0x700005cd8000 says says Hello from Uranus <br> <br> Hello from Neptune <br></code> <br><br>  Dies liegt daran, dass f√ºnf Threads gleichzeitig in zuf√§lliger Reihenfolge auf den Ausgabestream zugreifen.  Um die Schlussfolgerung genauer zu formulieren, m√ºssen Sie den Zugriff auf die gemeinsam genutzte Ressource mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: mutex</a> sch√ºtzen.  √Ñndern Sie einfach die <i>CallHome ()</i> -Funktion so, dass der Mutex vor der Verwendung von <i>std :: cout</i> erfasst und anschlie√üend freigegeben wird. <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Fehler Nr. 6: Vergessen Sie, die Sperre nach dem Verlassen des kritischen Abschnitts aufzuheben </h3><br>  Im vorherigen Absatz haben Sie gesehen, wie Sie einen kritischen Abschnitt mit einem Mutex sch√ºtzen.  Das Aufrufen der Methoden <i>lock ()</i> und <i>entsperren ()</i> direkt im Mutex ist jedoch nicht die bevorzugte Option, da Sie m√∂glicherweise vergessen haben, die gehaltene Sperre anzugeben.  Was wird als n√§chstes passieren?  Alle anderen Threads, die auf die Freigabe der Ressource warten, werden unendlich blockiert und das Programm kann h√§ngen bleiben. <br><br>  Wenn Sie in unserem synthetischen Beispiel vergessen haben, den Mutex im Funktionsaufruf <i>CallHome ()</i> zu entsperren, wird die erste Nachricht von Stream t1 an den Standard-Stream ausgegeben und das Programm st√ºrzt ab.  Dies liegt an der Tatsache, dass der Thread t1 eine Mutex-Sperre erhalten hat und die verbleibenden Threads darauf warten, dass diese Sperre aufgehoben wird. <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#666666">//mu.unlock();     </font> <br> <font color="#008000">}</font></code> <br> <br>  Das Folgende ist die Ausgabe dieses Codes: Das Programm st√ºrzte ab, zeigte die einzige Meldung im Terminal an und wurde nicht beendet: <br><br> <code>Thread 0x700005986000 says Hello from Pluto <br> <br></code> <br><br>  Solche Fehler treten h√§ufig auf, weshalb es unerw√ºnscht ist, die Methoden <i>lock () / entsperren ()</i> direkt aus dem Mutex heraus zu verwenden.  Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stattdessen die</a> Vorlagenklasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: lock_guard</a> , die das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RAII-</a> Idiom verwendet, um die Lebensdauer der Sperre zu steuern.  Wenn das Objekt <i>lock_guard</i> erstellt wird, versucht es, den Mutex zu √ºbernehmen.  Wenn das Programm den Bereich des Objekts <i>lock_guard</i> verl√§sst, wird der Destruktor aufgerufen, wodurch der Mutex <i>freigegeben</i> wird. <br><br>  Wir schreiben die <i>CallHome () -</i> Funktion mit dem Objekt <i>std :: lock_guard neu</i> : <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   </font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#666666">//  lock_guard    </font></code> <br> <br><h3>  Fehler Nr. 7: Machen Sie den kritischen Abschnitt gr√∂√üer als n√∂tig </h3><br>  Wenn ein Thread innerhalb eines kritischen Abschnitts ausgef√ºhrt wird, werden alle anderen, die versuchen, ihn einzugeben, im Wesentlichen blockiert.  Wir sollten im kritischen Abschnitt so wenig Anweisungen wie m√∂glich aufbewahren.  Zur Veranschaulichung wird ein Beispiel f√ºr fehlerhaften Code mit einem gro√üen kritischen Abschnitt angegeben: <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//    lock_guard    mu </font></code> <br> <br>  Die <i>ReadFifyThousandRecords ()</i> -Methode √§ndert keine Daten.  Es gibt keinen Grund, es unter Verschluss auszuf√ºhren.  Wenn diese Methode 10 Sekunden lang ausgef√ºhrt wird und 50.000 Zeilen aus der Datenbank gelesen werden, werden alle anderen Threads f√ºr diesen gesamten Zeitraum unn√∂tig blockiert.  Dies kann die Programmleistung ernsthaft beeintr√§chtigen. <br><br>  Die richtige L√∂sung w√§re, im kritischen Bereich nur mit <i>std :: cout zu arbeiten</i> . <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//         ..    </font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//     lock_guard    mu </font></code> <br> <br><h3>  Fehler Nr. 8: Mehrere Sperren in einer anderen Reihenfolge </h3><br><br>  Dies ist eine der h√§ufigsten Ursachen f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deadlocks</a> . In dieser Situation werden Threads unendlich blockiert, da auf den Zugriff auf Ressourcen gewartet wird, die von anderen Threads blockiert werden.  Betrachten Sie ein Beispiel: <br><br><table><tbody><tr><th>  Stream 1 </th><th>  Stream 2 </th></tr><tr><td>  Schloss A. </td><td>  Schloss B. </td></tr><tr><td>  // ... einige Operationen </td><td>  // ... einige Operationen </td></tr><tr><td>  Schloss B. </td><td>  Schloss A. </td></tr><tr><td>  // ... einige andere Operationen </td><td>  // ... einige andere Operationen </td></tr><tr><td>  entsperren B. </td><td>  entsperren A. </td></tr><tr><td>  entsperren A. </td><td>  entsperren B. </td></tr></tbody></table><br>  Es kann vorkommen, dass Thread 1 versucht, Sperre B zu erfassen und blockiert wird, weil Thread 2 sie bereits erfasst hat.  Gleichzeitig versucht der zweite Thread, Sperre A zu erfassen, kann dies jedoch nicht, da er vom ersten Thread erfasst wurde.  Thread 1 kann die Verriegelung A erst l√∂sen, wenn sie B usw. verriegelt.  Mit anderen Worten, das Programm friert ein. <br><br>  Dieses Codebeispiel hilft Ihnen bei der Reproduktion von <i>Deadlocks</i> : <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muA <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muB <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th1 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//  - </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th2 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">// -  </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome_Th1, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome_Th2, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Wenn Sie diesen Code ausf√ºhren, st√ºrzt er ab.  Wenn Sie tiefer in den Debugger im Thread-Fenster einsteigen, werden Sie sehen, dass der erste Thread (aufgerufen von <i>CallHome_Th1 ()</i> ) versucht, Mutex B zu sperren, w√§hrend Thread 2 (aufgerufen von <i>CallHome_Th2 ()</i> ) versucht, Mutex A zu blockieren. Keiner der Threads kann nicht erfolgreich sein, was zu einem Deadlock f√ºhrt! <br><br> <a href=""><img src="https://habrastorage.org/webt/ud/kf/a5/udkfa53cvuh8xsrn8lljglb09fa.png"></a> <br>  (das Bild ist anklickbar) <br><br>  Was k√∂nnen Sie dagegen tun?  Die beste L√∂sung w√§re, den Code so umzustrukturieren, dass Sperren jedes Mal in derselben Reihenfolge auftreten. <br><br>  Je nach Situation k√∂nnen Sie andere Strategien anwenden: <br><br>  1. Verwenden Sie die Wrapper- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse std :: scoped_lock</a> , um mehrere Sperren gemeinsam zu erfassen: <br><br> <code>std <font color="#008080">::</font> <font color="#007788">scoped_lock</font> lock <font color="#008000">{</font> muA, muB <font color="#008000">}</font> <font color="#008080">;</font></code> <br> <br>  2. Verwenden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse std :: timed_mutex</a> , in der Sie ein Zeitlimit angeben k√∂nnen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Danach wird</a> die Sperre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgehoben</a> , wenn die Ressource nicht verf√ºgbar ist. <br><br> <code>std <font color="#008080">::</font> <font color="#007788">timed_mutex</font> m <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> DoSome <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> timeout <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> m. <font color="#007788">try_lock_for</font> <font color="#008000">(</font> timeout <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": acquire mutex successfully"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> m. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#0000ff">else</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": can't  acquire mutex, do something else"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Fehler Nr. 9: Ich habe zweimal versucht, eine std :: mutex-Sperre zu ergreifen </h3><br>  Der Versuch, die Sperre zweimal zu sperren, f√ºhrt zu undefiniertem Verhalten.  In den meisten Debug-Implementierungen st√ºrzt dies ab.  Im folgenden Code <i>sperrt LaunchRocket () beispielsweise</i> den Mutex und ruft dann <i>StartThruster () auf</i> .  Was merkw√ºrdig ist, im obigen Code wird dieses Problem w√§hrend des normalen Betriebs des Programms nicht auftreten. Das Problem tritt nur auf, wenn eine Ausnahme ausgel√∂st wird, die von undefiniertem Verhalten begleitet wird oder das Programm abnormal beendet wird. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">int</font> counter <font color="#000080">=</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#666666">// - </font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching rocket"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Um dieses Problem zu beheben, m√ºssen Sie den Code so korrigieren, dass das erneute Abrufen zuvor empfangener Sperren verhindert wird.  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: recursive_mutex</a> als Kr√ºckenl√∂sung verwenden, aber eine solche L√∂sung weist fast immer auf eine schlechte Architektur des Programms hin. <br><br><h3>  Fehler Nr. 10: Verwenden Sie Mutexe, wenn std :: atomic-Typen ausreichen </h3><br><br>  Wenn Sie einfache Datentypen wie einen Booleschen Wert oder einen Ganzzahlz√§hler √§ndern m√ºssen, bietet die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std: atomic</a> im Allgemeinen eine bessere Leistung als die Verwendung von Mutexen. <br><br>  Zum Beispiel, anstatt das folgende Konstrukt zu verwenden: <br><br> <code><font color="#0000ff">int</font> counter <font color="#008080">;</font> <br> ... <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br></code> <br><br>  Es ist besser, eine Variable als <i>std :: atomic</i> zu deklarieren: <br><br> <code>std <font color="#008080">::</font> <font color="#007788">atomic</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> counter <font color="#008080">;</font> <br> ... <br> <font color="#007788">counter</font> <font color="#000040">++</font> <font color="#008080">;</font></code> <br> <br>  Einen detaillierten Vergleich von Mutex und Atom finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich: Lockless-Programmierung mit Atomics in C ++ 11 vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mutex- und RW-Schl√∂sser ¬ª</a> <br><br><h3>  Fehler Nr. 11: Erstellen und zerst√∂ren Sie eine gro√üe Anzahl von Threads direkt, anstatt einen Pool freier Threads zu verwenden </h3><br>  Das Erstellen und Zerst√∂ren von Threads ist in Bezug auf die Prozessorzeit ein teurer Vorgang.  Stellen Sie sich einen Versuch vor, einen Stream zu erstellen, w√§hrend das System rechenintensive Operationen ausf√ºhrt, z. B. das Rendern von Grafiken oder das Berechnen von Spielphysik.  Der h√§ufig f√ºr solche Aufgaben verwendete Ansatz besteht darin, einen Pool vorab zugewiesener Threads zu erstellen, die Routineaufgaben wie das Schreiben auf die Festplatte oder das Senden von Daten √ºber das Netzwerk w√§hrend des gesamten Lebenszyklus des Prozesses ausf√ºhren k√∂nnen. <br><br>  Ein weiterer Vorteil des Thread-Pools gegen√ºber dem Laichen und Zerst√∂ren von Threads selbst besteht darin, dass Sie sich keine Gedanken √ºber eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberbelegung</a> von Threads machen m√ºssen (eine Situation, in der die Anzahl der Threads die Anzahl der verf√ºgbaren Kerne √ºberschreitet und ein erheblicher Teil der Prozessorzeit f√ºr das Wechseln von Kontexten aufgewendet wird [ca. √úbersetzer]).  Dies kann die Systemleistung beeintr√§chtigen. <br><br>  Dar√ºber hinaus erspart uns die Verwendung des Pools die Probleme bei der Verwaltung des Lebenszyklus von Threads, was sich letztendlich in kompakterem Code mit weniger Fehlern niederschl√§gt. <br><br>  Die beiden beliebtesten Bibliotheken, die den Thread-Pool implementieren, sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel Thread Building Blocks (TBB)</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Parallel Patterns Library (PPL)</a> . <br><br><h3>  Fehler Nr. 12: Behandeln Sie keine Ausnahmen, die in Hintergrundthreads auftreten </h3><br>  Ausnahmen, die in einem Thread ausgel√∂st werden, k√∂nnen nicht in einem anderen Thread behandelt werden.  Stellen wir uns vor, wir haben eine Funktion, die eine Ausnahme ausl√∂st.  Wenn wir diese Funktion in einem separaten Thread ausf√ºhren, der vom Hauptthread der Ausf√ºhrung abzweigt, und erwarten, dass wir eine vom zus√§tzlichen Thread ausgel√∂ste Ausnahme abfangen, funktioniert dies nicht.  Betrachten Sie ein Beispiel: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> teptr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Wenn dieses Programm ausgef√ºhrt wird, st√ºrzt es ab. Der catch-Block in der Funktion main () wird jedoch nicht ausgef√ºhrt und behandelt die im Thread t1 ausgel√∂ste Ausnahme nicht. <br><br>  Die L√∂sung f√ºr dieses Problem besteht darin, die Funktionen von C ++ 11 zu verwenden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: exception_ptr</a> wird verwendet, um die im Hintergrundthread ausgel√∂ste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausnahme</a> zu behandeln.  Hier sind die Schritte, die Sie unternehmen m√ºssen: <br><br><ul><li>  Erstellen Sie eine globale Instanz der Klasse <i>std :: exception_ptr</i> , die mit <i>nullptr</i> initialisiert wurde </li><li>  Behandeln Sie in einer Funktion, die in einem separaten Thread ausgef√ºhrt wird, alle Ausnahmen und legen Sie den Wert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: current_exception () der</a> im vorherigen Schritt deklarierten globalen Variablen <i>std :: exception_ptr fest</i> </li><li>  √úberpr√ºfen Sie den Wert einer globalen Variablen im Hauptthread </li><li>  Wenn der Wert festgelegt ist, rufen Sie mit der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: rethrow_exception (exception_ptr p)</a> die zuvor abgefangene Ausnahme wiederholt auf und √ºbergeben Sie sie als Referenz als Parameter </li></ul><br>  Das Abrufen einer Ausnahme als Referenz tritt in dem Thread, in dem sie erstellt wurde, nicht auf. Daher eignet sich diese Funktion hervorragend zum Behandeln von Ausnahmen in verschiedenen Threads. <br><br>  Im folgenden Code k√∂nnen Sie die im Hintergrund-Thread ausgel√∂ste Ausnahme sicher behandeln. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> globalExceptionPtr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> globalExceptionPtr <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">current_exception</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">rethrow_exception</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  Fehler Nr. 13: Verwenden Sie Threads, um den asynchronen Betrieb zu simulieren, anstatt std :: async zu verwenden </h3><br>  Wenn Sie den Code zur asynchronen Ausf√ºhrung ben√∂tigen, d. H.  Ohne den Hauptthread der Ausf√ºhrung zu blockieren, w√§re die beste Wahl die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: async ()</a> .  Dies entspricht dem Erstellen eines Streams und dem √úbergeben des erforderlichen Codes zur Ausf√ºhrung in diesem Stream √ºber einen Zeiger auf eine Funktion oder einen Parameter in Form einer Lambda-Funktion.  Im letzteren Fall m√ºssen Sie jedoch die Erstellung, das Anh√§ngen / Entfernen dieses Threads sowie die Behandlung aller Ausnahmen √ºberwachen, die in diesem Thread auftreten k√∂nnen.  Wenn Sie <i>std :: async () verwenden</i> , entlasten Sie sich von diesen Problemen und verringern die Wahrscheinlichkeit, in einen <i>Deadlock</i> zu <i>geraten</i> , <i>erheblich</i> . <br><br>  Ein weiterer wesentlicher Vorteil der Verwendung von <i>std :: async</i> ist die M√∂glichkeit, das Ergebnis einer asynchronen Operation mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: future-</a> Objekts an den aufrufenden Thread zur√ºckzugeben.  Stellen Sie sich vor, wir haben eine <i>ConjureMagic ()</i> -Funktion, die ein int zur√ºckgibt.  Wir k√∂nnen eine asynchrone Operation starten, die den Wert in Zukunft auf das <i>zuk√ºnftige</i> Objekt setzt, wenn die Aufgabe abgeschlossen ist, und wir k√∂nnen das Ergebnis der Ausf√ºhrung aus diesem Objekt in dem Ausf√ºhrungsfluss extrahieren, aus dem die Operation aufgerufen wurde. <br><br> <code><font color="#666666">//        future</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> asyncResult2 <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> <font color="#000040">&amp;</font> ConjureMagic <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//...  -   future   </font> <br> <br> <font color="#666666">//     future</font> <br> <font color="#0000ff">int</font> v <font color="#000080">=</font> asyncResult2. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Das Zur√ºckholen des Ergebnisses vom laufenden Thread zum Aufrufer ist umst√§ndlicher.  Zwei M√∂glichkeiten sind m√∂glich: <br><br><ol><li>  √úbergeben eines Verweises auf die Ausgabevariable an den Stream, in dem das Ergebnis gespeichert wird. </li><li>  Speichern Sie das Ergebnis in der Feldvariablen des Workflow-Objekts, die gelesen werden kann, sobald der Thread die Ausf√ºhrung abgeschlossen hat. </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurt Guntheroth stellte</a> fest, dass der Aufwand f√ºr die Erstellung eines Streams in Bezug auf die Leistung 14-mal so <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hoch</a> ist wie f√ºr die Verwendung von <i>Async</i> . <br><br>  Fazit: Verwenden Sie standardm√§√üig <i>std :: async (),</i> bis Sie starke Argumente f√ºr die direkte Verwendung von <i>std :: thread finden</i> . <br><br><h3>  Fehler Nr. 14: Verwenden Sie std :: launch :: async nicht, wenn Asynchronit√§t erforderlich ist </h3><br>  Die Funktion <i>std :: async ()</i> ist nicht ganz der richtige Name, da sie standardm√§√üig m√∂glicherweise nicht asynchron ausgef√ºhrt wird! <br><br>  Es gibt zwei <i>std :: async-</i> Laufzeitrichtlinien: <br><br><ol><li>  <i>std :: launch :: async</i> : Die √ºbergebene Funktion wird sofort in einem separaten Thread ausgef√ºhrt </li><li>  <i>std :: launch :: deferred</i> : Die √ºbergebene Funktion wird nicht sofort gestartet. Der Start wird verz√∂gert, bevor die Aufrufe <i>get ()</i> oder <i>wait ()</i> f√ºr das Objekt <i>std :: future ausgef√ºhrt</i> werden, das vom Aufruf <i>std :: async zur√ºckgegeben wird</i> .  Anstelle des Aufrufs dieser Methoden wird die Funktion synchron ausgef√ºhrt. </li></ol><br>  Wenn wir <i>std :: async ()</i> mit Standardparametern aufrufen, beginnt dies mit einer Kombination dieser beiden Parameter, was tats√§chlich zu unvorhersehbarem Verhalten f√ºhrt.  Es gibt eine Reihe anderer Schwierigkeiten bei der Verwendung von <i>std: async ()</i> mit der Standardstartrichtlinie: <br><br><ul><li>  Unf√§higkeit, den korrekten Zugriff auf lokale Flussvariablen vorherzusagen </li><li>  Eine asynchrone Task wird m√∂glicherweise √ºberhaupt nicht gestartet, da w√§hrend der Programmausf√ºhrung m√∂glicherweise keine Aufrufe der Methoden <i>get ()</i> und <i>wait ()</i> aufgerufen werden </li><li>  Bei Verwendung in Schleifen, in denen die Exit-Bedingung erwartet, dass das Objekt std :: future bereit ist, werden diese Schleifen m√∂glicherweise nie beendet, da die vom Aufruf von std :: async zur√ºckgegebene std :: future m√∂glicherweise im verz√∂gerten Zustand beginnt. </li></ul><br>  Um all diese Schwierigkeiten zu vermeiden, rufen Sie <i>std :: async immer</i> mit der <i>Startrichtlinie std :: launch :: async</i> auf. <br><br>  Mach das nicht: <br><br> <code><font color="#666666">//  myFunction  std::async     </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Tun Sie stattdessen Folgendes: <br><br> <code><font color="#666666">//  myFunction </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Dieser Punkt wird in dem Buch von Scott Meyers ‚ÄûEffective and Modern C ++‚Äú ausf√ºhrlicher behandelt. <br><br><h3>  Fehler Nr. 15: Aufruf der Methode get () eines std :: future-Objekts in einem Codeblock, dessen Ausf√ºhrungszeit kritisch ist </h3><br>  Der folgende Code verarbeitet das Ergebnis, das vom <i>std :: future-</i> Objekt einer asynchronen Operation erhalten wurde.  Die <i>while-Schleife</i> wird jedoch gesperrt, bis der asynchrone Vorgang abgeschlossen ist (in diesem Fall 10 Sekunden lang).  Wenn Sie diese Schleife verwenden m√∂chten, um Informationen auf dem Bildschirm anzuzeigen, kann dies zu unangenehmen Verz√∂gerungen beim Rendern der Benutzeroberfl√§che f√ºhren. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <font color="#666666">//  -   Val</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  <b>Hinweis</b> : Ein weiteres Problem des obigen Codes besteht darin, dass versucht wird, ein zweites Mal auf das <i>std :: future-</i> Objekt zuzugreifen, obwohl der Status des <i>std :: future-</i> Objekts bei der ersten Iteration der Schleife abgerufen wurde und nicht abgerufen werden konnte. <br><br>  Die richtige L√∂sung w√§re, die G√ºltigkeit des <i>std :: future-</i> Objekts zu √ºberpr√ºfen, bevor Sie die <i>get ()</i> -Methode aufrufen.  Daher blockieren wir nicht den Abschluss der asynchronen Task und versuchen nicht, das bereits extrahierte <i>std :: future-</i> Objekt <i>abzufragen</i> . <br><br>  Mit diesem Code-Snippet k√∂nnen Sie Folgendes erreichen: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <br> <font color="#666666">//   -   Val</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  ‚Ññ16:  ,  ,    ,        std::future::get() </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich vor, wir haben das folgende Codefragment. Was ist Ihrer Meinung nach das Ergebnis des Aufrufs von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: future :: get ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">Wenn Sie davon ausgehen, dass das Programm abst√ºrzt, haben Sie absolut Recht! </font><font style="vertical-align: inherit;">Die in der asynchronen Operation ausgel√∂ste Ausnahme wird nur ausgel√∂st, wenn die Methode </font><i><font style="vertical-align: inherit;">get ()</font></i><font style="vertical-align: inherit;"> f√ºr das </font><i><font style="vertical-align: inherit;">Objekt std :: future</font></i><font style="vertical-align: inherit;"> aufgerufen wird </font><font style="vertical-align: inherit;">. Und wenn die Methode </font><i><font style="vertical-align: inherit;">get ()</font></i><font style="vertical-align: inherit;"> nicht aufgerufen wird, wird die Ausnahme ignoriert und ausgel√∂st, wenn das </font><font style="vertical-align: inherit;">Objekt </font><i><font style="vertical-align: inherit;">std :: future den</font></i><font style="vertical-align: inherit;"> G√ºltigkeitsbereich verl√§sst. </font><font style="vertical-align: inherit;">Wenn Ihre asynchrone Operation eine Ausnahme ausl√∂sen kann, sollten Sie den Aufruf von </font><i><font style="vertical-align: inherit;">std :: future :: get () immer</font></i><font style="vertical-align: inherit;"> in einen </font><i><font style="vertical-align: inherit;">try / catch-</font></i><font style="vertical-align: inherit;"> Block einschlie√üen. Ein Beispiel daf√ºr, wie dies aussehen k√∂nnte:</font></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#000040">&amp;</font> e <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Async task threw exception: "</font> <font color="#000080">&lt;&lt;</font> e. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  ‚Ññ17:  std::async,        </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: async ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den meisten F√§llen ausreicht, gibt es Situationen, in denen Sie m√∂glicherweise eine sorgf√§ltige Kontrolle √ºber die Ausf√ºhrung Ihres Codes in einem Stream ben√∂tigen. Zum Beispiel, wenn Sie einen bestimmten Thread an einen bestimmten Prozessorkern in einem Multiprozessorsystem (z. B. Xbox) binden m√∂chten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das angegebene Codefragment stellt die Bindung des Threads an den 5. Prozessorkern im System her. </font><font style="vertical-align: inherit;">Dies ist m√∂glich dank der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">native_handle ()</font></a><font style="vertical-align: inherit;"> -Methode des </font><i><font style="vertical-align: inherit;">std :: thread-</font></i><font style="vertical-align: inherit;"> Objekts </font><font style="vertical-align: inherit;">und der √úbergabe an die </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Win32-API-</font></a><font style="vertical-align: inherit;"> Stream-Funktion </font><font style="vertical-align: inherit;">. Es gibt viele andere Funktionen, die √ºber die Streaming-Win32-API bereitgestellt werden und in </font><i><font style="vertical-align: inherit;">std :: thread</font></i><font style="vertical-align: inherit;"> oder </font><i><font style="vertical-align: inherit;">std :: async ()</font></i><font style="vertical-align: inherit;"> nicht verf√ºgbar sind </font><font style="vertical-align: inherit;">. Beim Durcharbeiten</font></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;windows.h&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> DWORD result <font color="#000080">=</font> <font color="#008080">::</font> <font color="#007788">SetThreadIdealProcessor</font> <font color="#008000">(</font> t1. <font color="#007788">native_handle</font> <font color="#008000">(</font> <font color="#008000">)</font> , <font color="#0000dd">5</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: async () sind</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese grundlegenden Plattformfunktionen nicht verf√ºgbar, weshalb diese Methode f√ºr komplexere Aufgaben ungeeignet ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Alternative besteht darin, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: packaged_task</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu erstellen </font><font style="vertical-align: inherit;">und nach dem Festlegen der Eigenschaften des Threads in den gew√ºnschten Ausf√ºhrungsthread zu verschieben.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler Nr. 18: Es sind viel mehr "laufende" Threads als Kerne verf√ºgbar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus architektonischer Sicht k√∂nnen Fl√ºsse in zwei Gruppen eingeteilt werden: "Laufen" und "Warten". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ausf√ºhren von Threads nutzt 100% der Prozessorzeit des Kernels, auf dem sie ausgef√ºhrt werden. Wenn einem Kern mehr als ein laufender Thread zugeordnet ist, sinkt die Effizienz der CPU-Auslastung. Wir erzielen keinen Leistungsgewinn, wenn wir mehr als einen laufenden Thread auf einem Prozessorkern ausf√ºhren. In Wirklichkeit sinkt die Leistung aufgrund zus√§tzlicher Kontextwechsel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wartende Threads verwenden nur wenige Taktzyklen, in denen sie ausgef√ºhrt werden, w√§hrend sie auf Systemereignisse oder Netzwerk-E / A usw. warten. In diesem Fall bleibt der gr√∂√üte Teil der verf√ºgbaren Prozessorzeit des Kernels ungenutzt. Ein wartender Thread kann Daten verarbeiten, w√§hrend die anderen auf das Ausl√∂sen von Ereignissen warten. Aus diesem Grund ist es vorteilhaft, mehrere wartende Threads auf einen einzelnen Kern zu verteilen. Durch das Planen mehrerer ausstehender Threads pro Kern kann die Programmleistung erheblich gesteigert werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann man also verstehen, wie viele laufende Threads das System unterst√ºtzt? Verwenden Sie die Methode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: thread :: hardware_concurrency ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Funktion gibt normalerweise die Anzahl der Prozessorkerne zur√ºck, ber√ºcksichtigt jedoch Kerne, die sich aufgrund von zwei oder mehr logischen Kernen verhalten</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hypertreading</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen den erhaltenen Wert der Zielplattform verwenden, um die maximale Anzahl gleichzeitig laufender Threads Ihres Programms zu planen. Sie k√∂nnen auch einen Kern f√ºr alle ausstehenden Threads zuweisen und die verbleibende Anzahl von Kernen zum Ausf√ºhren von Threads verwenden. Verwenden Sie in einem Quad-Core-System beispielsweise einen Kern f√ºr ALLE ausstehenden Threads und f√ºr die verbleibenden drei Kerne drei laufende Threads. Abh√§ngig von der Effizienz Ihres Thread-Schedulers k√∂nnen einige Ihrer ausf√ºhrbaren Threads den Kontext wechseln (aufgrund von Fehlern beim Seitenzugriff usw.), wodurch der Kernel f√ºr einige Zeit inaktiv bleibt. Wenn Sie diese Situation w√§hrend der Profilerstellung beobachten, sollten Sie eine etwas gr√∂√üere Anzahl von auszuf√ºhrenden Threads als die Anzahl der Kerne erstellen und diesen Wert f√ºr Ihr System konfigurieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler Nr. 19: Verwenden des fl√ºchtigen Schl√ºsselworts f√ºr die Synchronisation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Schl√ºsselwort </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fl√ºchtig</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">bevor der Typ einer Variablen angegeben wird, macht Operationen f√ºr diese Variable nicht atomar oder threadsicher. </font><font style="vertical-align: inherit;">Was Sie wahrscheinlich wollen, ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: atomic</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Weitere Informationen finden </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie in der Diskussion zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stackoverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler Nr. 20: Verwenden der sperrenfreien Architektur, sofern dies nicht unbedingt erforderlich ist </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt etwas in der Komplexit√§t, das jeder Ingenieur mag. Das Erstellen sperrfreier Programme klingt im Vergleich zu regul√§ren Synchronisationsmechanismen wie Mutex, bedingten Variablen, Asynchronit√§t usw. sehr verlockend. Allerdings hatte jeder erfahrene C ++ - Entwickler, mit dem ich gesprochen habe, eine Meinung dass die Verwendung der nicht sperrenden Programmierung als anf√§ngliche Option eine Art vorzeitige Optimierung ist, die im ung√ºnstigsten Moment seitw√§rts gehen kann (denken Sie an einen Fehler in einem Betriebssystem, wenn Sie keinen vollst√§ndigen Heap-Dump haben!).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In meiner Karriere in C ++ gab es nur eine Situation, in der Code ohne Sperren ausgef√ºhrt werden musste, da wir in einem System mit begrenzten Ressourcen arbeiteten, in dem jede Transaktion in unserer Komponente nicht l√§nger als 10 Mikrosekunden dauern sollte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor Sie √ºber die Anwendung eines Entwicklungsansatzes ohne Blockierung nachdenken, beantworten Sie bitte drei Fragen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haben Sie versucht, die Architektur Ihres Systems so zu gestalten, dass kein Synchronisationsmechanismus erforderlich ist? </font><font style="vertical-align: inherit;">Die beste Synchronisation ist in der Regel das Fehlen einer Synchronisation.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine Synchronisierung ben√∂tigen, haben Sie Ihren Code profiliert, um die Leistungsmerkmale zu verstehen? </font><font style="vertical-align: inherit;">Wenn ja, haben Sie versucht, Engp√§sse zu optimieren?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> K√∂nnen Sie horizontal statt vertikal skalieren? </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassend l√§sst sich sagen, dass Sie f√ºr eine normale Anwendungsentwicklung eine nicht sperrende Programmierung nur in Betracht ziehen sollten, wenn Sie alle anderen Alternativen ausgesch√∂pft haben. </font><font style="vertical-align: inherit;">Eine andere M√∂glichkeit, dies zu betrachten, besteht darin, dass Sie sich wahrscheinlich von der Programmierung fernhalten sollten, ohne zu blockieren, wenn Sie immer noch einige der oben genannten 19 Fehler machen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Von. </font><font style="vertical-align: inherit;">√úbersetzer: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dank an </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;">vovo4K</font></a><font style="vertical-align: inherit;"> f√ºr die Unterst√ºtzung bei der Vorbereitung dieses Artikels.]</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443406/">https://habr.com/ru/post/de443406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443396/index.html">3D-Druck und Airsoft: Wie ich "Laufwerk" gedruckt habe</a></li>
<li><a href="../de443398/index.html">Implementierung von ERP in Industrieunternehmen: Alevtina Svetozarovna und Excel gegen harte Architekten und die englische Fabrik</a></li>
<li><a href="../de443400/index.html">Z√§hlen von Fehlern im Windows-Rechner</a></li>
<li><a href="../de443402/index.html">So machen Sie Code√ºberpr√ºfungen schneller und effizienter</a></li>
<li><a href="../de443404/index.html">Das neue Ziel der NASA f√ºr die Suche nach au√üerirdischen Zivilisationen: technologische Zeichen</a></li>
<li><a href="../de443408/index.html">Photonen, Quanten und Fock-Zustand: Manipulationen auf Quantenebene mit einem Hochfrequenzresonator</a></li>
<li><a href="../de443412/index.html">Warum Programmierer weiterhin ausf√ºhrliches Java verwenden, obwohl es pr√§gnantes Python gibt</a></li>
<li><a href="../de443414/index.html">Wegweiser: Wenn Haltepunkte nicht ausreichen</a></li>
<li><a href="../de443416/index.html">Winnti: ein Angriff auf Lieferketten - asiatische Spieleentwickler stehen an vorderster Front</a></li>
<li><a href="../de443418/index.html">Software-Testmethoden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>