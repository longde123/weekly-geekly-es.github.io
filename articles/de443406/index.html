<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏿 🔊 🏮 Top 20 Fehler bei der Arbeit mit Multithreading in C ++ und Möglichkeiten, sie zu vermeiden 👂🏻 🕟 🚘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich mache Sie auf eine Übersetzung des Artikels „Top 20 C ++ - Multithreading-Fehler und wie man sie vermeidet“ von Deb Haldar aufmerksam....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 20 Fehler bei der Arbeit mit Multithreading in C ++ und Möglichkeiten, sie zu vermeiden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443406/">  Hallo Habr!  Ich mache Sie auf eine Übersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Top 20 C ++ - Multithreading-Fehler und wie man sie vermeidet“</a> von Deb Haldar aufmerksam. <br><br><img src="https://habrastorage.org/webt/wi/a8/4v/wia84vtxrf1vqym4rwoynnvtfw0.jpeg" title="KDPV.  Szene aus dem Film „Die Schleife der Zeit (2012)“"><br>  <i>Szene aus dem Film „The Loop of Time“ (2012)</i> <br><br>  Multithreading ist einer der schwierigsten Bereiche in der Programmierung, insbesondere in C ++.  Im Laufe der Jahre der Entwicklung habe ich viele Fehler gemacht.  Glücklicherweise wurden die meisten von ihnen durch Überprüfungscode und Tests identifiziert.  Trotzdem sind einige irgendwie auf die Produktivität gerutscht, und wir mussten die Betriebssysteme bearbeiten, was immer teuer ist. <br><br>  In diesem Artikel habe ich versucht, alle mir bekannten Fehler mit möglichen Lösungen zu kategorisieren.  Wenn Sie andere Fallstricke kennen oder Vorschläge zur Behebung der beschriebenen Fehler haben, hinterlassen Sie bitte Ihre Kommentare unter dem Artikel. <br><a name="habracut"></a><br><h3>  Fehler Nr. 1: Verwenden Sie join () nicht, um auf Hintergrundthreads zu warten, bevor Sie die Anwendung beenden </h3><br>  Wenn Sie vergessen, dem Stream <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beizutreten</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">join ()</a> ) oder ihn zu trennen (trennen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">()</a> ) (nicht zu verbinden), bevor das Programm beendet wird, führt dies zum Absturz.  (Die Übersetzung enthält die Wörter "join" im Kontext von " <i>join")</i> und " <i>separ"</i> im Kontext von " <i>attach ()"</i> , obwohl dies nicht ganz korrekt ist. Tatsächlich ist " <i>join ()"</i> der Punkt, an dem ein Ausführungsthread auf den Abschluss eines anderen wartet und kein Verbinden oder Zusammenführen von Threads erfolgt [Kommentarübersetzer]). <br><br>  Im folgenden Beispiel haben wir vergessen, <i>join () von</i> Thread t1 im Hauptthread auszuführen: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//t1.join(); //     join-     </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Warum ist das Programm abgestürzt ?!  Da am Ende der Funktion <i>main ()</i> die Variable t1 den Gültigkeitsbereich verlassen hat und der Thread-Destruktor aufgerufen wurde.  Der Destruktor prüft, ob der Thread t1 <i>verbunden werden kann</i> .  Ein Thread kann <i>verbunden werden,</i> wenn er nicht getrennt wurde.  In diesem Fall wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: terminate</a> in seinem Destruktor aufgerufen.  Folgendes macht beispielsweise der MSVC ++ - Compiler. <br><br> <code>~thread <font color="#008000">(</font> <font color="#008000">)</font> _NOEXCEPT <br> <font color="#008000">{</font> <font color="#666666">// clean up</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> joinable <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> XSTD terminate <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Je nach Aufgabe gibt es zwei Möglichkeiten, das Problem zu beheben: <br><br>  1. Rufen Sie <i>join () von</i> Thread t1 im Hauptthread auf: <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//  join  t1,        </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  2. Trennen Sie den Stream t1 vom Hauptstream und lassen Sie ihn weiterhin als "dämonisierten" Stream arbeiten: <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   t1   </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Fehler Nr. 2: Es wurde versucht, einen zuvor gelösten Thread anzuhängen </h3><br>  Wenn Sie irgendwann in der Arbeit des Programms einen getrennten Stream haben, können Sie ihn nicht wieder an den Haupt-Stream anhängen.  Dies ist ein sehr offensichtlicher Fehler.  Das Problem ist, dass Sie den Stream entfernen und dann einige hundert Codezeilen schreiben und versuchen können, ihn erneut anzuhängen.  Wer erinnert sich denn daran, dass er 300 Zeilen zurückgeschrieben hat? <br><br>  Das Problem ist, dass dies keinen Kompilierungsfehler verursacht, sondern das Programm beim Start abstürzt.  Zum Beispiel: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">// CRASH !!!</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Die Lösung besteht darin, den Thread immer auf <i>joinable ()</i> zu überprüfen, bevor Sie versuchen, ihn an den aufrufenden Thread anzuhängen. <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> t1. <font color="#007788">joinable</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  Fehler Nr. 3: Missverständnis, dass std :: thread :: join () den aufrufenden Ausführungsthread blockiert </h3><br>  In realen Anwendungen müssen Sie häufig „langwierige“ Vorgänge bei der Verarbeitung von Netzwerk-E / A trennen oder darauf warten, dass ein Benutzer auf eine Schaltfläche usw. klickt.  Ein Aufruf von <i>join ()</i> für solche Workflows (z. B. der UI-Rendering-Thread) kann dazu führen, dass die Benutzeroberfläche hängen bleibt.  Es gibt geeignetere Implementierungsmethoden. <br><br>  Beispielsweise kann in GUI-Anwendungen ein Arbeitsthread nach Abschluss eine Nachricht an den UI-Thread senden.  Der UI-Stream verfügt über eine eigene Ereignisverarbeitungsschleife, z. B.: Bewegen der Maus, Drücken von Tasten usw.  Diese Schleife kann auch Nachrichten von Arbeitsthreads empfangen und darauf antworten, ohne die blockierende <i>join ()</i> -Methode aufrufen zu müssen. <br><br>  Aus diesem Grund werden fast alle Benutzerinteraktionen in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WinRT-</a> Plattform von Microsoft asynchronisiert, und synchrone Alternativen sind nicht verfügbar.  Diese Entscheidungen wurden getroffen, um sicherzustellen, dass Entwickler die API verwenden, die die bestmögliche Endbenutzererfahrung bietet.  Weitere Informationen zu diesem Thema finden Sie im Handbuch „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moderne C ++ - und Windows Store-Apps</a> “. <br><br><h3>  Fehler Nr. 4: Angenommen, Stream-Funktionsargumente werden standardmäßig als Referenz übergeben </h3><br>  Die Argumente an die Stream-Funktion werden standardmäßig als Wert übergeben.  Wenn Sie Änderungen an den übergebenen Argumenten vornehmen müssen, müssen Sie diese mithilfe der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: ref () als</a> Referenz übergeben. <br><br>  Unter dem Spoiler finden Sie Beispiele aus einem anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ 11-Artikel zum Multithreading-Tutorial über Fragen und Antworten - Grundlagen der Thread-Verwaltung (Deb Haldar)</a> , in dem die Parameterübergabe [ca.  Übersetzer]. <br><br><div class="spoiler">  <b class="spoiler_title">Weitere Details:</b> <div class="spoiler_text">  Bei der Ausführung des Codes: <br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, targetCity <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Es wird im Terminal angezeigt: <br> <code>Changing The Target City To Metropolis <br> Current Target City is Star City</code> <br> <br>  Wie Sie sehen können, hat sich der Wert der <i>targetCity-</i> Variablen, die von der im Stream als Referenz aufgerufenen Funktion empfangen wurde, nicht geändert. <br><br>  Schreiben Sie den Code mit <i>std :: ref () neu</i> , um das Argument zu übergeben: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, std <font color="#008080">::</font> <font color="#007788">ref</font> <font color="#008000">(</font> targetCity <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Es wird ausgegeben: <br> <code>Changing The Target City To Metropolis <br> Current Target City is Metropolis</code> <br> <br>  Im neuen Thread vorgenommene Änderungen wirken sich auf den Wert der in der <i>Hauptfunktion</i> deklarierten und initialisierten <i>targetCity-</i> Variablen aus. <br></div></div><br><h3>  Fehler Nr. 5: Schützen Sie gemeinsam genutzte Daten und Ressourcen nicht mit einem kritischen Abschnitt (z. B. einem Mutex). </h3><br>  In einer Umgebung mit mehreren Threads konkurrieren normalerweise mehr als ein Thread um Ressourcen und gemeinsam genutzte Daten.  Dies führt häufig zu einem unsicheren Zustand für Ressourcen und Daten, es sei denn, der Zugriff auf diese Ressourcen ist durch einen Mechanismus geschützt, der es nur einem Ausführungsthread ermöglicht, Operationen an ihnen gleichzeitig auszuführen. <br><br>  Im folgenden Beispiel ist <i>std :: cout</i> eine gemeinsam genutzte Ressource, mit der 6 Threads arbeiten (t1-t5 + main). <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t3 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Moon"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> CallHome <font color="#008000">(</font> <font color="#FF0000">"Hello from Main/Earth"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> thread t4 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Uranus"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t5 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Neptune"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t3. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t4. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t5. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Wenn wir dieses Programm ausführen, erhalten wir die Schlussfolgerung: <br><br> <code>Thread 0x1000fb5c0 says Hello from Main/Earth <br> Thread Thread Thread 0x700005bd20000x700005b4f000 says says Thread Thread Hello from Pluto0x700005c55000Hello from Jupiter says 0x700005d5b000Hello from Moon <br> 0x700005cd8000 says says Hello from Uranus <br> <br> Hello from Neptune <br></code> <br><br>  Dies liegt daran, dass fünf Threads gleichzeitig in zufälliger Reihenfolge auf den Ausgabestream zugreifen.  Um die Schlussfolgerung genauer zu formulieren, müssen Sie den Zugriff auf die gemeinsam genutzte Ressource mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: mutex</a> schützen.  Ändern Sie einfach die <i>CallHome ()</i> -Funktion so, dass der Mutex vor der Verwendung von <i>std :: cout</i> erfasst und anschließend freigegeben wird. <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Fehler Nr. 6: Vergessen Sie, die Sperre nach dem Verlassen des kritischen Abschnitts aufzuheben </h3><br>  Im vorherigen Absatz haben Sie gesehen, wie Sie einen kritischen Abschnitt mit einem Mutex schützen.  Das Aufrufen der Methoden <i>lock ()</i> und <i>entsperren ()</i> direkt im Mutex ist jedoch nicht die bevorzugte Option, da Sie möglicherweise vergessen haben, die gehaltene Sperre anzugeben.  Was wird als nächstes passieren?  Alle anderen Threads, die auf die Freigabe der Ressource warten, werden unendlich blockiert und das Programm kann hängen bleiben. <br><br>  Wenn Sie in unserem synthetischen Beispiel vergessen haben, den Mutex im Funktionsaufruf <i>CallHome ()</i> zu entsperren, wird die erste Nachricht von Stream t1 an den Standard-Stream ausgegeben und das Programm stürzt ab.  Dies liegt an der Tatsache, dass der Thread t1 eine Mutex-Sperre erhalten hat und die verbleibenden Threads darauf warten, dass diese Sperre aufgehoben wird. <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#666666">//mu.unlock();     </font> <br> <font color="#008000">}</font></code> <br> <br>  Das Folgende ist die Ausgabe dieses Codes: Das Programm stürzte ab, zeigte die einzige Meldung im Terminal an und wurde nicht beendet: <br><br> <code>Thread 0x700005986000 says Hello from Pluto <br> <br></code> <br><br>  Solche Fehler treten häufig auf, weshalb es unerwünscht ist, die Methoden <i>lock () / entsperren ()</i> direkt aus dem Mutex heraus zu verwenden.  Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stattdessen die</a> Vorlagenklasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: lock_guard</a> , die das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RAII-</a> Idiom verwendet, um die Lebensdauer der Sperre zu steuern.  Wenn das Objekt <i>lock_guard</i> erstellt wird, versucht es, den Mutex zu übernehmen.  Wenn das Programm den Bereich des Objekts <i>lock_guard</i> verlässt, wird der Destruktor aufgerufen, wodurch der Mutex <i>freigegeben</i> wird. <br><br>  Wir schreiben die <i>CallHome () -</i> Funktion mit dem Objekt <i>std :: lock_guard neu</i> : <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   </font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#666666">//  lock_guard    </font></code> <br> <br><h3>  Fehler Nr. 7: Machen Sie den kritischen Abschnitt größer als nötig </h3><br>  Wenn ein Thread innerhalb eines kritischen Abschnitts ausgeführt wird, werden alle anderen, die versuchen, ihn einzugeben, im Wesentlichen blockiert.  Wir sollten im kritischen Abschnitt so wenig Anweisungen wie möglich aufbewahren.  Zur Veranschaulichung wird ein Beispiel für fehlerhaften Code mit einem großen kritischen Abschnitt angegeben: <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//    lock_guard    mu </font></code> <br> <br>  Die <i>ReadFifyThousandRecords ()</i> -Methode ändert keine Daten.  Es gibt keinen Grund, es unter Verschluss auszuführen.  Wenn diese Methode 10 Sekunden lang ausgeführt wird und 50.000 Zeilen aus der Datenbank gelesen werden, werden alle anderen Threads für diesen gesamten Zeitraum unnötig blockiert.  Dies kann die Programmleistung ernsthaft beeinträchtigen. <br><br>  Die richtige Lösung wäre, im kritischen Bereich nur mit <i>std :: cout zu arbeiten</i> . <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//         ..    </font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//     lock_guard    mu </font></code> <br> <br><h3>  Fehler Nr. 8: Mehrere Sperren in einer anderen Reihenfolge </h3><br><br>  Dies ist eine der häufigsten Ursachen für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deadlocks</a> . In dieser Situation werden Threads unendlich blockiert, da auf den Zugriff auf Ressourcen gewartet wird, die von anderen Threads blockiert werden.  Betrachten Sie ein Beispiel: <br><br><table><tbody><tr><th>  Stream 1 </th><th>  Stream 2 </th></tr><tr><td>  Schloss A. </td><td>  Schloss B. </td></tr><tr><td>  // ... einige Operationen </td><td>  // ... einige Operationen </td></tr><tr><td>  Schloss B. </td><td>  Schloss A. </td></tr><tr><td>  // ... einige andere Operationen </td><td>  // ... einige andere Operationen </td></tr><tr><td>  entsperren B. </td><td>  entsperren A. </td></tr><tr><td>  entsperren A. </td><td>  entsperren B. </td></tr></tbody></table><br>  Es kann vorkommen, dass Thread 1 versucht, Sperre B zu erfassen und blockiert wird, weil Thread 2 sie bereits erfasst hat.  Gleichzeitig versucht der zweite Thread, Sperre A zu erfassen, kann dies jedoch nicht, da er vom ersten Thread erfasst wurde.  Thread 1 kann die Verriegelung A erst lösen, wenn sie B usw. verriegelt.  Mit anderen Worten, das Programm friert ein. <br><br>  Dieses Codebeispiel hilft Ihnen bei der Reproduktion von <i>Deadlocks</i> : <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muA <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muB <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th1 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//  - </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th2 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">// -  </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome_Th1, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome_Th2, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Wenn Sie diesen Code ausführen, stürzt er ab.  Wenn Sie tiefer in den Debugger im Thread-Fenster einsteigen, werden Sie sehen, dass der erste Thread (aufgerufen von <i>CallHome_Th1 ()</i> ) versucht, Mutex B zu sperren, während Thread 2 (aufgerufen von <i>CallHome_Th2 ()</i> ) versucht, Mutex A zu blockieren. Keiner der Threads kann nicht erfolgreich sein, was zu einem Deadlock führt! <br><br> <a href=""><img src="https://habrastorage.org/webt/ud/kf/a5/udkfa53cvuh8xsrn8lljglb09fa.png"></a> <br>  (das Bild ist anklickbar) <br><br>  Was können Sie dagegen tun?  Die beste Lösung wäre, den Code so umzustrukturieren, dass Sperren jedes Mal in derselben Reihenfolge auftreten. <br><br>  Je nach Situation können Sie andere Strategien anwenden: <br><br>  1. Verwenden Sie die Wrapper- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse std :: scoped_lock</a> , um mehrere Sperren gemeinsam zu erfassen: <br><br> <code>std <font color="#008080">::</font> <font color="#007788">scoped_lock</font> lock <font color="#008000">{</font> muA, muB <font color="#008000">}</font> <font color="#008080">;</font></code> <br> <br>  2. Verwenden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse std :: timed_mutex</a> , in der Sie ein Zeitlimit angeben können. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Danach wird</a> die Sperre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgehoben</a> , wenn die Ressource nicht verfügbar ist. <br><br> <code>std <font color="#008080">::</font> <font color="#007788">timed_mutex</font> m <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> DoSome <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> timeout <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> m. <font color="#007788">try_lock_for</font> <font color="#008000">(</font> timeout <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": acquire mutex successfully"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> m. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#0000ff">else</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": can't  acquire mutex, do something else"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Fehler Nr. 9: Ich habe zweimal versucht, eine std :: mutex-Sperre zu ergreifen </h3><br>  Der Versuch, die Sperre zweimal zu sperren, führt zu undefiniertem Verhalten.  In den meisten Debug-Implementierungen stürzt dies ab.  Im folgenden Code <i>sperrt LaunchRocket () beispielsweise</i> den Mutex und ruft dann <i>StartThruster () auf</i> .  Was merkwürdig ist, im obigen Code wird dieses Problem während des normalen Betriebs des Programms nicht auftreten. Das Problem tritt nur auf, wenn eine Ausnahme ausgelöst wird, die von undefiniertem Verhalten begleitet wird oder das Programm abnormal beendet wird. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">int</font> counter <font color="#000080">=</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#666666">// - </font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching rocket"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Um dieses Problem zu beheben, müssen Sie den Code so korrigieren, dass das erneute Abrufen zuvor empfangener Sperren verhindert wird.  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: recursive_mutex</a> als Krückenlösung verwenden, aber eine solche Lösung weist fast immer auf eine schlechte Architektur des Programms hin. <br><br><h3>  Fehler Nr. 10: Verwenden Sie Mutexe, wenn std :: atomic-Typen ausreichen </h3><br><br>  Wenn Sie einfache Datentypen wie einen Booleschen Wert oder einen Ganzzahlzähler ändern müssen, bietet die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std: atomic</a> im Allgemeinen eine bessere Leistung als die Verwendung von Mutexen. <br><br>  Zum Beispiel, anstatt das folgende Konstrukt zu verwenden: <br><br> <code><font color="#0000ff">int</font> counter <font color="#008080">;</font> <br> ... <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br></code> <br><br>  Es ist besser, eine Variable als <i>std :: atomic</i> zu deklarieren: <br><br> <code>std <font color="#008080">::</font> <font color="#007788">atomic</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> counter <font color="#008080">;</font> <br> ... <br> <font color="#007788">counter</font> <font color="#000040">++</font> <font color="#008080">;</font></code> <br> <br>  Einen detaillierten Vergleich von Mutex und Atom finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich: Lockless-Programmierung mit Atomics in C ++ 11 vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mutex- und RW-Schlösser »</a> <br><br><h3>  Fehler Nr. 11: Erstellen und zerstören Sie eine große Anzahl von Threads direkt, anstatt einen Pool freier Threads zu verwenden </h3><br>  Das Erstellen und Zerstören von Threads ist in Bezug auf die Prozessorzeit ein teurer Vorgang.  Stellen Sie sich einen Versuch vor, einen Stream zu erstellen, während das System rechenintensive Operationen ausführt, z. B. das Rendern von Grafiken oder das Berechnen von Spielphysik.  Der häufig für solche Aufgaben verwendete Ansatz besteht darin, einen Pool vorab zugewiesener Threads zu erstellen, die Routineaufgaben wie das Schreiben auf die Festplatte oder das Senden von Daten über das Netzwerk während des gesamten Lebenszyklus des Prozesses ausführen können. <br><br>  Ein weiterer Vorteil des Thread-Pools gegenüber dem Laichen und Zerstören von Threads selbst besteht darin, dass Sie sich keine Gedanken über eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überbelegung</a> von Threads machen müssen (eine Situation, in der die Anzahl der Threads die Anzahl der verfügbaren Kerne überschreitet und ein erheblicher Teil der Prozessorzeit für das Wechseln von Kontexten aufgewendet wird [ca. Übersetzer]).  Dies kann die Systemleistung beeinträchtigen. <br><br>  Darüber hinaus erspart uns die Verwendung des Pools die Probleme bei der Verwaltung des Lebenszyklus von Threads, was sich letztendlich in kompakterem Code mit weniger Fehlern niederschlägt. <br><br>  Die beiden beliebtesten Bibliotheken, die den Thread-Pool implementieren, sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel Thread Building Blocks (TBB)</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Parallel Patterns Library (PPL)</a> . <br><br><h3>  Fehler Nr. 12: Behandeln Sie keine Ausnahmen, die in Hintergrundthreads auftreten </h3><br>  Ausnahmen, die in einem Thread ausgelöst werden, können nicht in einem anderen Thread behandelt werden.  Stellen wir uns vor, wir haben eine Funktion, die eine Ausnahme auslöst.  Wenn wir diese Funktion in einem separaten Thread ausführen, der vom Hauptthread der Ausführung abzweigt, und erwarten, dass wir eine vom zusätzlichen Thread ausgelöste Ausnahme abfangen, funktioniert dies nicht.  Betrachten Sie ein Beispiel: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> teptr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Wenn dieses Programm ausgeführt wird, stürzt es ab. Der catch-Block in der Funktion main () wird jedoch nicht ausgeführt und behandelt die im Thread t1 ausgelöste Ausnahme nicht. <br><br>  Die Lösung für dieses Problem besteht darin, die Funktionen von C ++ 11 zu verwenden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: exception_ptr</a> wird verwendet, um die im Hintergrundthread ausgelöste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausnahme</a> zu behandeln.  Hier sind die Schritte, die Sie unternehmen müssen: <br><br><ul><li>  Erstellen Sie eine globale Instanz der Klasse <i>std :: exception_ptr</i> , die mit <i>nullptr</i> initialisiert wurde </li><li>  Behandeln Sie in einer Funktion, die in einem separaten Thread ausgeführt wird, alle Ausnahmen und legen Sie den Wert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: current_exception () der</a> im vorherigen Schritt deklarierten globalen Variablen <i>std :: exception_ptr fest</i> </li><li>  Überprüfen Sie den Wert einer globalen Variablen im Hauptthread </li><li>  Wenn der Wert festgelegt ist, rufen Sie mit der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: rethrow_exception (exception_ptr p)</a> die zuvor abgefangene Ausnahme wiederholt auf und übergeben Sie sie als Referenz als Parameter </li></ul><br>  Das Abrufen einer Ausnahme als Referenz tritt in dem Thread, in dem sie erstellt wurde, nicht auf. Daher eignet sich diese Funktion hervorragend zum Behandeln von Ausnahmen in verschiedenen Threads. <br><br>  Im folgenden Code können Sie die im Hintergrund-Thread ausgelöste Ausnahme sicher behandeln. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> globalExceptionPtr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> globalExceptionPtr <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">current_exception</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">rethrow_exception</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  Fehler Nr. 13: Verwenden Sie Threads, um den asynchronen Betrieb zu simulieren, anstatt std :: async zu verwenden </h3><br>  Wenn Sie den Code zur asynchronen Ausführung benötigen, d. H.  Ohne den Hauptthread der Ausführung zu blockieren, wäre die beste Wahl die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: async ()</a> .  Dies entspricht dem Erstellen eines Streams und dem Übergeben des erforderlichen Codes zur Ausführung in diesem Stream über einen Zeiger auf eine Funktion oder einen Parameter in Form einer Lambda-Funktion.  Im letzteren Fall müssen Sie jedoch die Erstellung, das Anhängen / Entfernen dieses Threads sowie die Behandlung aller Ausnahmen überwachen, die in diesem Thread auftreten können.  Wenn Sie <i>std :: async () verwenden</i> , entlasten Sie sich von diesen Problemen und verringern die Wahrscheinlichkeit, in einen <i>Deadlock</i> zu <i>geraten</i> , <i>erheblich</i> . <br><br>  Ein weiterer wesentlicher Vorteil der Verwendung von <i>std :: async</i> ist die Möglichkeit, das Ergebnis einer asynchronen Operation mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: future-</a> Objekts an den aufrufenden Thread zurückzugeben.  Stellen Sie sich vor, wir haben eine <i>ConjureMagic ()</i> -Funktion, die ein int zurückgibt.  Wir können eine asynchrone Operation starten, die den Wert in Zukunft auf das <i>zukünftige</i> Objekt setzt, wenn die Aufgabe abgeschlossen ist, und wir können das Ergebnis der Ausführung aus diesem Objekt in dem Ausführungsfluss extrahieren, aus dem die Operation aufgerufen wurde. <br><br> <code><font color="#666666">//        future</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> asyncResult2 <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> <font color="#000040">&amp;</font> ConjureMagic <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//...  -   future   </font> <br> <br> <font color="#666666">//     future</font> <br> <font color="#0000ff">int</font> v <font color="#000080">=</font> asyncResult2. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Das Zurückholen des Ergebnisses vom laufenden Thread zum Aufrufer ist umständlicher.  Zwei Möglichkeiten sind möglich: <br><br><ol><li>  Übergeben eines Verweises auf die Ausgabevariable an den Stream, in dem das Ergebnis gespeichert wird. </li><li>  Speichern Sie das Ergebnis in der Feldvariablen des Workflow-Objekts, die gelesen werden kann, sobald der Thread die Ausführung abgeschlossen hat. </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurt Guntheroth stellte</a> fest, dass der Aufwand für die Erstellung eines Streams in Bezug auf die Leistung 14-mal so <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hoch</a> ist wie für die Verwendung von <i>Async</i> . <br><br>  Fazit: Verwenden Sie standardmäßig <i>std :: async (),</i> bis Sie starke Argumente für die direkte Verwendung von <i>std :: thread finden</i> . <br><br><h3>  Fehler Nr. 14: Verwenden Sie std :: launch :: async nicht, wenn Asynchronität erforderlich ist </h3><br>  Die Funktion <i>std :: async ()</i> ist nicht ganz der richtige Name, da sie standardmäßig möglicherweise nicht asynchron ausgeführt wird! <br><br>  Es gibt zwei <i>std :: async-</i> Laufzeitrichtlinien: <br><br><ol><li>  <i>std :: launch :: async</i> : Die übergebene Funktion wird sofort in einem separaten Thread ausgeführt </li><li>  <i>std :: launch :: deferred</i> : Die übergebene Funktion wird nicht sofort gestartet. Der Start wird verzögert, bevor die Aufrufe <i>get ()</i> oder <i>wait ()</i> für das Objekt <i>std :: future ausgeführt</i> werden, das vom Aufruf <i>std :: async zurückgegeben wird</i> .  Anstelle des Aufrufs dieser Methoden wird die Funktion synchron ausgeführt. </li></ol><br>  Wenn wir <i>std :: async ()</i> mit Standardparametern aufrufen, beginnt dies mit einer Kombination dieser beiden Parameter, was tatsächlich zu unvorhersehbarem Verhalten führt.  Es gibt eine Reihe anderer Schwierigkeiten bei der Verwendung von <i>std: async ()</i> mit der Standardstartrichtlinie: <br><br><ul><li>  Unfähigkeit, den korrekten Zugriff auf lokale Flussvariablen vorherzusagen </li><li>  Eine asynchrone Task wird möglicherweise überhaupt nicht gestartet, da während der Programmausführung möglicherweise keine Aufrufe der Methoden <i>get ()</i> und <i>wait ()</i> aufgerufen werden </li><li>  Bei Verwendung in Schleifen, in denen die Exit-Bedingung erwartet, dass das Objekt std :: future bereit ist, werden diese Schleifen möglicherweise nie beendet, da die vom Aufruf von std :: async zurückgegebene std :: future möglicherweise im verzögerten Zustand beginnt. </li></ul><br>  Um all diese Schwierigkeiten zu vermeiden, rufen Sie <i>std :: async immer</i> mit der <i>Startrichtlinie std :: launch :: async</i> auf. <br><br>  Mach das nicht: <br><br> <code><font color="#666666">//  myFunction  std::async     </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Tun Sie stattdessen Folgendes: <br><br> <code><font color="#666666">//  myFunction </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Dieser Punkt wird in dem Buch von Scott Meyers „Effective and Modern C ++“ ausführlicher behandelt. <br><br><h3>  Fehler Nr. 15: Aufruf der Methode get () eines std :: future-Objekts in einem Codeblock, dessen Ausführungszeit kritisch ist </h3><br>  Der folgende Code verarbeitet das Ergebnis, das vom <i>std :: future-</i> Objekt einer asynchronen Operation erhalten wurde.  Die <i>while-Schleife</i> wird jedoch gesperrt, bis der asynchrone Vorgang abgeschlossen ist (in diesem Fall 10 Sekunden lang).  Wenn Sie diese Schleife verwenden möchten, um Informationen auf dem Bildschirm anzuzeigen, kann dies zu unangenehmen Verzögerungen beim Rendern der Benutzeroberfläche führen. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <font color="#666666">//  -   Val</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  <b>Hinweis</b> : Ein weiteres Problem des obigen Codes besteht darin, dass versucht wird, ein zweites Mal auf das <i>std :: future-</i> Objekt zuzugreifen, obwohl der Status des <i>std :: future-</i> Objekts bei der ersten Iteration der Schleife abgerufen wurde und nicht abgerufen werden konnte. <br><br>  Die richtige Lösung wäre, die Gültigkeit des <i>std :: future-</i> Objekts zu überprüfen, bevor Sie die <i>get ()</i> -Methode aufrufen.  Daher blockieren wir nicht den Abschluss der asynchronen Task und versuchen nicht, das bereits extrahierte <i>std :: future-</i> Objekt <i>abzufragen</i> . <br><br>  Mit diesem Code-Snippet können Sie Folgendes erreichen: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <br> <font color="#666666">//   -   Val</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  №16:  ,  ,    ,        std::future::get() </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich vor, wir haben das folgende Codefragment. Was ist Ihrer Meinung nach das Ergebnis des Aufrufs von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: future :: get ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">Wenn Sie davon ausgehen, dass das Programm abstürzt, haben Sie absolut Recht! </font><font style="vertical-align: inherit;">Die in der asynchronen Operation ausgelöste Ausnahme wird nur ausgelöst, wenn die Methode </font><i><font style="vertical-align: inherit;">get ()</font></i><font style="vertical-align: inherit;"> für das </font><i><font style="vertical-align: inherit;">Objekt std :: future</font></i><font style="vertical-align: inherit;"> aufgerufen wird </font><font style="vertical-align: inherit;">. Und wenn die Methode </font><i><font style="vertical-align: inherit;">get ()</font></i><font style="vertical-align: inherit;"> nicht aufgerufen wird, wird die Ausnahme ignoriert und ausgelöst, wenn das </font><font style="vertical-align: inherit;">Objekt </font><i><font style="vertical-align: inherit;">std :: future den</font></i><font style="vertical-align: inherit;"> Gültigkeitsbereich verlässt. </font><font style="vertical-align: inherit;">Wenn Ihre asynchrone Operation eine Ausnahme auslösen kann, sollten Sie den Aufruf von </font><i><font style="vertical-align: inherit;">std :: future :: get () immer</font></i><font style="vertical-align: inherit;"> in einen </font><i><font style="vertical-align: inherit;">try / catch-</font></i><font style="vertical-align: inherit;"> Block einschließen. Ein Beispiel dafür, wie dies aussehen könnte:</font></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#000040">&amp;</font> e <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Async task threw exception: "</font> <font color="#000080">&lt;&lt;</font> e. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  №17:  std::async,        </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: async ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den meisten Fällen ausreicht, gibt es Situationen, in denen Sie möglicherweise eine sorgfältige Kontrolle über die Ausführung Ihres Codes in einem Stream benötigen. Zum Beispiel, wenn Sie einen bestimmten Thread an einen bestimmten Prozessorkern in einem Multiprozessorsystem (z. B. Xbox) binden möchten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das angegebene Codefragment stellt die Bindung des Threads an den 5. Prozessorkern im System her. </font><font style="vertical-align: inherit;">Dies ist möglich dank der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">native_handle ()</font></a><font style="vertical-align: inherit;"> -Methode des </font><i><font style="vertical-align: inherit;">std :: thread-</font></i><font style="vertical-align: inherit;"> Objekts </font><font style="vertical-align: inherit;">und der Übergabe an die </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Win32-API-</font></a><font style="vertical-align: inherit;"> Stream-Funktion </font><font style="vertical-align: inherit;">. Es gibt viele andere Funktionen, die über die Streaming-Win32-API bereitgestellt werden und in </font><i><font style="vertical-align: inherit;">std :: thread</font></i><font style="vertical-align: inherit;"> oder </font><i><font style="vertical-align: inherit;">std :: async ()</font></i><font style="vertical-align: inherit;"> nicht verfügbar sind </font><font style="vertical-align: inherit;">. Beim Durcharbeiten</font></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;windows.h&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> DWORD result <font color="#000080">=</font> <font color="#008080">::</font> <font color="#007788">SetThreadIdealProcessor</font> <font color="#008000">(</font> t1. <font color="#007788">native_handle</font> <font color="#008000">(</font> <font color="#008000">)</font> , <font color="#0000dd">5</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: async () sind</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese grundlegenden Plattformfunktionen nicht verfügbar, weshalb diese Methode für komplexere Aufgaben ungeeignet ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Alternative besteht darin, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: packaged_task</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu erstellen </font><font style="vertical-align: inherit;">und nach dem Festlegen der Eigenschaften des Threads in den gewünschten Ausführungsthread zu verschieben.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler Nr. 18: Es sind viel mehr "laufende" Threads als Kerne verfügbar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus architektonischer Sicht können Flüsse in zwei Gruppen eingeteilt werden: "Laufen" und "Warten". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ausführen von Threads nutzt 100% der Prozessorzeit des Kernels, auf dem sie ausgeführt werden. Wenn einem Kern mehr als ein laufender Thread zugeordnet ist, sinkt die Effizienz der CPU-Auslastung. Wir erzielen keinen Leistungsgewinn, wenn wir mehr als einen laufenden Thread auf einem Prozessorkern ausführen. In Wirklichkeit sinkt die Leistung aufgrund zusätzlicher Kontextwechsel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wartende Threads verwenden nur wenige Taktzyklen, in denen sie ausgeführt werden, während sie auf Systemereignisse oder Netzwerk-E / A usw. warten. In diesem Fall bleibt der größte Teil der verfügbaren Prozessorzeit des Kernels ungenutzt. Ein wartender Thread kann Daten verarbeiten, während die anderen auf das Auslösen von Ereignissen warten. Aus diesem Grund ist es vorteilhaft, mehrere wartende Threads auf einen einzelnen Kern zu verteilen. Durch das Planen mehrerer ausstehender Threads pro Kern kann die Programmleistung erheblich gesteigert werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann man also verstehen, wie viele laufende Threads das System unterstützt? Verwenden Sie die Methode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: thread :: hardware_concurrency ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Funktion gibt normalerweise die Anzahl der Prozessorkerne zurück, berücksichtigt jedoch Kerne, die sich aufgrund von zwei oder mehr logischen Kernen verhalten</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hypertreading</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen den erhaltenen Wert der Zielplattform verwenden, um die maximale Anzahl gleichzeitig laufender Threads Ihres Programms zu planen. Sie können auch einen Kern für alle ausstehenden Threads zuweisen und die verbleibende Anzahl von Kernen zum Ausführen von Threads verwenden. Verwenden Sie in einem Quad-Core-System beispielsweise einen Kern für ALLE ausstehenden Threads und für die verbleibenden drei Kerne drei laufende Threads. Abhängig von der Effizienz Ihres Thread-Schedulers können einige Ihrer ausführbaren Threads den Kontext wechseln (aufgrund von Fehlern beim Seitenzugriff usw.), wodurch der Kernel für einige Zeit inaktiv bleibt. Wenn Sie diese Situation während der Profilerstellung beobachten, sollten Sie eine etwas größere Anzahl von auszuführenden Threads als die Anzahl der Kerne erstellen und diesen Wert für Ihr System konfigurieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler Nr. 19: Verwenden des flüchtigen Schlüsselworts für die Synchronisation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Schlüsselwort </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flüchtig</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">bevor der Typ einer Variablen angegeben wird, macht Operationen für diese Variable nicht atomar oder threadsicher. </font><font style="vertical-align: inherit;">Was Sie wahrscheinlich wollen, ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: atomic</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Weitere Informationen finden </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie in der Diskussion zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stackoverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler Nr. 20: Verwenden der sperrenfreien Architektur, sofern dies nicht unbedingt erforderlich ist </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt etwas in der Komplexität, das jeder Ingenieur mag. Das Erstellen sperrfreier Programme klingt im Vergleich zu regulären Synchronisationsmechanismen wie Mutex, bedingten Variablen, Asynchronität usw. sehr verlockend. Allerdings hatte jeder erfahrene C ++ - Entwickler, mit dem ich gesprochen habe, eine Meinung dass die Verwendung der nicht sperrenden Programmierung als anfängliche Option eine Art vorzeitige Optimierung ist, die im ungünstigsten Moment seitwärts gehen kann (denken Sie an einen Fehler in einem Betriebssystem, wenn Sie keinen vollständigen Heap-Dump haben!).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In meiner Karriere in C ++ gab es nur eine Situation, in der Code ohne Sperren ausgeführt werden musste, da wir in einem System mit begrenzten Ressourcen arbeiteten, in dem jede Transaktion in unserer Komponente nicht länger als 10 Mikrosekunden dauern sollte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor Sie über die Anwendung eines Entwicklungsansatzes ohne Blockierung nachdenken, beantworten Sie bitte drei Fragen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haben Sie versucht, die Architektur Ihres Systems so zu gestalten, dass kein Synchronisationsmechanismus erforderlich ist? </font><font style="vertical-align: inherit;">Die beste Synchronisation ist in der Regel das Fehlen einer Synchronisation.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine Synchronisierung benötigen, haben Sie Ihren Code profiliert, um die Leistungsmerkmale zu verstehen? </font><font style="vertical-align: inherit;">Wenn ja, haben Sie versucht, Engpässe zu optimieren?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Können Sie horizontal statt vertikal skalieren? </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassend lässt sich sagen, dass Sie für eine normale Anwendungsentwicklung eine nicht sperrende Programmierung nur in Betracht ziehen sollten, wenn Sie alle anderen Alternativen ausgeschöpft haben. </font><font style="vertical-align: inherit;">Eine andere Möglichkeit, dies zu betrachten, besteht darin, dass Sie sich wahrscheinlich von der Programmierung fernhalten sollten, ohne zu blockieren, wenn Sie immer noch einige der oben genannten 19 Fehler machen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Von. </font><font style="vertical-align: inherit;">Übersetzer: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dank an </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;">vovo4K</font></a><font style="vertical-align: inherit;"> für die Unterstützung bei der Vorbereitung dieses Artikels.]</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443406/">https://habr.com/ru/post/de443406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443396/index.html">3D-Druck und Airsoft: Wie ich "Laufwerk" gedruckt habe</a></li>
<li><a href="../de443398/index.html">Implementierung von ERP in Industrieunternehmen: Alevtina Svetozarovna und Excel gegen harte Architekten und die englische Fabrik</a></li>
<li><a href="../de443400/index.html">Zählen von Fehlern im Windows-Rechner</a></li>
<li><a href="../de443402/index.html">So machen Sie Codeüberprüfungen schneller und effizienter</a></li>
<li><a href="../de443404/index.html">Das neue Ziel der NASA für die Suche nach außerirdischen Zivilisationen: technologische Zeichen</a></li>
<li><a href="../de443408/index.html">Photonen, Quanten und Fock-Zustand: Manipulationen auf Quantenebene mit einem Hochfrequenzresonator</a></li>
<li><a href="../de443412/index.html">Warum Programmierer weiterhin ausführliches Java verwenden, obwohl es prägnantes Python gibt</a></li>
<li><a href="../de443414/index.html">Wegweiser: Wenn Haltepunkte nicht ausreichen</a></li>
<li><a href="../de443416/index.html">Winnti: ein Angriff auf Lieferketten - asiatische Spieleentwickler stehen an vorderster Front</a></li>
<li><a href="../de443418/index.html">Software-Testmethoden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>