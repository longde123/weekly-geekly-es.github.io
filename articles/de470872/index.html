<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•¶ üõ¢Ô∏è üë©üèº‚Äçüç≥ Leistungsmetriken f√ºr die Suche nach unglaublich schnellen Webanwendungen ‚òùüèº üßõüèª üï¥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt ein Sprichwort: "Was Sie nicht messen k√∂nnen, k√∂nnen Sie nicht verbessern." Der Autor des Artikels, dessen √úbersetzung wir heute ver√∂ffentlich...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Leistungsmetriken f√ºr die Suche nach unglaublich schnellen Webanwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470872/">  Es gibt ein Sprichwort: "Was Sie nicht messen k√∂nnen, k√∂nnen Sie nicht verbessern."  Der Autor des Artikels, dessen √úbersetzung wir heute ver√∂ffentlichen, arbeitet f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Superhuman</a> .  Er sagt, dass dieses Unternehmen den schnellsten E-Mail-Client der Welt entwickelt.  Hier werden wir dar√ºber sprechen, was ‚Äûschnell‚Äú ist und wie Tools zur Messung der Leistung unglaublich schneller Webanwendungen erstellt werden. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/q6/af/pp/q6afppxtd4rv6r-iqwvk9-6nyai.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Anwendungsgeschwindigkeitsmessung</font> </h2><br>  Um unsere Entwicklung zu verbessern, haben wir viel Zeit damit verbracht, die Geschwindigkeit zu messen.  Und wie sich herausstellte, sind Leistungsmetriken Indikatoren, die √ºberraschend schwer zu verstehen und anzuwenden sind. <br><br>  Einerseits ist es schwierig, Metriken zu entwerfen, die die Empfindungen, die der Benutzer w√§hrend der Arbeit mit dem System erf√§hrt, genau beschreiben.  Andererseits ist es nicht einfach, Metriken zu erstellen, die so genau sind, dass Sie mit ihrer Analyse fundierte Entscheidungen treffen k√∂nnen.  Infolgedessen k√∂nnen viele Entwicklungsteams den Daten, die sie √ºber die Leistung ihrer Projekte sammeln, nicht vertrauen. <br><br>  Selbst wenn Entwickler √ºber zuverl√§ssige und genaue Metriken verf√ºgen, ist deren Verwendung nicht einfach.  Wie definiere ich den Begriff ‚Äûschnell‚Äú?  Wie finde ich ein Gleichgewicht zwischen Geschwindigkeit und Best√§ndigkeit?  Wie kann man lernen, Leistungseinbu√üen schnell zu erkennen oder die Auswirkungen von Optimierungen auf das System zu bewerten? <br><br>  Hier m√∂chten wir einige Gedanken zur Entwicklung von Tools zur Leistungsanalyse von Webanwendungen teilen. <br><br><h2>  <font color="#3AC1EF">1. Mit der richtigen "Uhr"</font> </h2><br>  JavaScript verf√ºgt √ºber zwei Mechanismen zum Abrufen von Zeitstempeln: <code>performance.now()</code> und <code>new Date()</code> . <br><br>  Wie unterscheiden sie sich?  Die folgenden zwei Unterschiede sind f√ºr uns von grundlegender Bedeutung: <br><br><ul><li>  Die Methode <code>performance.now()</code> ist viel genauer.  Die Genauigkeit des <code>new Date()</code> -Konstrukts betr√§gt ¬± 1 ms, w√§hrend die Genauigkeit von <code>performance.now()</code> bereits ¬± 100 ¬µs betr√§gt (ja, es geht um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mikrosekunden</a> !). </li><li>  Die von der Methode <code>performance.now()</code> Werte steigen immer mit konstanter Geschwindigkeit und sind unabh√§ngig von der Systemzeit.  Diese Methode misst einfach Zeitintervalle, ohne sich auf die Systemzeit zu konzentrieren.  Und am <code>new Date()</code> wirkt sich <code>new Date()</code> Systemzeit aus.  Wenn Sie die Systemuhr neu anordnen, √§ndert sich auch die R√ºckgabe von <code>new Date ()</code> , wodurch die Leistungs√ºberwachungsdaten zerst√∂rt werden. </li></ul><br>  Obwohl die durch die Methode <code>performance.now()</code> ‚ÄûUhren‚Äú offensichtlich viel besser zum Messen von Zeitintervallen geeignet sind, sind sie auch nicht ideal.  Sowohl <code>performance.now()</code> als auch <code>new Date()</code> leiden unter demselben Problem, das sich in dem Fall √§u√üert, dass sich das System im Ruhezustand befindet: Die Messungen umfassen die Zeit, zu der die Maschine noch nicht einmal aktiv war. <br><br><h2>  <font color="#3AC1EF">2. √úberpr√ºfen der Anwendungsaktivit√§t</font> </h2><br>  Wenn Sie die Leistung einer Webanwendung messen und von der Registerkarte zu einer anderen wechseln, wird der Datenerfassungsprozess unterbrochen.  Warum?  Tatsache ist, dass der Browser die Anwendungen auf den Hintergrundregistern einschr√§nkt. <br><br>  Es gibt zwei Situationen, in denen Metriken verzerrt sein k√∂nnen.  Infolgedessen erscheint die Anwendung viel langsamer als sie tats√§chlich ist. <br><br><ol><li>  Der Computer wechselt in den Ruhemodus. </li><li>  Die Anwendung wird auf der Registerkarte "Hintergrund" des Browsers ausgef√ºhrt. </li></ol><br>  Das Auftreten dieser beiden Situationen ist nicht ungew√∂hnlich.  Gl√ºcklicherweise haben wir zwei M√∂glichkeiten, sie zu l√∂sen. <br><br>  Erstens k√∂nnen wir verzerrte Metriken einfach ignorieren und Messergebnisse verwerfen, die zu stark von einigen vern√ºnftigen Werten abweichen.  Zum Beispiel kann der Code, der beim Dr√ºcken einer Taste aufgerufen wird, 15 Minuten lang nicht ausgef√ºhrt werden!  Vielleicht ist dies das einzige, was Sie brauchen, um die beiden oben beschriebenen Probleme zu l√∂sen. <br><br>  Zweitens k√∂nnen Sie die Eigenschaft <code>document.hidden</code> und das Ereignis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sichtbarkeits√§nderung verwenden</a> .  Das <code>visibilitychange</code> wird ausgel√∂st, wenn der Benutzer von der gew√ºnschten Browser-Registerkarte zu einer anderen wechselt oder zur f√ºr uns interessanten Registerkarte zur√ºckkehrt.  Es wird aufgerufen, wenn das Browserfenster minimiert oder maximiert, wenn der Computer zu arbeiten beginnt und den Ruhemodus verl√§sst.  Mit anderen Worten, genau das brauchen wir.  Au√üerdem befindet sich die Eigenschaft <code>document.hidden</code> <code>true</code> , solange sich die Registerkarte im Hintergrund befindet. <br><br>  Hier ist ein einfaches Beispiel, das die Verwendung der Eigenschaft <code>document.hidden</code> und des Ereignisses " <code>visibilitychange</code> Change" demonstriert. <br><br><pre> <code class="plaintext hljs">let lastVisibilityChange = 0 window.addEventListener('visibilitychange', () =&gt; {  lastVisibilityChange = performance.now() }) //    ,      , //  ,   ,     if (metric.start &lt; lastVisibilityChange || document.hidden) return</code> </pre> <br>  Wie Sie sehen k√∂nnen, verwerfen wir einige Daten, aber das ist gut.  Tatsache ist, dass dies Daten sind, die sich auf jene Zeitr√§ume des Programms beziehen, in denen die Ressourcen des Systems nicht vollst√§ndig genutzt werden k√∂nnen. <br><br>  Jetzt haben wir √ºber Indikatoren gesprochen, die uns nicht interessieren.  Es gibt jedoch viele Situationen, in denen die gesammelten Daten f√ºr uns sehr interessant sind.  Schauen wir uns an, wie diese Daten gesammelt werden. <br><br><h2>  <font color="#3AC1EF">3. Suchen Sie nach dem Indikator, mit dem Sie den Zeitpunkt des Ereignisses am besten erfassen k√∂nnen</font> </h2><br>  Eine der umstrittensten Funktionen von JavaScript ist, dass die Ereignisschleife f√ºr diese Sprache Single-Threaded ist.  Zu einem bestimmten Zeitpunkt kann nur ein Code ausgef√ºhrt werden, dessen Ausf√ºhrung nicht unterbrochen werden kann. <br><br>  Wenn der Benutzer w√§hrend der Ausf√ºhrung eines bestimmten Codes die Taste dr√ºckt, wei√ü das Programm nichts davon, bis die Ausf√ºhrung dieses Codes abgeschlossen ist.  Wenn die Anwendung beispielsweise 1000 ms in einem kontinuierlichen Zyklus verbracht hat und der Benutzer 100 ms nach Beginn des Zyklus die <code>Escape</code> Taste gedr√ºckt hat, wird das Ereignis f√ºr weitere 900 ms nicht aufgezeichnet. <br><br>  Dies kann Metriken stark verzerren.  Wenn wir genau messen m√ºssen, wie der Benutzer die Arbeit mit dem Programm wahrnimmt, ist dies ein gro√ües Problem! <br><br>  Gl√ºcklicherweise ist die L√∂sung dieses Problems nicht so schwierig.  Wenn es sich um das aktuelle Ereignis handelt, k√∂nnen wir anstelle von <code>performance.now()</code> (dem Zeitpunkt, zu dem wir das Ereignis gesehen haben) <code>window.event.timeStamp</code> (dem Zeitpunkt, zu dem das Ereignis erstellt wurde) verwenden. <br><br>  Der Zeitstempel des Ereignisses wird vom Hauptbrowserprozess festgelegt.  Da dieser Prozess nicht blockiert, wenn die JS-Ereignisschleife gesperrt ist, liefert <code>event.timeStamp</code> viel wertvollere Informationen dar√ºber, wann das Ereignis tats√§chlich ausgel√∂st wurde. <br><br>  Es ist zu beachten, dass dieser Mechanismus nicht ideal ist.  Zwischen dem Dr√ºcken der physischen Taste und dem Eintreffen des entsprechenden Ereignisses in Chrome vergehen 9 bis 15 ms nicht ber√ºcksichtigter Zeit ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier ist ein</a> ausgezeichneter Artikel, in dem Sie erfahren k√∂nnen, warum dies geschieht). <br><br>  Selbst wenn wir die Zeit messen k√∂nnen, die das Ereignis ben√∂tigt, um Chrome zu erreichen, sollten wir diese Zeit nicht in unsere Metriken einbeziehen.  Warum?  Tatsache ist, dass wir solche Optimierungen nicht in den Code einf√ºhren k√∂nnen, die solche Verz√∂gerungen erheblich beeinflussen k√∂nnen.  Wir k√∂nnen sie in keiner Weise verbessern. <br><br>  Wenn wir also √ºber das Finden des Zeitstempels f√ºr den Beginn des Ereignisses <code>event.timeStamp</code> , sieht die <code>event.timeStamp</code> Anzeige hier am besten aus. <br><br>  Was ist die beste Sch√§tzung, wann die Veranstaltung endet? <br><br><h2>  <font color="#3AC1EF">4. Schalten Sie den Timer in requestAnimationFrame () aus.</font> </h2><br>  Eine weitere Konsequenz ergibt sich aus den Funktionen des Ereignisschleifenger√§ts in JavaScript: Einige Codes, die nicht mit Ihrem Code zusammenh√§ngen, k√∂nnen danach ausgef√ºhrt werden, bevor der Browser eine aktualisierte Version der Seite auf dem Bildschirm anzeigt. <br><br>  Betrachten Sie zum Beispiel Reagieren.  Nach der Ausf√ºhrung Ihres Codes aktualisiert React das DOM.  Wenn Sie nur die Zeit in Ihrem Code messen, bedeutet dies, dass Sie nicht die Zeit messen, die zum Ausf√ºhren des React-Codes ben√∂tigt wurde. <br><br>  Um diese zus√§tzliche Zeit zu messen, verwenden wir <code>requestAnimationFrame()</code> , um den Timer auszuschalten.  Dies erfolgt nur, wenn der Browser bereit ist, das n√§chste Bild auszugeben. <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; { metric.finish(performance.now()) })</code> </pre> <br>  Hier ist der Lebenszyklus des Rahmens (das Diagramm stammt aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> wunderbaren Material auf <code>requestAnimationFrame</code> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/439/0d4/4034390d4dd3060d8653bf03d72d4ca2.png"></div><br>  <i><font color="#999999">Rahmenlebenszyklus</font></i> <br><br>  Wie Sie in dieser Abbildung sehen k√∂nnen, wird <code>requestAnimationFrame()</code> aufgerufen, nachdem der Prozessor abgeschlossen wurde, unmittelbar bevor der Frame angezeigt wird.  Wenn wir hier den Timer ausschalten, k√∂nnen wir absolut sicher sein, dass alles, was die Zeit zum Aktualisieren des Bildschirms in Anspruch genommen hat, in den gesammelten Daten des Zeitintervalls enthalten ist. <br><br>  So weit so gut, aber jetzt wird die Situation ziemlich kompliziert ... <br><br><h2>  <font color="#3AC1EF">5. Ignorieren Sie die Zeit, die zum Erstellen eines Seitenlayouts und seiner Visualisierung erforderlich ist.</font> </h2><br>  Das vorherige Diagramm, das den Lebenszyklus eines Frames zeigt, zeigt ein weiteres Problem, auf das wir gesto√üen sind.  Am Ende des Lebenszyklus des Frames befinden sich Layoutbl√∂cke (bilden ein Seitenlayout) und Malen (Anzeigen einer Seite).  Wenn Sie die f√ºr diese Vorg√§nge erforderliche Zeit nicht ber√ºcksichtigen, ist die von uns gemessene Zeit k√ºrzer als die Zeit, die einige aktualisierte Daten ben√∂tigen, um auf dem Bildschirm angezeigt zu werden. <br><br>  Zum Gl√ºck hat <code>requestAnimationFrame</code> ein weiteres Ass im √Ñrmel.  Wenn die von <code>requestAnimationFrame</code> Funktion <code>requestAnimationFrame</code> , wird dieser Funktion ein Zeitstempel √ºbergeben, der die Startzeit f√ºr die Bildung des aktuellen Frames <code>requestAnimationFrame</code> die im linken Teil unseres Diagramms befindliche).  Dieser Zeitstempel liegt normalerweise sehr nahe an der Endzeit des vorherigen Frames. <br><br>  Infolgedessen kann der obige Nachteil behoben werden, indem die Gesamtzeit gemessen wird, die vom Moment des <code>event.timeStamp</code> bis zum Zeitpunkt des <code>event.timeStamp</code> der Bildung des n√§chsten Rahmens verstrichen ist.  Beachten Sie den verschachtelten <code>requestAnimationFrame</code> : <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  requestAnimationFrame((timestamp) =&gt; { metric.finish(timestamp) }) })</code> </pre> <br>  Obwohl das oben gezeigte eine hervorragende L√∂sung f√ºr das Problem darstellt, haben wir uns letztendlich entschieden, dieses Design nicht zu verwenden.  Tatsache ist, dass, obwohl diese Technik es erm√∂glicht, zuverl√§ssigere Daten zu erhalten, die Genauigkeit solcher Daten verringert ist.  Frames in Chrome werden mit einer Frequenz von 16 ms gebildet.  Dies bedeutet, dass die h√∂chste uns zur Verf√ºgung stehende Genauigkeit ¬± 16 ms betr√§gt.  Und wenn der Browser √ºberlastet ist und Frames √ºberspringt, ist die Genauigkeit noch geringer und diese Verschlechterung ist unvorhersehbar. <br><br>  Wenn Sie diese L√∂sung implementieren, wirkt sich eine ernsthafte Verbesserung der Leistung Ihres Codes, z. B. die Beschleunigung einer Aufgabe, die zuvor um 32 ms bis zu 15 ms ausgef√ºhrt wurde, m√∂glicherweise nicht auf die Ergebnisse der Leistungsmessung aus. <br><br>  Ohne Ber√ºcksichtigung der Zeit, die zum Erstellen eines Seitenlayouts und seiner Ausgabe erforderlich ist, erhalten wir viel genauere Metriken (¬± 100 Œºs) f√ºr den Code, den wir steuern.  Infolgedessen k√∂nnen wir einen numerischen Ausdruck jeder Verbesserung erhalten, die an diesem Code vorgenommen wurde. <br><br>  Wir haben auch eine √§hnliche Idee untersucht: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  setTimeout(() =&gt; { metric.finish(performance.now()) } })</code> </pre> <br>  Dies schlie√üt die Renderzeit ein, aber die Genauigkeit des Indikators ist nicht auf ¬± 16 ms beschr√§nkt.  Wir haben uns jedoch auch entschieden, diesen Ansatz nicht zu verwenden.  Wenn das System auf ein langes Eingabeereignis st√∂√üt, kann der Aufruf von <code>setTimeout</code> erheblich verz√∂gert und ausgef√ºhrt werden, nachdem die Benutzeroberfl√§che aktualisiert wurde. <br><br><h2>  <font color="#3AC1EF">6. Kl√§rung des ‚ÄûProzentsatzes der Ereignisse, die unter dem Ziel liegen‚Äú</font> </h2><br>  Wir entwickeln ein Projekt, konzentrieren uns auf hohe Leistung und versuchen, es auf zwei Arten zu optimieren: <br><br><ol><li>  Geschwindigkeit.  Die Ausf√ºhrungszeit der schnellsten Aufgabe sollte so nahe wie m√∂glich bei 0 ms liegen. </li><li>  Einheitlichkeit.  Die Ausf√ºhrungszeit der langsamsten Aufgabe sollte so nahe wie m√∂glich an der Ausf√ºhrungszeit der schnellsten Aufgabe liegen. </li></ol><br>  Aufgrund der Tatsache, dass sich diese Indikatoren im Laufe der Zeit √§ndern, sind sie schwer zu visualisieren und nicht leicht zu diskutieren.  Ist es m√∂glich, ein System zur Visualisierung solcher Indikatoren zu erstellen, das uns dazu inspirieren w√ºrde, sowohl Geschwindigkeit als auch Gleichm√§√üigkeit zu optimieren? <br><br>  Ein typischer Ansatz besteht darin, das 90. Perzentil der Verz√∂gerung zu messen.  Mit diesem Ansatz k√∂nnen Sie ein Liniendiagramm entlang der Y-Achse zeichnen, dessen Zeit in Millisekunden gespeichert wird.  In diesem Diagramm k√∂nnen Sie sehen, dass 90% der Ereignisse unterhalb des Liniendiagramms liegen, dh, sie werden schneller ausgef√ºhrt als die im Liniendiagramm angegebene Zeit. <br><br>  Es ist bekannt, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">100 ms</a> die Grenze zwischen dem ist, was als "schnell" und "langsam" wahrgenommen wird. <br><br>  Aber was werden wir dar√ºber herausfinden, wie sich Benutzer von der Arbeit f√ºhlen, wenn wir wissen, dass das 90. Perzentil der Verz√∂gerung 103 ms betr√§gt?  Nicht besonders viel.  Welche Indikatoren bieten Benutzern Benutzerfreundlichkeit?  Es gibt keine M√∂glichkeit, dies sicher zu wissen. <br><br>  Aber was ist, wenn wir wissen, dass das 90. Perzentil der Verz√∂gerung 93 ms betr√§gt?  Es besteht das Gef√ºhl, dass 93 besser als 103 ist, aber wir k√∂nnen nichts mehr √ºber diese Indikatoren sagen und dar√ºber, was sie f√ºr die Wahrnehmung des Projekts durch die Benutzer bedeuten.  Auch hier gibt es keine genaue Antwort auf diese Frage. <br><br>  Wir haben eine L√∂sung f√ºr dieses Problem gefunden.  Es besteht darin, den Prozentsatz der Ereignisse zu messen, deren Ausf√ºhrungszeit 100 ms nicht √ºberschreitet.  Dieser Ansatz bietet drei gro√üe Vorteile: <br><br><ul><li>  Die Metrik ist benutzerorientiert.  Sie kann uns sagen, wie viel Prozent der Zeit unsere Anwendung schnell ist und wie viel Prozent der Benutzer sie als schnell wahrnehmen. </li><li>  Mit dieser Metrik k√∂nnen wir die Messungen auf die Genauigkeit zur√ºcksetzen, die aufgrund der Tatsache verloren gegangen ist, dass wir die Zeit, die f√ºr die Ausf√ºhrung der Aufgaben am Ende des Frames ben√∂tigt wurde, nicht gemessen haben (dar√ºber haben wir in Abschnitt Nr. 5 gesprochen).  Aufgrund der Tatsache, dass wir einen Zielindikator festlegen, der in mehrere Frames passt, sind die Messergebnisse, die diesem Indikator nahe kommen, entweder geringer oder h√∂her. </li><li>  Diese Metrik ist einfacher zu berechnen.  Es reicht aus, einfach die Anzahl der Ereignisse zu berechnen, deren Ausf√ºhrungszeit unter dem Zielindikator liegt, und sie anschlie√üend durch die Gesamtzahl der Ereignisse zu dividieren.  Perzentile sind viel schwieriger zu z√§hlen.  Es gibt effektive Ann√§herungen, aber um alles richtig zu machen, m√ºssen Sie jede Dimension ber√ºcksichtigen. </li></ul><br>  Dieser Ansatz hat nur ein Minus: Wenn die Indikatoren schlechter als das Ziel sind, ist es nicht leicht, ihre Verbesserung zu bemerken. <br><br><h2>  <font color="#3AC1EF">7. Verwendung mehrerer Schwellenwerte bei der Analyse von Indikatoren</font> </h2><br>  Um das Ergebnis der Leistungsoptimierung zu visualisieren, haben wir mehrere zus√§tzliche Schwellenwerte in unser System eingef√ºhrt - √ºber 100 ms und darunter. <br><br>  Wir haben die Verz√∂gerungen folgenderma√üen gruppiert: <br><br><ul><li>  Weniger als 50 ms (schnell). </li><li>  50 bis 100 ms (gut). </li><li>  100 bis 1000 ms (langsam). </li><li>  Mehr als 1000 ms (furchtbar langsam). </li></ul><br>  "Schrecklich langsame" Ergebnisse lassen uns erkennen, dass wir irgendwo sehr viel verpasst haben.  Deshalb markieren wir sie hellrot. <br><br>  Was in 50 ms passt, reagiert sehr empfindlich auf √Ñnderungen.  Hier sind Leistungsverbesserungen oft sichtbar, lange bevor sie in einer Gruppe sichtbar werden, die 100 ms entspricht. <br><br>  Das folgende Diagramm zeigt beispielsweise die Leistung der Thread-Anzeige in Superhuman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/773/9e8/eb57739e82476e3b7a2c9212908ff5bf.png"></div><br>  <i><font color="#999999">Thread anzeigen</font></i> <br><br>  Es zeigt den Zeitraum des Leistungsabfalls und dann - die Ergebnisse von Verbesserungen.  Es ist schwierig, den Leistungsabfall zu bewerten, wenn Sie nur Indikatoren betrachten, die 100 ms entsprechen (die oberen Teile der blauen Spalten).  Bei Betrachtung der Ergebnisse, die in 50 ms passen (die oberen Teile der gr√ºnen Spalten), sind Leistungsprobleme bereits viel deutlicher sichtbar. <br><br>  Wenn wir den traditionellen Ansatz zur Untersuchung von Leistungsmetriken verwendet h√§tten, h√§tten wir wahrscheinlich kein Problem bemerkt, dessen Auswirkungen auf das System in der vorherigen Abbildung dargestellt sind.  Dank der Art und Weise, wie wir Messungen durchf√ºhren und unsere Metriken visualisieren, konnten wir ein Problem sehr schnell finden und l√∂sen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Es stellte sich heraus, dass es √ºberraschend schwierig war, den richtigen Ansatz f√ºr die Arbeit mit Leistungsmetriken zu finden.  Es ist uns gelungen, eine Methodik zu entwickeln, mit der wir hochwertige Tools zur Messung der Leistung von Webanwendungen erstellen k√∂nnen.  Wir sprechen n√§mlich √ºber Folgendes: <br><br><ol><li>  Die Startzeit eines Ereignisses wird mit <code>event.timeStamp</code> gemessen. </li><li>  Die Ereignisendzeit wird mithilfe von <code>performance.now()</code> in dem an <code>requestAnimationFrame()</code> R√ºckruf <code>requestAnimationFrame()</code> . </li><li>  Alles, was mit der Anwendung passiert, w√§hrend sie sich auf der inaktiven Browserregisterkarte befindet, wird ignoriert. </li><li>  Die Daten werden mithilfe eines Indikators aggregiert, der als ‚ÄûProzentsatz der Ereignisse, die unter dem Ziel liegen‚Äú beschrieben werden kann. </li><li>  Die Daten werden mit mehreren Schwellenwerten dargestellt. </li></ol><br>  Diese Technik bietet Ihnen die Werkzeuge, um zuverl√§ssige und genaue Metriken zu erstellen.  Sie k√∂nnen Diagramme erstellen, die einen deutlichen Leistungsabfall anzeigen, und die Ergebnisse von Optimierungen visualisieren.  Und vor allem haben Sie die M√∂glichkeit, schnelle Projekte noch schneller zu machen. <br><br>  <b>Liebe Leser!</b>  Wie analysieren Sie die Leistung Ihrer Webanwendungen? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470872/">https://habr.com/ru/post/de470872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470856/index.html">Telegramm GRAM Wallet: Nutzungsbedingungen</a></li>
<li><a href="../de470858/index.html">Antiquit√§ten: Benchmark des 386. Prozessors und der schneidigen neunziger Jahre</a></li>
<li><a href="../de470864/index.html">√úber die Freuden des Wechsels zum Panel und nicht nur</a></li>
<li><a href="../de470868/index.html">Zeit bis zum ersten Byte: Was ist das und warum ist es wichtig?</a></li>
<li><a href="../de470870/index.html">Schriftarten vorladen</a></li>
<li><a href="../de470874/index.html">Optimierung des Ladens von JavaScript auf Wikipedia</a></li>
<li><a href="../de470876/index.html">Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 1</a></li>
<li><a href="../de470878/index.html">Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 2</a></li>
<li><a href="../de470880/index.html">Spielmechanik. Abenteuer, das Konzept der Null und √ºberzeugende Sprachtherapie</a></li>
<li><a href="../de470882/index.html">Warum hast du meine Maus oder ein Brettspiel als Modell f√ºr soziale Interaktion erwischt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>