<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥦 🛢️ 👩🏼‍🍳 Leistungsmetriken für die Suche nach unglaublich schnellen Webanwendungen ☝🏼 🧛🏻 🕴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt ein Sprichwort: "Was Sie nicht messen können, können Sie nicht verbessern." Der Autor des Artikels, dessen Übersetzung wir heute veröffentlich...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Leistungsmetriken für die Suche nach unglaublich schnellen Webanwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470872/">  Es gibt ein Sprichwort: "Was Sie nicht messen können, können Sie nicht verbessern."  Der Autor des Artikels, dessen Übersetzung wir heute veröffentlichen, arbeitet für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Superhuman</a> .  Er sagt, dass dieses Unternehmen den schnellsten E-Mail-Client der Welt entwickelt.  Hier werden wir darüber sprechen, was „schnell“ ist und wie Tools zur Messung der Leistung unglaublich schneller Webanwendungen erstellt werden. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/q6/af/pp/q6afppxtd4rv6r-iqwvk9-6nyai.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Anwendungsgeschwindigkeitsmessung</font> </h2><br>  Um unsere Entwicklung zu verbessern, haben wir viel Zeit damit verbracht, die Geschwindigkeit zu messen.  Und wie sich herausstellte, sind Leistungsmetriken Indikatoren, die überraschend schwer zu verstehen und anzuwenden sind. <br><br>  Einerseits ist es schwierig, Metriken zu entwerfen, die die Empfindungen, die der Benutzer während der Arbeit mit dem System erfährt, genau beschreiben.  Andererseits ist es nicht einfach, Metriken zu erstellen, die so genau sind, dass Sie mit ihrer Analyse fundierte Entscheidungen treffen können.  Infolgedessen können viele Entwicklungsteams den Daten, die sie über die Leistung ihrer Projekte sammeln, nicht vertrauen. <br><br>  Selbst wenn Entwickler über zuverlässige und genaue Metriken verfügen, ist deren Verwendung nicht einfach.  Wie definiere ich den Begriff „schnell“?  Wie finde ich ein Gleichgewicht zwischen Geschwindigkeit und Beständigkeit?  Wie kann man lernen, Leistungseinbußen schnell zu erkennen oder die Auswirkungen von Optimierungen auf das System zu bewerten? <br><br>  Hier möchten wir einige Gedanken zur Entwicklung von Tools zur Leistungsanalyse von Webanwendungen teilen. <br><br><h2>  <font color="#3AC1EF">1. Mit der richtigen "Uhr"</font> </h2><br>  JavaScript verfügt über zwei Mechanismen zum Abrufen von Zeitstempeln: <code>performance.now()</code> und <code>new Date()</code> . <br><br>  Wie unterscheiden sie sich?  Die folgenden zwei Unterschiede sind für uns von grundlegender Bedeutung: <br><br><ul><li>  Die Methode <code>performance.now()</code> ist viel genauer.  Die Genauigkeit des <code>new Date()</code> -Konstrukts beträgt ± 1 ms, während die Genauigkeit von <code>performance.now()</code> bereits ± 100 µs beträgt (ja, es geht um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mikrosekunden</a> !). </li><li>  Die von der Methode <code>performance.now()</code> Werte steigen immer mit konstanter Geschwindigkeit und sind unabhängig von der Systemzeit.  Diese Methode misst einfach Zeitintervalle, ohne sich auf die Systemzeit zu konzentrieren.  Und am <code>new Date()</code> wirkt sich <code>new Date()</code> Systemzeit aus.  Wenn Sie die Systemuhr neu anordnen, ändert sich auch die Rückgabe von <code>new Date ()</code> , wodurch die Leistungsüberwachungsdaten zerstört werden. </li></ul><br>  Obwohl die durch die Methode <code>performance.now()</code> „Uhren“ offensichtlich viel besser zum Messen von Zeitintervallen geeignet sind, sind sie auch nicht ideal.  Sowohl <code>performance.now()</code> als auch <code>new Date()</code> leiden unter demselben Problem, das sich in dem Fall äußert, dass sich das System im Ruhezustand befindet: Die Messungen umfassen die Zeit, zu der die Maschine noch nicht einmal aktiv war. <br><br><h2>  <font color="#3AC1EF">2. Überprüfen der Anwendungsaktivität</font> </h2><br>  Wenn Sie die Leistung einer Webanwendung messen und von der Registerkarte zu einer anderen wechseln, wird der Datenerfassungsprozess unterbrochen.  Warum?  Tatsache ist, dass der Browser die Anwendungen auf den Hintergrundregistern einschränkt. <br><br>  Es gibt zwei Situationen, in denen Metriken verzerrt sein können.  Infolgedessen erscheint die Anwendung viel langsamer als sie tatsächlich ist. <br><br><ol><li>  Der Computer wechselt in den Ruhemodus. </li><li>  Die Anwendung wird auf der Registerkarte "Hintergrund" des Browsers ausgeführt. </li></ol><br>  Das Auftreten dieser beiden Situationen ist nicht ungewöhnlich.  Glücklicherweise haben wir zwei Möglichkeiten, sie zu lösen. <br><br>  Erstens können wir verzerrte Metriken einfach ignorieren und Messergebnisse verwerfen, die zu stark von einigen vernünftigen Werten abweichen.  Zum Beispiel kann der Code, der beim Drücken einer Taste aufgerufen wird, 15 Minuten lang nicht ausgeführt werden!  Vielleicht ist dies das einzige, was Sie brauchen, um die beiden oben beschriebenen Probleme zu lösen. <br><br>  Zweitens können Sie die Eigenschaft <code>document.hidden</code> und das Ereignis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sichtbarkeitsänderung verwenden</a> .  Das <code>visibilitychange</code> wird ausgelöst, wenn der Benutzer von der gewünschten Browser-Registerkarte zu einer anderen wechselt oder zur für uns interessanten Registerkarte zurückkehrt.  Es wird aufgerufen, wenn das Browserfenster minimiert oder maximiert, wenn der Computer zu arbeiten beginnt und den Ruhemodus verlässt.  Mit anderen Worten, genau das brauchen wir.  Außerdem befindet sich die Eigenschaft <code>document.hidden</code> <code>true</code> , solange sich die Registerkarte im Hintergrund befindet. <br><br>  Hier ist ein einfaches Beispiel, das die Verwendung der Eigenschaft <code>document.hidden</code> und des Ereignisses " <code>visibilitychange</code> Change" demonstriert. <br><br><pre> <code class="plaintext hljs">let lastVisibilityChange = 0 window.addEventListener('visibilitychange', () =&gt; {  lastVisibilityChange = performance.now() }) //    ,      , //  ,   ,     if (metric.start &lt; lastVisibilityChange || document.hidden) return</code> </pre> <br>  Wie Sie sehen können, verwerfen wir einige Daten, aber das ist gut.  Tatsache ist, dass dies Daten sind, die sich auf jene Zeiträume des Programms beziehen, in denen die Ressourcen des Systems nicht vollständig genutzt werden können. <br><br>  Jetzt haben wir über Indikatoren gesprochen, die uns nicht interessieren.  Es gibt jedoch viele Situationen, in denen die gesammelten Daten für uns sehr interessant sind.  Schauen wir uns an, wie diese Daten gesammelt werden. <br><br><h2>  <font color="#3AC1EF">3. Suchen Sie nach dem Indikator, mit dem Sie den Zeitpunkt des Ereignisses am besten erfassen können</font> </h2><br>  Eine der umstrittensten Funktionen von JavaScript ist, dass die Ereignisschleife für diese Sprache Single-Threaded ist.  Zu einem bestimmten Zeitpunkt kann nur ein Code ausgeführt werden, dessen Ausführung nicht unterbrochen werden kann. <br><br>  Wenn der Benutzer während der Ausführung eines bestimmten Codes die Taste drückt, weiß das Programm nichts davon, bis die Ausführung dieses Codes abgeschlossen ist.  Wenn die Anwendung beispielsweise 1000 ms in einem kontinuierlichen Zyklus verbracht hat und der Benutzer 100 ms nach Beginn des Zyklus die <code>Escape</code> Taste gedrückt hat, wird das Ereignis für weitere 900 ms nicht aufgezeichnet. <br><br>  Dies kann Metriken stark verzerren.  Wenn wir genau messen müssen, wie der Benutzer die Arbeit mit dem Programm wahrnimmt, ist dies ein großes Problem! <br><br>  Glücklicherweise ist die Lösung dieses Problems nicht so schwierig.  Wenn es sich um das aktuelle Ereignis handelt, können wir anstelle von <code>performance.now()</code> (dem Zeitpunkt, zu dem wir das Ereignis gesehen haben) <code>window.event.timeStamp</code> (dem Zeitpunkt, zu dem das Ereignis erstellt wurde) verwenden. <br><br>  Der Zeitstempel des Ereignisses wird vom Hauptbrowserprozess festgelegt.  Da dieser Prozess nicht blockiert, wenn die JS-Ereignisschleife gesperrt ist, liefert <code>event.timeStamp</code> viel wertvollere Informationen darüber, wann das Ereignis tatsächlich ausgelöst wurde. <br><br>  Es ist zu beachten, dass dieser Mechanismus nicht ideal ist.  Zwischen dem Drücken der physischen Taste und dem Eintreffen des entsprechenden Ereignisses in Chrome vergehen 9 bis 15 ms nicht berücksichtigter Zeit ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier ist ein</a> ausgezeichneter Artikel, in dem Sie erfahren können, warum dies geschieht). <br><br>  Selbst wenn wir die Zeit messen können, die das Ereignis benötigt, um Chrome zu erreichen, sollten wir diese Zeit nicht in unsere Metriken einbeziehen.  Warum?  Tatsache ist, dass wir solche Optimierungen nicht in den Code einführen können, die solche Verzögerungen erheblich beeinflussen können.  Wir können sie in keiner Weise verbessern. <br><br>  Wenn wir also über das Finden des Zeitstempels für den Beginn des Ereignisses <code>event.timeStamp</code> , sieht die <code>event.timeStamp</code> Anzeige hier am besten aus. <br><br>  Was ist die beste Schätzung, wann die Veranstaltung endet? <br><br><h2>  <font color="#3AC1EF">4. Schalten Sie den Timer in requestAnimationFrame () aus.</font> </h2><br>  Eine weitere Konsequenz ergibt sich aus den Funktionen des Ereignisschleifengeräts in JavaScript: Einige Codes, die nicht mit Ihrem Code zusammenhängen, können danach ausgeführt werden, bevor der Browser eine aktualisierte Version der Seite auf dem Bildschirm anzeigt. <br><br>  Betrachten Sie zum Beispiel Reagieren.  Nach der Ausführung Ihres Codes aktualisiert React das DOM.  Wenn Sie nur die Zeit in Ihrem Code messen, bedeutet dies, dass Sie nicht die Zeit messen, die zum Ausführen des React-Codes benötigt wurde. <br><br>  Um diese zusätzliche Zeit zu messen, verwenden wir <code>requestAnimationFrame()</code> , um den Timer auszuschalten.  Dies erfolgt nur, wenn der Browser bereit ist, das nächste Bild auszugeben. <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; { metric.finish(performance.now()) })</code> </pre> <br>  Hier ist der Lebenszyklus des Rahmens (das Diagramm stammt aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> wunderbaren Material auf <code>requestAnimationFrame</code> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/439/0d4/4034390d4dd3060d8653bf03d72d4ca2.png"></div><br>  <i><font color="#999999">Rahmenlebenszyklus</font></i> <br><br>  Wie Sie in dieser Abbildung sehen können, wird <code>requestAnimationFrame()</code> aufgerufen, nachdem der Prozessor abgeschlossen wurde, unmittelbar bevor der Frame angezeigt wird.  Wenn wir hier den Timer ausschalten, können wir absolut sicher sein, dass alles, was die Zeit zum Aktualisieren des Bildschirms in Anspruch genommen hat, in den gesammelten Daten des Zeitintervalls enthalten ist. <br><br>  So weit so gut, aber jetzt wird die Situation ziemlich kompliziert ... <br><br><h2>  <font color="#3AC1EF">5. Ignorieren Sie die Zeit, die zum Erstellen eines Seitenlayouts und seiner Visualisierung erforderlich ist.</font> </h2><br>  Das vorherige Diagramm, das den Lebenszyklus eines Frames zeigt, zeigt ein weiteres Problem, auf das wir gestoßen sind.  Am Ende des Lebenszyklus des Frames befinden sich Layoutblöcke (bilden ein Seitenlayout) und Malen (Anzeigen einer Seite).  Wenn Sie die für diese Vorgänge erforderliche Zeit nicht berücksichtigen, ist die von uns gemessene Zeit kürzer als die Zeit, die einige aktualisierte Daten benötigen, um auf dem Bildschirm angezeigt zu werden. <br><br>  Zum Glück hat <code>requestAnimationFrame</code> ein weiteres Ass im Ärmel.  Wenn die von <code>requestAnimationFrame</code> Funktion <code>requestAnimationFrame</code> , wird dieser Funktion ein Zeitstempel übergeben, der die Startzeit für die Bildung des aktuellen Frames <code>requestAnimationFrame</code> die im linken Teil unseres Diagramms befindliche).  Dieser Zeitstempel liegt normalerweise sehr nahe an der Endzeit des vorherigen Frames. <br><br>  Infolgedessen kann der obige Nachteil behoben werden, indem die Gesamtzeit gemessen wird, die vom Moment des <code>event.timeStamp</code> bis zum Zeitpunkt des <code>event.timeStamp</code> der Bildung des nächsten Rahmens verstrichen ist.  Beachten Sie den verschachtelten <code>requestAnimationFrame</code> : <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  requestAnimationFrame((timestamp) =&gt; { metric.finish(timestamp) }) })</code> </pre> <br>  Obwohl das oben gezeigte eine hervorragende Lösung für das Problem darstellt, haben wir uns letztendlich entschieden, dieses Design nicht zu verwenden.  Tatsache ist, dass, obwohl diese Technik es ermöglicht, zuverlässigere Daten zu erhalten, die Genauigkeit solcher Daten verringert ist.  Frames in Chrome werden mit einer Frequenz von 16 ms gebildet.  Dies bedeutet, dass die höchste uns zur Verfügung stehende Genauigkeit ± 16 ms beträgt.  Und wenn der Browser überlastet ist und Frames überspringt, ist die Genauigkeit noch geringer und diese Verschlechterung ist unvorhersehbar. <br><br>  Wenn Sie diese Lösung implementieren, wirkt sich eine ernsthafte Verbesserung der Leistung Ihres Codes, z. B. die Beschleunigung einer Aufgabe, die zuvor um 32 ms bis zu 15 ms ausgeführt wurde, möglicherweise nicht auf die Ergebnisse der Leistungsmessung aus. <br><br>  Ohne Berücksichtigung der Zeit, die zum Erstellen eines Seitenlayouts und seiner Ausgabe erforderlich ist, erhalten wir viel genauere Metriken (± 100 μs) für den Code, den wir steuern.  Infolgedessen können wir einen numerischen Ausdruck jeder Verbesserung erhalten, die an diesem Code vorgenommen wurde. <br><br>  Wir haben auch eine ähnliche Idee untersucht: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  setTimeout(() =&gt; { metric.finish(performance.now()) } })</code> </pre> <br>  Dies schließt die Renderzeit ein, aber die Genauigkeit des Indikators ist nicht auf ± 16 ms beschränkt.  Wir haben uns jedoch auch entschieden, diesen Ansatz nicht zu verwenden.  Wenn das System auf ein langes Eingabeereignis stößt, kann der Aufruf von <code>setTimeout</code> erheblich verzögert und ausgeführt werden, nachdem die Benutzeroberfläche aktualisiert wurde. <br><br><h2>  <font color="#3AC1EF">6. Klärung des „Prozentsatzes der Ereignisse, die unter dem Ziel liegen“</font> </h2><br>  Wir entwickeln ein Projekt, konzentrieren uns auf hohe Leistung und versuchen, es auf zwei Arten zu optimieren: <br><br><ol><li>  Geschwindigkeit.  Die Ausführungszeit der schnellsten Aufgabe sollte so nahe wie möglich bei 0 ms liegen. </li><li>  Einheitlichkeit.  Die Ausführungszeit der langsamsten Aufgabe sollte so nahe wie möglich an der Ausführungszeit der schnellsten Aufgabe liegen. </li></ol><br>  Aufgrund der Tatsache, dass sich diese Indikatoren im Laufe der Zeit ändern, sind sie schwer zu visualisieren und nicht leicht zu diskutieren.  Ist es möglich, ein System zur Visualisierung solcher Indikatoren zu erstellen, das uns dazu inspirieren würde, sowohl Geschwindigkeit als auch Gleichmäßigkeit zu optimieren? <br><br>  Ein typischer Ansatz besteht darin, das 90. Perzentil der Verzögerung zu messen.  Mit diesem Ansatz können Sie ein Liniendiagramm entlang der Y-Achse zeichnen, dessen Zeit in Millisekunden gespeichert wird.  In diesem Diagramm können Sie sehen, dass 90% der Ereignisse unterhalb des Liniendiagramms liegen, dh, sie werden schneller ausgeführt als die im Liniendiagramm angegebene Zeit. <br><br>  Es ist bekannt, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">100 ms</a> die Grenze zwischen dem ist, was als "schnell" und "langsam" wahrgenommen wird. <br><br>  Aber was werden wir darüber herausfinden, wie sich Benutzer von der Arbeit fühlen, wenn wir wissen, dass das 90. Perzentil der Verzögerung 103 ms beträgt?  Nicht besonders viel.  Welche Indikatoren bieten Benutzern Benutzerfreundlichkeit?  Es gibt keine Möglichkeit, dies sicher zu wissen. <br><br>  Aber was ist, wenn wir wissen, dass das 90. Perzentil der Verzögerung 93 ms beträgt?  Es besteht das Gefühl, dass 93 besser als 103 ist, aber wir können nichts mehr über diese Indikatoren sagen und darüber, was sie für die Wahrnehmung des Projekts durch die Benutzer bedeuten.  Auch hier gibt es keine genaue Antwort auf diese Frage. <br><br>  Wir haben eine Lösung für dieses Problem gefunden.  Es besteht darin, den Prozentsatz der Ereignisse zu messen, deren Ausführungszeit 100 ms nicht überschreitet.  Dieser Ansatz bietet drei große Vorteile: <br><br><ul><li>  Die Metrik ist benutzerorientiert.  Sie kann uns sagen, wie viel Prozent der Zeit unsere Anwendung schnell ist und wie viel Prozent der Benutzer sie als schnell wahrnehmen. </li><li>  Mit dieser Metrik können wir die Messungen auf die Genauigkeit zurücksetzen, die aufgrund der Tatsache verloren gegangen ist, dass wir die Zeit, die für die Ausführung der Aufgaben am Ende des Frames benötigt wurde, nicht gemessen haben (darüber haben wir in Abschnitt Nr. 5 gesprochen).  Aufgrund der Tatsache, dass wir einen Zielindikator festlegen, der in mehrere Frames passt, sind die Messergebnisse, die diesem Indikator nahe kommen, entweder geringer oder höher. </li><li>  Diese Metrik ist einfacher zu berechnen.  Es reicht aus, einfach die Anzahl der Ereignisse zu berechnen, deren Ausführungszeit unter dem Zielindikator liegt, und sie anschließend durch die Gesamtzahl der Ereignisse zu dividieren.  Perzentile sind viel schwieriger zu zählen.  Es gibt effektive Annäherungen, aber um alles richtig zu machen, müssen Sie jede Dimension berücksichtigen. </li></ul><br>  Dieser Ansatz hat nur ein Minus: Wenn die Indikatoren schlechter als das Ziel sind, ist es nicht leicht, ihre Verbesserung zu bemerken. <br><br><h2>  <font color="#3AC1EF">7. Verwendung mehrerer Schwellenwerte bei der Analyse von Indikatoren</font> </h2><br>  Um das Ergebnis der Leistungsoptimierung zu visualisieren, haben wir mehrere zusätzliche Schwellenwerte in unser System eingeführt - über 100 ms und darunter. <br><br>  Wir haben die Verzögerungen folgendermaßen gruppiert: <br><br><ul><li>  Weniger als 50 ms (schnell). </li><li>  50 bis 100 ms (gut). </li><li>  100 bis 1000 ms (langsam). </li><li>  Mehr als 1000 ms (furchtbar langsam). </li></ul><br>  "Schrecklich langsame" Ergebnisse lassen uns erkennen, dass wir irgendwo sehr viel verpasst haben.  Deshalb markieren wir sie hellrot. <br><br>  Was in 50 ms passt, reagiert sehr empfindlich auf Änderungen.  Hier sind Leistungsverbesserungen oft sichtbar, lange bevor sie in einer Gruppe sichtbar werden, die 100 ms entspricht. <br><br>  Das folgende Diagramm zeigt beispielsweise die Leistung der Thread-Anzeige in Superhuman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/773/9e8/eb57739e82476e3b7a2c9212908ff5bf.png"></div><br>  <i><font color="#999999">Thread anzeigen</font></i> <br><br>  Es zeigt den Zeitraum des Leistungsabfalls und dann - die Ergebnisse von Verbesserungen.  Es ist schwierig, den Leistungsabfall zu bewerten, wenn Sie nur Indikatoren betrachten, die 100 ms entsprechen (die oberen Teile der blauen Spalten).  Bei Betrachtung der Ergebnisse, die in 50 ms passen (die oberen Teile der grünen Spalten), sind Leistungsprobleme bereits viel deutlicher sichtbar. <br><br>  Wenn wir den traditionellen Ansatz zur Untersuchung von Leistungsmetriken verwendet hätten, hätten wir wahrscheinlich kein Problem bemerkt, dessen Auswirkungen auf das System in der vorherigen Abbildung dargestellt sind.  Dank der Art und Weise, wie wir Messungen durchführen und unsere Metriken visualisieren, konnten wir ein Problem sehr schnell finden und lösen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Es stellte sich heraus, dass es überraschend schwierig war, den richtigen Ansatz für die Arbeit mit Leistungsmetriken zu finden.  Es ist uns gelungen, eine Methodik zu entwickeln, mit der wir hochwertige Tools zur Messung der Leistung von Webanwendungen erstellen können.  Wir sprechen nämlich über Folgendes: <br><br><ol><li>  Die Startzeit eines Ereignisses wird mit <code>event.timeStamp</code> gemessen. </li><li>  Die Ereignisendzeit wird mithilfe von <code>performance.now()</code> in dem an <code>requestAnimationFrame()</code> Rückruf <code>requestAnimationFrame()</code> . </li><li>  Alles, was mit der Anwendung passiert, während sie sich auf der inaktiven Browserregisterkarte befindet, wird ignoriert. </li><li>  Die Daten werden mithilfe eines Indikators aggregiert, der als „Prozentsatz der Ereignisse, die unter dem Ziel liegen“ beschrieben werden kann. </li><li>  Die Daten werden mit mehreren Schwellenwerten dargestellt. </li></ol><br>  Diese Technik bietet Ihnen die Werkzeuge, um zuverlässige und genaue Metriken zu erstellen.  Sie können Diagramme erstellen, die einen deutlichen Leistungsabfall anzeigen, und die Ergebnisse von Optimierungen visualisieren.  Und vor allem haben Sie die Möglichkeit, schnelle Projekte noch schneller zu machen. <br><br>  <b>Liebe Leser!</b>  Wie analysieren Sie die Leistung Ihrer Webanwendungen? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470872/">https://habr.com/ru/post/de470872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470856/index.html">Telegramm GRAM Wallet: Nutzungsbedingungen</a></li>
<li><a href="../de470858/index.html">Antiquitäten: Benchmark des 386. Prozessors und der schneidigen neunziger Jahre</a></li>
<li><a href="../de470864/index.html">Über die Freuden des Wechsels zum Panel und nicht nur</a></li>
<li><a href="../de470868/index.html">Zeit bis zum ersten Byte: Was ist das und warum ist es wichtig?</a></li>
<li><a href="../de470870/index.html">Schriftarten vorladen</a></li>
<li><a href="../de470874/index.html">Optimierung des Ladens von JavaScript auf Wikipedia</a></li>
<li><a href="../de470876/index.html">Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 1</a></li>
<li><a href="../de470878/index.html">Erstellen Sie mit Babel benutzerdefinierte JavaScript-Syntaxkonstrukte. Teil 2</a></li>
<li><a href="../de470880/index.html">Spielmechanik. Abenteuer, das Konzept der Null und überzeugende Sprachtherapie</a></li>
<li><a href="../de470882/index.html">Warum hast du meine Maus oder ein Brettspiel als Modell für soziale Interaktion erwischt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>