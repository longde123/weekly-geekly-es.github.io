<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèΩ üëåüèª ‚òéÔ∏è bear_hug: Spiele in ASCII-Grafik in Python3.6 + üë©üèº‚Äçü§ù‚Äçüë®üèΩ ‚òØÔ∏è üèáüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="F√ºr meine Spiele in ASCII-Kunst habe ich die Bibliothek bear_hug mit einer Ereigniswarteschlange, einer Sammlung von Widgets, ECS-Unterst√ºtzung und an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>bear_hug: Spiele in ASCII-Grafik in Python3.6 +</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470950/"><img src="https://habrastorage.org/webt/b0/zu/vj/b0zuvjk4xdzcznbys9oslxl_veo.png"><br><br>  F√ºr meine Spiele in ASCII-Kunst habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Bibliothek bear_hug</a> mit einer Ereigniswarteschlange, einer Sammlung von Widgets, ECS-Unterst√ºtzung und anderen n√ºtzlichen Kleinigkeiten geschrieben.  In diesem Artikel werden wir sehen, wie man damit ein minimal funktionierendes Spiel macht. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Haftungsausschluss</b> <div class="spoiler_text"><ul><li>  Ich bin der einzige Entwickler der Bibliothek, daher kann ich voreingenommen sein. </li><li>  bear_hug ist im Wesentlichen ein Wrapper um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bearlibterminal</a> , daher gibt es keine Operationen auf relativ niedriger Ebene mit Glyphen. </li><li>  Es gibt eine √§hnliche Funktionalit√§t in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clubsandwich</a> , aber ich habe sie nicht verwendet und kann sie nicht vergleichen. </li></ul></div></div><br>  Unter der Haube von bear_hug befindet sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bearlibterminal</a> , eine SDL-Bibliothek zum Erstellen eines Pseudokonsolenfensters.  Das hei√üt, in reinem TTY wird es wie einige Fl√ºche nicht funktionieren.  Aber dann ist das Bild unter Linux und Windows dasselbe und h√§ngt nicht von den Einstellungen des Benutzerterminals ab.  Dies ist besonders f√ºr Spiele wichtig, denn wenn Sie die Schriftart ASCII-art √§ndern, kann Gott sich in Folgendes verwandeln: <br><br><img src="https://habrastorage.org/webt/ys/rh/6f/ysrh6fhay5u9slnpwvqn53is1ek.png"><br>  <i>Dieselbe Zeichnung in ihrer urspr√ºnglichen Form und nach dem Kopieren und Einf√ºgen in verschiedene Programme</i> <br><br>  Nat√ºrlich wurde die Bibliothek f√ºr relativ gro√üe Projekte geschrieben.  Um sich jedoch nicht vom Spieldesign und der Architektur ablenken zu lassen, werden wir in diesem Artikel etwas Einfaches erstellen.  Ein One-Night-Projekt, in dem die Grundfunktionen der Bibliothek gezeigt werden.  N√§mlich - ein vereinfachter Klon derselben Panzer mit Dandy (sie sind auch Battle City).  Es gibt einen Spielerpanzer, feindliche Panzer, zerst√∂rbare Mauern, Ger√§usche und Punkte.  Das Hauptmen√º, die Levels und die ausgew√§hlten Boni werden jedoch nicht angezeigt.  Nicht weil es unm√∂glich w√§re, sie hinzuzuf√ºgen, sondern weil dieses Projekt nichts anderes als eine Halloworld ist. <br><br><img src="https://habrastorage.org/webt/8k/e7/my/8ke7mymnrejpei7isjbxtbwvyjs.png"><br>  <i>Es wird ein Gameover geben, aber es wird keinen Sieg geben.</i>  <i>Weil das Leben Schmerz ist.</i> <br><br>  Das gesamte im Artikel verwendete Material befindet sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf dem Github</a> .  Die Bibliothek selbst befindet sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ebenfalls</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf PyPI</a> (unter der MIT-Lizenz). <br><br>  Zuallererst brauchen wir Verm√∂genswerte.  Um ASCII-Kunst zu zeichnen, verwende ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">REXpaint</a> von Josh Ge (alias Kyzrati), dem Entwickler des Science-Fiction-Bagels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cogmind</a> .  Der Editor ist kostenlos, jedoch nicht Open Source.  Die offizielle Version ist nur f√ºr Windows, aber unter Wein funktioniert alles einwandfrei.  Die Oberfl√§che ist sehr klar und bequem: <br><br><img src="https://habrastorage.org/webt/jf/x-/bi/jfx-bigu3sedblmkuspxh_pd4d4.png"><br><br>  Wir speichern im lokalen Bin√§rformat .xp und kopieren mit dem zuk√ºnftigen Spiel von <code>/path/to/rexpaint/images</code> in den Ordner.  Grunds√§tzlich wird auch das Laden von Bildern aus TXT-Dateien unterst√ºtzt, es ist jedoch offensichtlich unm√∂glich, die Farben einzelner Zeichen in einer Textdatei zu speichern.  Ja, und das Bearbeiten von ASCII-Grafiken in einem Notizbuch ist f√ºr mich pers√∂nlich nicht bequem.  Um die Koordinaten und die Gr√∂√üe jedes Elements nicht fest zu codieren, werden diese Daten in einer separaten JSON-Datei gespeichert: <br><br><div class="spoiler">  <b class="spoiler_title">Battlecity.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_r"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_l"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, ... ]</code> </pre> <br></div></div><br>  Klingt unter kostenlosen Lizenzen aus dem Internet.  Bisher wird nur .wav unterst√ºtzt.  Das ist alles mit Assets, Sie k√∂nnen mit dem Codieren beginnen.  Zun√§chst m√ºssen Sie das Terminal und die Ereigniswarteschlange initialisieren. <br><br><div class="spoiler">  <b class="spoiler_title">game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  terminal = BearTerminal(font_path='cp437_12x12.png', size='91x60', title='AsciiCity', filter=['keyboard', 'mouse']) #   dispatcher = BearEventDispatcher() # ,         loop = BearLoop(terminal, dispatcher)</span></span></code> </pre> <br></div></div><br>  Das Terminal ist das eigentliche Fenster des Spiels.  Sie k√∂nnen Widgets darauf platzieren und es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> nach Bedarf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eingabeereignisse</a> ausgel√∂st.  Als Schl√ºssel beim Erstellen eines Terminals k√∂nnen Sie alle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Terminaloptionen bearlibterminal verwenden</a> .  In diesem Fall legen wir die Schriftart, die Fenstergr√∂√üe (in Zeichen), den Fenstertitel und die f√ºr uns interessanten Eingabemethoden fest. <br><br>  Die Ereigniswarteschlange verf√ºgt √ºber eine sehr einfache Oberfl√§che: dispatcher.add_event (Ereignis) f√ºgt das Ereignis der Warteschlange hinzu, und dispatcher.register_listener (Listener, event_types) erm√∂glicht das Abonnieren.  Ein Unterzeichner (z. B. ein Widget oder eine Komponente) muss √ºber einen on_event-R√ºckruf verf√ºgen, der ein Ereignis als einzelnes Argument verwendet und entweder nichts oder ein anderes Ereignis oder eine Reihe von Ereignissen zur√ºckgibt.  Das Ereignis selbst besteht aus Typ und Wert;  Der Typ ist hier nicht im Sinne von str oder int, sondern im Sinne von "Variet√©", zum Beispiel "key_down" oder "tick".  Die Warteschlange akzeptiert nur Ereignisse bekannter Typen (integriert oder vom Benutzer erstellt) und sendet sie an on_event an alle, die diesen Typ abonnieren.  Die Werte werden in keiner Weise √ºberpr√ºft, es gibt jedoch Konventionen innerhalb der Bibliothek dar√ºber, was f√ºr jeden Ereignistyp ein g√ºltiger Wert ist. <br><br>  Zuerst stellen wir ein paar Zuh√∂rer in die Warteschlange.  Dies ist die Basisklasse f√ºr Objekte, die Ereignisse abonnieren k√∂nnen, jedoch keine Widgets oder Komponenten sind.  Im Prinzip ist eine Verwendung nicht erforderlich, solange der Unterzeichner die Methode on_event hatte. <br><br><div class="spoiler">  <b class="spoiler_title">Zuh√∂rer</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       dispatcher.register_listener(ClosingListener(), ['misc_input', 'tick']) #       dispatcher.register_listener(EntityTracker(), ['ecs_create', 'ecs_destroy']) #   jukebox = SoundListener({'shot': 'shot.wav', 'explosion': 'explosion.wav'}) # https://freesound.org/people/EMSIarma/sounds/108852/ # https://freesound.org/people/FlashTrauma/sounds/398283/ dispatcher.register_listener(jukebox, 'play_sound')</span></span></code> </pre> <br></div></div><br>  Eine vollst√§ndige Liste der integrierten Ereignistypen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Dokumentation</a> .  Es ist leicht zu erkennen, dass es Ereignisse f√ºr die Schaffung und Zerst√∂rung von Entit√§ten gibt, aber nicht f√ºr Schaden.  Da wir Objekte haben, die nicht von einem Schuss abfallen (W√§nde und Panzer des Spielers), werden wir sie erstellen: <br><br><div class="spoiler">  <b class="spoiler_title">Registrierung des Ereignistyps</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,    #   dispatcher.register_event_type('ac_damage') #       logger = LoggingListener(sys.stderr) dispatcher.register_listener(logger, ['ac_damage', 'play_sound'])</span></span></code> </pre> <br></div></div><br>  Wir sind uns einig, dass dieses Ereignis als Wert ein Tupel aus der ID des Unternehmens, das den Schaden erlitten hat, und dem Wert des Schadens enth√§lt.  LoggingListener ist nur ein Debugging-Tool, das alle empfangenen Ereignisse druckt, wo immer sie sagen, in diesem Fall in stderr.  In diesem Fall wollte ich sicherstellen, dass der Schaden korrekt auftritt und dass der Ton immer dann angefordert wird, wenn er sollte. <br><br>  Mit Listeners k√∂nnen Sie jetzt das erste Widget hinzuf√ºgen.  Wir haben dieses ECSLayout-Klassenspielfeld.  Dies ist ein solches Layout, das Widgets auf Entit√§ten setzen und diese als Reaktion auf ecs_move-Ereignisse verschieben kann und gleichzeitig Kollisionen ber√ºcksichtigt.  Wie bei den meisten Widgets sind zwei Argumente erforderlich: eine verschachtelte Liste von Zeichen (m√∂glicherweise leer - Leerzeichen oder Keine) und eine verschachtelte Liste von Farben f√ºr jedes Zeichen.  Benannte Farben werden als Farben akzeptiert, RGB im Format "0xAARRGGBB" (oder "0xARGB", "0xRGB", "0xRRGGBB") und im Format "#fff".  Die Gr√∂√üen beider Listen m√ºssen √ºbereinstimmen.  Andernfalls wird eine Ausnahme ausgel√∂st. <br><br><div class="spoiler">  <b class="spoiler_title">Erstes Widget</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   .  8460,   9160. # 7         chars = [[' ' for x in range(84)] for y in range(60)] colors = copy_shape(chars, 'gray') layout = ECSLayout(chars, colors) # 'all' -  ,      dispatcher.register_listener(layout, 'all')</span></span></code> </pre> <br></div></div><br>  Da wir jetzt wissen, worauf Objekte im Spiel platziert werden sollen, k√∂nnen wir mit dem Erstellen von Entit√§ten beginnen.  Der gesamte Code von Entit√§ten und Komponenten wird in eine separate Datei verschoben.  Die einfachste davon ist eine zerst√∂rbare Mauer.  Sie wei√ü, wie man sich an einem bestimmten Ort befindet, ihr Widget anzeigt, als Kollisionsobjekt dient und Schaden erleidet.  Nach gen√ºgend Schaden verschwindet die Wand. <br><br><div class="spoiler">  <b class="spoiler_title">entity.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_wall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dispatcher, atlas, entity_id, x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   wall = Entity(entity_id) #  wall.add_component(PositionComponent(dispatcher, x, y)) wall.add_component(CollisionComponent(dispatcher)) wall.add_component(PassingComponent(dispatcher)) wall.add_component(DestructorComponent(dispatcher)) #     ,      #    -  /   images_dict = {'wall_3': atlas.get_element('wall_3'), 'wall_2': atlas.get_element('wall_2'), 'wall_1': atlas.get_element('wall_1')} wall.add_component(SwitchWidgetComponent(dispatcher, SwitchingWidget(images_dict=images_dict, initial_image='wall_3'))) wall.add_component(VisualDamageHealthComponent(dispatcher, hitpoints=3, widgets_dict={3: 'wall_3', 2: 'wall_2', 1: 'wall_1'})) #     dispatcher.add_event(BearEvent('ecs_create', wall)) dispatcher.add_event(BearEvent('ecs_add', (wall.id, wall.position.x, wall.position.y)))</span></span></code> </pre> <br></div></div><br>  Zun√§chst wird das Entit√§tsobjekt selbst erstellt.  Es enth√§lt nur einen Namen (der eindeutig sein muss) und eine Reihe von Komponenten.  Sie k√∂nnen entweder bei der Erstellung auf einmal √ºbertragen oder wie hier einzeln hinzugef√ºgt werden.  Dann werden alle notwendigen Komponenten erstellt.  Als Widget wird SwitchWidget verwendet, das mehrere Zeichnungen derselben Gr√∂√üe enth√§lt und diese per Befehl √§ndern kann.  Beim Erstellen eines Widgets werden √ºbrigens Zeichnungen aus dem Atlas geladen.  Und schlie√ülich werden die Ank√ºndigung der Erstellung der Entit√§t und die Reihenfolge, sie auf die erforderlichen Koordinaten zu zeichnen, in die Warteschlange gestellt. <br><br>  Von den nicht eingebauten Komponenten gibt es nur Gesundheit.  Ich habe die Basisklasse "Gesundheitskomponente" erstellt und von ihr das "Widget zum √Ñndern der Gesundheitskomponente" geerbt (um die Wand intakt und in mehreren Stadien der Zerst√∂rung anzuzeigen). <br><br><div class="spoiler">  <b class="spoiler_title">Klasse HealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Component)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, hitpoints=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, name=<span class="hljs-string"><span class="hljs-string">'health'</span></span>, **kwargs) self.dispatcher.register_listener(self, <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>) self._hitpoints = hitpoints <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> event.event_value[<span class="hljs-number"><span class="hljs-number">0</span></span>] == self.owner.id: self.hitpoints -= event.event_value[<span class="hljs-number"><span class="hljs-number">1</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._hitpoints @hitpoints.setter <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> isinstance(value, int): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> BearECSException( <span class="hljs-string"><span class="hljs-string">f'Attempting to set hitpoints of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.owner.id}</span></span></span><span class="hljs-string"> to non-integer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{value}</span></span></span><span class="hljs-string">'</span></span>) self._hitpoints = value <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._hitpoints &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: self._hitpoints = <span class="hljs-number"><span class="hljs-number">0</span></span> self.process_hitpoint_update() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Should be overridden by child classes. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError(<span class="hljs-string"><span class="hljs-string">'HP update processing should be overridden'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#           return dumps({'class': self.__class__.__name__, 'hitpoints': self.hitpoints})</span></span></code> </pre> <br></div></div><br>  Beim Erstellen einer Komponente wird der Schl√ºssel 'name' an super () .__ init__ √ºbergeben.  Wenn eine Komponente zu einer Entit√§t hinzugef√ºgt wird, wird sie unter dem Namen dieses Schl√ºssels zum __dict__ der Entit√§t hinzugef√ºgt und kann √ºber entity_object.health aufgerufen werden.  Neben dem Komfort der Schnittstelle ist dieser Ansatz gut, da er die Ausgabe von Entit√§ten mehrerer homogener Komponenten verbietet.  Die Tatsache, dass es in der Komponente fest codiert ist, erm√∂glicht es Ihnen nicht, beispielsweise WidgetComponent f√§lschlicherweise in den Steckplatz der Integrit√§tskomponente einzuf√ºgen.  Unmittelbar nach der Erstellung abonniert die Komponente die f√ºr sie interessanten Ereignisklassen, in diesem Fall ac_damage.  Nachdem die Methode on_event ein solches Ereignis erhalten hat, pr√ºft sie eine Stunde lang, ob es sich um ihren Besitzer handelt.  In diesem Fall subtrahiert er den gew√ºnschten Wert von den Trefferpunkten und zieht den R√ºckruf, um den Zustand zu √§ndern. Die Basisklasse ist abstrakt.  Es gibt auch die Methode __repr__, die f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serialisierung in JSON verwendet wird</a> (z. B. zum Speichern).  Es ist nicht erforderlich, es hinzuzuf√ºgen, aber alle integrierten Komponenten und die meisten integrierten Widgets haben es. <br><br>  Durch das Erben der zugrunde liegenden Integrit√§tskomponente von VisualDamageHealthComponent wird der R√ºckruf bei Integrit√§ts√§nderungen √ºberschrieben: <br><br><div class="spoiler">  <b class="spoiler_title">Klasse VisualDamageHealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VisualDamageHealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(HealthComponent)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       .    HP=0 """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, widgets_dict={}, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self.widgets_dict = OrderedDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(widgets_dict.keys()): self.widgets_dict[int(x)] = widgets_dict[x] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hasattr(self.owner, <span class="hljs-string"><span class="hljs-string">'destructor'</span></span>): self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.widgets_dict: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints &gt;= x: self.owner.widget.switch_to_image(self.widgets_dict[x])</code> </pre> <br></div></div><br>  W√§hrend der Zustand √ºber 0 liegt, fordert er die f√ºr das Widget verantwortliche Komponente auf, die Wand im gew√ºnschten Zustand zu zeichnen.  Hier wird der oben beschriebene Aufruf √ºber das Attribut des Entit√§tsobjekts verwendet.  Sobald die Trefferpunkte √ºberschritten sind, werden die Komponente, die f√ºr die korrekte Zerst√∂rung der Entit√§t verantwortlich ist, und alle Komponenten auf dieselbe Weise aufgerufen. <br><br>  Bei anderen Entit√§ten ist alles √§hnlich, nur die Komponenten sind unterschiedlich.  Panzer werden mit Controllern (Eingabe f√ºr den Spieler, KI f√ºr Gegner) und rotierenden Widgets f√ºr Muscheln hinzugef√ºgt - eine Kollisionskomponente, die denjenigen Schaden zuf√ºgt, die sie treffen.  Ich werde nicht jeden von ihnen analysieren, weil es sperrig und eher trivial ist;  schau nur auf den Projektilkollider.  Es hat eine collided_into-Methode, die aufgerufen wird, wenn die Host-Entit√§t gegen etwas st√∂√üt: <br><br><div class="spoiler">  <b class="spoiler_title">Bullet Component Collider</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collided_into</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, entity)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> entity: self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> hasattr(EntityTracker().entities[entity], <span class="hljs-string"><span class="hljs-string">'collision'</span></span>): self.dispatcher.add_event(BearEvent(event_type=<span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>, event_value=( entity, self.damage))) self.owner.destructor.destroy()</code> </pre> <br></div></div><br>  Um sicherzustellen, dass es m√∂glich ist, ein Opfer zu finden (was beispielsweise f√ºr Hintergrundelemente falsch sein kann), verwendet das Projektil EntityTracker ().  Dies ist ein Singleton, der alle erstellten und zerst√∂rten Entit√§ten verfolgt.  Durch sie k√∂nnen Sie ein Entit√§tsobjekt nach Namen abrufen und etwas mit seinen Komponenten tun.  In diesem Fall wird √ºberpr√ºft, ob entity.collision (der Opferkollisionshandler) √ºberhaupt vorhanden ist. <br><br>  Jetzt rufen wir in der Hauptdatei des Spiels einfach alle notwendigen Funktionen zum Erstellen von Entit√§ten auf: <br><br><div class="spoiler">  <b class="spoiler_title">Zur√ºck zu game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  , -     atlas = Atlas(XpLoader('battlecity.xp'), 'battlecity.json') #   create_player_tank(dispatcher, atlas, 30, 50) #    wall_array = [[0 for _ in range(14)], [0 for _ in range(14)], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0 for _ in range(14)], [0 for _ in range(14)], [0 for _ in range(14)] ] for y in range(10): for x in range(14): if wall_array[y][x] == 1: create_wall(dispatcher, atlas, f'wall{x}{y}', x*6, y*6) #   -  .     . create_spawner_house(dispatcher, atlas, 35, 0)</span></span></code> </pre> <br></div></div><br>  Punkt- und Trefferpunktz√§hler sind keine Einheiten und befinden sich nicht auf dem Schlachtfeld.  Daher werden sie nicht zu ECSLayout hinzugef√ºgt, sondern direkt zum Terminal rechts von der Karte.  Relevante Widgets erben von Label (Textausgabe-Widget) und verf√ºgen √ºber eine on_event-Methode, um herauszufinden, was sie interessiert.  Im Gegensatz zu Layout aktualisiert das Terminal Widgets nicht automatisch bei jedem Tick. Nach dem √Ñndern des Texts weisen ihn die Widgets an, dies zu tun: <br><br><div class="spoiler">  <b class="spoiler_title">listeners.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScoreLabel</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Label)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(text=<span class="hljs-string"><span class="hljs-string">'Score:\n0'</span></span>) self.score = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ecs_destroy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'enemy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'bullet'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value: <span class="hljs-comment"><span class="hljs-comment">#    self.score += 10 self.text = f'Score:\n{self.score}' self.terminal.update_widget(self) class HPLabel(Label): """   """ def __init__(self, *args, **kwargs): super().__init__(text='HP:\n5') self.hp = 5 def on_event(self, event): if event.event_type == 'ac_damage' and event.event_value[0] == 'player': self.hp -= event.event_value[1] self.text = f'HP:\n{self.hp}' self.terminal.update_widget(self)</span></span></code> </pre> <br></div></div><br>  Der feindliche Generator und das Objekt, das f√ºr die Ausgabe von ‚ÄûGAME OVER‚Äú verantwortlich ist, werden √ºberhaupt nicht angezeigt und erben daher vom Listener.  Das Prinzip ist dasselbe: Objekte h√∂ren auf die Warteschlange, warten auf den richtigen Moment und erstellen dann eine Entit√§t oder ein Widget. <br><br><div class="spoiler">  <b class="spoiler_title">Gameover</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    - . . . class GameOverListener(Listener): """       """ def __init__(self, *args, widget=None, **kwargs): print (args) super().__init__(*args, *kwargs) self.widget = widget def on_event(self, event): if event.event_type == 'ecs_destroy' and event.event_value == 'player': self.terminal.add_widget(self.widget, pos=(20, 20), layer=5)</span></span></code> </pre><br></div></div><br>  Jetzt haben wir alles geschaffen, was wir brauchen, und wir k√∂nnen das Spiel starten. <br><br><div class="spoiler">  <b class="spoiler_title">Wir starten</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,   Listeners    terminal.start() terminal.add_widget(layout) terminal.add_widget(score, pos=(85, 10)) terminal.add_widget(hp, pos=(85, 15))</span></span></code> </pre> <br></div></div><br>  Widgets werden dem Bildschirm erst nach dem Start hinzugef√ºgt.  Entit√§ten k√∂nnen der Karte hinzugef√ºgt werden, bevor - Erstellungsereignisse (in denen die gesamte Entit√§t einschlie√ülich des Widgets gespeichert ist) einfach in der Warteschlange gesammelt und beim ersten H√§kchen aufgel√∂st werden.  Das Terminal kann Widgets jedoch erst hinzuf√ºgen, nachdem ein Fenster erfolgreich f√ºr das Terminal erstellt wurde. <br><br>  Zu diesem Zeitpunkt haben wir einen funktionierenden Prototyp, den Sie <s>in Early Access f√ºr zwanzig Dollar ausgeben</s> k√∂nnen, um Funktionen hinzuzuf√ºgen und das Gameplay zu verbessern.  Dies geht aber bereits √ºber den Rahmen der heiligen Welt und damit des Artikels hinaus.  Ich werde nur hinzuf√ºgen, dass der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systempython</a> unabh√§ngige Build mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pyinstaller erstellt werden kann</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470950/">https://habr.com/ru/post/de470950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470930/index.html">Gamification des Produkts. Verlauf Ratatype</a></li>
<li><a href="../de470934/index.html">Heilt vor der Hochzeit: Zellproliferation und Regenerationsf√§higkeit von Quallen</a></li>
<li><a href="../de470938/index.html">So √∂ffnen Sie einen Link in Python. Arbeiten mit WebBrowser und L√∂sen eines Problems mit Internet Explorer</a></li>
<li><a href="../de470940/index.html">MSK VUE.JS Meetup # 3 bei Mail.ru Group: Materialien von Mitap</a></li>
<li><a href="../de470942/index.html">Vom Anf√§nger bis zur Stilikone: Wie wir in 2GIS Auszeichnungen vergeben haben</a></li>
<li><a href="../de470952/index.html">Tipps und Tricks zur digitalen Forensik: Forensik-App ‚ÄûYour Phone‚Äú</a></li>
<li><a href="../de470954/index.html">Installieren Sie Zimbra OSE 8.8.15 und Zextras Suite Pro unter Ubuntu 18.04 LTS</a></li>
<li><a href="../de470958/index.html">Lebendigkeitssonden in Kubernetes k√∂nnen gef√§hrlich sein</a></li>
<li><a href="../de470962/index.html">JSConf Budapest 2019</a></li>
<li><a href="../de470964/index.html">Holzspielzeug - Inschriften</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>