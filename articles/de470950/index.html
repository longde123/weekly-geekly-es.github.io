<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏽 👌🏻 ☎️ bear_hug: Spiele in ASCII-Grafik in Python3.6 + 👩🏼‍🤝‍👨🏽 ☯️ 🏇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Für meine Spiele in ASCII-Kunst habe ich die Bibliothek bear_hug mit einer Ereigniswarteschlange, einer Sammlung von Widgets, ECS-Unterstützung und an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>bear_hug: Spiele in ASCII-Grafik in Python3.6 +</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470950/"><img src="https://habrastorage.org/webt/b0/zu/vj/b0zuvjk4xdzcznbys9oslxl_veo.png"><br><br>  Für meine Spiele in ASCII-Kunst habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Bibliothek bear_hug</a> mit einer Ereigniswarteschlange, einer Sammlung von Widgets, ECS-Unterstützung und anderen nützlichen Kleinigkeiten geschrieben.  In diesem Artikel werden wir sehen, wie man damit ein minimal funktionierendes Spiel macht. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Haftungsausschluss</b> <div class="spoiler_text"><ul><li>  Ich bin der einzige Entwickler der Bibliothek, daher kann ich voreingenommen sein. </li><li>  bear_hug ist im Wesentlichen ein Wrapper um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bearlibterminal</a> , daher gibt es keine Operationen auf relativ niedriger Ebene mit Glyphen. </li><li>  Es gibt eine ähnliche Funktionalität in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clubsandwich</a> , aber ich habe sie nicht verwendet und kann sie nicht vergleichen. </li></ul></div></div><br>  Unter der Haube von bear_hug befindet sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bearlibterminal</a> , eine SDL-Bibliothek zum Erstellen eines Pseudokonsolenfensters.  Das heißt, in reinem TTY wird es wie einige Flüche nicht funktionieren.  Aber dann ist das Bild unter Linux und Windows dasselbe und hängt nicht von den Einstellungen des Benutzerterminals ab.  Dies ist besonders für Spiele wichtig, denn wenn Sie die Schriftart ASCII-art ändern, kann Gott sich in Folgendes verwandeln: <br><br><img src="https://habrastorage.org/webt/ys/rh/6f/ysrh6fhay5u9slnpwvqn53is1ek.png"><br>  <i>Dieselbe Zeichnung in ihrer ursprünglichen Form und nach dem Kopieren und Einfügen in verschiedene Programme</i> <br><br>  Natürlich wurde die Bibliothek für relativ große Projekte geschrieben.  Um sich jedoch nicht vom Spieldesign und der Architektur ablenken zu lassen, werden wir in diesem Artikel etwas Einfaches erstellen.  Ein One-Night-Projekt, in dem die Grundfunktionen der Bibliothek gezeigt werden.  Nämlich - ein vereinfachter Klon derselben Panzer mit Dandy (sie sind auch Battle City).  Es gibt einen Spielerpanzer, feindliche Panzer, zerstörbare Mauern, Geräusche und Punkte.  Das Hauptmenü, die Levels und die ausgewählten Boni werden jedoch nicht angezeigt.  Nicht weil es unmöglich wäre, sie hinzuzufügen, sondern weil dieses Projekt nichts anderes als eine Halloworld ist. <br><br><img src="https://habrastorage.org/webt/8k/e7/my/8ke7mymnrejpei7isjbxtbwvyjs.png"><br>  <i>Es wird ein Gameover geben, aber es wird keinen Sieg geben.</i>  <i>Weil das Leben Schmerz ist.</i> <br><br>  Das gesamte im Artikel verwendete Material befindet sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf dem Github</a> .  Die Bibliothek selbst befindet sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ebenfalls</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf PyPI</a> (unter der MIT-Lizenz). <br><br>  Zuallererst brauchen wir Vermögenswerte.  Um ASCII-Kunst zu zeichnen, verwende ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">REXpaint</a> von Josh Ge (alias Kyzrati), dem Entwickler des Science-Fiction-Bagels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cogmind</a> .  Der Editor ist kostenlos, jedoch nicht Open Source.  Die offizielle Version ist nur für Windows, aber unter Wein funktioniert alles einwandfrei.  Die Oberfläche ist sehr klar und bequem: <br><br><img src="https://habrastorage.org/webt/jf/x-/bi/jfx-bigu3sedblmkuspxh_pd4d4.png"><br><br>  Wir speichern im lokalen Binärformat .xp und kopieren mit dem zukünftigen Spiel von <code>/path/to/rexpaint/images</code> in den Ordner.  Grundsätzlich wird auch das Laden von Bildern aus TXT-Dateien unterstützt, es ist jedoch offensichtlich unmöglich, die Farben einzelner Zeichen in einer Textdatei zu speichern.  Ja, und das Bearbeiten von ASCII-Grafiken in einem Notizbuch ist für mich persönlich nicht bequem.  Um die Koordinaten und die Größe jedes Elements nicht fest zu codieren, werden diese Daten in einer separaten JSON-Datei gespeichert: <br><br><div class="spoiler">  <b class="spoiler_title">Battlecity.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_r"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_l"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, ... ]</code> </pre> <br></div></div><br>  Klingt unter kostenlosen Lizenzen aus dem Internet.  Bisher wird nur .wav unterstützt.  Das ist alles mit Assets, Sie können mit dem Codieren beginnen.  Zunächst müssen Sie das Terminal und die Ereigniswarteschlange initialisieren. <br><br><div class="spoiler">  <b class="spoiler_title">game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  terminal = BearTerminal(font_path='cp437_12x12.png', size='91x60', title='AsciiCity', filter=['keyboard', 'mouse']) #   dispatcher = BearEventDispatcher() # ,         loop = BearLoop(terminal, dispatcher)</span></span></code> </pre> <br></div></div><br>  Das Terminal ist das eigentliche Fenster des Spiels.  Sie können Widgets darauf platzieren und es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> nach Bedarf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eingabeereignisse</a> ausgelöst.  Als Schlüssel beim Erstellen eines Terminals können Sie alle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Terminaloptionen bearlibterminal verwenden</a> .  In diesem Fall legen wir die Schriftart, die Fenstergröße (in Zeichen), den Fenstertitel und die für uns interessanten Eingabemethoden fest. <br><br>  Die Ereigniswarteschlange verfügt über eine sehr einfache Oberfläche: dispatcher.add_event (Ereignis) fügt das Ereignis der Warteschlange hinzu, und dispatcher.register_listener (Listener, event_types) ermöglicht das Abonnieren.  Ein Unterzeichner (z. B. ein Widget oder eine Komponente) muss über einen on_event-Rückruf verfügen, der ein Ereignis als einzelnes Argument verwendet und entweder nichts oder ein anderes Ereignis oder eine Reihe von Ereignissen zurückgibt.  Das Ereignis selbst besteht aus Typ und Wert;  Der Typ ist hier nicht im Sinne von str oder int, sondern im Sinne von "Varieté", zum Beispiel "key_down" oder "tick".  Die Warteschlange akzeptiert nur Ereignisse bekannter Typen (integriert oder vom Benutzer erstellt) und sendet sie an on_event an alle, die diesen Typ abonnieren.  Die Werte werden in keiner Weise überprüft, es gibt jedoch Konventionen innerhalb der Bibliothek darüber, was für jeden Ereignistyp ein gültiger Wert ist. <br><br>  Zuerst stellen wir ein paar Zuhörer in die Warteschlange.  Dies ist die Basisklasse für Objekte, die Ereignisse abonnieren können, jedoch keine Widgets oder Komponenten sind.  Im Prinzip ist eine Verwendung nicht erforderlich, solange der Unterzeichner die Methode on_event hatte. <br><br><div class="spoiler">  <b class="spoiler_title">Zuhörer</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       dispatcher.register_listener(ClosingListener(), ['misc_input', 'tick']) #       dispatcher.register_listener(EntityTracker(), ['ecs_create', 'ecs_destroy']) #   jukebox = SoundListener({'shot': 'shot.wav', 'explosion': 'explosion.wav'}) # https://freesound.org/people/EMSIarma/sounds/108852/ # https://freesound.org/people/FlashTrauma/sounds/398283/ dispatcher.register_listener(jukebox, 'play_sound')</span></span></code> </pre> <br></div></div><br>  Eine vollständige Liste der integrierten Ereignistypen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Dokumentation</a> .  Es ist leicht zu erkennen, dass es Ereignisse für die Schaffung und Zerstörung von Entitäten gibt, aber nicht für Schaden.  Da wir Objekte haben, die nicht von einem Schuss abfallen (Wände und Panzer des Spielers), werden wir sie erstellen: <br><br><div class="spoiler">  <b class="spoiler_title">Registrierung des Ereignistyps</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,    #   dispatcher.register_event_type('ac_damage') #       logger = LoggingListener(sys.stderr) dispatcher.register_listener(logger, ['ac_damage', 'play_sound'])</span></span></code> </pre> <br></div></div><br>  Wir sind uns einig, dass dieses Ereignis als Wert ein Tupel aus der ID des Unternehmens, das den Schaden erlitten hat, und dem Wert des Schadens enthält.  LoggingListener ist nur ein Debugging-Tool, das alle empfangenen Ereignisse druckt, wo immer sie sagen, in diesem Fall in stderr.  In diesem Fall wollte ich sicherstellen, dass der Schaden korrekt auftritt und dass der Ton immer dann angefordert wird, wenn er sollte. <br><br>  Mit Listeners können Sie jetzt das erste Widget hinzufügen.  Wir haben dieses ECSLayout-Klassenspielfeld.  Dies ist ein solches Layout, das Widgets auf Entitäten setzen und diese als Reaktion auf ecs_move-Ereignisse verschieben kann und gleichzeitig Kollisionen berücksichtigt.  Wie bei den meisten Widgets sind zwei Argumente erforderlich: eine verschachtelte Liste von Zeichen (möglicherweise leer - Leerzeichen oder Keine) und eine verschachtelte Liste von Farben für jedes Zeichen.  Benannte Farben werden als Farben akzeptiert, RGB im Format "0xAARRGGBB" (oder "0xARGB", "0xRGB", "0xRRGGBB") und im Format "#fff".  Die Größen beider Listen müssen übereinstimmen.  Andernfalls wird eine Ausnahme ausgelöst. <br><br><div class="spoiler">  <b class="spoiler_title">Erstes Widget</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   .  8460,   9160. # 7         chars = [[' ' for x in range(84)] for y in range(60)] colors = copy_shape(chars, 'gray') layout = ECSLayout(chars, colors) # 'all' -  ,      dispatcher.register_listener(layout, 'all')</span></span></code> </pre> <br></div></div><br>  Da wir jetzt wissen, worauf Objekte im Spiel platziert werden sollen, können wir mit dem Erstellen von Entitäten beginnen.  Der gesamte Code von Entitäten und Komponenten wird in eine separate Datei verschoben.  Die einfachste davon ist eine zerstörbare Mauer.  Sie weiß, wie man sich an einem bestimmten Ort befindet, ihr Widget anzeigt, als Kollisionsobjekt dient und Schaden erleidet.  Nach genügend Schaden verschwindet die Wand. <br><br><div class="spoiler">  <b class="spoiler_title">entity.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_wall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dispatcher, atlas, entity_id, x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   wall = Entity(entity_id) #  wall.add_component(PositionComponent(dispatcher, x, y)) wall.add_component(CollisionComponent(dispatcher)) wall.add_component(PassingComponent(dispatcher)) wall.add_component(DestructorComponent(dispatcher)) #     ,      #    -  /   images_dict = {'wall_3': atlas.get_element('wall_3'), 'wall_2': atlas.get_element('wall_2'), 'wall_1': atlas.get_element('wall_1')} wall.add_component(SwitchWidgetComponent(dispatcher, SwitchingWidget(images_dict=images_dict, initial_image='wall_3'))) wall.add_component(VisualDamageHealthComponent(dispatcher, hitpoints=3, widgets_dict={3: 'wall_3', 2: 'wall_2', 1: 'wall_1'})) #     dispatcher.add_event(BearEvent('ecs_create', wall)) dispatcher.add_event(BearEvent('ecs_add', (wall.id, wall.position.x, wall.position.y)))</span></span></code> </pre> <br></div></div><br>  Zunächst wird das Entitätsobjekt selbst erstellt.  Es enthält nur einen Namen (der eindeutig sein muss) und eine Reihe von Komponenten.  Sie können entweder bei der Erstellung auf einmal übertragen oder wie hier einzeln hinzugefügt werden.  Dann werden alle notwendigen Komponenten erstellt.  Als Widget wird SwitchWidget verwendet, das mehrere Zeichnungen derselben Größe enthält und diese per Befehl ändern kann.  Beim Erstellen eines Widgets werden übrigens Zeichnungen aus dem Atlas geladen.  Und schließlich werden die Ankündigung der Erstellung der Entität und die Reihenfolge, sie auf die erforderlichen Koordinaten zu zeichnen, in die Warteschlange gestellt. <br><br>  Von den nicht eingebauten Komponenten gibt es nur Gesundheit.  Ich habe die Basisklasse "Gesundheitskomponente" erstellt und von ihr das "Widget zum Ändern der Gesundheitskomponente" geerbt (um die Wand intakt und in mehreren Stadien der Zerstörung anzuzeigen). <br><br><div class="spoiler">  <b class="spoiler_title">Klasse HealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Component)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, hitpoints=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, name=<span class="hljs-string"><span class="hljs-string">'health'</span></span>, **kwargs) self.dispatcher.register_listener(self, <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>) self._hitpoints = hitpoints <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> event.event_value[<span class="hljs-number"><span class="hljs-number">0</span></span>] == self.owner.id: self.hitpoints -= event.event_value[<span class="hljs-number"><span class="hljs-number">1</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._hitpoints @hitpoints.setter <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> isinstance(value, int): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> BearECSException( <span class="hljs-string"><span class="hljs-string">f'Attempting to set hitpoints of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.owner.id}</span></span></span><span class="hljs-string"> to non-integer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{value}</span></span></span><span class="hljs-string">'</span></span>) self._hitpoints = value <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._hitpoints &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: self._hitpoints = <span class="hljs-number"><span class="hljs-number">0</span></span> self.process_hitpoint_update() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Should be overridden by child classes. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError(<span class="hljs-string"><span class="hljs-string">'HP update processing should be overridden'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#           return dumps({'class': self.__class__.__name__, 'hitpoints': self.hitpoints})</span></span></code> </pre> <br></div></div><br>  Beim Erstellen einer Komponente wird der Schlüssel 'name' an super () .__ init__ übergeben.  Wenn eine Komponente zu einer Entität hinzugefügt wird, wird sie unter dem Namen dieses Schlüssels zum __dict__ der Entität hinzugefügt und kann über entity_object.health aufgerufen werden.  Neben dem Komfort der Schnittstelle ist dieser Ansatz gut, da er die Ausgabe von Entitäten mehrerer homogener Komponenten verbietet.  Die Tatsache, dass es in der Komponente fest codiert ist, ermöglicht es Ihnen nicht, beispielsweise WidgetComponent fälschlicherweise in den Steckplatz der Integritätskomponente einzufügen.  Unmittelbar nach der Erstellung abonniert die Komponente die für sie interessanten Ereignisklassen, in diesem Fall ac_damage.  Nachdem die Methode on_event ein solches Ereignis erhalten hat, prüft sie eine Stunde lang, ob es sich um ihren Besitzer handelt.  In diesem Fall subtrahiert er den gewünschten Wert von den Trefferpunkten und zieht den Rückruf, um den Zustand zu ändern. Die Basisklasse ist abstrakt.  Es gibt auch die Methode __repr__, die für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serialisierung in JSON verwendet wird</a> (z. B. zum Speichern).  Es ist nicht erforderlich, es hinzuzufügen, aber alle integrierten Komponenten und die meisten integrierten Widgets haben es. <br><br>  Durch das Erben der zugrunde liegenden Integritätskomponente von VisualDamageHealthComponent wird der Rückruf bei Integritätsänderungen überschrieben: <br><br><div class="spoiler">  <b class="spoiler_title">Klasse VisualDamageHealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VisualDamageHealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(HealthComponent)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       .    HP=0 """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, widgets_dict={}, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self.widgets_dict = OrderedDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(widgets_dict.keys()): self.widgets_dict[int(x)] = widgets_dict[x] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hasattr(self.owner, <span class="hljs-string"><span class="hljs-string">'destructor'</span></span>): self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.widgets_dict: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints &gt;= x: self.owner.widget.switch_to_image(self.widgets_dict[x])</code> </pre> <br></div></div><br>  Während der Zustand über 0 liegt, fordert er die für das Widget verantwortliche Komponente auf, die Wand im gewünschten Zustand zu zeichnen.  Hier wird der oben beschriebene Aufruf über das Attribut des Entitätsobjekts verwendet.  Sobald die Trefferpunkte überschritten sind, werden die Komponente, die für die korrekte Zerstörung der Entität verantwortlich ist, und alle Komponenten auf dieselbe Weise aufgerufen. <br><br>  Bei anderen Entitäten ist alles ähnlich, nur die Komponenten sind unterschiedlich.  Panzer werden mit Controllern (Eingabe für den Spieler, KI für Gegner) und rotierenden Widgets für Muscheln hinzugefügt - eine Kollisionskomponente, die denjenigen Schaden zufügt, die sie treffen.  Ich werde nicht jeden von ihnen analysieren, weil es sperrig und eher trivial ist;  schau nur auf den Projektilkollider.  Es hat eine collided_into-Methode, die aufgerufen wird, wenn die Host-Entität gegen etwas stößt: <br><br><div class="spoiler">  <b class="spoiler_title">Bullet Component Collider</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collided_into</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, entity)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> entity: self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> hasattr(EntityTracker().entities[entity], <span class="hljs-string"><span class="hljs-string">'collision'</span></span>): self.dispatcher.add_event(BearEvent(event_type=<span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>, event_value=( entity, self.damage))) self.owner.destructor.destroy()</code> </pre> <br></div></div><br>  Um sicherzustellen, dass es möglich ist, ein Opfer zu finden (was beispielsweise für Hintergrundelemente falsch sein kann), verwendet das Projektil EntityTracker ().  Dies ist ein Singleton, der alle erstellten und zerstörten Entitäten verfolgt.  Durch sie können Sie ein Entitätsobjekt nach Namen abrufen und etwas mit seinen Komponenten tun.  In diesem Fall wird überprüft, ob entity.collision (der Opferkollisionshandler) überhaupt vorhanden ist. <br><br>  Jetzt rufen wir in der Hauptdatei des Spiels einfach alle notwendigen Funktionen zum Erstellen von Entitäten auf: <br><br><div class="spoiler">  <b class="spoiler_title">Zurück zu game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  , -     atlas = Atlas(XpLoader('battlecity.xp'), 'battlecity.json') #   create_player_tank(dispatcher, atlas, 30, 50) #    wall_array = [[0 for _ in range(14)], [0 for _ in range(14)], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0 for _ in range(14)], [0 for _ in range(14)], [0 for _ in range(14)] ] for y in range(10): for x in range(14): if wall_array[y][x] == 1: create_wall(dispatcher, atlas, f'wall{x}{y}', x*6, y*6) #   -  .     . create_spawner_house(dispatcher, atlas, 35, 0)</span></span></code> </pre> <br></div></div><br>  Punkt- und Trefferpunktzähler sind keine Einheiten und befinden sich nicht auf dem Schlachtfeld.  Daher werden sie nicht zu ECSLayout hinzugefügt, sondern direkt zum Terminal rechts von der Karte.  Relevante Widgets erben von Label (Textausgabe-Widget) und verfügen über eine on_event-Methode, um herauszufinden, was sie interessiert.  Im Gegensatz zu Layout aktualisiert das Terminal Widgets nicht automatisch bei jedem Tick. Nach dem Ändern des Texts weisen ihn die Widgets an, dies zu tun: <br><br><div class="spoiler">  <b class="spoiler_title">listeners.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScoreLabel</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Label)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(text=<span class="hljs-string"><span class="hljs-string">'Score:\n0'</span></span>) self.score = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ecs_destroy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'enemy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'bullet'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value: <span class="hljs-comment"><span class="hljs-comment">#    self.score += 10 self.text = f'Score:\n{self.score}' self.terminal.update_widget(self) class HPLabel(Label): """   """ def __init__(self, *args, **kwargs): super().__init__(text='HP:\n5') self.hp = 5 def on_event(self, event): if event.event_type == 'ac_damage' and event.event_value[0] == 'player': self.hp -= event.event_value[1] self.text = f'HP:\n{self.hp}' self.terminal.update_widget(self)</span></span></code> </pre> <br></div></div><br>  Der feindliche Generator und das Objekt, das für die Ausgabe von „GAME OVER“ verantwortlich ist, werden überhaupt nicht angezeigt und erben daher vom Listener.  Das Prinzip ist dasselbe: Objekte hören auf die Warteschlange, warten auf den richtigen Moment und erstellen dann eine Entität oder ein Widget. <br><br><div class="spoiler">  <b class="spoiler_title">Gameover</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    - . . . class GameOverListener(Listener): """       """ def __init__(self, *args, widget=None, **kwargs): print (args) super().__init__(*args, *kwargs) self.widget = widget def on_event(self, event): if event.event_type == 'ecs_destroy' and event.event_value == 'player': self.terminal.add_widget(self.widget, pos=(20, 20), layer=5)</span></span></code> </pre><br></div></div><br>  Jetzt haben wir alles geschaffen, was wir brauchen, und wir können das Spiel starten. <br><br><div class="spoiler">  <b class="spoiler_title">Wir starten</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,   Listeners    terminal.start() terminal.add_widget(layout) terminal.add_widget(score, pos=(85, 10)) terminal.add_widget(hp, pos=(85, 15))</span></span></code> </pre> <br></div></div><br>  Widgets werden dem Bildschirm erst nach dem Start hinzugefügt.  Entitäten können der Karte hinzugefügt werden, bevor - Erstellungsereignisse (in denen die gesamte Entität einschließlich des Widgets gespeichert ist) einfach in der Warteschlange gesammelt und beim ersten Häkchen aufgelöst werden.  Das Terminal kann Widgets jedoch erst hinzufügen, nachdem ein Fenster erfolgreich für das Terminal erstellt wurde. <br><br>  Zu diesem Zeitpunkt haben wir einen funktionierenden Prototyp, den Sie <s>in Early Access für zwanzig Dollar ausgeben</s> können, um Funktionen hinzuzufügen und das Gameplay zu verbessern.  Dies geht aber bereits über den Rahmen der heiligen Welt und damit des Artikels hinaus.  Ich werde nur hinzufügen, dass der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systempython</a> unabhängige Build mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pyinstaller erstellt werden kann</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470950/">https://habr.com/ru/post/de470950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470930/index.html">Gamification des Produkts. Verlauf Ratatype</a></li>
<li><a href="../de470934/index.html">Heilt vor der Hochzeit: Zellproliferation und Regenerationsfähigkeit von Quallen</a></li>
<li><a href="../de470938/index.html">So öffnen Sie einen Link in Python. Arbeiten mit WebBrowser und Lösen eines Problems mit Internet Explorer</a></li>
<li><a href="../de470940/index.html">MSK VUE.JS Meetup # 3 bei Mail.ru Group: Materialien von Mitap</a></li>
<li><a href="../de470942/index.html">Vom Anfänger bis zur Stilikone: Wie wir in 2GIS Auszeichnungen vergeben haben</a></li>
<li><a href="../de470952/index.html">Tipps und Tricks zur digitalen Forensik: Forensik-App „Your Phone“</a></li>
<li><a href="../de470954/index.html">Installieren Sie Zimbra OSE 8.8.15 und Zextras Suite Pro unter Ubuntu 18.04 LTS</a></li>
<li><a href="../de470958/index.html">Lebendigkeitssonden in Kubernetes können gefährlich sein</a></li>
<li><a href="../de470962/index.html">JSConf Budapest 2019</a></li>
<li><a href="../de470964/index.html">Holzspielzeug - Inschriften</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>