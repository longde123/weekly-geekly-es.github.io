<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§æüèº üàÇÔ∏è #‚É£ Num√©ros de latence sur iPhone üèà üíø üßú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Num√©ros de latence que chaque programmeur devrait conna√Ætre - un tableau des ¬´retards que chaque programmeur devrait conna√Ætre¬ª. Il contient les valeu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Num√©ros de latence sur iPhone</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/437590/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Num√©ros de latence que chaque programmeur devrait conna√Ætre</a> - un tableau des ¬´retards que chaque programmeur devrait conna√Ætre¬ª.  Il contient les valeurs moyennes de temps pour effectuer des op√©rations informatiques de base en 2012.  Il existe plusieurs vues alternatives pour ce tableau, et en voici une. <br><br><img src="https://habrastorage.org/webt/oa/i4/ho/oai4hogxseqehs_ciso1lz9q_io.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien</a> vers la source du sch√©ma</i> <br><br>  Mais quel est l'avantage pour les d√©veloppeurs mobiles de ces informations en 2019?  Il semble que non, mais <b>Dmitry Kurkin</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">SClown</a> ) de l'√©quipe Yandex.Navigator a pens√©: "A quoi ressemblerait la table pour un iPhone moderne?"  Ce qui en est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ressorti</a> , dans une version texte r√©vis√©e du rapport de Dmitry sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cyzo48f0exw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  √Ä quoi √ßa sert? </h2><br>  Pourquoi les programmeurs devraient-ils conna√Ætre ces chiffres?  Et sont-ils pertinents pour les d√©veloppeurs mobiles?  Il y a deux t√¢ches principales qui peuvent √™tre r√©solues √† l'aide de ces chiffres. <br><a name="habracut"></a><br><h3>  Comprendre l'√©chelle de temps d'un ordinateur </h3> <br>  Prenez une situation simple - une conversation t√©l√©phonique.  Nous pouvons facilement dire quand ce processus est rapide et quand il est long: quelques secondes est tr√®s rapide, quelques minutes est une conversation moyenne et une heure ou plus est tr√®s longue.  Le chargement des pages est similaire: en moins d'une seconde - rapidement, quelques secondes - supportable, et une minute est un d√©sastre, l'utilisateur peut ne pas attendre le t√©l√©chargement. <br><br>  Mais qu'en est-il des op√©rations telles que l'ajout d'un num√©ro √† un tableau - l'insertion tr√®s rapide dont les gens aiment parfois parler lors des entretiens?  Combien cela prend-il sur un smartphone?  Nanosecondes, microsecondes ou millisecondes?  J'ai rencontr√© peu de gens qui pouvaient dire qu'une milliseconde, c'est long, mais dans notre cas, c'est le cas. <br><br><h3>  Le rapport de la vitesse de divers composants informatiques </h3><br>  Le temps d'ex√©cution des op√©rations sur divers appareils peut varier de plusieurs dizaines ou centaines de fois.  Par exemple, le temps d'acc√®s √† la m√©moire principale est 100 fois diff√©rent de l'acc√®s au cache L1.  C'est une grande diff√©rence, mais pas infinie.  Si nous avons une signification sp√©cifique pour cela, alors lors de l'optimisation de nos applications, nous pouvons √©valuer s'il y aura un gain de temps ou non. <br><br><img src="https://habrastorage.org/webt/km/q5/ze/kmq5zekztqx_yhwcoyrjomhjcy4.png"><br><br><h2>  "Chiffres de latence" dans la vraie vie </h2><br>  Quand j'ai vu ces chiffres, je me suis int√©ress√© √† la diff√©rence entre le cache et l'acc√®s √† la m√©moire.  Si je mets soigneusement mes donn√©es dans 64 Ko, ce qui n'est pas si petit, alors mon code fonctionnera 100 fois plus vite - c'est rapide, tout volera! <br><br><img src="https://habrastorage.org/webt/-p/oh/fh/-pohfhloth8e4c-8sl2i5jdmbi4.png"><br><br>  J'ai imm√©diatement voulu v√©rifier tout cela, le montrer √† mes coll√®gues et l'appliquer dans la mesure du possible.  J'ai d√©cid√© de commencer avec l'outil standard qu'Apple propose - XCTest avec MeasureBlock.  Le test s'est organis√© comme suit: a allou√© un tableau, l'a rempli de nombres, leur XOR'il et a r√©p√©t√© l'algorithme 10 fois, c'est s√ªr.  Apr√®s cela, j'ai regard√© combien de temps cela prend pour un √©l√©ment. <br><br><table><tbody><tr><td>  <b>Taille du tampon</b> </td><td>  <b>Dur√©e totale</b> </td><td>  <b>Temps pour la chirurgie</b> </td></tr><tr><td>  50 kb </td><td>  1,5 ms </td><td>  30 ns </td></tr><tr><td>  500 kb </td><td>  12 ms </td><td>  24 ns </td></tr><tr><td>  5000 kb </td><td>  85 ms </td><td>  17 ns </td></tr></tbody></table><br>  La taille du tampon a augment√© 100 fois, et le temps pour l'op√©ration non seulement n'a pas augment√© 100 fois, mais a diminu√© presque 2 fois.  <i>Messieurs, officiers, ils nous ont trahis?!</i> <br><br>  Apr√®s un tel r√©sultat, de grands doutes ont surgi en moi que ces chiffres peuvent √™tre vus dans la vraie vie.  Il peut ne pas √™tre possible pour une application r√©guli√®re de d√©tecter cette diff√©rence.  Ou peut-√™tre que sur la plate-forme mobile, tout est diff√©rent. <br><br>  J'ai commenc√© √† chercher un moyen de voir la diff√©rence de performances entre les caches et la m√©moire principale.  Au cours de la recherche, je suis tomb√© sur un article o√π l'auteur se plaignait d'avoir un benchmark en cours d'ex√©cution sur son Mac et iPhone et n'a pas montr√© ces retards.  J'ai pris cet outil et j'ai obtenu le r√©sultat - comme dans une pharmacie.  Le temps d'acc√®s √† la m√©moire augmentait assez clairement lorsque la taille du tampon d√©passait la taille du cache correspondant. <br><br><img src="https://habrastorage.org/webt/he/_q/k8/he_qk85tbetz4emjxbp5znbqidc.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LMbench</a> m'a aid√© √† obtenir ces r√©sultats.  Il s'agit d'une r√©f√©rence cr√©√©e par Larry McVoy, l'un des d√©veloppeurs du noyau Linux, qui vous permet de mesurer le temps d'acc√®s √† la m√©moire, le co√ªt de commutation des threads et des op√©rations du syst√®me de fichiers, et m√™me le temps que prennent les op√©rations du processeur principal: addition, soustraction, etc. Selon cette r√©f√©rence Texas Instruments a pr√©sent√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des donn√©es de</a> mesure <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">int√©ressantes</a> pour ses processeurs.  LMBench est √©crit en C, il n'a donc pas √©t√© difficile de l'ex√©cuter sur iOS. <br><br><h2>  Co√ªts de la m√©moire </h2><br>  Arm√© d'un outil aussi merveilleux, j'ai d√©cid√© de faire des mesures similaires, mais pour un appareil mobile r√©el - pour l'iPhone.  Les principales mesures ont √©t√© effectu√©es sur le 5S, puis j'ai obtenu les r√©sultats alors que d'autres appareils tombaient entre mes mains.  Par cons√©quent, si le p√©riph√©rique n'est pas sp√©cifi√©, il s'agit de 5S. <br><br><h3>  Acc√®s m√©moire </h3><br>  Pour ce test, un tableau sp√©cial est utilis√©, qui est rempli d'√©l√©ments qui se r√©f√©rencent.  Chacun des √©l√©ments est un pointeur vers un autre √©l√©ment.  Le tableau n'est pas travers√© par un index, mais par des transitions d'un n≈ìud √† un autre.  Ces √©l√©ments sont dispers√©s √† travers le tableau de sorte que, lors de l'acc√®s √† un nouvel √©l√©ment, le plus souvent possible, il n'√©tait pas dans le cache, mais d√©charg√© de la RAM.  Cet arrangement interf√®re autant que possible avec les caches. <br><br>  Vous avez d√©j√† vu le r√©sultat pr√©liminaire.  Dans le cas du cache L1, c'est moins de 10 nanosecondes, pour L2 c'est quelques dizaines de nanosecondes, et dans le cas de la m√©moire principale, le temps passe √† des centaines de nanosecondes. <br><br><img src="https://habrastorage.org/webt/6u/dk/f0/6udkf0ihlo3lgfqhntfkzp3vshm.png"><br><br><h3>  Vitesse de lecture et d'√©criture </h3><br>  Trois op√©rations principales sont mesur√©es: <br><br><ul><li>  lecture ( <em>p [i] +</em> ) - nous lisons les √©l√©ments et les ajoutons au montant total; </li><li>  record ( <em>p [i] = 1</em> ) - un nombre constant est √©crit dans chaque √©l√©ment; </li><li>  lecture et √©criture ( <em>p [i] = p [i] * 2</em> ) - nous retirons l'√©l√©ment, le modifions et r√©√©crivons la nouvelle valeur. </li></ul><br>  Lorsque vous travaillez avec le tampon, 2 approches sont utilis√©es: dans le premier cas, seul un quatri√®me √©l√©ment est utilis√© et dans le second, tous les √©l√©ments sont s√©quentiellement. <br><br><img src="https://habrastorage.org/webt/yr/ke/ia/yrkeiaf0vzc47trw7wc_hypse-s.png"><br><br>  La vitesse la plus √©lev√©e est obtenue avec une petite taille de tampon, puis il y a des √©tapes claires, selon les tailles des caches L1 et L2.  La chose la plus int√©ressante est que lorsque les donn√©es sont lues s√©quentiellement, aucune r√©duction de vitesse ne se produit.  Mais dans le cas des passes, des √©tapes claires sont visibles. <br><br><img src="https://habrastorage.org/webt/2t/-d/_6/2t-d_68-oyjigkraj2mpirwjzfw.png"><br><br>  Pendant la lecture s√©quentielle, le syst√®me d'exploitation parvient √† charger les donn√©es n√©cessaires dans le cache, donc pour toute taille de tampon, je n'ai pas besoin d'acc√©der √† la m√©moire - toutes les donn√©es n√©cessaires sont obtenues √† partir du cache.  Cela explique pourquoi je n'ai pas vu la diff√©rence de temps dans mon test de base. <br><br>  Les r√©sultats des mesures des op√©rations de lecture et d'√©criture ont montr√© que dans une application normale, il est assez difficile d'obtenir l'acc√©l√©ration estim√©e de 100 fois.  D'une part, le syst√®me lui-m√™me cache assez bien les donn√©es, et m√™me avec de grands tableaux, nous sommes tr√®s susceptibles de trouver des donn√©es dans le cache.  Et d'autre part, travailler avec diverses variables peut facilement n√©cessiter un acc√®s √† la m√©moire et la perte de centaines de nanosecondes gagn√©es. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>La m√©moire</b> </td></tr><tr><td>  Num√©ros de latence </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td></tr></tbody></table><br><h2>  Co√ªts d'enfilage </h2><br>  Ensuite, je voulais obtenir des donn√©es similaires pour travailler avec des threads afin de <strong>comprendre le co√ªt de l'utilisation du multithreading</strong> : combien cela co√ªte-t-il de cr√©er un thread et de passer d'un thread √† un autre.  Pour nous, ce sont des op√©rations fr√©quentes, et je veux comprendre la perte. <br><br><h3>  Instruments.  Trace syst√®me </h3><br>  System Trace aide beaucoup √† suivre le travail des threads dans l'application.  Cet outil a √©t√© d√©crit en d√©tail lors de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WWDC 2016</a> .  L'outil permet de voir les transitions par conditions de flux et pr√©sente des donn√©es sur les flux dans trois cat√©gories principales: les appels syst√®me, l'utilisation de la m√©moire et les conditions de flux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hs/gx/kq/hsgxkqsh5khfclg4gncfbksihya.png" width="500"></div><br><br><ol><li>  <strong>Appels syst√®me</strong>  Ils sont pr√©sent√©s sous forme de "saucisses" rouges.  Lorsque vous les pointez, vous pouvez voir le nom de la m√©thode syst√®me et la dur√©e de l'ex√©cution.  Souvent, dans les applications d'application, un tel appel syst√®me ne se produit pas directement: nous utilisons quelque chose, qui √† son tour appelle d√©j√† la m√©thode syst√®me.  Vous ne devez pas compter sur le fait qu'ici les m√©thodes de votre code seront visibles. </li><li>  <strong>Op√©rations de m√©moire</strong> .  Ils sont pr√©sent√©s sous forme de "saucisses" bleues.  Cela inclut des op√©rations telles que l'allocation de m√©moire, la lib√©ration, la remise √† z√©ro, etc. </li><li>  <strong>Statut du flux</strong> .  Couleur bleue - un thread est en cours d'ex√©cution, certains processeurs ex√©cutent du code √† partir de ce thread.  Gris - le thread est bloqu√© pour une raison quelconque et ne peut pas continuer l'ex√©cution.  Rouge - le thread est pr√™t √† fonctionner, mais pour le moment il n'y a pas de noyau libre pour ex√©cuter son code.  Couleur orange - le flux est interrompu pour un travail de priorit√© plus √©lev√©e. </li><li> <strong>Points d'int√©r√™t</strong> .  Ce sont des √©tiquettes sp√©ciales qui peuvent √™tre organis√©es par code en appelant <code>kdebug_signpost</code> .  Les √©tiquettes peuvent √™tre uniques (un endroit sp√©cifique dans le code) ou sous forme de plage (pour mettre en √©vidence toute la proc√©dure).  En utilisant de telles √©tiquettes, il est beaucoup plus facile de corr√©ler les microsecondes et les appels syst√®me avec votre application. </li></ol><br><h3>  Co√ªts de cr√©ation de flux </h3><br>  Le premier test est l' <strong>ex√©cution d'une t√¢che dans un nouveau thread</strong> .  Nous cr√©ons un fil avec une certaine proc√©dure et attendons qu'il termine son travail.  En comparant le temps total avec le temps de la proc√©dure elle-m√™me, nous obtenons la perte totale pour d√©marrer la proc√©dure dans un nouveau thread. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m3/ln/wa/m3lnwaf0zdjx7b7suyujhp9eywu.png" width="600"></div><br><br>  Dans System Trace, vous pouvez voir clairement comment tout se passe vraiment: <br><br><img src="https://habrastorage.org/webt/wh/ta/qd/whtaqdwmfal7dyi4d-fs_22oir0.png"><br><br><ol><li>  Cr√©ez un flux. </li><li>  Le nouveau thread dans lequel notre proc√©dure s'ex√©cute.  La zone rouge au d√©but indique que le thread a √©t√© cr√©√©, mais pendant un certain temps, il n'a pas pu √™tre ex√©cut√©, car il n'y avait pas de noyau libre. </li><li>  L'ach√®vement du flux.  Fait int√©ressant, la proc√©dure d'ach√®vement du thread lui-m√™me est encore plus importante que sa cr√©ation.  Bien qu'il semble que la suppression soit toujours plus rapide. </li><li>  En attente de la fin de la proc√©dure, qui √©tait dans le sch√©ma d'origine, et elle se termine apr√®s la fin du flux - pendant un certain temps, la m√©thode s'en rend compte et, apr√®s cela, rend compte.  Cette dur√©e est l√©g√®rement plus longue que l'ach√®vement du flux. </li></ol><br>  En cons√©quence, la cr√©ation d'un flux n√©cessite des co√ªts assez importants: iPhone 5S - 230 microsecondes, 6S - 50 microsecondes.  <b>L'ach√®vement du flux prend presque 2 fois plus de temps que la cr√©ation</b> , la jointure prend √©galement un temps tangible.  Lorsque nous travaillons avec la m√©moire, nous avons obtenu des centaines de nanosecondes, ce qui est 100 fois moins que des dizaines de microsecondes. <br><br><table><tbody><tr><td></td><td>  <b>frais g√©n√©raux</b> </td><td>  <b>cr√©er</b> </td><td>  <b>fin</b> </td><td>  <b>rejoindre</b> </td></tr><tr><td>  iPhone 5s </td><td>  230 Œºs </td><td>  40 Œºs </td><td>  70 Œºs </td><td>  30 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  50 Œºs </td><td>  12 Œºs </td><td>  20 Œºs </td><td>  7 Œºs </td></tr></tbody></table><br><h3>  Temps de commutation du s√©maphore </h3><br>  Le prochain test est des <strong>mesures sur le travail du s√©maphore</strong> .  Nous avons 2 threads pr√©-cr√©√©s, et pour chacun d'eux il y a un s√©maphore.  Les flux signalent alternativement le s√©maphore du voisin et attendent le leur.  En se transmettant des signaux, les flux jouent au ping-pong, se ravivent.  Cette double it√©ration donne un temps de commutation double s√©maphore. <br><br><img src="https://habrastorage.org/webt/nf/de/iq/nfdeiqezf1edyugn_lkccjocndy.png"><br><br>  Dans System Trace, tout se ressemble: <br><br><ol><li>  Un signal est donn√© pour le s√©maphore du deuxi√®me flux.  On voit que cette op√©ration est tr√®s courte. </li><li>  Le deuxi√®me thread est d√©verrouill√©, l'attente sur son s√©maphore se termine. </li><li>  Un signal est donn√© pour le s√©maphore du premier flux. </li><li>  Le premier thread est d√©bloqu√©, l'attente sur son s√©maphore se termine. </li></ol><br><img src="https://habrastorage.org/webt/0e/jn/mb/0ejnmb3dxvozsz-h0zaijdl_3xm.png"><br><br>  Le temps de commutation √©tait dans les 10 microsecondes.  La diff√©rence avec la cr√©ation d'un thread par 50 fois est exactement la raison pour laquelle les pools de threads sont cr√©√©s, et non un nouveau thread pour chaque proc√©dure. <br><br><h3>  Pertes lors du changement de contexte du thread syst√®me </h3><br>  Dans les deux tests pr√©c√©dents, le transfert de contr√¥le entre les threads √©tait compl√®tement contr√¥l√© - nous avons clairement compris o√π et o√π la transition devait se produire.  Cependant, il arrive souvent que le syst√®me lui-m√™me passe d'un thread √† un autre.  Lorsque nous ex√©cutons plus de t√¢ches en parall√®le que les c≈ìurs de l'appareil, le syst√®me d'exploitation doit pouvoir se commuter lui-m√™me pour fournir √† chacun du temps processeur. <br><br>  Dans ce test, je voulais mesurer la perte de d√©marrage d'un trop grand nombre de threads.  Pour ce faire, un pool de 16 threads est cr√©√©, chacun d'eux attend un s√©maphore et, d√®s qu'il re√ßoit un signal, effectue une certaine proc√©dure et signale le s√©maphore en retour.  Le thread principal d√©marre le pool entier, donnant 16 signaux, puis attend 16 signaux en r√©ponse. <br><br><img src="https://habrastorage.org/webt/fv/ki/an/fvkiang1lid-dgw6bmddnudyjro.png"><br><br>  Dans System Trace, vous pouvez voir que les blocs sont dispers√©s de mani√®re al√©atoire, certains d'entre eux sont beaucoup plus longs que les autres.  Si plusieurs commutations entra√Ænent une augmentation du temps d'ex√©cution de l'op√©ration, le temps d'ex√©cution moyen devrait en cons√©quence augmenter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ar/0b/r6/ar0br6h-8hm8qwmlyokuots92au.png" width="500"></div><br>  <b>Cependant, avec une augmentation du nombre de threads, le temps de fonctionnement moyen n'augmente pas.</b> <br><br>  En th√©orie, le temps moyen doit √™tre conserv√© tant que la charge correspond √† la puissance de traitement.  Autrement dit, le nombre de t√¢ches correspond au nombre de c≈ìurs. <br><br><img src="https://habrastorage.org/webt/9r/8l/-p/9r8l-p83_ad6ibrit6ee2d67cwa.png"><br><br>  Si vous ex√©cutez plusieurs t√¢ches en parall√®le, le syst√®me d'exploitation, passant d'une t√¢che √† une autre, entra√Ænera des retards suppl√©mentaires.  Cela devrait se refl√©ter dans le r√©sultat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fe/0x/ko/fe0xko9wqlkfu5nt4n0fonqcrfs.png"></div><br>  En pratique, non seulement notre application fonctionne sur l'appareil, mais elle a encore de nombreux processus parall√®les et syst√®me.  M√™me le seul thread de notre application sera affect√© par la commutation, ce qui entra√Æne des interruptions et des retards.  Par cons√©quent, dans toutes les situations, il y a des retards, et il n'y a aucune diff√©rence entre cr√©er des t√¢ches en s√©rie ou ex√©cuter en parall√®le. <br><br><img src="https://habrastorage.org/webt/by/io/c4/byioc4ax6qgcuwxpkmjhpfyaaeg.png"><br><br>  Vous trouverez ci-dessous notre tableau des num√©ros de latence avec des donn√©es sur les flux et le s√©maphore. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>La m√©moire</b> </td><td>  <b>S√©maphore</b> </td></tr><tr><td>  Num√©ros de latence </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td><td>  25 ns </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td><td>  8 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td><td>  5 Œºs </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td><td>  3,2 Œºs </td></tr></tbody></table><br><h2>  Co√ªts des fichiers </h2><br>  Nous avons d√©j√† de la m√©moire et des threads - pour √™tre complet, nous n'avons besoin que des op√©rations du syst√®me de fichiers. <br><br><h3>  Lire le fichier </h3><br>  Le premier test est <strong>la vitesse de lecture</strong> - combien co√ªte la lecture d'un fichier.  Le test se compose de deux parties.  Dans la premi√®re, nous <strong>mesurons la vitesse de lecture</strong> en tenant compte de l'ouverture, de la lecture et de la fermeture du fichier.  Dans le second, nous <strong>supposons que le fichier est constamment ouvert</strong> : nous nous positionnons quelque part et lisons autant que nous voulons. <br><br>  Les r√©sultats sont correctement vus de deux points de vue.  <strong>Lorsque le fichier est petit</strong> , il y a un temps minimal pour lire les donn√©es du fichier.  Jusqu'√† un kilo-octet √©quivaut √† 5,3 microsecondes - peu importe: 1 octet, 2 ou 1 Ko - pour tous les 5,3 Œºs.  Par cons√©quent, vous ne pouvez parler de vitesse que dans le cas de fichiers volumineux, lorsque le temps fixe peut d√©j√† √™tre n√©glig√©.  L'op√©ration d'ouverture et de fermeture du fichier prend environ le m√™me temps pour n'importe quelle taille de fichier - dans le cas de 5S, environ 50 microsecondes. <br><br><img src="https://habrastorage.org/webt/zv/na/-2/zvna-2en_axstzffeo9iru-bpuo.png"><br><br>  Pour la vitesse de lecture, de tels graphiques sont obtenus. <br><br><img src="https://habrastorage.org/webt/h4/2g/ri/h42griw_vpjjlfgkpxdbty3c8yw.png"><br><br>  Pour l'iPhone X et un fichier de 1 Mo, la vitesse peut atteindre 20 Mo / s.  Fait int√©ressant, la lecture d'un fichier de 1 Mo est plus efficace.  Avec des fichiers de grande taille, les tailles de cache semblent √™tre affect√©es.  C'est pourquoi la vitesse baisse encore et se stabilise autour de 10 Mb. <br><br><h3>  Cr√©er et supprimer des fichiers </h3><br>  Le test consiste √† <strong>cr√©er un fichier et √† √©crire des donn√©es</strong> , et √† <strong>supprimer les</strong> fichiers cr√©√©s.  Le r√©sultat est pas √† pas: sur les petites tailles, le temps est stable - environ 7 Œºs, et continue de cro√Ætre.  L'√©chelle est logarithmique. <br><br><img src="https://habrastorage.org/webt/da/xn/sp/daxnspzyy0raugagyluwnkwjqhs.png"><br><br>  J'ai √©t√© surpris que le temps n√©cessaire pour supprimer un gros fichier soit proportionnel au temps n√©cessaire pour cr√©er, car je supposais que la suppression √©tait une op√©ration rapide.  Il s'av√®re que pour l'iPhone, la suppression dans le temps est comparable √† la cr√©ation d'un fichier.  Le tableau r√©capitulatif ressemble √† ceci. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>La m√©moire</b> </td><td>  <b>S√©maphore</b> </td><td>  <b>Disque</b> </td></tr><tr><td>  Num√©ros de latence </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td><td>  25 ns </td><td>  150 Œºs </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td><td>  8 Œºs </td><td>  5 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td><td>  5 Œºs </td><td>  4 Œºs </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td><td>  3,2 Œºs </td><td>  1,3 Œºs </td></tr></tbody></table><br><h2>  Conclusion </h2><br>  Sur la base de ces mesures, nous avons maintenant une id√©e du temps n√©cessaire aux op√©rations iOS de base: l'acc√®s √† la m√©moire est en nanosecondes, le travail avec des fichiers en microsecondes, la cr√©ation d'un flux repr√©sente des dizaines de microsecondes et la commutation n'est que de quelques microsecondes. <br><br>  Pour obtenir un blocage physiquement perceptible dans l'application, le temps d'ex√©cution de la proc√©dure doit d√©passer 15 millisecondes (le temps qu'il faut pour mettre √† jour l'√©cran √† 60fps).  C'est presque mille fois plus grand que la plupart des mesures prises dans l'article.  Sur une telle √©chelle, une milliseconde, c'est beaucoup, et une seconde est d√©j√† "pour toujours". <br><br>  Les tests ont montr√© que malgr√© la grande diff√©rence dans le temps d'acc√®s √† la m√©moire et aux caches, l'utilisation directe de ce rapport est assez difficile.  Avant de compiler toutes vos donn√©es sous L1, vous devez vous assurer que dans votre cas, cela donnera vraiment un r√©sultat. <br><br>  Selon les tests des op√©rations avec les threads, nous avons pu nous assurer que la cr√©ation et la destruction de threads n√©cessitent un temps consid√©rable, mais effectuer un grand nombre d'op√©rations parall√®les n'entra√Æne pas de co√ªts suppl√©mentaires. <br><br>  Eh bien, en conclusion, je voudrais vous rappeler la r√®gle la plus importante lorsque vous travaillez sur les performances - d' <b>abord les mesures et ensuite l'optimisation</b> ! <br><br>  Pr√©sentateur de profil Dmitry Kurkin sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br><blockquote>  La conversion et la transformation des rapports AppsConf 2018 en articles vont de pair avec la <b>pr√©paration de la toute nouvelle conf√©rence</b> 2019.  Jusqu'√† pr√©sent, il n'y a que 7 sujets dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste des rapports accept√©s</a> , mais cette liste s'allongera tout le temps pour qu'une conf√©rence sympa pour les d√©veloppeurs mobiles ait lieu <b>du 22 au 23 avril</b> . <br><br>  Suivez les publications, abonnez-vous √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cha√Æne youtube</a> et √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">newsletter</a> et cette fois passera rapidement. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437590/">https://habr.com/ru/post/fr437590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437580/index.html">Comment se souvenir d'un manuel JavaScript en 5 jours, ou du ¬´Palais de la m√©moire¬ª dans la vie quotidienne d'un programmeur</a></li>
<li><a href="../fr437582/index.html">Pr√©sentation de Vue.js 2.6</a></li>
<li><a href="../fr437584/index.html">Les bases math√©matiques de la mise en page automatique</a></li>
<li><a href="../fr437586/index.html">Nous cr√©ons une application vocale en utilisant l'exemple de Google Assistant</a></li>
<li><a href="../fr437588/index.html">Est-ce plus amusant √† d√©velopper pour les t√©l√©phones portables que pour le web?</a></li>
<li><a href="../fr437592/index.html">Architecture de couche d'ex√©cution de t√¢che asynchrone</a></li>
<li><a href="../fr437594/index.html">Comment j'ai √©radiqu√© la cause du b√©gaiement et du saut de trame dans tous les jeux, et aussi abaiss√© accidentellement la temp√©rature de 15 degr√©s</a></li>
<li><a href="../fr437596/index.html">OTRS: authentification, autorisation et synchronisation LDAP (FreeIPA, AD)</a></li>
<li><a href="../fr437598/index.html">Comment enregistrer le syst√®me de jeu √† partir d'un PC personnel au moyen de la virtualisation</a></li>
<li><a href="../fr437600/index.html">opencv4arts: Dessine ma ville, Vincent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>