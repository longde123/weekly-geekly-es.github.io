<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â£ï¸ â˜€ï¸ ğŸ‘ƒğŸ½ Python: bagaimana cara mengurangi konsumsi memori hingga setengahnya dengan menambahkan hanya satu baris kode? ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ¼ ğŸ’†ğŸ¼ ğŸ‘©ğŸ¾â€ğŸ¤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai habr. 

 Dalam satu proyek di mana perlu untuk menyimpan dan memproses daftar dinamis yang agak besar, penguji mulai mengeluh tentang kurangnya me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python: bagaimana cara mengurangi konsumsi memori hingga setengahnya dengan menambahkan hanya satu baris kode?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427909/">  Hai habr. <br><br>  Dalam satu proyek di mana perlu untuk menyimpan dan memproses daftar dinamis yang agak besar, penguji mulai mengeluh tentang kurangnya memori.  Cara sederhana untuk memperbaiki masalah dengan "darah kecil" dengan menambahkan hanya satu baris kode dijelaskan di bawah ini.  Hasilnya dalam gambar: <br><img src="https://habrastorage.org/webt/-z/zv/mu/-zzvmusqts90jkz_wityj3n1yia.png"><br><br>  Cara kerjanya, dilanjutkan di bawah luka. <a name="habracut"></a><br><br>  Pertimbangkan contoh "pelatihan" sederhana - buat kelas DataItem yang berisi data <s>pribadi</s> tentang seseorang, misalnya, nama, usia, dan alamat. <br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataItem</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, age, address)</span></span></span><span class="hljs-function">:</span></span> self.name = name self.age = age self.address = address</code> </pre> <br>  Pertanyaan "anak-anak" adalah berapa banyak benda seperti itu mengingat? <br><br>  Mari kita coba solusinya di dahi: <br><pre> <code class="python hljs">d1 = DataItem(<span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">"-"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"sys.getsizeof(d1):"</span></span>, sys.getsizeof(d1))</code> </pre> <br>  Kami mendapat respons 56 byte.  Sepertinya sedikit, cukup puas. <br>  Namun, kami memeriksa objek lain di mana ada lebih banyak data: <br><pre> <code class="python hljs">d2 = DataItem(<span class="hljs-string"><span class="hljs-string">"Boris"</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-string"><span class="hljs-string">"In the middle of nowhere"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"sys.getsizeof(d2):"</span></span>, sys.getsizeof(d2))</code> </pre> <br>  Jawabannya adalah lagi 56. Pada titik ini, kami memahami bahwa ada sesuatu yang tidak beres di sini, dan tidak semuanya sesederhana seperti yang terlihat pada pandangan pertama. <br><br>  Intuisi tidak mengecewakan kita, dan semuanya benar-benar tidak begitu sederhana.  Python adalah bahasa yang sangat fleksibel dengan pengetikan dinamis, dan untuk pekerjaannya, Python menyimpan banyak data tambahan.  Yang dengan sendirinya membutuhkan banyak.  Sama seperti contoh, sys.getsizeof ("") akan mengembalikan 33 - ya, sebanyak 33 byte per baris kosong!  Dan sys.getsizeof (1) akan mengembalikan 24 - 24 byte untuk integer (saya meminta programmer C untuk menjauh dari layar dan tidak membaca lebih lanjut, agar tidak kehilangan kepercayaan pada yang indah).  Untuk elemen yang lebih kompleks, seperti kamus, sys.getsizeof (dict ()) akan mengembalikan 272 byte - dan ini untuk kamus <i>kosong</i> .  Saya tidak akan melanjutkan, saya berharap prinsipnya jelas, <s>dan produsen RAM juga perlu menjual chip mereka</s> . <br><br>  Tetapi kembali ke kelas DataItem kami dan pertanyaan "anak".  Berapa lama kelas seperti itu mengingat?  Untuk mulai dengan, kami menampilkan seluruh konten kelas di tingkat yang lebih rendah: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> attr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dir(obj): print(<span class="hljs-string"><span class="hljs-string">" obj.%s = %r"</span></span> % (attr, getattr(obj, attr)))</code> </pre> <br>  Fungsi ini akan menunjukkan apa yang disembunyikan "di bawah tenda" sehingga semua fungsi Python (mengetik, warisan, dan barang lainnya) dapat berfungsi. <br>  Hasilnya mengesankan: <br><img src="https://habrastorage.org/webt/_l/w_/sf/_lw_sf57xadzzmacifxd8-hxiru.png"><br><br>  Berapa semua ini?  Di github ada fungsi yang menghitung jumlah data aktual, secara rekursif memanggil getsize untuk semua objek. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj, seen=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># From https://goshippo.com/blog/measure-real-size-any-python-object/ # Recursively finds size of objects size = sys.getsizeof(obj) if seen is None: seen = set() obj_id = id(obj) if obj_id in seen: return 0 # Important mark as seen *before* entering recursion to gracefully handle # self-referential objects seen.add(obj_id) if isinstance(obj, dict): size += sum([get_size(v, seen) for v in obj.values()]) size += sum([get_size(k, seen) for k in obj.keys()]) elif hasattr(obj, '__dict__'): size += get_size(obj.__dict__, seen) elif hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes, bytearray)): size += sum([get_size(i, seen) for i in obj]) return size</span></span></code> </pre><br>  Kami mencobanya: <br><pre> <code class="python hljs">d1 = DataItem(<span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">"-"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"get_size(d1):"</span></span>, get_size(d1)) d2 = DataItem(<span class="hljs-string"><span class="hljs-string">"Boris"</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-string"><span class="hljs-string">"In the middle of nowhere"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"get_size(d2):"</span></span>, get_size(d2))</code> </pre> <br>  Kami mendapatkan masing-masing 460 dan 484 byte, yang lebih mirip kebenaran. <br><br>  Memiliki fungsi ini, sejumlah percobaan dapat dilakukan.  Sebagai contoh, saya bertanya-tanya berapa banyak data yang akan diambil jika Anda meletakkan struktur DataItem dalam daftar.  Fungsi get_size ([d1]) mengembalikan 532 byte - rupanya ini adalah "sama" 460 + beberapa overhead.  Tetapi get_size ([d1, d2]) akan mengembalikan 863 byte - kurang dari 460 + 484 secara terpisah.  Yang lebih menarik adalah hasilnya untuk get_size ([d1, d2, d1]) - kami mendapatkan 871 byte, hanya sedikit lagi, yaitu.  Python cukup pintar untuk tidak mengalokasikan memori untuk objek yang sama untuk kedua kalinya. <br><br>  Sekarang kita beralih ke bagian kedua dari pertanyaan - apakah mungkin untuk mengurangi konsumsi memori?  Ya kamu bisa.  Python adalah penerjemah, dan kami dapat memperluas kelas kami kapan saja, misalnya, menambahkan bidang baru: <br><pre> <code class="python hljs">d1 = DataItem(<span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">"-"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"get_size(d1):"</span></span>, get_size(d1)) d1.weight = <span class="hljs-number"><span class="hljs-number">66</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"get_size(d1):"</span></span>, get_size(d1))</code> </pre> <br>  Ini bagus, tetapi jika kita <u>tidak membutuhkan</u> fungsi ini, kita bisa memaksa penerjemah untuk membuat daftar objek kelas menggunakan arahan __slots__: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataItem</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> __slots__ = [<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'age'</span></span>, <span class="hljs-string"><span class="hljs-string">'address'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, age, address)</span></span></span><span class="hljs-function">:</span></span> self.name = name self.age = age self.address = address</code> </pre><br>  Anda dapat membaca lebih lanjut di dokumentasi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTFM</a> ), yang mengatakan bahwa "__slots__ memungkinkan kami untuk secara eksplisit mendeklarasikan anggota data (seperti properti) dan menolak pembuatan __dict__ dan __weakref__. Ruang yang dihemat saat menggunakan __dict__ <i>dapat menjadi signifikan</i> ". <br>  Periksa: ya, sangat signifikan, get_size (d1) mengembalikan ... 64 byte, bukan 460, yaitu  7 kali lebih sedikit.  Sebagai bonus, objek dibuat sekitar 20% lebih cepat (lihat tangkapan layar pertama artikel). <br><br>  Sayangnya, dengan penggunaan nyata, keuntungan besar dalam memori tidak akan disebabkan oleh biaya overhead lainnya.  Mari kita buat array untuk 100.000 hanya dengan menambahkan elemen, dan lihat konsumsi memori: <br><pre> <code class="python hljs">data = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">100000</span></span>): data.append(DataItem(<span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">"middle of nowhere"</span></span>)) snapshot = tracemalloc.take_snapshot() top_stats = snapshot.statistics(<span class="hljs-string"><span class="hljs-string">'lineno'</span></span>) total = sum(stat.size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> stat <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> top_stats) print(<span class="hljs-string"><span class="hljs-string">"Total allocated size: %.1f MB"</span></span> % (total / (<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre><br>  Kami memiliki 16,8 MB tanpa __slots__ dan 6,9 MB dengan itu.  Tentu saja tidak 7 kali, tetapi meskipun demikian, mengingat bahwa perubahan kodenya minimal. <br><br>  Sekarang tentang kekurangannya.  Mengaktifkan __slots__ melarang pembuatan semua elemen, termasuk __dict__, yang berarti, misalnya, kode untuk menerjemahkan struktur ke json tidak akan berfungsi: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toJSON</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json.dumps(self.__dict__)</code> </pre><br>  Tapi itu mudah diperbaiki, cukup buat dict Anda secara terprogram, pilah-pilah semua elemen dalam loop: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toJSON</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> data = dict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__slots__: data[var] = getattr(self, var) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json.dumps(data)</code> </pre><br><br>  Juga tidak mungkin untuk menambahkan variabel baru secara dinamis ke kelas, tetapi dalam kasus saya ini tidak diperlukan. <br><br>  Dan tes terakhir untuk hari ini.  Sangat menarik untuk melihat berapa banyak memori seluruh program.  Tambahkan loop tanpa akhir di akhir program sehingga tidak menutup, dan lihat konsumsi memori pada task manager Windows. <br>  Tanpa __slots__: <br><img src="https://habrastorage.org/webt/rj/hf/ge/rjhfgeodoumssq5zlgh_ez0ocwq.png"><br>  16,8MB oleh beberapa keajaiban diubah (mengedit - penjelasan tentang keajaiban di bawah ini) menjadi 70MB (programmer C mudah-mudahan belum kembali ke layar?). <br><br>  Dengan __slots__ diaktifkan: <br><img src="https://habrastorage.org/webt/_o/5e/qu/_o5equjilnz9xaps6xegemhj_uy.png"><br><br>  6.9MB berubah menjadi 27MB ... yah, setelah semua, kami menghemat memori, 27MB bukannya 70 tidak begitu buruk untuk hasil penambahan satu baris kode. <br><br>  <b>Sunting</b> : di komentar (terima kasih kepada robert_ayrapetyan untuk pengujian), mereka menyarankan agar pustaka debug tracemalloc memakan banyak memori tambahan.  Rupanya, ia menambahkan elemen tambahan untuk <i>setiap</i> objek yang dibuat.  Jika Anda menonaktifkannya, total konsumsi memori akan jauh lebih sedikit, tangkapan layar menunjukkan 2 opsi: <br><img src="https://habrastorage.org/webt/-l/s0/ms/-ls0ms1ccsf6a5d3q-erfppenwk.png"><br><br>  Apa yang harus dilakukan jika Anda perlu menghemat lebih banyak memori?  Ini dimungkinkan menggunakan perpustakaan <b>numpy</b> , yang memungkinkan Anda membuat struktur gaya-C, tetapi dalam kasus saya ini akan membutuhkan penyempurnaan yang lebih dalam dari kode, dan metode pertama ternyata cukup cukup. <br><br>  Sungguh aneh bahwa penggunaan __slots__ belum pernah diperiksa secara rinci tentang HabrÃ©, saya harap artikel ini akan mengisi celah ini sedikit. <br><br>  Alih-alih sebuah kesimpulan. <br>  Artikel ini mungkin tampak seperti anti-iklan Python, tetapi sama sekali tidak.  Python sangat andal (Anda harus berusaha <i>sangat</i> keras untuk menjatuhkan program Python), bahasa yang mudah dibaca dan mudah untuk menulis kode.  Keuntungan ini lebih besar daripada yang kontra dalam banyak kasus, tetapi jika Anda membutuhkan kinerja dan efisiensi maksimum, Anda dapat menggunakan perpustakaan seperti numpy yang ditulis dalam C ++ yang bekerja dengan data cukup cepat dan efisien. <br><br>  Terima kasih atas perhatian Anda, dan kode yang baik :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427909/">https://habr.com/ru/post/id427909/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427897/index.html">Parsing a Magnetic Resonance Imager II: Metamaterials dalam MRI</a></li>
<li><a href="../id427899/index.html">JsonWriterSax - perpustakaan untuk membuat JSON</a></li>
<li><a href="../id427901/index.html">Bagaimana tidak menggunakan Node.js Stream API</a></li>
<li><a href="../id427905/index.html">Penambangan makanan atau persimpangan jalan melalui mata seorang hacker</a></li>
<li><a href="../id427907/index.html">Drone shooting, rake, life hacks, pengembangan diri dan karier seorang fotografer / videografer: podcast GLPH baru</a></li>
<li><a href="../id427911/index.html">Kesukaan kantor</a></li>
<li><a href="../id427913/index.html">Menghibur prolog # 2</a></li>
<li><a href="../id427915/index.html">Anggapan kebodohan</a></li>
<li><a href="../id427917/index.html">Membalas posting Presumption of the Mind</a></li>
<li><a href="../id427919/index.html">Porting COM ke Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>