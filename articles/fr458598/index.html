<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏾 🅿️ 👨🏼‍🔧 Reconnaissance des sources lumineuses sur les cartes de l'environnement 🗒️ 👐🏽 🤾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article présente une implémentation Python de l'algorithme de reconnaissance des sources lumineuses sur les cartes d'environnement (LDR ou HDR) à ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reconnaissance des sources lumineuses sur les cartes de l'environnement</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458598/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/e48/451/a44e484510a596be61f83f9c303f25fc.png" alt="image"></div><br>  Cet article présente une implémentation Python de l'algorithme de reconnaissance des sources lumineuses sur les cartes d'environnement (LDR ou HDR) à l'aide d'une projection équirectangulaire.  Cependant, après avoir apporté des modifications mineures, il peut également être utilisé avec de simples images d'arrière-plan ou des cartes cubiques.  Exemples d'application possible de l'algorithme: programmes de traçage de rayons dans lesquels il est nécessaire de reconnaître des sources lumineuses primaires pour en émettre des rayons;  dans les rendus pixellisés, il peut être utilisé pour projeter des ombres à l'aide d'une carte d'environnement;  en outre, l'algorithme peut également être utilisé dans des programmes d'élimination des projecteurs, par exemple en RA. <br><br>  L'algorithme comprend les étapes suivantes: <br><br><ol><li>  Diminution de la résolution de l'image d'origine, par exemple, à 1024. </li><li>  Convertissez l'image en luminosité (luminance), si nécessaire, avec un flou de l'image. </li><li>  Application de la méthode quasi-Monte Carlo. </li><li>  Transformation de coordonnées sphériques en coordonnées équidistantes. </li><li>  Filtrer les échantillons en fonction de la luminosité d'un voisin. </li><li>  Triez les échantillons en fonction de leur luminosité. </li><li>  Filtrage des échantillons basés sur la métrique euclidienne. </li><li>  Fusion d'échantillons à l'aide de l'algorithme de Bresenham. </li><li>  Calcul de la position du groupe d'éclairage en fonction de sa luminosité. </li></ol><br>  Il existe de nombreux algorithmes pour réduire la résolution des images.  Le filtrage bilinéaire est le plus rapide ou le plus facile à mettre en œuvre, et en plus, il est le mieux adapté dans la plupart des cas.  Pour convertir la luminosité des images LDR et HDR, vous pouvez utiliser la formule standard: <br><br><pre><code class="python hljs">lum = img[:, :, <span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">0.2126</span></span> + img[:, :, <span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">0.7152</span></span> + img[:, :, <span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">0.0722</span></span></code> </pre> <br>  De plus, vous pouvez appliquer un léger flou à l'image de luminosité, par exemple, 1 à 2 pixels pour une image avec une résolution de 1024, pour éliminer tous les détails haute fréquence (en particulier, causés par une diminution de la résolution). <br><a name="habracut"></a><br><h3>  Projection équidistante </h3><br>  La projection la plus courante dans les cartes d'environnement est la projection équidistante <sup>3</sup> .  Mon algorithme peut fonctionner avec d'autres projections, par exemple, avec des cartes panoramiques et cubiques, cependant, dans l'article, nous ne considérerons qu'une projection également espacée.  Vous devez d'abord normaliser les coordonnées de l'image: <br><br><pre> <code class="python hljs">pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = x / width pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = y / height</code> </pre> <br>  Ensuite, nous devons convertir des coordonnées cartésiennes à partir de coordonnées sphériques, c'est-à-dire  θ et φ, où θ = x * 2π, et φ = y * π. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sphereToEquirectangular</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pos)</span></span></span><span class="hljs-function">:</span></span> invAngles = (<span class="hljs-number"><span class="hljs-number">0.1591</span></span>, <span class="hljs-number"><span class="hljs-number">0.3183</span></span>) xy = (math.atan2(pos[<span class="hljs-number"><span class="hljs-number">1</span></span>], pos[<span class="hljs-number"><span class="hljs-number">0</span></span>]), math.asin(pos[<span class="hljs-number"><span class="hljs-number">2</span></span>])) xy = (xy[<span class="hljs-number"><span class="hljs-number">0</span></span>] * invAngles[<span class="hljs-number"><span class="hljs-number">0</span></span>], xy[<span class="hljs-number"><span class="hljs-number">1</span></span>] * invAngles[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (xy[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>, xy[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equirectangularToSphere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pos)</span></span></span><span class="hljs-function">:</span></span> angles = (<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">0.1591</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">0.3183</span></span>) thetaPhi = (pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) thetaPhi = (thetaPhi[<span class="hljs-number"><span class="hljs-number">0</span></span>] * angles[<span class="hljs-number"><span class="hljs-number">0</span></span>], thetaPhi[<span class="hljs-number"><span class="hljs-number">1</span></span>] * angles[<span class="hljs-number"><span class="hljs-number">1</span></span>]) length = math.cos(thetaPhi[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (math.cos(thetaPhi[<span class="hljs-number"><span class="hljs-number">0</span></span>]) * length, math.sin(thetaPhi[<span class="hljs-number"><span class="hljs-number">0</span></span>]) * length, math.sin(thetaPhi[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre> <br><h3>  Échantillonnage de Hammersley </h3><br>  La prochaine étape consistera à appliquer la méthode quasi-Monte Carlo, par exemple l'échantillonnage Hammersley <sup>2</sup> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f9/b07/70f/4f9b0770f72e69ede59e56a25258343d.png"></div><br>  Vous pouvez utiliser d'autres méthodes d'échantillonnage, comme Holton <sup>4</sup> , mais Hammersley est plus rapide et fournit une bonne répartition des échantillons à travers la sphère.  Holton serait un bon choix pour les échantillons d'avion si une simple image est utilisée à la place de la carte de l'environnement.  Une exigence obligatoire pour l'échantillonnage de Hammersley est l'inversion des racines (rangée) de van der Corpute, pour plus de détails, voir les liens <sup>2</sup> .  Voici sa mise en œuvre rapide: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vdcSequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits)</span></span></span><span class="hljs-function">:</span></span> bits = (bits &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (bits &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x55555555</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xAAAAAAAA</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x33333333</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xCCCCCCCC</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xF0F0F0F0</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) bits = ((bits &amp; <span class="hljs-number"><span class="hljs-number">0x00FF00FF</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((bits &amp; <span class="hljs-number"><span class="hljs-number">0xFF00FF00</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float(bits) * <span class="hljs-number"><span class="hljs-number">2.3283064365386963e-10</span></span> <span class="hljs-comment"><span class="hljs-comment"># / 0x100000000 def hammersleySequence(i, N): return (float(i) / float(N), vdcSequence(i))</span></span></code> </pre> <br>  Ensuite, nous utilisons une superposition uniforme sur la sphère: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sphereSample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function">:</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159265358979</span></span> phi = v * <span class="hljs-number"><span class="hljs-number">2.0</span></span> * PI cosTheta = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * u - <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-comment"><span class="hljs-comment"># map to -1,1 sinTheta = math.sqrt(1.0 - cosTheta * cosTheta); return (math.cos(phi) * sinTheta, math.sin(phi) * sinTheta, cosTheta)</span></span></code> </pre> <br>  Pour échantillonner Hammersley, nous utilisons un nombre fixe d'échantillons, en fonction de la résolution de l'image, et convertissons des coordonnées sphériques en cartésiennes, puis en équidistantes: <br><br><pre> <code class="python hljs"> samplesMultiplier = <span class="hljs-number"><span class="hljs-number">0.006</span></span> samples = int(samplesMultiplier * width * height) samplesList = [] <span class="hljs-comment"><span class="hljs-comment"># apply hammersley sampling for i in range(0, samples): xi = hammersleySequence(i, samples) xyz = sphereSample(xi[0], xi[1]) # to cartesian imagePos = sphereToEquirectangular(xyz) luminance = lum[imagePos[0] * width, imagePos[1] * height]</span></span></code> </pre> <br>  Cela nous donnera une bonne répartition des échantillons qui seront vérifiés pour la présence de sources lumineuses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/0a6/470/aa80a64703ef6e38cd0b73f9b02a5852.png"></div><br><h3>  Filtrage des sources lumineuses </h3><br>  Lors de la première passe de filtrage, nous ignorons tous les échantillons qui ne dépassent pas le seuil de luminosité (pour les cartes HDR, il peut être supérieur), puis trions tous les échantillons selon leur luminosité: <br><br><pre> <code class="python hljs"> localSize = int(float(<span class="hljs-number"><span class="hljs-number">12</span></span>) * (width / <span class="hljs-number"><span class="hljs-number">1024.0</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span> samplesList = [] <span class="hljs-comment"><span class="hljs-comment"># apply hammersley sampling for i in range(0, samples): xi = hammersleySequence(i, samples) xyz = sphereSample(xi[0], xi[1]) # to cartesian imagePos = sphereToEquirectangular(xyz) luminance = lum[imagePos [0] * width, imagePos [1] * height] sample = Sample(luminance, imagePos , xyz) luminanceThreshold = 0.8 #do a neighbour search for the maximum luminance nLum = computeNeighborLuminance(lum, width, height, sample.imagePos, localSize) if nLum &gt; luminanceThreshold: samplesList.append(sample) samplesList = sorted(samplesList, key=lambda obj: obj.luminance, reverse=True)</span></span></code> </pre> <br>  Le prochain passage filtrera en fonction de la métrique euclidienne et de la distance de seuil entre les pixels (en fonction de la résolution de l'image) - il s'agit d'une structure de données spatiales qui peut être utilisée pour se débarrasser de la complexité O (N <sup>2</sup> ): <br><br><pre> <code class="python hljs"> euclideanThreshold = int(float(euclideanThresholdPixel) * (width / <span class="hljs-number"><span class="hljs-number">2048.0</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># filter based euclidian distance filteredCount = len(samplesList) localIndices = np.empty(filteredCount); localIndices.fill(-1) for i in range(0, filteredCount): cpos = samplesList[i].pos if localIndices[i] == -1: localIndices[i] = i for j in range(0, filteredCount): if i != j and localIndices[j] == -1 and distance2d(cpos, samplesList[j].pos) &lt; euclideanThreshold: localIndices[j] = i</span></span></code> </pre> <br>  Les échantillons résultants passent par l'étape de fusion pour réduire davantage le nombre de sources lumineuses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/152/e1e/d39152e1e587c40c3ed29888faf02120.png"></div><br><h3>  Fusion de sources lumineuses </h3><br>  À la dernière étape, la fusion d'échantillons appartenant au même groupe d'éclairage est effectuée.  Pour ce faire, nous pouvons utiliser l'algorithme de Bresenham et commencer par les échantillons avec la luminosité la plus élevée, car ils sont déjà commandés.  Lorsque nous trouvons une source de lumière qui satisfait au test de Bresenham, nous utilisons sa position pour changer la position de la source en fonction du poids de la course: <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># apply bresenham check and compute position of the light clusters lights = [] finalIndices = np.empty(filteredCount); finalIndices.fill(-1) for i in localIndices: sample = samplesList[i] startPos = sample.pos if finalIndices[i] == -1: finalIndices[i] = i light = Light() light.originalPos = np.array(sample.pos) # position of the local maxima light.worldPos = np.array(sample.worldPos) light.pos = np.array(sample.pos) light.luminance = sample.luminance for j in localIndices: if i != j and finalIndices[j] == -1: endPos = samplesList[j].pos if bresenhamCheck(lum, width, height, startPos[0], startPos[1], endPos[0], endPos[1]): finalIndices[j] = i # compute final position of the light source sampleWeight = samplesList[j].luminance / sample.luminance light.pos = light.pos + np.array(endPos) * sampleWeight light.pos = light.pos / (1.0 + sampleWeight) imagePos = light.pos * np.array([1.0 / width, 1.0 / height) light.worldPos = equirectangularToSphere(imagePos) lights.append(light)</span></span></code> </pre> <br>  La fonction Bresenham recherche une ligne continue qui a la même luminosité.  Si le delta du pixel actuel dépasse un certain seuil, la vérification échoue: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bresenhamCheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lum, imageSize, x0, y0, x1, y1)</span></span></span><span class="hljs-function">:</span></span> dX = int(x1 - x0) stepX = int((dX &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) - (dX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) dX = abs(dX) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> dY = int(y1 - y0) stepY = int((dY &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) - (dY &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) dY = abs(dY) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> luminanceThreshold = <span class="hljs-number"><span class="hljs-number">0.15</span></span> prevLum = lum[x0][y0] sumLum = <span class="hljs-number"><span class="hljs-number">0.0</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dX &gt;= dY): <span class="hljs-comment"><span class="hljs-comment"># delta may go below zero delta = int (dY - (dX &gt;&gt; 1)) while (x0 != x1): # reduce delta, while taking into account the corner case of delta == 0 if ((delta &gt; 0) or (delta == 0 and (stepX &gt; 0))): delta -= dX y0 += stepY delta += dY x0 += stepX sumLum = sumLum + min(lum[x0][y0], 1.25) c = c + 1 if(abs(sumLum / c - prevLum) &gt; luminanceThreshold and (sumLum / c) &lt; 1.0): return 0 else: # delta may go below zero delta = int(dX - (dY &gt;&gt; 1)) while (y0 != y1): # reduce delta, while taking into account the corner case of delta == 0 if ((delta &gt; 0) or (delta == 0 and (stepY &gt; 0))): delta -= dY x0 += stepX delta += dX y0 += stepY sumLum = sumLum + min(lum[x0][y0], 1.25) c = c + 1 if(abs(sumLum / c - prevLum) &gt; luminanceThreshold and (sumLum / c) &lt; 1.0): return 0 return 1</span></span></code> </pre> <br>  Il convient de noter que, si nécessaire, des améliorations peuvent être apportées au test de Bresenham, ce qui conduira à une meilleure fusion des échantillons, par exemple, il peut prendre en compte le transfert horizontal des sources de lumière situées sur les bords de l'image.  De plus, la fonction peut être facilement étendue afin qu'elle se rapproche de la zone des sources lumineuses.  Autre amélioration: vous pouvez ajouter un seuil de distance pour ne pas combiner des échantillons trop éloignés.  Résultats finaux: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/4a8/fd9/4224a8fd98cec4203235bb4678ee6826.png"></div><br>  Le bleu indique les maxima locaux des groupes d'éclairage, le bleu représente les positions finales des sources lumineuses et le rouge désigne les échantillons qui font partie du même groupe d'éclairage et sont reliés par des lignes. <br><br>  Autres exemples de résultats: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/e48/451/a44e484510a596be61f83f9c303f25fc.png"></div><br><hr><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Détection de sources lumineuses dans les photographies numériques par Maciej Laskowski</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Points Hammersley sur l'hémisphère par Holger Dammertz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Projection équirectangulaire de Paul Reed</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Échantillonnage avec Hammersley et Halton Points par Tien-Tsin Wong</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458598/">https://habr.com/ru/post/fr458598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458584/index.html">11 juillet, Webinaire Group-IB «Analyse des logiciels malveillants pour les débutants: approches de base»</a></li>
<li><a href="../fr458590/index.html">Approches architecturales dans les applications iOS</a></li>
<li><a href="../fr458592/index.html">De la latence Ceph élevée au patch du noyau avec eBPF / BCC</a></li>
<li><a href="../fr458594/index.html">N'oubliez pas d'augmenter les chances de réponse au client en utilisant une demande répétée dans l'équilibrage L7</a></li>
<li><a href="../fr458596/index.html">Petty Little Joy # 6: OpenAI Gym - Jouez à des jeux et contrôlez des robots</a></li>
<li><a href="../fr458600/index.html">Que sont les vélos électriques (examen de groupe en deux parties de cinq modèles de deux fabricants), partie 1</a></li>
<li><a href="../fr458602/index.html">Comment nous avons percé le grand pare-feu chinois (partie 1)</a></li>
<li><a href="../fr458604/index.html">Pourquoi les deux plus grands fabricants d'électronique ont uni leurs forces dans un nouveau projet de GPU</a></li>
<li><a href="../fr458606/index.html">Exécutez OpenVPN dans Docker en 2 secondes</a></li>
<li><a href="../fr458608/index.html">Outils de développement Node.js File d'attente des travaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>