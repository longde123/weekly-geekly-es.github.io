<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏿 ☃️ 👼🏾 Bayangan 2D pada Bidang Jarak yang Ditandatangani 🕖 👨🏽‍🍳 💃🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekarang kita tahu dasar-dasar menggabungkan fungsi jarak yang ditandatangani, Anda dapat menggunakannya untuk membuat hal-hal keren. Dalam tutorial i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bayangan 2D pada Bidang Jarak yang Ditandatangani</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438942/"> Sekarang kita tahu dasar-dasar menggabungkan fungsi jarak yang ditandatangani, Anda dapat menggunakannya untuk membuat hal-hal keren.  Dalam tutorial ini, kita akan menggunakannya untuk membuat bayangan dua dimensi yang lembut.  Jika Anda belum membaca tutorial sebelumnya tentang bidang jarak yang ditandatangani (SDF), maka saya sangat menyarankan Anda mempelajarinya, dimulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial tentang cara membuat bentuk sederhana</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/el/eh/ylelehlfeymk9yzxs5eezpyzyfq.gif"></div><br>  [GIF menghasilkan artefak tambahan selama rekompresi.] <br><a name="habracut"></a><br><h2>  Konfigurasi dasar </h2><br>  Saya membuat konfigurasi sederhana dengan sebuah ruangan, menggunakan teknik yang dijelaskan dalam tutorial sebelumnya.  Sebelumnya, saya tidak menyebutkan bahwa saya menggunakan fungsi <code>abs</code> untuk vector2 untuk mencerminkan posisi relatif terhadap sumbu x dan y, dan juga bahwa saya membalikkan jarak gambar untuk menukar bagian dalam dan luar. <br><br>  Kami akan menyalin file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2D_SDF.cginc</a> dari tutorial sebelumnya ke dalam satu folder dengan shader, yang akan kami tulis dalam tutorial ini. <br><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/037_2D_SDF_Shadows"</span></span>{ Properties{ } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float bounds = -rectangle(position, 2); float2 quarterPos = abs(position); float corner = rectangle(translate(quarterPos, 1), 0.5); corner = subtract(corner, rectangle(position, 1.2)); float diamond = rectangle(rotate(position, 0.125), .5); float world = merge(bounds, corner); world = merge(world, diamond); return world; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); return dist; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  Jika kami masih menggunakan teknik visualisasi dari tutorial sebelumnya, angkanya akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ff/2cc/aee/5ff2ccaee5f12c0f87a1b7ae455bc044.png"></div><br><h2>  Bayangan sederhana </h2><br>  Untuk membuat bayangan yang tajam, kita berkeliling ruang dari posisi sampel ke posisi sumber cahaya.  Jika kita menemukan objek di jalan, kita memutuskan bahwa pixel harus diarsir, dan jika kita sampai ke sumber tanpa hambatan, kita mengatakan bahwa itu tidak diarsir. <br><br>  Kami mulai dengan menghitung parameter dasar balok.  Kami sudah memiliki titik awal (posisi piksel yang kami render) dan titik target (posisi sumber cahaya) untuk balok.  Kami membutuhkan panjang dan arah yang dinormalisasi.  Arah dapat diperoleh dengan mengurangi awal dari akhir dan menormalkan hasilnya.  Panjangnya dapat diperoleh dengan mengurangi posisi dan meneruskan nilai ke metode <code>length</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> direction = normalise(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = length(lightPosition - position); }</code> </pre> <br>  Kemudian kita mengulangi ray dalam loop.  Kami akan mengatur iterasi loop dalam deklarasi define, dan ini akan memungkinkan kami untuk mengkonfigurasi jumlah iterasi maksimum nanti, dan juga memungkinkan kompiler untuk sedikit mengoptimalkan shader dengan memperluas loop. <br><br>  Dalam loop, kita membutuhkan posisi kita sekarang, jadi kita mendeklarasikannya di luar loop dengan nilai awal 0. Dalam loop, kita dapat menghitung posisi sampel dengan menambahkan balok maju dikalikan dengan arah balok dengan posisi dasar.  Kemudian kita mencicipi fungsi jarak yang ditandatangani di posisi yang baru saja dihitung. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// outside of function #define SAMPLES 32 // in shadow function float rayDistance = 0; for(int i=0 ;i&lt;SAMPLES; i++){ float sceneDist = scene(pos + direction * rayDistance); //do other stuff and move the ray further }</span></span></code> </pre> <br>  Kemudian kita periksa untuk melihat apakah kita sudah pada titik di mana kita dapat menghentikan siklus.  Jika jarak adegan fungsi jarak dengan tanda dekat dengan 1, maka kita dapat mengasumsikan bahwa balok diblokir oleh gambar dan mengembalikan 0. Jika balok menyebar lebih jauh dari jarak ke sumber cahaya, kita dapat mengasumsikan bahwa kita mencapai sumber tanpa tabrakan dan mengembalikan nilai 1. <br><br>  Jika pengembalian tidak berhasil, maka Anda perlu menghitung posisi sampel selanjutnya.  Ini dilakukan dengan menambahkan jarak dalam adegan kemajuan balok.  Alasan untuk ini adalah bahwa jarak dalam adegan memberi kita jarak ke gambar terdekat, jadi jika kita menambahkan nilai ini ke balok, kita mungkin tidak akan bisa memancarkan balok lebih jauh dari angka terdekat, atau bahkan di luar itu, yang akan mengarah pada aliran bayangan. <br><br>  Jika kami tidak menemukan apa pun dan tidak mencapai sumber cahaya pada saat stok sampel selesai (siklus berakhir), kami juga harus mengembalikan nilainya.  Karena ini terutama terjadi di sebelah bentuk, sesaat sebelum piksel masih dianggap teduh, di sini kami menggunakan nilai balik 0. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAMPLES 32 float traceShadows(float2 position, float2 lightPosition){ float2 direction = normalize(lightPosition - position); float lightDistance = length(lightPosition - position); float rayProgress = 0; for(int i=0 ;i</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SAMPLES; i++){ float sceneDist = scene(position + direction * rayProgress); if(sceneDist &lt;= 0){ return 0; } if(rayProgress &gt; lightDistance){ return 1; } rayProgress = rayProgress + sceneDist; } return 0; }</span></span></span></span></code> </pre> <br>  Untuk menggunakan fungsi ini, kami menyebutnya dalam fungsi fragmen dengan posisi piksel dan posisi sumber cahaya.  Lalu kami mengalikan hasilnya dengan warna apa saja untuk mencampurnya dengan warna sumber cahaya. <br><br>  Saya juga menggunakan teknik yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial pertama tentang bidang jarak dengan tanda</a> untuk memvisualisasikan geometri.  Lalu saya baru saja menambahkan lipatan dan geometri.  Di sini kita cukup menggunakan operasi penjumlahan, dan tidak melakukan interpolasi linier atau tindakan serupa, karena bentuknya hitam di mana-mana di mana bentuknya tidak, dan bayangannya hitam di mana pun bentuknya. <br><br> <code>fixed4 frag(v2f i) : SV_TARGET{ float2 position = i.worldPos.xz;</code> <br> <br><pre> <code class="cpp hljs">float2 lightPos; sincos(_Time.y, lightPos.x <span class="hljs-comment"><span class="hljs-comment">/*sine of time*/</span></span>, lightPos.y <span class="hljs-comment"><span class="hljs-comment">/*cosine of time*/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadows = traceShadows(position, lightPos); float3 light = shadows * float3(<span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = scene(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(sceneDistance) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> binaryScene = smoothstep(distanceChange, -distanceChange, sceneDistance); float3 geometry = binaryScene * float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); float3 col = geometry + light; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(col, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/29f/0cc/3e529f0cc0c90767d42bf4c14916f377.gif"></div><br><h2>  Bayangan lembut </h2><br>  Mulai dari bayangan yang keras ini menjadi lebih lembut dan lebih realistis cukup mudah.  Dalam hal ini, shader tidak menjadi mahal secara komputasi. <br><br>  Pertama, kita cukup mendapatkan jarak ke objek pemandangan terdekat untuk setiap sampel yang kita bypass, dan pilih yang terdekat.  Lalu tempat kami dulu mengembalikan 1, akan mungkin untuk mengembalikan jarak ke angka terdekat.  Agar kecerahan bayangan tidak terlalu tinggi dan tidak mengarah pada penciptaan warna aneh, kami akan meneruskannya melalui metode <code>saturate</code> , yang membatasi ke interval dari 0 hingga 1. Kami mendapatkan minimum antara gambar terdekat saat ini dan yang berikutnya setelah memeriksa apakah berkas sumber cahaya telah mencapai distribusi. jika tidak, kita dapat mengambil sampel yang melampaui sumber cahaya dan mendapatkan artefak aneh. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition)</span></span></span></span>{ float2 direction = normalize(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightDistance = length(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rayProgress = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nearest = <span class="hljs-number"><span class="hljs-number">9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span> ;i&lt;SAMPLES; i++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDist = scene(position + direction * rayProgress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sceneDist &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rayProgress &gt; lightDistance){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(nearest); } nearest = min(nearest, sceneDist); rayProgress = rayProgress + sceneDist; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/953/680/6af9536801d8eba4596b10e55aba7c3b.png"></div><br>  Hal pertama yang kita perhatikan setelah ini adalah "gigi" aneh di bayang-bayang.  Mereka muncul karena jarak dari tempat kejadian ke sumber cahaya kurang dari 1. Saya mencoba untuk menangkal ini dengan berbagai cara, tetapi tidak dapat menemukan solusi.  Sebaliknya, kita bisa menerapkan ketajaman bayangan.  Ketajaman akan menjadi parameter lain dalam fungsi bayangan.  Dalam lingkaran, kita mengalikan jarak dalam adegan dengan ketajaman, dan kemudian dengan ketajaman 2, bagian abu-abu yang lembut dan abu-abu dari bayangan akan menjadi setengahnya.  Saat menggunakan ketajaman, sumber cahaya dapat berasal dari gambar pada jarak minimal 1 dibagi dengan ketajaman, jika tidak, artefak akan muncul.  Karena itu, jika Anda menggunakan ketajaman 20, maka jaraknya harus setidaknya 0,05 unit. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hardness)</span></span></span></span>{ float2 direction = normalize(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightDistance = length(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rayProgress = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nearest = <span class="hljs-number"><span class="hljs-number">9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span> ;i&lt;SAMPLES; i++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDist = scene(position + direction * rayProgress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sceneDist &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rayProgress &gt; lightDistance){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(nearest); } nearest = min(nearest, hardness * sceneDist); rayProgress = rayProgress + sceneDist; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in fragment function float shadows = traceShadows(position, lightPos, 20);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/610/70b/5a4/61070b5a42c96ac0d121b8aa7f2130ae.png"></div><br>  Dengan meminimalkan masalah ini, kami perhatikan hal berikut: bahkan di area yang tidak boleh diarsir, pelemahan masih terlihat di dekat dinding.  Selain itu, kelembutan bayangan tampaknya sama untuk seluruh bayangan, dan tidak tajam di sebelah gambar dan lebih lembut ketika bergerak menjauh dari objek yang memancarkan bayangan. <br><br>  Kami akan memperbaikinya dengan membagi jarak dalam adegan dengan perambatan balok.  Berkat ini, kami akan membagi jarak menjadi angka yang sangat kecil di awal balok, yaitu, kami masih akan mendapatkan nilai tinggi dan bayangan jernih yang indah.  Ketika kita menemukan titik terdekat dengan sinar pada titik berikutnya dalam sinar, titik terdekat dibagi dengan jumlah yang lebih besar, yang membuat bayangan lebih lembut.  Karena ini tidak sepenuhnya terkait dengan jarak terpendek, kami akan mengganti nama variabel menjadi <code>shadow</code> . <br><br>  Kami juga akan membuat satu perubahan kecil lagi: karena kami membaginya dengan rayProgress, Anda tidak boleh memulai dengan 0 (membaginya dengan nol hampir selalu merupakan ide yang buruk).  Sebagai permulaan, Anda dapat memilih angka yang sangat kecil. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hardness)</span></span></span></span>{ float2 direction = normalize(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightDistance = length(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rayProgress = <span class="hljs-number"><span class="hljs-number">0.0001</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadow = <span class="hljs-number"><span class="hljs-number">9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span> ;i&lt;SAMPLES; i++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDist = scene(position + direction * rayProgress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sceneDist &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rayProgress &gt; lightDistance){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(shadow); } shadow = min(shadow, hardness * sceneDist / rayProgress); rayProgress = rayProgress + sceneDist; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e46/715/305/e46715305ef51c3016c4d56b34f47a8d.png"></div><br><h2>  Berbagai Sumber Penerangan </h2><br>  Dalam implementasi single-core yang sederhana ini, cara termudah untuk mendapatkan banyak sumber cahaya adalah dengan menghitungnya secara individual dan menambahkan hasilnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ float2 position = i.worldPos.xz; float2 lightPos1 = float2(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y), <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadows1 = traceShadows(position, lightPos1, <span class="hljs-number"><span class="hljs-number">20</span></span>); float3 light1 = shadows1 * float3(<span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); float2 lightPos2 = float2(-<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y) * <span class="hljs-number"><span class="hljs-number">1.75</span></span>, <span class="hljs-number"><span class="hljs-number">1.75</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadows2 = traceShadows(position, lightPos2, <span class="hljs-number"><span class="hljs-number">10</span></span>); float3 light2 = shadows2 * float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = scene(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(sceneDistance) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> binaryScene = smoothstep(distanceChange, -distanceChange, sceneDistance); float3 geometry = binaryScene * float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); float3 col = geometry + light1 + light2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(col, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3b/b70/6ce/a3bb706cec13c16a54d8d740b0d91589.gif"></div><br><h2>  Kode sumber </h2><br><h3>  Pustaka SDF dua dimensi (tidak berubah, tetapi digunakan di sini) </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/037_SDF_2D_Shadows/2D_SDF.cginc</a> </li></ul><br><h3>  Bayangan lembut dua dimensi </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/037_SDF_2D_Shadows/2D_SDF_Shadows.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/037_2D_SDF_Shadows"</span></span>{ Properties{ } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float bounds = -rectangle(position, 2); float2 quarterPos = abs(position); float corner = rectangle(translate(quarterPos, 1), 0.5); corner = subtract(corner, rectangle(position, 1.2)); float diamond = rectangle(rotate(position, 0.125), .5); float world = merge(bounds, corner); world = merge(world, diamond); return world; } #define STARTDISTANCE 0.00001 #define MINSTEPDIST 0.02 #define SAMPLES 32 float traceShadows(float2 position, float2 lightPosition, float hardness){ float2 direction = normalize(lightPosition - position); float lightDistance = length(lightPosition - position); float lightSceneDistance = scene(lightPosition) * 0.8; float rayProgress = 0.0001; float shadow = 9999; for(int i=0 ;i&lt;SAMPLES; i++){ float sceneDist = scene(position + direction * rayProgress); if(sceneDist &lt;= 0){ return 0; } if(rayProgress &gt; lightDistance){ return saturate(shadow); } shadow = min(shadow, hardness * sceneDist / rayProgress); rayProgress = rayProgress + max(sceneDist, 0.02); } return 0; } fixed4 frag(v2f i) : SV_TARGET{ float2 position = i.worldPos.xz; float2 lightPos1 = float2(sin(_Time.y), -1); float shadows1 = traceShadows(position, lightPos1, 20); float3 light1 = shadows1 * float3(.6, .6, 1); float2 lightPos2 = float2(-sin(_Time.y) * 1.75, 1.75); float shadows2 = traceShadows(position, lightPos2, 10); float3 light2 = shadows2 * float3(1, .6, .6); float sceneDistance = scene(position); float distanceChange = fwidth(sceneDistance) * 0.5; float binaryScene = smoothstep(distanceChange, -distanceChange, sceneDistance); float3 geometry = binaryScene * float3(0, 0.3, 0.1); float3 col = geometry + light1 + light2; return float4(col, 1); } ENDCG } } FallBack "Standard" }</span></span></code> </pre> <br>  Ini hanyalah salah satu dari banyak contoh penggunaan bidang jarak yang ditandatangani.  Sejauh ini mereka agak rumit, karena semua bentuk harus didaftarkan di shader atau melewati properti shader, tapi saya punya beberapa ide tentang cara membuatnya lebih nyaman untuk tutorial di masa depan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438942/">https://habr.com/ru/post/id438942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438930/index.html">Pihak berwenang mengubah strategi kontrol internet secara mendasar</a></li>
<li><a href="../id438932/index.html">Pengenalan Pola dalam Inteligensi Buatan Buatan</a></li>
<li><a href="../id438934/index.html">Buat dan konfigurasikan pembuatan portabel Lab dan Notebook Jupyter di Windows. Bagian 1</a></li>
<li><a href="../id438936/index.html">Kenalan BotMan</a></li>
<li><a href="../id438940/index.html">Kursus terbuka "Belajar dalam-dalam dengan jari"</a></li>
<li><a href="../id438946/index.html">DateTimeOffset (Ketat)</a></li>
<li><a href="../id438948/index.html">Mengapa kita perlu optimasi tingkat rendah pada Elbrus atau bagaimana mempercepat sistem pengenalan satu setengah kali</a></li>
<li><a href="../id438950/index.html">Bank Sentral meluncurkan robot untuk mencari skema penghasilan di Internet</a></li>
<li><a href="../id438952/index.html">Apa yang dapat Anda pelajari saat mengembangkan pemutar audio untuk berbagai browser</a></li>
<li><a href="../id438954/index.html">Menggabungkan Bidang Jarak yang Ditandatangani dalam 2D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>