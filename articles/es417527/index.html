<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèæ ü§≠ üëÜüèº Desarrollamos camarones: controlamos solicitudes paralelas, iniciamos sesi√≥n a trav√©s de spdlog y m√°s ... üëçüèΩ üïâÔ∏è üßëüèæ‚Äçü§ù‚Äçüßëüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La semana pasada, hablamos sobre nuestro peque√±o proyecto de demostraci√≥n, Shrimp , que muestra claramente c√≥mo puede usar las bibliotecas C ++ RESTin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollamos camarones: controlamos solicitudes paralelas, iniciamos sesi√≥n a trav√©s de spdlog y m√°s ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417527/"><img src="https://habrastorage.org/webt/6p/er/na/6pernaqwjoqg3picsc4pz2d1xba.jpeg"><br><br>  La semana pasada, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hablamos sobre nuestro peque√±o proyecto de demostraci√≥n, Shrimp</a> , que muestra claramente c√≥mo puede usar las bibliotecas C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RESTinio</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> en condiciones m√°s o menos similares.  Shrimp es una peque√±a aplicaci√≥n C ++ 17 que, a trav√©s de RESTinio, acepta solicitudes HTTP para escalar im√°genes y atiende estas solicitudes en modo de subprocesos m√∫ltiples a trav√©s de SObjectizer e ImageMagick ++. <br><br>  El proyecto result√≥ ser m√°s que √∫til para nosotros.  La alcanc√≠a de la lista de deseos para ampliar la funcionalidad de RESTinio y SObjectizer se ha reabastecido significativamente.  Algo que incluso se ha incorporado en una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versi√≥n</a> muy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reciente de RESTinio-0.4.7</a> .  As√≠ que decidimos no detenernos en la primera y m√°s trivial versi√≥n de Shrimp, sino hacer una o dos iteraciones m√°s en torno a este proyecto.  Si alguien est√° interesado en qu√© y c√≥mo lo hemos hecho durante este tiempo, eres bienvenido con cat. <br><blockquote>  Como spoiler: hablaremos sobre c√≥mo nos deshicimos del procesamiento paralelo de solicitudes id√©nticas, c√≥mo agregamos el registro a Shrimp utilizando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">excelente biblioteca spdlog</a> , y tambi√©n hicimos un comando para forzar el reinicio del cach√© de im√°genes transformadas. </blockquote><a name="habracut"></a><h1>  v0.3: control de procesamiento paralelo de solicitudes id√©nticas </h1><br>  La primera versi√≥n de Shrimp, descrita en un art√≠culo anterior, conten√≠a una seria simplificaci√≥n: no hab√≠a control sobre si la misma solicitud se est√° procesando actualmente o no. <br><br>  Imagine que por primera vez Shrimp recibe una solicitud del formulario "/demo.jpg?op=resize&amp;max=1024".  Todav√≠a no existe dicha imagen en el cach√© de im√°genes transformadas, por lo que la solicitud se est√° procesando.  El procesamiento puede llevar un tiempo considerable, por ejemplo, unos pocos cientos de milisegundos. <br><br>  El proceso de solicitud a√∫n no se ha completado, y Shrimp nuevamente recibe la misma solicitud "/demo.jpg?op=resize&amp;max=1024", pero de otro cliente.  A√∫n no hay resultados de transformaci√≥n en la memoria cach√©, por lo tanto, esta solicitud tambi√©n se procesar√°. <br><br>  Ni la primera ni la segunda solicitud a√∫n se han completado, y Shrimp puede recibir nuevamente la misma solicitud "/demo.jpg?op=resize&amp;max=1024".  Y esta solicitud tambi√©n ser√° procesada.  Resulta que la misma imagen se escala al mismo tama√±o en paralelo varias veces. <br><br>  Esto no es bueno  Por lo tanto, lo primero que decidimos en Shrimp fue deshacernos de una jamba tan seria.  Hicimos esto debido a dos contenedores dif√≠ciles en el agente transform_manager.  El primer contenedor es una cola de espera de solicitudes de transformador gratuitas.  Este es un contenedor llamado m_pending_requests.  El segundo contenedor almacena solicitudes que ya han sido procesadas (es decir, se asignaron transformadores espec√≠ficos a estas solicitudes).  Este es un contenedor llamado m_inprogress_requests. <br><br>  Cuando transform_manager recibe la siguiente solicitud, comprueba la presencia de la imagen terminada en el cach√© de im√°genes transformadas.  Si no hay una imagen convertida, se comprueban los contenedores m_inprogress_requests y m_pending_requests.  Y si no hay una solicitud con tales par√°metros en ninguno de estos contenedores, solo entonces se intenta colocar la solicitud en la cola m_pending_requests.  Se ve <a href="">as√≠</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br>  Se dijo anteriormente que m_inprogress_requests y m_pending_requests son contenedores complicados.  Pero cual es el truco? <br><br>  El truco es que estos contenedores combinan las propiedades de una cola FIFO regular (en la que se conserva el orden cronol√≥gico de la adici√≥n de elementos) y multimapas, es decir.  Un contenedor asociativo en el que se pueden asignar m√∫ltiples valores a una sola clave. <br><br>  Mantener el orden cronol√≥gico es importante, ya que los elementos m√°s antiguos en m_pending_requests deben verificarse peri√≥dicamente y eliminarse de m_pending_requests aquellas solicitudes para las que se excede el tiempo de espera m√°ximo.  Y se necesita un acceso efectivo a los elementos por clave tanto para verificar la presencia de solicitudes id√©nticas en las colas, como para que todas las solicitudes duplicadas se puedan eliminar de la cola a la vez. <br><br>  En Shrimp, ciclamos <a href="">nuestro peque√±o contenedor</a> para estos fines.  Aunque, si Boost se usara en Shrimp, Boost.MultiIndex podr√≠a usarse.  Y, probablemente, con el tiempo, ser√° necesario organizar una b√∫squeda efectiva en m_pending_requests por alg√∫n otro criterio, luego Boost.MultiIndex en Shrimp tendr√° que activarse. <br><br><h1>  v0.4: inicio de sesi√≥n con spdlog </h1><br>  Intentamos dejar la primera versi√≥n de Shrimp lo m√°s simple y compacta posible.  Por eso, en la primera versi√≥n de Shrimp, no utilizamos el registro.  En general <br><br>  Por un lado, esto hizo posible mantener conciso el c√≥digo de la primera versi√≥n, que no conten√≠a m√°s que la l√≥gica comercial necesaria de Shrimp.  Pero, por otro lado, la falta de tala complica tanto el desarrollo del camar√≥n como su funcionamiento.  Por lo tanto, tan pronto como lo pusimos en nuestras manos, inmediatamente arrastramos a Shrimp una excelente biblioteca moderna de C ++ para el registro: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">spdlog</a> .  La respiraci√≥n se hizo m√°s f√°cil de inmediato, aunque el c√≥digo de algunos m√©todos creci√≥ en volumen. <br><br>  Por ejemplo, el c√≥digo anterior del m√©todo handle_not_transformed_image () con el registro comienza a parecerse a <a href="">esto</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . m_logger-&gt;debug( "same request is already in progress; request_key={}", request_key ); //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . m_logger-&gt;debug( "same request is already pending; request_key={}", request_key ); store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . m_logger-&gt;debug( "store request to pending requests queue; request_key={}", request_key ); store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . m_logger-&gt;warn( "request is rejected because of overloading; " "request_key={}", request_key ); do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br><h2>  Configurar registradores spdlog </h2><br>  El inicio de sesi√≥n en Shrimp se realiza en la consola (es decir, en la secuencia de salida est√°ndar).  En principio, uno podr√≠a seguir un camino muy simple y crear en Shrimp la √∫nica instancia del spd-logger.  Es decir  uno podr√≠a llamar a <a href="">stdout_color_mt</a> (o <a href="">stdout_logger_mt</a> ), y luego pasar este registrador a todas las entidades en Shrimp.  Pero tomamos un camino un poco m√°s complicado: creamos manualmente el llamado  sumidero (es decir, el canal donde spdlog generar√° los mensajes generados), y para las entidades Shrimp crearon registradores separados adjuntos a este sumidero. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     . [[nodiscard]] spdlog::sink_ptr make_logger_sink() { auto sink = std::make_shared&lt; spdlog::sinks::ansicolor_stdout_sink_mt &gt;(); return sink; } [[nodiscard]] std::shared_ptr&lt;spdlog::logger&gt; make_logger( const std::string &amp; name, spdlog::sink_ptr sink, spdlog::level::level_enum level = spdlog::level::trace ) { auto logger = std::make_shared&lt; spdlog::logger &gt;( name, std::move(sink) ); logger-&gt;set_level( level ); logger-&gt;flush_on( level ); return logger; } //        : auto manager = coop.make_agent_with_binder&lt; a_transform_manager_t &gt;( create_one_thread_disp( "manager" )-&gt;binder(), make_logger( "manager", logger_sink ) ); ... const auto worker_name = fmt::format( "worker_{}", worker ); auto transformer = coop.make_agent_with_binder&lt; a_transformer_t &gt;( create_one_thread_disp( worker_name )-&gt;binder(), make_logger( worker_name, logger_sink ), app_params.m_storage );</span></span></code> </pre><br>  Hay un punto sutil con la configuraci√≥n de los registradores en spdlog: de manera predeterminada, el registrador ignora los mensajes con niveles de severidad de rastreo y depuraci√≥n.  A saber, demuestran ser m√°s √∫tiles al depurar.  Por lo tanto, en make_logger, habilitamos de forma predeterminada el registro para todos los niveles, incluido el rastreo / depuraci√≥n. <br><br>  Debido al hecho de que cada entidad en Shrimp tiene su propio registrador con su propio nombre, podemos ver qui√©n hace qu√© en el registro: <br><br><img src="https://habrastorage.org/webt/1o/jh/yx/1ojhyxgywovfstlfsybe19h0lb0.png"><br><br><h2>  Seguimiento de SObjectizer con spdlog </h2><br>  Los tiempos de registro, que se realizan como parte de la l√≥gica comercial principal de una aplicaci√≥n SObjectizer, no son suficientes para depurar la aplicaci√≥n.  No est√° claro por qu√© se inicia alguna acci√≥n en un agente, pero en realidad no se realiza en otro agente.  En este caso, el mecanismo msg_tracing integrado en SObjectizer ayuda mucho (de lo que hablamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en un art√≠culo separado</a> ).  Pero entre las implementaciones est√°ndar de msg_tracing para SObjectizer, no hay una que use spdlog.  Haremos esta implementaci√≥n para camarones nosotros mismos: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spdlog_sobj_tracer_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(logger) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; what )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override </span></span>{ m_logger-&gt;trace( what ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_unique_ptr_t</span></span> make( spdlog::sink_ptr sink ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>&gt;( make_logger( <span class="hljs-string"><span class="hljs-string">"sobjectizer"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(sink) ) ); } };</code> </pre> <br>  Aqu√≠ vemos la implementaci√≥n de la interfaz especial SObjectizer tracer_t, en la que lo principal es el m√©todo virtual trace ().  Es √©l quien realiza el rastreo de las partes internas de SObjectizer usando spdlog. <br><br>  A continuaci√≥n, esta implementaci√≥n se instala como un trazador al iniciar SObjectizer: <br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">wrapped_env_t</span></span> sobj{ [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">sobj_tracing_t</span></span>::on == sobj_tracing ) params.message_delivery_tracer( <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>::make( logger_sink ) ); } };</code> </pre> <br><h2>  RESTinio trace a trav√©s de spdlog </h2><br>  Adem√°s de rastrear lo que sucede dentro del SObjectizer, a veces puede ser muy √∫til rastrear lo que sucede dentro de RESTinio.  En la versi√≥n actualizada de Shrimp, tambi√©n se agrega ese rastro. <br><br>  Este seguimiento se implementa a trav√©s de la definici√≥n de una clase especial que puede realizar el registro en RESTinio: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_logger_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( logger ) } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::trace, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::info, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">warn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::warn, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::err, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log_if_enabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( spdlog::level::level_enum lv, Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_logger-&gt;should_log(lv) ) { m_logger-&gt;<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lv, msg_builder() ); } } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; };</code> </pre> <br>  Esta clase no se hereda de nada, ya que el mecanismo de registro en RESTinio se basa en la programaci√≥n generalizada y no en el enfoque tradicional orientado a objetos.  Eso le permite deshacerse por completo de cualquier sobrecarga en los casos en que el registro no es necesario en absoluto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cubrimos</a> este tema con m√°s detalle cuando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hablamos sobre el uso de plantillas en RESTinio</a> ). <br><br>  A continuaci√≥n, debemos indicar que el servidor HTTP usar√° la clase http_server_logger_t que se muestra arriba como su registrador.  Esto se hace aclarando las propiedades del servidor HTTP: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span>; };</code> </pre> <br>  Bueno, entonces no queda nada por hacer: crear una instancia espec√≠fica del spd-logger y enviar este registrador al servidor HTTP creado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> restinio_logger = make_logger( <span class="hljs-string"><span class="hljs-string">"restinio"</span></span>, logger_sink, <span class="hljs-keyword"><span class="hljs-keyword">restinio_tracing_t</span></span>::off == restinio_tracing ? spdlog::level::off : log_level ); restinio::run( asio_io_ctx, shrimp::make_http_server_settings( thread_count.m_io_threads, params, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(restinio_logger), manager_mbox_promise.get_future().get() ) );</code> </pre> <br><h1>  v0.5: reinicio forzado de la cach√© de imagen transformada </h1><br>  En el proceso de depuraci√≥n de Shrimp, se descubri√≥ una peque√±a cosa que era un poco molesta: para vaciar el contenido del cach√© de la imagen transformada, ten√≠a que reiniciar todo el Shrimp.  Parecer√≠a un poco, pero desagradable. <br><br>  Como es desagradable, debes deshacerte de esta deficiencia.  Afortunadamente, esto no es del todo dif√≠cil. <br><br>  Primero, definiremos otra URL en Shrimp a la que puede enviar solicitudes HTTP DELETE: "/ cache".  En consecuencia, colgaremos nuestro controlador en esta URL: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt; make_router( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">app_params_t</span></span> &amp; params, so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> req_handler_mbox ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt;(); add_transform_op_handler( params, *router, req_handler_mbox ); add_delete_cache_handler( *router, req_handler_mbox ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br>  donde la funci√≥n add_delete_cache_handler () se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_delete_cache_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_delete( <span class="hljs-string"><span class="hljs-string">"/cache"</span></span>, [req_handler_mbox]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-comment"><span class="hljs-comment">/*params*/</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> token = qp.get_param( <span class="hljs-string"><span class="hljs-string">"token"</span></span>sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !token ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_403_response( req, <span class="hljs-string"><span class="hljs-string">"No token provided\r\n"</span></span> ); } <span class="hljs-comment"><span class="hljs-comment">// Delegate request processing to transform_manager. so_5::send&lt; so_5::mutable_msg&lt;a_transform_manager_t::delete_cache_request_t&gt; &gt;( req_handler_mbox, req, restinio::cast_to&lt;std::string&gt;(*token) ); return restinio::request_accepted(); } ); }</span></span></code> </pre> <br>  Un poco detallado, pero nada complicado.  La cadena de consulta de la consulta debe tener un par√°metro de token.  Este par√°metro debe contener una cadena con un valor especial para el token administrativo.  Solo puede restablecer la memoria cach√© si el valor del token del par√°metro del token coincide con lo establecido cuando se lanz√≥ Shrimp.  Si no hay ning√∫n par√°metro de token, la solicitud de procesamiento no se acepta.  Si hay token, el agente transform_manager, que posee el cach√©, recibe un mensaje de comando especial, ejecutando el cual el agente transform_manager responder√° a la solicitud HTTP. <br><br>  En segundo lugar, implementamos el nuevo controlador de mensajes delete_cache_request_t en el agente transform_manager_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_delete_cache_request( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">delete_cache_request_t</span></span>&gt; cmd ) { m_logger-&gt;warn( <span class="hljs-string"><span class="hljs-string">"delete cache request received; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}, token={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id(), cmd-&gt;m_token ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delay_response = [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> response_text ) { so_5::send_delayed&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">7</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response_text) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * env_token = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getenv( <span class="hljs-string"><span class="hljs-string">"SHRIMP_ADMIN_TOKEN"</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// Token must be present and must not be empty. env_token &amp;&amp; *env_token ) { if( cmd-&gt;m_token == env_token ) { m_transformed_cache.clear(); m_logger-&gt;info( "cache deleted" ); do_200_plaintext_response( std::move(cmd-&gt;m_http_req), "Cache deleted\r\n" ); } else { m_logger-&gt;error( "invalid token value for delete cache request; " "token={}", cmd-&gt;m_token ); delay_response( "Token value mismatch\r\n" ); } } else { m_logger-&gt;warn( "delete cache can't performed because there is no " "admin token defined" ); // Operation can't be performed because admin token is not avaliable. delay_response( "No admin token defined\r\n" ); } }</span></span></code> </pre> <br>  Aqu√≠ hay dos puntos que deben aclararse. <br><br>  El primer punto en la implementaci√≥n de on_delete_cache_request () es la verificaci√≥n del valor del token en s√≠.  El token administrativo se establece a trav√©s de la variable de entorno SHRIMP_ADMIN_TOKEN.  Si se establece esta variable y su valor coincide con el valor del par√°metro de token de la solicitud HTTP DELETE, la memoria cach√© se borra y se genera inmediatamente una respuesta positiva a la solicitud. <br><br>  Y el segundo punto en la implementaci√≥n de on_delete_cache_request () es el retraso forzado de una respuesta negativa a HTTP DELETE.  Si el valor incorrecto del token administrativo ha llegado, entonces deber√≠a retrasar la respuesta a HTTP DELETE para que no haya deseo de seleccionar el valor del token por fuerza bruta.  ¬øPero c√≥mo hacer este retraso?  Despu√©s de todo, llamar a std :: thread :: sleep_for () no es una opci√≥n. <br><br>  Aqu√≠ es donde los mensajes pendientes de SObjectizer vienen al rescate.  En lugar de generar inmediatamente una respuesta negativa dentro de on_delete_cache_request (), el agente transform_manager simplemente se env√≠a un mensaje pendiente negativo_delete_cache_response_t.  El temporizador SObjectizer contar√° el tiempo establecido y entregar√° este mensaje al agente despu√©s de que haya transcurrido el retraso especificado.  Y ahora, en el controlador negative_delete_cache_response_t, ya puede generar inmediatamente una respuesta a la solicitud HTTP DELETE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_negative_delete_cache_response( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; cmd ) { m_logger-&gt;debug( <span class="hljs-string"><span class="hljs-string">"send negative response to delete cache request; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id() ); do_403_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_response_text) ); }</code> </pre> <br>  Es decir  Resulta el siguiente escenario: <br><br><ul><li>  El servidor HTTP recibe una solicitud DELETE HTTP, convierte esta solicitud en un mensaje delete_cache_request_t al agente transform_manager; </li><li>  El agente transform_manager recibe el mensaje delete_cache_request_t e inmediatamente genera una respuesta positiva a la solicitud o se env√≠a un mensaje negativo negativo_delete_cache_response_t pendiente; </li><li>  transform_manager recibe un mensaje negative_delete_cache_response_t e inmediatamente genera una respuesta negativa a la solicitud HTTP DELETE correspondiente. </li></ul><br><h1>  Fin de la segunda parte. </h1><br>  Al final de la segunda parte, es bastante natural hacer la pregunta: "¬øQu√© sigue?" <br><br>  Adem√°s, probablemente habr√° otra iteraci√≥n y otra actualizaci√≥n de nuestro proyecto de demostraci√≥n.  Me gustar√≠a hacer algo como convertir una imagen de un formato a otro.  Digamos, en el servidor, la imagen est√° en jpg, y despu√©s de la transformaci√≥n, se env√≠a al cliente en webp. <br><br>  Tambi√©n ser√≠a interesante adjuntar una "p√°gina" separada con la visualizaci√≥n de las estad√≠sticas actuales sobre el trabajo de los camarones.  En primer lugar, es curioso.  Pero, en principio, dicha p√°gina tambi√©n se puede adaptar a las necesidades de monitoreo de la viabilidad de los camarones. <br><br>  Si alguien m√°s tiene sugerencias sobre lo que me gustar√≠a ver en Shrimp o en art√≠culos sobre Shrimp, nos complacer√° escuchar cualquier pensamiento constructivo. <br><br>  Por separado, quiero se√±alar un aspecto en la implementaci√≥n de Shrimp, que nos sorprendi√≥ un poco.  Este es un uso activo de mensajes mutables cuando se comunican entre s√≠ y con el servidor HTTP.  Por lo general, en nuestra pr√°ctica, sucede lo contrario: con mayor frecuencia se intercambian datos a trav√©s de mensajes inmunes.  No es as√≠ aqu√≠.  Esto sugiere que escuchamos a sabiendas los deseos de los usuarios a su debido tiempo y agregamos mensajes mutables a SObjectizer.  Entonces, si desea ver algo en RESTinio o SObjectizer, no dude en compartir sus ideas.  Estamos seguros de escuchar a los buenos. <br><br>  Bueno, y en conclusi√≥n, me gustar√≠a agradecer a todos los que se tomaron el tiempo y hablaron sobre la primera versi√≥n de Shrimp, tanto en Habr√© como a trav√©s de otros recursos.  Gracias <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√° ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417527/">https://habr.com/ru/post/es417527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417511/index.html">Intel adquiere eASIC - Desarrollador ASIC estructural</a></li>
<li><a href="../es417513/index.html">An√°logos en Python y JavaScript. Parte dos</a></li>
<li><a href="../es417515/index.html">Lo que aprend√≠ al crear 100 juegos en 5 a√±os</a></li>
<li><a href="../es417517/index.html">P√°ginas de la historia de Intel. Foto cr√≥nica y cuestionario</a></li>
<li><a href="../es417521/index.html">Revise los certificados SSL para revocaci√≥n</a></li>
<li><a href="../es417529/index.html">Tres tendencias tecnol√≥gicas que cambian el comercio y el consumidor.</a></li>
<li><a href="../es417531/index.html">C√≥mo ganamos en SmartMailHack 2</a></li>
<li><a href="../es417533/index.html">El Bloc de notas en Windows recibi√≥ la primera actualizaci√≥n significativa en dos d√©cadas</a></li>
<li><a href="../es417535/index.html">¬øEst√° el desarrollo de CUBA a un gran paso de la primavera?</a></li>
<li><a href="../es417537/index.html">"Tu juego es aburrido", o c√≥mo elevar la retenci√≥n ya alta del primer d√≠a</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>