<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”­ ğŸ’‚ ğŸ‘©ğŸ½â€ğŸŒ¾ Render teks membenci Anda ğŸ– â¬œï¸ ğŸ¤µğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Daftar isi 

- 1. Terminologi 
- 2. Apakah gaya, tata letak, dan bentuk saling bergantung? 
- 3. Teks bukan karakter yang terpisah 3.1. Hamparan teks ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Render teks membenci Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469529/"><div class="spoiler">  <b class="spoiler_title">Daftar isi</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Terminologi</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. Apakah gaya, tata letak, dan bentuk saling bergantung?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. Teks bukan karakter yang terpisah</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hamparan teks</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gaya dapat mengubah ligatur</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Emoji memecah warna dan gaya</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Menghaluskan adalah neraka</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Offset subpixel memecah cache mesin terbang</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subpiksel smoothing tidak boleh komposit</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. Esoterik</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Font dapat berisi SVG</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Karakter bisa sangat besar</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pilihan bukan bingkai, tetapi teks berjalan ke segala arah</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana cara menulis apa yang tidak mungkin untuk ditulis?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gaya adalah bagian dari font (kecuali jika tidak)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tidak ada rendering teks yang sempurna</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. Tautan tambahan</a> </li></ul></div></div><br>  Teks rendering: seberapa rumitkah itu?  Ternyata menjadi sangat menantang!  Sejauh yang saya tahu, secara harfiah tidak ada sistem yang menampilkan teks "dengan sempurna".  Tempat yang lebih baik, tempat yang lebih buruk. <br><br>  Misalkan Anda ingin teks sewenang-wenang dengan font, warna, dan gaya sewenang-wenang, dengan pembungkus garis dan dukungan penyorotan teks.  Sebenarnya, ini adalah persyaratan minimum untuk tampilan teks kompleks yang benar, jendela terminal, halaman web, dll. <br><br>  Secara umum, katakanlah segera: tidak ada jawaban yang benar berturut-turut, semuanya jauh lebih penting daripada yang Anda pikirkan, dan semuanya memengaruhi segalanya. <br><br>  Kami akan membahas topik yang tidak disatukan dalam satu konsep, ini hanya masalah yang harus saya hadapi selama beberapa tahun bekerja pada rendering teks di Firefox.  Sebagai contoh, kita tidak akan membahas terlalu banyak masalah segmentasi teks atau pengelolaan berbagai pustaka teks untuk platform tertentu, karena saya tidak terlalu tertarik dengan ini. <br><a name="habracut"></a><br><a name="1"></a><h1>  1. Terminologi </h1><br>  Sifat teksnya kompleks, dan bahasa Inggris dengan buruk menyampaikan semua nuansa.  Untuk dokumen ini, saya akan mencoba mematuhi ketentuan berikut.  Harap dicatat bahwa kata-kata ini tidak "benar," Saya hanya menemukan mereka berguna untuk menyampaikan konsep-konsep kunci kepada penutur asli bahasa Inggris yang tidak memiliki pengalaman dalam linguistik. <br><br>  Karakter: <br><br><ul><li>  Skalar (skalar): Skalar Unicode, "unit terkecil" di Unicode (ini juga merupakan titik kode). <br></li><li>  Karakter: cluster Unicode grapheme (EGC) yang diperluas, â€œunit terbesarâ€ di Unicode (berpotensi terdiri dari beberapa skalar). <br></li><li>  Glyph (glyph): unit atom rendering yang diberikan dalam font.  Biasanya memiliki pengidentifikasi unik di font. <br></li><li>  Ligatur: Mesin terbang yang terdiri dari beberapa skalar dan berpotensi bahkan beberapa karakter (penutur asli dapat mewakili ligatur sebagai beberapa karakter, tetapi untuk font itu hanya satu karakter). <br></li><li>  Emoji: mesin terbang "penuh warna". <img src="https://habrastorage.org/webt/bz/bc/0l/bzbc0lnl6kzkaygl4g6kdufbtpo.png" width="70"></li></ul><br>  Font <br><br><ul><li>  Font: Dokumen yang memetakan karakter ke mesin terbang. <br></li><li>  Menulis / menulis (skrip): satu set mesin terbang yang membentuk bahasa tertentu (font, sebagai aturan, mengimplementasikan skrip tertentu). <br></li><li>  Fon tulisan tangan (skrip kursif): font apa pun di mana mesin terbang bersentuhan dan mengalir satu sama lain (misalnya, Arab). <br></li><li>  Warna: Nilai RGB dan alpha untuk font (tidak diperlukan untuk beberapa kasus penggunaan, tetapi ini menarik). <br></li><li>  Gaya: pengubah tebal dan miring untuk font (dalam implementasi praktis, petunjuk, alias dan pengaturan lainnya biasanya juga disediakan). </li></ul><br><a name="2"></a><h1>  2. Apakah gaya, tata letak, dan bentuk saling bergantung? </h1><br>  Berikut adalah garis besar singkat untuk memberi Anda gambaran tentang bagaimana pipeline rendering teks tipikal bekerja: <br><br><ol><li>  Stylization (parsing markup, sistem kueri untuk font). <br></li><li>  Layout (memecah teks menjadi beberapa baris). <br></li><li>  Membentuk, membentuk (perhitungan mesin terbang dan posisinya). <br></li><li>  Rasterisasi mesin terbang yang diperlukan ke tekstur atlas / cache). <br></li><li>  Komposisi (menyalin mesin terbang dari atlas ke posisi yang diinginkan). </li></ol><br>  Sayangnya, langkah-langkah ini tidak sesederhana kelihatannya. <br><br>  Sebagian besar font tidak benar-benar menghasilkan semua mesin terbang mungkin sesuai permintaan.  Ada terlalu banyak mesin terbang, jadi font biasanya hanya menerapkan huruf tertentu.  Pengguna akhir biasanya tidak tahu atau tidak peduli tentang ini, jadi sistem yang andal harus <i>mengalir</i> ke font lain jika karakter tidak tersedia. <br><br>  Misalnya, meskipun markup dari teks berikut ini tidak <i>menyiratkan</i> banyak font, perlu untuk rendering yang tepat pada sistem apa pun: halo <img src="https://habrastorage.org/webt/s6/z5/b8/s6z5b8fxd5g525xyirad9asxejk.png" width="22">  à¤®à¤¨à¥€ Ø¨ Ø¨Ø³Ù… å¥½.  Jadi kita mendekati fakta bahwa langkah 1 (stilisasi) mulai tergantung pada langkah 3 (membentuk)! <br><br>  (Atau, Anda dapat mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pendekatan Noto</a> dan menggunakan font Uber tunggal yang berisi semua karakter. Meskipun kemudian pengguna tidak dapat mengkonfigurasi font, dan Anda tidak dapat memberikan antarmuka teks "asli" kepada pengguna di semua platform. Tapi anggaplah Anda membutuhkan yang lebih andal keputusan). <br><br>  Demikian pula, untuk tata letak Anda perlu tahu berapa banyak ruang yang dibutuhkan setiap potongan teks, tetapi ini baru diketahui setelah membentuk!  Apakah langkah 2 bergantung pada hasil langkah 3? <br><br>  Tapi untuk membentuknya, Anda perlu tahu tata letak dan gaya, jadi kami sepertinya mandek.  Apa yang harus dilakukan <br><br>  Pertama, stilisasi berlaku curang.  Meskipun kami <i>benar</i> - <i>benar</i> ingin mendapatkan mesin terbang yang lengkap, <i>skalar</i> cukup untuk styling.  Jika font tidak mendukung penulisan dengan benar, font tersebut tidak akan mengklaim tahu apa pun tentang skalar tulisan itu.  Dengan demikian, Anda dapat dengan mudah menemukan font "terbaik" sebagai berikut: <br><br>  Untuk setiap simbol (EGC) dalam teks kami, kami menginterogasi setiap font dalam daftar (kaskade) apakah semua skalar yang membentuk simbol ini diketahui.  Jika demikian, gunakan itu.  Jika kita sampai di akhir daftar tanpa hasil, kita akan tahu ( <img src="https://habrastorage.org/webt/qv/6w/jj/qv6wjjqmos_ob7gzmy_ogneaowy.png" width="20">  , indikator mesin terbang hilang). <br><br>  Anda mungkin sudah melihat indikator seperti itu ketika bertemu dengan emoji!  Karena beberapa emoji sebenarnya adalah ligatur dari beberapa emoji yang lebih sederhana, font dapat mengindikasikan dukungan untuk karakter dengan mengeluarkan hanya komponen individual.  Dengan cara ini <img src="https://habrastorage.org/webt/vr/mr/yk/vrmrykt5b5kjdkyj8b4nabjhjac.png" width="22">  mungkin terlihat seperti <img src="https://habrastorage.org/webt/6m/yv/6n/6myv6nhjem72asbiysa_wzah8t4.png" width="70">  jika font "terlalu lama" untuk mengetahui tentang ligatur baru.  Ini juga dapat terjadi jika Anda memiliki implementasi Unicode "terlalu lama" yang tidak tahu tentang karakter baru, memaksa sistem gaya untuk menerima kecocokan sebagian. <br><br>  Jadi, sekarang kita tahu persis font mana yang akan kita gunakan, tanpa harus merujuk ke tata letak atau bentuk (meskipun membentuk dapat mengubah warna kita, lebih banyak tentang itu di bagian selanjutnya).  Bisakah kita juga menangani saling ketergantungan tata letak dan bentuk?  Tidak!  Hal-hal seperti istirahat paragraf memberi Anda istirahat garis yang sulit, tetapi satu-satunya cara untuk membentuk adalah melalui pembentukan berulang! <br><br>  Penting untuk mengasumsikan bahwa teks ditempatkan pada satu baris, dan bentuk baris ini sampai ruang habis.  Pada titik ini, Anda dapat melakukan operasi penataan huruf dan mencari tahu di mana memecah teks dan memulai baris berikutnya.  Ulangi sampai semuanya selesai. <br><br><a name="3"></a><h1>  3. Teks bukan karakter yang terpisah </h1><br>  Menilai hanya dengan bahasa Inggris, maka Anda mungkin berpikir bahwa ikatan adalah semacam omong kosong yang aneh.  Maksudku, siapa yang <i>benar</i> - <i>benar</i> peduli bahwa "Ã¦" dieja "ae"?  Tetapi ternyata beberapa bahasa pada dasarnya terdiri dari ligatur.  Misalnya, à¤¡à¥ Ø¨ Ø¨Ø³Ù… terdiri dari karakter individual Â«Ø¨ Ø¨ Ø³ Ù….  Dalam sistem rendering teks canggih apa pun (yaitu, di salah satu browser utama), kedua baris ini akan terlihat <i>sangat</i> berbeda. <br><br>  Dan tidak: ini bukan tentang perbedaan antara skalar Unicode dan kluster grafem yang diperluas.  Jika Anda meminta sistem Unicode yang andal (misalnya, Swift) untuk memberikan kluster grafem yang diperluas dari baris ini, itu akan memberikan lima karakter ini! <br><br>  Bentuk karakter tergantung pada tetangganya: <b>teks tidak dapat menampilkan karakter setelah karakter dengan benar</b> . <br><br>  Artinya, Anda harus menggunakan perpustakaan pembentuk.  Standar industri di sini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HarfBuzz</a> , dan tugas-tugas ini sangat sulit untuk diselesaikan sendiri.  Jadi gunakan HarfBuzz. <br><br><a name="3_1"></a><h3>  3.1.  Hamparan teks </h3><br>  Dalam font tulisan tangan, mesin terbang sering tumpang tindih untuk menghindari jahitan, dan ini dapat menyebabkan masalah. <br><br>  Mari kita lihat lagi à¤®à¤¨à¥€ Ù… Ù…Ù†Ø´.  Apakah ini terlihat normal?  Sekarang tingkatkan: <br><br><img src="https://habrastorage.org/webt/sb/u0/kv/sbu0kvn9ii-lhltb9y7pqnj67pa.png"><br><br>  Tampaknya masih indah, tetapi mari kita buat teks menjadi transparan sebagian.  Jika Anda menggunakan Safari atau Edge, teksnya mungkin terlihat bagus!  Tetapi di Firefox atau Chrome, tampilan mengerikan: <br><br><img src="https://habrastorage.org/webt/0m/rs/fq/0mrsfqxdecmizkckojpww0o0iju.png"><br><br>  Masalahnya adalah bahwa Chrome dan Firefox mencoba <i>menipu</i> .  Mereka membentuk teks dengan benar, tetapi begitu mereka menemukan mesin terbang seperti itu, mereka masih mencoba menggambar mereka secara terpisah.  Ini biasanya berfungsi dengan baik, kecuali ketika ada transparansi dan tumpang tindih yang menghasilkan peredupan seperti itu. <br><br>  Implementasi yang "benar" akan membawa teks ke permukaan sementara <i>tanpa</i> transparansi, dan kemudian ke tempat kejadian <i>dengan</i> transparansi.  Firefox dan Chrome tidak melakukan ini karena mahal dan biasanya tidak diperlukan untuk bahasa Barat utama.  Menariknya, mereka benar-benar memahami masalahnya, karena mereka secara khusus memproses skrip untuk emoji (tetapi kami akan kembali ke sini nanti). <br><br><a name="3_1"></a><h3>  3.2.  Gaya dapat mengubah ligatur </h3><br>  Oke, contoh ini kami menganalisis <i>terutama</i> karena penasaran tentang bagaimana markup dapat pecah, meskipun saya tidak tahu skenario yang masuk akal di mana itu bisa sangat menyakitkan.  Berikut adalah dua bagian teks dengan konten yang sama tetapi warna berbeda: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/450/9ef/bcd/4509efbcddabd9a36f7a77372f99a832.png"><br><br>  Seperti apa bentuknya di Safari: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf0/1f5/057/cf01f505710b9a16186cb8671a852a08.png"><br><br>  Seperti inilah tampilannya di Chrome (saat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi mockup baru</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efa/a09/2d8/efaa092d8e5df031d1f7efbe0fdc991d.png"><br><br>  Dan ini mereka di Firefox: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/450/9ef/bcd/4509efbcddabd9a36f7a77372f99a832.png"><br><br>  Singkatnya: <br><br><ul><li>  Safari tidak memadai <br></li><li>  Chrome memecah mesin terbang tetapi menjatuhkan banyak warna <br></li><li>  Firefox secara bersamaan memecah mesin terbang dan menampilkan warna </li></ul><br>  Saya pikir semua orang harus menggunakan Firefox, bukan?  Tetapi jika Anda memperbesar, kita akan melihat bahwa dia melakukan sesuatu yang sangat aneh: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/516/9ce/d38/5169ced3843dcd4ab70e98c58b1929ed.png"><br><br>  Dia hanya membagi ligatur ini menjadi empat bagian yang sama dengan warna berbeda! <br><br>  Masalahnya adalah tidak ada jawaban yang masuk akal mengenai apa yang <i>harus</i> dilakukan di sini.  Kami membagi ligatur ke dalam gaya yang berbeda, dan karena ligatur, dalam arti tertentu, merupakan "unit" render, masuk akal jika menolak untuk mendukung pemisahan seperti itu (seperti yang dilakukan kebanyakan orang). <br><br>  Untuk beberapa alasan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seseorang di Firefox sangat antusias membuat implementasi yang lebih elegan</a> .  Pendekatannya adalah menggambar ligatur beberapa kali dengan topeng optimal dan warna berbeda, yang bekerja dengan sangat baik! <br><br>  Ada <i>beberapa</i> alasan dalam mencoba untuk mendukung "pengikatan parsial" ini: hanya pembentukan yang dapat mengetahui apakah suatu pengikat tertentu akan ditampilkan, dan ini tergantung pada font sistem, sehingga pengikat dapat muncul di tempat yang tidak diharapkan oleh siapa pun!  Contoh bahasa Inggris klasik adalah ligatur Ã¦ dari font yang dipasang pengguna di perbatasan hyperlink. <br><br>  Agak aneh juga bahwa bahasa Inggris dapat berubah di tengah kata, tetapi tidak dapat menggunakan font tulisan tangan? <br><br>  Bahkan jangan bertanya tentang kode yang memecah baris dengan pengikat parsial. <br><br><a name="4"></a><h1>  4. Emoji memecah warna dan gaya </h1><br>  Jika Anda menampilkan emoji seperti yang dilakukan sistem asli, Anda perlu mengabaikan pengaturan warna teks (dengan pengecualian transparansi): <br><br><img src="https://habrastorage.org/webt/cp/4d/2f/cp4d2fokoxffueesiohd1urszuu.png"><br><br>  Biasanya emoji memiliki warna asli mereka sendiri, dan warna ini bahkan mungkin memiliki makna semantik, seperti halnya dengan pengubah warna kulit.  Selain itu: mereka dapat memiliki beberapa warna! <br><br>  Sejauh yang saya tahu, tidak ada masalah sebelum emoji, sehingga platform yang berbeda memiliki pendekatan yang berbeda untuk menyelesaikannya.  Beberapa menunjukkan emoji sebagai gambar solid (Apple), yang lain sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian <i>lapisan</i> monokrom</a> (Microsoft). <br><br>  Pendekatan yang terakhir ini tidak buruk, karena terintegrasi dengan baik dengan jalur pipa rendering teks yang ada, â€œhanyaâ€ memecah mesin terbang menjadi serangkaian mesin terbang monokrom yang digunakan semua orang untuk bekerja dengannya. <br><br>  Namun, ini berarti bahwa ketika Anda menggambar mesin terbang "tunggal", gaya Anda mungkin <i>berulang kali</i> berubah.  Ini juga berarti bahwa "satu" mesin terbang dapat tumpang tindih dengan sendirinya, yang mengarah ke masalah transparansi yang disebutkan di bagian sebelumnya.  Meski begitu, browser <i>benar-</i> benar menggabungkan transparansi lapisan di emoji! <br><br>  Perbedaan ini dapat dijelaskan dengan tiga cara: <br><br><ul><li>  Anda sudah mencari mesin terbang berwarna untuk memprosesnya dengan cara khusus, sehingga mudah bagi mereka untuk memilih jalur tata letak khusus. <br></li><li>  Fon tulisan tangan dengan transparansi yang buruk terlihat sedikit jelek, tetapi emoji benar-benar rusak dan berubah menjadi rangkaian karakter yang tidak terbaca, sehingga pekerjaan tambahan itu dibenarkan. <br></li><li>  Pengembang barat lebih peduli tentang emoji daripada bahasa seperti Arab dan Marathi. </li></ul><br>  Pilih opsi sesuai selera Anda. <br><br>  Namun, bagaimana cara menyoroti emoticon dalam huruf miring atau tebal?  Abaikan gaya ini?  Haruskah mereka disintesis?  Siapa tahu ... <br><br>  Juga, bukankah emoji ini anehnya kecil? <br><br>  Ya, untuk beberapa alasan, sekelompok sistem diam-diam meningkatkan ukuran font untuk emoji agar terlihat lebih baik. <br><br><a name="5"></a><h1>  5. Menghaluskan adalah neraka </h1><br>  Karakter dalam teks sangat kecil dan terperinci.  Sangat penting bahwa teks itu mudah dibaca.  Kedengarannya seperti tugas smoothing!  Sial, 480p resolusi sangat rendah.  Lebih halus !!! <br><br><img src="https://habrastorage.org/webt/m9/8x/qa/m98xqayxjlpla-5bgc2rmktqpd8.png" align="right">  Jadi, ada dua jenis utama: <br><br><ul><li>  Grayscale Smoothing <img src="https://habrastorage.org/webt/sf/xr/qu/sfxrqug5y1yihdid_djblyqhhii.png" width="22"><br></li><li>  Subpixel Smoothing <img src="https://habrastorage.org/webt/i7/pt/mk/i7ptmkl9iwj6tve6ly5ch7dv-y0.png" width="22"></li></ul><br>  Pemulusan abu-abu adalah pendekatan "alami".  Ide dasarnya adalah bahwa sebagian piksel yang dilapisi mendapatkan transparansi sebagian.  Selama komposisi, ini akan menyebabkan pixel mendapatkan rona yang sesuai, meningkatkan detail keseluruhan. <br><br>  Istilah "nuansa abu-abu" digunakan untuk warna satu dimensi, sama seperti transparansi satu dimensi kami (jika tidak, mesin terbang ditampilkan dalam satu warna solid).  Selain itu, dalam situasi khas teks hitam pada latar belakang putih, anti-aliasing secara harfiah menampilkan nuansa abu-abu di sepanjang tepinya. <br><br>  Subpixel anti-aliasing adalah trik yang menyalahgunakan penempatan piksel normal pada monitor.  Ini jauh lebih rumit, jadi jika Anda benar-benar tertarik, Anda harus membaca dokumentasi yang lebih rinci, di sini hanya deskripsi singkat tentang konsep tingkat tinggi. <br><br>  Pixel pada monitor Anda sebenarnya adalah tiga kolom kecil merah, hijau, dan biru.  Jika Anda ingin merah, Anda <i>bisa</i> mengatakan "putih hitam hitam".  Dengan cara yang sama, jika Anda ingin mendapatkan warna biru, maka tentukan "hitam putih hitam".  Dengan kata lain, jika Anda mengutak-atik bunga, Anda dapat <i>melipattigakan</i> resolusi horizontal dan mendapatkan lebih banyak detail! <br><br>  Anda mungkin berpikir bahwa "pelangi" seperti itu akan sangat jelek, tetapi dalam praktiknya sistem ini bekerja dengan sangat baik (walaupun beberapa tidak setuju dengan ini).  Otak manusia senang mengenali pola dan melicinkannya.  Namun demikian, jika Anda mengambil tangkapan layar teks dengan perataan subpixel, Anda akan melihat dengan jelas semua warna tambahan jika Anda mengubah ukuran gambar atau hanya melihatnya di monitor dengan tata letak subpixel yang berbeda.  Inilah sebabnya mengapa tangkapan layar dengan teks sering terlihat sangat aneh dan buruk. <br><br>  (Secara umum, sistem ini juga berarti bahwa warna ikon dapat secara tidak sengaja mengubah ukuran dan posisinya, yang benar-benar menjengkelkan). <br><br>  Jadi subpixel anti-aliasing adalah hack yang benar-benar bersih yang dapat secara signifikan meningkatkan kejelasan teks, hebat!  Tapi, sayangnya, ini juga merupakan serpihan besar di pantat! <br><br>  Perhatikan bahwa <i>pergeseran mesin terbang subpiksel</i> terjadi dalam sistem anti-aliasing apa pun.  Anda selalu ingin mesin terbang rasterisasi Anda tersentak ke piksel penuh, tetapi rasterisasi itu sendiri dirancang untuk offset sub-piksel tertentu (nilai antara 0 dan 1). <br><br>  Untuk memahami hal ini, bayangkan kotak hitam 1x1 dengan smooth gralecale: <br><br><ul><li>  Jika offset subpikselnya adalah 0, maka hanya piksel hitam yang keluar saat rasterisasi. <br></li><li>  Jika subpixel offset 0,5, maka saat dirasterisasi, dua piksel keluar pada warna abu-abu 50%. </li></ul><br><a name="5_1"></a><h3>  5.1.  Offset subpixel memecah cache mesin terbang </h3><br>  Rasterisasi mesin terbang membutuhkan jumlah komputasi yang luar biasa, jadi jauh lebih baik untuk menyimpannya dalam atlas tekstur.  Tetapi bagaimana cara men-cache tekstur dengan offset subpixel?  Setiap offset memiliki rasterisasi uniknya sendiri! <br><br>  Di sini Anda perlu menemukan kompromi antara kualitas dan kinerja, dan ini dapat dilakukan dengan mengoptimalkan offset subpixel.  Untuk teks bahasa Inggris, keseimbangan yang wajar adalah kurangnya akurasi subpiksel vertikal dengan offset horizontal yang diikat ke seperempat bilangan bulat.  Ini hanya menyisakan empat posisi sub-pixel, yang masih sangat meningkatkan kualitas dengan tetap mempertahankan ukuran cache yang masuk akal. <br><br><a name="5_2"></a><h3>  5.2.  Subpiksel smoothing tidak boleh komposit </h3><br>  Salah satu fitur bagus dari anti-aliasing dalam nuansa abu-abu adalah Anda dapat bermain dengannya dengan bebas, dan itu dengan anggun menurun.  Misalnya, jika Anda mengonversi tekstur dengan teks (penskalaan, rotasi, atau transformasi), itu mungkin menjadi sedikit buram, tetapi akan terlihat normal secara umum. <br><br>  Jika Anda melakukan hal yang sama dengan subpixel anti-aliasing, itu akan terlihat mengerikan.  Seluruh idenya adalah untuk memanipulasi piksel pada tampilan.  Jika piksel tampilan tidak cocok dengan piksel tekstur Anda, maka tepi merah dan biru akan terlihat jelas! <br><br>  Anda mungkin berpikir bahwa ini "diperbaiki" hanya dengan rasterisasi mesin terbang baru di lokasi baru.  Dan memang, jika konversi itu statis, ini mungkin berhasil.  Tetapi jika transformasi adalah <i>animasi</i> , itu akan menjadi lebih buruk.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini sebenarnya adalah kesalahan peramban yang sangat umum: jika tidak menemukan bahwa animasi sedang terjadi dengan teks, maka karakter akan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berkedut</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena setiap mesin terbang melompat antara binding subpixel yang berbeda dengan mengisyaratkan pada setiap frame. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akibatnya, browser berisi beberapa heuristik untuk mendeteksi animasi seperti itu untuk mematikan anti-aliasing sub-pixel untuk bagian halaman ini (dan idealnya bahkan penempatan sub-pixel). Sangat sulit untuk mengimplementasikannya dengan andal, karena animasi dapat dipicu oleh JS yang kompleks tanpa memberikan "petunjuk" yang jelas pada browser.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, perataan subpiksel sulit digunakan dengan adanya transparansi parsial. Bahkan, di sini kita mengkonfigurasi saluran R, G, dan B untuk menyandikan tiga nilai transparansi (satu untuk setiap subpiksel), tetapi teks itu sendiri juga memiliki warna dan latar belakang, sehingga informasi mudah hilang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat menggunakan grayscale anti-aliasing, kami memiliki saluran alpha khusus, jadi tidak ada yang hilang. Dengan demikian, browser biasanya menggunakan nuansa abu-abu untuk bekerja dengan objek yang tembus cahaya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... Kecuali Firefox. </font><font style="vertical-align: inherit;">Sekali lagi, dalam organisasi yang aneh ini, seseorang benar-benar terbawa suasana dan melakukan sesuatu yang rumit: komponen alfa. </font><font style="vertical-align: inherit;">Ternyata Anda benar-benar dapat membuat teks dengan benar dengan subpixel anti-aliasing, tetapi ini membutuhkan tiga saluran transparansi tambahan untuk R, G dan B. Tidak mengherankan bahwa anti-aliasing semacam itu menggandakan konsumsi memori. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untungnya, selama bertahun-tahun, perataan sub-pixel menjadi kurang relevan:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Layar retina tidak membutuhkannya sama sekali. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tata letak sub-pixel pada ponsel memblokir trik ini (tanpa kerja serius). </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam versi MacOS yang lebih baru, teks subpixel dinonaktifkan secara default di level OS. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chrome tampaknya lebih agresif dalam menonaktifkan subpixel anti-aliasing (tidak yakin apakah ini kebijakan yang tepat). </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Backend grafis baru Firefox (webrender) meninggalkan komponen Alpha untuk kesederhanaan. </font></font></li></ul><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Esoterik </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian ini hanya kumpulan hal-hal kecil yang tidak pantas banyak dibahas. </font></font><br><br><a name="6_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1. </font><font style="vertical-align: inherit;">Font dapat berisi SVG</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu menyebalkan. </font><font style="vertical-align: inherit;">Font ini sebagian besar disediakan oleh Adobe, karena beberapa waktu lalu mereka masuk ke dalam SVG dengan cukup baik. </font><font style="vertical-align: inherit;">Kadang-kadang Anda dapat mengabaikan bagian SVG (saya percaya bahwa font Source Code Pro secara teknis mengandung beberapa glyphs SVG, tetapi dalam praktiknya mereka tidak benar-benar digunakan oleh situs web), tetapi secara umum Anda harus menerapkan dukungan SVG untuk secara formal mendukung semua font. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan apakah Anda pernah mendengar tentang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">font animasi SVG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font> Tidak  Bagus<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya pikir mereka rusak atau tidak diimplementasikan di mana-mana (Firefox secara tidak sengaja mendukung mereka untuk sementara waktu karena semacam pengembang yang antusias). </font></font><br><br><a name="6_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2. </font><font style="vertical-align: inherit;">Karakter bisa sangat besar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin secara naif memenuhi permintaan pengguna akan font yang sangat besar (atau tingkat zoom yang sangat besar), maka Anda akan menghadapi masalah manajemen memori ekstrim untuk atlas mesin terbang ukuran ini, karena setiap karakter dapat lebih besar dari seluruh layar. </font><font style="vertical-align: inherit;">Ada beberapa cara untuk menangani ini:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menolak menggambar mesin terbang (pengguna sedih). </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rasterisasi mesin terbang dalam ukuran yang lebih kecil dan tingkatkan skala selama komposisi (ini mudah, tetapi bentuk kabur di sepanjang tepi). </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rasterisasi mesin terbang langsung pada permukaan setelah komposisi (sulit, berpotensi mahal). </font></font></li></ul><br><a name="6_3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3. </font><font style="vertical-align: inherit;">Pilihan bukan bingkai, tetapi teks berjalan ke segala arah</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orang biasanya tahu bahwa arah utama teks dapat dari kiri ke kanan (Inggris), kanan ke kiri (Arab), atau atas ke bawah (Jepang). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, inilah teks yang lucu untuk Anda:</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo semuanya </font></font><font color="purple"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ø¨Ø³Ù… Ø§Ù„Ù„Ù‡ Ù„Ø§</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beep beep !!</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda memilih teks pada desktop dengan mouse dari kiri ke kanan, maka seleksi menjadi terputus-putus dan entah bagaimana aneh berkedut di tengah. </font><font style="vertical-align: inherit;">Ini karena kami menggabungkan teks dalam satu baris dari kiri ke kanan dan dari kanan ke kiri, yang terjadi setiap saat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, seleksi ke kanan meningkatkan seleksi, tetapi kemudian menguranginya sampai tiba-tiba mulai meningkat lagi. </font><font style="vertical-align: inherit;">Ini sebenarnya cukup benar: seleksi tetap kontinu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada baris aktual</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dengan demikian, Anda dapat menyalin sepotong teks dengan benar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda perlu mempertimbangkan ini dalam kode Anda untuk menyorot teks, serta dalam algoritma line break untuk tata letak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi itu belum semuanya. </font></font><br><img src="https://habrastorage.org/webt/h5/vm/ee/h5vmee428zjgkmlcs9syoyhzte0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harap Anda tidak harus berurusan dengan hal-hal seperti itu.</font></font><br><br><a name="6_4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.4. </font><font style="vertical-align: inherit;">Bagaimana cara menulis apa yang tidak mungkin untuk ditulis?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika tidak ada karakter dalam font, alangkah baiknya untuk memberi tahu pengguna tentang font tersebut. Mesin terbang "tahu" dimaksudkan untuk ini. Anda bisa menggambar tahu kosong (persegi panjang) dan membatasi diri Anda untuk itu. Tetapi jika Anda ingin memberikan informasi yang sangat berguna, Anda dapat menulis nilai karakter yang hilang untuk menyederhanakan debugging. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi tunggu, kami menggunakan teks untuk menjelaskan bahwa kami tidak dapat menampilkan teks?</font></font> Hm <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengatakan bahwa harus ada font dasar dalam sistem yang akan selalu menampilkan karakter 0-9 dan AF, tetapi ini adalah asumsi untuk para pengecut. </font><font style="vertical-align: inherit;">Jika pengguna benar-benar menghancurkan alatnya dengan alatnya, maka Firefox menawarkan jalan keluar: font mikro! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di dalam Firefox ada array kecil hard-coded dari seni satu-bit pixel dengan atlas kecil persis 16 karakter ini. </font><font style="vertical-align: inherit;">Jadi ketika menggambar tahu dia bisa meneruskan karakter ini tanpa khawatir tentang font.</font></font><br><br><img src="https://habrastorage.org/webt/us/by/n1/usbyn1o8olhyj82uy1b5ljw_pzg.png"><br><br><a name="6_5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.5. </font><font style="vertical-align: inherit;">Gaya adalah bagian dari font (kecuali jika tidak)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Font berkualitas tinggi awalnya dengan gaya seperti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">huruf miring</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tebal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena tidak ada cara algoritmik sederhana untuk menampilkan efek ini dengan indah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, beberapa font muncul tanpa gaya ini, jadi Anda masih memerlukan cara algoritmik sederhana untuk membuat efek ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deteksi dan pemrosesan gaya yang tepat sangat tergantung pada sistem dan di luar bidang keahlian saya, jadi saya tidak bisa menjelaskannya dengan baik. Saya hanya akan mempelajari </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode penanganan font di Webrender</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimanapun, Anda membutuhkan </font><font style="vertical-align: inherit;">fallback </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sintetis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Untungnya, implementasinya sebenarnya cukup sederhana: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cetak miring sintetis: miringkan setiap mesin terbang.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bold sintetis: gambar setiap mesin terbang beberapa kali dengan sedikit offset ke arah teks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejujurnya, pendekatan ini cukup baik! </font><font style="vertical-align: inherit;">Tetapi pengguna mungkin memperhatikan bahwa semuanya tampak "salah." </font><font style="vertical-align: inherit;">Karena itu, Anda dapat melakukan yang lebih baik jika Anda berusaha.</font></font><br><br><a name="6_6"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.6. </font><font style="vertical-align: inherit;">Tidak ada rendering teks yang sempurna</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap platform memiliki kesalahan, optimalisasi, dan keunikan begitu lama sehingga mereka menjadi estetika. </font><font style="vertical-align: inherit;">Oleh karena itu, bahkan jika Anda sangat yakin bahwa hal-hal tertentu ideal atau penting, akan selalu ada sekelompok besar pengguna dengan preferensi berbeda. </font><font style="vertical-align: inherit;">Sistem visualisasi teks yang kuat mendukung berbagai preferensi ini (ketika memilih default yang wajar). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurasi Anda harus mempertimbangkan sistem pengguna, font tertentu, aplikasi spesifik, dan teks tertentu. </font><font style="vertical-align: inherit;">Anda juga harus mencoba untuk mencocokkan "tampilan" asli dari setiap platform (kebiasaan seperti itu). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini termasuk:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemampuan untuk menonaktifkan sub-pixel anti-aliasing (beberapa sangat membencinya). </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemampuan untuk menonaktifkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setiap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anti-aliasing (ya, orang melakukannya).</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Satu ton properti platform / format-spesifik, seperti mengisyaratkan, menghaluskan, variasi, gamma, dll. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini juga berarti bahwa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pustaka teks asli harus digunakan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mencocokkan estetika masing-masing sistem (Core Text, DirectWrite dan FreeType pada platform masing-masing).</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Tautan tambahan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berikut adalah beberapa artikel tentang mimpi rendering teks: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">â€œWindows harus menambal beberapa font TrueType agar berfungsiâ€</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Ada begitu banyak ruang koordinat di Firefox."</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469529/">https://habr.com/ru/post/id469529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469515/index.html">Mempersiapkan aplikasi untuk Istio</a></li>
<li><a href="../id469521/index.html">Saya membeli sepeda motor untuk naik, bukan untuk jatuh</a></li>
<li><a href="../id469523/index.html">Ketergantungan kinerja kode pada konteks deklarasi variabel dalam JavaScript</a></li>
<li><a href="../id469525/index.html">Sistem kontrol otomatis untuk excavator pertambangan</a></li>
<li><a href="../id469527/index.html">Apakah interkom itu mata-mata?</a></li>
<li><a href="../id469531/index.html">â€œMembandingkan bahasa pemrograman dengan basis yang lebih baik-lebih buruk adalah pekerjaan yang benar-benar bodoh.â€</a></li>
<li><a href="../id469533/index.html">Masalah dan ancaman identifikasi biometrik</a></li>
<li><a href="../id469537/index.html">Mengenal Swift dengan Snake</a></li>
<li><a href="../id469541/index.html">Perakitan dan penyebaran layanan microser yang sama dengan werf dan GitLab CI</a></li>
<li><a href="../id469543/index.html">Redis Scaling dan Failover untuk Layanan DirectumRX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>