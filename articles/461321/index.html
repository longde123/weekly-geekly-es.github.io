<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèñÔ∏è üë®üèª‚Äçüíª üåª Modelos gen√©ricos y de metaprogramaci√≥n: Go, Rust, Swift, D y otros. üòö üë®‚Äçüç≥ üë®üèæ‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En algunas √°reas de programaci√≥n, es normal querer escribir una estructura de datos o algoritmo que pueda funcionar con elementos de diferentes tipos....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modelos gen√©ricos y de metaprogramaci√≥n: Go, Rust, Swift, D y otros.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/461321/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/o5/zc/cso5zcp78nxxi31mspfvdat89w4.jpeg"></div><br>  En algunas √°reas de programaci√≥n, es normal querer escribir una estructura de datos o algoritmo que pueda funcionar con elementos de diferentes tipos.  Por ejemplo, una lista de gen√©ricos o un algoritmo de clasificaci√≥n que solo necesita una funci√≥n de comparaci√≥n.  En varios lenguajes, se ofrecen varias formas de resolver este problema: desde simplemente se√±alar las funciones comunes apropiadas (C, Go) a los programadores hasta sistemas gen√©ricos tan poderosos que se vuelven completos de Turing ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rust</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++</a> ).  En este art√≠culo hablar√© sobre sistemas gen√©ricos de diferentes idiomas y su implementaci√≥n.  Comenzar√© resolviendo el problema en lenguajes sin dicho sistema (como C), y luego mostrar√© c√≥mo la adici√≥n gradual de extensiones conduce a sistemas de otros lenguajes. <br><a name="habracut"></a><br>  Considero que los gen√©ricos son una opci√≥n interesante porque son un caso especial simple de la tarea general de metaprogramaci√≥n: escribir programas que pueden generar clases de otros programas.  Como prueba, mostrar√© c√≥mo tres m√©todos de metaprogramaci√≥n diferentes y completamente generales pueden considerarse extensiones multidireccionales en el espacio de sistemas gen√©ricos: lenguajes din√°micos como Python, macro sistemas de procedimientos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Template Haskel</a> y compilaci√≥n por fases como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zig</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Terra</a> . <br><br><h2>  Revisar </h2><br>  Dibuj√© un diagrama de bloques de todos los sistemas descritos en el art√≠culo para que pueda presentar su contenido y c√≥mo estos sistemas est√°n interconectados: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/259/577/5fa259577cd99685d90ab7912710e348.png"><br><br><h2>  Ideas principales </h2><br>  Supongamos que estamos escribiendo en un lenguaje sin sistemas gen√©ricos, y queremos hacer una estructura de datos de estructura de datos de pila gen√©rica que funcione con datos de cualquier tipo.  El problema es que cada definici√≥n de funci√≥n y tipo solo funcionar√° con datos del mismo tama√±o y copiados de una manera, y generalmente funciona de manera similar. <br><br>  Hay dos formas de evitar esto: aseg√∫rese de que todos los tipos de datos act√∫en de la misma manera en nuestra estructura, o haga muchas copias de la estructura de datos con cambios menores para que funcionen correctamente con cada tipo de datos.  Estas ideas formaron la base de dos grandes grupos de soluciones con gen√©ricos: boxeo y monomorfizaci√≥n. <br><br>  Empaquetar significa poner todo en una fila en "cajas" unificadas que funcionan de la misma manera.  Esto generalmente se hace as√≠: los datos se colocan en un mont√≥n, y los punteros se colocan en la estructura de datos.  ¬°Puede hacer punteros a todos los tipos que funcionar√°n de la misma manera, por lo que el mismo c√≥digo funcionar√° con datos de cualquier tipo!  Sin embargo, esto conduce a un mayor consumo de memoria, b√∫squeda din√°mica y errores de cach√©.  En C, esto significa que su estructura de datos almacena punteros <code>void*</code> y simplemente almacena en cach√© los datos hacia y desde <code>void*</code> (si los datos no est√°n en el mont√≥n, los coloca all√≠). <br><br>  Monomorfizaci√≥n significa copiar repetidamente c√≥digo para los diferentes tipos de datos que queremos almacenar.  Luego, cada instancia de c√≥digo puede usar directamente el tama√±o y los m√©todos de datos con los que trabaja sin b√∫squeda din√°mica.  Con este enfoque, el c√≥digo se ejecuta m√°s r√°pido, pero su tama√±o y el tiempo de compilaci√≥n aumentan, porque compilamos repetidamente el mismo c√≥digo con cambios menores.  En C, esto corresponde a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">definici√≥n de toda la estructura de datos como una macro</a> , seguida de su invocaci√≥n para cada tipo de datos. <br><br>  En general, durante la compilaci√≥n, el c√≥digo se compila m√°s r√°pido, pero su rendimiento puede deteriorarse durante la ejecuci√≥n, mientras que durante la monomorfizaci√≥n generamos c√≥digo r√°pido, pero lleva m√°s tiempo compilar y optimizar todas las instancias del c√≥digo.  Otra diferencia es que cuando las extensiones de empaquetado le permiten realizar un comportamiento m√°s din√°mico del c√≥digo ejecutable, y la monomorfizaci√≥n le permite separar de manera m√°s flexible diferentes instancias del c√≥digo gen√©rico.  Tambi√©n vale la pena se√±alar que en algunos programas grandes, los beneficios de la monomorfizaci√≥n se pueden compensar con errores en el cach√© de instrucciones adicionales del c√≥digo generado. <br><br>  Cada uno de los esquemas descritos para trabajar con gen√©ricos se puede ampliar en diferentes direcciones, si necesita m√°s funciones o seguridad, y los autores de varios idiomas han encontrado soluciones muy interesantes.  Por ejemplo, ambos enfoques se pueden usar en Rust y C #! <br><br><h2>  Embalaje </h2><br>  Comencemos con un ejemplo de empaque b√°sico en Go: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { values []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { this.values = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(this.values, value) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { x := this.values[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] this.values = this.values[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x }</code> </pre> <br>  Adem√°s, el empaquetado se usa en C ( <code>void*</code> ), Go ( <code>interface{}</code> ), Java pre-gen√©rico ( <code>Object</code> ) y Objective-C pre-gen√©rico ( <code>id</code> ). <br><br><h2>  Gen√©ricos empaquetados con tipos de trituraci√≥n </h2><br>  El m√©todo de embalaje principal tiene desventajas: <br><br><ul><li>  Dependiendo del idioma, a menudo tenemos que emitir valores hacia o desde el tipo correcto cada vez que leemos o escribimos en la estructura de datos. <br></li><li>  Nada nos impide poner elementos de diferentes tipos en la estructura, lo que puede provocar errores que parecen fallas durante la ejecuci√≥n del c√≥digo. <br></li></ul><br>  Ambos problemas se pueden resolver agregando gen√©ricos al sistema de tipos de funcionalidad, mientras se usa el m√©todo de empaquetado principal de la misma manera que antes durante la ejecuci√≥n del c√≥digo.  Este enfoque a menudo se llama borrado de tipo, porque los tipos en el sistema gen√©rico se "sobrescriben" y se convierten en un tipo bajo el cap√≥ (como <code>Object</code> ). <br><br>  Java y Objective-C comenzaron con el empaquetado habitual, y luego adquirieron herramientas de lenguaje para gen√©ricos con maceraci√≥n de tipos, en aras de la compatibilidad, utilizando los mismos tipos de colecci√≥n que antes, pero con los par√°metros opcionales de los tipos gen√©ricos.  Considere un ejemplo de un art√≠culo de Wikipedia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gen√©ricos en Java</a> : <br><br><pre> <code class="java hljs">List v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); v.add(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// A String that cannot be cast to an Integer Integer i = (Integer)v.get(0); // Run time error List&lt;String&gt; v = new ArrayList&lt;String&gt;(); v.add("test"); Integer i = v.get(0); // (type error) compilation-time error</span></span></code> </pre><br><h3>  Gen√©ricos empaquetados derivados con rendimiento unificado </h3><br>  OCaml desarrolla a√∫n m√°s la idea de una vista unificada.  No hay tipos primitivos que necesiten una ubicaci√≥n de empaque adicional (ya que un <code>int</code> debe convertirse en <code>Integer</code> para ingresar a una <code>ArrayList</code> en Java), porque todo ya est√° empaquetado o representado por un valor entero del tama√±o de un puntero, es decir, todo cabe en una sola palabra de m√°quina.  Pero cuando el recolector de basura analiza los datos almacenados en estructuras gen√©ricas, necesita distinguir los punteros de los n√∫meros, por lo que los n√∫meros se marcan con un solo bit, colocado donde los punteros correctamente alineados no tienen un bit, dejando rangos de solo 31 o 63 bits. <br><br>  OCaml tambi√©n tiene un sistema de inferencia de tipos, por lo que puede escribir una funci√≥n y el compilador generar√° el tipo gen√©rico m√°s adecuado si no lo anota, por lo que las funciones se ver√°n como si fuera un lenguaje de tipo din√°mico: <br><br><pre> <code class="plaintext hljs">let first (head :: tail) = head (* inferred type: 'a list -&gt; 'a *)</code> </pre> <br>  El tipo dado se puede llamar "una funci√≥n de la lista de elementos del tipo <code>'a</code> en algo con el tipo <code>'a</code> ".  Esto significa que el tipo de retorno ser√° el mismo que el tipo de lista, y puede ser de cualquier tipo. <br><br><h2>  Interfaces </h2><br>  Otra limitaci√≥n de los envases convencionales es que los tipos de envases son <i>completamente</i> opacos.  Esto no es un problema para las estructuras de datos como una pila, pero las herramientas como la clasificaci√≥n de funciones gen√©ricas necesitan caracter√≠sticas adicionales, como funciones de comparaci√≥n espec√≠ficas del tipo.  Hay muchas formas de implementar esto en tiempo de ejecuci√≥n y reflexionar en el lenguaje, t√©cnicamente estas son direcciones diferentes, y puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementar el mismo lenguaje con varios enfoques similares</a> .  Sin embargo, las caracter√≠sticas de diferentes idiomas afectan su implementaci√≥n, y solo entonces las extensiones mejoran las fortalezas de las implementaciones seleccionadas.  Esto significa que hay dos familias de idiomas basadas en diferentes enfoques del tiempo de ejecuci√≥n: tablas de m√©todos virtuales (vtables) y transferencia de diccionario. <br><br><h3>  Tablas de m√©todos de interfaz </h3><br>  Si queremos proporcionar funciones espec√≠ficas de tipo, adheridas a la estrategia de empaquetado en aras del trabajo unificado con todo, entonces es suficiente tener una forma unificada de encontrar funciones similares que necesitamos obtener del objeto.  Este enfoque se denomina "tablas de m√©todos virtuales" (vtables, tablas de m√©todos virtuales), aunque nadie usa el nombre completo.  Se implementa de la siguiente manera: en un desplazamiento cero en cada objeto de estructura gen√©rico, hay un puntero a una tabla de punteros de funci√≥n con un circuito consistente.  En estas tablas, el c√≥digo gen√©rico busca punteros para escribir funciones espec√≠ficas indexando punteros espec√≠ficos en desplazamientos fijos. <br><br>  As√≠ es como se implementan los tipos de <code>interface</code> en los objetos de <code>dyn trait</code> Go y <code>dyn trait</code> en Rust.  Cuando convierte un tipo a un tipo de interfaz de lo que implementa, se crea un contenedor para la interfaz que contiene un puntero al objeto de origen y un puntero a la tabla de funciones espec√≠ficas del tipo.  Pero esto requiere un nivel adicional de direccionamiento indirecto de punteros y otro esquema.  Por lo tanto, la ordenaci√≥n en Go usa la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaz para el contenedor con el m√©todo Swap</a> , y no toma el segmento de la interfaz Comparable, ya que esto requerir√≠a colocar en la memoria un segmento de tipo de interfaz completamente nuevo que se ordenar√≠a en lugar del segmento original. <br><br><h3>  Programaci√≥n orientada a objetos. </h3><br>  OOP es una propiedad de lenguaje que hace un buen uso de las capacidades de las tablas de tipos virtuales.  En lugar de objetos de interfaz separados con vtables, los lenguajes OOP como Java simplemente insertan un puntero a una tabla de tipos virtuales al comienzo de cada objeto.  Los lenguajes tipo Java tienen un sistema de herencia e interfaces que pueden implementarse completamente usando estas tablas de objetos de tipo virtual. <br><br>  Adem√°s de proporcionar caracter√≠sticas adicionales, incrustar vtable en cada objeto resuelve el problema de la necesidad de construir nuevos tipos de interfaz con direccionamiento indirecto (indirecci√≥n).  A diferencia de Go, en Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, la funci√≥n de clasificaci√≥n</a> puede aplicar la interfaz <code>Comparable</code> a los tipos que implementa. <br><br><h3>  Reflexion </h3><br>  Si tiene tablas de tipos virtuales, no le resultar√° dif√≠cil forzar al compilador a generar tablas de otros tipos de informaci√≥n, por ejemplo, nombres de campos, tipos y ubicaciones.  Esto permitir√° el acceso a todos los datos de este tipo utilizando un c√≥digo que puede ver todos los datos de cualquier otro tipo.  Este comportamiento se puede usar para agregar "reflexi√≥n" al lenguaje, lo que permite la serializaci√≥n y una hermosa visualizaci√≥n de tipos arbitrarios.  La reflexi√≥n, como una extensi√≥n del paradigma de empaquetado, tiene un inconveniente: para ello, solo una copia del c√≥digo es suficiente, pero debe realizar muchas b√∫squedas din√°micas, lo que reduce la velocidad de serializaci√≥n. <br><br>  Lenguajes que usan la reflexi√≥n para la serializaci√≥n y otras funciones: Java, C # y Go. <br><br><h3>  Idiomas tipificados din√°micamente </h3><br>  Reflection es una herramienta muy poderosa que te permite resolver un mont√≥n de diferentes tareas de metaprogramaci√≥n.  Pero no le permite crear nuevos tipos o editar informaci√≥n sobre los tipos de valores existentes.  Si agregamos esta funci√≥n y hacemos que el acceso a los datos y las sintaxis de modificaci√≥n usen la reflexi√≥n de forma predeterminada, ¬°obtendremos idiomas escritos din√°micamente!  La incre√≠ble flexibilidad de la metaprogramaci√≥n en lenguajes como Python y Ruby ha surgido gracias a los eficaces y potentes sistemas de reflexi√≥n que se utilizan para resolver cualquier problema. <br><br>  Puede decir: "¬°Pero los lenguajes din√°micos no funcionan as√≠, simplemente implementan todo usando tablas hash!"  Las tablas hash son solo una buena estructura de datos para crear tablas editables con informaci√≥n de tipo.  Adem√°s, algunos int√©rpretes, como CPython, funcionan de esta manera.  En un JIT de alto rendimiento, digamos V8, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hay muchas tablas de tipos virtuales e</a> informaci√≥n de reflexi√≥n.  En V8, las clases ocultas (vtables e informaci√≥n de reflexi√≥n) y la estructura de los objetos son similares a lo que puede ver en Java VM, con la capacidad de reemplazar objetos con nuevas tablas de tipos virtuales en tiempo de ejecuci√≥n.  Esto no es una coincidencia, porque no hay coincidencias: el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">creador de V8</a> sol√≠a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajar en Java VM de alto rendimiento</a> . <br><br><h3>  Transferencia de diccionario </h3><br>  Otra forma de implementar interfaces din√°micas es transferir una tabla con los punteros de funci√≥n requeridos a la funci√≥n gen√©rica que los necesita.  Esto es algo similar a la construcci√≥n de objetos de interfaz en forma de Go en el lugar de la llamada, solo en nuestro caso la tabla se pasa como un argumento oculto y no se empaqueta en un paquete como uno de los argumentos existentes. <br><br>  Este enfoque se usa en las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clases de tipos en Haskell</a> , aunque GHC le permite realizar alg√∫n tipo de monomorfizaci√≥n mediante la incorporaci√≥n y la especializaci√≥n.  OCaml utiliza la transferencia de diccionario con un argumento expl√≠cito en forma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de m√≥dulos de primera clase</a> , pero ya se ha propuesto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregar la capacidad de hacer que el par√°metro sea impl√≠cito</a> . <br><br><h3>  Tablas de testigos en Swift </h3><br>  Los autores de Swift usaron una soluci√≥n interesante: transferir el diccionario, as√≠ como poner datos sobre los tama√±os de letra y c√≥mo moverlos, copiarlos y soltarlos en la tabla, le permite proporcionar toda la informaci√≥n necesaria para el trabajo unificado con cualquier tipo sin empaquetarlos.  Por lo tanto, Swift puede implementar gen√©ricos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sin monomorfizaci√≥n y colocaci√≥n en la memoria en una representaci√≥n unificada de</a> todas las entidades.  S√≠, tiene que pagar por las b√∫squedas din√°micas, como es caracter√≠stico de toda la familia que utiliza el empaquetado, pero ahorra recursos para su ubicaci√≥n en la memoria, su consumo y la inconsistencia de la memoria cach√©.  Utilizando las funciones <a href="">anotadas como @inlinable</a> , el compilador Swift tambi√©n puede especializarse (monomorfizar) y gen√©ricos en l√≠nea dentro del m√≥dulo o entre m√≥dulos para evitar los gastos mencionados.  Probablemente se utiliza una evaluaci√≥n heur√≠stica del efecto sobre el tama√±o del c√≥digo. <br><br>  Esto tambi√©n explica c√≥mo Swift puede <a href="">implementar la estabilidad ABI</a> , mientras le permite agregar y redistribuir campos en la estructura, aunque los autores proporcionan el atributo <code>@frozen</code> para rechazar b√∫squedas din√°micas para un mejor rendimiento. <br><br><h3>  An√°lisis de tipo Intensional </h3><br>  Hay otra forma de implementar interfaces para tipos empaquetados.  Agregamos el identificador de tipo a una determinada parte del objeto, siguiendo el ejemplo del puntero vtable, y luego generamos funciones para cada m√©todo de interfaz que tiene una expresi√≥n de <code>switch</code> grande para todos los tipos que implementan este m√©todo y lo pasan al m√©todo espec√≠fico de tipo correcto. <br><br>  No advierto contra el uso de lenguajes que usan este enfoque, pero los compiladores de C ++ y las m√°quinas virtuales Java act√∫an de manera similar, cuando usan la optimizaci√≥n basada en perfiles descubren que un determinado lugar de llamadas gen√©ricas funciona principalmente con objetos de ciertos tipos.  Los compiladores y las m√°quinas virtuales reemplazan los puntos de llamada con verificaciones para cada tipo ordinario, y luego env√≠an est√°ticamente estos tipos, como una alternativa usando el despacho din√°mico convencional.  Por lo tanto, el algoritmo de predicci√≥n de bifurcaci√≥n puede predecir en qu√© bifurcaci√≥n continuar√° el c√≥digo y continuar√° enviando instrucciones mediante llamadas est√°ticas. <br><br><h2>  Monomorfizaci√≥n </h2><br>  Esta es una alternativa al embalaje.  Con la monomorfizaci√≥n, necesitamos encontrar una manera de generar m√∫ltiples versiones del c√≥digo para cada tipo que queremos usar.  Los compiladores tienen varias fases de presentaci√≥n por las que pasa el c√≥digo y, en teor√≠a, pueden copiarse en cualquiera de estas etapas. <br><br><h3>  Generaci√≥n de c√≥digo fuente </h3><br>  La forma m√°s f√°cil de monomorfizar es copiar en la primera etapa de presentaci√≥n: ¬°copie el c√≥digo fuente!  Entonces, el compilador ni siquiera tiene que admitir gen√©ricos, y esto a veces lo hacen los usuarios de los lenguajes C y Go, cuyos compiladores no tienen dicho soporte. <br><br>  En C, puede usar un preprocesador y definir la estructura de datos en una macro o encabezado insert√°ndolo repetidamente con <code>#define</code> diferente.  Go tiene scripts como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">genny</a> que facilitan la generaci√≥n de c√≥digo. <br><br>  La desventaja de duplicar el c√≥digo fuente es que, dependiendo del idioma, puede ser necesario lidiar con numerosos problemas y casos extremos, adem√°s, el compilador analiza muchas veces y comprueba los tipos para pr√°cticamente el mismo c√≥digo.  Nuevamente, dependiendo del lenguaje y las herramientas, estos m√©todos gen√©ricos pueden ser dif√≠ciles de escribir y usar, como si dentro de una macro C cada l√≠nea terminara con una barra invertida y todos los tipos y nombres de funciones se deben pegar manualmente en sus identificadores para evitar colisiones. <br><br><h3>  Cadena mixins en D </h3><br>  Sin embargo, la generaci√≥n de c√≥digo tiene sus ventajas, como el hecho de que puede generar c√≥digo utilizando un lenguaje de programaci√≥n completo, as√≠ como utilizar una vista familiar para los usuarios. <br><br>  Algunos lenguajes en los que los gen√©ricos se implementan de manera diferente tambi√©n le permiten generar c√≥digo para casos de metaprogramaci√≥n m√°s generales que no se consideran en sus sistemas gen√©ricos, por ejemplo, para la serializaci√≥n.  El ejemplo m√°s comprensible son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los mixins de cadenas en D</a> , que permiten compilar c√≥digo D en forma de valores de cadena en el medio de la compilaci√≥n, utilizando todas las caracter√≠sticas del lenguaje. <br><br><h3>  Macros procesales de √≥xido </h3><br>  Un ejemplo similar, solo con una representaci√≥n en el compilador en una sola etapa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las macros de procedimiento de Rust</a> usan flujos de tokens como entrada y salida, proporcionando utilidades para convertir estos flujos en cadenas y viceversa.  La ventaja de este enfoque es que las secuencias de tokens pueden almacenar informaci√≥n de ubicaci√≥n del c√≥digo fuente.  El c√≥digo escrito por el usuario, la macro se puede insertar como tokens directamente desde la entrada al fin de semana.  Y si este c√≥digo conduce a un error de compilaci√≥n en la salida de los macos, el compilador mostrar√° un mensaje y se√±alar√° con precisi√≥n el archivo, la l√≠nea y la columna de la parte rota del c√≥digo.  Pero si la macro genera un c√≥digo roto, entonces un mensaje de error indicar√° una llamada de macro.  Por ejemplo, si usa una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">macro que envuelve una funci√≥n al registrar llamadas</a> y comete un error al implementar una funci√≥n ajustada, el mensaje de error apuntar√° directamente al error en el archivo y no al c√≥digo generado por la macro. <br><br><h3>  Macros de √°rbol de sintaxis </h3><br>  Algunos lenguajes van m√°s all√° y ofrecen herramientas para usar y crear diferentes tipos de √°rboles de sintaxis abstracta en macros (√Årbol de sintaxis abstracta, AST).  Los ejemplos incluyen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Template Haskell</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">macros Nim</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OCaml PPX</a> y casi todos los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lisp</a> . <br><br>  El inconveniente de las macros AST es que no desea obligar a los usuarios a aprender un mont√≥n de funciones para construir tipos AST, as√≠ como lenguajes b√°sicos.  En la familia de idiomas Lisp, esto se resuelve con la ayuda de una fuerte simplificaci√≥n y la m√°xima correspondencia entre la sintaxis y la estructura de AST, sin embargo, crear estructuras no siempre es f√°cil. <br><br>  Por lo tanto, en todos los idiomas que mencion√©, de una forma u otra hay una primitiva de "cita" a la que le da un c√≥digo en el idioma, y ‚Äã‚Äãque devuelve un √°rbol de sintaxis.  Estas primitivas pueden fusionar los valores del √°rbol de sintaxis utilizando la similitud de la interpolaci√≥n de cadenas.  Aqu√≠ hay un ejemplo de Template Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- using AST construction functions genFn :: Name -&gt; Q Exp genFn f = do x &lt;- newName "x" lamE [varP x] (appE (varE f) (varE x)) -- using quotation with $() for splicing genFn' :: Name -&gt; Q Exp genFn' f = [| \x -&gt; $(varE f) x |]</span></span></code> </pre> <br>         ,     ,   ,           .      .  ,  PPX  OCaml  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     </a> /  ,  .  Rust  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parsing</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">quotation</a> ,          ,       .    Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> ,    ,  </a> ! <br><br><h3>  Patrones </h3><br>    ‚Äî        .   ++  D    ,         ¬´ ¬ª.        ,     ,      ,        ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myMax</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a&gt;b?a:b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> {</span></span> T values[<span class="hljs-number"><span class="hljs-number">2</span></span>]; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ myMax(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); Pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p { {<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>} }; <span class="hljs-comment"><span class="hljs-comment">// This would give us a compile error inside myMax // about Pair being an invalid operand to `&gt;`: // myMax(p, p); }</span></span></code> </pre> <br>       ,                 ,        .     ,         ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">D</a>     ,  ,       :       ,    ,       .    D;    <code>if</code>       ( <code>!</code>     ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// We're going to use the isNumeric function in std.traits import std.traits; // The `if` is optional (without it you'll get an error inside like C++) // The `if` is also included in docs and participates in overloading! T myMax(T)(T a, T b) if(isNumeric!T) { return (a&gt;b?a:b); } struct Pair(T) { T[2] values; } void main() { myMax(5, 6); Pair!int p = {[5,6]}; // This would give a compile error saying that `(Pair!int, Pair!int)` // doesn't match the available instance `myMax(T a, T b) if(isNumeric!T)`: // myMax(p, p); }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C++20  ¬´¬ª</a> ,      ,           . <br><br><h3>    </h3><br>    D   ,        (compile time function evaluation)  <code>static if</code> , ,  ,    ,          - runtime-.          , ,   ,    ++    ,    . <br><br>  ,      ¬´    ¬ª. , Zig: <br><br><pre> <code class="plaintext hljs">fn Stack(comptime T: type) type { return struct { items: []T, len: usize, const Self = @This(); pub fn push(self: Self, item: T) { // ... } }; }</code> </pre> <br>  Zig            ,      ,  <code>comptime</code> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Terra</a>    ,   . Terra ‚Äî   Lua,     -  ,     Lua API    ,    quoting  splicing: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> struct Stack { items : &amp;T; <span class="hljs-comment"><span class="hljs-comment">-- &amp;T is a pointer to T len : int; } terra Stack:push(item : T) -- ... end return Stack end</span></span></code> </pre> <br>     Terra  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">        - (domain specific) </a> ,       <a href="">Java</a>  <a href="">Go</a>      .    Terra      runtime     ,   . <br><br><h3>   Rust </h3><br>           ,   .  ,    ,      ++,       .   ,    ,  ,     ,   .      ,                  .     Rust,     ‚Äî  Swift  Haskell. <br><br>  Rust      ¬´ ¬ª (trait bounds). <code>Trait</code> ‚Äî      ,    ,  .  Rust ,     -    ,   ,      ,      .   -  Rust <i></i>         .  ,           -. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_max</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>&gt;(a: T, b: T) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &gt; b { a } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { b } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span></span>&lt;T&gt; { values: [T; <span class="hljs-number"><span class="hljs-number">2</span></span>], } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { my_max(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p: Pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; = Pair { values: [<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] }; <span class="hljs-comment"><span class="hljs-comment">// Would give a compile error saying that // PartialOrd is not implemented for Pair&lt;i32&gt;: // my_max(p,p); }</span></span></code> </pre> <br>           ,            .  Rust       .  Rust 2018    ,    <code>v: &amp;impl SomeTrait</code>  ,   <code>v: &amp;dyn SomeTrait</code>  .      GHC  Swift  Haskell     ,       . <br><br><h3>    </h3><br>        ‚Äî          ,  .      ,    (placeholders)  -,           ,    .            <code>memcpy</code>   ,  !   ,       .          .         JIT,            ,     . <br><br>   ,      ,    ,   ,        ,     ,        !  ,              ,   ,       .  ,        ,              . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461321/">https://habr.com/ru/post/461321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461307/index.html">Te invitamos a VK Hackathon 2019. El pozo de premios de este a√±o es de dos millones de rublos.</a></li>
<li><a href="../461309/index.html">Todo excepto Kotlin: Andrei Breslav sobre equilibrio de g√©nero en TI, emociones y m√°s</a></li>
<li><a href="../461313/index.html">Zimbra 8.8.15 LTS lanzado</a></li>
<li><a href="../461317/index.html">9 principios para crear aplicaciones iOS de calidad</a></li>
<li><a href="../461319/index.html">¬øQu√© hace un dise√±ador de juegos?</a></li>
<li><a href="../461323/index.html">Una explicaci√≥n accesible del algoritmo de colapso de la funci√≥n de onda</a></li>
<li><a href="../461325/index.html">Victoria en PHDays 9. Compartimos hacks de vida en tres partes. Parte 3</a></li>
<li><a href="../461327/index.html">Crisis de front-end?</a></li>
<li><a href="../461329/index.html">Segmentaci√≥n autom√°tica de √≥rganos respiratorios.</a></li>
<li><a href="../461333/index.html">ITX5 mitap: JAVA en vivo, magia de Kotlin y yesca de tomate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>