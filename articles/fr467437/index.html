<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèª üñ±Ô∏è üìî MVCC dans PostgreSQL-1. L'isolement üë©‚Äçüë©‚Äçüëß‚Äçüëß üë©üèø‚Äçü§ù‚Äçüë®üèΩ üêπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Avec cet article, je commence un ensemble de s√©ries (ou une s√©rie d'ensembles? - En un mot, l'id√©e est grandiose) sur la structure inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-1. L'isolement</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/467437/">  Bonjour, Habr!  Avec cet article, je commence un ensemble de s√©ries (ou une s√©rie d'ensembles? - En un mot, l'id√©e est grandiose) sur la structure interne de PostgreSQL. <br><br>  Le mat√©riel sera bas√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des cours de formation</a> (en russe) sur l'administration que Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">pluzanov</a> et moi cr√©ons.  Tout le monde n'aime pas regarder des vid√©os (ce n'est certainement pas le cas), et lire des diapositives, m√™me avec des commentaires, n'est pas bon du tout. <br><br><blockquote>  Malheureusement, le seul cours disponible en anglais pour le moment est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduction de 2 jours √† PostgreSQL 11</a> . <br></blockquote><br>  Bien s√ªr, les articles ne seront pas exactement les m√™mes que le contenu des cours.  Je ne parlerai que de la fa√ßon dont tout est organis√©, en omettant l'administration elle-m√™me, mais j'essaierai de le faire plus en d√©tail et de mani√®re plus approfondie.  Et je crois que ces connaissances sont aussi utiles √† un d√©veloppeur d'applications qu'√† un administrateur. <br><br>  Je vais cibler ceux qui ont d√©j√† une certaine exp√©rience de l'utilisation de PostgreSQL et au moins en g√©n√©ral comprendre ce qui est quoi.  Le texte sera trop difficile pour les d√©butants.  Par exemple, je ne dirai pas un mot sur la fa√ßon d'installer PostgreSQL et d'ex√©cuter psql. <br><br>  Le contenu en question ne varie pas beaucoup d'une version √† l'autre, mais j'utiliserai le 11e PostgreSQL vanilla actuel. <br><br>  La premi√®re s√©rie traite des probl√®mes li√©s √† l'isolement et √† la concurrence multiversionnelle, et le plan de la s√©rie est le suivant: <br><br><ol><li>  Isolement tel que compris par le standard et PostgreSQL (cet article). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Forks, fichiers, pages</a> - ce qui se passe au niveau physique. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Versions de ligne</a> , transactions virtuelles et sous-transactions. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instantan√©s de donn√©es</a> et visibilit√© des versions de ligne;  l'horizon des √©v√©nements. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vide sur la page et mises √† jour CHAUDES</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vide normal</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autovacuum</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformation et gel de l'ID de transaction</a> . </li></ol><br>  C'est parti! <br><br><blockquote>  Et avant de commencer, je voudrais remercier Elena Indrupskaya d'avoir traduit les articles en anglais. <br></blockquote><br><a name="habracut"></a><br><h1>  Qu'est-ce que l'isolement et pourquoi est-il important? </h1><br>  Probablement, tout le monde est au moins conscient de l'existence de transactions, est tomb√© sur l'abr√©viation ACID et a entendu parler des niveaux d'isolement.  Mais nous nous trouvons toujours face √† l'opinion que cela rel√®ve de la th√©orie, ce qui n'est pas n√©cessaire dans la pratique.  Je vais donc passer un peu de temps √† expliquer pourquoi c'est vraiment important. <br><br>  Il est peu probable que vous soyez satisfait si une application obtient des donn√©es incorrectes de la base de donn√©es ou si l'application √©crit des donn√©es incorrectes dans la base de donn√©es. <br><br>  Mais que sont les donn√©es ¬´correctes¬ª?  Il est connu que des <em>contraintes d'int√©grit√©</em> , telles que NOT NULL ou UNIQUE, peuvent √™tre cr√©√©es au niveau de la base de donn√©es.  Si les donn√©es respectent toujours les contraintes d'int√©grit√© (et c'est le cas puisque le SGBD le garantit), alors elles sont int√©grales. <br><br>  Les m√™mes choses sont-elles <em>correctes</em> et <em>int√©grales</em> ?  Pas exactement.  Toutes les contraintes ne peuvent pas √™tre sp√©cifi√©es au niveau de la base de donn√©es.  Certaines contraintes sont trop compliqu√©es, par exemple, qui couvrent plusieurs tables √† la fois.  Et m√™me si une contrainte en g√©n√©ral aurait pu √™tre d√©finie dans la base de donn√©es, mais pour une raison inconnue, cela ne signifie pas que la contrainte peut √™tre viol√©e. <br><br>  Ainsi, l' <em>exactitude</em> est plus forte que l' <em>int√©grit√©</em> , mais nous ne savons pas exactement ce que cela signifie.  Nous devons admettre que ¬´l'√©talon-or¬ª de la rectitude est une application qui, comme nous aimerions le croire, est √©crite <em>correctement</em> et ne fonctionne jamais mal.  Dans tous les cas, si une application ne viole pas l'int√©grit√©, mais viole l'exactitude, le SGBD n'en sera pas inform√© et n'attrapera pas l'application ¬´en flagrant d√©lit¬ª. <br><br>  De plus, nous utiliserons le terme <em>coh√©rence</em> pour d√©signer l'exactitude. <br><br>  Supposons cependant qu'une application ex√©cute uniquement des s√©quences d'op√©rateurs correctes.  Quel est le r√¥le du SGBD si l'application est correcte en l'√©tat? <br><br>  Tout d'abord, il s'av√®re qu'une s√©quence correcte d'op√©rateurs peut temporairement rompre la coh√©rence des donn√©es et, curieusement, c'est normal.  Un exemple galvaud√© mais clair est un transfert de fonds d'un compte √† un autre.  La r√®gle de coh√©rence peut ressembler √† ceci: <em>un transfert ne modifie jamais le montant total d'argent sur les comptes</em> (cette r√®gle est assez difficile √† sp√©cifier dans SQL en tant que contrainte d'int√©grit√©, elle existe donc au niveau de l'application et est invisible pour le SGBD).  Un transfert se compose de deux op√©rations: la premi√®re r√©duit les fonds sur un compte, et la seconde - les augmente sur l'autre.  La premi√®re op√©ration rompt la coh√©rence des donn√©es, tandis que la seconde la restaure. <br><br><blockquote>  Un bon exercice consiste √† appliquer la r√®gle ci-dessus au niveau des contraintes d'int√©grit√©. <br></blockquote><br>  Que faire si la premi√®re op√©ration est effectu√©e et que la seconde ne l'est pas?  En fait, sans trop de bruit: lors de la deuxi√®me op√©ration, il peut se produire une panne d'√©lectricit√©, une panne de serveur, une division par z√©ro - peu importe.  Il est clair que la coh√©rence sera rompue et cela ne peut pas √™tre autoris√©.  En g√©n√©ral, il est possible de r√©soudre ces probl√®mes au niveau de l'application, mais au prix d'efforts consid√©rables;  cependant, heureusement, ce n'est pas n√©cessaire: cela se fait par le SGBD.  Mais pour ce faire, le SGBD doit savoir que les deux op√©rations sont un tout indivisible.  Autrement dit, <em>une transaction</em> . <br><br>  Cela s'av√®re int√©ressant: comme le SGBD sait que les op√©rations constituent une transaction, il aide √† maintenir la coh√©rence en s'assurant que les transactions sont atomiques, et il le fait sans rien savoir des r√®gles de coh√©rence sp√©cifiques. <br><br>  Mais il y a un deuxi√®me point, plus subtil.  D√®s que plusieurs transactions simultan√©es apparaissent dans le syst√®me, qui sont absolument correctes s√©par√©ment, elles peuvent ne pas fonctionner correctement ensemble.  En effet, l'ordre des op√©rations est m√©lang√©: vous ne pouvez pas supposer que toutes les op√©rations d'une transaction sont effectu√©es en premier, puis toutes les op√©rations de l'autre. <br><br>  Une note sur la simultan√©it√©.  En effet, les transactions peuvent s'ex√©cuter simultan√©ment sur un syst√®me dot√© d'un processeur multic≈ìur, d'une baie de disques, etc.  Mais le m√™me raisonnement vaut pour un serveur qui ex√©cute des commandes s√©quentiellement, dans un mode de partage de temps: pendant certains cycles d'horloge, une transaction est ex√©cut√©e et pendant certains cycles suivants, l'autre.  Parfois, le terme ex√©cution <em>simultan√©e</em> est utilis√© pour une g√©n√©ralisation. <br><br>  Les situations o√π les transactions correctes fonctionnent incorrectement sont appel√©es <em>anomalies</em> d'ex√©cution simultan√©e. <br><br>  Pour un exemple simple: si une application veut obtenir des donn√©es correctes de la base de donn√©es, elle ne doit pas, au moins, voir les changements d'autres transactions non valid√©es.  Sinon, vous pouvez non seulement obtenir des donn√©es incoh√©rentes, mais √©galement voir quelque chose qui n'a jamais √©t√© dans la base de donn√©es (si la transaction est annul√©e).  Cette anomalie est appel√©e une <em>lecture sale</em> . <br><br>  Il y a d'autres anomalies, plus complexes, que nous traiterons un peu plus tard. <br><br>  Il est certainement impossible d'√©viter l'ex√©cution simultan√©e: sinon, de quel type de performance peut-on parler?  Mais vous ne pouvez pas non plus travailler avec des donn√©es incorrectes. <br><br>  Et encore une fois, le SGBD vient √† la rescousse.  Vous pouvez effectuer des transactions <em>comme si elles √©taient</em> s√©quentielles, <em>comme si</em> elles se succ√©daient.  En d'autres termes - <em>isol√©s les</em> uns des autres.  En r√©alit√©, le SGBD peut effectuer des op√©rations m√©lang√©es, mais assurez-vous que le r√©sultat d'une ex√©cution simultan√©e sera le m√™me que le r√©sultat de certaines des ex√©cutions s√©quentielles possibles.  Et cela √©limine toutes les anomalies possibles. <br><br>  Nous sommes donc arriv√©s √† la d√©finition: <br><br><blockquote>  Une transaction est un ensemble d'op√©rations effectu√©es par une application qui transf√®re une base de donn√©es d'un √©tat correct √† un autre √©tat correct (coh√©rence), √† ‚Äã‚Äãcondition que la transaction soit termin√©e (atomicit√©) et sans interf√©rence d'autres transactions (isolement). <br></blockquote><br>  Cette d√©finition unit les trois premi√®res lettres de l'acronyme ACID.  Ils sont si √©troitement li√©s les uns aux autres qu'il est insens√© de consid√©rer l'un sans les autres.  En fait, il est √©galement difficile de d√©tacher la lettre D (durabilit√©).  En effet, lorsqu'un syst√®me se bloque, il pr√©sente toujours des modifications de transactions non valid√©es, avec lesquelles vous devez faire quelque chose pour restaurer la coh√©rence des donn√©es. <br><br>  Tout aurait √©t√© parfait, mais la mise en ≈ìuvre d'une isolation compl√®te est une t√¢che techniquement difficile entra√Ænant une r√©duction du d√©bit du syst√®me.  Par cons√©quent, dans la pratique tr√®s souvent (pas toujours, mais presque toujours) l'isolement affaibli est utilis√©, ce qui emp√™che certaines, mais pas toutes les anomalies.  Cela signifie qu'une partie du travail visant √† garantir l'exactitude des donn√©es incombe √† l'application.  Pour cette raison, il est tr√®s important de comprendre quel niveau d'isolement est utilis√© dans le syst√®me, ce qui le garantit et ce qu'il ne donne pas, et comment √©crire du code correct dans de telles conditions. <br><br><h1>  Niveaux d'isolement et anomalies dans la norme SQL </h1><br>  Le standard SQL d√©crit depuis longtemps quatre niveaux d'isolement.  Ces niveaux sont d√©finis en r√©pertoriant les anomalies autoris√©es ou non lorsque les transactions sont ex√©cut√©es simultan√©ment √† ce niveau.  Par cons√©quent, pour parler de ces niveaux, il est n√©cessaire de conna√Ætre les anomalies. <br><br>  J'insiste sur le fait que, dans cette partie, nous parlons de la norme, c'est-√†-dire d'une th√©orie, sur laquelle la pratique se fonde de mani√®re significative, mais √† partir de laquelle elle diverge de mani√®re significative.  Par cons√©quent, tous les exemples ici sont sp√©culatifs.  Ils utiliseront les m√™mes op√©rations sur les comptes clients: c'est assez d√©monstratif, m√™me si, certes, cela n'a rien √† voir avec l'organisation des op√©rations bancaires dans la r√©alit√©. <br><br><h2>  Mise √† jour des pertes </h2><br>  Commen√ßons par une <em>mise √† jour perdue</em> .  Cette anomalie se produit lorsque deux transactions lisent la m√™me ligne de la table, puis une transaction met √† jour cette ligne, puis la deuxi√®me transaction met √©galement √† jour la m√™me ligne sans prendre en compte les modifications apport√©es par la premi√®re transaction. <br><br>  Par exemple, deux transactions vont augmenter le montant sur le m√™me compte de ‚ÇΩ100 (‚ÇΩ est le symbole mon√©taire du rouble russe).  La premi√®re transaction lit la valeur actuelle (‚ÇΩ1000), puis la deuxi√®me transaction lit la m√™me valeur.  La premi√®re transaction augmente le montant (cela donne ‚ÇΩ1100) et √©crit cette valeur.  La deuxi√®me transaction agit de la m√™me mani√®re: elle obtient le m√™me ‚ÇΩ1100 et √©crit cette valeur.  En cons√©quence, le client a perdu 100 ‚ÇΩ. <br><br>  La norme n'autorise pas les mises √† jour perdues √† n'importe quel niveau d'isolement. <br><br><h2>  Lecture sale et lecture non valid√©e </h2><br>  Une <em>lecture sale</em> est ce que nous avons d√©j√† appris.  Cette anomalie se produit lorsqu'une transaction lit des modifications qui n'ont pas encore √©t√© valid√©es par une autre transaction. <br><br>  Par exemple, la premi√®re transaction transf√®re tout l'argent du compte du client vers un autre compte, mais n'engage pas la modification.  Une autre transaction lit le solde du compte, pour obtenir ‚ÇΩ0, et refuse de retirer de l'argent au client, bien que la premi√®re transaction abandonne et annule ses modifications, de sorte que la valeur de 0 n'a jamais exist√© dans la base de donn√©es. <br><br>  La norme autorise les lectures incorrectes au niveau de lecture non valid√©e. <br><br><h2>  Lecture non r√©p√©table et lecture valid√©e </h2><br>  Une anomalie de <em>lecture non r√©p√©table</em> se produit lorsqu'une transaction lit deux fois la m√™me ligne, et entre les lectures, la deuxi√®me transaction modifie (ou supprime) cette ligne et valide les modifications.  Ensuite, la premi√®re transaction obtiendra des r√©sultats diff√©rents. <br><br>  Par exemple, laissez une r√®gle de coh√©rence <em>interdire les montants n√©gatifs sur les comptes clients</em> .  La premi√®re transaction va r√©duire le montant du compte de ‚ÇΩ100.  Il v√©rifie la valeur actuelle, obtient ‚ÇΩ1000 et d√©cide que la diminution est possible.  Dans le m√™me temps, la deuxi√®me transaction r√©duit √† z√©ro le montant du compte et valide les modifications.  Si la premi√®re transaction rev√©rifiait maintenant le montant, elle obtiendrait ‚ÇΩ0 (mais elle a d√©j√† d√©cid√© de r√©duire la valeur, et le compte ¬´passe au rouge¬ª). <br><br>  La norme autorise les lectures non r√©p√©tables aux niveaux Lecture non valid√©e et Lecture valid√©e.  Mais Read Committed ne permet pas de lectures incorrectes. <br><br><h2>  Lecture fant√¥me et lecture r√©p√©table </h2><br>  Une <em>lecture fant√¥me</em> se produit lorsqu'une transaction lit un ensemble de lignes par la m√™me condition deux fois, et entre les lectures, la deuxi√®me transaction ajoute des lignes qui remplissent cette condition (et valide les modifications).  Ensuite, la premi√®re transaction obtiendra un ensemble diff√©rent de lignes. <br><br>  Par exemple, laissez une r√®gle de coh√©rence <em>emp√™cher un client d'avoir plus de 3 comptes</em> .  La premi√®re transaction va ouvrir un nouveau compte, v√©rifie le nombre actuel de comptes (disons, 2) et d√©cide que l'ouverture est possible.  Dans le m√™me temps, la deuxi√®me transaction ouvre √©galement un nouveau compte pour le client et valide les modifications.  Maintenant, si la premi√®re transaction rev√©rifiait le nombre, il obtiendrait 3 (mais il ouvre d√©j√† un autre compte, et le client semble en avoir 4). <br><br>  La norme autorise les lectures fant√¥mes aux niveaux Lecture non valid√©e, Lecture valid√©e et Lecture r√©p√©table.  Cependant, la lecture non r√©p√©table n'est pas autoris√©e au niveau de la lecture r√©p√©table. <br><br><h2>  L'absence d'anomalies et s√©rialisables </h2><br>  La norme d√©finit un niveau de plus - S√©rialisable - qui ne permet aucune anomalie.  Et ce n'est pas la m√™me chose que d'interdire les mises √† jour perdues et les lectures sales, non r√©p√©tables ou fant√¥mes. <br><br>  Le fait est qu'il y a beaucoup plus d'anomalies connues que celles √©num√©r√©es dans la norme et aussi un nombre inconnu de celles encore inconnues. <br><br>  Le niveau s√©rialisable doit emp√™cher <em>absolument toutes les</em> anomalies.  Cela signifie qu'√† ce niveau, un d√©veloppeur d'applications n'a pas besoin de penser √† l'ex√©cution simultan√©e.  Si les transactions ex√©cutent une s√©quence correcte d'op√©rateurs travaillant s√©par√©ment, les donn√©es seront √©galement coh√©rentes lorsque ces transactions seront ex√©cut√©es simultan√©ment. <br><br><h2>  Tableau r√©capitulatif </h2><br>  Nous pouvons maintenant fournir un tableau bien connu.  Mais ici, la derni√®re colonne, qui manque dans la norme, est ajout√©e pour plus de clart√©. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Changements perdus </th><th>  Lecture sale </th><th>  Lecture non r√©p√©table </th><th>  Lecture fant√¥me </th><th>  Autres anomalies </th></tr><tr><th>  Lire sans engagement </th><th>  - </th><th>  Oui </th><th>  Oui </th><th>  Oui </th><th>  Oui </th></tr><tr><th>  Lire engag√© </th><th>  - </th><th>  - </th><th>  Oui </th><th>  Oui </th><th>  Oui </th></tr><tr><th>  Lecture r√©p√©table </th><th>  - </th><th>  - </th><th>  - </th><th>  Oui </th><th>  Oui </th></tr><tr><th>  S√©rialisable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br><h2>  Pourquoi exactement ces anomalies? </h2><br>  Pourquoi la norme ne r√©pertorie-t-elle que quelques-unes des nombreuses anomalies possibles et pourquoi sont-elles exactement celles-ci? <br><br>  Personne ne semble le savoir avec certitude.  Mais ici, la pratique est √©videmment en avance sur la th√©orie, il est donc possible qu'√† cette √©poque (de la norme SQL: 92) d'autres anomalies n'aient pas √©t√© simplement pens√©es. <br><br>  De plus, on a suppos√© que l'isolement devait √™tre construit sur des serrures.  L'id√©e derri√®re le <em>protocole de verrouillage √† deux phases</em> largement utilis√© (2PL) est que lors de l'ex√©cution, une transaction verrouille les lignes avec lesquelles elle travaille et lib√®re les verrous √† la fin.  Simplifiant consid√©rablement, plus une transaction acquiert de verrous, mieux elle est isol√©e des autres transactions.  Mais les performances du syst√®me souffrent √©galement davantage, car au lieu de travailler ensemble, les transactions commencent √† se mettre en file d'attente pour les m√™mes lignes. <br><br>  Mon sentiment est que c'est juste le nombre de verrous requis, qui explique la diff√©rence entre les niveaux d'isolement de la norme. <br><br>  Si une transaction verrouille les lignes √† modifier de la mise √† jour, mais pas de la lecture, nous obtenons le niveau de lecture non valid√©e: les modifications perdues ne sont pas autoris√©es, mais les donn√©es non valid√©es peuvent √™tre lues. <br><br>  Si une transaction verrouille les lignes √† modifier √† la fois de la lecture et de la mise √† jour, nous obtenons le niveau de lecture valid√©e: vous ne pouvez pas lire les donn√©es non valid√©es, mais vous pouvez obtenir une valeur diff√©rente (lecture non r√©p√©table) lorsque vous acc√©dez √† nouveau √† la ligne. <br><br>  Si une transaction verrouille les lignes √† lire et √† modifier et √† la fois de la lecture et de la mise √† jour, nous obtenons le niveau de lecture r√©p√©table: relire la ligne retournera la m√™me valeur. <br><br>  Mais il y a un probl√®me avec Serializable: vous ne pouvez pas verrouiller une ligne qui n'existe pas encore.  Par cons√©quent, une lecture fant√¥me est toujours possible: une autre transaction peut ajouter (mais pas supprimer) une ligne qui remplit les conditions d'une requ√™te pr√©c√©demment ex√©cut√©e, et cette ligne sera incluse dans la res√©lection. <br><br>  Par cons√©quent, pour impl√©menter le niveau S√©rialisable, les verrous normaux ne suffisent pas - vous devez verrouiller les conditions (pr√©dicats) plut√¥t que les lignes.  Par cons√©quent, ces verrous √©taient appel√©s <em>pr√©dicats</em> .  Ils ont √©t√© propos√©s en 1976, mais leur applicabilit√© pratique est limit√©e par des conditions assez simples pour lesquelles il est clair comment joindre deux pr√©dicats diff√©rents.  Pour autant que je sache, de tels verrous n'ont jamais √©t√© impl√©ment√©s dans aucun syst√®me jusqu'√† pr√©sent. <br><br><h1>  Niveaux d'isolement dans PostgreSQL </h1><br>  Au fil du temps, les protocoles de gestion des transactions bas√©s sur les verrous ont √©t√© remplac√©s par le protocole Snapshot Isolation (SI).  Son id√©e est que chaque transaction fonctionne avec un instantan√© coh√©rent des donn√©es √† un certain point dans le temps, et seules ces modifications entrent dans l'instantan√© qui ont √©t√© valid√©es avant sa cr√©ation. <br><br>  Cette isolation emp√™che automatiquement les lectures sales.  Formellement, vous pouvez sp√©cifier le niveau Read Uncommitted dans PostgreSQL, mais cela fonctionnera exactement de la m√™me mani√®re que Read Committed.  Par cons√©quent, nous ne parlerons pas du tout du niveau Read Uncommitted. <br><br>  PostgreSQL impl√©mente une variante <em>multiversionnelle</em> de ce protocole.  L'id√©e de la concurrence multiversionnelle est que plusieurs versions de la m√™me ligne peuvent coexister dans un SGBD.  Cela vous permet de cr√©er un instantan√© des donn√©es √† l'aide des versions existantes et d'utiliser un minimum de verrous.  En fait, seules les modifications ult√©rieures de la m√™me ligne sont verrouill√©es.  Toutes les autres op√©rations sont effectu√©es simultan√©ment: les transactions d'√©criture ne verrouillent jamais les transactions en lecture seule et les transactions en lecture seule ne verrouillent jamais rien. <br><br>  En utilisant des instantan√©s de donn√©es, l'isolement dans PostgreSQL est plus strict que requis par la norme: le niveau de lecture r√©p√©table ne permet pas seulement des lectures non r√©p√©tables, mais aussi des lectures fant√¥mes (bien qu'il ne fournisse pas une isolation compl√®te).  Et cela est r√©alis√© sans perte d'efficacit√©. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Changements perdus </th><th>  Lecture sale </th><th>  Lecture non r√©p√©table </th><th>  Lecture fant√¥me </th><th>  Autres anomalies </th></tr><tr><th>  Lire sans engagement </th><th>  - </th><th>  - </th><th>  Oui </th><th>  Oui </th><th>  Oui </th></tr><tr><th>  Lire engag√© </th><th>  - </th><th>  - </th><th>  Oui </th><th>  Oui </th><th>  Oui </th></tr><tr><th>  Lecture r√©p√©table </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  Oui </th></tr><tr><th>  S√©rialisable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br>  Nous parlerons dans les prochains articles de la fa√ßon dont la concurrence multiversionnelle est mise en ≈ìuvre ¬´sous le capot¬ª, et maintenant nous examinerons en d√©tail chacun des trois niveaux avec l'≈ìil d'un utilisateur (comme vous le savez, le plus int√©ressant se cache derri√®re ¬´d'autres anomalies¬ª). ‚Äù).  Pour ce faire, cr√©ons un tableau des comptes.  Alice et Bob ont chacun 1000 livres sterling, mais Bob a deux comptes ouverts: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Lire engag√© </h2><br><h3>  L'absence de lecture sale </h3><br>  Il est facile de s'assurer que les donn√©es sales ne peuvent pas √™tre lues.  Nous commen√ßons la transaction.  Par d√©faut, il utilisera le niveau d'isolement Read Committed: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  Plus pr√©cis√©ment, le niveau par d√©faut est d√©fini par le param√®tre, qui peut √™tre modifi√© si n√©cessaire: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Ainsi, dans une transaction ouverte, nous retirons des fonds du compte, mais n'engageons pas les modifications.  La transaction voit ses propres changements: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  Dans la deuxi√®me session, nous commencerons une autre transaction avec le m√™me niveau de lecture valid√©e.  Pour distinguer les transactions, les commandes de la deuxi√®me transaction seront mises en retrait et marqu√©es d'une barre. <br><br>  Afin de r√©p√©ter les commandes ci-dessus (ce qui est utile), vous devez ouvrir deux terminaux et ex√©cuter psql dans chacun d'eux.  Dans le premier terminal, vous pouvez entrer les commandes d'une transaction, et dans le second - celles de l'autre. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Comme pr√©vu, l'autre transaction ne voit pas de modifications non valid√©es car les lectures incorrectes ne sont pas autoris√©es. <br><br><h3>  Lecture non r√©p√©table </h3><br>  Maintenant, laissez la premi√®re transaction valider les modifications et la seconde r√©ex√©cute la m√™me requ√™te. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  La requ√™te obtient d√©j√† de nouvelles donn√©es - et c'est l'anomalie de <em>lecture non r√©p√©table</em> , qui est autoris√©e au niveau de lecture valid√©e. <br><br>  <em>Conclusion pratique</em> : dans une transaction, vous ne pouvez pas prendre de d√©cisions bas√©es sur des donn√©es lues par un op√©rateur pr√©c√©dent car les choses peuvent changer entre l'ex√©cution des op√©rateurs.  Voici un exemple dont les variations se produisent si souvent dans le code d'application qu'il est consid√©r√© comme un contre-mod√®le classique: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  Pendant le temps qui s'√©coule entre la v√©rification et la mise √† jour, d'autres transactions peuvent changer l'√©tat du compte de quelque fa√ßon que ce soit, donc un tel ¬´ch√®que¬ª ne s√©curise rien.  Il est commode d'imaginer qu'entre les op√©rateurs d'une transaction, tout autre op√©rateur d'autres transactions peut se ¬´coincer¬ª, par exemple, comme suit: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Si tout peut √™tre g√¢ch√© en r√©organisant les op√©rateurs, le code est mal √©crit.  Et ne vous trompez pas qu'une telle co√Øncidence ne se produira pas - elle le sera, c'est certain. <br><br>  Mais comment √©crire du code correctement?  Les options sont g√©n√©ralement les suivantes: <br><br><ul><li>  Ne pas √©crire de code. <br>  Ce n'est pas une blague.  Par exemple, dans ce cas, la v√©rification se transforme facilement en contrainte d'int√©grit√©: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  Aucune v√©rification n'est n√©cessaire maintenant: effectuez simplement l'op√©ration et, si n√©cessaire, g√©rez l'exception qui se produira si une violation d'int√©grit√© est tent√©e. <br></li><li>  Pour utiliser une seule instruction SQL. <br>  Des probl√®mes de coh√©rence se posent car dans l'intervalle de temps entre les op√©rateurs, une autre transaction peut √™tre effectu√©e, ce qui modifiera les donn√©es visibles.  Et s'il y a un op√©rateur, il n'y a pas d'intervalle de temps. <br>  PostgreSQL dispose de suffisamment de techniques pour r√©soudre des probl√®mes complexes avec une seule instruction SQL.  Notons les expressions de table communes (CTE), dans lesquelles, parmi les autres, vous pouvez utiliser les instructions INSERT / UPDATE / DELETE, ainsi que l'instruction INSERT ON CONFLICT, qui impl√©mente la logique de "insert, mais si la ligne existe d√©j√†, mise √† jour ¬ªdans une d√©claration. <br></li><li>  Serrures personnalis√©es. <br>  Le dernier recours consiste √† d√©finir manuellement un verrou exclusif sur toutes les lignes n√©cessaires (SELECT FOR UPDATE) ou m√™me sur la table enti√®re (LOCK TABLE).  Cela fonctionne toujours, mais annule les avantages de la concurrence multiversionnelle: certaines op√©rations seront ex√©cut√©es s√©quentiellement au lieu d'une ex√©cution simultan√©e. <br></li></ul><br><h3>  Lecture incoh√©rente </h3><br>  Avant de passer au niveau d'isolement suivant, vous devez admettre que ce n'est pas aussi simple qu'il y para√Æt.  L'impl√©mentation de PostgreSQL est telle qu'elle permet d'autres anomalies, moins connues, qui ne sont pas r√©glement√©es par la norme. <br><br>  Supposons que la premi√®re transaction ait commenc√© le transfert de fonds d'un compte Bob √† l'autre: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Dans le m√™me temps, une autre transaction compte le solde de Bob et le calcul est effectu√© en boucle sur tous les comptes de Bob.  En fait, la transaction commence avec le premier compte (et, √©videmment, voit l'√©tat pr√©c√©dent): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  √Ä ce stade, la premi√®re transaction se termine avec succ√®s: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Et l'autre lit l'√©tat du deuxi√®me compte (et voit d√©j√† la nouvelle valeur): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Par cons√©quent, la deuxi√®me transaction a obtenu un total de 001100, c'est-√†-dire des donn√©es incorrectes.  Et ceci est une anomalie de <em>lecture incoh√©rente</em> . <br><br>  Comment √©viter une telle anomalie tout en restant au niveau Read Committed?  Bien s√ªr, utilisez un seul op√©rateur.  Par exemple: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  Jusqu'√† pr√©sent, j'ai affirm√© que la visibilit√© des donn√©es ne pouvait changer qu'entre op√©rateurs, mais est-ce si √©vident?  Et si la requ√™te prend du temps, peut-elle voir une partie des donn√©es dans un √©tat et une partie dans un autre? <br><br>  V√©rifions.  Une fa√ßon pratique de le faire consiste √† ins√©rer un retard forc√© dans l'op√©rateur en appelant la fonction pg_sleep.  Son param√®tre sp√©cifie le temps de retard en secondes. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Pendant que cet op√©rateur est ex√©cut√©, nous transf√©rons les fonds dans une autre transaction: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Le r√©sultat montre que l'op√©rateur voit les donn√©es dans l'√©tat qu'elles avaient au moment o√π l'ex√©cution de l'op√©rateur a commenc√©.  C'est sans aucun doute correct. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Mais ce n'est pas aussi simple ici non plus.  PostgreSQL vous permet de d√©finir des fonctions, et les fonctions ont le concept d'une <em>cat√©gorie de volatilit√©</em> .  Si une fonction VOLATILE est appel√©e dans une requ√™te et qu'une autre requ√™te est ex√©cut√©e dans cette fonction, la requ√™te √† l'int√©rieur de la fonction verra des donn√©es qui ne sont pas coh√©rentes avec les donn√©es de la requ√™te principale. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Dans ce cas, nous obtenons des donn√©es incorrectes - ‚ÇΩ100 sont perdus: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Je souligne que cet effet n'est possible qu'au niveau d'isolement Read Committed et uniquement avec les fonctions VOLATILE.  Le probl√®me est que par d√©faut, c'est exactement ce niveau d'isolement et cette cat√©gorie de volatilit√© qui sont utilis√©s.  Ne tombez pas dans le pi√®ge! <br><br><h3>  Lecture incoh√©rente en √©change de modifications perdues </h3><br>  Nous pouvons √©galement obtenir une lecture incoh√©rente au sein d'un seul op√©rateur lors d'une mise √† jour, bien que d'une mani√®re quelque peu inattendue. <br><br>  Voyons ce qui se passe lorsque deux transactions tentent de modifier la m√™me ligne.  Maintenant, Bob a ‚ÇΩ1000 sur deux comptes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Nous commen√ßons une transaction qui r√©duit le solde de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Dans le m√™me temps, dans une autre transaction, des int√©r√™ts courent sur tous les comptes clients avec un solde total √©gal ou sup√©rieur √† 1 000:: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  L'ex√©cution de l'op√©rateur UPDATE se compose de deux parties.  Tout d'abord, SELECT est r√©ellement ex√©cut√©, qui s√©lectionne les lignes √† mettre √† jour qui remplissent la condition appropri√©e.  √âtant donn√© que la modification de la premi√®re transaction n'est pas valid√©e, la deuxi√®me transaction ne peut pas la voir et la modification n'affecte pas la s√©lection des lignes pour l'accumulation des int√©r√™ts.  Eh bien, les comptes de Bob remplissent la condition et une fois la mise √† jour effectu√©e, son solde devrait augmenter de ‚ÇΩ10. <br><br>  La deuxi√®me √©tape de l'ex√©cution consiste √† mettre √† jour les lignes s√©lectionn√©es une par une.  Ici, la deuxi√®me transaction est forc√©e de ¬´se bloquer¬ª car la ligne avec id = 3 est d√©j√† verrouill√©e par la premi√®re transaction. <br><br>  Pendant ce temps, la premi√®re transaction valide les modifications: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Quel sera le r√©sultat? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Eh bien, d'une part, la commande UPDATE ne doit pas voir les modifications de la deuxi√®me transaction.  Mais d'un autre c√¥t√©, il ne faut pas perdre les modifications engag√©es lors de la deuxi√®me transaction. <br><br>  Une fois le verrou lib√©r√©, UPDATE relit la ligne qu'il tente de mettre √† jour (mais uniquement celle-ci).  En cons√©quence, Bob a accumul√© ‚ÇΩ9, sur la base du montant de 00900.  Mais si Bob avait ‚ÇΩ900, ses comptes n'auraient pas du tout √©t√© dans la s√©lection. <br><br>  Ainsi, la transaction obtient des donn√©es incorrectes: certaines des lignes sont visibles √† un moment donn√© et d'autres √† un autre.  Au lieu d'une mise √† jour perdue, nous obtenons √† nouveau l'anomalie d' <em>une lecture incoh√©rente</em> . <br><br><blockquote>  Les lecteurs attentifs notent qu'avec l'aide de l'application, vous pouvez obtenir une mise √† jour perdue m√™me au niveau de Read Committed.  Par exemple: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  La base de donn√©es n'est pas √† bl√¢mer: elle obtient deux instructions SQL et ne sait rien du fait que la valeur de x + 100 est en quelque sorte li√©e au montant des comptes.  √âvitez d'√©crire du code de cette fa√ßon. <br></blockquote><br><h2>  Lecture r√©p√©table </h2><br><h3>  L'absence de lectures non reproductibles et fant√¥mes </h3><br>  Le nom m√™me du niveau d'isolement suppose que la lecture est reproductible.  V√©rifions-le, et en m√™me temps assurez-vous qu'il n'y a pas de lectures fant√¥mes.  Pour ce faire, lors de la premi√®re transaction, nous r√©tablissons les comptes de Bob √† leur √©tat pr√©c√©dent et cr√©ons un nouveau compte pour Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Dans la deuxi√®me session, nous d√©marrons la transaction avec le niveau de lecture r√©p√©table en le sp√©cifiant dans la commande BEGIN (le niveau de la premi√®re transaction est inessentiel). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Maintenant, la premi√®re transaction valide les modifications et la seconde r√©ex√©cute la m√™me requ√™te. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  La deuxi√®me transaction voit toujours exactement les m√™mes donn√©es qu'au d√©but: aucune modification des lignes existantes ou de nouvelles lignes n'est visible. <br><br>  √Ä ce niveau, vous pouvez √©viter de vous soucier de quelque chose qui pourrait changer entre deux op√©rateurs. <br><br><h3>  Erreur de s√©rialisation en √©change de modifications perdues </h3><br>  Nous avons expliqu√© pr√©c√©demment que lorsque deux transactions mettent √† jour la m√™me ligne au niveau de lecture valid√©e, une anomalie de lecture incoh√©rente peut se produire.  En effet, la transaction en attente relit la ligne verrouill√©e et ne la voit donc pas au m√™me moment que les autres lignes. <br><br>  Au niveau de la lecture r√©p√©table, cette anomalie n'est pas autoris√©e, mais si elle se produit, rien ne peut √™tre fait - la transaction se termine donc avec une erreur de s√©rialisation.  V√©rifions-le en r√©p√©tant le m√™me sc√©nario avec l'accumulation des int√©r√™ts: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>;&lt;span/&gt; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span>&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>&lt;span/&gt; | );&lt;span/&gt;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Les donn√©es sont rest√©es coh√©rentes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  La m√™me erreur se produira dans le cas de tout autre changement concurrentiel d'une ligne, m√™me si les colonnes de notre pr√©occupation n'ont pas √©t√© r√©ellement modifi√©es. <br><br>  <em>Conclusion pratique</em> : si votre application utilise le niveau d'isolement Lecture r√©p√©table pour les transactions d'√©criture, elle doit √™tre pr√™te √† r√©p√©ter les transactions qui se sont termin√©es par une erreur de s√©rialisation.  Pour les transactions en lecture seule, ce r√©sultat n'est pas possible. <br><br><h3>  √âcriture incoh√©rente </h3><br>  Ainsi, dans PostgreSQL, au niveau d'isolement en lecture r√©p√©table, toutes les anomalies d√©crites dans la norme sont √©vit√©es.  Mais pas toutes les anomalies en g√©n√©ral.  Il s'av√®re qu'il y a <em>exactement deux</em> anomalies qui sont encore possibles.  (Cela est vrai non seulement pour PostgreSQL, mais aussi pour d'autres impl√©mentations de Snapshot Isolation.) <br><br>  La premi√®re de ces anomalies est une <em>√©criture incoh√©rente</em> . <br><br>  Soit la r√®gle de coh√©rence suivante: <em>les montants n√©gatifs sur les comptes clients sont autoris√©s si le montant total sur tous les comptes de ce client reste non n√©gatif</em> . <br><br>  La premi√®re transaction obtient le montant sur les comptes de Bob: ‚ÇΩ900. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  La deuxi√®me transaction obtient le m√™me montant. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  La premi√®re transaction estime √† juste titre que le montant de l'un des comptes peut √™tre r√©duit de ‚ÇΩ600. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Et la deuxi√®me transaction arrive √† la m√™me conclusion.  Mais cela r√©duit un autre compte: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Nous avons r√©ussi √† faire passer le solde de Bob dans le rouge, bien que chaque transaction fonctionne correctement seule. <br><br><h3>  Anomalie de transaction en lecture seule </h3><br>  Il s'agit de la deuxi√®me et derni√®re des anomalies possibles au niveau de la lecture r√©p√©table.  Pour le d√©montrer, vous aurez besoin de trois transactions, dont deux modifieront les donn√©es, et la troisi√®me ne fera que les lire. <br><br>  Mais d'abord, restaurons l'√©tat des comptes de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  Lors de la premi√®re transaction, les int√©r√™ts sur le montant disponible sur tous les comptes de Bob s'accumulent.  Les int√©r√™ts sont cr√©dit√©s sur l'un de ses comptes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Ensuite, une autre transaction retire de l'argent d'un autre compte Bob et valide ses modifications: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Si la premi√®re transaction est valid√©e √† ce stade, aucune anomalie ne se produira: on pourrait supposer que la premi√®re transaction a √©t√© ex√©cut√©e en premier puis la seconde (mais pas l'inverse car la premi√®re transaction a vu l'√©tat du compte avec id = 3 avant cela a √©t√© modifi√© lors de la deuxi√®me transaction). <br><br>  Mais imaginez qu'√† ce stade, la troisi√®me transaction (en lecture seule) commence, qui lit l'√©tat d'un compte qui n'est pas affect√© par les deux premi√®res transactions: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  Et seulement apr√®s que la premi√®re transaction soit termin√©e: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Quel √©tat la troisi√®me transaction devrait-elle voir maintenant? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Une fois lanc√©e, la troisi√®me transaction pouvait voir les changements de la deuxi√®me transaction (qui avait d√©j√† √©t√© valid√©e), mais pas de la premi√®re (qui n'avait pas encore √©t√© valid√©e).  En revanche, nous avons d√©j√† constat√© ci-dessus que la deuxi√®me transaction doit √™tre consid√©r√©e comme commenc√©e apr√®s la premi√®re.  Quel que soit l'√©tat de la troisi√®me transaction, il ne sera pas coh√©rent - ce n'est que l'anomalie d'une transaction en lecture seule.  Mais au niveau de lecture r√©p√©table, il est autoris√©: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  S√©rialisable </h2><br>  Le niveau S√©rialisable emp√™che toutes les anomalies possibles.  En fait, Serializable est construit au-dessus de l'isolement de l'instantan√©.  Les anomalies qui ne se produisent pas avec la lecture r√©p√©table (comme une lecture sale, non r√©p√©table ou fant√¥me) ne se produisent pas non plus au niveau s√©rialisable.  Et les anomalies qui se produisent (une √©criture incoh√©rente et une anomalie de transaction en lecture seule) sont d√©tect√©es et la transaction s'interrompt - une erreur de s√©rialisation famili√®re se produit: <em>impossible de s√©rialiser l'acc√®s</em> . <br><br><h3>  √âcriture incoh√©rente </h3><br>  Pour illustrer cela, r√©p√©tons le sc√©nario avec une anomalie d'√©criture incoh√©rente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Tout comme au niveau de lecture r√©p√©table, une application qui utilise le niveau d'isolement s√©rialisable doit r√©p√©ter les transactions qui se sont termin√©es par une erreur de s√©rialisation, comme le message d'erreur nous l'indique. <br><br>  Nous gagnons en simplicit√© de programmation, mais le prix √† payer est la r√©siliation forc√©e d'une partie des transactions et la n√©cessit√© de les r√©p√©ter.  La question, bien s√ªr, est de savoir quelle est la taille de cette fraction.  Si seules les transactions termin√©es qui se chevauchaient de mani√®re incomp√©tente avec d'autres transactions, cela aurait √©t√© bien.  Mais une telle impl√©mentation serait in√©vitablement gourmande en ressources et inefficace car il faudrait suivre les op√©rations sur chaque ligne. <br><br>  En fait, l'impl√©mentation de PostgreSQL est telle qu'elle autorise les faux n√©gatifs: certaines transactions absolument normales qui sont simplement ¬´malchanceuses¬ª seront √©galement abandonn√©es.  Comme nous le verrons plus loin, cela d√©pend de nombreux facteurs, tels que la disponibilit√© des index appropri√©s ou la quantit√© de RAM disponible.  En outre, il existe d'autres restrictions d'impl√©mentation (assez s√©v√®res), par exemple, les requ√™tes au niveau s√©rialisable ne fonctionneront pas sur les r√©plicas et n'utiliseront pas de plans d'ex√©cution parall√®les.  Bien que le travail d'am√©lioration de la mise en ≈ìuvre se poursuive, les limites existantes rendent ce niveau d'isolement moins attrayant. <br><blockquote>  Les plans parall√®les appara√Ætront d√®s dans PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patch</a> ).  Et les requ√™tes sur les r√©pliques peuvent commencer √† fonctionner dans PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un autre patch</a> ). <br></blockquote><br><h3>  Anomalie de transaction en lecture seule </h3><br>  Pour qu'une transaction en lecture seule n'entra√Æne pas d'anomalie et n'en souffre pas, PostgreSQL propose une technique int√©ressante: une telle transaction peut √™tre verrouill√©e jusqu'√† ce que son ex√©cution soit s√©curis√©e.  C'est le seul cas o√π un op√©rateur SELECT peut √™tre verrouill√© par des mises √† jour de lignes.  Voici √† quoi cela ressemble: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  La troisi√®me transaction est explicitement d√©clar√©e LIRE SEULEMENT et DEFERRABLE: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Lorsque vous essayez d'ex√©cuter la requ√™te, la transaction est verrouill√©e car sinon cela provoquerait une anomalie. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Et seulement apr√®s la validation de la premi√®re transaction, la troisi√®me continue l'ex√©cution: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Autre remarque importante: si l'isolement s√©rialisable est utilis√©, toutes les transactions de l'application doivent utiliser ce niveau.  Vous ne pouvez pas m√©langer des transactions valid√©es en lecture (ou en lecture r√©p√©table) avec s√©rialisables.  Autrement dit, vous <em>pouvez</em> m√©langer, mais Serializable se comportera comme une lecture r√©p√©table sans aucun avertissement.  Nous expliquerons pourquoi cela se produit plus tard, lorsque nous parlerons de la mise en ≈ìuvre. <br><br>  Donc, si vous d√©cidez d'utiliser Serializble, il est pr√©f√©rable de d√©finir globalement le niveau par d√©faut (bien que cela, bien s√ªr, ne vous emp√™che pas de sp√©cifier explicitement un niveau incorrect): <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote>  Vous pouvez trouver une pr√©sentation plus rigoureuse des probl√®mes li√©s aux transactions, √† la coh√©rence et aux anomalies dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livre</a> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cours magistral</a> de Boris Novikov ¬´Fondamentaux des technologies de base de donn√©es¬ª (disponible en russe uniquement). <br></blockquote><br><h1>  Quel niveau d'isolement utiliser? </h1><br>  Le niveau d'isolation Read Committed est utilis√© par d√©faut dans PostgreSQL, et il est probable que ce niveau soit utilis√© dans la grande majorit√© des applications.  Cette valeur par d√©faut est pratique car √† ce niveau, un abandon de transaction n'est possible qu'en cas d'√©chec, mais pas comme moyen d'√©viter une incoh√©rence.  En d'autres termes, une erreur de s√©rialisation ne peut pas se produire. <br><br>  L'autre c√¥t√© de la m√©daille est un grand nombre d'anomalies possibles, qui ont √©t√© discut√©es en d√©tail ci-dessus.  L'ing√©nieur logiciel doit toujours les garder √† l'esprit et √©crire du code afin de ne pas leur permettre d'appara√Ætre.  Si vous ne pouvez pas coder les actions n√©cessaires dans une seule instruction SQL, vous devez recourir au verrouillage explicite.  Le plus g√™nant est que le code est difficile √† tester pour les erreurs associ√©es √† l'obtention de donn√©es incoh√©rentes, et les erreurs elles-m√™mes peuvent se produire de mani√®re impr√©visible et non reproductible et sont donc difficiles √† corriger. <br><br>  Le niveau d'isolement de lecture r√©p√©table √©limine certains des probl√®mes d'incoh√©rence, mais h√©las, pas tous.  Par cons√©quent, vous devez non seulement vous souvenir des anomalies restantes, mais √©galement modifier l'application afin qu'elle g√®re correctement les erreurs de s√©rialisation.  C'est certainement g√™nant.  Mais pour les transactions en lecture seule, ce niveau compl√®te parfaitement Read Committed et est tr√®s pratique, par exemple, pour cr√©er des rapports qui utilisent plusieurs requ√™tes SQL. <br><br>  Enfin, le niveau S√©rialisable vous permet de ne pas vous soucier du tout d'incoh√©rence, ce qui facilite grandement le codage.  La seule chose qui est requise de l'application est de pouvoir r√©p√©ter n'importe quelle transaction lors de l'obtention d'une erreur de s√©rialisation.  Mais la fraction des transactions abandonn√©es, les frais suppl√©mentaires et l'incapacit√© de parall√©liser les requ√™tes peuvent r√©duire consid√©rablement le d√©bit du syst√®me.  Notez √©galement que le niveau Serializable n'est pas applicable sur les r√©plicas et qu'il ne peut pas √™tre m√©lang√© avec d'autres niveaux d'isolement. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuez √† lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467437/">https://habr.com/ru/post/fr467437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467423/index.html">Xamarin.Forms - utilisation pratique des polices d'ic√¥nes dans l'application</a></li>
<li><a href="../fr467425/index.html">Approche d'apprentissage intensif STEM</a></li>
<li><a href="../fr467427/index.html">BudgetTracker - un autre outil open-source pour la comptabilit√© des finances personnelles</a></li>
<li><a href="../fr467429/index.html">Habrastatistique: explorer les sections les plus et les moins visit√©es du site</a></li>
<li><a href="../fr467435/index.html">Nous envoyons les rapports de l'agent Veeam Linux par courrier ou par t√©l√©gramme</a></li>
<li><a href="../fr467439/index.html">Pourquoi le vinyle est-il revenu et comment les services de streaming sont-ils li√©s √† cela?</a></li>
<li><a href="../fr467443/index.html">Centre multim√©dia "Kodi" et projet Yocto</a></li>
<li><a href="../fr467445/index.html">Liste insaisissable des mises √† jour Windows install√©es</a></li>
<li><a href="../fr467449/index.html">D√©tection des vuln√©rabilit√©s et √©valuation de la r√©sistance aux attaques de pirates des cartes √† puce et des processeurs cryptographiques avec protection int√©gr√©e</a></li>
<li><a href="../fr467453/index.html">R√©solution du probl√®me du num√©ro 42 √† l'aide d'un supercalculateur plan√©taire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>