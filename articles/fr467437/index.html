<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏻 🖱️ 📔 MVCC dans PostgreSQL-1. L'isolement 👩‍👩‍👧‍👧 👩🏿‍🤝‍👨🏽 🐹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Avec cet article, je commence un ensemble de séries (ou une série d'ensembles? - En un mot, l'idée est grandiose) sur la structure inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-1. L'isolement</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/467437/">  Bonjour, Habr!  Avec cet article, je commence un ensemble de séries (ou une série d'ensembles? - En un mot, l'idée est grandiose) sur la structure interne de PostgreSQL. <br><br>  Le matériel sera basé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des cours de formation</a> (en russe) sur l'administration que Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">pluzanov</a> et moi créons.  Tout le monde n'aime pas regarder des vidéos (ce n'est certainement pas le cas), et lire des diapositives, même avec des commentaires, n'est pas bon du tout. <br><br><blockquote>  Malheureusement, le seul cours disponible en anglais pour le moment est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduction de 2 jours à PostgreSQL 11</a> . <br></blockquote><br>  Bien sûr, les articles ne seront pas exactement les mêmes que le contenu des cours.  Je ne parlerai que de la façon dont tout est organisé, en omettant l'administration elle-même, mais j'essaierai de le faire plus en détail et de manière plus approfondie.  Et je crois que ces connaissances sont aussi utiles à un développeur d'applications qu'à un administrateur. <br><br>  Je vais cibler ceux qui ont déjà une certaine expérience de l'utilisation de PostgreSQL et au moins en général comprendre ce qui est quoi.  Le texte sera trop difficile pour les débutants.  Par exemple, je ne dirai pas un mot sur la façon d'installer PostgreSQL et d'exécuter psql. <br><br>  Le contenu en question ne varie pas beaucoup d'une version à l'autre, mais j'utiliserai le 11e PostgreSQL vanilla actuel. <br><br>  La première série traite des problèmes liés à l'isolement et à la concurrence multiversionnelle, et le plan de la série est le suivant: <br><br><ol><li>  Isolement tel que compris par le standard et PostgreSQL (cet article). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Forks, fichiers, pages</a> - ce qui se passe au niveau physique. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Versions de ligne</a> , transactions virtuelles et sous-transactions. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instantanés de données</a> et visibilité des versions de ligne;  l'horizon des événements. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vide sur la page et mises à jour CHAUDES</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vide normal</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autovacuum</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformation et gel de l'ID de transaction</a> . </li></ol><br>  C'est parti! <br><br><blockquote>  Et avant de commencer, je voudrais remercier Elena Indrupskaya d'avoir traduit les articles en anglais. <br></blockquote><br><a name="habracut"></a><br><h1>  Qu'est-ce que l'isolement et pourquoi est-il important? </h1><br>  Probablement, tout le monde est au moins conscient de l'existence de transactions, est tombé sur l'abréviation ACID et a entendu parler des niveaux d'isolement.  Mais nous nous trouvons toujours face à l'opinion que cela relève de la théorie, ce qui n'est pas nécessaire dans la pratique.  Je vais donc passer un peu de temps à expliquer pourquoi c'est vraiment important. <br><br>  Il est peu probable que vous soyez satisfait si une application obtient des données incorrectes de la base de données ou si l'application écrit des données incorrectes dans la base de données. <br><br>  Mais que sont les données «correctes»?  Il est connu que des <em>contraintes d'intégrité</em> , telles que NOT NULL ou UNIQUE, peuvent être créées au niveau de la base de données.  Si les données respectent toujours les contraintes d'intégrité (et c'est le cas puisque le SGBD le garantit), alors elles sont intégrales. <br><br>  Les mêmes choses sont-elles <em>correctes</em> et <em>intégrales</em> ?  Pas exactement.  Toutes les contraintes ne peuvent pas être spécifiées au niveau de la base de données.  Certaines contraintes sont trop compliquées, par exemple, qui couvrent plusieurs tables à la fois.  Et même si une contrainte en général aurait pu être définie dans la base de données, mais pour une raison inconnue, cela ne signifie pas que la contrainte peut être violée. <br><br>  Ainsi, l' <em>exactitude</em> est plus forte que l' <em>intégrité</em> , mais nous ne savons pas exactement ce que cela signifie.  Nous devons admettre que «l'étalon-or» de la rectitude est une application qui, comme nous aimerions le croire, est écrite <em>correctement</em> et ne fonctionne jamais mal.  Dans tous les cas, si une application ne viole pas l'intégrité, mais viole l'exactitude, le SGBD n'en sera pas informé et n'attrapera pas l'application «en flagrant délit». <br><br>  De plus, nous utiliserons le terme <em>cohérence</em> pour désigner l'exactitude. <br><br>  Supposons cependant qu'une application exécute uniquement des séquences d'opérateurs correctes.  Quel est le rôle du SGBD si l'application est correcte en l'état? <br><br>  Tout d'abord, il s'avère qu'une séquence correcte d'opérateurs peut temporairement rompre la cohérence des données et, curieusement, c'est normal.  Un exemple galvaudé mais clair est un transfert de fonds d'un compte à un autre.  La règle de cohérence peut ressembler à ceci: <em>un transfert ne modifie jamais le montant total d'argent sur les comptes</em> (cette règle est assez difficile à spécifier dans SQL en tant que contrainte d'intégrité, elle existe donc au niveau de l'application et est invisible pour le SGBD).  Un transfert se compose de deux opérations: la première réduit les fonds sur un compte, et la seconde - les augmente sur l'autre.  La première opération rompt la cohérence des données, tandis que la seconde la restaure. <br><br><blockquote>  Un bon exercice consiste à appliquer la règle ci-dessus au niveau des contraintes d'intégrité. <br></blockquote><br>  Que faire si la première opération est effectuée et que la seconde ne l'est pas?  En fait, sans trop de bruit: lors de la deuxième opération, il peut se produire une panne d'électricité, une panne de serveur, une division par zéro - peu importe.  Il est clair que la cohérence sera rompue et cela ne peut pas être autorisé.  En général, il est possible de résoudre ces problèmes au niveau de l'application, mais au prix d'efforts considérables;  cependant, heureusement, ce n'est pas nécessaire: cela se fait par le SGBD.  Mais pour ce faire, le SGBD doit savoir que les deux opérations sont un tout indivisible.  Autrement dit, <em>une transaction</em> . <br><br>  Cela s'avère intéressant: comme le SGBD sait que les opérations constituent une transaction, il aide à maintenir la cohérence en s'assurant que les transactions sont atomiques, et il le fait sans rien savoir des règles de cohérence spécifiques. <br><br>  Mais il y a un deuxième point, plus subtil.  Dès que plusieurs transactions simultanées apparaissent dans le système, qui sont absolument correctes séparément, elles peuvent ne pas fonctionner correctement ensemble.  En effet, l'ordre des opérations est mélangé: vous ne pouvez pas supposer que toutes les opérations d'une transaction sont effectuées en premier, puis toutes les opérations de l'autre. <br><br>  Une note sur la simultanéité.  En effet, les transactions peuvent s'exécuter simultanément sur un système doté d'un processeur multicœur, d'une baie de disques, etc.  Mais le même raisonnement vaut pour un serveur qui exécute des commandes séquentiellement, dans un mode de partage de temps: pendant certains cycles d'horloge, une transaction est exécutée et pendant certains cycles suivants, l'autre.  Parfois, le terme exécution <em>simultanée</em> est utilisé pour une généralisation. <br><br>  Les situations où les transactions correctes fonctionnent incorrectement sont appelées <em>anomalies</em> d'exécution simultanée. <br><br>  Pour un exemple simple: si une application veut obtenir des données correctes de la base de données, elle ne doit pas, au moins, voir les changements d'autres transactions non validées.  Sinon, vous pouvez non seulement obtenir des données incohérentes, mais également voir quelque chose qui n'a jamais été dans la base de données (si la transaction est annulée).  Cette anomalie est appelée une <em>lecture sale</em> . <br><br>  Il y a d'autres anomalies, plus complexes, que nous traiterons un peu plus tard. <br><br>  Il est certainement impossible d'éviter l'exécution simultanée: sinon, de quel type de performance peut-on parler?  Mais vous ne pouvez pas non plus travailler avec des données incorrectes. <br><br>  Et encore une fois, le SGBD vient à la rescousse.  Vous pouvez effectuer des transactions <em>comme si elles étaient</em> séquentielles, <em>comme si</em> elles se succédaient.  En d'autres termes - <em>isolés les</em> uns des autres.  En réalité, le SGBD peut effectuer des opérations mélangées, mais assurez-vous que le résultat d'une exécution simultanée sera le même que le résultat de certaines des exécutions séquentielles possibles.  Et cela élimine toutes les anomalies possibles. <br><br>  Nous sommes donc arrivés à la définition: <br><br><blockquote>  Une transaction est un ensemble d'opérations effectuées par une application qui transfère une base de données d'un état correct à un autre état correct (cohérence), à ​​condition que la transaction soit terminée (atomicité) et sans interférence d'autres transactions (isolement). <br></blockquote><br>  Cette définition unit les trois premières lettres de l'acronyme ACID.  Ils sont si étroitement liés les uns aux autres qu'il est insensé de considérer l'un sans les autres.  En fait, il est également difficile de détacher la lettre D (durabilité).  En effet, lorsqu'un système se bloque, il présente toujours des modifications de transactions non validées, avec lesquelles vous devez faire quelque chose pour restaurer la cohérence des données. <br><br>  Tout aurait été parfait, mais la mise en œuvre d'une isolation complète est une tâche techniquement difficile entraînant une réduction du débit du système.  Par conséquent, dans la pratique très souvent (pas toujours, mais presque toujours) l'isolement affaibli est utilisé, ce qui empêche certaines, mais pas toutes les anomalies.  Cela signifie qu'une partie du travail visant à garantir l'exactitude des données incombe à l'application.  Pour cette raison, il est très important de comprendre quel niveau d'isolement est utilisé dans le système, ce qui le garantit et ce qu'il ne donne pas, et comment écrire du code correct dans de telles conditions. <br><br><h1>  Niveaux d'isolement et anomalies dans la norme SQL </h1><br>  Le standard SQL décrit depuis longtemps quatre niveaux d'isolement.  Ces niveaux sont définis en répertoriant les anomalies autorisées ou non lorsque les transactions sont exécutées simultanément à ce niveau.  Par conséquent, pour parler de ces niveaux, il est nécessaire de connaître les anomalies. <br><br>  J'insiste sur le fait que, dans cette partie, nous parlons de la norme, c'est-à-dire d'une théorie, sur laquelle la pratique se fonde de manière significative, mais à partir de laquelle elle diverge de manière significative.  Par conséquent, tous les exemples ici sont spéculatifs.  Ils utiliseront les mêmes opérations sur les comptes clients: c'est assez démonstratif, même si, certes, cela n'a rien à voir avec l'organisation des opérations bancaires dans la réalité. <br><br><h2>  Mise à jour des pertes </h2><br>  Commençons par une <em>mise à jour perdue</em> .  Cette anomalie se produit lorsque deux transactions lisent la même ligne de la table, puis une transaction met à jour cette ligne, puis la deuxième transaction met également à jour la même ligne sans prendre en compte les modifications apportées par la première transaction. <br><br>  Par exemple, deux transactions vont augmenter le montant sur le même compte de ₽100 (₽ est le symbole monétaire du rouble russe).  La première transaction lit la valeur actuelle (₽1000), puis la deuxième transaction lit la même valeur.  La première transaction augmente le montant (cela donne ₽1100) et écrit cette valeur.  La deuxième transaction agit de la même manière: elle obtient le même ₽1100 et écrit cette valeur.  En conséquence, le client a perdu 100 ₽. <br><br>  La norme n'autorise pas les mises à jour perdues à n'importe quel niveau d'isolement. <br><br><h2>  Lecture sale et lecture non validée </h2><br>  Une <em>lecture sale</em> est ce que nous avons déjà appris.  Cette anomalie se produit lorsqu'une transaction lit des modifications qui n'ont pas encore été validées par une autre transaction. <br><br>  Par exemple, la première transaction transfère tout l'argent du compte du client vers un autre compte, mais n'engage pas la modification.  Une autre transaction lit le solde du compte, pour obtenir ₽0, et refuse de retirer de l'argent au client, bien que la première transaction abandonne et annule ses modifications, de sorte que la valeur de 0 n'a jamais existé dans la base de données. <br><br>  La norme autorise les lectures incorrectes au niveau de lecture non validée. <br><br><h2>  Lecture non répétable et lecture validée </h2><br>  Une anomalie de <em>lecture non répétable</em> se produit lorsqu'une transaction lit deux fois la même ligne, et entre les lectures, la deuxième transaction modifie (ou supprime) cette ligne et valide les modifications.  Ensuite, la première transaction obtiendra des résultats différents. <br><br>  Par exemple, laissez une règle de cohérence <em>interdire les montants négatifs sur les comptes clients</em> .  La première transaction va réduire le montant du compte de ₽100.  Il vérifie la valeur actuelle, obtient ₽1000 et décide que la diminution est possible.  Dans le même temps, la deuxième transaction réduit à zéro le montant du compte et valide les modifications.  Si la première transaction revérifiait maintenant le montant, elle obtiendrait ₽0 (mais elle a déjà décidé de réduire la valeur, et le compte «passe au rouge»). <br><br>  La norme autorise les lectures non répétables aux niveaux Lecture non validée et Lecture validée.  Mais Read Committed ne permet pas de lectures incorrectes. <br><br><h2>  Lecture fantôme et lecture répétable </h2><br>  Une <em>lecture fantôme</em> se produit lorsqu'une transaction lit un ensemble de lignes par la même condition deux fois, et entre les lectures, la deuxième transaction ajoute des lignes qui remplissent cette condition (et valide les modifications).  Ensuite, la première transaction obtiendra un ensemble différent de lignes. <br><br>  Par exemple, laissez une règle de cohérence <em>empêcher un client d'avoir plus de 3 comptes</em> .  La première transaction va ouvrir un nouveau compte, vérifie le nombre actuel de comptes (disons, 2) et décide que l'ouverture est possible.  Dans le même temps, la deuxième transaction ouvre également un nouveau compte pour le client et valide les modifications.  Maintenant, si la première transaction revérifiait le nombre, il obtiendrait 3 (mais il ouvre déjà un autre compte, et le client semble en avoir 4). <br><br>  La norme autorise les lectures fantômes aux niveaux Lecture non validée, Lecture validée et Lecture répétable.  Cependant, la lecture non répétable n'est pas autorisée au niveau de la lecture répétable. <br><br><h2>  L'absence d'anomalies et sérialisables </h2><br>  La norme définit un niveau de plus - Sérialisable - qui ne permet aucune anomalie.  Et ce n'est pas la même chose que d'interdire les mises à jour perdues et les lectures sales, non répétables ou fantômes. <br><br>  Le fait est qu'il y a beaucoup plus d'anomalies connues que celles énumérées dans la norme et aussi un nombre inconnu de celles encore inconnues. <br><br>  Le niveau sérialisable doit empêcher <em>absolument toutes les</em> anomalies.  Cela signifie qu'à ce niveau, un développeur d'applications n'a pas besoin de penser à l'exécution simultanée.  Si les transactions exécutent une séquence correcte d'opérateurs travaillant séparément, les données seront également cohérentes lorsque ces transactions seront exécutées simultanément. <br><br><h2>  Tableau récapitulatif </h2><br>  Nous pouvons maintenant fournir un tableau bien connu.  Mais ici, la dernière colonne, qui manque dans la norme, est ajoutée pour plus de clarté. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Changements perdus </th><th>  Lecture sale </th><th>  Lecture non répétable </th><th>  Lecture fantôme </th><th>  Autres anomalies </th></tr><tr><th>  Lire sans engagement </th><th>  - </th><th>  Oui </th><th>  Oui </th><th>  Oui </th><th>  Oui </th></tr><tr><th>  Lire engagé </th><th>  - </th><th>  - </th><th>  Oui </th><th>  Oui </th><th>  Oui </th></tr><tr><th>  Lecture répétable </th><th>  - </th><th>  - </th><th>  - </th><th>  Oui </th><th>  Oui </th></tr><tr><th>  Sérialisable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br><h2>  Pourquoi exactement ces anomalies? </h2><br>  Pourquoi la norme ne répertorie-t-elle que quelques-unes des nombreuses anomalies possibles et pourquoi sont-elles exactement celles-ci? <br><br>  Personne ne semble le savoir avec certitude.  Mais ici, la pratique est évidemment en avance sur la théorie, il est donc possible qu'à cette époque (de la norme SQL: 92) d'autres anomalies n'aient pas été simplement pensées. <br><br>  De plus, on a supposé que l'isolement devait être construit sur des serrures.  L'idée derrière le <em>protocole de verrouillage à deux phases</em> largement utilisé (2PL) est que lors de l'exécution, une transaction verrouille les lignes avec lesquelles elle travaille et libère les verrous à la fin.  Simplifiant considérablement, plus une transaction acquiert de verrous, mieux elle est isolée des autres transactions.  Mais les performances du système souffrent également davantage, car au lieu de travailler ensemble, les transactions commencent à se mettre en file d'attente pour les mêmes lignes. <br><br>  Mon sentiment est que c'est juste le nombre de verrous requis, qui explique la différence entre les niveaux d'isolement de la norme. <br><br>  Si une transaction verrouille les lignes à modifier de la mise à jour, mais pas de la lecture, nous obtenons le niveau de lecture non validée: les modifications perdues ne sont pas autorisées, mais les données non validées peuvent être lues. <br><br>  Si une transaction verrouille les lignes à modifier à la fois de la lecture et de la mise à jour, nous obtenons le niveau de lecture validée: vous ne pouvez pas lire les données non validées, mais vous pouvez obtenir une valeur différente (lecture non répétable) lorsque vous accédez à nouveau à la ligne. <br><br>  Si une transaction verrouille les lignes à lire et à modifier et à la fois de la lecture et de la mise à jour, nous obtenons le niveau de lecture répétable: relire la ligne retournera la même valeur. <br><br>  Mais il y a un problème avec Serializable: vous ne pouvez pas verrouiller une ligne qui n'existe pas encore.  Par conséquent, une lecture fantôme est toujours possible: une autre transaction peut ajouter (mais pas supprimer) une ligne qui remplit les conditions d'une requête précédemment exécutée, et cette ligne sera incluse dans la resélection. <br><br>  Par conséquent, pour implémenter le niveau Sérialisable, les verrous normaux ne suffisent pas - vous devez verrouiller les conditions (prédicats) plutôt que les lignes.  Par conséquent, ces verrous étaient appelés <em>prédicats</em> .  Ils ont été proposés en 1976, mais leur applicabilité pratique est limitée par des conditions assez simples pour lesquelles il est clair comment joindre deux prédicats différents.  Pour autant que je sache, de tels verrous n'ont jamais été implémentés dans aucun système jusqu'à présent. <br><br><h1>  Niveaux d'isolement dans PostgreSQL </h1><br>  Au fil du temps, les protocoles de gestion des transactions basés sur les verrous ont été remplacés par le protocole Snapshot Isolation (SI).  Son idée est que chaque transaction fonctionne avec un instantané cohérent des données à un certain point dans le temps, et seules ces modifications entrent dans l'instantané qui ont été validées avant sa création. <br><br>  Cette isolation empêche automatiquement les lectures sales.  Formellement, vous pouvez spécifier le niveau Read Uncommitted dans PostgreSQL, mais cela fonctionnera exactement de la même manière que Read Committed.  Par conséquent, nous ne parlerons pas du tout du niveau Read Uncommitted. <br><br>  PostgreSQL implémente une variante <em>multiversionnelle</em> de ce protocole.  L'idée de la concurrence multiversionnelle est que plusieurs versions de la même ligne peuvent coexister dans un SGBD.  Cela vous permet de créer un instantané des données à l'aide des versions existantes et d'utiliser un minimum de verrous.  En fait, seules les modifications ultérieures de la même ligne sont verrouillées.  Toutes les autres opérations sont effectuées simultanément: les transactions d'écriture ne verrouillent jamais les transactions en lecture seule et les transactions en lecture seule ne verrouillent jamais rien. <br><br>  En utilisant des instantanés de données, l'isolement dans PostgreSQL est plus strict que requis par la norme: le niveau de lecture répétable ne permet pas seulement des lectures non répétables, mais aussi des lectures fantômes (bien qu'il ne fournisse pas une isolation complète).  Et cela est réalisé sans perte d'efficacité. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Changements perdus </th><th>  Lecture sale </th><th>  Lecture non répétable </th><th>  Lecture fantôme </th><th>  Autres anomalies </th></tr><tr><th>  Lire sans engagement </th><th>  - </th><th>  - </th><th>  Oui </th><th>  Oui </th><th>  Oui </th></tr><tr><th>  Lire engagé </th><th>  - </th><th>  - </th><th>  Oui </th><th>  Oui </th><th>  Oui </th></tr><tr><th>  Lecture répétable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  Oui </th></tr><tr><th>  Sérialisable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br>  Nous parlerons dans les prochains articles de la façon dont la concurrence multiversionnelle est mise en œuvre «sous le capot», et maintenant nous examinerons en détail chacun des trois niveaux avec l'œil d'un utilisateur (comme vous le savez, le plus intéressant se cache derrière «d'autres anomalies»). ”).  Pour ce faire, créons un tableau des comptes.  Alice et Bob ont chacun 1000 livres sterling, mais Bob a deux comptes ouverts: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Lire engagé </h2><br><h3>  L'absence de lecture sale </h3><br>  Il est facile de s'assurer que les données sales ne peuvent pas être lues.  Nous commençons la transaction.  Par défaut, il utilisera le niveau d'isolement Read Committed: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  Plus précisément, le niveau par défaut est défini par le paramètre, qui peut être modifié si nécessaire: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Ainsi, dans une transaction ouverte, nous retirons des fonds du compte, mais n'engageons pas les modifications.  La transaction voit ses propres changements: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  Dans la deuxième session, nous commencerons une autre transaction avec le même niveau de lecture validée.  Pour distinguer les transactions, les commandes de la deuxième transaction seront mises en retrait et marquées d'une barre. <br><br>  Afin de répéter les commandes ci-dessus (ce qui est utile), vous devez ouvrir deux terminaux et exécuter psql dans chacun d'eux.  Dans le premier terminal, vous pouvez entrer les commandes d'une transaction, et dans le second - celles de l'autre. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Comme prévu, l'autre transaction ne voit pas de modifications non validées car les lectures incorrectes ne sont pas autorisées. <br><br><h3>  Lecture non répétable </h3><br>  Maintenant, laissez la première transaction valider les modifications et la seconde réexécute la même requête. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  La requête obtient déjà de nouvelles données - et c'est l'anomalie de <em>lecture non répétable</em> , qui est autorisée au niveau de lecture validée. <br><br>  <em>Conclusion pratique</em> : dans une transaction, vous ne pouvez pas prendre de décisions basées sur des données lues par un opérateur précédent car les choses peuvent changer entre l'exécution des opérateurs.  Voici un exemple dont les variations se produisent si souvent dans le code d'application qu'il est considéré comme un contre-modèle classique: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  Pendant le temps qui s'écoule entre la vérification et la mise à jour, d'autres transactions peuvent changer l'état du compte de quelque façon que ce soit, donc un tel «chèque» ne sécurise rien.  Il est commode d'imaginer qu'entre les opérateurs d'une transaction, tout autre opérateur d'autres transactions peut se «coincer», par exemple, comme suit: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Si tout peut être gâché en réorganisant les opérateurs, le code est mal écrit.  Et ne vous trompez pas qu'une telle coïncidence ne se produira pas - elle le sera, c'est certain. <br><br>  Mais comment écrire du code correctement?  Les options sont généralement les suivantes: <br><br><ul><li>  Ne pas écrire de code. <br>  Ce n'est pas une blague.  Par exemple, dans ce cas, la vérification se transforme facilement en contrainte d'intégrité: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  Aucune vérification n'est nécessaire maintenant: effectuez simplement l'opération et, si nécessaire, gérez l'exception qui se produira si une violation d'intégrité est tentée. <br></li><li>  Pour utiliser une seule instruction SQL. <br>  Des problèmes de cohérence se posent car dans l'intervalle de temps entre les opérateurs, une autre transaction peut être effectuée, ce qui modifiera les données visibles.  Et s'il y a un opérateur, il n'y a pas d'intervalle de temps. <br>  PostgreSQL dispose de suffisamment de techniques pour résoudre des problèmes complexes avec une seule instruction SQL.  Notons les expressions de table communes (CTE), dans lesquelles, parmi les autres, vous pouvez utiliser les instructions INSERT / UPDATE / DELETE, ainsi que l'instruction INSERT ON CONFLICT, qui implémente la logique de "insert, mais si la ligne existe déjà, mise à jour »dans une déclaration. <br></li><li>  Serrures personnalisées. <br>  Le dernier recours consiste à définir manuellement un verrou exclusif sur toutes les lignes nécessaires (SELECT FOR UPDATE) ou même sur la table entière (LOCK TABLE).  Cela fonctionne toujours, mais annule les avantages de la concurrence multiversionnelle: certaines opérations seront exécutées séquentiellement au lieu d'une exécution simultanée. <br></li></ul><br><h3>  Lecture incohérente </h3><br>  Avant de passer au niveau d'isolement suivant, vous devez admettre que ce n'est pas aussi simple qu'il y paraît.  L'implémentation de PostgreSQL est telle qu'elle permet d'autres anomalies, moins connues, qui ne sont pas réglementées par la norme. <br><br>  Supposons que la première transaction ait commencé le transfert de fonds d'un compte Bob à l'autre: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Dans le même temps, une autre transaction compte le solde de Bob et le calcul est effectué en boucle sur tous les comptes de Bob.  En fait, la transaction commence avec le premier compte (et, évidemment, voit l'état précédent): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  À ce stade, la première transaction se termine avec succès: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Et l'autre lit l'état du deuxième compte (et voit déjà la nouvelle valeur): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Par conséquent, la deuxième transaction a obtenu un total de 001100, c'est-à-dire des données incorrectes.  Et ceci est une anomalie de <em>lecture incohérente</em> . <br><br>  Comment éviter une telle anomalie tout en restant au niveau Read Committed?  Bien sûr, utilisez un seul opérateur.  Par exemple: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  Jusqu'à présent, j'ai affirmé que la visibilité des données ne pouvait changer qu'entre opérateurs, mais est-ce si évident?  Et si la requête prend du temps, peut-elle voir une partie des données dans un état et une partie dans un autre? <br><br>  Vérifions.  Une façon pratique de le faire consiste à insérer un retard forcé dans l'opérateur en appelant la fonction pg_sleep.  Son paramètre spécifie le temps de retard en secondes. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Pendant que cet opérateur est exécuté, nous transférons les fonds dans une autre transaction: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Le résultat montre que l'opérateur voit les données dans l'état qu'elles avaient au moment où l'exécution de l'opérateur a commencé.  C'est sans aucun doute correct. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Mais ce n'est pas aussi simple ici non plus.  PostgreSQL vous permet de définir des fonctions, et les fonctions ont le concept d'une <em>catégorie de volatilité</em> .  Si une fonction VOLATILE est appelée dans une requête et qu'une autre requête est exécutée dans cette fonction, la requête à l'intérieur de la fonction verra des données qui ne sont pas cohérentes avec les données de la requête principale. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Dans ce cas, nous obtenons des données incorrectes - ₽100 sont perdus: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Je souligne que cet effet n'est possible qu'au niveau d'isolement Read Committed et uniquement avec les fonctions VOLATILE.  Le problème est que par défaut, c'est exactement ce niveau d'isolement et cette catégorie de volatilité qui sont utilisés.  Ne tombez pas dans le piège! <br><br><h3>  Lecture incohérente en échange de modifications perdues </h3><br>  Nous pouvons également obtenir une lecture incohérente au sein d'un seul opérateur lors d'une mise à jour, bien que d'une manière quelque peu inattendue. <br><br>  Voyons ce qui se passe lorsque deux transactions tentent de modifier la même ligne.  Maintenant, Bob a ₽1000 sur deux comptes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Nous commençons une transaction qui réduit le solde de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Dans le même temps, dans une autre transaction, des intérêts courent sur tous les comptes clients avec un solde total égal ou supérieur à 1 000:: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  L'exécution de l'opérateur UPDATE se compose de deux parties.  Tout d'abord, SELECT est réellement exécuté, qui sélectionne les lignes à mettre à jour qui remplissent la condition appropriée.  Étant donné que la modification de la première transaction n'est pas validée, la deuxième transaction ne peut pas la voir et la modification n'affecte pas la sélection des lignes pour l'accumulation des intérêts.  Eh bien, les comptes de Bob remplissent la condition et une fois la mise à jour effectuée, son solde devrait augmenter de ₽10. <br><br>  La deuxième étape de l'exécution consiste à mettre à jour les lignes sélectionnées une par une.  Ici, la deuxième transaction est forcée de «se bloquer» car la ligne avec id = 3 est déjà verrouillée par la première transaction. <br><br>  Pendant ce temps, la première transaction valide les modifications: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Quel sera le résultat? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Eh bien, d'une part, la commande UPDATE ne doit pas voir les modifications de la deuxième transaction.  Mais d'un autre côté, il ne faut pas perdre les modifications engagées lors de la deuxième transaction. <br><br>  Une fois le verrou libéré, UPDATE relit la ligne qu'il tente de mettre à jour (mais uniquement celle-ci).  En conséquence, Bob a accumulé ₽9, sur la base du montant de 00900.  Mais si Bob avait ₽900, ses comptes n'auraient pas du tout été dans la sélection. <br><br>  Ainsi, la transaction obtient des données incorrectes: certaines des lignes sont visibles à un moment donné et d'autres à un autre.  Au lieu d'une mise à jour perdue, nous obtenons à nouveau l'anomalie d' <em>une lecture incohérente</em> . <br><br><blockquote>  Les lecteurs attentifs notent qu'avec l'aide de l'application, vous pouvez obtenir une mise à jour perdue même au niveau de Read Committed.  Par exemple: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  La base de données n'est pas à blâmer: elle obtient deux instructions SQL et ne sait rien du fait que la valeur de x + 100 est en quelque sorte liée au montant des comptes.  Évitez d'écrire du code de cette façon. <br></blockquote><br><h2>  Lecture répétable </h2><br><h3>  L'absence de lectures non reproductibles et fantômes </h3><br>  Le nom même du niveau d'isolement suppose que la lecture est reproductible.  Vérifions-le, et en même temps assurez-vous qu'il n'y a pas de lectures fantômes.  Pour ce faire, lors de la première transaction, nous rétablissons les comptes de Bob à leur état précédent et créons un nouveau compte pour Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Dans la deuxième session, nous démarrons la transaction avec le niveau de lecture répétable en le spécifiant dans la commande BEGIN (le niveau de la première transaction est inessentiel). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Maintenant, la première transaction valide les modifications et la seconde réexécute la même requête. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  La deuxième transaction voit toujours exactement les mêmes données qu'au début: aucune modification des lignes existantes ou de nouvelles lignes n'est visible. <br><br>  À ce niveau, vous pouvez éviter de vous soucier de quelque chose qui pourrait changer entre deux opérateurs. <br><br><h3>  Erreur de sérialisation en échange de modifications perdues </h3><br>  Nous avons expliqué précédemment que lorsque deux transactions mettent à jour la même ligne au niveau de lecture validée, une anomalie de lecture incohérente peut se produire.  En effet, la transaction en attente relit la ligne verrouillée et ne la voit donc pas au même moment que les autres lignes. <br><br>  Au niveau de la lecture répétable, cette anomalie n'est pas autorisée, mais si elle se produit, rien ne peut être fait - la transaction se termine donc avec une erreur de sérialisation.  Vérifions-le en répétant le même scénario avec l'accumulation des intérêts: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>;&lt;span/&gt; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span>&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>&lt;span/&gt; | );&lt;span/&gt;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Les données sont restées cohérentes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  La même erreur se produira dans le cas de tout autre changement concurrentiel d'une ligne, même si les colonnes de notre préoccupation n'ont pas été réellement modifiées. <br><br>  <em>Conclusion pratique</em> : si votre application utilise le niveau d'isolement Lecture répétable pour les transactions d'écriture, elle doit être prête à répéter les transactions qui se sont terminées par une erreur de sérialisation.  Pour les transactions en lecture seule, ce résultat n'est pas possible. <br><br><h3>  Écriture incohérente </h3><br>  Ainsi, dans PostgreSQL, au niveau d'isolement en lecture répétable, toutes les anomalies décrites dans la norme sont évitées.  Mais pas toutes les anomalies en général.  Il s'avère qu'il y a <em>exactement deux</em> anomalies qui sont encore possibles.  (Cela est vrai non seulement pour PostgreSQL, mais aussi pour d'autres implémentations de Snapshot Isolation.) <br><br>  La première de ces anomalies est une <em>écriture incohérente</em> . <br><br>  Soit la règle de cohérence suivante: <em>les montants négatifs sur les comptes clients sont autorisés si le montant total sur tous les comptes de ce client reste non négatif</em> . <br><br>  La première transaction obtient le montant sur les comptes de Bob: ₽900. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  La deuxième transaction obtient le même montant. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  La première transaction estime à juste titre que le montant de l'un des comptes peut être réduit de ₽600. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Et la deuxième transaction arrive à la même conclusion.  Mais cela réduit un autre compte: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Nous avons réussi à faire passer le solde de Bob dans le rouge, bien que chaque transaction fonctionne correctement seule. <br><br><h3>  Anomalie de transaction en lecture seule </h3><br>  Il s'agit de la deuxième et dernière des anomalies possibles au niveau de la lecture répétable.  Pour le démontrer, vous aurez besoin de trois transactions, dont deux modifieront les données, et la troisième ne fera que les lire. <br><br>  Mais d'abord, restaurons l'état des comptes de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  Lors de la première transaction, les intérêts sur le montant disponible sur tous les comptes de Bob s'accumulent.  Les intérêts sont crédités sur l'un de ses comptes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Ensuite, une autre transaction retire de l'argent d'un autre compte Bob et valide ses modifications: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Si la première transaction est validée à ce stade, aucune anomalie ne se produira: on pourrait supposer que la première transaction a été exécutée en premier puis la seconde (mais pas l'inverse car la première transaction a vu l'état du compte avec id = 3 avant cela a été modifié lors de la deuxième transaction). <br><br>  Mais imaginez qu'à ce stade, la troisième transaction (en lecture seule) commence, qui lit l'état d'un compte qui n'est pas affecté par les deux premières transactions: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  Et seulement après que la première transaction soit terminée: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Quel état la troisième transaction devrait-elle voir maintenant? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Une fois lancée, la troisième transaction pouvait voir les changements de la deuxième transaction (qui avait déjà été validée), mais pas de la première (qui n'avait pas encore été validée).  En revanche, nous avons déjà constaté ci-dessus que la deuxième transaction doit être considérée comme commencée après la première.  Quel que soit l'état de la troisième transaction, il ne sera pas cohérent - ce n'est que l'anomalie d'une transaction en lecture seule.  Mais au niveau de lecture répétable, il est autorisé: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  Sérialisable </h2><br>  Le niveau Sérialisable empêche toutes les anomalies possibles.  En fait, Serializable est construit au-dessus de l'isolement de l'instantané.  Les anomalies qui ne se produisent pas avec la lecture répétable (comme une lecture sale, non répétable ou fantôme) ne se produisent pas non plus au niveau sérialisable.  Et les anomalies qui se produisent (une écriture incohérente et une anomalie de transaction en lecture seule) sont détectées et la transaction s'interrompt - une erreur de sérialisation familière se produit: <em>impossible de sérialiser l'accès</em> . <br><br><h3>  Écriture incohérente </h3><br>  Pour illustrer cela, répétons le scénario avec une anomalie d'écriture incohérente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Tout comme au niveau de lecture répétable, une application qui utilise le niveau d'isolement sérialisable doit répéter les transactions qui se sont terminées par une erreur de sérialisation, comme le message d'erreur nous l'indique. <br><br>  Nous gagnons en simplicité de programmation, mais le prix à payer est la résiliation forcée d'une partie des transactions et la nécessité de les répéter.  La question, bien sûr, est de savoir quelle est la taille de cette fraction.  Si seules les transactions terminées qui se chevauchaient de manière incompétente avec d'autres transactions, cela aurait été bien.  Mais une telle implémentation serait inévitablement gourmande en ressources et inefficace car il faudrait suivre les opérations sur chaque ligne. <br><br>  En fait, l'implémentation de PostgreSQL est telle qu'elle autorise les faux négatifs: certaines transactions absolument normales qui sont simplement «malchanceuses» seront également abandonnées.  Comme nous le verrons plus loin, cela dépend de nombreux facteurs, tels que la disponibilité des index appropriés ou la quantité de RAM disponible.  En outre, il existe d'autres restrictions d'implémentation (assez sévères), par exemple, les requêtes au niveau sérialisable ne fonctionneront pas sur les réplicas et n'utiliseront pas de plans d'exécution parallèles.  Bien que le travail d'amélioration de la mise en œuvre se poursuive, les limites existantes rendent ce niveau d'isolement moins attrayant. <br><blockquote>  Les plans parallèles apparaîtront dès dans PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patch</a> ).  Et les requêtes sur les répliques peuvent commencer à fonctionner dans PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un autre patch</a> ). <br></blockquote><br><h3>  Anomalie de transaction en lecture seule </h3><br>  Pour qu'une transaction en lecture seule n'entraîne pas d'anomalie et n'en souffre pas, PostgreSQL propose une technique intéressante: une telle transaction peut être verrouillée jusqu'à ce que son exécution soit sécurisée.  C'est le seul cas où un opérateur SELECT peut être verrouillé par des mises à jour de lignes.  Voici à quoi cela ressemble: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  La troisième transaction est explicitement déclarée LIRE SEULEMENT et DEFERRABLE: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Lorsque vous essayez d'exécuter la requête, la transaction est verrouillée car sinon cela provoquerait une anomalie. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Et seulement après la validation de la première transaction, la troisième continue l'exécution: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Autre remarque importante: si l'isolement sérialisable est utilisé, toutes les transactions de l'application doivent utiliser ce niveau.  Vous ne pouvez pas mélanger des transactions validées en lecture (ou en lecture répétable) avec sérialisables.  Autrement dit, vous <em>pouvez</em> mélanger, mais Serializable se comportera comme une lecture répétable sans aucun avertissement.  Nous expliquerons pourquoi cela se produit plus tard, lorsque nous parlerons de la mise en œuvre. <br><br>  Donc, si vous décidez d'utiliser Serializble, il est préférable de définir globalement le niveau par défaut (bien que cela, bien sûr, ne vous empêche pas de spécifier explicitement un niveau incorrect): <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote>  Vous pouvez trouver une présentation plus rigoureuse des problèmes liés aux transactions, à la cohérence et aux anomalies dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livre</a> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cours magistral</a> de Boris Novikov «Fondamentaux des technologies de base de données» (disponible en russe uniquement). <br></blockquote><br><h1>  Quel niveau d'isolement utiliser? </h1><br>  Le niveau d'isolation Read Committed est utilisé par défaut dans PostgreSQL, et il est probable que ce niveau soit utilisé dans la grande majorité des applications.  Cette valeur par défaut est pratique car à ce niveau, un abandon de transaction n'est possible qu'en cas d'échec, mais pas comme moyen d'éviter une incohérence.  En d'autres termes, une erreur de sérialisation ne peut pas se produire. <br><br>  L'autre côté de la médaille est un grand nombre d'anomalies possibles, qui ont été discutées en détail ci-dessus.  L'ingénieur logiciel doit toujours les garder à l'esprit et écrire du code afin de ne pas leur permettre d'apparaître.  Si vous ne pouvez pas coder les actions nécessaires dans une seule instruction SQL, vous devez recourir au verrouillage explicite.  Le plus gênant est que le code est difficile à tester pour les erreurs associées à l'obtention de données incohérentes, et les erreurs elles-mêmes peuvent se produire de manière imprévisible et non reproductible et sont donc difficiles à corriger. <br><br>  Le niveau d'isolement de lecture répétable élimine certains des problèmes d'incohérence, mais hélas, pas tous.  Par conséquent, vous devez non seulement vous souvenir des anomalies restantes, mais également modifier l'application afin qu'elle gère correctement les erreurs de sérialisation.  C'est certainement gênant.  Mais pour les transactions en lecture seule, ce niveau complète parfaitement Read Committed et est très pratique, par exemple, pour créer des rapports qui utilisent plusieurs requêtes SQL. <br><br>  Enfin, le niveau Sérialisable vous permet de ne pas vous soucier du tout d'incohérence, ce qui facilite grandement le codage.  La seule chose qui est requise de l'application est de pouvoir répéter n'importe quelle transaction lors de l'obtention d'une erreur de sérialisation.  Mais la fraction des transactions abandonnées, les frais supplémentaires et l'incapacité de paralléliser les requêtes peuvent réduire considérablement le débit du système.  Notez également que le niveau Serializable n'est pas applicable sur les réplicas et qu'il ne peut pas être mélangé avec d'autres niveaux d'isolement. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuez à lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467437/">https://habr.com/ru/post/fr467437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467423/index.html">Xamarin.Forms - utilisation pratique des polices d'icônes dans l'application</a></li>
<li><a href="../fr467425/index.html">Approche d'apprentissage intensif STEM</a></li>
<li><a href="../fr467427/index.html">BudgetTracker - un autre outil open-source pour la comptabilité des finances personnelles</a></li>
<li><a href="../fr467429/index.html">Habrastatistique: explorer les sections les plus et les moins visitées du site</a></li>
<li><a href="../fr467435/index.html">Nous envoyons les rapports de l'agent Veeam Linux par courrier ou par télégramme</a></li>
<li><a href="../fr467439/index.html">Pourquoi le vinyle est-il revenu et comment les services de streaming sont-ils liés à cela?</a></li>
<li><a href="../fr467443/index.html">Centre multimédia "Kodi" et projet Yocto</a></li>
<li><a href="../fr467445/index.html">Liste insaisissable des mises à jour Windows installées</a></li>
<li><a href="../fr467449/index.html">Détection des vulnérabilités et évaluation de la résistance aux attaques de pirates des cartes à puce et des processeurs cryptographiques avec protection intégrée</a></li>
<li><a href="../fr467453/index.html">Résolution du problème du numéro 42 à l'aide d'un supercalculateur planétaire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>