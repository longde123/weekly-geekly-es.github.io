<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ï üîñ ‚úäüèª Redis Streams en tant que structure de donn√©es propre üßô üèà üë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La nouvelle structure de donn√©es Redis 5, appel√©e flux, a suscit√© un vif int√©r√™t dans la communaut√©. D'une mani√®re ou d'une autre, je parlerai √† ceux ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redis Streams en tant que structure de donn√©es propre</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444996/">  La nouvelle structure de donn√©es Redis 5, appel√©e flux, a suscit√© un vif int√©r√™t dans la communaut√©.  D'une mani√®re ou d'une autre, je parlerai √† ceux qui utilisent des flux en production et j'√©crirai √† ce sujet.  Mais maintenant, je veux consid√©rer un sujet l√©g√®rement diff√©rent.  Il me semble que beaucoup de gens consid√®rent les flux comme une sorte d'outil surr√©aliste pour r√©soudre des t√¢ches terriblement difficiles.  En effet, cette structure de donn√©es * fournit √©galement des messages, mais ce sera une simplification incroyable de supposer que la fonctionnalit√© de Redis Streams n'est limit√©e que par cela. <br><br>  Les flux sont un mod√®le et un ¬´mod√®le mental¬ª formidables qui peuvent √™tre utilis√©s avec grand succ√®s dans la conception de syst√®mes, mais en r√©alit√©, comme la plupart des structures de donn√©es Redis, sont une structure plus g√©n√©rale et peuvent √™tre utilis√©s pour un tas d'autres t√¢ches.  Dans cet article, nous pr√©senterons les flux comme une structure de donn√©es pure, ignorant compl√®tement les op√©rations de blocage, les groupes de destinataires et toutes les autres fonctionnalit√©s de messagerie. <br><a name="habracut"></a><br><h1>  Streams - Ceci est CSV sur les st√©ro√Ødes </h1><br>  Si vous souhaitez enregistrer un certain nombre d'√©l√©ments de donn√©es structur√©s et pensez que la base de donn√©es sera un exc√®s ici, vous pouvez simplement ouvrir le fichier en mode <code>append only</code> et √©crire chaque ligne en CSV (Comma Separated Value): <br><br><pre> <code class="plaintext hljs">(open data.csv in append only) time=1553096724033,cpu_temp=23.4,load=2.3 time=1553096725029,cpu_temp=23.2,load=2.1</code> </pre> <br>  √áa a l'air simple.  Les gens l'ont fait il y a longtemps et le font toujours: c'est un mod√®le fiable, si vous savez quoi.  Mais quel sera l'√©quivalent en m√©moire?  En m√©moire, un traitement des donn√©es beaucoup plus avanc√© devient possible, et de nombreuses restrictions des fichiers CSV sont automatiquement supprim√©es, telles que: <br><br><ol><li>  Il est difficile (inefficace) de r√©pondre aux demandes de plage. <br></li><li>  Trop d'informations redondantes: chaque enregistrement a presque le m√™me temps et les champs sont dupliqu√©s.  Dans le m√™me temps, la suppression de donn√©es rendra le format moins flexible si je souhaite basculer vers un autre ensemble de champs. <br></li><li>  Les d√©calages d'√©l√©ments sont simplement des d√©calages d'octets dans le fichier: si nous changeons la structure du fichier, les d√©calages deviendront faux, il n'y a donc pas de v√©ritable concept d'identifiant principal.  Les inscriptions ne peuvent pas √™tre pr√©sent√©es sans ambigu√Øt√©. <br></li><li>  Sans la possibilit√© de collecter les d√©chets et sans r√©√©crire le journal, vous ne pouvez pas supprimer les entr√©es, mais uniquement les marquer comme non valides.  La r√©√©criture des journaux craint g√©n√©ralement pour plusieurs raisons, il est conseill√© de l'√©viter. </li></ol><br>  En m√™me temps, un tel journal CSV est bon √† sa mani√®re: il n'y a pas de structure fixe, les champs peuvent changer, il est trivial de le g√©n√©rer et il est assez compact.  L'id√©e avec les flux Redis √©tait de pr√©server les vertus, mais de surmonter les limites.  Le r√©sultat est une structure de donn√©es hybride tr√®s similaire aux ensembles tri√©s de Redis: ils * ressemblent * √† la structure de donn√©es fondamentale, mais utilisent plusieurs repr√©sentations internes pour obtenir cet effet. <br><br><h1>  Introduction aux threads (vous pouvez sauter si vous connaissez d√©j√† les bases) </h1><br>  Les flux Redis sont repr√©sent√©s comme des n≈ìuds de macro compress√©s en delta connect√©s par une arborescence de base.  Par cons√©quent, vous pouvez rechercher tr√®s rapidement des enregistrements al√©atoires, obtenir des plages, supprimer d'anciens √©l√©ments, etc. En m√™me temps, l'interface du programmeur est tr√®s similaire √† un fichier CSV: <br><br><pre> <code class="plaintext hljs">&gt; XADD mystream * cpu-temp 23.4 load 2.3 "1553097561402-0" &gt; XADD mystream * cpu-temp 23.2 load 2.1 "1553097568315-0"</code> </pre> <br>  Comme vous pouvez le voir dans l'exemple, la commande XADD g√©n√®re et renvoie automatiquement l'identifiant de l'enregistrement, qui augmente de fa√ßon monotone et se compose de deux parties: &lt;time&gt; - &lt;counter&gt;.  Temps en millisecondes et le compteur est incr√©ment√© pour les enregistrements avec la m√™me heure. <br><br>  Ainsi, la premi√®re nouvelle abstraction pour l'id√©e d'un fichier CSV en mode <code>append only</code> est d'utiliser l'ast√©risque comme argument ID pour XADD: c'est ainsi que nous obtenons gratuitement l'identifiant d'enregistrement du serveur.  Cet identifiant est utile non seulement pour indiquer un √©l√©ment sp√©cifique dans le flux, il est √©galement associ√© √† l'heure √† laquelle l'enregistrement a √©t√© ajout√© au flux.  En fait, avec XRANGE, vous pouvez ex√©cuter des requ√™tes de plage ou r√©cup√©rer des √©l√©ments individuels: <br><br><pre> <code class="plaintext hljs">&gt; XRANGE mystream 1553097561402-0 1553097561402-0 1) 1) "1553097561402-0" 2) 1) "cpu-temp" 2) "23.4" 3) "load" 4) "2.3"</code> </pre> <br>  Dans ce cas, j'ai utilis√© le m√™me ID pour d√©marrer et terminer la plage pour identifier un √©l√©ment.  Cependant, je peux utiliser n'importe quelle plage et argument COUNT pour limiter le nombre de r√©sultats.  De m√™me, il n'est pas n√©cessaire de sp√©cifier des identifiants complets pour une plage, je peux simplement utiliser uniquement le temps unix pour obtenir des √©l√©ments dans une plage de temps donn√©e: <br><br><pre> <code class="plaintext hljs">&gt; XRANGE mystream 1553097560000 1553097570000 1) 1) "1553097561402-0" 2) 1) "cpu-temp" 2) "23.4" 3) "load" 4) "2.3" 2) 1) "1553097568315-0" 2) 1) "cpu-temp" 2) "23.2" 3) "load" 4) "2.1"</code> </pre> <br>  Pour le moment, il n'est pas n√©cessaire de vous montrer d'autres fonctionnalit√©s de l'API, il existe une documentation pour cela.  Pour l'instant, concentrons-nous uniquement sur ce mod√®le d'utilisation: XADD pour ajouter, XRANGE (et aussi XREAD) pour extraire des plages (selon ce que vous voulez faire), et voyons pourquoi les flux sont si puissants qu'ils les appellent des structures de donn√©es. <br><br>  Si vous souhaitez en savoir plus sur les flux et les API, assurez-vous de lire le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">didacticiel</a> . <br><br><h1>  Joueurs de tennis </h1><br>  Il y a quelques jours, un de mes amis qui a commenc√© √† √©tudier Redis et moi avons simul√© une application pour suivre les courts de tennis, les joueurs et les matchs locaux.  La fa√ßon de mod√©liser les joueurs est √©vidente, le joueur est un petit objet, nous n'avons donc besoin que d'un hachage avec des cl√©s comme <code>player:&lt;id&gt;</code> .  Ensuite, vous r√©aliserez imm√©diatement que vous avez besoin d'un moyen de suivre les matchs dans des clubs de tennis sp√©cifiques.  Si <code>player:1</code> et <code>player:2</code> jou√© entre eux et <code>player:1</code> gagn√©, nous pouvons envoyer le record suivant au stream: <br><br><pre> <code class="plaintext hljs">&gt; XADD club:1234.matches * player-a 1 player-b 2 winner 1 "1553254144387-0"</code> </pre> <br>  Une op√©ration aussi simple nous donne: <br><br><ol><li>  Identifiant de correspondance unique: ID dans le flux. <br></li><li>  Il n'est pas n√©cessaire de cr√©er un objet pour l'identification de correspondance. <br></li><li>  Demandes de port√©e libre pour les matchs de pagination ou de regarder des matchs pour une date et une heure sp√©cifiques. </li></ol><br>  Avant que les flux n'apparaissent, nous devions cr√©er un ensemble tri√© par le temps: les √©l√©ments de l'ensemble tri√© seraient des identificateurs de correspondance, qui sont stock√©s dans une cl√© diff√©rente en tant que valeur de hachage.  Ce n'est pas seulement plus de travail, mais aussi plus de m√©moire.  Beaucoup, beaucoup plus de m√©moire (voir ci-dessous). <br><br>  Maintenant, notre objectif est de montrer que les flux Redis sont une sorte d'ensemble tri√© en mode <code>append only</code> , avec des cl√©s par heure, o√π chaque √©l√©ment est un petit hachage.  Et dans sa simplicit√©, c'est une v√©ritable r√©volution dans le contexte de la mod√©lisation. <br><br><h1>  La m√©moire </h1><br>  Le cas d'utilisation ci-dessus n'est pas seulement un mod√®le de programmation plus coh√©rent.  La consommation de m√©moire dans les threads est tellement diff√©rente de l'ancienne approche avec un ensemble tri√© + hachage pour chaque objet que certaines choses commencent maintenant √† fonctionner qui √©taient auparavant impossible √† impl√©menter. <br><br>  Voici des statistiques sur la quantit√© de m√©moire pour stocker un million de correspondances dans la configuration pr√©sent√©e pr√©c√©demment: <br><br><pre> <code class="plaintext hljs">  +  = 220  (242 RSS)  = 16,8  (18.11 RSS)</code> </pre> <br>  La diff√©rence est sup√©rieure √† un ordre de grandeur (√† savoir 13 fois).  Cela signifie pouvoir travailler avec des t√¢ches qui √©taient auparavant trop co√ªteuses pour √™tre ex√©cut√©es en m√©moire.  Maintenant, ils sont tout √† fait viables.  La magie consiste √† introduire les flux Redis: les n≈ìuds de macro peuvent contenir plusieurs √©l√©ments qui sont cod√©s de mani√®re tr√®s compacte dans une structure de donn√©es appel√©e listpack.  Cette structure prendra soin, par exemple, de coder des entiers sous forme binaire, m√™me s'il s'agit de cha√Ænes s√©mantiques.  De plus, nous appliquons la compression delta et compressons les m√™mes champs.  Cependant, il reste possible de rechercher par ID ou par heure, car ces macro-n≈ìuds sont li√©s dans une arborescence de base, √©galement con√ßue avec une optimisation de la m√©moire.  Ensemble, cela explique l'utilisation √©conomique de la m√©moire, mais la partie int√©ressante est que s√©mantiquement l'utilisateur ne voit aucun d√©tail d'impl√©mentation qui rend les threads si efficaces. <br><br>  Maintenant comptons.  Si je peux stocker 1 million d'enregistrements dans environ 18 Mo de m√©moire, je peux en stocker 10 millions sur 180 Mo et 100 millions sur 1,8 Go.  Avec seulement 18 Go de m√©moire, je peux avoir 1 milliard d'articles. <br><br><h1>  S√©ries chronologiques </h1><br>  Il est important de noter que l'exemple ci-dessus avec des matchs de tennis est s√©mantiquement * tr√®s diff√©rent * de l'utilisation de flux Redis pour les s√©ries chronologiques.  Oui, logiquement, nous enregistrons toujours une sorte d'√©v√©nement, mais il y a une diff√©rence fondamentale.  Dans le premier cas, nous enregistrons et cr√©ons des enregistrements pour le rendu des objets.  Et dans la s√©rie chronologique, nous mesurons simplement quelque chose qui se passe √† l'ext√©rieur et qui ne repr√©sente pas r√©ellement l'objet.  Vous pouvez dire que cette distinction est triviale, mais elle ne l'est pas.  Il est important de comprendre l'id√©e que les threads Redis peuvent √™tre utilis√©s pour cr√©er de petits objets avec un ordre commun et attribuer des identifiants √† ces objets. <br><br>  Mais m√™me la mani√®re la plus simple d'utiliser les s√©ries temporelles est √©videmment une √©norme perc√©e, car avant l'av√®nement des threads, Redis √©tait pratiquement impuissant √† faire quoi que ce soit ici.  Les caract√©ristiques de la m√©moire et la flexibilit√© des flux, ainsi que la possibilit√© de limiter les flux plafonn√©s (voir les param√®tres XADD) sont des outils tr√®s importants entre les mains du d√©veloppeur. <br><br><h1>  Conclusions </h1><br>  Les flux sont flexibles et offrent de nombreux cas d'utilisation, mais je voulais √©crire un tr√®s court article pour montrer clairement les exemples et la consommation de m√©moire.  Pour de nombreux lecteurs, cette utilisation des flux √©tait peut-√™tre √©vidente.  Cependant, les conversations avec les d√©veloppeurs au cours des derniers mois m'ont donn√© l'impression que beaucoup ont une forte association entre les flux et les donn√©es en streaming, comme si la structure des donn√©es n'√©tait bonne que l√†-bas.  Ce n'est pas le cas.  :-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444996/">https://habr.com/ru/post/fr444996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444982/index.html">Mockito et comment le faire cuire</a></li>
<li><a href="../fr444984/index.html">D'o√π viennent les photos pour tester les syst√®mes de reconnaissance faciale?</a></li>
<li><a href="../fr444986/index.html">IETF approuve ACME - Il s'agit de la norme pour travailler avec des certificats SSL</a></li>
<li><a href="../fr444992/index.html">Erreurs int√©gr√©es au syst√®me: leur r√¥le dans les statistiques</a></li>
<li><a href="../fr444994/index.html">√Ä propos des lecteurs et de leur utilisation sur les ordinateurs modernes</a></li>
<li><a href="../fr444998/index.html">La vuln√©rabilit√© critique des dispositifs de survie implant√©s donne aux attaquants la possibilit√© de les contr√¥ler</a></li>
<li><a href="../fr445002/index.html">Comment se pr√©parer rapidement √† un entretien d'embauche avec des questions sur les algorithmes et les technologies</a></li>
<li><a href="../fr445004/index.html">Le profileur SQL est-il dangereux?</a></li>
<li><a href="../fr445006/index.html">Micro√©lectronique pour les √©tudiants de la source m√™me</a></li>
<li><a href="../fr445008/index.html">Examens Azure (version r√©vis√©e et r√©vis√©e)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>