<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóúÔ∏è üì™ ‚õπüèæ Implementierung der verbleibenden Funktionen von PEG ‚úàÔ∏è ü§ûüèª üåΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem ich im vorherigen Beitrag alle Teile des PEG-Parser-Generators zusammengestellt habe, bin ich bereit zu zeigen, wie einige andere interessante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung der verbleibenden Funktionen von PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471992/"><p>  Nachdem ich im vorherigen Beitrag alle Teile des PEG-Parser-Generators zusammengestellt habe, bin ich bereit zu zeigen, wie einige andere interessante Dinge implementiert werden k√∂nnen. </p><br><div class="spoiler">  <b class="spoiler_title">Inhalt der Python PEG Parser-Serie</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peg Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Implementierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Generierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Visualisierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linke rekursive PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinzuf√ºgen von Aktionen zur PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meta-Grammatik f√ºr PEG-Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung der verbleibenden Funktionen von PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG auf Core Developer Sprint</a> </li></ul></div></div><br><p>  Wir werden die folgenden Merkmale von PEG betrachten: </p><a name="habracut"></a><br><ul><li> Benannte Elemente: <code>NAME=item</code> (Name kann in der Aktion verwendet werden) </li><li>  Lookaheads: <code>&amp;item</code> (positiv) und <code>!item</code> (negativ) </li><li>  Gruppieren von Elementen in Klammern: (Elementelement <code>item item ...</code> ) </li><li>  Optionale Artikel: <code>[item item ...]</code> und <code>item?</code> </li><li>  Doppelte Elemente: <code>item*</code> (null oder mehr) und <code>item+</code> (eines oder mehrere) </li></ul><br><h2 id="imenovannye-argumenty">  Benannte Argumente </h2><br><p>  Beginnen wir mit benannten Elementen.  Dies ist praktisch, wenn wir mehrere davon in einer Alternative f√ºr dieselbe Regel haben, zum Beispiel: </p><br><pre> <code class="plaintext hljs">expr: term '+' term</code> </pre> <br><p>  Wir k√∂nnen uns auf den zweiten <code>term</code> beziehen, indem wir dem Variablennamen die Nummer <code>1</code> hinzuf√ºgen, so dass es in der Aktion folgenderma√üen aussieht: </p><br><pre> <code class="plaintext hljs">expr: term '+' term { term + term1 }</code> </pre> <br><p>  Aber nicht jeder mag es, und ich pers√∂nlich w√ºrde lieber so etwas schreiben: </p><br><pre> <code class="plaintext hljs">expr: left=term '+' right=term { left + right }</code> </pre> <br><p>  Dies wird in der Meta-Grammatik leicht unterst√ºtzt, indem die Regel f√ºr das <code>item</code> wie folgt ge√§ndert wird: </p><br><pre> <code class="plaintext hljs">item: | NAME = atom { NamedItem(name.string, atom) } | atom { atom } atom: | NAME { name.string } | STRING { string.string }</code> </pre> <br><p>  (Wo <code>atom</code> nur ein alter <code>item</code> ) </p><br><p>  Dazu m√ºssen wir die Definition der <code>NamedItem</code> Klasse zu <code>grammar.py</code> .  Es ist eine dieser Datenklassen, die ich zuvor erw√§hnt habe - es hat auch die <code>name</code> und <code>item</code> . </p><br><p>  Wir m√ºssen auch kleine √Ñnderungen am Codegenerator vornehmen, die ich als √úbung f√ºr den Leser hinterlassen werde (oder Sie k√∂nnen in mein Repository schauen :-).  Der generierte Code weist nun das Ergebnis der Zuordnung jedes Elements zu einer Variablen mit dem angegebenen Namen und nicht mit dem Namen zu, der aus dem Namen der Elementregel erhalten wurde.  Dies funktioniert auch f√ºr Elemente, bei denen es sich um Token handelt (entweder in der Form <code>NAME</code> oder in Zeichenfolgenliteralen wie <code>':='</code> ). </p><br><h2 id="lookahead">  Lookahead </h2><br><p>  Gefolgt von Lookahead.  Sie sind wahrscheinlich in regul√§ren Ausdr√ºcken auf dieses Konzept gesto√üen.  W√§hrend des Forward-Lookaheads kann die analysierte Alternative sofort abgelehnt oder akzeptiert werden, ohne den Tokenizer-Zeiger zu verschieben. </p><br><p>  Tats√§chlich kann Lookahead als eleganterer Weg verwendet werden, um Verwechslungen mit den Parser-Ausnahmen zu vermeiden, √ºber die ich in einem fr√ºheren Artikel geschrieben habe.  Anstatt Aktionen zu erlauben, eine bereits akzeptierte Alternative durch R√ºckgabe von None abzulehnen, k√∂nnen wir vor dem <code>OP</code> eine Anweisung hinzuf√ºgen, <code>"}"</code> auszuschlie√üen.  Die alte Regel sah so aus: </p><br><pre> <code class="plaintext hljs"> | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  Die neue Version sieht folgenderma√üen aus: </p><br><pre> <code class="plaintext hljs"> | !"}" OP { op.string }</code> </pre> <br><p>  Dadurch wird die Verarbeitung der geschweiften Klammern von der Aktion auf die Grammatik √ºbertragen, zu der sie geh√∂rt.  Wir m√ºssen <code>"{"</code> nicht aktivieren, da es einer fr√ºheren Alternative entspricht (tats√§chlich gilt dies auch f√ºr die alte Version, aber ich habe es vergessen :-). </p><br><p>  Wir f√ºgen der Regel f√ºr <code>item</code> wie folgt Grammatik f√ºr Lookaheads hinzu: </p><br><pre> <code class="plaintext hljs">item: | NAME = atom { NamedItem(name.string, atom) } | atom { atom } | "&amp;" atom { Lookahead(atom, True) } | "!" atom { Lookahead(atom, False) }</code> </pre> <br><p>  Wir m√ºssen die Lookahead- <code>Lookahead</code> zu <code>grammar.py</code> (und in <code>@subheader</code> !) Und den Generator ein wenig √§ndern, indem wir die <code>Lookahead</code> <code>grammar.py</code> hinzuf√ºgen: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookahead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, positive, func, *args)</span></span></span><span class="hljs-function">:</span></span> mark = self.mark() ok = func(*args) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.reset(mark) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok == positive</code> </pre> <br><p>  In unserem Fall sieht der generierte Code f√ºr diese Alternative folgenderma√üen aus: </p><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.lookahead(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, self.expect, <span class="hljs-string"><span class="hljs-string">"}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (op := self.expect(OP)) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op . string</code> </pre> <br><p>  Wie Sie dem obigen Grammatikfragment entnehmen k√∂nnen, kann Lookahead keine Eigennamen erhalten.  Dies ist leicht zu beheben, aber ich habe immer noch keine Ahnung, wie n√ºtzlich es w√§re.  Bei negativen Prognosen ist der Wert au√üerdem immer <code>None</code> . </p><br><h2 id="gruppirovka-v-skobkah">  Gruppierung in Klammern </h2><br><p>  Lassen Sie uns nun Gruppen mit Klammern implementieren.  Der beste Ort, um sie dem Metagramm hinzuzuf√ºgen, ist die Regel f√ºr <code>atom</code> : </p><br><pre> <code class="plaintext hljs">atom: | NAME { name.string } | STRING { string.string } | "(" alts ")" { self.synthetic_rule(alts) }</code> </pre> <br><p>  Die ersten beiden Alternativen haben sich nicht ge√§ndert.  Die Aktion f√ºr die neue Alternative verwendet einen Hack (dessen Implementierung ungekl√§rt bleibt), mit dem der Meta-Parser der Grammatik im laufenden Betrieb neue Regeln hinzuf√ºgen kann.  Diese Hilfsfunktion (im Meta-Parser definiert) gibt den Namen des neuen Regelobjekts zur√ºck.  Es besteht aus einem festen Pr√§fix gefolgt von einer Zahl, wodurch es eindeutig wird, z. B. <code>_synthetic_rule_1</code> . </p><br><p>  Sie k√∂nnen fragen, was passiert, wenn die synthetische Regel irgendwann fallen gelassen wird.  Ich wei√ü nicht, wie ich das vermeiden soll, aber es sollte keine Probleme geben - im schlimmsten Fall gibt es eine nicht verwendete Regel in der Grammatik.  Und dank Memoization wird dieselbe Aktion niemals zweimal f√ºr dieselbe Eingabeposition ausgef√ºhrt, sodass dies auch kein Problem darstellt (aber selbst wenn dies der Fall w√§re, h√§tten wir im schlimmsten Fall eine tote Regel). </p><br><p>  Wenn Sie <code>alts</code> in Klammern verwenden, k√∂nnen Sie einen vertikalen Balken als Trennzeichen innerhalb einer Gruppe definieren.  Zum Beispiel, dass unsere neue Aktionsl√∂sung nicht versehentlich mit <code>{</code> √ºbereinstimmt, k√∂nnten wir die Negation folgenderma√üen √§ndern: </p><br><pre> <code class="plaintext hljs"> | !("{" | "}") OP { op.string }</code> </pre> <br><p>  Dar√ºber hinaus k√∂nnen Gruppen auch Aktionen enthalten!  Dies w√ºrde nicht helfen, das Problem mit den Aktionen zu l√∂sen, aber in anderen Situationen kann es durchaus n√ºtzlich sein.  Und da wir auf jeden Fall eine synthetische Regel generieren, ist keine zus√§tzliche Arbeit erforderlich, um sie zu implementieren (mit Ausnahme der Implementierung von <code>synthetic_rule</code> Regel :-). </p><br><h2 id="opcionalnye-elementy">  Optionale Artikel </h2><br><p>  Wie im alten Pgen verwende ich eckige Klammern, um eine Gruppe optionaler Token anzuzeigen.  Hier erweist es sich als n√ºtzlich.  Beispielsweise kann eine Grammatikregel, die eine Python <code>for</code> Schleife beschreibt, damit angeben, dass eine Erweiterung von <code>else</code> kann.  Und wieder k√∂nnen wir die Grammatik f√ºr <code>atom</code> wie folgt erweitern: </p><br><pre> <code class="plaintext hljs">atom: | NAME { name.string } | STRING { string.string } | "(" alts ")" { self.synthetic_rule(alts) } | "[" alts "]" { Maybe(self.synthetic_rule(alts)) }</code> </pre> <br><p>  Hier ist <code>Maybe</code> eine andere Datenklasse mit einem einzelnen <code>item</code> .  Wir modifizieren den Codegenerator so, dass das Ergebnis der Synthesefunktion nicht fehlschl√§gt, wenn dieser Wert <code>None</code> .  Dazu k√∂nnen Sie in der Implementierung <code>or True</code> hinzuf√ºgen.  Zum Beispiel f√ºr <code>[term]</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ((term := self.term()) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> term</code> </pre> <br><h2 id="povtoryayuschiesya-elementy">  Doppelte Elemente </h2><br><p>  Das Umschalten auf Wiederholung ist eine weitere n√ºtzliche PEG-Funktion (die Notation stammt aus regul√§ren Ausdr√ºcken und wird auch in pgen verwendet).  Es gibt zwei Formen: Das Hinzuf√ºgen von <code>*</code> zu einem Atom bedeutet "null oder mehr Wiederholungen", w√§hrend das Hinzuf√ºgen von <code>+</code> "eine oder mehrere Wiederholungen" bedeutet.  Aus anderen Gr√ºnden musste ich die Grammatikregeln f√ºr <code>item</code> und <code>atom</code> neu schreiben und eine Zwischenregel hinzuf√ºgen, die ich <code>molecule</code> nannte: </p><br><pre> <code class="plaintext hljs">item: | NAME '=' molecule { NamedItem(name.string, molecule) } | "&amp;" atom { Lookahead(atom) } | "!" atom { Lookahead(atom, False) } | molecule { molecule } molecule: | atom "?" { Maybe(atom) } | atom "*" { Loop(atom, False) } | atom "+" { Loop(atom, True) } | atom { atom } | "[" alts "]" { Maybe(self.synthetic_rule(alts)) } atom: | NAME { name.string } | STRING {string.string } | "(" alts ")" { self.synthetic_rule(alts) }</code> </pre> <br><p>  Beachten Sie, dass dies eine alternative Syntax f√ºr optionale Elemente ( <code>atom?</code> ) <code>atom?</code> .  Es sind keine zus√§tzlichen Implementierungsbem√ºhungen erforderlich, da dies nur eine weitere M√∂glichkeit ist, einen <code>Maybe</code> Knoten zu erstellen. </p><br><p>  Das Umgestalten dieser Regeln war notwendig, weil ich bestimmte Situationen nicht g√ºltig machen m√∂chte: </p><br><ul><li>  optionale Wiederholungen (da dies nur eine Wiederholung von null oder mehr ist); </li><li>  Wiederholungen (intern w√ºrde alle √úbereinstimmungen erfassen, da PEG immer einen gierigen Algorithmus verwendet) </li><li>  wiederholte optionale Werte (die die Analyse unterbrechen w√ºrden, wenn das optionale Element nicht √ºbereinstimmt). </li></ul><br><p>  Dies ist jedoch immer noch keine ideale L√∂sung, da Sie so etwas wie <code>(foo?)*</code> Schreiben k√∂nnen.  Es wird notwendig sein, diese Situation im Parser-Generator zu √ºberpr√ºfen, aber ich werde dies au√üerhalb des Artikels tun. </p><br><p>  Die <code>Loop</code> Datenklasse hat zwei Attribute: <code>item</code> und <code>nonempty</code> .  Der generierte Code verwendet die Helfer-Parser-Methode <code>loop()</code> .  Es ist der zuvor gezeigten Methode <code>lookahead()</code> sehr √§hnlich: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, nonempty, func, *args)</span></span></span><span class="hljs-function">:</span></span> mark = self.mark() nodes = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node := func(*args) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: nodes.append(node) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(nodes) &gt;= nonempty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodes self.reset(mark) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Wenn <code>nonempty</code> <code>False</code> (in dem Sinne, dass die Grammatik <code>*</code> ), f√ºhrt dies nicht zu einem Fehler.  Es werden keine Eintr√§ge gefunden und eine leere Liste wird zur√ºckgegeben.  Um dies zu erreichen, implementieren wir den Parser-Generator so, dass <code>is not None</code> hinzugef√ºgt wird.  Eine weichere Pr√ºfung aus einem vorherigen Beitrag w√ºrde bei einer leeren Liste <code>False</code> . </p><br><p>  Das ist alles f√ºr heute!  Ich wollte √ºber den in TatSu vorhandenen Operator "cut" ( <code>~</code> ) sprechen, hatte aber bisher keine Gelegenheit, ihm zu begegnen.  Ich bin noch nicht einmal bereit, dar√ºber zu diskutieren - die TatSu-Dokumentation gibt nur ein einfaches Beispiel, das mich ein wenig interessiert.  Ich habe es in anderen Generatoren von PEG-Parsern nicht gefunden, daher ist diese Funktion m√∂glicherweise nur TatSu.  Vielleicht erz√§hle ich eines Tages von ihm.  (In der Zwischenzeit habe ich es nur f√ºr den Fall implementiert, dass man es nie wei√ü. :-) </p><br><p>  Ich denke, der n√§chste Artikel befasst sich mit meiner Erfahrung beim Schreiben einer PEG-Grammatik, die Python-Grammatik analysieren kann.  Ich werde Ihnen erz√§hlen, wie der Sprint der Python-Kernel-Entwickler stattgefunden hat, der diese Woche in London mit logistischer Unterst√ºtzung von Bloomberg und finanzieller Unterst√ºtzung von PSF und einigen anderen Unternehmen stattfand (zum Beispiel hat Dropbox mir das Hotel und den Flug bezahlt).  Besonderer Dank geht an Emily Morhouse und Pablo Galindo Salgado, die bei der Implementierung der Tools und Tests sehr geholfen haben.  Als N√§chstes schreiben wir Leistungstests und f√ºgen dieser Grammatik Aktionen hinzu, damit AST-B√§ume erstellt werden k√∂nnen, die vom CPython-Bytecode-Compiler kompiliert werden k√∂nnen.  Es liegen noch so viel interessantere Dinge vor uns! </p><br><p>  Lizenz f√ºr diesen Artikel und zitierten Code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471992/">https://habr.com/ru/post/de471992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471980/index.html">Telefonbetr√ºger. Vierter Akt, Finale ...</a></li>
<li><a href="../de471982/index.html">Die Zukunft von PHP diskutieren</a></li>
<li><a href="../de471986/index.html">Linke rekursive PEG-Grammatik</a></li>
<li><a href="../de471988/index.html">Hinzuf√ºgen von Aktionen zur PEG-Grammatik</a></li>
<li><a href="../de471990/index.html">Meta-Grammatik f√ºr PEG-Parser</a></li>
<li><a href="../de471994/index.html">Arbeiten Sie an PEG im Core Developer Sprint</a></li>
<li><a href="../de471998/index.html">F # 10: Listen</a></li>
<li><a href="../de472000/index.html">‚ÄûF√ºr die Community ist es wichtig, Standards zu setzen‚Äú: Marchin Moskala √ºber Kotlin</a></li>
<li><a href="../de472002/index.html">Umpacken von Paketen in Gradle</a></li>
<li><a href="../de472004/index.html">Boost.Spirit oder Hinzuf√ºgen von ‚ÄûSpiritualit√§t‚Äú zu Listenfiltern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>