<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìà ‚ô¶Ô∏è üòÅ Un poco sobre la programaci√≥n de ESP8266 en C bajo FreeRTOS üèÖ üò≤ üñåÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Deber√≠a haber una PAC, pero no hab√≠a suficiente presupuesto para ello. 

 Motivado por la respuesta de Tarson a mi comentario sobre Programaci√≥n e int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un poco sobre la programaci√≥n de ESP8266 en C bajo FreeRTOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/406813/"> <i><b>Deber√≠a haber una PAC, pero no hab√≠a suficiente presupuesto para ello.</b></i> <br><br>  Motivado por la respuesta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Tarson</a> a mi comentario sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programaci√≥n e intercambio de datos con ARDUINO a trav√©s de WIFI a trav√©s de ESP8266</a> , decid√≠ escribir sobre los conceptos b√°sicos de la programaci√≥n de ESP8266 en C en FreeRTOS.  Detalles debajo del corte. <br><a name="habracut"></a><br>  <b>Paso 0 - dispositivo</b> <br><br>  Primero necesita obtener un dispositivo con ESP8266, es deseable que USB a UART se separe all√≠, para que no tenga que apagar el programador.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paso</a> mis experimentos inhumanos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NodeMCU</a> . <br><br>  <b>Entonces, paso 1: recolecta la cadena de herramientas</b> <br><br>  Primero necesita tener una computadora con la distribuci√≥n de Linux instalada (tengo OpenSUSE Leap).  Vamos al github en el enlace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tyts</a> , leemos las instrucciones de ensamblaje, instalamos las dependencias necesarias, clonamos el repositorio y recopilamos.  Clon√© en / opt / ESP y antes de ensamblar las reglas de Makefile, establec√≠ las variables: <br><br><pre><code class="bash hljs">STANDALONE = n VENDOR_SDK = 2.1.0</code> </pre> <br>  A continuaci√≥n, puede agregar la ruta a los binarios de la cadena de herramientas en PATH en ~ / .bashrc: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PATH=/opt/ESP/esp-open-sdk/xtensa-lx106-elf/bin:<span class="hljs-variable"><span class="hljs-variable">$PATH</span></span></code> </pre><br>  <b>Paso 2: obt√©n el SDK</b> <br><br>  Vamos a github ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tynk</a> ), leemos las instrucciones, clonamos (por ejemplo en / opt / ESP).  A continuaci√≥n, configuramos la variable de entorno ESP8266_SDK_PATH de nuestra manera favorita (por ejemplo, a trav√©s de ~ / .bashrc): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ESP8266_SDK_PATH=/opt/ESP/esp-open-rtos</code> </pre><br>  <b>Paso 3 - crea un proyecto</b> <br><br>  Vamos al directorio de ejemplos en el directorio con el SDK y copiamos cualquier ejemplo que desee.  Importamos / abrimos el proyecto en nuestro entorno de desarrollo favorito, los masoquistas pueden usar un editor de texto.  Prefiero NetBeans: tiene un buen soporte para proyectos C / C ++, incluidos los basados ‚Äã‚Äãen Makefile.  El proyecto se ensambla usando make, se flashea usando make flash.  En el archivo local.mk, puede configurar los par√°metros para actualizar su dispositivo (tama√±o y modo de acceso a la memoria flash, por ejemplo). <br><br>  <b>Paso 4 - Programaci√≥n</b> <br><br>  Analizamos los requisitos, el √°rea tem√°tica, compilamos las especificaciones t√©cnicas de acuerdo con GOST 34.602-89, despu√©s de lo cual puede comenzar a escribir el c√≥digo :) No parpadear√© los LED, porque no los tengo, por lo que como HelloWorld leer√© los datos del sensor AM2302 (es DHT22) y envi√°ndolos a trav√©s del protocolo MQTT al servidor. <br><br>  Para usar m√≥dulos adicionales, por ejemplo MQTT o DHT, deben agregarse al Makefile: <br><br><pre> <code class="hljs ruby">PROGRAM=fffmeteo EXTRA_COMPONENTS = extras/paho_mqtt_c extras/dht <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $(ESP8266_SDK_PATH)/common.mk</code> </pre><br><div class="spoiler">  <b class="spoiler_title">main.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;limits.h&gt; #include &lt;FreeRTOS.h&gt; #include &lt;task.h&gt; #include &lt;queue.h&gt; #include &lt;semphr.h&gt; #define DEBUG #ifdef DEBUG #define debug(args...) printf("--- "); printf(args) #define SNTP_DEBUG_ENABLED true #else #define debug(args...) #define SNTP_DEBUG_ENABLED false #endif #define WIFI_SSID "kosmonaFFFt" #define WIFI_PASS "mysupermegapassword" #define MQTT_HOST "m11.cloudmqtt.com" #define MQTT_PORT 16464 #define MQTT_USER "kosmonaFFFt" #define MQTT_PASS "mysupermegapassword" #define MQTT_TOPIC "/meteo" #define NTP_SERVER "pool.ntp.org" #define UART0_BAUD 9600 #define STACK_SIZE 512 #define INIT_TASK_PRIORITY (configTIMER_TASK_PRIORITY + 1) #define MEASUREMENT_TASK_PRIORITY (INIT_TASK_PRIORITY + 1) #define SENDING_DATA_TASK_PRIORITY (MEASUREMENT_TASK_PRIORITY + 1) #define MEASUREMENTS_PERIOD_S 59 #define MAX_MEASUREMENTS_COUNT 16 #define SEND_PERIOD_S 120 #define RUN_SNTP_SYNC_PERIOD 5 #define MS(x) (x / portTICK_PERIOD_MS) #define AM2302_PIN 5 #ifdef __cplusplus extern "C" { #endif #ifdef __cplusplus } #endif #endif /* MAIN_H */</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sntp.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;esp/uart.h&gt; #include &lt;espressif/esp_common.h&gt; #include &lt;paho_mqtt_c/MQTTESP8266.h&gt; #include &lt;paho_mqtt_c/MQTTClient.h&gt; #include &lt;dht/dht.h&gt; //-----------------------------------------------------------------------------+ // Measurements task section. | //-----------------------------------------------------------------------------+ struct measurement_results { time_t timestamp; int am2302_humidity; int am2302_temperature; }; static QueueHandle_t measurements_queue; void measurement_task(void *arg) { int16_t humidity; int16_t temperature; struct measurement_results measurements; while (true) { debug("MEASUREMENTS: Start measurements...\n"); measurements.timestamp = time(NULL); bool success = dht_read_data(DHT_TYPE_DHT22, AM2302_PIN, &amp;humidity, &amp;temperature); if (success &amp;&amp; temperature &gt;= -500 &amp;&amp; temperature &lt;= 1500 &amp;&amp; humidity &gt;= 0 &amp;&amp; humidity &lt;= 1000) { measurements.am2302_humidity = humidity; measurements.am2302_temperature = temperature; } else { debug("MEASUREMENT: Error! Cannot read data from AM2302!!!\n"); measurements.am2302_humidity = INT_MIN; measurements.am2302_temperature = INT_MIN; } debug("MEASUREMENTS: Measurements finished...\n"); xQueueSendToBack(measurements_queue, &amp;measurements, MS(250)); vTaskDelay(MS(MEASUREMENTS_PERIOD_S * 1000)); } vTaskDelete(NULL); } //-----------------------------------------------------------------------------+ // Sending data task section. | //-----------------------------------------------------------------------------+ static uint8_t mqtt_buf[512]; static uint8_t mqtt_readbuf[128]; void sending_data_task(void *arg) { mqtt_network_t network; mqtt_network_new(&amp;network); mqtt_client_t client = mqtt_client_default; mqtt_packet_connect_data_t data = mqtt_packet_connect_data_initializer; uint8_t sntp_sync_counter = 0; while (true) { debug("MQTT: ConnectNetwork...\n"); int err = mqtt_network_connect(&amp;network, MQTT_HOST, MQTT_PORT); if (err) { debug("MQTT: Error!!! ConnectNetwork ERROR!\n"); vTaskDelay(MS(5 * 1000)); continue; } else { debug("MQTT: ConnectNetwork success...\n"); } // TODO: add check for errors!!! // TODO: replace magic constants!!! mqtt_client_new(&amp;client, &amp;network, 5000, mqtt_buf, 100, mqtt_readbuf, 100); data.willFlag = 0; data.MQTTVersion = 3; data.clientID.cstring = "fff"; data.username.cstring = MQTT_USER; data.password.cstring = MQTT_PASS; data.keepAliveInterval = 10; data.cleansession = 0; err = mqtt_connect(&amp;client, &amp;data); if (err) { debug("MQTT: Error!!! MQTTConnect ERROR!\n"); vTaskDelay(MS(5 * 1000)); continue; } else { debug("MQTT: MQTTConnect success...\n"); } struct measurement_results msg; while (xQueueReceive(measurements_queue, &amp;msg, 0) == pdTRUE) { if (msg.am2302_humidity == INT_MIN || msg.am2302_temperature == INT_MIN) { debug("MQTT: Got invalid message, no publishing!!!\n"); continue; } debug("MQTT: Got message to publish...\n"); debug(" timestamp: %ld\n", msg.timestamp); debug(" am2302_humidity: %.1f\n", msg.am2302_humidity / 10.0); debug(" am2302_temperature: %.1f\n", msg.am2302_temperature / 10.0); msg.timestamp = htonl(msg.timestamp); msg.am2302_humidity = htonl(msg.am2302_humidity); msg.am2302_temperature = htonl(msg.am2302_temperature); mqtt_message_t message; message.payload = &amp;msg; message.payloadlen = sizeof (msg); message.dup = 0; message.qos = MQTT_QOS1; message.retained = 0; err = mqtt_publish(&amp;client, MQTT_TOPIC, &amp;message); if (err) { debug("MQTT: Error!!! Error while publishing message!\n"); } else { debug("MQTT: Successfully publish message...\n"); } } mqtt_disconnect(&amp;client); mqtt_network_disconnect(&amp;network); ++sntp_sync_counter; if (sntp_sync_counter == RUN_SNTP_SYNC_PERIOD) { sntp_sync(NTP_SERVER, NULL, arg); sntp_sync_counter = 0; } vTaskDelay(MS(SEND_PERIOD_S * 1000)); } vTaskDelete(NULL); } //-----------------------------------------------------------------------------+ // Init task section. | //-----------------------------------------------------------------------------+ /** * This semaphore is taken during sntp sync and released after it finished. */ static SemaphoreHandle_t init_task_sem; /** * Set time and free init task semaphore. * @param error unused * @param arg unused */ void init_sntp_callback(int8_t error, void* arg) { time_t ts = time(NULL); debug("TIME: %s", ctime(&amp;ts)); xSemaphoreGive(init_task_sem); } /** * Connection parameters. */ static struct sdk_station_config STATION_CONFIG = { .ssid = WIFI_SSID, .password = WIFI_PASS, }; void init_task(void* arg) { debug("INIT: setting pins...\n"); gpio_set_pullup(AM2302_PIN, false, false); debug("INIT: Set station parameters...\n"); sdk_wifi_station_set_auto_connect(false); sdk_wifi_station_set_config(&amp;STATION_CONFIG); debug("Station parameters has been set.\n"); debug("INIT: Connecting to AP...\n"); sdk_wifi_station_connect(); while (sdk_wifi_station_get_connect_status() != STATION_GOT_IP) { vTaskDelay(MS(1000)); } debug("INIT: Connection to AP has been estabilished...\n"); debug("INIT: Start SNTP synchronization...\n"); init_task_sem = xSemaphoreCreateMutex(); if (!init_task_sem) { debug("INIT: Cannot create init task semaphore!!!"); return; } xSemaphoreTake(init_task_sem, 0); sntp_init(); sntp_sync(NTP_SERVER, init_sntp_callback, arg); BaseType_t result = pdFALSE; while (true) { debug("INIT: Trying to take init task semaphore...\n"); result = xSemaphoreTake(init_task_sem, MS(5 * 1000)); if (result == pdTRUE) { debug("INIT: Init task semaphore is taken...\n"); break; } } measurements_queue = xQueueCreate(MAX_MEASUREMENTS_COUNT, sizeof (struct measurement_results)); if (!measurements_queue) { debug("INIT: ERROR!!! Cannot create queue for measurements!\n"); goto fail; } result = xTaskCreate(measurement_task, "measurement_task", STACK_SIZE, NULL, MEASUREMENT_TASK_PRIORITY, NULL); if (result == pdFAIL) { debug("INIT: Measurement task creation failed!!!\n"); goto fail; } debug("INIT: Measurement task created...\n"); result = xTaskCreate(sending_data_task, "send_data_task", STACK_SIZE, NULL, SENDING_DATA_TASK_PRIORITY, NULL); if (result == pdFAIL) { debug("INIT: Send task creation failed!!!\n"); goto fail; } debug("INIT: Send data task created...\n"); fail: vSemaphoreDelete(init_task_sem); vTaskDelete(NULL); } //-----------------------------------------------------------------------------+ // Application entry point. | //-----------------------------------------------------------------------------+ void user_init(void) { debug("USER_INIT: SDK version: %s\n", sdk_system_get_sdk_version()); debug("USER_INIT: sizeof (int): %d\n", sizeof (int)); debug("USER_INIT: sizeof (float): %d\n", sizeof (float)); debug("USER_INIT: sizeof (time_t): %d\n", sizeof (time_t)); uart_set_baud(0, UART0_BAUD); BaseType_t result = xTaskCreate(init_task, (const char * const) "init_task", STACK_SIZE, NULL, INIT_TASK_PRIORITY, NULL); if (!result) { debug("USER_INIT: Cannot create init task!!!"); return; } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">sntp.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SNTP_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SNTP_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;time.h&gt; #include &lt;stdint.h&gt; #ifdef __cplusplus extern "C" { #endif #define SNTP_ERR_OK 0 #define SNTP_ERR_CONTEXT -1 #define SNTP_ERR_DNS -2 #define SNTP_ERR_UDP_PCB_ALLOC -3 #define SNTP_ERR_PBUF_ALLOC -4 #define SNTP_ERR_SEND -5 #define SNTP_ERR_RECV_ADDR_PORT -6; #define SNTP_ERR_RECV_SIZE -7 #define SNTP_ERR_RECV_MODE -8 #define SNTP_ERR_RECV_STRATUM -9 typedef void (*sntp_sync_callback)(int8_t error, void *arg); void sntp_init(); void sntp_sync(char *server, sntp_sync_callback callback, void *callback_arg); time_t sntp_get_rtc_time(int32_t *us); void sntp_update_rtc(time_t t, uint32_t us); #ifdef __cplusplus } #endif #endif /* SNTP_H */</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">sntp.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sntp.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;time.h&gt; #include &lt;string.h&gt; #include &lt;lwip/ip_addr.h&gt; #include &lt;lwip/err.h&gt; #include &lt;lwip/dns.h&gt; #include &lt;lwip/udp.h&gt; #include &lt;esp/rtc_regs.h&gt; #include &lt;espressif/esp_common.h&gt; #define TIMER_COUNT RTC.COUNTER /** * Daylight settings. * Base calculated with value obtained from NTP server (64 bits). */ #define SNTP_BASE (*((uint64_t*) RTC.SCRATCH)) /** * Timer value when base was obtained. */ #define SNTP_TIME_REF (RTC.SCRATCH[2]) /** * Calibration value. */ #define SNTP_CALIBRATION (RTC.SCRATCH[3]) /** * SNTP modes. */ #define SNTP_MODE_CLIENT 0x03 #define SNTP_MODE_SERVER 0x04 #define SNTP_MODE_BROADCAST 0x05 /** * Kiss-of-death code. */ #define SNTP_STRATUM_KOD 0x00 #define SNTP_OFFSET_LI_VN_MODE 0 #define SNTP_OFFSET_STRATUM 1 #define SNTP_OFFSET_RECEIVE_TIME 32 #define DIFF_SEC_1900_1970 (2208988800UL) struct sntp_message { uint8_t li_vn_mode; uint8_t stratum; uint8_t poll; uint8_t precision; uint32_t root_delay; uint32_t root_dispersion; uint32_t reference_identifier; uint32_t reference_timestamp[2]; uint32_t originate_timestamp[2]; uint32_t receive_timestamp[2]; uint32_t transmit_timestamp[2]; } __attribute__ ((packed)); struct sntp_sync_context { ip_addr_t ip_address; sntp_sync_callback callback; void* callback_arg; }; void sntp_init() { SNTP_BASE = 0; SNTP_CALIBRATION = 1; SNTP_TIME_REF = TIMER_COUNT; } void on_dns_found(const char* name, ip_addr_t* ipaddr, void* arg); void on_udp_recv(void* arg, struct udp_pcb* pcb, struct pbuf* p, ip_addr_t* addr, u16_t port); void sntp_sync(char* server, sntp_sync_callback callback, void* callback_arg) { int result = ERR_OK; debug("SNTP: Start SNTP synchronization, allocating memory for context...\n"); struct sntp_sync_context* context = malloc(sizeof (struct sntp_sync_context)); if (!context) { debug("SNTP: Error!!! Cannot allocate memory for context!\n"); result = SNTP_ERR_CONTEXT; goto fail; } context-&gt;callback = callback; context-&gt;callback_arg = callback_arg; debug("SNTP: Context successfully allocated...\n"); debug("SNTP: Start DNS lookup...\n"); err_t err = dns_gethostbyname(server, &amp;(context-&gt;ip_address), on_dns_found, context); if (!(err == ERR_OK || err == ERR_INPROGRESS)) { debug("SNTP: Error!!! DNS lookup error!\n"); result = SNTP_ERR_DNS; goto fail; } return; fail: if (context) { free(context); } if (callback) { callback(result, callback_arg); } } // //============================================================================================================================================================== // void on_dns_found(const char* name, ip_addr_t* ipaddr, void* arg) { debug("SNTP: Start DNS lookup successfully finished...\n"); int result = ERR_OK; struct sntp_sync_context* context = arg; sntp_sync_callback callback = context-&gt;callback; void* callback_arg = context-&gt;callback_arg; debug("SNTP: Creating upd_pcb...\n"); struct udp_pcb* sntp_pcb = udp_new(); if (!sntp_pcb) { debug("SNTP: Error!!! Cannot allocate udp_pcb!\n"); result = SNTP_ERR_UDP_PCB_ALLOC; goto fail; } debug("SNTP: Successfully created upd_pcb...\n"); debug("SNTP: Allocating pbuf...\n"); struct pbuf* p = pbuf_alloc(PBUF_TRANSPORT, sizeof (struct sntp_message), PBUF_RAM); if (!p) { debug("SNTP: Error!!! DNS lookup error!\n"); result = SNTP_ERR_PBUF_ALLOC; goto fail; } struct sntp_message* message = p-&gt;payload; memset(message, 0, sizeof (struct sntp_message)); message-&gt;li_vn_mode = 0b00100011; // li = 00, vn = 4, mode = 3 debug("SNTP: Pbuf allocated successfully...\n"); debug("SNTP: Sending data to server...\n"); udp_recv(sntp_pcb, on_udp_recv, context); err_t err = udp_sendto(sntp_pcb, p, ipaddr, 123); pbuf_free(p); if (err != ERR_OK) { debug("SNTP: Error!!! data sending error!\n"); result = SNTP_ERR_SEND; goto fail; } debug("SNTP: Data sent...\n"); return; fail: if (context) { free(context); } if (sntp_pcb) { udp_remove(sntp_pcb); } if (callback) { callback(result, callback_arg); } } void on_udp_recv(void* arg, struct udp_pcb* pcb, struct pbuf* p, ip_addr_t* addr, u16_t port) { debug("SNTP: Response has successfully received...\n"); int result = ERR_OK; struct sntp_sync_context* context = arg; sntp_sync_callback callback = context-&gt;callback; void* callback_arg = context-&gt;callback_arg; debug("SNTP: Checking response size...\n"); if (p-&gt;tot_len &lt; sizeof (struct sntp_message)) { debug("SNTP: Error!!! Invalid response size!\n"); result = SNTP_ERR_RECV_SIZE; goto fail; } debug("SNTP: Response size is OK...\n"); debug("SNTP: Checking mode...\n"); u8_t mode = 0x0; pbuf_copy_partial(p, &amp;mode, sizeof (mode), SNTP_OFFSET_LI_VN_MODE); mode &amp;= 0b00000111; if (mode != SNTP_MODE_SERVER &amp;&amp; mode != SNTP_MODE_BROADCAST) { debug("SNTP: Error!!! Invalid mode!\n"); result = SNTP_ERR_RECV_MODE; goto fail; } debug("SNTP: Mode is OK...\n"); debug("SNTP: Checking stratum...\n"); u8_t stratum = 0x0; pbuf_copy_partial(p, &amp;stratum, sizeof (stratum), SNTP_OFFSET_STRATUM); if (stratum == SNTP_STRATUM_KOD) { debug("SNTP: Error!!! Kiss of death!\n"); result = SNTP_ERR_RECV_STRATUM; goto fail; } debug("SNTP: Stratum is OK...\n"); debug("SNTP: Updating system timer...\n"); uint32_t receive_time[2]; pbuf_copy_partial(p, &amp;receive_time, 2 * sizeof (uint32_t), SNTP_OFFSET_RECEIVE_TIME); time_t t = ntohl(receive_time[0]) - DIFF_SEC_1900_1970; uint32_t us = ntohl(receive_time[1]) / 4295; sntp_update_rtc(t, us); debug("SNTP: System timer updated...\n"); fail: if (context) { free(context); } if (pcb) { udp_remove(pcb); } if (callback) { callback(result, callback_arg); } } /** * Check if a timer wrap has occurred. Compensate sntp_base reference * if affirmative. * TODO: think about multitasking and race conditions. */ inline void sntp_check_timer_wrap(uint32_t current_value) { if (current_value &lt; SNTP_TIME_REF) { // Timer wrap has occurred, compensate by subtracting 2^32 to ref. SNTP_BASE -= 1LLU &lt;&lt; 32; } } /** * Return secs. If us is not a null pointer, fill it with usecs */ time_t sntp_get_rtc_time(int32_t *us) { time_t secs; uint32_t tim; uint64_t base; tim = TIMER_COUNT; // Check for timer wrap. sntp_check_timer_wrap(tim); base = SNTP_BASE + tim - SNTP_TIME_REF; secs = base * SNTP_CALIBRATION / (1000000U &lt;&lt; 12); if (us) { *us = base * SNTP_CALIBRATION % (1000000U &lt;&lt; 12); } return secs; } /** * Update RTC timer. Called by SNTP module each time it receives an update. */ void sntp_update_rtc(time_t t, uint32_t us) { // Apply daylight and timezone correction // DEBUG: Compute and print drift int64_t sntp_current = SNTP_BASE + TIMER_COUNT - SNTP_TIME_REF; int64_t sntp_correct = (((uint64_t) us + (uint64_t) t * 1000000U) &lt;&lt; 12) / SNTP_CALIBRATION; debug("RTC Adjust: drift = %ld ticks, cal = %d\n", (time_t) (sntp_correct - sntp_current), SNTP_CALIBRATION); SNTP_TIME_REF = TIMER_COUNT; SNTP_CALIBRATION = sdk_system_rtc_clock_cali_proc(); SNTP_BASE = (((uint64_t) us + (uint64_t) t * 1000000U) &lt;&lt; 12) / SNTP_CALIBRATION; } /** * Syscall implementation. doesn't seem to use tzp. */ int _gettimeofday_r(struct _reent* r, struct timeval* tp, void* tzp) { // Syscall defined by xtensa newlib defines tzp as void* // So it looks like it is not used. Also check tp is not NULL if (tzp || !tp) { return EINVAL; } tp-&gt;tv_sec = sntp_get_rtc_time((int32_t*) &amp; tp-&gt;tv_usec); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Divagaci√≥n l√≠rica sobre la disponibilidad de su propio c√≥digo de sincronizaci√≥n de tiempo a trav√©s de SNTP: en las extensiones del SDK ya existe un m√≥dulo de este tipo, pero por alguna raz√≥n no me gust√≥ (fue hace mucho tiempo, no recuerdo por qu√©), as√≠ que copi√© este c√≥digo con imprudencia y lo modifiqu√© por m√≠ mismo. <br><br>  Todo funciona de manera simple: cuando se inicia el controlador, comienza la tarea de inicializaci√≥n, que se conecta al punto de acceso, sincroniza la hora a trav√©s de SNTP, inicia la tarea de medir la temperatura con la humedad y enviar datos al servidor, despu√©s de lo cual se suicida.  La tarea de medici√≥n sondea el sensor una vez cada 59 segundos y coloca los resultados en una cola, la tarea de env√≠o comienza cada 2 minutos, lee los datos de la cola y los env√≠a al servidor MQTT. <br><br>  Te√≥ricamente, puedes escribir en C ++. <br><br>  <b>Paso 5 - conclusi√≥n, donde sin √©l</b> <br><br>  De una manera tan simple, utilizando el lenguaje C y las manos con un peque√±o radio de curvatura, puede programar el controlador ESP8266.  La principal ventaja de este enfoque sobre las soluciones de secuencias de comandos (por ejemplo, LUA o MicroPython) es el control total sobre la composici√≥n y los recursos del firmware, y la capacidad de obtener m√°s funcionalidad con recursos limitados del controlador.  Tambi√©n hay una opci√≥n para usar RTOS SDK o NONOS SDK de Espressif, pero no crec√≠ junto con el primero y no intent√© usar el segundo.  Si alguien est√° interesado, as√≠ como cuando lo descubro yo mismo, puedo escribir el siguiente tutorial sobre OTA (actualizaci√≥n de firmware por aire). <br><br>  Algunos resultados de este c√≥digo: <br><br><div class="spoiler">  <b class="spoiler_title">Datos recibidos del servidor MQTT y cargados en la base de datos</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/db8/1b7/085/db81b70850ce4ef8afbb77536c57f973.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Controlador de depuraci√≥n de escape en UART</b> <div class="spoiler_text"><pre> <code class="hljs delphi">SDK version: <span class="hljs-number"><span class="hljs-number">0.9</span></span>.<span class="hljs-number"><span class="hljs-number">9</span></span> --- USER_INIT: sizeof (int): <span class="hljs-number"><span class="hljs-number">4</span></span> --- USER_INIT: sizeof (float): <span class="hljs-number"><span class="hljs-number">4</span></span> --- USER_INIT: sizeof (time_t): <span class="hljs-number"><span class="hljs-number">4</span></span> mode : sta(<span class="hljs-number"><span class="hljs-number">18</span></span>:fe:<span class="hljs-number"><span class="hljs-number">34</span></span>:d2:c5:a7) add if0 --- INIT: setting pins... --- INIT: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> station parameters... --- Station parameters has been <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>. --- INIT: Connecting <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> AP... scandone add <span class="hljs-number"><span class="hljs-number">0</span></span> aid <span class="hljs-number"><span class="hljs-number">2</span></span> cnt connected <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> kosmonaFFFt, channel <span class="hljs-number"><span class="hljs-number">1</span></span> dhcp client start... ip:<span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">1.21</span></span>,mask:<span class="hljs-number"><span class="hljs-number">255.255</span></span>.<span class="hljs-number"><span class="hljs-number">255.0</span></span>,gw:<span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">1.1</span></span> --- INIT: Connection <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> AP has been estabilished... --- INIT: Start SNTP synchronization... --- SNTP: Start SNTP synchronization, allocating memory <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> context... --- SNTP: Context successfully allocated... --- SNTP: Start DNS lookup... --- INIT: Trying <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> take init task semaphore... --- SNTP: Start DNS lookup successfully finished... --- SNTP: Creating upd_pcb... --- SNTP: Successfully created upd_pcb... --- SNTP: Allocating pbuf... --- SNTP: Pbuf allocated successfully... --- SNTP: Sending data <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> server... --- SNTP: Data sent... --- SNTP: Response has successfully received... --- SNTP: Checking response size... --- SNTP: Response size <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> OK... --- SNTP: Checking mode... --- SNTP: Mode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> OK... --- SNTP: Checking stratum... --- SNTP: Stratum <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> OK... --- SNTP: Updating system timer... --- RTC Adjust: drift = <span class="hljs-number"><span class="hljs-number">1220897578</span></span> ticks, cal = <span class="hljs-number"><span class="hljs-number">1</span></span> --- SNTP: System timer updated... --- TIME: Thu Sep <span class="hljs-number"><span class="hljs-number">21</span></span> <span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-number"><span class="hljs-number">2017</span></span> --- INIT: Init task semaphore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> taken... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- INIT: Measurement task created... --- MQTT: ConnectNetwork... --- INIT: Send data task created... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021636</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">55.8</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">23.4</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MQTT: ConnectNetwork... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021694</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">55.2</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">23.8</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021751</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">56.5</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.4</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MQTT: ConnectNetwork... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021807</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">53.0</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.7</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021863</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">52.3</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.8</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MQTT: ConnectNetwork... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021919</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">52.0</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.9</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021975</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">53.3</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">25.2</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>...</code> </pre> <br></div></div><br>  <b>PD:</b> recomiendo usar minicom (consola) o cutecom (GUI) para trabajar con UART en PC. <br><br>  <b>Enlaces utiles:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API FreeRTOS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ESP RTOS SDK Guide</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es406813/">https://habr.com/ru/post/es406813/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es406803/index.html">Rossvyaz est√° explorando la posibilidad de crear una √∫nica base de datos IMEI de tel√©fonos que funcionan en la Federaci√≥n Rusa</a></li>
<li><a href="../es406805/index.html">La interfaz cerebro-computadora ya no es ciencia ficci√≥n</a></li>
<li><a href="../es406807/index.html">La Marina de los EE. UU. Decide usar controladores Xbox 360 en lugar de costosos controles remotos de $ 38,000</a></li>
<li><a href="../es406809/index.html">El avi√≥n Stratolaunch m√°s grande del mundo prob√≥ motores y sistema de combustible.</a></li>
<li><a href="../es406811/index.html">¬øC√≥mo es el mundo secreto para entrenar a los robomobiles Waymo?</a></li>
<li><a href="../es406815/index.html">No, no es posible sentir l√°stima por todos de inmediato.</a></li>
<li><a href="../es406817/index.html">¬øPuede una criatura viviente ser del tama√±o de una galaxia?</a></li>
<li><a href="../es406819/index.html">C√≥mo funciona la producci√≥n automatizada de tonelaje de geles</a></li>
<li><a href="../es406821/index.html">Hacer papel con Epson PaperLab</a></li>
<li><a href="../es406823/index.html">Simetr√≠as C, P, T (y combinaciones de las mismas)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>