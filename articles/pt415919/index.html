<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📮 👩‍🎤 👨‍👨‍👦 Refatorando um programa em movimento: aceleração 23 vezes 🤩 ☝🏿 👩‍👩‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Meu nome é Marco, trabalho no Badoo no departamento de Plataforma. Temos muitas coisas escritas no Go, e muitas vezes são críticas para o desempenh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Refatorando um programa em movimento: aceleração 23 vezes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/415919/"><img src="https://habrastorage.org/webt/fw/oq/ji/fwoqjijc84e50kqfhpyzqfl-oay.jpeg"><br><br>  <i>Oi</i>  <i>Meu nome é Marco, trabalho no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Badoo</a> no departamento de Plataforma.</i>  <i>Temos muitas coisas escritas no Go, e muitas vezes são críticas para o desempenho do sistema.</i>  <i>É por isso que hoje ofereço uma tradução de um artigo que realmente gostei e, tenho certeza, será muito útil para você.</i>  <i>O autor mostra passo a passo como ele abordou os problemas de desempenho e como eles os resolveram.</i>  <i>Incluindo você se familiarizará com as ferramentas avançadas disponíveis no Go para esse trabalho.</i>  <i>Boa leitura!</i> <br><br>  Algumas semanas atrás, li o artigo “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bom código contra código incorreto no Go</a> ” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, em</a> que o autor, passo a passo, demonstra a refatoração de um aplicativo real que resolve problemas reais de negócios.  Ele se concentra em transformar "código incorreto" em "código válido": mais idiomático, mais compreensível, utilizando totalmente as especificidades do Go.  Mas o autor também afirmou a importância do desempenho do aplicativo em questão.  A curiosidade surgiu em mim: vamos tentar acelerar! <br><a name="habracut"></a><br>  O programa, grosso modo, lê o arquivo de entrada, analisa-o linha por linha e preenche os objetos na memória. <br><br><img src="https://habrastorage.org/webt/q0/ar/rr/q0arrrwx11e7qz627mj4ttz1r7y.png"><br><br>  O autor não apenas postou o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">código fonte no GitHub</a> , mas também escreveu uma referência.  Essa é uma ótima ideia.  De fato, o autor convidou todos a brincar com o código e tentar acelerá-lo.  Para reproduzir os resultados do autor, use o seguinte comando: <br><br><pre><code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=.</code> </pre> <br><img src="https://habrastorage.org/webt/jw/x2/6w/jwx26wyngj_sqokfhrbk-3u3yeo.png"><br>  <i>μs por chamada (menos - melhor)</i> <br><br>  Acontece que no meu computador o “código bom” é 16% mais rápido.  Podemos acelerar? <br><br>  Na minha experiência, há uma correlação entre qualidade e desempenho do código.  Se você refatorou o código com sucesso, o tornou mais limpo e menos conectado, provavelmente o tornou mais rápido porque ficou menos confuso (e não há mais instruções desnecessárias que foram executadas em vão).  Talvez durante a refatoração você tenha notado algumas oportunidades de otimização ou agora tenha apenas a oportunidade de criá-las.  Mas, por outro lado, se você quiser tornar o código ainda mais produtivo, provavelmente precisará se afastar da simplicidade e adicionar vários hacks.  Você realmente economiza milissegundos, mas a qualidade do código sofrerá: ficará mais difícil lê-lo e falar sobre ele, ficará mais frágil e flexível. <br><br><img src="https://habrastorage.org/webt/c9/lz/zd/c9lzzdc9yi73nsxn6cm93vwbvei.gif"><br>  <i>Subimos a montanha da Simplicidade e depois descemos dela</i> <br><br>  Esta é uma troca: até onde você está disposto a ir? <br><br>  Para priorizar adequadamente o trabalho de aceleração, a estratégia ideal é encontrar gargalos e focar neles.  Para fazer isso, use as ferramentas de criação de perfil.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pprof</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trace</a> são seus amigos: <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -cpuprofile cpu.prof $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool pprof -svg cpu.prof &gt; cpu.svg</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/dc/j4/vf/dcj4vfmpccf5k2gjyxumvbtxj-k.png"></a> <br>  <i>Um gráfico bastante amplo do uso da CPU (clique para SVG)</i> <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -trace trace.out $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool trace trace.out</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/dd/tf/pk/ddtfpkssk98xhs_6o2ncqbxkucq.png"></a> <br>  <i>Rastreamento do arco-íris: muitas tarefas pequenas (clique para abrir, funciona apenas no Google Chrome)</i> <br><br>  O rastreamento confirma que todos os núcleos do processador estão ocupados (linhas abaixo de 0, 1 etc.) e, à primeira vista, isso é bom.  Mas ela também mostra milhares de pequenos cálculos de cores e várias áreas vazias onde os núcleos estavam ociosos.  Vamos ampliar: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/h3/-w/qe/h3-wqeqyb3xiiwyyvott4cwywg4.png"></a> <br>  <i>"Janela" em 3 ms (clique para abrir, funciona apenas no Google Chrome)</i> <br><br>  Cada núcleo fica ocioso por um bom tempo e também “salta” entre micro-tarefas o tempo todo.  Parece que a granularidade dessas tarefas não é ótima, o que leva a um grande número de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alternâncias</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contexto</a> e à concorrência devido à sincronização. <br><br>  Vamos ver o que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">detector de vôo</a> nos diz.  Existem problemas no acesso síncrono aos dados (se houver algum, temos problemas muito maiores que o desempenho)? <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -race PASS</code> </pre> <br>  Ótimo!  Tudo está correto.  Não foram encontrados voos.  Funções de teste e funções de benchmark são funções diferentes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">consulte a documentação</a> ), mas aqui elas chamam a mesma função <i>ParseAdexpMessage</i> ; portanto, o que verificamos para vôos de dados por testes é bom. <br><br>  O modelo competitivo na versão “boa” consiste em processar cada linha do arquivo de entrada em uma goroutine separada (para usar todos os núcleos).  A intuição do autor aqui funcionou bem, pois as goroutines têm uma reputação de recursos fáceis e baratos.  Mas quanto ganhamos com a execução paralela?  Vamos comparar com o mesmo código, mas sem usar goroutines (basta remover a palavra go que vem antes da chamada da função): <br><br><img src="https://habrastorage.org/webt/up/1q/0f/up1q0fy6bggo-62uevoioyo0huq.png"><br><img src="https://habrastorage.org/webt/ae/v3/go/aev3gocqbxle0pa3_lmeeyyczrg.png"><br><br>  Ops, parece que o código se tornou mais rápido sem o uso de simultaneidade.  Isso significa que a sobrecarga (diferente de zero) para o lançamento de goroutines excede o tempo que ganhamos usando vários núcleos ao mesmo tempo.  O próximo passo natural deve ser remover a sobrecarga (diferente de zero) para usar canais para enviar os resultados.  Vamos substituí-lo por uma fatia regular: <br><br><img src="https://habrastorage.org/webt/p_/sm/dl/p_smdl6hi439zezi4dygfvuyvtc.png"><br>  <i>μs por chamada (menos é melhor)</i> <br><br>  Obtivemos cerca de 40% de aceleração em relação à versão “boa”, simplificando o código e removendo a concorrência ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diff</a> ). <br><br><img src="https://habrastorage.org/webt/qr/in/pi/qrinpifpqvwgdb65z1yflyywjhg.png"><br>  <i>Com uma goroutine, apenas um núcleo funciona por vez</i> <br><br>  Vamos agora ver as funções importantes no gráfico pprof: <br><br> <a href=""><img src="https://habrastorage.org/webt/89/sd/bk/89sdbk8fhme8ixv37a2hmnxpj54.png"></a> <br>  <i>Procurando gargalos</i> <br><br>  A referência da versão atual (operação sequencial, fatias) gasta 86% do tempo analisando as mensagens, e isso é normal.  Mas notamos rapidamente que 43% do tempo é gasto no uso de expressões regulares e da função <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(* Regexp) .FindAll</a> . <br><br>  Apesar de as expressões regulares serem uma maneira conveniente e flexível de obter dados de texto sem formatação, elas têm desvantagens, incluindo o uso de um grande número de recursos, processador e memória.  Eles são uma ferramenta poderosa, mas geralmente seu uso é desnecessário. <br><br>  Em nosso programa, um modelo <br><br><pre> <code class="go hljs">patternSubfield = <span class="hljs-string"><span class="hljs-string">"-.[^-]*"</span></span></code> </pre> <br>  Destina-se principalmente a destacar comandos começando com um traço (-), e pode haver vários na linha.  Depois de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">extrair</a> um pequeno código, isso pode ser feito usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bytes.Split</a> .  Vamos adaptar o código ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confirmar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confirmar</a> ) para alterar as expressões regulares para Split: <br><br><img src="https://habrastorage.org/webt/ks/8l/s2/ks8ls2upltp-tnqnpinp2tauqkc.png"><br>  <i>μs por chamada (menos</i> é <i>melhor)</i> <br><br>  Uau!  Código 40% mais produtivo!  O gráfico de consumo da CPU agora fica assim: <br><br> <a href=""><img src="https://habrastorage.org/webt/be/ux/dy/beuxdy132ncb8resbitn2gndy1a.png"></a> <br><br>  Não há mais tempo perdido em expressões regulares.  Uma parte significativa (40%) vai para a alocação de memória de cinco funções diferentes.  Curiosamente, agora 21% do tempo é gasto na função <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bytes.Trim</a> : <br><br><img src="https://habrastorage.org/webt/8f/if/md/8fifmdma-hteqqu_p85umbyo1ly.png"><br>  <i>Esse recurso me intriga.</i>  <i>O que podemos fazer aqui?</i> <i><br><br></i>  <i>bytes.Trim</i> espera uma string com caracteres que "corta" como argumento, mas como essa string passamos uma string com apenas um caractere - um espaço.  Este é apenas um exemplo de como você pode obter aceleração devido à complexidade: vamos criar nossa função de apara em vez da função padrão.  Nossa função de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ajuste</a> personalizado funcionará com um único byte em vez de uma linha inteira: <br><br><img src="https://habrastorage.org/webt/xs/cv/np/xscvnpnpkjo9ml4yq8chimeimv4.png"><br><img src="https://habrastorage.org/webt/h-/is/7x/h-is7xreexvfn_s537mdqtdkmrc.png"><br>  <i>μs por chamada (menos é melhor)</i> <br><br>  Viva, mais 20% de desconto!  A versão atual é quatro vezes mais rápida que a original “ruim” e, ao mesmo tempo, usa apenas um núcleo.  Nada mal! <br><br><hr><br><br>  Anteriormente, abandonamos a competitividade no nível de processamento de linha, mas eu argumento que a aceleração pode ser alcançada usando a competitividade em um nível superior.  Por exemplo, o processamento de 6.000 arquivos (6.000 mensagens) é mais rápido no meu computador se cada arquivo for processado em sua própria goroutine: <br><br><img src="https://habrastorage.org/webt/r0/lf/oo/r0lfoof3kljocawz0tjcmogrww4.png"><br>  <i>μs por chamada (menos é melhor; roxo é uma solução competitiva)</i> <br><br>  O ganho é de 66% (ou seja, aceleração três vezes).  Isso é bom, mas não muito, considerando que todos os 12 núcleos de processador que tenho são usados.  Isso pode significar que o novo código otimizado que processa o arquivo inteiro ainda é uma "pequena tarefa", para a qual a sobrecarga para a criação de goroutines e o custo da sincronização não são insignificantes.  Curiosamente, aumentar o número de mensagens de 6.000 para 120.000 não afeta a versão de thread único e reduz o desempenho na versão "uma goroutine por mensagem".  Isso ocorre porque, apesar de criar uma quantidade tão grande de goroutines ser possível e às vezes útil, ele traz sua própria sobrecarga na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">área</a> do programador de tempo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">execução</a> . <br><br>  Podemos reduzir ainda mais o tempo de execução (não em 12 vezes, mas ainda assim) criando apenas alguns trabalhadores.  Por exemplo, 12 goroutines de longa duração, cada uma das quais processará parte das mensagens: <br><br><img src="https://habrastorage.org/webt/re/v2/wf/rev2wf-q7cfgvhxsfj15n30l6xa.png"><br>  <i>μs por chamada (menos é melhor; roxo é uma solução competitiva)</i> <br><br>  Esta opção reduz o tempo de execução em 79% em comparação com a versão de thread único.  Observe que essa estratégia só faz sentido se você tiver muitos arquivos para processar. <br><br>  O uso ideal de todos os núcleos do processador é usar várias goroutines, cada uma das quais processa uma quantidade significativa de dados sem nenhuma interação ou sincronização antes que o trabalho seja concluído. <br><br>  Geralmente eles levam tantos processos (goroutine) quanto os núcleos do processador, mas essa nem sempre é a melhor opção: tudo depende da tarefa específica.  Por exemplo, se você estiver lendo algo do sistema de arquivos ou fazendo muitas chamadas de rede, para obter mais desempenho, use mais goroutines que seus núcleos. <br><br><img src="https://habrastorage.org/webt/gd/m-/ic/gdm-icxpy5qq_n2fw5-zru20gu4.png"><br>  <i>μs por chamada (menos é melhor; roxo é uma solução competitiva)</i> <br><br>  Chegamos ao ponto em que é difícil aumentar o desempenho da análise com algumas alterações localizadas.  O tempo de execução é dominado pelo tempo para alocação de memória e coleta de lixo.  Isso parece lógico, pois as funções de gerenciamento de memória são bastante lentas.  Uma otimização adicional dos processos associados às alocações permanece como uma lição de casa para os leitores. <br><br><hr><br><br>  O uso de outros algoritmos também pode levar a um grande ganho de desempenho. <br><br>  Aqui eu fui inspirado por uma palestra da Lexical Scanning em Go from Rob Pike, <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HxaD_trXwRE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  para criar um lexer personalizado ( <a href="">origem</a> ) e um analisador personalizado ( <a href="">origem</a> ).  Esse código ainda não está pronto (não processo muitos casos de canto), é menos claro que o algoritmo original e, às vezes, é difícil escrever o tratamento de erros correto.  Mas é pequeno e 30% mais rápido que a versão mais otimizada. <br><br><img src="https://habrastorage.org/webt/ey/c3/n7/eyc3n7fnc1lu_szlyn2fnn0lzti.png"><br>  <i>μs por chamada (menos é melhor; roxo é uma solução competitiva)</i> <br><br>  Sim  Como resultado, obtivemos uma aceleração de 23 vezes em comparação com o código fonte. <br><br><hr><br><br>  Isso é tudo por hoje.  Espero que você tenha gostado dessa aventura.  Aqui estão algumas notas e conclusões: <br><br><ul><li>  A produtividade pode ser melhorada em vários níveis de abstração, usando diferentes técnicas, e o ganho é frequentemente aumentado. <br></li><li>  O ajuste precisa começar com abstrações de alto nível: estruturas de dados, algoritmos, o desacoplamento correto dos módulos.  Adote abstrações de baixo nível mais tarde: E / S, lotes, competitividade, usando a biblioteca padrão, trabalhando com memória, alocando memória. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> análise do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Big O</a> é muito importante, mas geralmente não é a ferramenta mais adequada para acelerar um programa. <br></li><li>  Escrever benchmarks é um trabalho árduo.  Use perfis e referências para encontrar gargalos e obter uma compreensão mais ampla do que está acontecendo no programa.  Lembre-se de que os resultados de referência não são os mesmos que os usuários experimentarão no trabalho da vida real. <br></li><li>  Felizmente, um conjunto de ferramentas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bench</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pprof</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trace</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Race Detector</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cover</a> ) torna a pesquisa sobre o desempenho do código acessível e interessante. <br></li><li>  Escrever testes bons e relevantes não é uma tarefa trivial.  Mas eles são extremamente importantes para não se aventurar na natureza.  Você pode refatorar, certificando-se de que o código permaneça correto. <br></li><li>  Pare e pergunte-se o quão rápido é "rápido o suficiente".  Não perca seu tempo otimizando alguns scripts únicos.  Não se esqueça que a otimização não é gratuita: tempo, complexidade, erros e dívida técnica do engenheiro. <br></li><li>  Pense duas vezes antes de complicar o código. <br></li><li>  Algoritmos com complexidade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ω</a> (n²) e acima geralmente são muito caros. <br></li><li>  Algoritmos com complexidade O (n) ou O (n log n) e abaixo geralmente estão ok. <br></li><li>  Vários <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fatores ocultos</a> não podem ser ignorados.  Por exemplo, todas as melhorias no artigo foram feitas reduzindo esses fatores e não alterando a classe de complexidade do algoritmo. <br></li><li>  A E / S geralmente é um gargalo: consultas de rede, consultas de banco de dados, sistema de arquivos. <br></li><li>  Expressões regulares geralmente são muito caras e desnecessárias. <br></li><li>  As alocações de memória são mais caras que os cálculos. <br></li><li>  Um objeto alocado na pilha é mais barato que um objeto alocado no heap. <br></li><li>  As fatias são úteis como uma alternativa às movimentações caras de memória. <br></li><li>  As seqüências de caracteres são eficazes quando somente leitura (incluindo nova segmentação).  Em todos os outros casos, [] byte são mais eficazes. <br></li><li>  É muito importante que os dados que você processa estejam próximos (caches do processador). <br></li><li>  Competitividade e paralelismo são muito úteis, mas difíceis de preparar. <br></li><li>  Ao cavar fundo e fundo, lembre-se do "piso de vidro" que você não deseja invadir o Go.  Se suas mãos estão ansiosas para tentar instruções de montagem, instruções SIMD, pode ser necessário usar o Go apenas para prototipagem e depois mudar para um idioma de nível inferior para obter o controle total do hardware e a cada nanossegundo! <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415919/">https://habr.com/ru/post/pt415919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415909/index.html">Extensão da Web entre navegadores para scripts personalizados Parte 2</a></li>
<li><a href="../pt415911/index.html">Acesso a um índice de matriz inexistente</a></li>
<li><a href="../pt415913/index.html">Aquecer para quem pode em Python</a></li>
<li><a href="../pt415915/index.html">Prática severa: que tipo de conexão sem fio temos para os hoteleiros</a></li>
<li><a href="../pt415917/index.html">A "Lei da Primavera" entrou em vigor: o que vem a seguir?</a></li>
<li><a href="../pt415923/index.html">A unidade é lenta? Cuidado LINQ</a></li>
<li><a href="../pt415925/index.html">MasterCard patenteada tecnologia blockchain anônima</a></li>
<li><a href="../pt415927/index.html">Lâmpada industrial Breeze 50</a></li>
<li><a href="../pt415929/index.html">Otimização da arquitetura de inteligência artificial: a corrida começa</a></li>
<li><a href="../pt415933/index.html">Como construir uma arquitetura IIoT faça você mesmo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>