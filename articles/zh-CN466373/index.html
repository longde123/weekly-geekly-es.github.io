<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏸️ 👨🏽‍🤝‍👨🏼 👨🏼‍🎓 Python TamTam机器人开发 📼 🚃 🧙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 让我自我介绍：我叫Sergey Agaltsov，我是“生活中的程序员”。 这意味着我长期以来一直是IT经理，完全不是专业的程序员，但是我经常在自己的主要活动和业余爱好中使用编程。 正如我以前的一位老板经常说的那样：“ Seryoga！您再次陷入编程之中！” 没错，我不能说他或其他任何人对...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python TamTam机器人开发</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/466373/"><p><img src="https://habrastorage.org/webt/hv/5y/zn/hv5yzn1xbdnmstacgsl-4bqqcfc.jpeg"></p><br><p> 哈Ha！ 让我自我介绍：我叫Sergey Agaltsov，我是“生活中的程序员”。 这意味着我长期以来一直是IT经理，完全不是专业的程序员，但是我经常在自己的主要活动和业余爱好中使用编程。 正如我以前的一位老板经常说的那样：“ Seryoga！您再次陷入编程之中！” 没错，我不能说他或其他任何人对此都不满意。 </p><br><p> 在TamTam Messenger上出现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Bot API</a>之后，作为一个真正的程序员，因此我是懒惰的程序员，我创建了2个Python库来使用它： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开放客户端API</a> （以下简称OAC）-最初是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenAPI Generator</a>基于API方案<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">生成</a>的，然后考虑到生成器的功能对其进行了修改； </li><li> 该客户端的外壳是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TamTamBot</a> （以下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">称为</a> TTB），可简化OAC的工作。 </li></ul><br><p> 因此，有一个特定的TamTam Python SDK。 </p><br><p> 我首先“为了自己，为了灵魂”做到了这一点，但也建议TamTam社区（如果需要）使用它。 但是，正如您所知，没有一件好事会受到惩罚-人们要求写一篇培训文章。 这是我的这篇文章。 在其中，我将告诉您如何使用这些库开发一个简单的机器人。 </p><a name="habracut"></a><br><h1 id="zadacha"> 挑战赛 </h1><br><p> 开发旨在简化机器人开发人员操作的机器人。 该机器人应以状态bot-api的永久轮询（长时间轮询）模式工作。 在本文中，该机器人将经过训练以显示发送给他的消息的内部，并且还将其配置为与开发的功能匹配。 </p><br><p> 据了解，读者已经安装了连接到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PyCharm</a>开发环境的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python 3</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">git</a> （开发环境可能有所不同，但故事将基于PyCharm）。 了解OOP的基础是可取的。 </p><br><h1 id="poluchenie-tokena-bota"> 获取机器人令牌 </h1><br><p> 通过调用专用机器人<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@PrimeBot获得</a>令牌。 </p><br><p> 我们在TamTam中找到该机器人，输入/ create命令并回答以下问题： </p><br><ul><li>输入机器人的唯一简称（用拉丁字母）-这是机器人的用户名，可以通过@或形式为<code>https://tt.me/username</code>的链接来使用它。 用户名没有特别限制。 特别是，bot这个词是可选的。 </li><li> 输入名称-这是机器人的显示名称。 在这里您已经可以使用西里尔字母。 </li></ul><br><p> 如果正确输入所有内容，则创建的漫游器将添加到联系人中，作为回报，我们将收到令牌-一系列字符，格式为：HDyDvomx6TfsXkgwfFCUY410fv-vbf4XVjr8JVSUu4c。 </p><br><h1 id="pervichnaya-nastroyka"> 初始设定 </h1><br><div class="spoiler">  <b class="spoiler_title">显示</b> <div class="spoiler_text"><p> 创建目录： </p><br><pre> <code class="plaintext hljs">mkdir ttBotDevHelper</code> </pre> <br><p> 转到它： </p><br><pre> <code class="plaintext hljs">cd ttBotDevHelper/</code> </pre> <br><p> 我们初始化git仓库： </p><br><pre> <code class="plaintext hljs">git init</code> </pre> <br><p> 下载必要的库，将它们添加为git的子模块： </p><br><pre> <code class="plaintext hljs">git submodule add https://github.com/asvbkr/openapi_client.git openapi_client git submodule add https://github.com/asvbkr/TamTamBot.git TamTamBot</code> </pre> <br><p> 我们在PyCharm中打开创建的目录（例如，从资源管理器中的上下文菜单“以PyCharm项目打开文件夹”下），并创建一个我们的机器人将包含的文件-File / New / Python文件。 在出现的对话框中，输入名称-ttBotDevHelper，并回答添加到git的问题。 </p><br><p> 现在，我们需要为项目创建一个虚拟环境。 </p><br><p> 要创建虚拟环境，请选择“文件/设置”，然后在“项目”选项卡上选择“项目解释器”子项。 接下来，在右侧，点击齿轮图标，然后选择添加： </p><br><p><img src="https://habrastorage.org/webt/dg/js/qv/dgjsqvo0ygtsp12lehregxcm8po.png" alt="图片"></p><br><p>  PyCharm将提供自己的住宿选择。 </p><br><p><img src="https://habrastorage.org/webt/lp/gg/og/lpggogip_ekpmuoiegolvfxyk2s.png" alt="图片"></p><br><p> 同意他是有意义的。 </p><br><p> 创建虚拟环境后，将打开上一个屏幕，但该屏幕已经包含有关创建的环境的信息。 在此屏幕上，您需要通过单击右侧的“ +”图标并输入软件包名称来安装必要的软件包： </p><br><ul><li> 要求 </li><li> 六 </li></ul><br><p> 然后，我们将.gitignore文件添加到项目中，不包括git中不需要的文件，其内容如下： </p><br><pre> <code class="plaintext hljs">venv/ .idea/ # Byte-compiled / optimized / DLL files __pycache__/ *.py[cod] *$py.class *.log *.log.* .env ttb.sqlite3</code> </pre> <br><p> 添加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个</a>名为<code>TT_BOT_API_TOKEN</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的环境变量</a> ，在其中我们指示从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tt.me/primebot</a>接收到的机器人标记的值，然后重新启动PyCharm。 </p><br><p>  <strong>（！）</strong> PyCharm最好使用特殊的.env文件，而不是直接将环境变量添加到OS环境。 其配置将在下面讨论。 </p><br><p> 恭喜，现在您可以继续进行最有趣的部分-编写机器人。 </p></div></div><br><h1 id="zapusk-prosteyshego-bota"> 简单的机器人启动 </h1><br><p> 打开ttBotDevHelper.py文件并编写第一行： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: UTF-8 -*- from TamTamBot.TamTamBot import TamTamBot class BotDevHelper(TamTamBot): pass</span></span></code> </pre> <br><p> 在这里，我们基于TamTamBot类创建bot类。 </p><br><p>  PyCharm建议BotDevHelper类包含需要实现的抽象方法。 在类名称上按Alt-Enter，选择“实施抽象方法”，选择PyCharm提出的所有方法（其中2种），然后单击“确定”。 结果，将添加两个空属性方法：令牌和描述。 我们修改结果代码如下： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: UTF-8 -*- import os from TamTamBot.TamTamBot import TamTamBot from TamTamBot.utils.lng import set_use_django class BotDevHelper(TamTamBot): @property def token(self): return os.environ.get('TT_BOT_API_TOKEN') @property def description(self): return '       .\n\n' \ 'This bot is an helper in the development and management of bots.' if __name__ == '__main__': set_use_django(False) BotDevHelper().polling()</span></span></code> </pre> <br><p>  <code>token</code>属性返回我们机器人的令牌，其值来自环境变量<code>TT_BOT_API_TOKEN</code> 。  <code>description</code>属性返回我们机器人的扩展描述，它将显示给用户。 </p><br><p> 要在状态轮询模式下运行我们的漫游器，需要文件末尾的代码。 </p><br><p> 我注意到基类<code>TamTamBot</code>涉及使用django Web服务器在Web挂钩模式下工作。 但是现在任务变得更简单了，我们不需要django，这就是我们在<code>set_use_django(False)</code>中报告的<code>set_use_django(False)</code> 。 在这里，为我们类的对象调用<code>polling()</code>方法，以确保在所需模式下进行操作。 </p><br><p> 完成了最低限度的工作。 该代码已经相当有效。 运行它来运行。 为此，请按组合键Ctrl-Shift-F10。 </p><br><p> 如果您之前没有将环境变量直接添加到操作系统，则在启动时会出现错误消息“ No access_token”。 要解决此问题，请将PyCharm配置为使用.env文件。 </p><br><div class="spoiler">  <b class="spoiler_title">展示如何</b> <div class="spoiler_text"><p> 创建一个.env文本文件。 在我们的情况下，其内容应如下： </p><br><pre> <code class="plaintext hljs">TT_BOT_API_TOKEN=__</code> </pre> <br><p> 现在，您需要将其连接到PyCharm中的启动配置： </p><br><p> 我们选择运行/编辑配置，然后在EnvFile选项卡上连接我们的.env文件： </p><br><p><img src="https://habrastorage.org/webt/2s/6s/ci/2s6scissf6roedcy6r26rjoi6ve.png" alt="图片"></p><br><p> 然后单击“应用”。 </p></div></div><br><p> 启动机器人后，您可以转到TamTam，与我们的机器人打开对话框，然后单击“开始”按钮。 该机器人将报告有关其隐藏的超能力的信息。 这意味着该机器人正在运行。 当机器人在演示模式下工作时，有4个命令可用。 只需检查一下。 </p><br><p> 尽管机器人对该机器人的冷静发表了明确的意见，但他还是胆怯地暗示了一个事实，即到目前为止，他什么也做不了。 教导他征服世界所需的一切是我们的任务。 </p><br><h1 id="priyom-soobscheniya-istochnika-i-otpravka-otvetnogo-soobscheniya-s-vnutrennim-predstavleniem-soobscheniya-istochnika"> 接收源消息并发送带有源消息内部表示的响应消息 </h1><br><p> 我们将阻止<code>receive_text()</code>方法，当向机器人发送文本到聊天室时，该方法的控制权将被转移： </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive_text</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update)</span></span></span><span class="hljs-function">:</span></span> res = self.msg.send_message(NewMessageBody(<span class="hljs-string"><span class="hljs-string">f' : </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{update.message}</span></span></span><span class="hljs-string">'</span></span>, link=update.link), user_id=update.user_id) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bool(res)</code> </pre> <br><p> 传递给此方法的<code>UpdateCmn</code>类的<code>update</code>对象包含各种有用的信息，尤其是我们现在需要的所有信息： </p><br><ul><li>  <code>update.message</code>包含消息本身的对象； </li><li>  <code>update.link</code>此消息的就绪响应链接； </li><li>  <code>update.user_id</code>发送消息的用户的标识符。 </li></ul><br><p> 要从漫游器发送消息，我们使用<code>self.msg</code>变量，该变量包含<code>MessagesApi</code>对象，该对象实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">API说明</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">messages</a>部分中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述的功能</a> 。 该对象包含我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>send_message()</code></a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>send_message()</code></a>方法，该方法提供消息的发送。 至少，必须将此方法传递给<code>NewMessageBody</code>类的对象和目标（在本例中为用户ID）。 </p><br><p> 反过来，在这种情况下， <code>NewMessageBody</code>类的对象是通过发送源消息对象的文本表示形式以及到源消息的响应链接来创建的。 </p><br><p> 我们重新启动僵尸程序，并与僵尸程序进行对话，检查该僵尸程序对包含源消息对象内部表示的任何消息产生响应。 </p><br><p> 此状态的源代码<a href="">在此处</a> 。 </p><br><h1 id="dobavlenie-novoy-komandy-bota-s-parametrom---pokaz-vnutrennego-predstavleniya-soobscheniya-po-ego-identifikatoru"> 添加带有参数的新bot命令-通过其标识符显示消息的内部表示 </h1><br><p> 开发机器人时，通常需要使用一个或多个已知消息标识符（消息ID-中）查看消息的内部表示。 将此功能添加到我们的机器人中。 为此，首先，我们采用一种单独的方法来输出有关消息内部表示的信息的功能： </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view_messages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update, list_mid, link=None)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> msgs = self.msg.get_messages(message_ids=list_mid) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msgs: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> msgs.messages: r = self.msg.send_message(NewMessageBody(<span class="hljs-string"><span class="hljs-string">f' </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{msg.body.mid}</span></span></span><span class="hljs-string">:\n`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{msg}</span></span></span><span class="hljs-string">`'</span></span>[:NewMessageBody.MAX_BODY_LENGTH], link=link), user_id=update.user_id) res = res <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre> <br><p> 在这种方法中，我们将列表传递给中间。 </p><br><p> 要获取消息对象，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>self.msg.get_messages</code></a>方法，该方法返回messages属性中的对象列表。 </p><br><p> 此外，每个接收到的消息的文本表示形式都以单独的消息发送到我们的对话中。 为避免错误，生成的消息的文本将被最大消息长度的常量<code>NewMessageBody.MAX_BODY_LENGTH</code>截断。 </p><br><p> 然后添加一种处理命令的方法。  <strong>我们</strong>称之为<strong>vmp</strong> 。 您可以将中间列表传递给带有空格的命令。 </p><br><p>  TTB的设计使命令处理程序应作为名为<code>cmd_handler_%s</code>的方法创建，其中％s是命令的名称。 即 对于vmp命令，该方法将称为<code>cmd_handler_vmp</code> 。  <code>UpdateCmn</code>类的对象传递给命令处理程序。 此外，对于命令，它可能包含<code>cmd_args</code>属性，该属性包含使用命令输入的行和单词的字典 </p><br><p> 该代码将如下所示： </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmd_handler_vmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> update.this_cmd_response: <span class="hljs-comment"><span class="hljs-comment">#    ,       if update.cmd_args: #        list_id = [] parts = update.cmd_args.get('c_parts') or [] if parts: for line in parts: for part in line: list_id.append(str(part)) if list_id: res = self.view_messages(update, list_id, update.link) return bool(res)</span></span></code> </pre> <br><p> 我们重启机器人。 现在，如果您在漫游器对话框中键入以下命令： <code>/vmp mid1 mid2</code> （您可以将其先前的检查作为mid），那么作为回报，对于每个传输的mid，我们都会得到两条带有内部消息源消息对象的消息。 </p><br><p> 此状态的源代码<a href="">在此处</a> 。 </p><br><h1 id="modifikaciya-komandy-bota-dlya-raboty-s-tekstovym-otvetom"> 修改用于处理文本响应的bot命令 </h1><br><p> 您也可以尝试从其他频道/聊天转发消息。 但是在这种情况下，只会显示与机器人对话时源消息中包含的内容。 特别是在发送消息时，不会保存按钮信息。 </p><br><p> 但是，如果我们想查看有关原始消息的信息怎么办？ 在这种情况下，您需要从转发的消息中抽中。 </p><br><p> 为了实现此模式，我们修改了<strong>vmp</strong>命令，以便在不带参数的情况下调用该命令时，它希望消息被转发，然后，它使用已发送消息的中间并显示有关该消息的信息。 </p><br><p>  <strong>（！）</strong>为使此功能正确运行，必须授予漫游器从频道/聊天源读取的权限。 </p><br><p> 我们将命令代码修改如下： </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmd_handler_vmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> update.this_cmd_response: <span class="hljs-comment"><span class="hljs-comment">#    ,       if update.cmd_args: #        list_id = [] parts = update.cmd_args.get('c_parts') or [] if parts: for line in parts: for part in line: list_id.append(str(part)) if list_id: res = self.view_messages(update, list_id, update.link) else: #      self.msg.send_message(NewMessageBody(f' **  /    :'), user_id=update.user_id) update.required_cmd_response = True #       else: #    message = update.message link = message.link #       link #  -   . if link and link.type == MessageLinkType.FORWARD: res = self.view_messages(update, [link.message.mid], update.link) else: #         ,    . self.msg.send_message(NewMessageBody(f'.  **   /. , .'), user_id=update.user_id) return False return bool(res)</span></span></code> </pre> <br><p> 由于 使用这种方法，由于缺少消息访问权限，风险会增加，然后在<code>view_messages()</code>方法中添加检查是否符合请求/接收的消息数量的方法： </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view_messages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update, list_mid, link=None)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> msgs = self.msg.get_messages(message_ids=list_mid) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msgs: <span class="hljs-comment"><span class="hljs-comment">#    mid     if len(msgs.messages) &lt; len(list_mid): self.msg.send_message(NewMessageBody( f'     .    @{self.username}  /  .', link=update.link ), user_id=update.user_id) return False else: for msg in msgs.messages: r = self.msg.send_message(NewMessageBody(f' {msg.body.mid}:\n`{msg}`'[:NewMessageBody.MAX_BODY_LENGTH], link=link), user_id=update.user_id) res = res or r return res</span></span></code> </pre> <br><p> 我们重新启动漫游器，给出/ vmp命令，并且在显示有关转发必要性的提示后，我们从频道/ chat转发消息。 如果漫游器有权在此频道/聊天中阅读消息，则将显示转发的消息对象的文本表示形式。 如果没有访问权限，该漫游器将报告可能的问题，并将等待从正确的源进行转发。 </p><br><h1 id="nastroyka-svoystv-bota"> 设置机器人属性 </h1><br><p> 现在仍然可以带来光泽。 让我们关闭<code>about</code>属性，该属性返回机器人开始工作时显示的文本以及/ start命令。 </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta"> @property def about(self): return '       .'</span></span></code> </pre> <br><p> 我们将阻止<code>get_commands()</code>方法，该方法返回机器人的命令列表，该列表显示在机器人的对话框中。 </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_commands</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: () -&gt; [BotCommand] commands = [ BotCommand('start', ' '), BotCommand('menu', ' '), BotCommand('vmp', '  '), ] return commands</span></span></code> </pre> <br><p> 让我们关闭main_menu_buttons属性，该属性返回由/ menu命令调用的主菜单上的按钮列表。 </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main_menu_buttons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: () -&gt; [] buttons = [ #       -  [CallbackButtonCmd(' ', 'start')], #        - .    -  [CallbackButtonCmd('  ', 'vmp', intent=Intent.POSITIVE)], ] return buttons</span></span></code> </pre> <br><p> 我们重启机器人，确保一切正常。 恭喜，您创建了第一个机器人，尽管有一些玩具，但它具有非常强大的功能。 </p><br><p> 此状态的源代码<a href="">在此处</a> 。 </p><br><p> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>看到正在运行的@devhelpbot机器人。 </p><br><p> 现在就这些了。 如果您对该主题感兴趣，那么在以下文章中，我将考虑该机器人的进一步开发。 例如，添加自定义按钮（尤其是“是/否”）并进行处理，发送各种类型的内容（文件，照片等），在网络摘机模式下工作等。 </p><br><p> 顺便说一句，您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特殊聊天中</a>快速提问。 直接的建议/想法在那里。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN466373/">https://habr.com/ru/post/zh-CN466373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN466361/index.html">如何获得哥萨克GICSP证书</a></li>
<li><a href="../zh-CN466363/index.html">lur饮DevOps。 第一天 Git，CI / CD，IaC和绿色恐龙</a></li>
<li><a href="../zh-CN466365/index.html">开发单片类Unix操作系统-入门（1）</a></li>
<li><a href="../zh-CN466367/index.html">Android API级别，向后和向前兼容</a></li>
<li><a href="../zh-CN466371/index.html">使用趋势技术可能遇到的三大销售异议</a></li>
<li><a href="../zh-CN466375/index.html">博物馆数据艺术。 KUVT2-学习和玩乐</a></li>
<li><a href="../zh-CN466379/index.html">在微控制器上运行“桌面”软件</a></li>
<li><a href="../zh-CN466381/index.html">时代LED灯泡在2019年如何变化</a></li>
<li><a href="../zh-CN466383/index.html">Cryptocurrency Ocean：使用CoinMarketCap审查前50个项目</a></li>
<li><a href="../zh-CN466385/index.html">了解消息代理。 通过ActiveMQ和Kafka学习消息传递的机制。 第一章</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>