<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏾 🤟🏾 🛂 Blockchain aléatoire RSA 🍤 🧑🏻‍🤝‍🧑🏻 ♀️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a un problème - il est difficile de générer un nombre aléatoire dans un réseau décentralisé. Presque toutes les blockchains l'ont déjà rencontré....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain aléatoire RSA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/464357/"> Il y a un problème - il est difficile de générer un nombre aléatoire dans un réseau décentralisé.  Presque toutes les blockchains l'ont déjà rencontré.  En effet, dans les réseaux où il n'y a pas de confiance entre les utilisateurs, la création d'un nombre aléatoire indéniable résout de nombreux problèmes. <br><br>  L'article explique comment résoudre le problème en utilisant des jeux comme exemple.  Le premier d'entre eux était l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbre de Noël Waves</a> .  Pour le développement, nous avions besoin d'un générateur de nombres aléatoires. <br><br><img src="https://habrastorage.org/webt/nq/lx/gi/nqlxgizojulzpf3ydp-rmq8g9fc.png"><br><a name="habracut"></a><br>  Au départ, nous avions prévu de générer un nombre basé sur les informations de la blockchain.  Cependant, il est devenu clair: le nombre pourrait être truqué, ce qui signifie que la solution ne convient pas. <br><br>  Nous avons trouvé une solution de contournement: utilisez le schéma de validation et de divulgation.  Le serveur a «deviné» un nombre de 1 à 5, y a ajouté du «sel», puis haché le résultat à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'</a> aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la fonction Keccak</a> .  Le serveur a pré-déployé un contrat intelligent avec un numéro déjà enregistré.  Il s'avère que le jeu a été réduit au fait que l'utilisateur a deviné le nombre caché par le hachage. <br><br>  Le joueur a fait un pari et le serveur a envoyé le numéro demandé et le «sel» au contrat intelligent.  En langage clair, il a révélé les cartes.  Après cela, le serveur a vérifié les numéros et a décidé si l'utilisateur avait gagné ou perdu. <br><br>  Si le serveur n'a pas envoyé de numéro ou de «sel» pour vérification, l'utilisateur a gagné.  Dans ce cas, pour chaque jeu, il était nécessaire de déployer un contrat intelligent à l'avance et d'y mettre des gains potentiels.  Cela s'est avéré gênant, long et coûteux.  A cette époque, il n'y avait pas d'autre solution sûre. <br><br>  Récemment, l'équipe Tradisys a proposé d'ajouter la fonction <b>rsaVerify ()</b> au protocole Waves.  Il vérifie la validité de la signature RSA en fonction de la clé publique et privée.  En conséquence, la fonction a été ajoutée. <br><br>  Nous avons développé trois jeux: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dice Roller</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Coin Flip</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ride On Waves</a> .  Chaque technologie implémentée de nombres aléatoires.  Voyons comment cela fonctionne. <br><br><img src="https://habrastorage.org/webt/tu/b5/bx/tub5bxgtyithovcsurhvcbkhgw8.png"><br><br>  Considérez la génération de nombres aléatoires en utilisant Ride on Waves comme exemple.  Un contrat intelligent peut être trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Accédez à l'onglet <b>Script</b> et sélectionnez <b>Décompilé</b> .  Voir le code du contrat intelligent (aka script). <br><br><img src="https://habrastorage.org/webt/s2/93/x-/s293x-xhotbeck3_j1ghquvhbmo.png"><br><br>  Le code de contrat intelligent contient un ensemble de fonctions.  Ceux marqués comme @Callable peuvent être déclenchés à l'aide de <b>transactions d'invocation</b> .  Nous sommes intéressés par deux fonctions: <b>parier</b> et <b>retirer</b> : <br><br><ul><li>  func bet (playerChoice) </li><li>  func retrait (gameId, rsaSign) </li></ul><br>  1. L'utilisateur sélectionne la longueur du segment et la taille du pari. <br><br><img src="https://habrastorage.org/webt/7s/0a/qu/7s0aqupmfkhtboadeg0bhtxpyrk.png"><br><br>  2. Le client forme une fonction de pari.  Pour l'image ci-dessus, ce sera <b>parié ("50")</b> . <br><br>  3. Le client envoie la transaction Invocation à l'adresse du contrat intelligent (diffusion InvocationTx).  Une transaction en tant que paramètre Call contient la fonction de mise.  Cela signifie que la transaction d'invocation démarre l'exécution de la fonction de pari (choix: chaîne) sur le contrat intelligent. <br><br><img src="https://habrastorage.org/webt/gz/xx/r4/gzxxr4qfp3qzavthif-gifp6k3y.png"><br><br>  4. Considérez la fonction de pari: <br><br><pre><code class="scala hljs"><span class="hljs-meta"><span class="hljs-meta">@Callable</span></span>(i) func bet (playerChoice) = { let newGameNum = <span class="hljs-type"><span class="hljs-type">IncrementGameNum</span></span>() let gameId = toBase58String(i.transactionId) let pmt = extract(i.payment) let betNotInWaves = isDefined(pmt.assetId) let feeNotInWaves = isDefined(pmt.assetId) let winAmt = <span class="hljs-type"><span class="hljs-type">ValidateBetAndDefineWinAmt</span></span>(pmt.amount, playerChoice) let txIdUsed = isDefined(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, gameId)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (betNotInWaves) then <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (<span class="hljs-string"><span class="hljs-string">"Bet amount must be in Waves"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (feeNotInWaves) then <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (<span class="hljs-string"><span class="hljs-string">"Transaction's fee must be in Waves"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (txIdUsed) then <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (<span class="hljs-string"><span class="hljs-string">"Passed txId had been used before. Game aborted."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { let playerPubKey58 = toBase58String(i.callerPublicKey) let gameDataStr = <span class="hljs-type"><span class="hljs-type">FormatGameDataStr</span></span>(<span class="hljs-type"><span class="hljs-type">STATESUBMITTED</span></span>, playerChoice, playerPubKey58, height, winAmt, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-type"><span class="hljs-type">ScriptResult</span></span>(<span class="hljs-type"><span class="hljs-type">WriteSet</span></span>(cons(<span class="hljs-type"><span class="hljs-type">DataEntry</span></span>(<span class="hljs-type"><span class="hljs-type">RESERVATIONKEY</span></span>, <span class="hljs-type"><span class="hljs-type">ValidateAndIncreaseReservedAmt</span></span>(winAmt)), cons(<span class="hljs-type"><span class="hljs-type">DataEntry</span></span>(<span class="hljs-type"><span class="hljs-type">GAMESCOUNTERKEY</span></span>, newGameNum), cons(<span class="hljs-type"><span class="hljs-type">DataEntry</span></span>(gameId, gameDataStr), nil)))), <span class="hljs-type"><span class="hljs-type">TransferSet</span></span>(cons(<span class="hljs-type"><span class="hljs-type">ScriptTransfer</span></span>(<span class="hljs-type"><span class="hljs-type">SERVER</span></span>, <span class="hljs-type"><span class="hljs-type">COMMISSION</span></span>, unit), nil))) } }</code> </pre> <br>  La fonction écrit un nouveau jeu dans l'état du contrat intelligent.  À savoir: <br><br><ul><li>  Identifiant unique pour un nouveau jeu <b>(identifiant de jeu)</b> </li><li>  État du jeu = SOUMIS </li><li>  Sélection des joueurs (longueur de ligne 50) </li><li>  Clé publique </li><li>  Gains potentiels (dépend de la mise du joueur) </li></ul><br><img src="https://habrastorage.org/webt/ia/w6/s9/iaw6s9uiyfpaut6mhn8gkolxaou.png"><br><br>  Voici à quoi ressemble l'enregistrement de données dans la blockchain (valeur-clé): <br><br><pre> <code class="scala hljs">{ <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"03WON_0283_448t8Jn9P3717UnXFEVD5VWjfeGE5gBNeWg58H2aJeQEgJ_06574069_09116020000_0229"</span></span>, <span class="hljs-string"><span class="hljs-string">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"2GKTX6NLTgUrE4iy9HtpSSHpZ3G8W4cMfdjyvvnc21dx"</span></span> }</code> </pre> <br>  "Clé" (clé) - <b>identifiant de jeu du</b> nouveau jeu.  Les données restantes sont contenues dans la ligne du champ «valeur» (valeur).  Ces entrées sont stockées dans l'onglet <b>Données</b> du contrat intelligent: <br><br><img src="https://habrastorage.org/webt/5l/fi/ur/5lfiurrw9f4mhxvttifuzjue5xm.png"><br><br><img src="https://habrastorage.org/webt/33/8q/tq/338qtq74ja1r7vylnmx_ska0aoy.png"><br><br>  5. Le serveur «regarde» le contrat intelligent et trouve la transaction envoyée (nouveau jeu) en utilisant la blockchain Api.  L'identifiant de jeu du nouveau jeu est déjà enregistré sur la blockchain, ce qui signifie qu'il n'est plus possible de le modifier ou de l'influencer <br><br>  6. Le serveur forme une fonction de retrait (gameId, rsaSign).  Par exemple, ceci: <br><br><pre> <code class="plaintext hljs">withdraw ("FwsuaaShC6DMWdSWQ5osGWtYkVbTEZrsnxqDbVx5oUpq", "base64:Gy69dKdmXUEsAmUrpoWxDLTQOGj5/qO8COA+QjyPVYTAjxXYvEESJbSiCSBRRCOAliqCWwaS161nWqoTL/TltiIvw3nKyd4RJIBNSIgEWGM1tEtNwwnRwSVHs7ToNfZ2Dvk/GgPUqLFDSjnRQpTHdHUPj9mQ8erWw0r6cJXrzfcagKg3yY/0wJ6AyIrflR35mUCK4cO7KumdvC9Mx0hr/ojlHhN732nuG8ps4CUlRw3CkNjNIajBUlyKQwpBKmmiy3yJa/QM5PLxqdppmfFS9y0sxgSlfLOgZ51xRDYuS8NViOA7c1JssH48ZtDbBT5yqzRJXs3RnmZcMDr/q0x6Bg==")</code> </pre> <br>  7. Le serveur envoie la transaction d'invocation au contrat intelligent (diffusion InvocationTx).  La transaction contient un appel à la fonction de retrait générée (gameId, rsaSign): <br><br><img src="https://habrastorage.org/webt/5s/qv/a9/5sqva9dije7xwufaactablctnic.png"><br><br>  La fonction contient l' <b>identifiant de jeu du</b> nouveau jeu et le résultat de la signature RSA de l'identifiant unique avec une clé privée.  Le résultat de la signature est inchangé. <br><br>  <i>Qu'est-ce que cela signifie?</i> <br><br>  Nous prenons la même valeur (identifiant de jeu) et lui appliquons la méthode de signature RSA.  Nous obtiendrons toujours le même résultat.  C'est ainsi que fonctionne l'algorithme RSA.  Vous ne pouvez pas manipuler le nombre final, car l'ID du jeu et le résultat de l'utilisation de RSA ne sont pas connus.  Faire correspondre un nombre est également inutile. <br><br>  8. La blockchain accepte la transaction.  Il exécute la fonction de retrait (gameId, rsaSign) <br><br>  9. Dans la fonction de retrait, la <b>fonction GenerateRandInt</b> (gameId, rsaSign) est exportée.  Ceci est un générateur de nombres aléatoires <br><br><br><pre> <code class="scala hljs"># <span class="hljs-meta"><span class="hljs-meta">@return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ... <span class="hljs-number"><span class="hljs-number">100</span></span> func <span class="hljs-type"><span class="hljs-type">GenerateRandInt</span></span> (gameId,rsaSign) = { # verify <span class="hljs-type"><span class="hljs-type">RSA</span></span> signature to proof random let rsaSigValid = rsaVerify (<span class="hljs-type"><span class="hljs-type">SHA256</span></span>, toBytes(gameId), rsaSign, <span class="hljs-type"><span class="hljs-type">RSAPUBLIC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rsaSigValid) then { let rand = (toInt(sha256(rsaSign)) % <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; rand)) then ((<span class="hljs-number"><span class="hljs-number">-1</span></span> * rand) + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (rand + <span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (<span class="hljs-string"><span class="hljs-string">"Invalid RSA signature"</span></span>) }</code> </pre> <br>  <b>rand</b> - et il y a un nombre aléatoire. <br><br>  Tout d'abord, une chaîne est prise, qui est le résultat de la signature RSA de l' <b>ID</b> de <b>jeu avec la</b> clé privée ( <b>rsaSign</b> ).  Il est ensuite haché à l'aide de SHA-256 ( <b>sha256 (rsaSign)</b> ). <br><br>  Nous ne pouvons pas prédire le résultat de la signature et du hachage ultérieur.  Par conséquent, il est impossible d'influencer la génération d'un nombre aléatoire.  Pour obtenir un nombre dans une certaine plage (par exemple, de 1 à 100), la fonction de conversion toInt et% 100 est utilisée (analogique vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod</a> ). <br><br>  Au début de l'article, nous avons mentionné la fonction <b>rsaVerify ()</b> , qui vous permet de vérifier la validité des signatures RSA avec une clé privée par clé publique.  Voici la partie GenerateRandInt (gameId, rsaSign): <br><br><pre> <code class="plaintext hljs">rsaVerify (SHA256, toBytes(gameId), rsaSign, RSAPUBLIC)</code> </pre> <br>  La clé publique RSAPUBLIC et la chaîne rsaSign sont transmises à l'entrée.  La validité de la signature est vérifiée.  Un numéro est généré si la vérification réussit.  Sinon, le système considère que la signature n'est pas valide (signature RSA non valide). <br><br>  Le serveur doit signer l'id du jeu avec la clé privée et envoyer une signature Rsa valide dans 2880 blocs.  Le paramètre est configuré lors du déploiement d'un contrat intelligent.  Si rien ne se passe pendant le temps imparti, l'utilisateur gagne.  Dans ce cas, le prix doit être envoyé à votre adresse vous-même.  Il s'avère que le serveur n'est "pas rentable de tricher", car cela entraîne une perte.  Voici un exemple. <br><br><img src="https://habrastorage.org/webt/y6/bt/q_/y6btq_yqv9ypdejhwe3d-mhnbfi.png"><br><br>  L'utilisateur joue au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rouleau de dés</a> .  J'ai choisi 2 faces sur 6 du cube, le pari est de 14 ONDES.  Si le serveur n'envoie pas de signature RSA valide sur le contrat intelligent dans le délai défini (2880 blocs), l'utilisateur prendra 34,44 ONDES. <br><br>  Pour générer des nombres dans les jeux, nous utilisons l'oracle - un système externe non bloquant.  Le serveur implémente la signature RSA de l'ID de jeu.  Le contrat intelligent vérifie la validité de la signature et détermine le gagnant.  Si le serveur n'a rien envoyé, l'utilisateur gagne automatiquement. <br><br>  La méthode décrite garantit que la manipulation est techniquement impossible.  Tous les jeux Tradisys utilisent un algorithme, ils sont donc honnêtes et transparents.  Tout se prête à l'examen du public.  Cela garantit l'honnêteté. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464357/">https://habr.com/ru/post/fr464357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464345/index.html">5 raisons d'ouvrir une startup informatique en Allemagne</a></li>
<li><a href="../fr464347/index.html">Modules d'injection de dépendances, JavaScript et ES6</a></li>
<li><a href="../fr464351/index.html">Caméras IP PoE, exigences spéciales et fonctionnement sans problème - tout rassembler</a></li>
<li><a href="../fr464353/index.html">1C: ERP VS 1C: KA 2.0. Que devraient choisir les fabricants d'aliments?</a></li>
<li><a href="../fr464355/index.html">Comment une image est rendue dans Shadow Fight 3</a></li>
<li><a href="../fr464359/index.html">Fonctionnalités de test des applications Web mobiles</a></li>
<li><a href="../fr464361/index.html">Intel Quartz Canyon - NUC pour les professionnels</a></li>
<li><a href="../fr464365/index.html">Security Week 34: vulnérabilités extraordinaires dans Windows</a></li>
<li><a href="../fr464367/index.html">Et une autre escalade des privilèges locaux du client Steam Windows 0day</a></li>
<li><a href="../fr464369/index.html">Quel bloqueur utilisez-vous? Résultats</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>