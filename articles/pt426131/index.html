<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëª üëãüèº ‚õ¥Ô∏è Fa√ßa o download da configura√ß√£o para FPGA via USB ou desmonte o FTDI MPSSE ‚óΩÔ∏è üìÅ üë∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na vida de cada gaveta, chega um momento em que voc√™ deseja gravar seu pr√≥prio carregador do arquivo de configura√ß√£o no FPGA. Eu tive que participar d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fa√ßa o download da configura√ß√£o para FPGA via USB ou desmonte o FTDI MPSSE</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426131/"><img src="https://habrastorage.org/webt/dx/i7/px/dxi7pxs820_gc9p_q_1m6zoaakm.jpeg"><br><br>  Na vida de cada gaveta, chega um momento em que voc√™ deseja gravar seu pr√≥prio carregador do arquivo de configura√ß√£o no FPGA.  Eu tive que participar do desenvolvimento de um estande de treinamento para o departamento de uma universidade t√©cnica.  O estande foi projetado para estudar o processamento de sinal digital, embora isso n√£o seja de particular import√¢ncia na estrutura deste artigo.  E o significado √© que o FPGA (Altera Cyclone IV) est√° no centro do estande, no qual os alunos colecionam todos os tipos de esquemas de DSP, conforme concebido pelo autor do estande.  O suporte est√° conectado ao computador via USB.  Voc√™ precisa baixar o FPGA do computador via USB. <br><p>  Foi tomada a decis√£o de conectar-se a um PC usando o FTDI em sua encarna√ß√£o de canal duplo - FT2232H.  Um canal ser√° usado para a configura√ß√£o FPGA, o outro pode ser usado para a troca FIFO de alta velocidade. </p><a name="habracut"></a><br><p>  O FTDI possui uma placa de depura√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MORPH-IC-II</a> , na qual o FPGA do Cyclone II √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">piscado</a> via USB.  Conceitos de dom√≠nio p√∫blico.  O c√≥digo fonte do carregador de inicializa√ß√£o est√° parcialmente aberto: o pr√≥prio carregador de inicializa√ß√£o est√° dispon√≠vel, no entanto, toda a l√≥gica de trabalhar com o FTDI √© movida para uma biblioteca privada e n√£o pode ser modificada.  Na verdade, originalmente planejei usar esse gerenciador de inicializa√ß√£o no meu projeto ou, em casos extremos, criar meu shell com base na dll deles.  O firmware √© carregado no FPGA no modo serial passivo (serial passivo - PS), o FTDI opera no modo MPSSE.  Na placa de ensaio, o desempenho da solu√ß√£o MORPH-IC-II foi totalmente confirmado, mas o problema, como costuma acontecer, n√£o veio de onde.  Verificou-se que, durante a opera√ß√£o da dll MORPH-IC-II, todos os dispositivos FTDI conectados s√£o bloqueados e, como parte do complexo de treinamento, existem mais dois dispositivos com conversores semelhantes: um gerador e um analisador de sinais.  O trabalho simult√¢neo com eles n√£o √© poss√≠vel.  Maldito estranho e irritante. </p><br><p>  Um caso semelhante foi implementado pelos caras do rover Mars: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">programador USB JTAG MBFTDI</a> .  O FTDI tamb√©m √© usado no modo MPSSE, mas, diferentemente do MORPH-IC-II, as opera√ß√µes do FPGA s√£o executadas no modo JTAG.  As fontes est√£o dispon√≠veis gratuitamente, mas n√£o encontrei uma indica√ß√£o clara de seu status (licen√ßa).  Portanto, para us√°-los em um projeto comercial, minha m√£o n√£o se levantou. </p><br><p>  Corrigirei esse erro, tudo o que ser√° apresentado na estrutura deste artigo ser√° publicado em um reposit√≥rio aberto sob a licen√ßa BSD. </p><br><h2 id="zagruzka-fayla-konfiguracii-v-mikroshemu-plis">  Baixe o arquivo de configura√ß√£o para o chip FPGA </h2><br><p>  Primeiro de tudo, voc√™ deve lidar com o modo de inicializa√ß√£o do FPGA.  Para aqueles que est√£o come√ßando a se familiarizar com o assunto, farei uma pequena excurs√£o.  Embora os FPGAs da Altera (Intel) da fam√≠lia Cyclone IV E estejam instalados na minha placa, os m√©todos de carregamento s√£o semelhantes para todo o grupo Cyclone FPGA, e h√° uma suspeita de que, de uma forma ou de outra, sejam adequados para muitas outras fam√≠lias. </p><br><p>  Esse tipo de FPGA usa SRAM vol√°til para armazenar dados de configura√ß√£o.  Esses dados de configura√ß√£o determinam a funcionalidade do dispositivo resultante.  No jarg√£o profissional, esses dados costumam ser chamados de "firmware".  Assim, o firmware √© armazenado em uma RAM especial e cada vez que o dispositivo √© ligado, ele deve ser carregado no chip FPGA.  Existem v√°rias maneiras (esquemas de configura√ß√£o) pelas quais o firmware pode ser carregado na SRAM (a lista √© relevante para o Cyclone IV E): </p><br><ol><li>  Serial ativo (AS). </li><li>  Paralelo ativo (AP) </li><li>  S√©rie passiva (PS) </li><li>  Paralelo passivo r√°pido (FPP). </li><li>  JTAG. </li></ol><br><p>  A escolha de um modo de inicializa√ß√£o espec√≠fico √© realizada usando os terminais externos do FPGA (grupo MSEL).  O modo JTAG est√° sempre dispon√≠vel.  O modo ativo implica que, quando a energia √© aplicada, o FPGA l√™ independentemente os dados da mem√≥ria externa (serial ou paralela).  No modo passivo, o FPGA aguarda um meio externo transferir proativamente os dados de configura√ß√£o para ele.  Esses esquemas se encaixam bem no conceito de mestre (mestre) - escravo (escravo).  Nos modos ativos, o FPGA atua como mestre e, nos modos passivos, como escravo. </p><br><p>  Nesse problema, n√£o √© o FPGA, mas o usu√°rio deve decidir quando o firmware deve ser atualizado, portanto o modo de inicializa√ß√£o deve ser passivo.  E para salvar as pernas do chip, escolhemos uma interface serial.  O modo serial passivo (PS) e o JTAG s√£o adequados aqui.  A l√≥gica do JTAG √© um pouco mais complicada, ent√£o vamos nos concentrar na primeira op√ß√£o. <br>  A figura abaixo mostra o esquema de conex√£o do FPGA a um controlador externo para download no modo PS. </p><br><img width="400" src="https://habrastorage.org/webt/q-/rj/pe/q-rjpeqe5y8ojlu8ywedoejklxq.png"><br><p>  Para iniciar a configura√ß√£o, o mestre externo deve gerar uma transi√ß√£o de baixa para alta na linha <em>nCONFIG</em> .  Assim que o FPGA estiver pronto para receber dados, ele formar√° um alto n√≠vel na linha <em>nSTATUS</em> .  Depois disso, o mestre pode come√ßar a transmitir dados na linha <em>DATA [0]</em> e o rel√≥gio correspondente pulsa na linha <em>DCLK</em> .  Os dados devem ser transmitidos ao dispositivo de destino at√© que um n√≠vel alto seja estabelecido na linha <em>CONF_DONE</em> (ou os dados n√£o terminam) e o FPGA alterna para o estado de inicializa√ß√£o.  Deve-se observar que, depois que <em>CONF_DONE √©</em> definido como um, mais dois pulsos de clock devem ser aplicados para que a inicializa√ß√£o do FPGA comece. </p><br><p>  Os dados s√£o transmitidos pelo encaminhamento de bit menos significativo ( <abbr title="Bit menos significativo">LSB</abbr> ), ou seja, se o arquivo de configura√ß√£o contiver a sequ√™ncia 02 1B EE 01 FA (como o exemplo est√° no Manual), a sequ√™ncia deve ser formada na linha de dados: </p><br><pre><code class="hljs powershell"><span class="hljs-number"><span class="hljs-number">0100</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">1101</span></span><span class="hljs-literal"><span class="hljs-literal">-1000</span></span> <span class="hljs-number"><span class="hljs-number">0111</span></span><span class="hljs-literal"><span class="hljs-literal">-0111</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">0101</span></span><span class="hljs-literal"><span class="hljs-literal">-1111</span></span></code> </pre> <br><p>  Assim, apenas cinco linhas s√£o usadas: linhas <em>DATA [0]</em> e <em>DCLK</em> para transmiss√£o serial, <em>linhas nCONFIG</em> , <em>nSTATUS</em> , <em>CONF_DONE</em> para controle. <br>  Na sua ess√™ncia, o modo PS nada mais √© do que SPI com manipula√ß√£o adicional de sinalizadores. <br>  A taxa de transfer√™ncia de dados deve ser menor que a frequ√™ncia m√°xima indicada na documenta√ß√£o; para a s√©rie Cyclone IV E usada no projeto, √© de 66 MHz. </p><br><p>  A frequ√™ncia m√≠nima de transmiss√£o n√£o existe, teoricamente √© poss√≠vel suspender a configura√ß√£o por tempo indeterminado.  Isso oferece excelentes oportunidades para a depura√ß√£o passo a passo com a participa√ß√£o de um oscilosc√≥pio, que certamente usaremos. </p><br><p>  A figura abaixo mostra o diagrama de tempo da interface com os tempos mais significativos. </p><br><img width="720" src="https://habrastorage.org/webt/54/et/uy/54etuy0yva1est_qtdqp9yopqj8.png"><br><h2 id="hitryy-zver-mpsse">  Sly Beast MPSSE </h2><br><p>  Considere a opera√ß√£o do FTDI no modo MPSSE.  O modo MPSSE (Multi-Protocol Synchronous Serial Engine), na minha opini√£o, √© uma tentativa mais ou menos bem-sucedida de criar um certo designer de interface serial, para dar ao desenvolvedor a oportunidade de implementar protocolos de transfer√™ncia de dados generalizados, como SPI, I2C, JTAG, 1-wire e muitos outros baseados neles. </p><br><p>  Atualmente, o modo est√° dispon√≠vel para microcircuitos: FT232H, FT2232D, FT2232H, FT4232H.  No meu projeto eu uso o FT2232H, ent√£o estamos falando mais sobre isso.  Para o modo MPSSE, 16 pernas s√£o alocadas, divididas em dois bytes: o L mais baixo e o H. mais alto. Cada byte pode ser lido ou definido.  As quatro pernas inferiores do byte L t√™m fun√ß√µes especiais - a transmiss√£o de dados seriais pode ocorrer atrav√©s deles.  Cada perna pode ser configurada como uma entrada ou sa√≠da, um valor padr√£o pode ser definido para a sa√≠da.  Para transmiss√£o sequencial, a ordem dos bits ( <abbr title="Bit mais significativo">MSB</abbr> / <abbr title="Bit menos significativo">LSB</abbr> ), o comprimento da palavra transmitida, a frequ√™ncia dos pulsos de rel√≥gio, a sincroniza√ß√£o frente - frente (Rising) ou traseira (Falling), voc√™ pode optar por transmitir apenas pulsos de rel√≥gio sem dados ou selecionar o rel√≥gio trif√°sico (relevante para I2C) e muito mais. </p><br><p>  Passar sem problemas para a programa√ß√£o.  Existem duas maneiras alternativas de intera√ß√£o do software com os chips FTDI: o primeiro, vamos chamar de cl√°ssico, neste caso, quando conectado a uma porta USB, o chip no sistema √© definido como uma porta serial virtual (COM), o sistema operacional usa o driver VCP (porta virtual COM).  Toda a programa√ß√£o adicional n√£o difere da programa√ß√£o da porta COM cl√°ssica: aberta - transmitida / contada - fechada.  E isso √© verdade para v√°rios sistemas operacionais, incluindo Linux e Mac OS.  No entanto, com essa abordagem, n√£o ser√° poss√≠vel realizar todos os recursos do controlador FTDI - o chip funcionar√° como um adaptador USB-UART.  O segundo m√©todo √© fornecido pela biblioteca propriet√°ria do FTD2XX; essa interface fornece fun√ß√µes especiais que n√£o est√£o dispon√≠veis na API da porta COM padr√£o; em particular, √© poss√≠vel configurar e usar modos operacionais especiais, como MPSSE, 245 FIFO, Bit-bang.  A biblioteca da API do FTD2XX est√° bem documentada pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia do Programador de Desenvolvimento de Aplicativos de Software D2XX</a> , amplamente conhecido por muito tempo em c√≠rculos estreitos.  E sim, o FTD2XX tamb√©m est√° dispon√≠vel para v√°rios sistemas operacionais. </p><br><p>  Os desenvolvedores de FTDI foram confrontados com a tarefa de integrar o relativamente novo MPSSE ao modelo de intera√ß√£o de software D2XX existente.  E eles conseguiram, para trabalhar no modo MPSSE, o mesmo conjunto de fun√ß√µes √© usado como para outros modos "cl√°ssicos", a mesma biblioteca FTD2XX API √© usada. </p><br><p>  Em resumo, o algoritmo para operar no modo MPSSE pode ser descrito da seguinte maneira: </p><br><ol><li>  Encontre o dispositivo no sistema e abra-o. </li><li>  Inicialize o chip e coloque-o no modo MPSSE. </li><li>  Defina o modo de opera√ß√£o do MPSEE. </li><li>  Trabalho direto com dados: transmita, receba, gerencie GPIO - implementamos o protocolo de troca de destino. </li><li>  Feche o dispositivo </li></ol><br><h2 id="pishem-zagruzchik">  Escrevendo um gerenciador de inicializa√ß√£o </h2><br><p>  Vamos direto √† parte pr√°tica.  Nas minhas experi√™ncias, usarei a vers√£o Eclipse do Oxygen.3a Release (4.7.3a) como IDE e o mingw32-gcc (6.3.0) como compilador.  Sistema operacional Win7. </p><br><p>  No site da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FTDI</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">baixamos</a> a vers√£o atual mais recente do driver para o nosso sistema operacional.  No arquivo, encontramos o arquivo de cabe√ßalho ftd2xx.h com uma descri√ß√£o de todas as fun√ß√µes da API.  A API em si √© implementada como ftd2xx.dll, mas deixaremos a importa√ß√£o din√¢mica para mais tarde e usaremos o link est√°tico: precisamos do arquivo de biblioteca ftd2xx.lib.  Para o meu caso, o ftd2xx.lib est√° no diret√≥rio i386. </p><br><p>  No Eclipse, crie um novo projeto C.  A cria√ß√£o de um <em>makefile</em> pode ser confi√°vel com um IDE.  Nas configura√ß√µes do vinculador, especifique o caminho e o nome da biblioteca ftd2xx (transferi os arquivos necess√°rios para o diret√≥rio do projeto na pasta ftdi).  N√£o vou me concentrar nos recursos da configura√ß√£o de um projeto para o Eclipse, pois suspeito que a maioria deles use outros ambientes e compiladores para a programa√ß√£o do Win. </p><br><h3 id="punkt-pervyy-nayti-devays-i-otkryt-ego">  Ponto um.  Encontre um dispositivo e abra-o </h3><br><p>  A API do FTD2XX permite abrir o chip usando uma ou outra informa√ß√£o conhecida sobre ele.  Este pode ser o n√∫mero de s√©rie no sistema: o primeiro chip FTDI conectado receber√° o n√∫mero 0, o pr√≥ximo 1 e assim por diante.  O n√∫mero no sistema √© determinado pela ordem em que os microcircuitos s√£o conectados, para dizer o m√≠nimo, isso nem sempre √© conveniente.  Para abrir o chip por n√∫mero, √© <code>FT_Open</code> fun√ß√£o <code>FT_Open</code> .  Voc√™ pode abrir o chip por seu n√∫mero de s√©rie ( <code>FT_OPEN_BY_SERIAL_NUMBER</code> ), descri√ß√£o ( <code>FT_OPEN_BY_DESCRIPTION</code> ) ou por local ( <code>FT_OPEN_BY_LOCATION</code> ); para isso, a fun√ß√£o <code>FT_OpenEx</code> √© <code>FT_OpenEx</code> .  O n√∫mero de s√©rie e a descri√ß√£o s√£o armazenados na mem√≥ria interna do chip e podem ser gravados durante o fabrico do dispositivo com o FTDI instalado.  A descri√ß√£o, como regra, caracteriza o tipo de dispositivo ou fam√≠lia e o n√∫mero de s√©rie deve ser exclusivo para cada produto.  Portanto, a maneira mais conveniente de identificar dispositivos suportados pelo programa em desenvolvimento √© sua descri√ß√£o.  Abriremos o chip FTDI de acordo com a descri√ß√£o (descritor).  De fato, se conhecemos inicialmente a linha de descritores de chips, n√£o precisamos procurar o dispositivo no sistema; no entanto, como um experimento, exibiremos todos os dispositivos conectados ao computador com FTDI.  Usando a fun√ß√£o <code>FT_CreateDeviceInfoList</code> , criaremos uma lista detalhada de chips conectados e, usando a fun√ß√£o <code>FT_GetDeviceInfoList</code> , a consideraremos. </p><br><div class="spoiler">  <b class="spoiler_title">Lista de dispositivos conectados.</b>  <b class="spoiler_title">Listagem:</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus == FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Number of devices is %d\n"</span></span>,numDevs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numDevs == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allocate storage for list based on numDevs devInfo = (FT_DEVICE_LIST_INFO_NODE*)malloc(sizeof(FT_DEVICE_LIST_INFO_NODE)*numDevs); ftStatus = FT_GetDeviceInfoList(devInfo,&amp;numDevs); if (ftStatus == FT_OK) for (int i = 0; i &lt; numDevs; i++) { printf("Dev %d:\n",i); printf(" Flags=0x%x\n",devInfo[i].Flags); printf(" Type=0x%x\n",devInfo[i].Type); printf(" ID=0x%x\n",devInfo[i].ID); printf(" LocId=0x%x\n",devInfo[i].LocId); printf(" SerialNumber=%s\n",devInfo[i].SerialNumber); printf(" Description=%s\n",devInfo[i].Description); }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Welcome my zoo</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">D:\workspace\ftdi-mpsse-ps\<span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>&gt;ftdi-mpsse-ps.exe Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> devices <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> Dev <span class="hljs-number"><span class="hljs-number">0</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x5</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036001</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x214</span></span> SerialNumber = AI043NNV Description = FT232R USB UART Dev <span class="hljs-number"><span class="hljs-number">1</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2121</span></span> SerialNumber = L731T70OA Description = LESO7 A Dev <span class="hljs-number"><span class="hljs-number">2</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2122</span></span> SerialNumber = L731T70OB Description = LESO7 B Dev <span class="hljs-number"><span class="hljs-number">3</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x8</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036014</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x213</span></span> SerialNumber = FTYZ92L6 Description = LESO4<span class="hljs-number"><span class="hljs-number">.1</span></span>_ER</code> </pre> </div></div><br><p>  Tr√™s dispositivos com chips FTDI est√£o conectados ao meu PC: FT232RL (tipo 0x5), FT2232H (tipo 0x6) e FT232H (tepe 0x8).  O chip FT2232H no sistema foi exibido como dois dispositivos independentes (Dev 1 e Dev 2).  A interface do FPGA PS est√° conectada ao Dev 2, e seu descritor √© "LESO7 B".  Abra: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Open a device with device description "LESO7 B" ftStatus = FT_OpenEx("LESO7 B", FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); if (ftStatus != FT_OK) { printf ("pen failure\r\n"); return -1; }</span></span></code> </pre> <br><p>  A maioria das fun√ß√µes da API retorna o status de sua chamada do tipo <code>FT_STATUS</code> , todos os valores poss√≠veis s√£o descritos como enumera√ß√£o no arquivo de cabe√ßalho.  Existem muitos deles, mas √© suficiente saber que o valor <code>FT_OK</code> √© a aus√™ncia de erro, todos os outros valores s√£o c√≥digos de erro.  Um bom estilo de programa√ß√£o √© verificar o valor do status ap√≥s cada chamada para a fun√ß√£o API. </p><br><p>  Se o dispositivo foi aberto com √™xito, na vari√°vel <code>ftHandle</code> aparece algum valor diferente de zero, algum descritor de arquivo equivalente, usado ao trabalhar com arquivos.  O identificador resultante estabelece uma conex√£o com a interface de hardware e deve ser usado ao chamar todas as fun√ß√µes da biblioteca que requerem acesso ao chip. <br>  Para confirmar na pr√°tica a operacionalidade do sistema para o est√°gio atual, devemos prosseguir imediatamente para a etapa cinco do nosso algoritmo. </p><br><p>  Depois de terminar de trabalhar com o chip, voc√™ precisa fech√°-lo.  Para fazer isso, use a fun√ß√£o <code>FT_Close</code> : </p><br><pre> <code class="cpp hljs">FT_Close(ftHandle);</code> </pre> <br><h3 id="punkt-2-inicializiruem-chip-i-vklyuchaem-mpsse">  Ponto 2. Inicialize o chip e ligue o MPSSE </h3><br><p>  A configura√ß√£o √© t√≠pica para a maioria dos modos e est√° bem descrita na documenta√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AN_135 FTDI MPSSE Basics</a> . </p><br><ol><li>  Realizamos uma redefini√ß√£o (rezet) do chip.  Fun√ß√£o <code>FT_ResetDevice</code> . </li><li>  Caso haja algum lixo no buffer de recebimento, n√≥s o limpamos.  Fun√ß√£o <code>FT_Purge</code> . </li><li>  Ajuste o tamanho dos buffers para leitura e grava√ß√£o.  Fun√ß√£o <code>FT_SetUSBParameters</code> . </li><li>  Desative a paridade.  <code>FT_SetChars</code> . </li><li>  Estabelecemos tempos limite para leitura e escrita.  Por padr√£o, os tempos limite est√£o desativados, ative o tempo limite da transmiss√£o.  <code>FT_SetTimeouts</code> . </li><li>  Configuramos o tempo de espera para enviar um pacote do chip para o host.  Por padr√£o, 16 ms, acelere para 1 ms.  <code>FT_SetLatencyTimer</code> . </li><li>  Ative o controle de fluxo para sincronizar solicita√ß√µes recebidas.  <code>FT_SetFlowControl</code> . </li><li>  Tudo est√° pronto para ativar o modo MPSSE.  Redefina o controlador MPSSE.  Usamos a fun√ß√£o <code>FT_SetBitMode</code> , defina o modo como 0 (mode = 0, mask = 0). </li><li>  Ligue o modo MPSSE.  Fun√ß√£o <code>FT_SetBitMode</code> - mode = 2, mask = 0. </li></ol><br><p>  <code>MPSSE_open</code> e configuramos o chip na fun√ß√£o <code>MPSSE_open</code> , como par√¢metro, passamos uma linha com a al√ßa do dispositivo a ser aberto: </p><br><div class="spoiler">  <b class="spoiler_title">Listagem MPSSE_open</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_open</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *description)</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; ftStatus = FT_OpenEx(description, FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus != FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open failure\r\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FT_DEVICE_NOT_OPENED; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open OK, %d\r\n"</span></span>, ftHandle); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nConfiguring port for MPSSE use...\n"</span></span>); ftStatus |= FT_ResetDevice(ftHandle); <span class="hljs-comment"><span class="hljs-comment">//Purge USB receive buffer first by reading out all old data from FT2232H receive buff: ftStatus |= FT_Purge(ftHandle, FT_PURGE_RX); //Set USB request transfer sizes to 64K: ftStatus |= FT_SetUSBParameters(ftHandle, 65536, 65536); //Disable event and error characters: ftStatus |= FT_SetChars(ftHandle, 0, 0, 0, 0); //Sets the read and write timeouts in milliseconds: ftStatus |= FT_SetTimeouts(ftHandle, 0, 5000); //Set the latency timer to 1mS (default is 16mS): ftStatus |= FT_SetLatencyTimer(ftHandle, 1); //Turn on flow control to synchronize IN requests: ftStatus |= FT_SetFlowControl(ftHandle, FT_FLOW_RTS_CTS, 0x00, 0x00); //Reset controller: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_RESET); //Enable MPSSE mode: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_MPSSE); if (ftStatus != FT_OK) { printf("Error in initializing the MPSSE %d\n", ftStatus); return FT_OTHER_ERROR; } Sleep(50); // Wait for all the USB stuff to complete and work return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-3-nastroim-rezhim-raboty-mpsee">  Item 3. Configure o modo de opera√ß√£o MPSEE </h3><br><p>  Na verdade, nesta fase, o processador MPSSE est√° ativado e pronto para receber comandos.  Comandos s√£o sequ√™ncias de bytes, cujo primeiro byte √© "c√≥digo operacional", seguido pelos par√¢metros do comando.  O comando pode n√£o ter par√¢metros e consistir em um "c√≥digo operacional".  Os comandos s√£o transmitidos usando a fun√ß√£o <code>FT_Write</code> , uma resposta do processador MPSSE pode ser obtida usando a fun√ß√£o <code>FT_Read</code> . </p><br><p>  Ap√≥s o envio de cada comando, √© √∫til ler a resposta do processador, pois, no caso de um comando incorreto, a resposta pode conter uma mensagem de erro - o caractere 0xFA.  O mecanismo "comando inv√°lido - resposta 0xFA" pode ser usado para sincronizar o programa de aplicativo com o processador MPSSE.  Se tudo estiver correto, o chip retornar√° o caractere 0xFA em um comando deliberadamente incorreto.  Os c√≥digos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">operacionais</a> s√£o descritos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Processador de comandos para o modo de emula√ß√£o de barramento de host MPSSE e MCU</a> . <br>  A configura√ß√£o do MPSSE se resume a definir a taxa de dados, a dire√ß√£o e os estados iniciais das linhas de E / S. <br>  Considere definir a taxa de dados do processador MPSSE.  As configura√ß√µes de chips com suporte apenas para o modo de velocidade total (FT2232 <strong>D</strong> ) e chips com alta velocidade (FT2232 <strong>H</strong> , FT232H, FT4232H) s√£o um pouco diferentes.  O FT2232D herdado usa um rel√≥gio de 12MHz, enquanto os modernos usam 60MHz.  Da√≠ a f√≥rmula para calcular a taxa de transfer√™ncia de dados: </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>V</mi><mi>e</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>i</mi><mi>d</mi><mi>a</mi><mi>d</mi><mi>e</mi><mi>d</mi><mi>o</mi><mi>s</mi><mi>d</mi><mi>a</mi><mi>d</mi><mi>o</mi><mi>s</mi><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow></msub></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mi>D</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>o</mi><mi>r</mi><mo stretchy=&quot;false&quot;>)</mo><mtext>&amp;#xA0;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><mn>2</mn></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="52.86ex" height="2.66ex" viewBox="0 -832 22759 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-56" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-65" x="769" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-6C" x="1236" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-6F" x="1534" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-63" x="2020" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-69" x="2453" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-64" x="2799" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-61" x="3322" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-64" x="3852" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-65" x="4375" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-64" x="4842" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-6F" x="5365" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-73" x="5851" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-64" x="6320" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-61" x="6844" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-64" x="7373" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-6F" x="7897" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-73" x="8382" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMAIN-3D" x="9129" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-66" x="10436" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-72" x="10986" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-61" x="11438" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-63" x="11967" y="0"></use><g transform="translate(12401,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-66" x="0" y="0"></use><g transform="translate(490,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-63" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-6F" x="433" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-72" x="919" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-65" x="1370" y="0"></use></g></g><g transform="translate(14290,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMAIN-31" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMAIN-2B" x="1112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-44" x="2112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-69" x="2941" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-76" x="3286" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-69" x="3772" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-73" x="4117" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-6F" x="4587" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-72" x="5072" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMAIN-29" x="5524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-63" x="6163" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-64" x="6597" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-6F" x="7120" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMATHI-74" x="7606" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhlW5FbLBhNbcX-splUTGbSXnlMXA#MJMAIN-32" x="7967" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>V</mi><mi>e</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>i</mi><mi>d</mi><mi>a</mi><mi>d</mi><mi>e</mi><mi>d</mi><mi>o</mi><mi>s</mi><mi>d</mi><mi>a</mi><mi>d</mi><mi>o</mi><mi>s</mi><mo>=</mo><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><msub><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow></msub></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>D</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>s</mi><mi>o</mi><mi>r</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><mn>2</mn></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> Velocidade dos dados = \ frac {f_ {core}} {(1 + Divisor) \ cdot 2} </script></p><br><p>  onde <em>f <sub>core</sub></em> √© a frequ√™ncia <em><sub>principal</sub></em> do FTDI, o <em>Divisor</em> √© um divisor de dois bytes que, de fato, define a frequ√™ncia do rel√≥gio de dados. <br>  Como resultado, se o divisor for igual a zero, a taxa m√°xima de transfer√™ncia de dados ser√° de 30 Mbps e a taxa m√≠nima de transfer√™ncia de dados ser√° de 65535 a 458 bits / s. <br>  Confiaremos o c√°lculo do divisor ao pr√©-processador.  A macro retorna o divisor: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FCORE 60000000ul #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV(data_speed) ((FCORE/(2*data_speed)) -1)</span></span></code> </pre> <br><p>  E essas duas macros retornam os bytes alto e baixo do divisor, respectivamente: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_H(data_speed) ((MPSSE_DATA_SPEED_DIV(data_speed)) &gt;&gt; 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_L(data_speed) \ (MPSSE_DATA_SPEED_DIV(data_speed) - (MPSSE_DATA_SPEED_DIV_H(data_speed)&lt;&lt; 8))</span></span></code> </pre> <br><p>  Al√©m disso, deve-se notar que em chips modernos para compatibilidade com o antigo FT2232D, h√° um divisor adicional de 5, que transforma 60 MHz em 12 MHz.  Esse divisor √© ativado por padr√£o; no nosso caso, deve ser desativado. <br>  Encontramos o c√≥digo operacional correspondente (0x8A) e o comando do capacete para o processador: </p><br><div class="spoiler">  <b class="spoiler_title">Listagem de envio da equipe</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; DWORD dwNumBytesToRead, dwNumBytesSent = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesRead = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x8A</span></span>; ftStatus = FT_Write(ftHandle, byOutputBuffer, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Error\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("dwNumBytesToRead = %d:", dwNumBytesToRead); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK;</span></span></code> </pre> </div></div><br><p>  Como um experimento, em vez do comando real 0x8A, enviaremos o valor 0xFE, que n√£o corresponde a nenhum c√≥digo operacional, a sa√≠da do console: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">dwNumBytesToRead</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>: FAh FEh</code> </pre> <br><p>  O processador retornou dois bytes, o byte de comando incorreto √© 0xFA e o valor desse comando incorreto.  Assim, enviando v√°rios comandos de uma s√≥ vez, podemos n√£o apenas rastrear o fato do erro em si, mas tamb√©m entender em qual equipe esse erro ocorreu. <br>  Para n√£o lidar com "n√∫meros m√°gicos" no futuro, formataremos todos os c√≥digos operacionais na forma de constantes e os colocaremos em um arquivo de cabe√ßalho separado. <br>  Para configurar completamente o modo, voc√™ deve especificar a dire√ß√£o das linhas de E / S e seu valor padr√£o.  Vamos passar para o diagrama de conex√£o.  Para n√£o desordenar um artigo j√° inchado, desenhei um fragmento interessante do esquema: </p><br><img width="500" src="https://habrastorage.org/webt/sc/6g/no/sc6gnoqy5_eyc5lsjpmlqbnl2-m.png"><br><p>  As <em>linhas DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG</em> devem ser configuradas como sa√≠das, as <em>linhas nSTATUS</em> , <em>CONF_DONE</em> como entradas.  Usando o diagrama, determinamos quais estados iniciais as linhas devem ter.  Para maior clareza, a pinagem do circuito est√° resumida na tabela: </p><br><table><thead><tr><th>  Pino FPGA </th><th>  Nome do PIN </th><th>  Pin </th><th>  MPSSE </th><th>  Dire√ß√£o </th><th>  padr√£o </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38. </td><td>  TCK / SK </td><td>  Fora </td><td>  0 0 </td></tr><tr><td>  DADOS [0] </td><td>  BDBUS1 </td><td>  39. </td><td>  TDI / DO </td><td>  Fora </td><td>  1 </td></tr><tr><td>  nCONFIG </td><td>  BDBUS2 </td><td>  40. </td><td>  TDO / DI </td><td>  Fora </td><td>  1 </td></tr><tr><td>  nSTATUS </td><td>  BDBUS3 </td><td>  41. </td><td>  TMS / CS </td><td>  Em </td><td>  1 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  Em </td><td>  1 </td></tr></tbody></table><br><p>  Todas as linhas usadas est√£o localizadas no byte baixo da porta MPSSE.  Para definir o valor, use o c√≥digo op 0x80.  Este comando assume dois argumentos: o primeiro byte ap√≥s o c√≥digo operacional √© o valor bit a bit e o segundo √© a dire√ß√£o (uma √© a porta de sa√≠da, zero √© a porta de entrada). <br>  Como parte da luta contra o "n√∫mero m√°gico", todos os n√∫meros de linha de s√©rie e seus valores padr√£o ser√£o formatados como constantes: </p><br><div class="spoiler">  <b class="spoiler_title">Definir portas</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_DIRECTION (0x07) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DCLK (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DATA0 (1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_CONFIG (2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_STATUS (3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONF_DONE (4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// initial states of the MPSSE interface #define DCLK_DEF (1) #define DATA0_DEF (0) #define N_CONFIG_DEF (1) #define N_STATUS_DEF (1) #define CONF_DONE_DEF (1)</span></span></span></span></code> </pre> </div></div><br><p>  Resta apenas garantir que o loop TDI - TDO esteja desativado (pode ser ativado para teste) e coloc√°-lo em uma fun√ß√£o separada: </p><br><div class="spoiler">  <b class="spoiler_title">Listando a fun√ß√£o MPSSE_setup</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_setup</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Multple commands can be sent to the MPSSE with one FT_Write dwNumBytesToSend = 0; // Start with a fresh index byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_DIVIDER_5; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_ADAPTIVE_CLK; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_3PHASE_CLOCKING; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set TCK frequency // Command to set clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_TCK_DIVISION; // Set ValueL of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_L(DATA_SPEED); // Set 0xValueH of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_H(DATA_SPEED); ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - low byte, both pin directions and output values /* | FPGA pin | Pin Name | Pin | MPSSE | Dir | def | | --------- | -------- | --- | ------ | --- | --- | | DCLK | BDBUS0 | 38 | TCK/SK | Out | 0 | | DATA[0] | BDBUS1 | 39 | TDI/DO | Out | 1 | | nCONFIG | BDBUS2 | 40 | TDO/DI | Out | 1 | | nSTATUS | BDBUS3 | 41 | TMS/CS | In | 1 | | CONF_DONE | BDBUS4 | 43 | GPIOL0 | In | 1 | */ // Configure data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; // Initial state config above: byOutputBuffer[dwNumBytesToSend++] = (DCLK_DEF &lt;&lt; DCLK) | (DATA0_DEF &lt;&lt; DATA0) | (N_CONFIG_DEF &lt;&lt; N_CONFIG) | (N_STATUS_DEF &lt;&lt; N_STATUS) | (CONF_DONE_DEF &lt;&lt; CONF_DONE); // Direction config above: byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Send off the low GPIO config commands dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - high byte, all input, Initial State -- 0. // Send off the high GPIO config commands: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_HIGHBYTE; byOutputBuffer[dwNumBytesToSend++] = 0x00; byOutputBuffer[dwNumBytesToSend++] = 0x00; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Disable loopback: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_LOOP_TDI_TDO; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(2); // Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Unknown error in initializing the MPSSE\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("Error in initializing the MPSSE, bad code:\r\n"); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-4-realizuem-protokol-zagruzki">  Ponto 4. Implementamos o protocolo de carregamento </h3><br><p>  Tudo parece pronto para experimentos pr√°ticos.  Primeiro, verifique se a inicializa√ß√£o foi realizada corretamente, no corpo principal do programa, chame <code>MPSSE_open()</code> e <code>MPSSE_setup()</code> e, antes de fechar o dispositivo ( <code>FT_Close</code> ), colocamos um <code>getchar()</code> vazio <code>getchar()</code> .  Execute o programa e use o oscilosc√≥pio para garantir que todas as linhas PS estejam definidas nos n√≠veis padr√£o.  Alterando o valor desses n√≠veis na inicializa√ß√£o (nada de ruim acontecer√° com o FPGA), garantimos que o processador MPSSE d√™ o resultado desejado como v√°lido - tudo funciona adequadamente e voc√™ pode continuar transferindo dados. <br>  O envio e o recebimento sequenciais de dados s√£o realizados no modo de comando usando o mesmo c√≥digo operacional.  O primeiro byte do comando √© op-code, que determina o tipo de opera√ß√£o, seguido pelo comprimento da sequ√™ncia transmitida ou recebida e, se for uma transmiss√£o, os dados reais.  O processador MPSSE pode enviar e receber dados e tamb√©m faz√™-lo ao mesmo tempo.  A transmiss√£o pode ser o menos significativo bit forward (LSB) ou o mais significativo (MSB).  A transmiss√£o de dados pode ocorrer nas bordas anterior ou posterior dos pulsos do rel√≥gio.  Cada combina√ß√£o de op√ß√µes possui seu pr√≥prio c√≥digo operacional, cada bit do c√≥digo operacional descreve o modo de opera√ß√£o: </p><br><table><thead><tr><th>  Bit </th><th>  Fun√ß√£o </th></tr></thead><tbody><tr><td>  0 0 </td><td>  Sincroniza√ß√£o de grava√ß√£o frontal: 0 - positivo, 1 - negativo </td></tr><tr><td>  1 </td><td>  1 - trabalhar com bytes, 0 - trabalhar com bits </td></tr><tr><td>  2 </td><td>  Borda frontal para leitura: 0 - positivo, 1 - negativo </td></tr><tr><td>  3 </td><td>  Modo de transmiss√£o: 1 - LSB, 0 - MSB primeiro </td></tr><tr><td>  4 </td><td>  Transmiss√£o de dados TDI </td></tr><tr><td>  5 </td><td>  Lendo dados de uma linha TDO </td></tr><tr><td>  6 </td><td>  Transmiss√£o de dados TMS </td></tr><tr><td>  7 </td><td>  Deve ser 0, caso contr√°rio, este √© outro grupo de comandos </td></tr></tbody></table><br><p>  Ao configurar FPGAs de acordo com o esquema PS, os dados s√£o transmitidos na borda principal no modo LSB.     ,   ,    op-code   0001_1000b  0x18   .       ( ,   ),    .    :     .  ,      ,     0,    65536,     65535. ,     .        <code>MPSSE_send</code> . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_send</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BYTE byBuffer[<span class="hljs-number"><span class="hljs-number">65536</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE * buff, DWORD dwBytesToWrite)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesSent, bytes; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Output on rising clock, no input // MSB first, clock a number of bytes out byBuffer[dwNumBytesToSend++] = MPSSE_CMD_LSB_DATA_OUT_BYTES_POS_EDGE; // 0x18 bytes = dwBytesToWrite -1; byBuffer[dwNumBytesToSend++] = (bytes) &amp; 0xFF; // Length L byBuffer[dwNumBytesToSend++] = (bytes &gt;&gt; 8) &amp; 0xFF; // Length H memcpy(&amp;byBuffer[dwNumBytesToSend], buff, dwBytesToWrite); dwNumBytesToSend += dwBytesToWrite; ftStatus = FT_Write(ftHandle, byBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if (ftStatus != FT_OK ) { printf ("ERROR send data\r\n"); return ftStatus; } else if (dwNumBytesSent != dwNumBytesToSend) { printf ("ERROR send data, %d %d\r\n", dwNumBytesSent, dwNumBytesToSend); } return FT_OK; }</span></span></code> </pre> </div></div><br><p>        ‚Äî      65 ,   - ,        op-code   .   <code>byBuffer</code> ,             <code>buff</code> ,  ,      op-code  .    ,     ,         . <br>    ,        ""  ,       25 , ,  ,     1  ( ,     <code>#define DATA_SPEED 1000000ul</code> ).   : </p><br><pre> <code class="hljs objectivec">BYTE byOutputBuffer[] = {<span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x1B</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">MPSSE_send</span></span>(byOutputBuffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(byOutputBuffer));</code> </pre> <br><p>    ( ): <br> <a href=""><img src="https://habrastorage.org/webt/bp/gp/es/bpgpesvsoradzqfecft07bdjk-u.png"></a> </p><br><p>   ‚Äî    <em>DATA[0]</em> ,   ‚Äî <em>DCLK</em> .             .  ,  ,   . </p><br><p>      ,     SPI  ( ).  ,     PS,     .   <em>nCONFIG</em> , <em>nSTATUS</em> , <em>CONF_DONE</em> .   ‚Äî  ,      ,   ‚Äî ,     . </p><br><p>  <code>MPSSE_get_lbyte</code>    ,  ,         . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_get_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_get_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE *lbyte)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_GET_DATA_BITS_LOWBYTE; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, lbyte, dwNumBytesToRead, &amp;dwNumBytesRead); if ((ftStatus != FT_OK) &amp; (dwNumBytesToRead != 1)) { printf("Error read Lbyte\r\n"); return FT_OTHER_ERROR; // Exit with error } return FT_OK; }</span></span></code> </pre> </div></div><br><p>  ,  op-code  ,         . ,     -     ,    ,          .    ,   .     <code>MPSSE_set_lbyte</code> : </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_set_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_set_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE lb, BYTE mask)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], lbyte; FT_STATUS ftStatus; ftStatus = MPSSE_get_lbyte(&amp;lbyte); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ftStatus != FT_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Set to zero the bits selected by the mask: lbyte &amp;= ~mask; // Setting zero is not selected by the mask bits: lb &amp;= mask; lbyte |= lb; dwNumBytesToSend = 0; // Set data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; byOutputBuffer[dwNumBytesToSend++] = lbyte; byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if ((ftStatus != FT_OK) &amp; (dwNumBytesSent != 1)) { printf("Error set Lbyte\r\n"); return FT_OTHER_ERROR; } return FT_OK; }</span></span></code> </pre> </div></div><br><p>   ,     .   :  FTDI;    MPSSE;  rbf-  ,    <em>nCONFIG</em>  ,      <em>N_STATUS</em> ;    rbf-    ;  ,    ,      <em>CONF_DONE</em> .     ,     MPSSE   FTDI       .   ,  <em>nCONFIG</em>      ""  ,     ,        ,     . </p><br><div class="spoiler"> <b class="spoiler_title">  main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; BYTE lowByte; DWORD numDevs; <span class="hljs-comment"><span class="hljs-comment">// create the device information list if ( argv[1] == NULL) { printf ("NO file\r\n"); return -1; } frbf = fopen(argv[1],"rb"); if (frbf == NULL) { printf ("Error open rbf\r\n"); return -1; } ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); if ((numDevs == 0) || (ftStatus != FT_OK)) { printf("Error. FTDI devices not found in the system\r\n"); return -1; } ftStatus = MPSSE_open ("LESO7 B"); if (ftStatus != FT_OK) { printf("Error in MPSSE_open %d\n", ftStatus); EXIT(-1); } MPSSE_setup(); if (ftStatus != FT_OK) { printf("Error in MPSSE_setup %d\n", ftStatus); EXIT(-1); } printf ("nConfig -&gt; 0\r\n"); MPSSE_set_lbyte(0, 1 &lt;&lt; N_CONFIG); printf ("nConfig -&gt; 1\r\n"); MPSSE_set_lbyte(1 &lt;&lt; N_CONFIG, 1 &lt;&lt; N_CONFIG); if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { EXIT(-1); } if (((lowByte &gt;&gt; N_STATUS) &amp; 1) == 0) { printf("Error. FPGA is not responding\r\n"); EXIT(-1); } int i = 0; size_t readBytes = 0; // Send the configuration file: do { readBytes = fread(buff, 1, MPSSE_PCK_SEND_SIZE, frbf); if (MPSSE_send(buff, readBytes) != FT_OK) EXIT(-1); putchar('*'); if (!((++i)%16)) printf("\r\n"); } while (readBytes == MPSSE_PCK_SEND_SIZE); printf("\r\n"); memset(buff, 0x00, sizeof(buff)); MPSSE_send(buff, 1); //        ? printf("Load complete\r\n"); // wait CONF_DONE set // A low-to-high transition on the CONF_DONE pin indicates that the configuration is // complete and initialization of the device can begin. i = 0; do { if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { printf ("Error read CONF_DONE\r\n"); EXIT(-1); } if (i++ &gt; TIMEOUT_CONF_DONE) { printf ("Error CONF_DONE\r\n"); EXIT(-1); } Sleep(2); } while (((lowByte &gt;&gt; CONF_DONE) &amp; 1) == 0); printf("Configuration complete\r\n"); FT_Close(ftHandle); fclose(frbf); }</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exemplo de como iniciar um programa: </font></font></p><br><pre> <code class="hljs pgsql">pen "LESO7 B" OK nConfig -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> nConfig -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ** <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> complete <span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span> complete</code> </pre> </div></div><br><p>    rbf-  .    .       30 /     . <br>      ,        -  JTAG. </p><br><h3 id="materialy-po-teme">    </h3><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FTDI-MPSSE-Altera PS</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> .   .       . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Software Application Development D2XX Programmer's Guide</a> .        FTDI.   API D2XX. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FTDI MPSSE Basics. Application Note AN_135</a> .    .  FTDI MPSSE.      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processador de comando para os modos de emula√ß√£o de barramento de host MPSSE e MCU. </font><font style="vertical-align: inherit;">Nota de aplica√ß√£o AN_108</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Refer√™ncia para c√≥digo operacional. </font><font style="vertical-align: inherit;">De jeito nenhum sem ele.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drivers D2XX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Driver FTDI.</font></font></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426131/">https://habr.com/ru/post/pt426131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426117/index.html">O ombudsman prop√µe bloquear an√∫ncios de produtos para beb√™s potencialmente perigosos</a></li>
<li><a href="../pt426119/index.html">Antiguidades: Ferro Cryptonomicon</a></li>
<li><a href="../pt426121/index.html">MC.exe (compilador de mensagens), rc.exe, link.exe para gerar .dll para EventMessageFile</a></li>
<li><a href="../pt426123/index.html">Aprenda o OpenGL. Li√ß√£o 6.1. PBR ou renderiza√ß√£o fisicamente correta. Teoria</a></li>
<li><a href="../pt426125/index.html">Ester√≥ides de carreira. Elevadores</a></li>
<li><a href="../pt426133/index.html">Apresentando a vers√£o alfa dos snapshots de volume no Kubernetes</a></li>
<li><a href="../pt426135/index.html">Nuvem privada para a Internet das Coisas</a></li>
<li><a href="../pt426137/index.html">Era da Honestidade</a></li>
<li><a href="../pt426141/index.html">Red Hat substitui Docker por Podman</a></li>
<li><a href="../pt426143/index.html">Anima√ß√£o 3D - v√≠deo ou interativa?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>