<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ––ğŸ¿ ğŸ§ğŸ¾ ğŸš£ğŸ¼ Manajemen memori python ğŸ‘‹ğŸ¿ ğŸ’° ğŸ‘¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernahkah Anda bertanya-tanya bagaimana data Anda bekerja dengan terlihat di perut Python? Tentang bagaimana variabel dibuat dan disimpan dalam memori...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manajemen memori python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441568/">  Pernahkah Anda bertanya-tanya bagaimana data Anda bekerja dengan terlihat di perut Python?  Tentang bagaimana variabel dibuat dan disimpan dalam memori?  Bagaimana dan kapan mereka dihapus?  Materi, terjemahan yang kami terbitkan, dikhususkan untuk meneliti kedalaman Python, di mana kami akan mencoba mencari tahu fitur-fitur manajemen memori dalam bahasa ini.  Setelah mempelajari artikel ini, Anda akan memahami bagaimana mekanisme komputer tingkat rendah bekerja, terutama yang terkait dengan memori.  Anda akan memahami bagaimana Python mengabstraksi operasi tingkat rendah dan bagaimana ia mengelola memori. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ok/qc/59/okqc59rnficniaz3pfcaaae5onc.jpeg"></a> <br><br>  Mengetahui apa yang terjadi dengan Python akan memungkinkan Anda untuk lebih memahami beberapa perilaku bahasa ini.  Saya harap, ini akan memberi Anda kesempatan untuk menghargai pekerjaan luar biasa yang sedang dilakukan di dalam implementasi bahasa yang Anda gunakan sehingga program Anda bekerja persis seperti yang Anda butuhkan. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Memori adalah buku kosong</font> </h2><br>  Memori komputer, pada awal bekerja dengannya, dapat direpresentasikan dalam bentuk buku kosong yang dimaksudkan untuk cerita pendek.  Meskipun tidak ada apa-apa di halamannya, tetapi segera penulis cerita akan muncul, masing-masing ingin menulis kisahnya sendiri di buku ini. <br><br>  Karena satu cerita tidak dapat ditulis di atas yang lain, penulis perlu berhati-hati tentang halaman buku yang mereka tulis.  Sebelum menulis apa pun, mereka berkonsultasi dengan pemimpin redaksi.  Dia memutuskan di mana tepatnya penulis dapat merekam cerita. <br><br>  Karena buku yang kita bicarakan sudah ada sejak lama, banyak cerita di dalamnya sudah ketinggalan jaman.  Jika tidak ada yang membaca cerita atau menyebutkannya dalam karya-karya mereka, cerita ini dihapus dari buku, membuat ruang untuk cerita baru. <br><br>  Secara umum, kita dapat mengatakan bahwa memori komputer sangat mirip dengan buku semacam itu.  Bahkan, blok memori berkelanjutan yang panjangnya tetap bahkan disebut halaman, jadi kami percaya bahwa membandingkan memori dengan buku sangat sukses. <br><br>  Penulis yang menulis cerita mereka di buku adalah aplikasi atau proses berbeda yang perlu menyimpan data dalam memori.  Pemimpin redaksi, yang memutuskan halaman buku mana yang bisa penulis tulis, adalah mekanisme yang berhubungan dengan manajemen memori.  Dan orang yang menghilangkan cerita lama dari buku, membuat ruang untuk yang baru, dapat dibandingkan dengan mekanisme pengumpulan sampah. <br><br><h2>  <font color="#3AC1EF">Manajemen Memori: Jalan dari Besi ke Program</font> </h2><br>  Manajemen memori adalah suatu proses, selama implementasi program mana yang menulis data ke memori dan membacanya dari sana.  Manajer memori adalah entitas yang menentukan di mana tepatnya suatu aplikasi dapat menempatkan datanya dalam memori.  Karena jumlah fragmen memori yang dapat dialokasikan untuk aplikasi tidak terbatas, seperti halnya jumlah halaman dalam buku apa pun tidak terbatas, manajer memori, yang melayani aplikasi, perlu menemukan fragmen memori yang bebas dan menyediakannya untuk aplikasi.  Proses ini, di mana memori dialokasikan untuk aplikasi, disebut alokasi memori. <br><br>  Di sisi lain, ketika beberapa data tidak lagi dibutuhkan, itu dapat dihapus, atau, dengan kata lain, membebaskan memori yang ditempati.  Tetapi apa sebenarnya yang mereka â€œisolasiâ€ dan â€œbebaskanâ€ ketika berbicara tentang ingatan? <br><br>  Di suatu tempat di komputer Anda ada perangkat fisik yang menyimpan data yang digunakan oleh program Python saat mereka bekerja.  Sebelum objek Python muncul dalam memori fisik, kode harus melalui banyak lapisan abstraksi. <br><br>  Salah satu lapisan utama seperti itu, yang terletak di atas perangkat keras (seperti RAM atau hard disk) adalah sistem operasi (OS).  Itu mengeksekusi (atau menolak untuk memenuhi) permintaan untuk membaca data dari memori dan untuk menulis data ke memori. <br><br>  Ada aplikasi di atas OS, dalam kasus kami, salah satu implementasi Python (mungkin paket perangkat lunak yang merupakan bagian dari OS Anda atau diunduh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">python.org</a> ).  Ini adalah paket perangkat lunak ini yang terlibat dalam manajemen memori, memastikan pengoperasian kode Python Anda.  Fokus artikel ini adalah pada algoritma dan struktur data yang digunakan Python untuk mengelola memori. <br><br><h2>  <font color="#3AC1EF">Implementasi referensi python</font> </h2><br>  Referensi implementasi Python disebut CPython.  Itu ditulis dalam C. Ketika saya pertama kali mendengarnya, itu benar-benar membuat saya gelisah.  Bahasa pemrograman yang ditulis dalam bahasa lain?  Sebenarnya ini tidak sepenuhnya benar. <br><br>  Spesifikasi Python dijelaskan dalam bahasa Inggris biasa dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumen ini</a> .  Namun, spesifikasi ini saja, kode yang ditulis dengan Python, tentu saja, tidak dapat dijalankan.  Untuk melakukan ini, Anda memerlukan sesuatu yang, mengikuti aturan spesifikasi ini, dapat menafsirkan kode yang ditulis dengan Python. <br><br>  Selain itu, Anda memerlukan sesuatu yang dapat mengeksekusi kode yang ditafsirkan di komputer.  Referensi implementasi Python memecahkan kedua tugas ini.  Itu mengubah kode menjadi instruksi yang kemudian dieksekusi di mesin virtual. <br><br>  Mesin virtual mirip dengan komputer biasa yang terbuat dari silikon, logam dan bahan lainnya, tetapi mereka diimplementasikan dalam perangkat lunak.  Mereka biasanya sibuk memproses instruksi dasar, mirip dengan instruksi yang ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Assembler</a> . <br><br>  Python adalah bahasa yang ditafsirkan.  Kode yang ditulis dengan Python dikompilasi menjadi seperangkat instruksi yang nyaman bagi komputer untuk digunakan, dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode byte yang</a> disebut.  Instruksi ini ditafsirkan oleh mesin virtual ketika Anda menjalankan program Anda. <br><br>  Pernahkah Anda melihat file dengan ekstensi <code>.pyc</code> atau folder <code>__pycache__</code> ?  Mereka mengandung bytecode yang sama yang ditafsirkan oleh mesin virtual. <br><br>  Penting untuk dicatat bahwa selain CPython, ada implementasi Python lainnya.  Misalnya, saat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IronPython,</a> kode Python dikompilasi menjadi pernyataan Microsoft CLR.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jython,</a> kode dikompilasi ke dalam bytecode Java dan dieksekusi dalam mesin virtual Java.  Di dunia Python, ada yang namanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyPy</a> , tetapi layak untuk artikel yang terpisah, jadi di sini kita hanya menyebutkannya. <br><br>  Untuk tujuan artikel ini, saya akan fokus pada bagaimana mekanisme manajemen memori bekerja dalam implementasi referensi Python - CPython. <br><br>  Perlu dicatat bahwa meskipun sebagian besar dari apa yang akan kita bicarakan di sini akan berlaku untuk versi baru Python, banyak hal dapat berubah di masa depan.  Oleh karena itu, perhatikan fakta bahwa dalam artikel ini saya fokus pada versi terbaru dari Python pada saat penulisan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python 3.7</a> . <br><br>  Jadi, paket perangkat lunak CPython ditulis dalam C, ia mengartikan bytecode Python.  Apa hubungannya ini dengan manajemen memori?  Faktanya adalah bahwa algoritma dan struktur data yang digunakan untuk manajemen memori ada dalam kode CPython yang ditulis, seperti yang telah dikatakan, dalam C. Untuk memahami bagaimana manajemen memori bekerja di Python, Anda harus terlebih dahulu memahami sedikit tentang CPython. <br><br>  Bahasa C di mana CPython ditulis tidak memiliki dukungan bawaan untuk pemrograman berorientasi objek.  Karena itu, banyak solusi arsitektur yang menarik digunakan dalam kode CPython. <br><br>  Anda mungkin pernah mendengar bahwa segala sesuatu di Python adalah objek, bahkan tipe data primitif seperti <code>int</code> dan <code>str</code> .  Dan ini memang kasus di tingkat implementasi bahasa di CPython.  Ada struktur yang disebut <code>PyObject</code> , yang digunakan oleh objek yang dibuat dalam CPython. <br><br>  Struktur adalah tipe data komposit yang dapat mengelompokkan data dari berbagai jenis.  Jika Anda membandingkan ini dengan pemrograman berorientasi objek, maka strukturnya mirip dengan kelas yang memiliki atribut tetapi tidak ada metode. <br><br>  <code>PyObject</code> adalah nenek moyang dari semua objek Python.  Struktur ini hanya berisi dua bidang: <br><br><ul><li>  <code>ob_refcnt</code> - penghitung referensi. </li><li>  <code>ob_type</code> - penunjuk ke tipe lain. </li></ul><br>  Penghitung referensi digunakan untuk menerapkan mekanisme pengumpulan sampah.  Bidang <code>PyObject</code> lain adalah pointer ke tipe objek tertentu.  Tipe ini diwakili oleh struktur lain yang menggambarkan objek Python (misalnya, itu bisa berupa tipe <code>dict</code> atau <code>int</code> ). <br><br>  Setiap objek memiliki sendiri, unik untuk objek seperti itu, mekanisme alokasi memori, yang tahu bagaimana mendapatkan memori yang diperlukan untuk menyimpan objek ini.  Selain itu, setiap objek memiliki mekanisme sendiri untuk membebaskan memori, yang "membebaskan" memori setelah tidak lagi diperlukan. <br><br>  Namun, perlu dicatat bahwa dalam semua percakapan tentang alokasi dan pelepasan memori ini, ada satu faktor penting.  Faktanya adalah bahwa memori komputer adalah sumber daya bersama.  Jika, pada saat yang sama, dua proses berbeda mencoba menulis sesuatu ke area memori yang sama, sesuatu yang buruk dapat terjadi. <br><br><h2>  <font color="#3AC1EF">Kunci Global Juru Bahasa</font> </h2><br>  Global Interpreter Lock (GIL) adalah solusi untuk masalah umum yang terjadi saat bekerja dengan sumber daya komputer bersama seperti memori.  Ketika dua utas mencoba untuk memodifikasi sumber daya yang sama secara bersamaan, mereka dapat "bertabrakan" satu sama lain.  Hasilnya akan berantakan dan tidak satu pun aliran akan mencapai apa yang diperjuangkannya. <br><br>  Mari kita kembali ke analogi buku lagi.  Bayangkan bahwa dua penulis secara sewenang-wenang memutuskan bahwa sekarang giliran mereka untuk membuat catatan.  Tetapi mereka juga memutuskan untuk mencatat secara bersamaan di halaman yang sama. <br><br>  Masing-masing dari mereka tidak memperhatikan fakta bahwa yang lain mencoba untuk menulis ceritanya.  Bersama-sama mereka mulai menulis teks pada halaman.  Akibatnya, dua cerita akan direkam di sana, satu di atas yang lain, yang akan membuat halaman tersebut benar-benar tidak dapat dibaca. <br><br>  Salah satu solusi untuk masalah ini adalah mekanisme juru bahasa global tunggal yang memblokir sumber daya bersama yang bekerja sama dengan utas tertentu.  Dalam contoh kami, ini adalah "mekanisme" yang "memblokir" halaman buku.  Mekanisme seperti itu menghilangkan situasi yang dijelaskan di atas, di mana dua penulis secara bersamaan menulis teks pada halaman yang sama. <br><br>  Mekanisme GIL dalam Python menyelesaikan ini dengan memblokir seluruh penerjemah.  Akibatnya, tidak ada yang dapat mengganggu pengoperasian utas saat ini.  Dan ketika CPython bekerja dengan memori, ia menggunakan GIL untuk memastikan bahwa pekerjaan ini dilakukan dengan aman dan efisien. <br><br>  Ada kekuatan dan kelemahan untuk pendekatan ini, dan GIL adalah subjek perdebatan sengit di komunitas Python.  Untuk mempelajari lebih lanjut tentang GIL, Anda dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">materi ini</a> . <br><br><h2>  <font color="#3AC1EF">Pengumpulan sampah</font> </h2><br>  Mari kita kembali ke analogi buku dan membayangkan bahwa beberapa kisah yang dicatat dalam buku ini sudah ketinggalan zaman.  Tidak ada yang membacanya, tidak ada yang menyebutkannya di mana saja.  Dan jika tidak ada yang membaca atau merujuk pada beberapa bahan dalam karya mereka, maka bahan ini dapat dibuang, memberi ruang bagi teks-teks baru. <br><br>  Ini, dongeng yang terlupakan, dapat dibandingkan dengan objek Python yang jumlah referensi nya nol.  Ini adalah penghitung yang sama yang kami bicarakan ketika membahas struktur <code>PyObject</code> . <br><br>  Penghitung tautan bertambah karena beberapa alasan.  Misalnya, penghitung bertambah jika objek yang disimpan dalam satu variabel ditulis ke variabel lain: <br><br><pre> <code class="python hljs">numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   = 1 more_numbers = numbers #   = 2</span></span></code> </pre> <br>  Itu meningkat ketika objek diteruskan ke beberapa fungsi sebagai argumen: <br><br><pre> <code class="python hljs">total = sum(numbers)</code> </pre> <br>  Dan di sini adalah contoh lain dari situasi di mana jumlah di penghitung referensi meningkat.  Ini terjadi jika objek termasuk dalam daftar: <br><br><pre> <code class="python hljs">matrix = [numbers, numbers, numbers]</code> </pre> <br>  Python memungkinkan programmer untuk mengetahui nilai saat ini dari jumlah referensi objek tertentu menggunakan modul <code>sys</code> .  Untuk ini, konstruksi berikut digunakan: <br><br><pre> <code class="python hljs">sys.getrefcount(numbers)</code> </pre> <br>  <code>getfefcount()</code> , Anda harus ingat bahwa meneruskan objek ke metode <code>getfefcount()</code> meningkatkan nilai penghitung sebesar 1. <br><br>  Bagaimanapun, jika objek masih digunakan di suatu tempat dalam kode, penghitung referensi akan lebih besar dari 0. Ketika nilai penghitung turun ke 0, fungsi khusus akan ikut bermain, yang "membebaskan" memori yang ditempati oleh objek.  Memori ini kemudian dapat digunakan oleh objek lain. <br><br>  Kami sekarang bertanya pada diri sendiri pertanyaan tentang apa "membebaskan memori" itu dan tentang bagaimana benda lain dapat menggunakan memori ini.  Untuk menjawab pertanyaan ini, mari kita bicara tentang mekanisme manajemen memori di CPython. <br><br><h2>  <font color="#3AC1EF">Mekanisme Manajemen Memori dalam CPython</font> </h2><br>  Sekarang kita akan berbicara tentang bagaimana CPython memiliki arsitektur memori dan bagaimana manajemen memori dilakukan di sana. <br><br>  Seperti yang telah disebutkan, ada beberapa lapisan abstraksi antara CPython dan memori fisik.  Sistem operasi mengabstraksi memori fisik dan membuat lapisan memori virtual yang dapat digunakan aplikasi (ini juga berlaku untuk Python). <br><br>  Manajer memori virtual dari sistem operasi tertentu mengalokasikan sepotong memori untuk proses Python.  Area abu-abu gelap pada gambar berikut adalah potongan memori yang termasuk dalam proses Python. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/f01/548/e51f0154800b0ae223bf1c7d96f5bab8.png"><br>  <i><font color="#999999">Area Memori Digunakan oleh CPython</font></i> <br><br>  Python menggunakan sejumlah memori untuk penggunaan internal dan untuk kebutuhan yang tidak terkait dengan mengalokasikan memori untuk objek.  Sepotong memori lain digunakan untuk menyimpan objek (ini adalah nilai dari tipe <code>int</code> , <code>dict</code> , dan lain-lain seperti itu).  Harap dicatat bahwa ini adalah diagram yang disederhanakan.  Jika Anda ingin melihat gambar lengkapnya, lihat kode sumber <a href="">CPython</a> , di mana semua yang kita bicarakan sedang terjadi. <br><br>  CPython memiliki fasilitas untuk mengalokasikan memori untuk objek, yang bertanggung jawab untuk mengalokasikan memori di area yang dimaksudkan untuk menyimpan objek.  Hal yang paling menarik terjadi ketika mekanisme ini bekerja.  Disebut ketika objek membutuhkan memori, atau dalam kasus di mana memori perlu dibebaskan. <br><br>  Biasanya, menambahkan atau menghapus data ke objek Python seperti <code>list</code> dan <code>int</code> tidak melibatkan pemrosesan simultan jumlah informasi yang sangat besar.  Oleh karena itu, arsitektur alat alokasi memori dibangun dengan mata pada pemrosesan sejumlah kecil data.  Selain itu, alat ini berusaha untuk tidak mengalokasikan memori sampai menjadi jelas bahwa itu mutlak diperlukan. <br><br>  Komentar dalam <a href="">kode sumber</a> menggambarkan alat alokasi memori sebagai "alat alokasi memori cepat, khusus untuk blok kecil yang dirancang untuk digunakan di atas malloc universal."  Dalam hal ini, <code>malloc</code> adalah fungsi pustaka C yang dirancang untuk mengalokasikan memori. <br><br>  Mari kita bahas strategi alokasi memori yang digunakan oleh CPython.  Pertama, kita akan berbicara tentang tiga entitas - blok yang disebut (blok), kolam (pool) dan arena (arena), dan bagaimana mereka terkait satu sama lain. <br><br>  Arena adalah fragmen memori terbesar.  Mereka disejajarkan di batas halaman memori.  Batas halaman adalah tempat blok terus menerus dari memori dengan panjang tetap berakhir digunakan oleh sistem operasi.  Python, ketika bekerja dengan memori, mengasumsikan bahwa ukuran halaman memori sistem adalah 256 KB. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75e/4d2/dc2/75e4d2dc2e0f6985363952432b7c169d.png"><br>  <i><font color="#999999">Arena, Kolam dan Blok</font></i> <br><br>  Kolam terletak di arena, yang merupakan 4 halaman memori virtual KB.  Mereka menyerupai halaman-halaman buku dari contoh kita.  Kolam dibagi menjadi blok memori kecil. <br><br>  Semua blok di kolam yang sama milik kelas ukuran yang sama.  Kelas ukuran tempat blok menentukan ukuran blok ini, yang dipilih dengan mempertimbangkan ukuran memori yang diminta.  Berikut adalah tabel yang diambil dari kode sumber yang menunjukkan jumlah data yang diminta sistem untuk disimpan dalam memori, ukuran blok yang dialokasikan, dan pengidentifikasi kelas ukuran. <br><table><tbody><tr><td>  Jumlah data dalam byte <br></td><td>  Ukuran blok <br></td><td>  ukuran kelas idx <br></td></tr><tr><td>  1-8 <br></td><td>  8 <br></td><td>  0 <br></td></tr><tr><td>  9-16 <br></td><td>  16 <br></td><td>  1 <br></td></tr><tr><td>  17-24 <br></td><td>  24 <br></td><td>  2 <br></td></tr><tr><td>  25-32 <br></td><td>  32 <br></td><td>  3 <br></td></tr><tr><td>  33-40 <br></td><td>  40 <br></td><td>  4 <br></td></tr><tr><td>  41-48 <br></td><td>  48 <br></td><td>  5 <br></td></tr><tr><td>  49-56 <br></td><td>  56 <br></td><td>  6 <br></td></tr><tr><td>  57-64 <br></td><td>  64 <br></td><td>  7 <br></td></tr><tr><td>  65-72 <br></td><td>  72 <br></td><td>  8 <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td></tr><tr><td>  497-504 <br></td><td>  504 <br></td><td>  62 <br></td></tr><tr><td>  505-512 <br></td><td>  512 <br></td><td>  63 <br></td></tr></tbody></table><br>  Misalnya, jika 42 byte diminta untuk disimpan, data akan ditempatkan di blok 48 byte. <br><br><h2>  <font color="#3AC1EF">Kolam renang</font> </h2><br>  Kolam terdiri dari blok milik kelas ukuran yang sama.  Setiap kumpulan dikaitkan dengan kumpulan lain yang berisi blok dengan kelas ukuran yang sama menggunakan mekanisme daftar tertaut ganda.  Dengan pendekatan ini, algoritma alokasi memori dapat dengan mudah menemukan ruang kosong untuk satu blok ukuran tertentu, bahkan jika harus mencari ruang kosong di kumpulan yang berbeda. <br><br>  Daftar <code>usedpools</code> memungkinkan Anda untuk melacak semua pool di mana ada ruang untuk data milik kelas ukuran tertentu.  Ketika diminta untuk menyimpan blok ukuran tertentu, algoritma memeriksa daftar ini untuk daftar kumpulan yang menyimpan blok ukuran yang diperlukan. <br><br>  Kolam itu sendiri harus di salah satu dari tiga negara.  Yaitu, mereka dapat digunakan (negara <code>used</code> ), mereka dapat diisi ( <code>full</code> ) atau kosong ( <code>empty</code> ).  Kolam yang digunakan memiliki blok gratis di mana dimungkinkan untuk menyimpan data dengan ukuran yang sesuai.  Semua blok kumpulan diisi dialokasikan untuk data.  Kumpulan kosong tidak berisi data, dan jika perlu, dapat ditugaskan untuk menyimpan blok milik kelas ukuran apa pun. <br><br>  Daftar <code>freepools</code> menyimpan informasi tentang semua kumpulan yang dalam keadaan <code>empty</code> .  Misalnya, jika tidak ada entri dalam daftar pool yang digunakan tentang kumpulan menyimpan blok ukuran 8 byte (kelas dengan idx 0), maka kumpulan baru diinisialisasi, yang dalam keadaan <code>empty</code> , yang dirancang untuk menyimpan blok tersebut.  <code>usedpools</code> baru ini ditambahkan ke daftar <code>usedpools</code> , dapat digunakan untuk memenuhi permintaan untuk menyimpan data yang diterima setelah pembuatannya. <br><br>  Misalkan dalam kumpulan yang dalam keadaan <code>full</code> , beberapa blok dibebaskan.  Ini karena fakta bahwa data yang disimpan di dalamnya tidak lagi diperlukan.  Pool ini lagi akan ada dalam daftar <code>usedpools</code> yang <code>usedpools</code> dan dapat digunakan untuk data dari kelas ukuran yang sesuai. <br><br>  Pengetahuan tentang algoritma ini memungkinkan kita untuk memahami bagaimana keadaan kumpulan berubah selama operasi (dan bagaimana kelas ukuran berubah, blok milik yang dapat disimpan di dalamnya). <br><br><h2>  <font color="#3AC1EF">Blok</font> </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/627/407/ef5/627407ef5dafac3533d81ae0beec66f2.png"><br>  <i><font color="#999999">Kolam bekas, penuh dan kosong</font></i> <br><br>  Seperti yang dapat Anda lihat dari ilustrasi sebelumnya, pool berisi pointer ke blok "bebas" memori yang dikandungnya.  Sehubungan dengan bekerja dengan blok, satu fitur kecil harus dicatat, yang ditunjukkan dalam kode sumber.  Sistem manajemen memori yang digunakan dalam CPython, di semua tingkatan (arena, kolam, blok), berusaha untuk mengalokasikan memori hanya ketika itu benar-benar diperlukan. <br><br>  Ini berarti bahwa kumpulan dapat berisi blok yang ada di salah satu dari tiga negara: <br><br><ul><li>  <code>untouched</code> adalah bagian dari memori yang belum dialokasikan. </li><li>  <code>free</code> - bagian dari memori yang sudah dialokasikan, tetapi kemudian dibuat "gratis" oleh CPython dan tidak lagi berisi data berharga. </li><li>  <code>allocated</code> adalah bagian dari memori yang berisi data berharga. </li></ul><br>  Pointer <code>freeblock</code> menunjuk ke daftar tunggal yang terhubung dari blok memori bebas.  Dengan kata lain, ini adalah daftar tempat di mana Anda dapat menyimpan data.  Jika lebih dari satu blok gratis diperlukan untuk menempatkan data, maka alat alokasi memori akan mengambil beberapa blok dari kumpulan yang tidak <code>untouched</code> . <br><br>  Ketika alat manajemen memori membuat blok "bebas", mereka, ketika mereka memperoleh status <code>free</code> , sampai ke puncak daftar <code>freeblock</code> .  Blok yang terkandung dalam daftar ini tidak selalu mewakili wilayah memori yang berdekatan seperti yang ditunjukkan pada gambar sebelumnya.  Mereka mungkin benar-benar terlihat seperti di bawah ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cca/0c7/725/cca0c7725ce480809ee3d59b4a1b28fa.png"><br>  <i><font color="#999999">Daftar freeblock tertaut tunggal</font></i> <br><br><h2>  <font color="#3AC1EF">Arena</font> </h2><br>  Arena berisi kolam.  Kumpulan-kumpulan ini, seperti yang telah disebutkan, dapat berada di kondisi <code>used</code> , <code>full</code> atau <code>empty</code> .  Perlu dicatat bahwa arena tidak memiliki status yang mirip dengan yang dimiliki oleh kumpulan. <br><br>  Arena diatur ke dalam daftar yang ditautkan ganda yang disebut <code>usable_arenas</code> .  Daftar ini diurutkan berdasarkan jumlah kolam gratis yang tersedia.  Semakin sedikit kolam gratis di arena, semakin dekat arena ke bagian atas daftar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f91/17d/6f1/f9117d6f1b6670afd7235a2efc936713.png"><br>  <i><font color="#999999">Daftar usable_arenas</font></i> <br><br>  Ini berarti bahwa arena, yang lebih kuat dari yang lain diisi dengan data, akan dipilih untuk menempatkan data baru di dalamnya.  Dan mengapa tidak sebaliknya?  Mengapa tidak memposting data baru di arena dengan ruang paling bebas? <br><br>  Faktanya, fitur ini menuntun kita pada gagasan untuk benar-benar membebaskan memori.  Anda mungkin telah memperhatikan bahwa kita sering menggunakan konsep "membebaskan memori" di sini, melampirkannya dalam tanda kutip.  Alasan mengapa ini dilakukan adalah bahwa meskipun blok dapat dianggap "bebas", potongan memori yang diwakilinya tidak benar-benar dikembalikan ke sistem operasi.  Proses Python menyimpan bagian memori ini dan kemudian menggunakannya untuk menyimpan data baru.  Membebaskan memori yang sebenarnya adalah kembali ke sistem operasinya, yang akan dapat menggunakannya. <br><br>  Arena adalah satu-satunya entitas dalam skema yang dipertimbangkan di sini, memori yang diwakili olehnya dapat benar-benar dibebaskan.  Akal sehat menyatakan bahwa skema kerja dengan arena yang dijelaskan di atas bertujuan untuk memungkinkan arena yang hampir kosong kosong sepenuhnya.  Dengan pendekatan ini, potongan memori yang diwakili oleh arena yang benar-benar kosong dapat benar-benar dibebaskan, yang akan mengurangi jumlah memori yang dikonsumsi oleh Python. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Inilah yang Anda pelajari dengan membaca materi ini: <br><br><ul><li>  Apa itu manajemen memori dan mengapa itu penting. </li><li>  Bagaimana implementasi referensi Python, Cpython, ditulis dalam bahasa pemrograman C diatur. </li><li>  Struktur data dan algoritma apa yang digunakan dalam CPython untuk manajemen memori. </li></ul><br>  Manajemen memori adalah bagian integral dari kerja program komputer.  Python memecahkan hampir semua tugas manajemen memori tanpa disadari oleh programmer.  Python memungkinkan siapa saja yang menulis dalam bahasa ini untuk mengabaikan banyak detail kecil yang terkait dengan bekerja dengan komputer.  Ini memberi programmer kesempatan untuk bekerja di tingkat yang lebih tinggi, untuk membuat kode sendiri tanpa khawatir tentang di mana datanya disimpan. <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda memiliki pengalaman dengan pengembangan Python, tolong beri tahu kami bagaimana Anda mendekati penggunaan memori dalam program Anda.  Misalnya, apakah Anda berupaya menyimpannya? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441568/">https://habr.com/ru/post/id441568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441550/index.html">Kehidupan seorang programmer sederhana itu keras dan sederhana</a></li>
<li><a href="../id441554/index.html">Seluruh sejarah Linux. Bagian I: bagaimana semuanya dimulai</a></li>
<li><a href="../id441560/index.html">Acara digital di Moskow dari 25 Februari hingga 3 Maret</a></li>
<li><a href="../id441562/index.html">Pixel Gallop - Bagian Lima - Animasi Karakter. Berjalan</a></li>
<li><a href="../id441566/index.html">12 Konsep JavaScript untuk Diketahui</a></li>
<li><a href="../id441570/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 353 (17 - 24 Februari 2019)</a></li>
<li><a href="../id441572/index.html">Frontend Weekly Digest (18 - 24 Feb 2019)</a></li>
<li><a href="../id441574/index.html">Learning Docker Bagian 6: Bekerja dengan Data</a></li>
<li><a href="../id441576/index.html">Kubernetes Networks: Pods</a></li>
<li><a href="../id441578/index.html">Bereaksi Tutorial Bagian 19: Metode Siklus Hidup Komponen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>