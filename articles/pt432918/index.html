<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéå üçú üëåüèø Desculpe, eu quebrei o seu recovery.conf üçÉ üé∏ üë®üèª‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No PostgreSQL, desde tempos muito antigos, j√° a vers√£o 8.0, lan√ßada em 2005, um arquivo de configura√ß√£o especial recovery.conf foi usado para restaura...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desculpe, eu quebrei o seu recovery.conf</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432918/"><img src="https://habrastorage.org/webt/fa/rt/zs/fartzsjcnmws2vzxpx4qhiw5ykq.jpeg" alt="eu quebro sua recupera√ß√£o" align="left">  No PostgreSQL, desde tempos muito antigos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">j√° a vers√£o 8.0,</a> lan√ßada em 2005, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivo de configura√ß√£o</a> especial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recovery.conf foi</a> usado para restaurar em um ponto espec√≠fico no tempo.  O mesmo arquivo subseq√ºentemente come√ßou a ser usado no modo de espera e na replica√ß√£o de streaming. <br><br>  No entanto, desde a pr√≥xima vers√£o do PostgreSQL 12, o recovery.conf n√£o funcionar√° mais: eu o quebrei. <br>  Mas porque? <br><a name="habracut"></a><br>  Recovery.conf tinha um recurso: era somente leitura no in√≠cio do DBMS.  E se a recupera√ß√£o point-in-time, necess√°ria menos de uma vez por ano, ainda puder ser conciliada, a necessidade de reiniciar todo o banco de dados para alterar o endere√ßo do servidor de replica√ß√£o upstream √© um pouco deprimente.  Vi v√°rias maneiras de pervers√µes para contornar essa limita√ß√£o, como usar roteamento L3, esquemas de replica√ß√£o em cascata (para que nem todas as r√©plicas, mas pelo menos apenas parte delas, respectivamente) e at√© mesmo (mesmo que eu n√£o tenha visto isso em produ√ß√£o) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">andemilho</a> . <br><br>  Ap√≥s o pr√≥ximo rein√≠cio agendado das r√©plicas, apenas devido √† necessidade de alterar os par√¢metros de replica√ß√£o, decidi busc√°-lo, mas quanto custaria para ensinar o PostgreSQL a reler o primary_conninfo no SIGHUP?  <s>Tudo saiu mal.</s>  Em princ√≠pio, √© necess√°rio alterar apenas uma vari√°vel no processo de inicializa√ß√£o e, a partir da√≠, solicitar a reinicializa√ß√£o do WalReceiver - e √© isso, a replica√ß√£o continuar√° com o novo endere√ßo corretamente.  Resta implementar isso corretamente.  Algumas semanas depois, terminei o patch com a implementa√ß√£o da releitura de recovery.conf no sinal SIGHUP, enquanto esse patch n√£o interrompeu o comportamento do banco de dados existente. <br><br>  Ent√£o, tendo a coragem, o <a href="">enviou</a> √† lista de discuss√£o para desenvolvedores do PostgreSQL.  O que Michael Paquier respondeu rapidamente: <br><blockquote>  Antes de tornar alguns deles recarreg√°veis, vamos troc√°-los primeiro por GUCs e n√£o reinventar o manuseio de par√¢metros SIGHUP como o seu patch. </blockquote>  Opa, aconteceu que eu fiz a pergunta errada ao mecanismo de pesquisa.  A quest√£o n√£o era reler o recovery.conf, mas a convers√£o de par√¢metros de um recovery.conf separado para a infraestrutura GUC (configura√ß√£o grandiosa unificada) usada para todos os outros par√¢metros do DBMS.  Ou seja, definitivamente n√£o, n√£o precisamos de um patch, n√£o queremos isso.  Vamos primeiro transferir todas essas configura√ß√µes do recovery.conf para nossa infraestrutura de configura√ß√µes padr√£o. <br><br>  Nesta not√≠cia sombria, eu queimei e pensei: ‚ÄúMas vamos nos transferir!‚Äù.  Li as discuss√µes arquivadas na consulta de pesquisa correta, abri a √∫ltima <a href="">discuss√£o</a> encontrada <a href="">sobre as configura√ß√µes de transfer√™ncia</a> (o link foi gentilmente fornecido por Michael Paquier em sua resposta, pela qual agrade√ßo separadamente e pela resposta r√°pida).  Naquela √©poca, em maio de 2018, o patch foi abandonado por mais de um ano.  Ent√£o, aqui come√ßamos.  Ou √© mais correto dizer "continuar"?  De acordo com o plano de entretenimento: <br><br><ol><li>  leia e liste as altera√ß√µes na vers√£o publicada mais recente do patch </li><li>  analisar as altera√ß√µes no patch e transferir o necess√°rio para a vers√£o atual da base de c√≥digo </li><li>  corrija todas as refer√™ncias ao recovery.conf e seus par√¢metros na documenta√ß√£o </li><li>  testes de reparo </li><li>  envie um novo patch para a lista de discuss√£o </li><li>  obtenha algum feedback </li><li>  corrigir algo de acordo com os desejos e retornar ao par√°grafo 5 </li><li>  receber uma recusa em aceitar o patch novamente (em um ano e meio) </li></ol><br>  Parece um plano de a√ß√£o?  Bem, aqui vamos n√≥s! <br><br>  Por quanto tempo, brevemente, cheguei ao ponto cinco e, em 21 de junho de 2018, publiquei uma nova vers√£o do patch <a href="">em um novo t√≥pico de discuss√£o</a> .  Depois, tr√™s meses no sil√™ncio opressivo do sil√™ncio arrepiante do peixe Baskervilles.  No final de setembro, Peter Eisentraut, um dos desenvolvedores do Core com o direito de se comprometer, de repente mostrou interesse no patch.  Ap√≥s v√°rias itera√ß√µes de corre√ß√µes, enquanto eu passava alguns dias em sil√™ncio para passear e ver os pontos tur√≠sticos, uma carta desanimadora de Peter Eisentraut chega: <br><blockquote>  Examinei o patch e fiz v√°rios pequenos refinamentos.  Tamb√©m atualizei a documenta√ß√£o mais amplamente.  O patch anexado √© aceit√°vel para mim. </blockquote>  Ou seja, Peter Eisentraut corrigiu mais algumas coisinhas a seu crit√©rio, atualizou a documenta√ß√£o, queimou toda a se√ß√£o recovery-config.sgml e acredita que, dessa forma, o patch j√° pode ser aceito.  Ah, e eu pensei que isso aconteceria apenas para o postgresql 13, mesmo que tenha tanta sorte que o patch geralmente atinja um estado de prontid√£o para confirma√ß√£o. <br><br>  E alguns dias depois, em 25 de novembro deste 2018, Peter Eisentraut realmente <a href="">aceita esse patch</a> : <br><blockquote>  As configura√ß√µes de recovery.conf agora est√£o definidas no postgresql.conf (ou em outras fontes GUC).  Atualmente, todas as configura√ß√µes afetadas s√£o PGC_POSTMASTER;  isso pode ser refinado no futuro caso a caso. <br>  A recupera√ß√£o agora √© iniciada por um arquivo recovery.signal.  O modo de espera √© iniciado por um arquivo standby.signal.  A configura√ß√£o standby_mode desapareceu.  Se um arquivo recovery.conf for encontrado, um erro ser√° emitido. <br>  A configura√ß√£o trigger_file foi renomeada para promover_trigger_file como parte da movimenta√ß√£o. <br>  O cap√≠tulo da documenta√ß√£o "Configura√ß√£o de recupera√ß√£o" foi integrado √† "Configura√ß√£o do servidor". <br>  pg_basebackup -R agora anexa configura√ß√µes ao postgresql.auto.conf e cria um arquivo standby.signal. <br>  Autor: Fujii Masao &lt;masao (ponto) fujii (at) gmail (ponto) com&gt; <br>  Autor: Simon Riggs &lt;simon (at) 2ndquadrant (dot) com&gt; <br>  Autor: Abhijit Menon-Sen &lt;ams (at) 2ndquadrant (dot) com&gt; <br>  Autor: Sergei Kornilov &lt;sk (at) zsrv (ponto) org&gt; </blockquote>  Duas semanas se passaram e esse commit n√£o foi revertido.  Incr√≠vel  E parece que eles nem v√£o.  Isso √© incr√≠vel.  N√£o se sabe se a comunidade decidir√° mudar o comportamento novamente em qualquer dire√ß√£o, principalmente porque ainda resta um pouco de tempo antes do congelamento do recurso do postgresql 12 em abril.  Mas parece que n√£o teremos mais recovery.conf. <br><br><h3>  Ent√£o, o que mudou </h3><br>  Em primeiro lugar, o DBMS se recusar√° a iniciar se encontrar um arquivo recovery.conf - isso foi feito especificamente para que o usu√°rio, usando uma das muitas instru√ß√µes antigas, n√£o se surpreendesse por que o banco de dados ignora a configura√ß√£o desse arquivo. <br><br>  A antiga configura√ß√£o standby_mode desapareceu.  Agora, assim como o pr√≥prio fato da exist√™ncia de recovery.conf para ativar o modo de recupera√ß√£o, √© substitu√≠do por dois arquivos (com qualquer conte√∫do, geralmente vazio): <br><br><ul><li>  $ PGDATA / recovery.signal - sucessor ideol√≥gico standby_mode = off, a restaura√ß√£o do arquivo ser√° executada no ponto especificado nas configura√ß√µes; </li><li>  $ PGDATA / standby.signal - respectivamente, standby_mode = ativado.  Veremos esse arquivo em todas as r√©plicas. </li></ul><br>  Se o processo de inicializa√ß√£o do banco de dados encontrou os dois arquivos, consideramos que estamos no modo de espera. <br><br>  Se, para maior clareza, reduzir o par√¢metro muda para uma placa: <br><table><tbody><tr><th>  recovery.conf antigo <br></th><th>  PostgreSQL 12+ postgresql.conf <br></th></tr><tr><td>  primary_conninfo <br></td><td>  primary_conninfo <br></td></tr><tr><td>  primary_slot_name <br></td><td>  primary_slot_name <br></td></tr><tr><td>  trigger_file <br></td><td>  promotion_trigger_file <br></td></tr><tr><td>  recovery_min_apply_delay <br></td><td>  recovery_min_apply_delay <br></td></tr><tr><td>  recovery_target <br></td><td>  recovery_target <br></td></tr><tr><td>  recovery_target_name <br></td><td>  recovery_target_name <br></td></tr><tr><td>  recovery_target_time <br></td><td>  recovery_target_time <br></td></tr><tr><td>  recovery_target_xid <br></td><td>  recovery_target_xid <br></td></tr><tr><td>  recovery_target_lsn <br></td><td>  recovery_target_lsn <br></td></tr><tr><td>  recovery_target_inclusive <br></td><td>  recovery_target_inclusive <br></td></tr><tr><td>  recovery_target_timeline <br></td><td>  recovery_target_timeline <br></td></tr><tr><td>  recovery_target_action <br></td><td>  recovery_target_action <br></td></tr><tr><td>  restore_command <br></td><td>  restore_command <br></td></tr><tr><td>  archive_cleanup_command <br></td><td>  archive_cleanup_command <br></td></tr><tr><td>  recovery_end_command <br></td><td>  recovery_end_command <br></td></tr></tbody></table><br>  Voc√™ pode ver que um pouco menos que nada foi alterado.  No momento (com a √∫nica exce√ß√£o do prefixo promotion_ para o arquivo promotion_trigger_file), todos os novos par√¢metros s√£o nomeados exatamente como os antigos e recebem os mesmos valores poss√≠veis.  Embora, de fato, ainda haja uma altera√ß√£o nas configura√ß√µes do destino de recupera√ß√£o.  N√£o sei se algu√©m usou isso antes, mas foi um comportamento documentado e foi poss√≠vel especificar v√°rios recovery_target, recovery_target_lsn, recovery_target_name, recovery_target_time ou recovery_target_xid ao mesmo tempo.  Por exemplo <br><br><pre><code class="plaintext hljs">recovery_target_lsn = '1/1D9FEA00' recovery_target_xid = '5238954'</code> </pre> <br>  A √∫ltima linha do recovery.conf foi realmente usada para recupera√ß√£o.  Isso n√£o √© mais poss√≠vel, a meta de recupera√ß√£o deve ser indicada por no m√°ximo uma.  No entanto, devido √† l√≥gica da infraestrutura GUC, voc√™ ainda pode especificar o par√¢metro com o mesmo nome v√°rias vezes: <br><br><pre> <code class="plaintext hljs">recovery_target_lsn = '1/1D9FEA00' recovery_target_lsn = '1/16AC7D0'</code> </pre> <br>  Isso √© aceit√°vel, seremos restaurados para o valor das configura√ß√µes especificadas por √∫ltimo. <br><br>  E, em geral, √© tudo o que precisa ser dito sobre as mudan√ßas vis√≠veis fora do PostgreSQL.  pg_basebackup -R (--write-recovery-conf) permaneceu em seu lugar e faz o que se destina, somente agora adicionar√° par√¢metros ao postgresql.auto.conf em vez de recovery.conf e cria um arquivo standby.signal <br><br>  Infelizmente, quando digo que essas s√£o todas as mudan√ßas atualmente vis√≠veis, √© exatamente isso que quero dizer.  Todos os novos par√¢metros ainda est√£o definidos como PGC_POSTMASTER, ou seja, eles s√≥ podem ser alterados quando o PostgreSQL for iniciado.  Como j√° mencionado, esse era um requisito da comunidade de desenvolvedores: primeiro, transfira todas as configura√ß√µes e s√≥ ent√£o veja se elas podem ser alteradas no banco de dados em execu√ß√£o.  Ent√£o agora o PostgreSQL est√° em um est√°gio maravilhoso de desenvolvimento, quando o comportamento antigo j√° foi quebrado e as mudan√ßas para melhor ainda n√£o foram trazidas. <br><br>  J√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publiquei um patch</a> que permitir√° alterar primary_conninfo e primary_slot_name em tempo real.  Vamos ver o que acontece. <br><br>  Desculpe, eu quebrei o seu recovery.conf <br><br><h3>  UPD 7 abril 2019 </h3><br>  No √∫ltimo dia antes do recurso de congelamento vers√£o 12, voc√™ pode resumir.  A altera√ß√£o das configura√ß√µes de replica√ß√£o n√£o foi inclu√≠da na vers√£o.  Claro, essa tamb√©m √© uma hist√≥ria curiosa.  Era uma vez, o patch de Simon Riggs que tomei como base j√° continha edi√ß√µes para reiniciar o receptor de walkers ao alterar as configura√ß√µes de conex√£o.  Eu os selecionei em um patch separado, complementando com documenta√ß√£o e testes.  E ap√≥s 6 atualiza√ß√µes de patches e alguns meses de discuss√£o, o fato √≥bvio aparece: se voc√™ reiniciar o walreceiver, o banco de dados tentar√° mudar para restaurar arquivos do comando restore_command.  Um comportamento bastante simples da m√°quina de estado, acionado pelo desligamento do receptor de walter por qualquer motivo.  Mas isso acaba sendo "algo que n√£o queremos".  Bem, antes era imposs√≠vel dizer?  Ok, refiz de alguma forma, mas o calend√°rio j√° tinha o commitfest final para a vers√£o 12 e ningu√©m olhou aqui.  Em geral, isso n√£o √© algo r√°pido, os patches do postgreSQL fazem.  Mas tenho todo o direito de me incluir na lista de pessoas, gra√ßas a quem o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">REINDEX inacabado mais √©pico inacabado CONCURRENTEMENTE foi</a> inclu√≠do na vers√£o 12! <br><br>  Vale ressaltar, no final, que v√°rias configura√ß√µes t√™m <a href="">a oportunidade</a> de mudar rapidamente: archive_cleanup_command, promotion_trigger_file, recovery_end_command, recovery_min_apply_delay </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt432918/">https://habr.com/ru/post/pt432918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt432906/index.html">Editando arquivos CSV para n√£o quebrar dados</a></li>
<li><a href="../pt432908/index.html">Na R√∫ssia, eles planejam introduzir controle adicional sobre pagamentos na Internet</a></li>
<li><a href="../pt432910/index.html">√â perigoso considerar a realidade virtual como uma m√°quina de empatia</a></li>
<li><a href="../pt432912/index.html">Como obter um est√°gio no Google</a></li>
<li><a href="../pt432914/index.html">Um bot de bate-papo muito simples para o Telegram, para os menores</a></li>
<li><a href="../pt432920/index.html">O fator humano na empresa: √© perigoso?</a></li>
<li><a href="../pt432924/index.html">Corra, Lagartixa, corra: um mecanismo de movimento h√≠brido de √°gua da lagartixa</a></li>
<li><a href="../pt432928/index.html">O que est√° acontecendo na Intel e por que a Amazon n√£o transferir√° totalmente a AWS para seus chips, apesar das manchetes altas</a></li>
<li><a href="../pt432930/index.html">Explorar quarta-feira dezembro de 2018: para testar os novos patches de tempo, eles dirigiram ...</a></li>
<li><a href="../pt432932/index.html">Ecossistema do mundo das compras digitais (para roubar menos)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>