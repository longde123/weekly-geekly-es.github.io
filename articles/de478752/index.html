<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíé üîÜ üë©üèª‚Äç‚öïÔ∏è Geschichte der Versionskontrollsysteme üéöÔ∏è üßîüèø ‚ôàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel vergleichen wir aus technischer Sicht die bekanntesten Versionskontrollsysteme (in Zukunft planen wir, die Liste zu erweitern): 



...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geschichte der Versionskontrollsysteme</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478752/"><img src="https://habrastorage.org/getpro/habr/post_images/96a/685/37c/96a68537c502d13dfc82d9b9c60be78f.png"><br><br>  In diesem Artikel vergleichen wir aus technischer Sicht die bekanntesten Versionskontrollsysteme (in Zukunft planen wir, die Liste zu erweitern): <br><br><ol><li>  Erste Generation <br><ul><li>  <a href="https://habr.com/ru/post/478752/">SCCS (Source Code Control System)</a> </li><li>  <a href="https://habr.com/ru/post/478752/">RCS (Revisionskontrollsystem)</a> </li></ul></li><li>  Zweite Generation <ul><li>  <a href="https://habr.com/ru/post/478752/">CVS (Concurrent Versions System)</a> </li><li>  <a href="https://habr.com/ru/post/478752/">SVN (Apache Subversion)</a> </li></ul></li><li>  Dritte Generation <ul><li>  <a href="https://habr.com/ru/post/478752/">Git</a> </li><li>  <a href="https://habr.com/ru/post/478752/">Mercurial</a> </li></ul></li></ol><a name="habracut"></a><br>  Die Versionskontrollsysteme der ersten Generation (VCS) verfolgten √Ñnderungen in einzelnen Dateien, und die Bearbeitung wurde nur lokal und von jeweils einem Benutzer unterst√ºtzt.  Die Systeme basierten auf der Annahme, dass sich alle Benutzer auf demselben gemeinsamen Unix-Knoten bei ihren Konten anmelden. <br><br>  VCS der zweiten Generation f√ºhrte die Netzwerkunterst√ºtzung ein, was zu zentralisierten Repositorys mit ‚Äûoffiziellen‚Äú Versionen von Projekten f√ºhrte.  Dies war ein bedeutender Fortschritt, da mehrere Benutzer gleichzeitig mit dem Code arbeiten und sich auf dasselbe zentrale Repository festlegen konnten.  Setzt jedoch den erforderlichen Zugriff auf das Netzwerk fest. <br><br>  Die dritte Generation besteht aus verteiltem VCS, bei dem alle Kopien des Repositorys als gleich gelten. Es gibt kein zentrales Repository.  Dies ebnet den Weg f√ºr Festschreibungen, Verzweigungen und Zusammenf√ºhrungen, die lokal ohne Zugriff auf das Netzwerk erstellt und bei Bedarf in andere Repositorys verschoben werden. <br><br><h2>  VCS Release Timeline </h2><br>  Im folgenden Diagramm sind die Daten aufgef√ºhrt, an denen diese Tools erschienen sind: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2e2/afa/c98/2e2afac9885c5bace93ee1c34d974b39.png"><br><br><a name="sccs"></a><h2>  SCCS (Source Code Control System): erste Generation </h2><br>  SCCS gilt als eines der ersten erfolgreichen Versionskontrollsysteme.  Es wurde 1972 von Mark Rochkind von Bell Labs entwickelt.  Das System ist in C geschrieben und f√ºr die Verfolgung von Quelldateiversionen ausgelegt.  Dar√ºber hinaus wurde die Suche nach Fehlerquellen im Programm erheblich erleichtert.  Die grundlegende Architektur und Syntax von SCCS erm√∂glicht es, die Wurzeln moderner VCS-Tools zu verstehen. <br><br><h4>  Architektur </h4><br>  Wie die meisten modernen Systeme verf√ºgt SCCS √ºber eine Reihe von Befehlen zum Arbeiten mit Dateiversionen: <br><br><ol><li>  Eincheckdateien f√ºr die Verlaufsverfolgung in SCCS. <br></li><li>  Checken Sie bestimmte Versionen von Dateien aus, um sie zu √ºberpr√ºfen oder zu kompilieren. <br></li><li>  Extrahieren Sie bestimmte Versionen zum Bearbeiten. <br></li><li>  Einf√ºhrung neuer Dateiversionen mit Kommentaren, die die √Ñnderungen erl√§utern. <br></li><li>  Verwerfen Sie die an der extrahierten Datei vorgenommenen √Ñnderungen. <br></li><li>  Wichtige √Ñnderungen beim Verzweigen und Zusammenf√ºhren. <br></li><li>  Datei-√Ñnderungsprotokoll. </li></ol><br>  Beim Hinzuf√ºgen einer Verfolgungsdatei zu SCCS wird ein besonderer Dateityp erstellt, der als <code>s-</code> oder <code> </code> .  Sie wird nur mit dem Pr√§fix <code>s.</code> als Quelldatei bezeichnet <code>s.</code>  und wird im <code>SCCS</code> Unterverzeichnis gespeichert.  Daher wird f√ºr die Datei <code>test.txt</code> eine Verlaufsdatei <code>test.txt</code> im Verzeichnis <code>./SCCS/</code> .  Zum Zeitpunkt der Erstellung enth√§lt die Verlaufsdatei den anf√§nglichen Inhalt der Quelldatei sowie einige Metadaten, mit deren Hilfe Versionen nachverfolgt werden k√∂nnen.  Hier werden Pr√ºfsummen gespeichert, um sicherzustellen, dass der Inhalt nicht ge√§ndert wurde.  Der Inhalt der Verlaufsdatei wird nicht komprimiert oder codiert (wie im VCS der n√§chsten Generation). <br><br>  Da der Inhalt der Quelldatei jetzt in der Verlaufsdatei gespeichert ist, kann er zum Anzeigen, Kompilieren oder Bearbeiten in das Arbeitsverzeichnis extrahiert werden.  Sie k√∂nnen √Ñnderungen an der Verlaufsdatei vornehmen, z. B. Zeilen hinzuf√ºgen, √§ndern und l√∂schen, wodurch die Versionsnummer erh√∂ht wird. <br><br>  Nachfolgende Dateizugriffe speichern nur <code></code> oder √Ñnderungen und nicht den gesamten Inhalt.  Dadurch wird die Gr√∂√üe der Verlaufsdatei verringert.  Jedes Delta wird in einer Verlaufsdatei in einer Struktur gespeichert, die als <code>-</code> .  Wie bereits erw√§hnt, wird der tats√§chliche Inhalt einer Datei mehr oder weniger w√∂rtlich kopiert, mit speziellen Escape-Sequenzen zum Markieren von Anfang und Ende von Abschnitten hinzugef√ºgter und gel√∂schter Inhalte.  Da SCCS-Verlaufsdateien keine Komprimierung verwenden, sind sie normalerweise gr√∂√üer als die tats√§chliche Datei, in der √Ñnderungen verfolgt werden.  SCCS verwendet eine Methode namens <code> </code> , die eine konstante Abrufzeit unabh√§ngig vom Alter der abgerufenen Version garantiert, dh √§ltere Versionen werden mit der gleichen Geschwindigkeit wie neue Versionen abgerufen. <br><br>  Es ist wichtig zu beachten, dass alle Dateien separat verfolgt und aufgezeichnet werden.  Es ist nicht m√∂glich, √Ñnderungen in mehreren Dateien als ein einzelner atomarer Block zu suchen, wie dies bei Commits in Git der Fall ist.  Jede nachverfolgte Datei verf√ºgt √ºber eine eigene Verlaufsdatei, in der der √Ñnderungsverlauf gespeichert wird.  Im Allgemeinen bedeutet dies, dass die Versionsnummern verschiedener Dateien in einem Projekt normalerweise nicht √ºbereinstimmen.  Sie k√∂nnen diese Versionen jedoch vereinbaren, indem Sie alle Dateien im Projekt gleichzeitig bearbeiten (ohne sie tats√§chlich zu √§ndern) und alle Dateien gleichzeitig hinzuf√ºgen.  Dies erh√∂ht gleichzeitig die Versionsnummer f√ºr alle Dateien und h√§lt sie konsistent. Beachten Sie jedoch, dass dies nicht dasselbe ist wie das Einschlie√üen mehrerer Dateien in einem einzelnen Commit, wie in Git.  In SCCS wird jeder Datei ein individueller Verlauf hinzugef√ºgt, anders als bei einem gro√üen Commit, bei dem alle √Ñnderungen gleichzeitig vorgenommen werden. <br><br>  Wenn eine Datei zum Bearbeiten in SCCS extrahiert wird, wird sie gesperrt, sodass sie von niemand anderem bearbeitet werden kann.  Dies verhindert das √úberschreiben von √Ñnderungen durch andere Benutzer, schr√§nkt jedoch auch die Entwicklung ein, da zu einem bestimmten Zeitpunkt nur ein Benutzer mit dieser Datei arbeiten kann. <br><br>  SCCS unterst√ºtzt Zweige, in denen √Ñnderungssequenzen in einer bestimmten Datei gespeichert werden.  Sie k√∂nnen einen Zweig mit der Originalversion oder einem anderen Zweig zusammenf√ºhren. <br><br><h4>  Hauptteams </h4><br>  Das Folgende ist eine Liste der am h√§ufigsten verwendeten SCCS-Befehle. <br><br><ul><li>  <code>sccs create &lt;filename.ext&gt;</code> : <code>sccs create &lt;filename.ext&gt;</code> eine neue Datei zu SCCS hinzu und erstellt eine neue Verlaufsdatei daf√ºr (standardm√§√üig im Verzeichnis <code>./SCCS/</code> ). <br></li><li>  <code>sccs get &lt;filename.ext&gt;</code> : Extrahiert die Datei aus der entsprechenden Verlaufsdatei und legt sie schreibgesch√ºtzt im Arbeitsverzeichnis ab. <br></li><li>  <code>sccs edit &lt;filename.ext&gt;</code> : Extrahiert die Datei zur Bearbeitung aus der entsprechenden Verlaufsdatei.  Sperren Sie die Verlaufsdatei, damit andere Benutzer sie nicht √§ndern k√∂nnen. <br></li><li>  <code>sccs delta &lt;filename.ext&gt;</code> : √Ñnderungen an der angegebenen Datei hinzuf√ºgen.  Das System fordert einen Kommentar an, speichert die √Ñnderungen in der Verlaufsdatei und gibt die Sperre frei. <br></li><li>  <code>sccs prt &lt;filename.ext&gt;</code> : <code>sccs prt &lt;filename.ext&gt;</code> das √Ñnderungsprotokoll f√ºr die √ºberwachte Datei an. <br></li><li>  <code>sccs diffs &lt;filename.ext&gt;</code> : <code>sccs diffs &lt;filename.ext&gt;</code> die Unterschiede zwischen der aktuellen Arbeitskopie der Datei und dem Status der Datei beim Extrahieren an. </li></ul><br>  Weitere Informationen zu SCCS-Interna finden Sie im <a href="http://sccs.sourceforge.net/man/sccs.me.html" rel="nofollow">Eric Allman</a> <a href="https://docs.oracle.com/cd/E19504-01/802-5880/6i9k05dhp/index.html" rel="nofollow">-Handbuch und im Oracle Programming Utility-Handbuch</a> . <br><br><h4>  Beispiel f√ºr eine SCCS-Verlaufsdatei </h4><br><pre> <code class="plaintext hljs">^Ah20562 ^As 00001/00001/00002 ^Ad D 1.3 19/11/26 14:37:08 jack 3 2 ^Ac Here is a comment. ^Ae ^As 00002/00000/00001 ^Ad D 1.2 19/11/26 14:36:00 jack 2 1 ^Ac No. ^Ae ^As 00001/00000/00000 ^Ad D 1.1 19/11/26 14:35:27 jack 1 0 ^Ac date and time created 19/11/26 14:35:27 by jack ^Ae ^Au ^AU ^Af e 0 ^At ^AT ^AI 1 Hi there ^AE 1 ^AI 2 ^AD 3 This is a test of SCCS ^AE 2 ^AE 3 ^AI 3 A test of SCCS ^AE 3</code> </pre> <br><a name="rcs"></a><h2>  RCS (Revision Control System): erste Generation </h2><br>  RCS wurde 1982 von Walter Tihey in C als Alternative zum SCCS-System geschrieben, das zu diesem Zeitpunkt noch kein Open Source-System war. <br><br><h4>  Architektur </h4><br>  RCS hat viel mit seinem Vorg√§nger gemeinsam, darunter: <br><br><ul><li>  Versionierung f√ºr jede Datei separat. <br></li><li>  √Ñnderungen an mehreren Dateien k√∂nnen nicht zu einem einzigen Commit zusammengefasst werden. <br></li><li>  Verfolgte Dateien k√∂nnen nicht von mehreren Benutzern gleichzeitig bearbeitet werden. <br></li><li>  Keine Netzwerkunterst√ºtzung. <br></li><li>  Versionen jeder nachverfolgten Datei werden in der entsprechenden Verlaufsdatei gespeichert. <br></li><li>  Verzweigen und Zusammenf√ºhren von Versionen nur f√ºr einzelne Dateien. </li></ul><br>  Wenn eine Datei zum ersten Mal zu RCS hinzugef√ºgt wird, wird eine entsprechende Verlaufsdatei f√ºr sie im lokalen Speicher im lokalen Verzeichnis <code>./RCS/</code> .  Eine Erweiterung <code>,v</code> , wird zu dieser Datei hinzugef√ºgt, d. <code>test.txt</code> Eine Datei mit dem Namen <code>test.txt</code> wird von einer Datei mit dem Namen <code>test.txt,v</code> . <br><br>  RCS verwendet ein Reverse-Delta-Schema zum Speichern von √Ñnderungen.  Wenn Sie eine Datei hinzuf√ºgen, wird eine vollst√§ndige Momentaufnahme ihres Inhalts in der Verlaufsdatei gespeichert.  Wenn die Datei ge√§ndert und erneut zur√ºckgegeben wird, wird ein Delta basierend auf dem vorhandenen Inhalt der Verlaufsdatei berechnet.  Das alte Bild wird verworfen und das neue zusammen mit dem Delta gespeichert, um zum alten Zustand zur√ºckzukehren.  Dies wird als <code> </code> , da RCS zum Abrufen einer √§lteren Version die neueste Version verwendet und nacheinander Deltas anwendet, bis die gew√ºnschte Version erreicht ist.  Mit dieser Methode k√∂nnen Sie die aktuellen Versionen sehr schnell abrufen, da immer ein vollst√§ndiger Schnappschuss der aktuellen Revision verf√ºgbar ist.  Je √§lter die Version ist, desto l√§nger dauert die √úberpr√ºfung, da Sie immer mehr Deltas √ºberpr√ºfen m√ºssen. <br><br>  In SCCS ist dies anders: Das Abrufen einer beliebigen Version dauert genauso lange.  Au√üerdem wird die Pr√ºfsumme nicht in den RCS-Verlaufsdateien gespeichert, sodass die Dateiintegrit√§t nicht gew√§hrleistet werden kann. <br><br><h4>  Hauptteams </h4><br>  Nachfolgend finden Sie eine Liste der am h√§ufigsten verwendeten RCS-Befehle: <br><br><ul><li>  <code>&lt;filename.ext&gt;</code> : F√ºgt eine neue Datei zu RCS hinzu und erstellt eine neue Verlaufsdatei daf√ºr (standardm√§√üig im Verzeichnis <code>./RCS/</code> ). <br></li><li>  <code>co &lt;filename.ext&gt;</code> : Extrahiert die Datei aus der entsprechenden Verlaufsdatei und legt sie schreibgesch√ºtzt im Arbeitsverzeichnis ab. <br></li><li>  <code>co -l &lt;filename.ext&gt;</code> : Extrahiert die Datei zur Bearbeitung aus der entsprechenden Verlaufsdatei.  Sperren Sie die Verlaufsdatei, damit andere Benutzer sie nicht √§ndern k√∂nnen. <br></li><li>  <code>ci &lt;filename.ext&gt;</code> : F√ºgt Datei√§nderungen hinzu und erstellt eine neue Revision in der entsprechenden Verlaufsdatei. <br></li><li>  <code>merge &lt;file-to-merge-into.ext&gt; &lt;parent.ext&gt; &lt;file-to-merge-from.ext&gt;</code> : √Ñnderungen von zwei modifizierten <code>merge &lt;file-to-merge-into.ext&gt; &lt;parent.ext&gt; &lt;file-to-merge-from.ext&gt;</code> derselben √ºbergeordneten Datei. <br></li><li>  <code>rcsdiff &lt;filename.ext&gt;</code> : <code>rcsdiff &lt;filename.ext&gt;</code> die Unterschiede zwischen der aktuellen Arbeitskopie der Datei und dem Status der Datei beim Extrahieren an. <br></li><li>  <code>rcsclean</code> : Arbeitsdateien l√∂schen, die nicht gesperrt sind. </li></ul><br>  Weitere Informationen zu internen RCS-Komponenten finden Sie im <a href="https://www.gnu.org/software/rcs/manual/rcs.html" rel="nofollow">GNU RCS-Handbuch</a> . <br><br><h4>  Beispiel einer RCS-Verlaufsdatei </h4><br><pre> <code class="plaintext hljs">head 1.2; access; symbols; locks; strict; comment @# @; 1.2 date 2019.11.25.05.51.55; author jstopak; state Exp; branches; next 1.1; 1.1 date 2019.11.25.05.49.02; author jstopak; state Exp; branches; next ; desc @This is a test. @ 1.2 log @Edited the file. @ text @hi there, you are my bud. You are so cool! The end. @ 1.1 log @Initial revision @ text @d1 5 a5 1 hi there @</code> </pre> <br><a name="cvs"></a><h2>  CVS (Concurrent Versions System): zweite Generation </h2><br>  CVS wurde 1986 von Dick Grun erstellt, um die Versionskontrolle durch Netzwerkunterst√ºtzung zu erweitern.  Es ist auch in C geschrieben und markiert die Geburtsstunde der zweiten Generation von VCS-Tools, dank derer geografisch verteilte Entwicklungsteams die M√∂glichkeit haben, gemeinsam an Projekten zu arbeiten. <br><br><h4>  Architektur </h4><br>  CVS ist ein Frontend f√ºr RCS. Es enth√§lt einen neuen Befehlssatz f√ºr die Interaktion mit Dateien in einem Projekt. Unter der Haube werden jedoch dasselbe RCS-Verlaufsdateiformat und dieselben RCS-Befehle verwendet.  Mit CVS konnten erstmals mehrere Entwickler gleichzeitig mit denselben Dateien arbeiten.  Dies wird mithilfe eines zentralen Repository-Modells implementiert.  Der erste Schritt besteht darin, ein zentrales Repository mithilfe von CVS auf dem Remoteserver zu konfigurieren.  Projekte k√∂nnen dann in das Repository importiert werden.  Wenn ein Projekt in CVS importiert wird, wird jede Datei in eine Verlaufsdatei <code>,v</code> konvertiert und in einem zentralen Verzeichnis gespeichert: <code></code> .  Das Repository befindet sich normalerweise auf einem Remote-Server, auf den √ºber ein lokales Netzwerk oder das Internet zugegriffen werden kann. <br><br>  Der Entwickler erh√§lt eine Kopie des Moduls, die in das Arbeitsverzeichnis auf seinem lokalen Computer kopiert wird.  Bei diesem Vorgang werden keine Dateien blockiert, sodass die Anzahl der Entwickler, die gleichzeitig mit dem Modul arbeiten k√∂nnen, unbegrenzt ist.  Entwickler k√∂nnen ihre Dateien √§ndern und √Ñnderungen nach Bedarf festschreiben (Festschreiben).  Wenn ein Entwickler eine √Ñnderung festschreibt, sollten andere Entwickler ihre Arbeitskopien mithilfe des (normalerweise) automatisierten Zusammenf√ºhrungsprozesses aktualisieren, bevor sie ihre √Ñnderungen festschreiben.  Manchmal m√ºssen Sie Zusammenf√ºhrungskonflikte vor dem Festschreiben manuell l√∂sen.  CVS bietet auch die M√∂glichkeit, Zweige zu erstellen und zusammenzuf√ºhren. <br><br><h4>  Hauptteams </h4><br><ul><li>  <code>export CVSROOT=&lt;path/to/repository&gt;</code> : <code>export CVSROOT=&lt;path/to/repository&gt;</code> das Stammverzeichnis des CVS-Repositorys fest, damit Sie es nicht in jedem Befehl angeben m√ºssen. <br></li><li>  <code>cvs import -m 'Import module' &lt;module-name&gt; &lt;vendor-tag&gt; &lt;release-tag&gt;</code> : Importiert Verzeichnisse mit Dateien in das CVS-Modul.  Wechseln Sie in das Stammverzeichnis des Projekts, bevor Sie diesen Vorgang starten. <br></li><li>  <code>cvs checkout &lt;module-name&gt;</code> : Kopieren Sie das Modul in das Arbeitsverzeichnis. <br></li><li>  <code>cvs commit &lt;filename.ext&gt;</code> : <code>cvs commit &lt;filename.ext&gt;</code> die ge√§nderte Datei zur√ºck in das Modul im zentralen Repository. <br></li><li>  <code>cvs add &lt;filename.txt&gt;</code> : <code>cvs add &lt;filename.txt&gt;</code> eine neue Datei hinzu, um √Ñnderungen <code>cvs add &lt;filename.txt&gt;</code> . <br></li><li>  <code>cvs update</code> : Aktualisieren Sie die Arbeitskopie, indem Sie festgeschriebene √Ñnderungen zusammenf√ºhren, die im zentralen Repository vorhanden sind, jedoch nicht in der Arbeitskopie. <br></li><li>  <code>cvs status</code> : <code>cvs status</code> allgemeine Informationen zur extrahierten Arbeitskopie des Moduls an. <br></li><li>  <code>cvs tag &lt;tag-name&gt; &lt;files&gt;</code> : <code>cvs tag &lt;tag-name&gt; &lt;files&gt;</code> einer Datei oder einer Gruppe von Dateien ein Tag hinzu. <br></li><li>  <code>cvs tag -b &lt;new-branch-name&gt;</code> neuen Zweigs <code>cvs tag -b &lt;new-branch-name&gt;</code> : <code>cvs tag -b &lt;new-branch-name&gt;</code> einen neuen Zweig im Repository (Sie m√ºssen ihn vor der lokalen Arbeit extrahieren). <br></li><li>  <code>cvs checkout -r &lt;branch-name&gt;</code> : Extrahiert eine vorhandene Filiale in das Arbeitsverzeichnis. <br></li><li>  <code>cvs update -j &lt;branch-to-merge&gt;</code> : F√ºhrt einen vorhandenen Branch mit einer lokalen Arbeitskopie zusammen. </li></ul><br>  Weitere Informationen zu den internen Komponenten von CVS finden Sie im <a href="https://www.gnu.org/software/trans-coord/manual/cvs/html_node" rel="nofollow">GNU CVS-Handbuch</a> und in <a href="" rel="nofollow">Dick Grohns Artikel</a> . <br><br><h4>  Beispiel f√ºr eine CVS-Verlaufsdatei </h4><br><pre> <code class="plaintext hljs">head 1.1; branch 1.1.1; access ; symbols start:1.1.1.1 jack:1.1.1; locks ; strict; comment @# @; 1.1 date 2019.11.26.18.45.07; author jstopak; state Exp; branches 1.1.1.1; next ; commitid zsEBhVyPc4lonoMB; 1.1.1.1 date 2019.11.26.18.45.07; author jstopak; state Exp; branches ; next ; commitid zsEBhVyPc4lonoMB; desc @@ 1.1 log @Initial revision @ text @hi there @ 1.1.1.1 log @Imported sources @ text @@</code> </pre> <br><a name="svn"></a><h2>  SVN (Subversion): Zweite Generation </h2><br>  Subversion wurde im Jahr 2000 von Collabnet Inc. erstellt und wird derzeit von der Apache Software Foundation unterst√ºtzt.  Das System ist in C geschrieben und als zuverl√§ssigere zentrale L√∂sung als CVS konzipiert. <br><br><h4>  Architektur </h4><br>  Wie CVS verwendet Subversion ein zentrales Repository-Modell.  Remotebenutzer ben√∂tigen eine Netzwerkverbindung, um eine Festschreibung f√ºr das zentrale Repository vorzunehmen. <br><br>  Subversion f√ºhrte die Funktionalit√§t von Atomic Commits mit der Garantie ein, dass das Commit entweder vollst√§ndig erfolgreich ist oder im Falle eines Problems vollst√§ndig abgebrochen wird.  In CVS kann das Repository im Falle einer Fehlfunktion w√§hrend eines Commits (z. B. aufgrund eines Netzwerkfehlers) in einem besch√§digten und inkonsistenten Zustand verbleiben.  Dar√ºber hinaus kann ein Commit oder eine Version in Subversion mehrere Dateien und Verzeichnisse enthalten.  Dies ist wichtig, da Sie so Zusammenfassungen verwandter √Ñnderungen als gruppierter Block und nicht wie in fr√ºheren Systemen f√ºr jede Datei einzeln nachverfolgen k√∂nnen. <br><br>  Subversion verwendet derzeit das Dateisystem FSFS (File System atop the File System).  Hier wird eine Datenbank mit der Struktur von Dateien und Verzeichnissen erstellt, die dem Host-Dateisystem entsprechen.  Ein einzigartiges Merkmal von FSFS ist, dass es nicht nur Dateien und Verzeichnisse, sondern auch deren Versionen nachverfolgen kann.  Dies ist ein zeitkritisches Dateisystem.  Verzeichnisse sind in Subversion auch vollst√§ndige Objekte.  Sie k√∂nnen leere Verzeichnisse an das System √ºbergeben, w√§hrend der Rest (auch Git) sie nicht bemerkt. <br><br>  Wenn Sie ein Subversion-Repository erstellen, wird eine (fast) leere Datenbank mit Dateien und Ordnern in ihrer Zusammensetzung erstellt.  Das Verzeichnis <code>db/revs</code> wird erstellt, in dem alle Versionsverfolgungsinformationen f√ºr die hinzugef√ºgten (festgeschriebenen) Dateien gespeichert werden.  Jedes Commit (das √Ñnderungen in mehreren Dateien enthalten kann) wird in einer neuen Datei im <code>revs</code> Verzeichnis gespeichert und erh√§lt einen Namen mit einer fortlaufenden numerischen Kennung, die mit 1 beginnt. Das erste Commit speichert den gesamten Inhalt der Datei.  Zuk√ºnftige Commits derselben Datei speichern nur √Ñnderungen, die auch als <code></code> oder Deltas bezeichnet werden, um Speicherplatz zu sparen.  Dar√ºber hinaus werden Deltas mit <code>lz4</code> oder <code>zlib</code> Komprimierungsalgorithmen komprimiert, um die Gr√∂√üe zu verringern. <br><br>  Ein solches System funktioniert nur bis zu einem bestimmten Punkt.  Deltas sparen zwar Platz, aber wenn es viele gibt, ist viel Zeit f√ºr den Vorgang erforderlich, da alle Deltas verarbeitet werden m√ºssen, um den aktuellen Status der Datei wiederherzustellen.  Aus diesem Grund speichert Subversion standardm√§√üig bis zu 1023 Deltas pro Datei und erstellt dann eine neue vollst√§ndige Kopie der Datei.  Dies sorgt f√ºr ein ausgewogenes Verh√§ltnis von Speicher und Geschwindigkeit. <br><br>  SVN verwendet nicht das √ºbliche Verzweigungs- und Kennzeichnungssystem.  Die regul√§re Subversion-Repository-Vorlage enth√§lt drei Ordner im Stammverzeichnis: <br><br><ul><li> <code>trunk/</code> <br> </li><li> <code>branches/</code> <br> </li><li> <code>tags/</code> </li> </ul><br>  Der <code>trunk/</code> Verzeichnis wird f√ºr die Produktionsversion des Projekts verwendet.  Das Verzeichnis " <code>branches/</code> - zum Speichern von Unterordnern, die einzelnen Zweigen entsprechen.  Das Verzeichnis <code>tags/</code> dient zum Speichern von Tags, die bestimmte (normalerweise wichtige) Versionen eines Projekts darstellen. <br><br><h4>  Hauptteams </h4><br><ul><li>  <code>svn create &lt;path-to-repository&gt;</code> : Erstellt eine neue leere Repository-Shell im angegebenen Verzeichnis. <br></li><li>  <code>svn import &lt;path-to-project&gt; &lt;svn-url&gt;</code> : Importiert das Dateiverzeichnis in das angegebene Subversion-Repository. <br></li><li>  <code>svn checkout &lt;svn-path&gt; &lt;path-to-checkout&gt;</code> : Kopieren Sie das Repository in das Arbeitsverzeichnis. <br></li><li>  <code>svn commit -m 'Commit message'</code> : Festschreiben einer Reihe ge√§nderter Dateien und Ordner zusammen mit der Nachricht. <br></li><li>  <code>svn add &lt;filename.txt&gt;</code> : F√ºgt eine neue Datei hinzu, um √Ñnderungen nachzuverfolgen. <br></li><li>  <code>svn update</code> : Aktualisieren Sie die Arbeitskopie, indem Sie festgeschriebene √Ñnderungen zusammenf√ºhren, die im zentralen Repository vorhanden sind, jedoch nicht in der Arbeitskopie. <br></li><li>  <code>svn status</code> : Zeigt eine Liste der √ºberwachten Dateien an, die sich im Arbeitsverzeichnis ge√§ndert haben (falls vorhanden). <br></li><li>  <code>svn info</code> : allgemeine Informationen zur extrahierten Kopie. <br></li><li>  <code>svn copy &lt;branch-to-copy&gt; &lt;new-branch-path-and-name&gt;</code> : Erstellt einen neuen Zweig, indem ein vorhandener kopiert wird. <br></li><li>  <code>svn switch &lt;existing-branch&gt;</code> : Wechselt das Arbeitsverzeichnis zu einem existierenden Zweig.  Dies erm√∂glicht es Ihnen, Dateien von dort zu nehmen. <br></li><li>  <code>svn merge &lt;existing-branch&gt;</code> : F√ºhrt den angegebenen Zweig mit dem aktuellen Zweig zusammen, der in das Arbeitsverzeichnis kopiert wurde.  Bitte beachten Sie, dass Sie sp√§ter ein Commit durchf√ºhren m√ºssen. <br></li><li>  <code>svn log</code> : <code>svn log</code> den Verlauf der Festschreibungen und die entsprechenden Meldungen f√ºr den aktiven Zweig an. </li></ul><br>  Weitere Informationen zu den internen Komponenten von SVN finden Sie unter <a href="http://svnbook.red-bean.com/" rel="nofollow">Subversion-Versionierung</a> . <br><br><h4>  Beispiel einer SVN-Verlaufsdatei </h4><br><pre> <code class="plaintext hljs">DELTA SVN^B^@^@ ^B ^A&lt;89&gt; hi there ENDREP id: 2-1.0.r1/4 type: file count: 0 text: 1 3 21 9 12f6bb1941df66b8f138a446d4e8670c 279d9035886d4c0427549863c4c2101e4a63e041 0-0/_4 cpath: /trunk/hi.txt copyroot: 0 / DELTA SVN^B^@^@$^B%^A¬§$K 6 hi.txt V 15 file 2-1.0.r1/4 END ENDREP id: 0-1.0.r1/6 type: dir count: 0 text: 1 5 48 36 d84cb1c29105ee7739f3e834178e6345 - - cpath: /trunk copyroot: 0 / DELTA SVN^B^@^@'^B#^A¬¢'K 5 trunk V 14 dir 0-1.0.r1/6 END ENDREP id: 0.0.r1/2 type: dir pred: 0.0.r0/2 count: 1 text: 1 7 46 34 1d30e888ec9e633100992b752c2ff4c2 - - cpath: / copyroot: 0 / _0.0.t0-0 add-dir false false false /trunk _2.0.t0-0 add-file true false false /trunk/hi.txt L2P-INDEX ^A&lt;80&gt;@^A^A^A^M^H^@√§^H√∑^A√©^FD√é^Bz√®^AP2L-INDEX ^A&lt;91&gt;^E&lt;80&gt;&lt;80&gt;@^A?^@'2^@&lt;8d&gt;¬ª√ù&lt;90&gt;^C¬ß^A^X^@√µ ¬Ω¬Ω^N= ^@√º&lt;8d&gt;√î√£^Ft^V^@&lt;92&gt;&lt;9a&gt;&lt;89&gt;√É^E; ^@&lt;8a&gt;√•w|I^@&lt;88&gt;&lt;83&gt;√é&lt;93&gt;^L`^M^@√π&lt;92&gt;√Ä^E√Ø√∫?^[^@^@657 6aad60ec758d121d5181ea4b81a9f5f4 688 75f59082c8b5ab687ae87708432ca406I</code> </pre> <br><a name="git"></a><h2>  Git: dritte Generation </h2><br>  Das Git-System wurde 2005 von Linus Torvalds (Erfinder von Linux) entwickelt.  Es ist haupts√§chlich in C in Kombination mit einigen Befehlszeilenskripten geschrieben.  Unterscheidet sich von VCS in Funktionen, Flexibilit√§t und Geschwindigkeit.  Torvalds hat das System urspr√ºnglich f√ºr die Linux-Codebasis geschrieben, aber mit der Zeit hat sich sein Anwendungsbereich erweitert, und heute ist es das beliebteste Versionskontrollsystem der Welt. <br><br><h4>  Architektur </h4><br>  Git ist ein verteiltes System.  Es gibt kein zentrales Repository: Alle Kopien werden gleich erstellt, was sich stark vom VCS der zweiten Generation unterscheidet, bei dem die Arbeit auf dem Hinzuf√ºgen und Extrahieren von Dateien aus dem zentralen Repository basiert.  Dies bedeutet, dass Entwickler √Ñnderungen sofort miteinander austauschen k√∂nnen, bevor sie ihre √Ñnderungen in einer offiziellen Zweigstelle zusammenf√ºhren. <br><br>  Dar√ºber hinaus k√∂nnen Entwickler ihre √Ñnderungen an der lokalen Kopie des Repositorys vornehmen, ohne andere Repositorys zu kennen.  Dies erm√∂glicht Commits, ohne mit einem Netzwerk oder dem Internet verbunden zu sein.  Entwickler k√∂nnen lokal offline arbeiten, bis sie bereit sind, ihre Arbeit mit anderen zu teilen.  Zu diesem Zeitpunkt werden die √Ñnderungen zur √úberpr√ºfung, zum Testen oder zur Bereitstellung an andere Repositorys gesendet. <br><br>  Wenn eine Datei zum Verfolgen in Git hinzugef√ºgt wird, wird sie mit dem <code>zlib</code> Komprimierungsalgorithmus komprimiert.  Das Ergebnis wird mit der SHA-1-Hash-Funktion gehasht.  Dies ergibt einen eindeutigen Hash, der speziell mit dem Inhalt dieser Datei √ºbereinstimmt.  Git speichert es in der <code> </code> , die sich in einem versteckten Ordner <code>.git/objects</code> .  Der Dateiname ist der generierte Hash und die Datei enth√§lt komprimierten Inhalt.  Diese Dateien werden als <code></code> und jedes Mal erstellt, wenn eine neue Datei (oder eine ge√§nderte Version einer vorhandenen Datei) zum Repository hinzugef√ºgt wird. <br><br>  Git implementiert einen Staging-Index, der als Zwischenbereich f√ºr √Ñnderungen dient, die f√ºr das Festschreiben vorbereitet werden.  Bei der Vorbereitung neuer √Ñnderungen wird auf deren komprimierten Inhalt in einer speziellen Indexdatei verwiesen, die die Form eines Baumobjekts hat.  Ein Baum ist ein Git-Objekt, das Blobs mit ihren tats√§chlichen Dateinamen, Dateiberechtigungen und Verkn√ºpfungen zu anderen B√§umen verkn√ºpft und somit den Status einer bestimmten Gruppe von Dateien und Verzeichnissen darstellt.       ,      ,    <code></code>     Git.        ,     ,   ,    .         (-),        . <br><br>   ,   Git ‚Äî ,    ‚Äî ,           .   <code> </code> (loose objects).        ,   Git  ,          .   ,       ,            Git     <code> </code> .      ,        .     <code>.pack</code>   ,        <code>.idx</code> ( )           . <br><br>          ,      .               . <br><br><h4>   </h4><br><ul><li> <code>git init</code> :      Git (   <code>.git</code>   ). <br></li><li> <code>git clone &lt;git-url&gt;</code> :    Git   URL. <br></li><li> <code>git add &lt;filename.ext&gt;</code> :         (      ). <br></li><li> <code>git commit -m 'Commit message'</code> :           . <br></li><li> <code>git status</code> :    ,  ,  ,    . . <br></li><li> <code>git branch &lt;new-branch&gt;</code> :        . <br></li><li> <code>git checkout &lt;branch&gt;</code> :      . <br></li><li> <code>git merge &lt;branch&gt;</code> :     ,     . <br></li><li> <code>git pull</code> :   ,     ,     ,     . <br></li><li> <code>git push</code> :                . <br></li><li> <code>git log</code> :         . <br></li><li> <code>git stash</code> :         ,    . </li></ul><br>   ,    Git,   <a href="https://initialcommit.io/" rel="nofollow"> Git  </a> .      .  <a href="https://book.git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain" rel="nofollow">   Pro Git</a> . <br><br><h4>  ,    Git </h4><br>    <code>37d4e6c5c48ba0d245164c4e10d5f41140cab980</code> : <br><br><pre> <code class="plaintext hljs">hi there</code> </pre> <br>     <code>b769f35b07fbe0076dcfc36fd80c121d747ccc04</code> : <br><br><pre> <code class="plaintext hljs">100644 blob 37d4e6c5c48ba0d245164c4e10d5f41140cab980hi.txt</code> </pre> <br>    <code>dc512627287a61f6111705151f4e53f204fbda9b</code> : <br><br><pre> <code class="plaintext hljs">tree b769f35b07fbe0076dcfc36fd80c121d747ccc04 author Jacob Stopak 1574915303 -0800 committer Jacob Stopak 1574915303 -0800 Initial commit</code> </pre> <br><a name="hg"></a><h2> Mercurial:   </h2><br> Mercurial   2005       Python.        Linux,        Git.       ,     . <br><br><h4>  Architektur </h4><br> Mercurial ‚Äî   ,             . Mercurial      ,   Git,       SHA-1,    . <br><br>        Mercurial,      <code>revlog</code>    <code>.hg/store/data/</code> .    <code>revlog</code> ( )    <code> </code>   VCS,   CVS, RCS  SCCS.    Git,          , Mercurial      revlog   .            .     ,     .              . <br><br>  revlog     ,   ,    <code>.i</code>  <code>.d</code> .  <code>.d</code>   .  <code>.i</code>            <code>.d</code> .              <code>.i</code> .   revlog       .  -  <code>nodeid</code> . <br><br>    Mercurial          <code></code> .     revlog ‚Äî    ,    .    ,  revlog,       nodeids,  ,       .       . -   <code>nodeid</code> . <br><br> , Mercurial     revlog,   changelog,    .   ,       : <br><br><ul><li> nodeid :    ,      . <br></li><li>    nodeid   :   Mercurial       .      (  )      ID. <br></li><li>   <br></li><li>   <br></li><li>   </li></ul><br>   changelog   ,    <code>nodeid</code> . <br><br><h4>   </h4><br><ul><li> <code>hg init</code> :      Mercurial (   <code>.hg</code>   ). <br></li><li> <code>hg clone &lt;hg-url&gt;</code> :    Mercurial   URL. <br></li><li> <code>hg add &lt;filename.ext&gt;</code> :      . <br></li><li> <code>hg commit -m 'Commit message'</code> :          . <br></li><li> <code>hg status</code> :  ,     ,  ,    .. <br></li><li> <code>hg update &lt;revision&gt;</code> :      . <br></li><li> <code>hg merge &lt;branch&gt;</code> :     ,    . <br></li><li> <code>hg pull</code> :      ,       . <br></li><li> <code>hg push</code> :      . <br></li><li> <code>hg log</code> :           . </li></ul><br><h4>   Mercurial </h4><br> : <br><br><pre> <code class="plaintext hljs">hey.txt208b6e0998e8099b16ad0e43f036ec745d58ec04 hi.txt74568dc1a5b9047c8041edd99dd6f566e78d3a42</code> </pre> <br>   (changelog): <br><br><pre> <code class="plaintext hljs">b8ee947ce6f25b84c22fbefecab99ea918fc0969 Jacob Stopak 1575082451 28800 hey.txt Add hey.txt</code> </pre> <br>     Mercurial: <br><br><ul><li> <a href="http://hgbook.red-bean.com/read/behind-the-scenes.html" rel="nofollow">  '  Mercurial</a> </li><li> <a href="https://www.mercurial-scm.org/wiki/Revlog" rel="nofollow"> Mercurial (Revlog)</a> </li><li> <a href="https://www.mercurial-scm.org/wiki/ChangeSet" rel="nofollow"> Mercurial (ChangeSet)</a> </li><li> <a href="https://www.mercurial-scm.org/wiki/Manifest" rel="nofollow"> Mercurial (Manifest)</a> </li><li> <a href="https://www.mercurial-scm.org/wiki/Revision" rel="nofollow"> Mercurial (Revision)</a> </li><li> <a href="https://www.mercurial-scm.org/wiki/Nodeid" rel="nofollow"> Mercurial (Nodeid)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478752/">https://habr.com/ru/post/de478752/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478728/index.html">Die 9 besten Open Source-Funde f√ºr November 2019</a></li>
<li><a href="../de478736/index.html">Die Zukunft der k√ºnstlichen Intelligenz im Bildungssystem: Alles, was man wissen sollte</a></li>
<li><a href="../de478740/index.html">Go to Go! Wie das PHP-Team dazu kam, Microservices zu schreiben</a></li>
<li><a href="../de478748/index.html">SSDs f√ºr Zuverl√§ssigkeitstests: 3dnews vs JEDEC vs common sense. Wo ist die Wahrheit, Bruder?</a></li>
<li><a href="../de478750/index.html">Aktuelle Datenvisualisierungsbibliotheken f√ºr Reaktionsentwickler</a></li>
<li><a href="../de478758/index.html">Hervorragende UTM-Tag-Anleitung: So finden Sie heraus, woher Benutzer kommen</a></li>
<li><a href="../de478760/index.html">"Zero" H√∂lle und wie man da rauskommt</a></li>
<li><a href="../de478764/index.html">JavaScript-Fehler: beheben, verarbeiten, reparieren</a></li>
<li><a href="../de478766/index.html">Passen Sie die Zuordnung von Spring MVC-Controllern an</a></li>
<li><a href="../de478772/index.html">Faltungsstruktur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>