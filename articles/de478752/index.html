<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💎 🔆 👩🏻‍⚕️ Geschichte der Versionskontrollsysteme 🎚️ 🧔🏿 ♈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel vergleichen wir aus technischer Sicht die bekanntesten Versionskontrollsysteme (in Zukunft planen wir, die Liste zu erweitern): 



...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geschichte der Versionskontrollsysteme</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478752/"><img src="https://habrastorage.org/getpro/habr/post_images/96a/685/37c/96a68537c502d13dfc82d9b9c60be78f.png"><br><br>  In diesem Artikel vergleichen wir aus technischer Sicht die bekanntesten Versionskontrollsysteme (in Zukunft planen wir, die Liste zu erweitern): <br><br><ol><li>  Erste Generation <br><ul><li>  <a href="https://habr.com/ru/post/478752/">SCCS (Source Code Control System)</a> </li><li>  <a href="https://habr.com/ru/post/478752/">RCS (Revisionskontrollsystem)</a> </li></ul></li><li>  Zweite Generation <ul><li>  <a href="https://habr.com/ru/post/478752/">CVS (Concurrent Versions System)</a> </li><li>  <a href="https://habr.com/ru/post/478752/">SVN (Apache Subversion)</a> </li></ul></li><li>  Dritte Generation <ul><li>  <a href="https://habr.com/ru/post/478752/">Git</a> </li><li>  <a href="https://habr.com/ru/post/478752/">Mercurial</a> </li></ul></li></ol><a name="habracut"></a><br>  Die Versionskontrollsysteme der ersten Generation (VCS) verfolgten Änderungen in einzelnen Dateien, und die Bearbeitung wurde nur lokal und von jeweils einem Benutzer unterstützt.  Die Systeme basierten auf der Annahme, dass sich alle Benutzer auf demselben gemeinsamen Unix-Knoten bei ihren Konten anmelden. <br><br>  VCS der zweiten Generation führte die Netzwerkunterstützung ein, was zu zentralisierten Repositorys mit „offiziellen“ Versionen von Projekten führte.  Dies war ein bedeutender Fortschritt, da mehrere Benutzer gleichzeitig mit dem Code arbeiten und sich auf dasselbe zentrale Repository festlegen konnten.  Setzt jedoch den erforderlichen Zugriff auf das Netzwerk fest. <br><br>  Die dritte Generation besteht aus verteiltem VCS, bei dem alle Kopien des Repositorys als gleich gelten. Es gibt kein zentrales Repository.  Dies ebnet den Weg für Festschreibungen, Verzweigungen und Zusammenführungen, die lokal ohne Zugriff auf das Netzwerk erstellt und bei Bedarf in andere Repositorys verschoben werden. <br><br><h2>  VCS Release Timeline </h2><br>  Im folgenden Diagramm sind die Daten aufgeführt, an denen diese Tools erschienen sind: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2e2/afa/c98/2e2afac9885c5bace93ee1c34d974b39.png"><br><br><a name="sccs"></a><h2>  SCCS (Source Code Control System): erste Generation </h2><br>  SCCS gilt als eines der ersten erfolgreichen Versionskontrollsysteme.  Es wurde 1972 von Mark Rochkind von Bell Labs entwickelt.  Das System ist in C geschrieben und für die Verfolgung von Quelldateiversionen ausgelegt.  Darüber hinaus wurde die Suche nach Fehlerquellen im Programm erheblich erleichtert.  Die grundlegende Architektur und Syntax von SCCS ermöglicht es, die Wurzeln moderner VCS-Tools zu verstehen. <br><br><h4>  Architektur </h4><br>  Wie die meisten modernen Systeme verfügt SCCS über eine Reihe von Befehlen zum Arbeiten mit Dateiversionen: <br><br><ol><li>  Eincheckdateien für die Verlaufsverfolgung in SCCS. <br></li><li>  Checken Sie bestimmte Versionen von Dateien aus, um sie zu überprüfen oder zu kompilieren. <br></li><li>  Extrahieren Sie bestimmte Versionen zum Bearbeiten. <br></li><li>  Einführung neuer Dateiversionen mit Kommentaren, die die Änderungen erläutern. <br></li><li>  Verwerfen Sie die an der extrahierten Datei vorgenommenen Änderungen. <br></li><li>  Wichtige Änderungen beim Verzweigen und Zusammenführen. <br></li><li>  Datei-Änderungsprotokoll. </li></ol><br>  Beim Hinzufügen einer Verfolgungsdatei zu SCCS wird ein besonderer Dateityp erstellt, der als <code>s-</code> oder <code> </code> .  Sie wird nur mit dem Präfix <code>s.</code> als Quelldatei bezeichnet <code>s.</code>  und wird im <code>SCCS</code> Unterverzeichnis gespeichert.  Daher wird für die Datei <code>test.txt</code> eine Verlaufsdatei <code>test.txt</code> im Verzeichnis <code>./SCCS/</code> .  Zum Zeitpunkt der Erstellung enthält die Verlaufsdatei den anfänglichen Inhalt der Quelldatei sowie einige Metadaten, mit deren Hilfe Versionen nachverfolgt werden können.  Hier werden Prüfsummen gespeichert, um sicherzustellen, dass der Inhalt nicht geändert wurde.  Der Inhalt der Verlaufsdatei wird nicht komprimiert oder codiert (wie im VCS der nächsten Generation). <br><br>  Da der Inhalt der Quelldatei jetzt in der Verlaufsdatei gespeichert ist, kann er zum Anzeigen, Kompilieren oder Bearbeiten in das Arbeitsverzeichnis extrahiert werden.  Sie können Änderungen an der Verlaufsdatei vornehmen, z. B. Zeilen hinzufügen, ändern und löschen, wodurch die Versionsnummer erhöht wird. <br><br>  Nachfolgende Dateizugriffe speichern nur <code></code> oder Änderungen und nicht den gesamten Inhalt.  Dadurch wird die Größe der Verlaufsdatei verringert.  Jedes Delta wird in einer Verlaufsdatei in einer Struktur gespeichert, die als <code>-</code> .  Wie bereits erwähnt, wird der tatsächliche Inhalt einer Datei mehr oder weniger wörtlich kopiert, mit speziellen Escape-Sequenzen zum Markieren von Anfang und Ende von Abschnitten hinzugefügter und gelöschter Inhalte.  Da SCCS-Verlaufsdateien keine Komprimierung verwenden, sind sie normalerweise größer als die tatsächliche Datei, in der Änderungen verfolgt werden.  SCCS verwendet eine Methode namens <code> </code> , die eine konstante Abrufzeit unabhängig vom Alter der abgerufenen Version garantiert, dh ältere Versionen werden mit der gleichen Geschwindigkeit wie neue Versionen abgerufen. <br><br>  Es ist wichtig zu beachten, dass alle Dateien separat verfolgt und aufgezeichnet werden.  Es ist nicht möglich, Änderungen in mehreren Dateien als ein einzelner atomarer Block zu suchen, wie dies bei Commits in Git der Fall ist.  Jede nachverfolgte Datei verfügt über eine eigene Verlaufsdatei, in der der Änderungsverlauf gespeichert wird.  Im Allgemeinen bedeutet dies, dass die Versionsnummern verschiedener Dateien in einem Projekt normalerweise nicht übereinstimmen.  Sie können diese Versionen jedoch vereinbaren, indem Sie alle Dateien im Projekt gleichzeitig bearbeiten (ohne sie tatsächlich zu ändern) und alle Dateien gleichzeitig hinzufügen.  Dies erhöht gleichzeitig die Versionsnummer für alle Dateien und hält sie konsistent. Beachten Sie jedoch, dass dies nicht dasselbe ist wie das Einschließen mehrerer Dateien in einem einzelnen Commit, wie in Git.  In SCCS wird jeder Datei ein individueller Verlauf hinzugefügt, anders als bei einem großen Commit, bei dem alle Änderungen gleichzeitig vorgenommen werden. <br><br>  Wenn eine Datei zum Bearbeiten in SCCS extrahiert wird, wird sie gesperrt, sodass sie von niemand anderem bearbeitet werden kann.  Dies verhindert das Überschreiben von Änderungen durch andere Benutzer, schränkt jedoch auch die Entwicklung ein, da zu einem bestimmten Zeitpunkt nur ein Benutzer mit dieser Datei arbeiten kann. <br><br>  SCCS unterstützt Zweige, in denen Änderungssequenzen in einer bestimmten Datei gespeichert werden.  Sie können einen Zweig mit der Originalversion oder einem anderen Zweig zusammenführen. <br><br><h4>  Hauptteams </h4><br>  Das Folgende ist eine Liste der am häufigsten verwendeten SCCS-Befehle. <br><br><ul><li>  <code>sccs create &lt;filename.ext&gt;</code> : <code>sccs create &lt;filename.ext&gt;</code> eine neue Datei zu SCCS hinzu und erstellt eine neue Verlaufsdatei dafür (standardmäßig im Verzeichnis <code>./SCCS/</code> ). <br></li><li>  <code>sccs get &lt;filename.ext&gt;</code> : Extrahiert die Datei aus der entsprechenden Verlaufsdatei und legt sie schreibgeschützt im Arbeitsverzeichnis ab. <br></li><li>  <code>sccs edit &lt;filename.ext&gt;</code> : Extrahiert die Datei zur Bearbeitung aus der entsprechenden Verlaufsdatei.  Sperren Sie die Verlaufsdatei, damit andere Benutzer sie nicht ändern können. <br></li><li>  <code>sccs delta &lt;filename.ext&gt;</code> : Änderungen an der angegebenen Datei hinzufügen.  Das System fordert einen Kommentar an, speichert die Änderungen in der Verlaufsdatei und gibt die Sperre frei. <br></li><li>  <code>sccs prt &lt;filename.ext&gt;</code> : <code>sccs prt &lt;filename.ext&gt;</code> das Änderungsprotokoll für die überwachte Datei an. <br></li><li>  <code>sccs diffs &lt;filename.ext&gt;</code> : <code>sccs diffs &lt;filename.ext&gt;</code> die Unterschiede zwischen der aktuellen Arbeitskopie der Datei und dem Status der Datei beim Extrahieren an. </li></ul><br>  Weitere Informationen zu SCCS-Interna finden Sie im <a href="http://sccs.sourceforge.net/man/sccs.me.html" rel="nofollow">Eric Allman</a> <a href="https://docs.oracle.com/cd/E19504-01/802-5880/6i9k05dhp/index.html" rel="nofollow">-Handbuch und im Oracle Programming Utility-Handbuch</a> . <br><br><h4>  Beispiel für eine SCCS-Verlaufsdatei </h4><br><pre> <code class="plaintext hljs">^Ah20562 ^As 00001/00001/00002 ^Ad D 1.3 19/11/26 14:37:08 jack 3 2 ^Ac Here is a comment. ^Ae ^As 00002/00000/00001 ^Ad D 1.2 19/11/26 14:36:00 jack 2 1 ^Ac No. ^Ae ^As 00001/00000/00000 ^Ad D 1.1 19/11/26 14:35:27 jack 1 0 ^Ac date and time created 19/11/26 14:35:27 by jack ^Ae ^Au ^AU ^Af e 0 ^At ^AT ^AI 1 Hi there ^AE 1 ^AI 2 ^AD 3 This is a test of SCCS ^AE 2 ^AE 3 ^AI 3 A test of SCCS ^AE 3</code> </pre> <br><a name="rcs"></a><h2>  RCS (Revision Control System): erste Generation </h2><br>  RCS wurde 1982 von Walter Tihey in C als Alternative zum SCCS-System geschrieben, das zu diesem Zeitpunkt noch kein Open Source-System war. <br><br><h4>  Architektur </h4><br>  RCS hat viel mit seinem Vorgänger gemeinsam, darunter: <br><br><ul><li>  Versionierung für jede Datei separat. <br></li><li>  Änderungen an mehreren Dateien können nicht zu einem einzigen Commit zusammengefasst werden. <br></li><li>  Verfolgte Dateien können nicht von mehreren Benutzern gleichzeitig bearbeitet werden. <br></li><li>  Keine Netzwerkunterstützung. <br></li><li>  Versionen jeder nachverfolgten Datei werden in der entsprechenden Verlaufsdatei gespeichert. <br></li><li>  Verzweigen und Zusammenführen von Versionen nur für einzelne Dateien. </li></ul><br>  Wenn eine Datei zum ersten Mal zu RCS hinzugefügt wird, wird eine entsprechende Verlaufsdatei für sie im lokalen Speicher im lokalen Verzeichnis <code>./RCS/</code> .  Eine Erweiterung <code>,v</code> , wird zu dieser Datei hinzugefügt, d. <code>test.txt</code> Eine Datei mit dem Namen <code>test.txt</code> wird von einer Datei mit dem Namen <code>test.txt,v</code> . <br><br>  RCS verwendet ein Reverse-Delta-Schema zum Speichern von Änderungen.  Wenn Sie eine Datei hinzufügen, wird eine vollständige Momentaufnahme ihres Inhalts in der Verlaufsdatei gespeichert.  Wenn die Datei geändert und erneut zurückgegeben wird, wird ein Delta basierend auf dem vorhandenen Inhalt der Verlaufsdatei berechnet.  Das alte Bild wird verworfen und das neue zusammen mit dem Delta gespeichert, um zum alten Zustand zurückzukehren.  Dies wird als <code> </code> , da RCS zum Abrufen einer älteren Version die neueste Version verwendet und nacheinander Deltas anwendet, bis die gewünschte Version erreicht ist.  Mit dieser Methode können Sie die aktuellen Versionen sehr schnell abrufen, da immer ein vollständiger Schnappschuss der aktuellen Revision verfügbar ist.  Je älter die Version ist, desto länger dauert die Überprüfung, da Sie immer mehr Deltas überprüfen müssen. <br><br>  In SCCS ist dies anders: Das Abrufen einer beliebigen Version dauert genauso lange.  Außerdem wird die Prüfsumme nicht in den RCS-Verlaufsdateien gespeichert, sodass die Dateiintegrität nicht gewährleistet werden kann. <br><br><h4>  Hauptteams </h4><br>  Nachfolgend finden Sie eine Liste der am häufigsten verwendeten RCS-Befehle: <br><br><ul><li>  <code>&lt;filename.ext&gt;</code> : Fügt eine neue Datei zu RCS hinzu und erstellt eine neue Verlaufsdatei dafür (standardmäßig im Verzeichnis <code>./RCS/</code> ). <br></li><li>  <code>co &lt;filename.ext&gt;</code> : Extrahiert die Datei aus der entsprechenden Verlaufsdatei und legt sie schreibgeschützt im Arbeitsverzeichnis ab. <br></li><li>  <code>co -l &lt;filename.ext&gt;</code> : Extrahiert die Datei zur Bearbeitung aus der entsprechenden Verlaufsdatei.  Sperren Sie die Verlaufsdatei, damit andere Benutzer sie nicht ändern können. <br></li><li>  <code>ci &lt;filename.ext&gt;</code> : Fügt Dateiänderungen hinzu und erstellt eine neue Revision in der entsprechenden Verlaufsdatei. <br></li><li>  <code>merge &lt;file-to-merge-into.ext&gt; &lt;parent.ext&gt; &lt;file-to-merge-from.ext&gt;</code> : Änderungen von zwei modifizierten <code>merge &lt;file-to-merge-into.ext&gt; &lt;parent.ext&gt; &lt;file-to-merge-from.ext&gt;</code> derselben übergeordneten Datei. <br></li><li>  <code>rcsdiff &lt;filename.ext&gt;</code> : <code>rcsdiff &lt;filename.ext&gt;</code> die Unterschiede zwischen der aktuellen Arbeitskopie der Datei und dem Status der Datei beim Extrahieren an. <br></li><li>  <code>rcsclean</code> : Arbeitsdateien löschen, die nicht gesperrt sind. </li></ul><br>  Weitere Informationen zu internen RCS-Komponenten finden Sie im <a href="https://www.gnu.org/software/rcs/manual/rcs.html" rel="nofollow">GNU RCS-Handbuch</a> . <br><br><h4>  Beispiel einer RCS-Verlaufsdatei </h4><br><pre> <code class="plaintext hljs">head 1.2; access; symbols; locks; strict; comment @# @; 1.2 date 2019.11.25.05.51.55; author jstopak; state Exp; branches; next 1.1; 1.1 date 2019.11.25.05.49.02; author jstopak; state Exp; branches; next ; desc @This is a test. @ 1.2 log @Edited the file. @ text @hi there, you are my bud. You are so cool! The end. @ 1.1 log @Initial revision @ text @d1 5 a5 1 hi there @</code> </pre> <br><a name="cvs"></a><h2>  CVS (Concurrent Versions System): zweite Generation </h2><br>  CVS wurde 1986 von Dick Grun erstellt, um die Versionskontrolle durch Netzwerkunterstützung zu erweitern.  Es ist auch in C geschrieben und markiert die Geburtsstunde der zweiten Generation von VCS-Tools, dank derer geografisch verteilte Entwicklungsteams die Möglichkeit haben, gemeinsam an Projekten zu arbeiten. <br><br><h4>  Architektur </h4><br>  CVS ist ein Frontend für RCS. Es enthält einen neuen Befehlssatz für die Interaktion mit Dateien in einem Projekt. Unter der Haube werden jedoch dasselbe RCS-Verlaufsdateiformat und dieselben RCS-Befehle verwendet.  Mit CVS konnten erstmals mehrere Entwickler gleichzeitig mit denselben Dateien arbeiten.  Dies wird mithilfe eines zentralen Repository-Modells implementiert.  Der erste Schritt besteht darin, ein zentrales Repository mithilfe von CVS auf dem Remoteserver zu konfigurieren.  Projekte können dann in das Repository importiert werden.  Wenn ein Projekt in CVS importiert wird, wird jede Datei in eine Verlaufsdatei <code>,v</code> konvertiert und in einem zentralen Verzeichnis gespeichert: <code></code> .  Das Repository befindet sich normalerweise auf einem Remote-Server, auf den über ein lokales Netzwerk oder das Internet zugegriffen werden kann. <br><br>  Der Entwickler erhält eine Kopie des Moduls, die in das Arbeitsverzeichnis auf seinem lokalen Computer kopiert wird.  Bei diesem Vorgang werden keine Dateien blockiert, sodass die Anzahl der Entwickler, die gleichzeitig mit dem Modul arbeiten können, unbegrenzt ist.  Entwickler können ihre Dateien ändern und Änderungen nach Bedarf festschreiben (Festschreiben).  Wenn ein Entwickler eine Änderung festschreibt, sollten andere Entwickler ihre Arbeitskopien mithilfe des (normalerweise) automatisierten Zusammenführungsprozesses aktualisieren, bevor sie ihre Änderungen festschreiben.  Manchmal müssen Sie Zusammenführungskonflikte vor dem Festschreiben manuell lösen.  CVS bietet auch die Möglichkeit, Zweige zu erstellen und zusammenzuführen. <br><br><h4>  Hauptteams </h4><br><ul><li>  <code>export CVSROOT=&lt;path/to/repository&gt;</code> : <code>export CVSROOT=&lt;path/to/repository&gt;</code> das Stammverzeichnis des CVS-Repositorys fest, damit Sie es nicht in jedem Befehl angeben müssen. <br></li><li>  <code>cvs import -m 'Import module' &lt;module-name&gt; &lt;vendor-tag&gt; &lt;release-tag&gt;</code> : Importiert Verzeichnisse mit Dateien in das CVS-Modul.  Wechseln Sie in das Stammverzeichnis des Projekts, bevor Sie diesen Vorgang starten. <br></li><li>  <code>cvs checkout &lt;module-name&gt;</code> : Kopieren Sie das Modul in das Arbeitsverzeichnis. <br></li><li>  <code>cvs commit &lt;filename.ext&gt;</code> : <code>cvs commit &lt;filename.ext&gt;</code> die geänderte Datei zurück in das Modul im zentralen Repository. <br></li><li>  <code>cvs add &lt;filename.txt&gt;</code> : <code>cvs add &lt;filename.txt&gt;</code> eine neue Datei hinzu, um Änderungen <code>cvs add &lt;filename.txt&gt;</code> . <br></li><li>  <code>cvs update</code> : Aktualisieren Sie die Arbeitskopie, indem Sie festgeschriebene Änderungen zusammenführen, die im zentralen Repository vorhanden sind, jedoch nicht in der Arbeitskopie. <br></li><li>  <code>cvs status</code> : <code>cvs status</code> allgemeine Informationen zur extrahierten Arbeitskopie des Moduls an. <br></li><li>  <code>cvs tag &lt;tag-name&gt; &lt;files&gt;</code> : <code>cvs tag &lt;tag-name&gt; &lt;files&gt;</code> einer Datei oder einer Gruppe von Dateien ein Tag hinzu. <br></li><li>  <code>cvs tag -b &lt;new-branch-name&gt;</code> neuen Zweigs <code>cvs tag -b &lt;new-branch-name&gt;</code> : <code>cvs tag -b &lt;new-branch-name&gt;</code> einen neuen Zweig im Repository (Sie müssen ihn vor der lokalen Arbeit extrahieren). <br></li><li>  <code>cvs checkout -r &lt;branch-name&gt;</code> : Extrahiert eine vorhandene Filiale in das Arbeitsverzeichnis. <br></li><li>  <code>cvs update -j &lt;branch-to-merge&gt;</code> : Führt einen vorhandenen Branch mit einer lokalen Arbeitskopie zusammen. </li></ul><br>  Weitere Informationen zu den internen Komponenten von CVS finden Sie im <a href="https://www.gnu.org/software/trans-coord/manual/cvs/html_node" rel="nofollow">GNU CVS-Handbuch</a> und in <a href="" rel="nofollow">Dick Grohns Artikel</a> . <br><br><h4>  Beispiel für eine CVS-Verlaufsdatei </h4><br><pre> <code class="plaintext hljs">head 1.1; branch 1.1.1; access ; symbols start:1.1.1.1 jack:1.1.1; locks ; strict; comment @# @; 1.1 date 2019.11.26.18.45.07; author jstopak; state Exp; branches 1.1.1.1; next ; commitid zsEBhVyPc4lonoMB; 1.1.1.1 date 2019.11.26.18.45.07; author jstopak; state Exp; branches ; next ; commitid zsEBhVyPc4lonoMB; desc @@ 1.1 log @Initial revision @ text @hi there @ 1.1.1.1 log @Imported sources @ text @@</code> </pre> <br><a name="svn"></a><h2>  SVN (Subversion): Zweite Generation </h2><br>  Subversion wurde im Jahr 2000 von Collabnet Inc. erstellt und wird derzeit von der Apache Software Foundation unterstützt.  Das System ist in C geschrieben und als zuverlässigere zentrale Lösung als CVS konzipiert. <br><br><h4>  Architektur </h4><br>  Wie CVS verwendet Subversion ein zentrales Repository-Modell.  Remotebenutzer benötigen eine Netzwerkverbindung, um eine Festschreibung für das zentrale Repository vorzunehmen. <br><br>  Subversion führte die Funktionalität von Atomic Commits mit der Garantie ein, dass das Commit entweder vollständig erfolgreich ist oder im Falle eines Problems vollständig abgebrochen wird.  In CVS kann das Repository im Falle einer Fehlfunktion während eines Commits (z. B. aufgrund eines Netzwerkfehlers) in einem beschädigten und inkonsistenten Zustand verbleiben.  Darüber hinaus kann ein Commit oder eine Version in Subversion mehrere Dateien und Verzeichnisse enthalten.  Dies ist wichtig, da Sie so Zusammenfassungen verwandter Änderungen als gruppierter Block und nicht wie in früheren Systemen für jede Datei einzeln nachverfolgen können. <br><br>  Subversion verwendet derzeit das Dateisystem FSFS (File System atop the File System).  Hier wird eine Datenbank mit der Struktur von Dateien und Verzeichnissen erstellt, die dem Host-Dateisystem entsprechen.  Ein einzigartiges Merkmal von FSFS ist, dass es nicht nur Dateien und Verzeichnisse, sondern auch deren Versionen nachverfolgen kann.  Dies ist ein zeitkritisches Dateisystem.  Verzeichnisse sind in Subversion auch vollständige Objekte.  Sie können leere Verzeichnisse an das System übergeben, während der Rest (auch Git) sie nicht bemerkt. <br><br>  Wenn Sie ein Subversion-Repository erstellen, wird eine (fast) leere Datenbank mit Dateien und Ordnern in ihrer Zusammensetzung erstellt.  Das Verzeichnis <code>db/revs</code> wird erstellt, in dem alle Versionsverfolgungsinformationen für die hinzugefügten (festgeschriebenen) Dateien gespeichert werden.  Jedes Commit (das Änderungen in mehreren Dateien enthalten kann) wird in einer neuen Datei im <code>revs</code> Verzeichnis gespeichert und erhält einen Namen mit einer fortlaufenden numerischen Kennung, die mit 1 beginnt. Das erste Commit speichert den gesamten Inhalt der Datei.  Zukünftige Commits derselben Datei speichern nur Änderungen, die auch als <code></code> oder Deltas bezeichnet werden, um Speicherplatz zu sparen.  Darüber hinaus werden Deltas mit <code>lz4</code> oder <code>zlib</code> Komprimierungsalgorithmen komprimiert, um die Größe zu verringern. <br><br>  Ein solches System funktioniert nur bis zu einem bestimmten Punkt.  Deltas sparen zwar Platz, aber wenn es viele gibt, ist viel Zeit für den Vorgang erforderlich, da alle Deltas verarbeitet werden müssen, um den aktuellen Status der Datei wiederherzustellen.  Aus diesem Grund speichert Subversion standardmäßig bis zu 1023 Deltas pro Datei und erstellt dann eine neue vollständige Kopie der Datei.  Dies sorgt für ein ausgewogenes Verhältnis von Speicher und Geschwindigkeit. <br><br>  SVN verwendet nicht das übliche Verzweigungs- und Kennzeichnungssystem.  Die reguläre Subversion-Repository-Vorlage enthält drei Ordner im Stammverzeichnis: <br><br><ul><li> <code>trunk/</code> <br> </li><li> <code>branches/</code> <br> </li><li> <code>tags/</code> </li> </ul><br>  Der <code>trunk/</code> Verzeichnis wird für die Produktionsversion des Projekts verwendet.  Das Verzeichnis " <code>branches/</code> - zum Speichern von Unterordnern, die einzelnen Zweigen entsprechen.  Das Verzeichnis <code>tags/</code> dient zum Speichern von Tags, die bestimmte (normalerweise wichtige) Versionen eines Projekts darstellen. <br><br><h4>  Hauptteams </h4><br><ul><li>  <code>svn create &lt;path-to-repository&gt;</code> : Erstellt eine neue leere Repository-Shell im angegebenen Verzeichnis. <br></li><li>  <code>svn import &lt;path-to-project&gt; &lt;svn-url&gt;</code> : Importiert das Dateiverzeichnis in das angegebene Subversion-Repository. <br></li><li>  <code>svn checkout &lt;svn-path&gt; &lt;path-to-checkout&gt;</code> : Kopieren Sie das Repository in das Arbeitsverzeichnis. <br></li><li>  <code>svn commit -m 'Commit message'</code> : Festschreiben einer Reihe geänderter Dateien und Ordner zusammen mit der Nachricht. <br></li><li>  <code>svn add &lt;filename.txt&gt;</code> : Fügt eine neue Datei hinzu, um Änderungen nachzuverfolgen. <br></li><li>  <code>svn update</code> : Aktualisieren Sie die Arbeitskopie, indem Sie festgeschriebene Änderungen zusammenführen, die im zentralen Repository vorhanden sind, jedoch nicht in der Arbeitskopie. <br></li><li>  <code>svn status</code> : Zeigt eine Liste der überwachten Dateien an, die sich im Arbeitsverzeichnis geändert haben (falls vorhanden). <br></li><li>  <code>svn info</code> : allgemeine Informationen zur extrahierten Kopie. <br></li><li>  <code>svn copy &lt;branch-to-copy&gt; &lt;new-branch-path-and-name&gt;</code> : Erstellt einen neuen Zweig, indem ein vorhandener kopiert wird. <br></li><li>  <code>svn switch &lt;existing-branch&gt;</code> : Wechselt das Arbeitsverzeichnis zu einem existierenden Zweig.  Dies ermöglicht es Ihnen, Dateien von dort zu nehmen. <br></li><li>  <code>svn merge &lt;existing-branch&gt;</code> : Führt den angegebenen Zweig mit dem aktuellen Zweig zusammen, der in das Arbeitsverzeichnis kopiert wurde.  Bitte beachten Sie, dass Sie später ein Commit durchführen müssen. <br></li><li>  <code>svn log</code> : <code>svn log</code> den Verlauf der Festschreibungen und die entsprechenden Meldungen für den aktiven Zweig an. </li></ul><br>  Weitere Informationen zu den internen Komponenten von SVN finden Sie unter <a href="http://svnbook.red-bean.com/" rel="nofollow">Subversion-Versionierung</a> . <br><br><h4>  Beispiel einer SVN-Verlaufsdatei </h4><br><pre> <code class="plaintext hljs">DELTA SVN^B^@^@ ^B ^A&lt;89&gt; hi there ENDREP id: 2-1.0.r1/4 type: file count: 0 text: 1 3 21 9 12f6bb1941df66b8f138a446d4e8670c 279d9035886d4c0427549863c4c2101e4a63e041 0-0/_4 cpath: /trunk/hi.txt copyroot: 0 / DELTA SVN^B^@^@$^B%^A¤$K 6 hi.txt V 15 file 2-1.0.r1/4 END ENDREP id: 0-1.0.r1/6 type: dir count: 0 text: 1 5 48 36 d84cb1c29105ee7739f3e834178e6345 - - cpath: /trunk copyroot: 0 / DELTA SVN^B^@^@'^B#^A¢'K 5 trunk V 14 dir 0-1.0.r1/6 END ENDREP id: 0.0.r1/2 type: dir pred: 0.0.r0/2 count: 1 text: 1 7 46 34 1d30e888ec9e633100992b752c2ff4c2 - - cpath: / copyroot: 0 / _0.0.t0-0 add-dir false false false /trunk _2.0.t0-0 add-file true false false /trunk/hi.txt L2P-INDEX ^A&lt;80&gt;@^A^A^A^M^H^@ä^H÷^Aé^FDÎ^Bzè^AP2L-INDEX ^A&lt;91&gt;^E&lt;80&gt;&lt;80&gt;@^A?^@'2^@&lt;8d&gt;»Ý&lt;90&gt;^C§^A^X^@õ ½½^N= ^@ü&lt;8d&gt;Ôã^Ft^V^@&lt;92&gt;&lt;9a&gt;&lt;89&gt;Ã^E; ^@&lt;8a&gt;åw|I^@&lt;88&gt;&lt;83&gt;Î&lt;93&gt;^L`^M^@ù&lt;92&gt;À^Eïú?^[^@^@657 6aad60ec758d121d5181ea4b81a9f5f4 688 75f59082c8b5ab687ae87708432ca406I</code> </pre> <br><a name="git"></a><h2>  Git: dritte Generation </h2><br>  Das Git-System wurde 2005 von Linus Torvalds (Erfinder von Linux) entwickelt.  Es ist hauptsächlich in C in Kombination mit einigen Befehlszeilenskripten geschrieben.  Unterscheidet sich von VCS in Funktionen, Flexibilität und Geschwindigkeit.  Torvalds hat das System ursprünglich für die Linux-Codebasis geschrieben, aber mit der Zeit hat sich sein Anwendungsbereich erweitert, und heute ist es das beliebteste Versionskontrollsystem der Welt. <br><br><h4>  Architektur </h4><br>  Git ist ein verteiltes System.  Es gibt kein zentrales Repository: Alle Kopien werden gleich erstellt, was sich stark vom VCS der zweiten Generation unterscheidet, bei dem die Arbeit auf dem Hinzufügen und Extrahieren von Dateien aus dem zentralen Repository basiert.  Dies bedeutet, dass Entwickler Änderungen sofort miteinander austauschen können, bevor sie ihre Änderungen in einer offiziellen Zweigstelle zusammenführen. <br><br>  Darüber hinaus können Entwickler ihre Änderungen an der lokalen Kopie des Repositorys vornehmen, ohne andere Repositorys zu kennen.  Dies ermöglicht Commits, ohne mit einem Netzwerk oder dem Internet verbunden zu sein.  Entwickler können lokal offline arbeiten, bis sie bereit sind, ihre Arbeit mit anderen zu teilen.  Zu diesem Zeitpunkt werden die Änderungen zur Überprüfung, zum Testen oder zur Bereitstellung an andere Repositorys gesendet. <br><br>  Wenn eine Datei zum Verfolgen in Git hinzugefügt wird, wird sie mit dem <code>zlib</code> Komprimierungsalgorithmus komprimiert.  Das Ergebnis wird mit der SHA-1-Hash-Funktion gehasht.  Dies ergibt einen eindeutigen Hash, der speziell mit dem Inhalt dieser Datei übereinstimmt.  Git speichert es in der <code> </code> , die sich in einem versteckten Ordner <code>.git/objects</code> .  Der Dateiname ist der generierte Hash und die Datei enthält komprimierten Inhalt.  Diese Dateien werden als <code></code> und jedes Mal erstellt, wenn eine neue Datei (oder eine geänderte Version einer vorhandenen Datei) zum Repository hinzugefügt wird. <br><br>  Git implementiert einen Staging-Index, der als Zwischenbereich für Änderungen dient, die für das Festschreiben vorbereitet werden.  Bei der Vorbereitung neuer Änderungen wird auf deren komprimierten Inhalt in einer speziellen Indexdatei verwiesen, die die Form eines Baumobjekts hat.  Ein Baum ist ein Git-Objekt, das Blobs mit ihren tatsächlichen Dateinamen, Dateiberechtigungen und Verknüpfungen zu anderen Bäumen verknüpft und somit den Status einer bestimmten Gruppe von Dateien und Verzeichnissen darstellt.       ,      ,    <code></code>     Git.        ,     ,   ,    .         (-),        . <br><br>   ,   Git — ,    — ,           .   <code> </code> (loose objects).        ,   Git  ,          .   ,       ,            Git     <code> </code> .      ,        .     <code>.pack</code>   ,        <code>.idx</code> ( )           . <br><br>          ,      .               . <br><br><h4>   </h4><br><ul><li> <code>git init</code> :      Git (   <code>.git</code>   ). <br></li><li> <code>git clone &lt;git-url&gt;</code> :    Git   URL. <br></li><li> <code>git add &lt;filename.ext&gt;</code> :         (      ). <br></li><li> <code>git commit -m 'Commit message'</code> :           . <br></li><li> <code>git status</code> :    ,  ,  ,    . . <br></li><li> <code>git branch &lt;new-branch&gt;</code> :        . <br></li><li> <code>git checkout &lt;branch&gt;</code> :      . <br></li><li> <code>git merge &lt;branch&gt;</code> :     ,     . <br></li><li> <code>git pull</code> :   ,     ,     ,     . <br></li><li> <code>git push</code> :                . <br></li><li> <code>git log</code> :         . <br></li><li> <code>git stash</code> :         ,    . </li></ul><br>   ,    Git,   <a href="https://initialcommit.io/" rel="nofollow"> Git  </a> .      .  <a href="https://book.git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain" rel="nofollow">   Pro Git</a> . <br><br><h4>  ,    Git </h4><br>    <code>37d4e6c5c48ba0d245164c4e10d5f41140cab980</code> : <br><br><pre> <code class="plaintext hljs">hi there</code> </pre> <br>     <code>b769f35b07fbe0076dcfc36fd80c121d747ccc04</code> : <br><br><pre> <code class="plaintext hljs">100644 blob 37d4e6c5c48ba0d245164c4e10d5f41140cab980hi.txt</code> </pre> <br>    <code>dc512627287a61f6111705151f4e53f204fbda9b</code> : <br><br><pre> <code class="plaintext hljs">tree b769f35b07fbe0076dcfc36fd80c121d747ccc04 author Jacob Stopak 1574915303 -0800 committer Jacob Stopak 1574915303 -0800 Initial commit</code> </pre> <br><a name="hg"></a><h2> Mercurial:   </h2><br> Mercurial   2005       Python.        Linux,        Git.       ,     . <br><br><h4>  Architektur </h4><br> Mercurial —   ,             . Mercurial      ,   Git,       SHA-1,    . <br><br>        Mercurial,      <code>revlog</code>    <code>.hg/store/data/</code> .    <code>revlog</code> ( )    <code> </code>   VCS,   CVS, RCS  SCCS.    Git,          , Mercurial      revlog   .            .     ,     .              . <br><br>  revlog     ,   ,    <code>.i</code>  <code>.d</code> .  <code>.d</code>   .  <code>.i</code>            <code>.d</code> .              <code>.i</code> .   revlog       .  -  <code>nodeid</code> . <br><br>    Mercurial          <code></code> .     revlog —    ,    .    ,  revlog,       nodeids,  ,       .       . -   <code>nodeid</code> . <br><br> , Mercurial     revlog,   changelog,    .   ,       : <br><br><ul><li> nodeid :    ,      . <br></li><li>    nodeid   :   Mercurial       .      (  )      ID. <br></li><li>   <br></li><li>   <br></li><li>   </li></ul><br>   changelog   ,    <code>nodeid</code> . <br><br><h4>   </h4><br><ul><li> <code>hg init</code> :      Mercurial (   <code>.hg</code>   ). <br></li><li> <code>hg clone &lt;hg-url&gt;</code> :    Mercurial   URL. <br></li><li> <code>hg add &lt;filename.ext&gt;</code> :      . <br></li><li> <code>hg commit -m 'Commit message'</code> :          . <br></li><li> <code>hg status</code> :  ,     ,  ,    .. <br></li><li> <code>hg update &lt;revision&gt;</code> :      . <br></li><li> <code>hg merge &lt;branch&gt;</code> :     ,    . <br></li><li> <code>hg pull</code> :      ,       . <br></li><li> <code>hg push</code> :      . <br></li><li> <code>hg log</code> :           . </li></ul><br><h4>   Mercurial </h4><br> : <br><br><pre> <code class="plaintext hljs">hey.txt208b6e0998e8099b16ad0e43f036ec745d58ec04 hi.txt74568dc1a5b9047c8041edd99dd6f566e78d3a42</code> </pre> <br>   (changelog): <br><br><pre> <code class="plaintext hljs">b8ee947ce6f25b84c22fbefecab99ea918fc0969 Jacob Stopak 1575082451 28800 hey.txt Add hey.txt</code> </pre> <br>     Mercurial: <br><br><ul><li> <a href="http://hgbook.red-bean.com/read/behind-the-scenes.html" rel="nofollow">  '  Mercurial</a> </li><li> <a href="https://www.mercurial-scm.org/wiki/Revlog" rel="nofollow"> Mercurial (Revlog)</a> </li><li> <a href="https://www.mercurial-scm.org/wiki/ChangeSet" rel="nofollow"> Mercurial (ChangeSet)</a> </li><li> <a href="https://www.mercurial-scm.org/wiki/Manifest" rel="nofollow"> Mercurial (Manifest)</a> </li><li> <a href="https://www.mercurial-scm.org/wiki/Revision" rel="nofollow"> Mercurial (Revision)</a> </li><li> <a href="https://www.mercurial-scm.org/wiki/Nodeid" rel="nofollow"> Mercurial (Nodeid)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478752/">https://habr.com/ru/post/de478752/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478728/index.html">Die 9 besten Open Source-Funde für November 2019</a></li>
<li><a href="../de478736/index.html">Die Zukunft der künstlichen Intelligenz im Bildungssystem: Alles, was man wissen sollte</a></li>
<li><a href="../de478740/index.html">Go to Go! Wie das PHP-Team dazu kam, Microservices zu schreiben</a></li>
<li><a href="../de478748/index.html">SSDs für Zuverlässigkeitstests: 3dnews vs JEDEC vs common sense. Wo ist die Wahrheit, Bruder?</a></li>
<li><a href="../de478750/index.html">Aktuelle Datenvisualisierungsbibliotheken für Reaktionsentwickler</a></li>
<li><a href="../de478758/index.html">Hervorragende UTM-Tag-Anleitung: So finden Sie heraus, woher Benutzer kommen</a></li>
<li><a href="../de478760/index.html">"Zero" Hölle und wie man da rauskommt</a></li>
<li><a href="../de478764/index.html">JavaScript-Fehler: beheben, verarbeiten, reparieren</a></li>
<li><a href="../de478766/index.html">Passen Sie die Zuordnung von Spring MVC-Controllern an</a></li>
<li><a href="../de478772/index.html">Faltungsstruktur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>