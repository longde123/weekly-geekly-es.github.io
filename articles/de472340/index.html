<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏼 👏 🌡️ Hat GraphQL in der HTTP / 2-Ära an Relevanz verloren? 🚢 🏇🏿 👩‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Phil Sturgeon hat kürzlich einen Tweet gepostet, der GraphQL-Fans sehr getroffen hat. In diesem Tweet wurde darüber gesprochen, wie GraphQL per Defini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hat GraphQL in der HTTP / 2-Ära an Relevanz verloren?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472340/">  Phil Sturgeon hat kürzlich einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://twitter.com/philsturgeon/status/1177804924064804864%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%26ref_url%3Dhttps%253A%252F%252Fcdn.embedly.com%252Fwidgets%252Fmedia.html%253Ftype%253Dtext%25252Fhtml%2526key%253Da19fcc184b9711e1b4764040d3dc5c07%2526schema%253Dtwitter%2526url%253Dhttps%25253A%252F%252Ftwitter.com%252Fphilsturgeon%252Fstatus%252F1177804924064804864%2526image%253Dhttps%25253A%252F%252Fi.embed.ly%252F1%252Fimage%25253Furl%25253D">Tweet</a> gepostet, der GraphQL-Fans sehr getroffen hat.  In diesem Tweet wurde darüber gesprochen, wie GraphQL per Definition eine Technologie ist, die dem Wesen von HTTP / 2 widerspricht.  Die Tatsache, dass der HTTP / 3-Standard bereits veröffentlicht wurde und dass der Autor des Tweets diejenigen nicht wirklich versteht, die sich bei der Auswahl von GraphQL auf den Weg der Inkompatibilität begeben.  Schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material an, um die Gründe für Phils Einstellung zu GraphQL besser zu verstehen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/f6/_e/s9/f6_es9rltblh2sxhiesno4aznac.jpeg"></a> <br><br>  Etwa zur gleichen Zeit wurde eine Ankündigung über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vulcain-</a> Projekt gemacht.  Diese Nachricht enthielt die Worte: "TL / DR: GraphQL, das Sie nicht mehr benötigen!".  Und schließlich wurde ein großartiger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von</a> Mark Nottingham über die leistungsstarken Funktionen von HTTP / 2 und die Bedeutung dieser Funktionen für diejenigen veröffentlicht, die die API entwerfen.  Darrel Miller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://twitter.com/darrel_miller/status/1183425699677376515%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%26ref_url%3Dhttps%253A%252F%252Fcdn.embedly.com%252Fwidgets%252Fmedia.html%253Ftype%253Dtext%25252Fhtml%2526key%253Da19fcc184b9711e1b4764040d3dc5c07%2526schema%253Dtwitter%2526url%253Dhttps%25253A%252F%252Ftwitter.com%252Fdarrel_miller%252Fstatus%252F1183425699677376515%2526image%253Dhttps%25253A%252F%252Fi.embed.ly%252F1%252Fimage%25253Furl%25253D">hat einen</a> Link zu diesem Artikel mit seinen Abonnenten geteilt. <br><br>  Was geschah, ließ mich über GraphQL und HTTP / 2 nachdenken.  Wenn alles mit HTTP / 2 (und HTTP / 3) funktioniert, haben wir dann keinen Grund, GraphQL zu verwenden?  Ich würde es heute gerne herausfinden. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">HTTP / 2-Innovationen</font> </h2><br>  Lassen Sie uns zunächst herausfinden, was die HTTP / 2-Technologie in den Augen der Entwickler auf den Wert von GraphQL auswirken kann.  HTTP / 2 hat viel zu bieten.  Dies ist beispielsweise ein neues Binärformat und eine verbesserte Header-Komprimierung.  In unserem Fall spielt die Hauptrolle jedoch die Verarbeitung der Übermittlung von Anforderungen und Antworten bei Verwendung von HTTP / 2. <br><br>  Das Öffnen einer TCP-Verbindung ist eine kostspielige Operation.  Clients, die HTTP / 1 verwenden, führen es normalerweise nicht zu oft aus.  Aus diesem Grund haben Entwickler aufgrund der großen zusätzlichen Belastung des Systems häufig versucht, die Anzahl der Anforderungen zu begrenzen, indem sie auf eine Vielzahl von Technologien zurückgegriffen haben.  Dies können beispielsweise Stapelabfragen ausführen, Abfragesprachen verwenden, CSS / JS-Code in den Seitencode einbetten, Sprite-Blätter anstelle einzelner Bilder verwenden usw.  In HTTP / 1.1.  Es wurde versucht, einige dieser Probleme mithilfe von dauerhaften Verbindungen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pipeline-</a> Datenverarbeitung zu lösen.  Diese beiden Technologien ermöglichten es Browsern, innerhalb derselben Verbindung mehrere Anfragen zu senden und Antworten darauf zu erhalten.  Der Nachteil eines solchen Datenaustauschschemas bestand darin, dass es dem Problem unterworfen war, den Beginn der Warteschlange zu blockieren ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Head-of-Line-Blockierung</a> ).  Dieses Problem drückt sich darin aus, dass eine langsame Anforderung die Verarbeitung aller darauf folgenden Anforderungen verlangsamen kann.  Die Experten, die an HTTP / 2 gearbeitet haben, schlugen verschiedene Möglichkeiten zur Lösung dieses Problems vor.  Zusammen mit dem neuen Binärprotokoll führt HTTP / 2 eine neue Datenlieferungsstrategie ein.  Während der Interaktion von Systemen, die das HTTP / 2-Protokoll verwenden, wird eine einzelne Verbindung geöffnet, in deren Rahmen das Multiplexen von Anforderungen und Antworten unter Verwendung einer neuen Binärebene durchgeführt wird, die für die Arbeit mit Frames ausgelegt ist, wenn jeder Frame Teil eines Streams ist.  Mithilfe dieses Mechanismus können Clients und Server Anforderungs- und Antwortflüsse basierend auf den Informationen in Frames neu erstellen.  Dadurch kann HTTP / 2 die Verarbeitung vieler Anforderungen, die innerhalb einer einzelnen Verbindung ausgeführt werden, sehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">effektiv</a> unterstützen. <br><br>  Das ist aber noch nicht alles.  HTTP / 2 hat ein neues Konzept namens Server Push.  Wenn Sie nicht auf Details eingehen, können wir sagen, dass diese Technologie es Servern ermöglicht, Daten im Voraus an Clients zu senden, bevor Clients diese Daten anfordern.  Die auffälligsten Beispiele für dieses Verhalten sind das Senden von Stylesheets und JavaScript-Ressourcen an Clients im Voraus.  Beim Generieren einer Antwort auf die HTTP-Anforderung kann der Server feststellen, dass zum Rendern der HTML-Seite eine CSS-Datei erforderlich ist, und im Voraus feststellen, dass der Client ihn in Kürze für diese Datei kontaktieren wird.  Auf diese Weise kann der Server die angegebene Datei an den Client senden, noch bevor der Client sie anfordert.  So funktioniert das oben erwähnte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vulcain-</a> Projekt, bei dem mithilfe dieser Technologie das effiziente Laden verwandter Ressourcen organisiert wird. <br><br>  Also, während alles klar ist.  Aber was hat das alles mit GraphQL zu tun? <br><br><h2>  <font color="#3AC1EF">GraphQL: Eine Abfrage, die alle Probleme löst</font> </h2><br>  Die GraphQL-Technologie ist teilweise auf ihre Attraktivität zurückzuführen, da sie Entwicklern hilft, die für HTTP / 1-Verbindungen typischen Nachteile zu bewältigen. <br><br>  Aus diesem Grund können Kunden mit GraphQL in einer Sitzung mit dem Server kommunizieren und Anforderungen erfüllen, um fast alles zu empfangen.  Dies kann mit der Hypermedia-API verglichen werden, bei deren Verwendung Sie normalerweise viele Netzwerkanforderungen ausführen müssen (manchmal kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Caching</a> jedoch die Situation verbessern). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f6/f7d/0f7/3f6f7d0f7d89abc5c854fd576e3f32f7.png"></div><br>  <i><font color="#999999">Die Fähigkeit, mehrere Ressourcen innerhalb einer einzigen Abfrage zu empfangen, ist eine der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stärken</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GraphQL</a> , auf die die Entwickler dieser Technologie die Aufmerksamkeit ihrer potenziellen Benutzer lenken.</font></i> <br><br>  Viele von denen, die sagen, dass mit dem Aufkommen von HTTP / 2 niemand GraphQL-Technologie benötigt, meinen diese Möglichkeit.  Die Verwendung von Batch-APIs, Abfragesprachen (wie GraphQL), die Optimierung von Beziehungen und sogar die Erstellung aggregierter Endpunkte sind jetzt weniger attraktiv als zuvor.  Die Sache ist, dass die "Kosten" für die Durchführung von Abfragen gering werden.  Und das ist wahr.  Aber verwenden wir GraphQL nur deshalb?  Ich glaube nicht. <br><br><h2>  <font color="#3AC1EF">Vielleicht ist die Tatsache, dass jetzt noch die Anfänge von HTTP / 2-Clients und einigen Serveranwendungen sind?</font> </h2><br>  Ich denke nicht, dass die im Titel dieses Abschnitts gestellte Frage eine würdige Erklärung für die Tatsache darstellt, dass wir GraphQL immer noch weit verbreitet verwenden.  Aber es ist erwähnenswert.  Die Verwendung von HTTP / 2 auf Anwendungsebene in einigen Ökosystemen ist eine Herausforderung, die noch lange nicht gelöst ist.  Suchen Sie beispielsweise nach den Wörtern "Rack / Rails über HTTP / 2."  Es wird interessant sein.  Die Sache ist, dass viele Serverteile von Anwendungen unter Verwendung des Anforderungs- / Antwortmusters erstellt werden.  Daher ist der Wechsel zum Konzept der HTTP / 2-Streams nicht so einfach.  Besonders - bei einigen Frameworks.  Dies ist jedoch eine unwürdige Ausrede. Viele Ökosysteme unterstützen dieses Interaktionsschema zwischen Clients und Servern perfekt, und theoretisch sollten wir uns weiterhin bemühen, diese Interaktion zu verbessern.  (Die meisten Proxys unterstützen dies ebenfalls, aber es ist nicht einfach, auf Initiative des Servers Daten wie das Senden von Daten an einen Client zu organisieren, wenn die Serveranwendung in der Vergangenheit mithilfe eines Anforderungs- / Antwortmusters hängen geblieben ist.) <br><br><h2>  <font color="#3AC1EF">GraphQL ist mehr als die Verkürzung der Zeit zum Empfangen und Senden von Daten oder die Optimierung der übertragenen Informationsmenge</font> </h2><br>  Obwohl die Verkürzung der Zeit zum Empfangen und Senden von Daten und die Optimierung der Menge der übertragenen Informationen die Stärken von GraphQL sind, von denen wir ständig hören, bietet uns diese Technologie viel mehr. <br><br>  Die Stärke der GraphQL-Technologie liegt in der Fokussierung auf Client-Systeme.  Der Client ist die Umgebung, in der GraphQL viele Kompromisse eingeht.  In den letzten Jahren hat dies viele gestört.  Daniel Jacobson hat vor 5-7 Jahren viele gute Artikel über einige dieser Probleme geschrieben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">da</a> - ein paar seiner Publikationen.  In einem von ihnen sagt er: „Unsere REST-APIs sind zwar in der Lage, allgemeine Anforderungen zu verarbeiten, sind jedoch für keine dieser Anforderungen optimiert.“ <br><br>  Bitte beachten Sie, dass diese Idee nicht nur für die REST-Technologie gilt.  Clientanwendungen müssen häufig mehr Serveranforderungen ausführen, als ihre Entwickler möchten.  Diese Anwendungen müssen sich mit dem Empfang unnötiger Daten von Servern befassen.  Hier geht es mehr darum, APIs zu entwerfen, die sich gut erstellen lassen, damit sie viele verschiedene Verwendungszwecke unterstützen.  Die übliche Methode zur Lösung dieses Problems besteht darin, die Client-Logik so nah wie möglich an der Server-Logik zu halten.  Ein Beispiel für diesen Ansatz sind die in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Artikel von 2012 erwähnten Netflix-Clientadapter.  Seitdem haben einige Netflix-Teams sogar auf GraphQL umgestellt.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BFF-</a> Muster zielt auch darauf ab, solche Probleme zu lösen. <br><br>  Die GraphQL-Technologie ändert das Konzept der Grenze zwischen Client und Server und hilft uns dabei, Serversysteme zu erstellen, die Informationen darüber enthalten können, wie sie von Clients verwendet werden.  Dies zeigt sich ganz deutlich bei der Verwendung der Technologie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ständiger</a> Anforderungen, da es sich hier im Wesentlichen um Serverressourcen handelt, die auf Initiative des Clients generiert werden. <br><br>  Denken Sie beim Nachdenken über die Relevanz von GraphQL in der HTTP / 2-Welt daran, dass es sich um Serverabstraktion handelt.  Die Unterstützung einer Vielzahl von Anwendungsfällen für Serverdaten kann zu Problemen bei herkömmlichen endpunktbasierten APIs führen.  Mit GraphQL können sich diejenigen, die die API unterstützen, darauf konzentrieren, Benutzern dieser APIs eine breite Palette von Funktionen zur Verfügung zu stellen.  Gleichzeitig machen sich die Eigentümer der API möglicherweise keine Sorgen über die zunehmende Belastung bestehender Clients und darüber, dass die Unterstützung für die API aufgrund der Notwendigkeit, viele verschiedene Ressourcen zu unterstützen, viel komplizierter wird.  (Die Unterstützung vieler verschiedener Ressourcen hat ihre Nachteile. Daher erschweren solche Schemata die Leistungsoptimierung. Solche Ressourcen werden nicht immer gut zwischengespeichert. APIs, die stark optimiert werden können, haben dieselben Probleme.) <br><br><h2>  <font color="#3AC1EF">Client-Systeme und GraphQL-Entwicklung</font> </h2><br>  In diesem Artikel spreche ich hauptsächlich über Server, aber es ist wichtig zu bedenken, dass Client-Entwickler die GraphQL-Technologie sehr mögen.  Wenn Sie GraphQL-Fragmente mit dem Komponentenansatz moderner Front-End-Frameworks kombinieren, erhalten Sie eine völlig erstaunliche Abstraktion.  Und wenn wir hier ständig Abfragen hinzufügen, können wir sagen, dass GraphQL Entwicklern von Client-Systemen das Leben erleichtert. <br><br><h2>  <font color="#3AC1EF">GraphQL ist ein ganzheitliches System mit bemerkenswerten Funktionen</font> </h2><br>  GraphQL verfügt nicht über völlig einzigartige Funktionen.  Es gibt Alternativen zu diesem System.  Typisiertes Schema?  Das gleiche gilt für OpenAPI!  Server-Abstraktionen, die verschiedene Client-Anwendungsfälle unterstützen?  Dies kann auf viele Arten implementiert werden.  Selbstbeobachtung?  Mithilfe von Hypermedia können Clients Aktionen erkennen und mit der Stammentität arbeiten.  Ein köstliches GraphiQL-Tool?  Ich bin sicher, dass etwas Ähnliches für OpenAPI erstellt wurde.  Die Möglichkeiten von GraphQL können immer mit anderen Technologien neu erstellt werden.  GraphQL ist jedoch ein ganzheitliches System.  Dies ist es, was ein so großes Publikum von Entwicklern für GraphQL anzieht, die dieses System gerne nutzen.  Ich vermute, dass dies einer der Gründe für die schnelle Verbreitung und Entwicklung von GraphQL ist.  Da der Aufbau der GraphQL-API gut dokumentiert ist, sind GraphQL-Bibliotheken, die für verschiedene Sprachen entwickelt wurden, normalerweise von hoher Qualität und Beliebtheit. <br><br><h2>  <font color="#3AC1EF">Die Vernetzung ist immer noch ein begrenzender Faktor (oder wird es immer so sein?)</font> </h2><br>  Hier ist ein weiterer Gedanke, auf den ich näher eingehen möchte.  Es besteht das Gefühl, dass das Netzwerk bei der Arbeit mit der API immer die Rolle eines begrenzenden Faktors spielt.  Es spielt keine Rolle, wie schnell die Netzwerkanforderungen sind.  Aus diesem Grund entwerfen wir Web-APIs nicht auf die gleiche Weise wie normale Objekte, die in verschiedenen Programmiersprachen verwendet werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> sprechen wir zum Beispiel darüber, warum Schnittstellen mit einem hohen Detaillierungsgrad nicht sehr gut geeignet sind, um Systeme zu erstellen, die für die Remote-Arbeit mit ihnen ausgelegt sind. <br><br>  Während HTTP / 2 definitiv die Ausführung von Anforderungen mit hoher Granularität fördert, denke ich, dass hier einige Kompromisse gemacht werden müssen. <br><br><h2>  <font color="#3AC1EF">Kann HTTP / 2 GraphQL helfen?</font> </h2><br>  GraphQL bietet dem Entwickler viele wichtige und nützliche Tools, aber HTTP / 2 ist auch eine großartige Technologie.  Lassen Sie uns in die Zukunft schauen und über die Vorteile nachdenken, die GraphQL-Systeme von der Verwendung von HTTP / 2 profitieren können.  Zum Beispiel könnte es so aussehen: <br><br><pre><code class="plaintext hljs">query {   viewer {     name     posts(first: 100) @stream {       title     }   } }</code> </pre> <br>  Es stellt sich heraus, dass wir die serverseitige Abstraktion von GraphQL, der deklarativen Abfragesprache dieser Technologie, gut nutzen und gleichzeitig die Funktionen von HTTP / 2-Streams nutzen können.  Ich denke, dass hier Web-Sockets verwendet werden.  Ich muss das noch herausfinden, aber ich bin sicher, dass viele bereits GraphQL-Anweisungen wie <code>@defer</code> , <code>@stream</code> und <code>@live</code> . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  HTTP / 2 ist eine großartige Technologie (und die hier aufgeführten Beispiele sind nur eine Art Wunder).  GraphQL kann nur als eine Technologie wahrgenommen werden, die die Anzahl der Client-Server-Kommunikationssitzungen reduziert oder zur Optimierung des übertragenen Datenvolumens beiträgt.  Wenn ja, kann jeder, der GraphQL aus einer ähnlichen Perspektive betrachtet, APIs verwenden, die auf HTTP / 2-Funktionen basieren.  Wenn Sie jedoch in GraphQL eine Kombination von Technologien sehen, die dem Entwickler viele nützliche Dinge bieten, wird klar, dass die Leistungsfähigkeit von GraphQL keineswegs darauf beschränkt ist, die Nutzung von Netzwerkressourcen zu verbessern und Datenverkehr zu sparen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie die GraphQL-Technologie verwenden, teilen Sie uns bitte mit, was Ihnen am besten gefällt. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472340/">https://habr.com/ru/post/de472340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472320/index.html">Interview mit Zabbix: 12 offene Antworten</a></li>
<li><a href="../de472326/index.html">Unsere Raumfahrtindustrie ... Und wenn Sie die Probleme der Branche aus der Perspektive eines Geeks betrachten?</a></li>
<li><a href="../de472334/index.html">Leben durch Gutscheine oder wie wir die Arbeit der sozialen Dienste optimieren</a></li>
<li><a href="../de472336/index.html">Beschleunigung instagram.com. Teil 3</a></li>
<li><a href="../de472338/index.html">Wer ist der JavaScript-Killer?</a></li>
<li><a href="../de472344/index.html">Zwei "Gefährten" oder Bürgerkrieg Phlogiston</a></li>
<li><a href="../de472350/index.html">Wie Methodius zu Anna wurde: die Erfahrung, Sprachnachrichten-Klassifikatoren zu entwickeln und zu starten. Teil 1</a></li>
<li><a href="../de472352/index.html">TechnoText, Folge II. Wir erzählen, wie die Autoren von Habr an Artikeln leben und arbeiten</a></li>
<li><a href="../de472354/index.html">Zwischen dem Stuhl und dem Monitor befindet sich die Hauptschwachstelle im System: VAP-Person</a></li>
<li><a href="../de472356/index.html">Microsoft vs IBM: Wichtige Änderungen in der Java-Unterstützung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>