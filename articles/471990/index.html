<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüíº üàÅ üéå Meta gram√°tica para el analizador PEG ü§∑ üëâüèø üëõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta semana estamos haciendo que el generador de analizadores sea "independiente", es decir, generar√° su propio analizador. 
 Contenido de la serie Py...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta gram√°tica para el analizador PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471990/"><p>  Esta semana estamos haciendo que el generador de analizadores sea "independiente", es decir, generar√° su propio analizador. </p><br><div class="spoiler">  <b class="spoiler_title">Contenido de la serie Python PEG Parser</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Analizadores de clavijas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n del analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Generador de analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Visualizaci√≥n del analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gram√°tica de PEG recursiva izquierda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Agregar acciones a la gram√°tica PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Meta gram√°tica para el analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementando las caracter√≠sticas restantes de PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PEG en Core Developer Sprint</a> </li></ul></div></div><br><p> Entonces, ya tenemos un generador de analizadores, parte del cual es un analizador de gram√°tica.  Podr√≠amos llamarlo un meta-analizador.  El meta-analizador funciona de manera similar al generado: <code>GrammarParser</code> hereda de <code>Parser</code> y usa el mismo mecanismo <code>mark()</code> / <code>reset()</code> / <code>hope()</code> .  Sin embargo, all√≠ estaba todo escrito a mano.  ¬øPero es eso correcto? </p><a name="habracut"></a><br><p>  Al dise√±ar un compilador, es habitual que el compilador se escriba en el lenguaje que compila.  Recuerdo con amor que el compilador Pascal que utilic√© cuando aprend√≠ a programar estaba escrito en Pascal, GCC est√° escrito en C y el compilador Rust est√° escrito en Rust. </p><br><p>  Como hacerlo  Al principio, implemente un compilador para un subconjunto o una versi√≥n anterior de un idioma en otro idioma.  (¬°Perm√≠tame recordarle que el compilador Pascal original se escribi√≥ en FORTRAN!) Luego, el nuevo compilador se escribe en el idioma de destino y se compila utilizando el compilador bootstrap implementado al principio.  Tan pronto como el nuevo compilador comienza a funcionar lo suficientemente bien, el compilador de arranque se elimina y cada versi√≥n posterior del lenguaje o compilador se limita a lo que se puede compilar usando la versi√≥n anterior del compilador. </p><br><p>  Hag√°moslo para nuestro meta analizador.  Escribiremos una gram√°tica para la gram√°tica (meta-gram√°tica), y luego generaremos un nuevo meta-analizador a partir de esto.  Afortunadamente, plane√© este movimiento desde el principio, por lo que ser√° bastante simple.  Las acciones que agregamos en el episodio anterior son un componente importante porque no necesitamos cambiar el generador, por lo que necesitamos crear una estructura de datos compatible. </p><br><p>  Aqu√≠ hay una versi√≥n simplificada del metagrama sin acciones: </p><br><pre> <code class="plaintext hljs">start: rules ENDMARKER rules: rule rules | rule rule: NAME ":" alts NEWLINE alts: alt "|" alts | alt alt: items items: item items | item item: NAME | STRING</code> </pre> <br><p>  Te mostrar√© c√≥mo agregar acci√≥n de abajo hacia arriba.  Recuerde de la Parte 3 que hay objetos <code>Rule</code> que tienen el <code>name</code> y los <code>alts</code> .  Inicialmente, <code>alts</code> era solo una lista de listas de l√≠neas (una lista externa para alternativas y una lista interna para cada elemento de la alternativa), pero para implementar las acciones, la cambi√© para que las alternativas fueran representadas por objetos <code>Alt</code> con <code>items</code> y atributos de <code>action</code> .  Los elementos todav√≠a se representan como cadenas simples.  Por <code>item</code> obtenemos: </p><br><pre> <code class="plaintext hljs">item: NAME { name.string } | STRING { string.string }</code> </pre> <br><p>  Esto requiere una peque√±a explicaci√≥n: cuando el analizador procesa el token, devuelve un objeto <code>TokenInfo</code> que tiene <code>type</code> , <code>string</code> y otros atributos.  No queremos que el generador <code>TokenInfo</code> objetos <code>TokenInfo</code> , por lo que las acciones aqu√≠ extraen la cadena del token.  Tenga en cuenta que para todos los tokens en may√∫sculas, como <code>NAME</code> , el analizador generado utiliza la versi√≥n de cadena (aqu√≠ <code>name</code> ) como el nombre de la variable. </p><br><p>  A continuaci√≥n hay <code>items</code> que deber√≠an devolver una lista de cadenas: </p><br><pre> <code class="plaintext hljs">items: item items { [item] + items } | item { [item] }</code> </pre> <br><p>  Aqu√≠ uso reglas recursivas a la derecha, por lo que no dependemos del procesamiento de la recursividad izquierda, que se agrega en la Parte 5. (¬øPor qu√© no? Siempre es bueno mantener las cosas lo m√°s simple posible, y esta gram√°tica no se beneficiar√° en gran medida de un cambio en la recursi√≥n izquierda). <code>item</code> lista, pero los <code>items</code> recursivamente no lo est√°n, ya que ya es una lista. </p><br><p>  Regla <code>alt</code> para crear un objeto <code>Alt</code> : </p><br><pre> <code class="plaintext hljs">alt: items { Alt(items) }</code> </pre> <br><p>  Omitir√© las acciones para las <code>rules</code> y <code>start</code> , ya que se definen de esta manera. </p><br><p>  Sin embargo, hay dos preguntas abiertas.  Primero, ¬øc√≥mo encuentro la definici√≥n de las clases <code>Rule</code> y <code>Alt</code> ?  Para hacer esto, necesitamos agregar varias declaraciones de <code>import</code> al c√≥digo generado.  La forma m√°s sencilla ser√≠a pasar la bandera al generador, que dice "esto es una metagram√°tica", y dejar que el generador inserte una <code>import</code> adicional al comienzo del programa generado.  Pero ahora que tenemos las acciones, muchos otros analizadores tambi√©n querr√°n personalizar su importaci√≥n, entonces, ¬øpor qu√© no ver si podemos implementar un enfoque m√°s general? </p><br><p>  Hay muchas formas de implementarlo.  Un mecanismo simple y general es agregar una secci√≥n de "definiciones de variables" en la parte superior de la gram√°tica y permitir que el generador use estas variables para controlar varios aspectos del c√≥digo generado.  Decid√≠ usar el s√≠mbolo <code>@</code> para comenzar a definir la variable, seguido del nombre de la variable ( <code>NAME</code> ) y el valor ( <code>STRING</code> ).  Por ejemplo, podemos poner el siguiente bloque de c√≥digo en la parte superior de la metagram√°tica: </p><br><pre> <code class="plaintext hljs">@subheader "from grammar import Rule, Alt"</code> </pre> <br><p>  El generador de analizador imprimir√° el valor de la variable del <code>subheader</code> despu√©s de la importaci√≥n est√°ndar, que se agrega de forma predeterminada (por ejemplo, para importar <code>memoize</code> ).  Si desea m√∫ltiples elementos de <code>import</code> , puede usar una cadena con comillas triples, por ejemplo, </p><br><pre> <code class="plaintext hljs">@subheader """ from token import OP from grammar import Rule, Alt """</code> </pre> <br><p>  Esto es f√°cil de agregar a la meta-gram√°tica: dividiremos la regla de <code>start</code> en lo siguiente: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER | rules ENDMARKER metas: meta metas | meta meta: "@" NAME STRING NEWLINE</code> </pre> <br><p>  (No recuerdo por qu√© lo llam√© "meta", pero eleg√≠ este nombre cuando escrib√≠ el c√≥digo, y me atendr√© a √©l. :-) </p><br><p>  Debemos agregar esto al metaparser bootstrap.  Ahora que la gram√°tica no es solo una lista de reglas, agreguemos un objeto de gram√°tica con los atributos de <code>metas</code> y <code>rules</code> .  Podemos establecer las siguientes acciones: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING { (name.string, eval(string.string)) }</code> </pre> <br><p>  (Tenga en cuenta que <code>meta</code> devuelve una tupla; y tambi√©n que usa <code>eval()</code> para procesar comillas). </p><br><p>  ¬°No mencion√© la implementaci√≥n de acciones en las reglas para <code>alt</code> !  La raz√≥n es que salen un poco desordenados.  Pero no tiene sentido posponer m√°s, as√≠ que aqu√≠: </p><br><pre> <code class="plaintext hljs">alt: items action { Alt(items, action) } | items { Alt(items, None) } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  La suciedad en la definici√≥n es causada por mi deseo de hacer que el c√≥digo arbitrario de Python sea v√°lido entre llaves de acci√≥n rizadas, incluidas las anidadas en otras llaves.  Para este prop√≥sito, utilizamos un token <code>OP</code> especial, que nuestro tokenizer genera para todos los signos de puntuaci√≥n reconocidos por Python (devolviendo un token √∫nico con el tipo <code>OP</code> para operadores de varios caracteres, como <code>&lt;=</code> o <code>**</code> ).  Los √∫nicos otros tokens que pueden ocurrir en las expresiones de Python son nombres, n√∫meros y cadenas.  Por lo tanto, el c√≥digo entre las llaves externas de la acci√≥n, al parecer, se puede expresar a trav√©s de repeticiones de <code>NAME | NUMBER | STRING | OP</code> <code>NAME | NUMBER | STRING | OP</code>  <code>NAME | NUMBER | STRING | OP</code> . </p><br><p>  Por desgracia, esto no funcionar√° porque el <code>OP</code> tambi√©n coincide con llaves, y dado que el analizador PEG siempre es codicioso, esto capturar√° el corchete de cierre y nunca veremos el final de la acci√≥n.  Por lo tanto, agregamos un peque√±o ajuste, permitiendo que la acci√≥n arroje un error de elecci√≥n alternativa, devolviendo Ninguno.  No s√© si esto es una ocurrencia est√°ndar en otros analizadores de PEG. Se me ocurri√≥ esto en el acto cuando tuve que resolver el problema de reconocer el par√©ntesis de cierre (incluso sin pares anidados).  Esto parece funcionar bien, y creo que encaja en la filosof√≠a general del an√°lisis PEG.  Esto puede considerarse como una forma especial de previsi√≥n (que analizar√© a continuaci√≥n). </p><br><p>  Usando este peque√±o truco, podemos hacer que la comparaci√≥n en el <code>OP</code> caiga en una llave rizada.  Entonces ser√° posible una comparaci√≥n de <code>stuff</code> y <code>action</code> . </p><br><p>  Con estas cosas, un metaparser de arranque puede analizar un meta-gram√°tica, y el generador puede convertirlo en un nuevo meta-analizador que pueda analizarse a s√≠ mismo.  Y, lo que es m√°s importante, el nuevo meta-analizador a√∫n puede analizar la misma meta-gram√°tica.  Si compilamos la meta-gram√°tica con el nuevo meta-compilador, el resultado es el mismo: esto prueba que el meta-analizador generado funciona correctamente. </p><br><p>  Aqu√≠ est√° la meta gram√°tica de acci√≥n completa.  Puede analizarse a s√≠ mismo, ya que sabe c√≥mo combinar l√≠neas largas: </p><br><pre> <code class="plaintext hljs">@subheader """ from grammar import Grammar, Rule, Alt from token import OP """ start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING NEWLINE { (name.string, eval(string.string)) } rules: rule rules { [rule] + rules } | rule { [rule] } rule: NAME ":" alts NEWLINE { Rule(name.string, alts) } alts: alt "|" alts { [alt] + alts } | alt { [alt] } alt: items action { Alt(items, action) } | items { Alt(items, None) } items: item items { [item] + items } | item { [item] } item: NAME { name.string } | STRING { string.string } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  Ahora que tenemos una meta-gram√°tica funcional, estamos casi listos para hacer algunas mejoras. </p><br><p>  Pero primero debes pensar un poco: ¬°l√≠neas vac√≠as!  Resulta que el m√≥dulo <code>tokenize</code> stdlib crea tokens adicionales para rastrear <code>tokenize</code> l√≠nea insignificantes (token <code>NL</code> ) y comentarios (token <code>COMMENT</code> ).  En lugar de incluirlos en la gram√°tica (¬°lo intent√©, no hay mucha diversi√≥n!), Hay un c√≥digo muy simple que podemos agregar a nuestra clase de tokenizadores para filtrarlos.  Aqu√≠ est√° el m√©todo mejorado <code>peek_token</code> : </p><br><pre> <code class="plaintext hljs"> def peek_token(self): if self.pos == len(self.tokens): while True: token = next(self.tokengen) if token.type in (NL, COMMENT): continue break self.tokens.append(token) self.report() return self.tokens[self.pos]</code> </pre> <br><p>  Esto elimina completamente los tokens <code>NL</code> y <code>COMMENT</code> , por lo que ya no tenemos que preocuparnos por ellos en la gram√°tica. </p><br><p>  Finalmente, ¬°hagamos mejoras en la meta-gram√°tica!  Ser√°n puramente cosm√©ticos: no me gusta cuando me veo obligado a escribir todas las alternativas en una l√≠nea.  La meta gram√°tica que mostr√© arriba no se analiza en s√≠ misma debido a tales cosas: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  Esto se debe al hecho de que el tokenizer crea un token <code>NEWLINE</code> al final de la primera l√≠nea, y en este momento el meta-analizador considerar√° que este es el final de la regla.  Adem√°s, esta <code>NEWLINE</code> ser√° seguida por el token <code>INDENT</code> , porque la siguiente l√≠nea est√° sangrada.  Hasta el comienzo de la siguiente regla, un token <code>DEDENT</code> tambi√©n estar√° presente. </p><br><p>  Aqu√≠ se explica c√≥mo manejarlo.  Para comprender el comportamiento del m√≥dulo <code>tokenize</code> , podemos ver la secuencia de tokens generados para bloques sangrados ejecutando el m√≥dulo <code>tokenize</code> como un script y pas√°ndole un texto: </p><br><pre> <code class="plaintext hljs">$ python -m tokenize foo bar baz dah dum ^D</code> </pre> <br><p>  Vemos que esto produce la siguiente secuencia de tokens (simplifiqu√© un poco la salida del c√≥digo anterior): </p><br><pre> <code class="plaintext hljs">NAME 'foo' NAME 'bar' NEWLINE INDENT NAME 'baz' NEWLINE NAME 'dah' NEWLINE DEDENT NAME 'dum' NEWLINE</code> </pre> <br><p>  Por lo tanto, un grupo seleccionado de cadenas se indica mediante <code>DEDENT</code> y <code>DEDENT</code> .  Ahora podemos reescribir la <code>rule</code> meta-gram√°tica para la <code>rule</code> siguiente manera: </p><br><pre> <code class="plaintext hljs">rule: NAME ":" alts NEWLINE INDENT more_alts DEDENT { Rule(name.string, alts + more_alts) } | NAME ":" alts NEWLINE { Rule(name.string, alts) } | NAME ":" NEWLINE INDENT more_alts DEDENT { Rule(name.string, more_alts) } more_alts: "|" alts NEWLINE more_alts { alts + more_alts } | "|" alts NEWLINE { alts }</code> </pre> <br><p>  (Divido las acciones en l√≠neas para que se lean normalmente en una columna de texto estrecha. Esto es posible porque el tokenizador ignora los saltos de l√≠nea dentro de las llaves correspondientes). </p><br><p>  Lo bueno de esto es que ni siquiera necesitamos cambiar el generador: la estructura de datos creada por esta meta-gram√°tica mejorada es la misma que antes.  Tambi√©n preste atenci√≥n a la tercera opci√≥n para la <code>rule</code> : esto nos permite escribir: </p><br><pre> <code class="plaintext hljs">start: | metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  que algunos pueden encontrarlo m√°s limpio que la versi√≥n que mostr√© anteriormente.  Ambas formas son f√°ciles de resolver, por lo que no necesitamos discutir sobre el estilo. </p><br><p>  En la pr√≥xima publicaci√≥n, mostrar√© c√≥mo implement√© varias funciones PEG, como elementos opcionales, repeticiones e informaci√≥n sobre herramientas.  (Para ser honesto, plane√© hablar sobre ellos en este art√≠culo, pero ya es demasiado grande. As√≠ que lo dividir√© en dos partes). </p><br><p>  Licencia para este art√≠culo y c√≥digo citado: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471990/">https://habr.com/ru/post/471990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471978/index.html">No podemos confiar solo en los sistemas de inteligencia artificial basados ‚Äã‚Äãen el aprendizaje profundo</a></li>
<li><a href="../471980/index.html">Estafadores telef√≥nicos. Acto cuatro, final ...</a></li>
<li><a href="../471982/index.html">Discutiendo el futuro de PHP</a></li>
<li><a href="../471986/index.html">Gram√°tica de PEG recursiva izquierda</a></li>
<li><a href="../471988/index.html">Agregar acciones a la gram√°tica PEG</a></li>
<li><a href="../471992/index.html">Implementando las caracter√≠sticas restantes de PEG</a></li>
<li><a href="../471994/index.html">Trabajar en PEG en Core Developer Sprint</a></li>
<li><a href="../471998/index.html">F # 10: listas</a></li>
<li><a href="../472000/index.html">"Es fundamental para la comunidad establecer est√°ndares": Marchin Moskala sobre Kotlin</a></li>
<li><a href="../472002/index.html">Empaquetado de Paquetes en Gradle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>