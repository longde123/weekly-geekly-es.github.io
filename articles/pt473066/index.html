<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👦‍👦 🚖 💹 Árvores de quadrante e reconhecimento de colisão 🤰🏿 🤾🏿 💅🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta semana foi curta, na segunda e na terça-feira continuei a trabalhar em um sistema de iluminação 2D . Passei o resto do tempo na implementação de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Árvores de quadrante e reconhecimento de colisão</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473066/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/237/20a/59e23720a19b3109d80e62c6d2d539a0.gif" alt="imagem"></div><br>  Esta semana foi curta, na segunda e na terça-feira continuei a trabalhar em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um sistema de iluminação 2D</a> .  Passei o resto do tempo na implementação de árvores quadtree. <br><br>  Neste artigo, compartilharei minha implementação e pensamentos que surgiram no processo de seu design. <br><br>  Primeiro, preciso dizer por que decidi implementar uma árvore quadrante. <br><br>  Quadtree é uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrutura de dados de partição espacial</a> .  Sua principal vantagem sobre outras estruturas de dados é sua adaptabilidade.  Ele fornece bom desempenho ao inserir, excluir e pesquisar.  Ou seja, podemos usar essa árvore em um contexto dinâmico em que os dados geralmente mudam.  Além disso, essa estrutura é bastante fácil de entender e implementar. <br><br>  Se o particionamento de espaço for um novo tópico para você, recomendo a leitura deste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo de</a> Robert Nistrom.  Se você quiser aprender mais sobre árvores de quadrante, leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> artigo. <br><a name="habracut"></a><br>  Existem áreas no meu jogo nas quais o uso do quadtree compensa instantaneamente: <br><br><ul><li>  Ao reconhecer colisões, a árvore do quadrante é muito mais eficiente que o método da força bruta (testando todos os pares).  Mas essa não é a abordagem mais eficaz, uma visão geral de várias técnicas e referências pode ser estudada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> .  No entanto, para a primeira versão do meu mecanismo de física, eu o uso.  Talvez mais tarde, se necessário, escolha um algoritmo mais especializado. </li><li>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gráfico</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cena,</a> ao executar o recorte, posso usar o quadtree para procurar todos os nós visíveis. </li><li>  Em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um sistema de iluminação,</a> você pode usar o quadtree para encontrar paredes que cruzam o polígono de visibilidade da fonte de luz. </li><li>  No sistema de IA, você pode usar o quadtree para procurar todos os objetos ou inimigos que estão próximos da essência. </li><li>  E assim por diante ... </li></ul><br>  Como você pode ver, as árvores de quadrante são bastante versáteis.  Eles serão uma boa reposição no seu kit de ferramentas. <br><br>  Todo o código mostrado no artigo pode ser encontrado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br><h1>  Preparação preliminar </h1><br>  Antes de detalhar o código quadtree, precisamos de pequenas classes para primitivas geométricas: a classe <code>Vector2</code> para definir pontos e a classe <code>Box</code> para definir retângulos.  Ambos serão padronizados. <br><br><h2>  Vector2 </h2><br>  A classe <a href=""><code>Vector2</code></a> minimalista.  Ele contém apenas construtores, bem como operadores <code>+</code> e <code>/</code> .  É tudo o que precisamos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T x; T y; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;(TX = <span class="hljs-number"><span class="hljs-number">0</span></span>, TY = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : x(X), y(Y) { } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x += other.x; y += other.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/=(T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x /= t; y /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vector2&lt;T&gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { lhs += rhs; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/(Vector2&lt;T&gt; vec, T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { vec /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec; }</code> </pre> <br><h2>  Box </h2><br>  A classe <a href=""><code>Box</code></a> não é muito mais complicada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T left; T top; T width; <span class="hljs-comment"><span class="hljs-comment">// Must be positive T height; // Must be positive constexpr Box(T Left = 0, T Top = 0, T Width = 0, T Height = 0) noexcept : left(Left), top(Top), width(Width), height(Height) { } constexpr Box(const Vector2&lt;T&gt;&amp; position, const Vector2&lt;T&gt;&amp; size) noexcept : left(position.x), top(position.y), width(size.x), height(size.y) { } constexpr T getRight() const noexcept { return left + width; } constexpr T getBottom() const noexcept { return top + height; } constexpr Vector2&lt;T&gt; getTopLeft() const noexcept { return Vector2&lt;T&gt;(left, top); } constexpr Vector2&lt;T&gt; getCenter() const noexcept { return Vector2&lt;T&gt;(left + width / 2, top + height / 2); } constexpr Vector2&lt;T&gt; getSize() const noexcept { return Vector2&lt;T&gt;(width, height); } constexpr bool contains(const Box&lt;T&gt;&amp; box) const noexcept { return left &lt;= box.left &amp;&amp; box.getRight() &lt;= getRight() &amp;&amp; top &lt;= box.top &amp;&amp; box.getBottom() &lt;= getBottom(); } constexpr bool intersects(const Box&lt;T&gt;&amp; box) const noexcept { return !(left &gt;= box.getRight() || getRight() &lt;= box.left || top &gt;= box.getBottom() || getBottom() &lt;= box.top); } };</span></span></code> </pre> <br>  Ele contém alguns getters úteis. <br><br>  O mais interessante é que ele contém o método contains, que verifica se o retângulo está dentro de outro, e o método de <code>intersects</code> , que verifica se o retângulo se cruza com o outro. <br><br>  Usaremos os <code>contains</code> ao inserir e excluir e <code>intersects</code> ao reconhecer cruzamentos. <br><br><h1>  Quadtree </h1><br>  Aqui está o <a href=""><code>Quadtree</code></a> classe <a href=""><code>Quadtree</code></a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> GetBox, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Equal = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::equal_to&lt;T&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Float = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; class Quadtree { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;GetBox, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, Box&lt;Float&gt;&gt;, <span class="hljs-string"><span class="hljs-string">"GetBox must be a callable of signature Box&lt;Float&gt;(const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Equal, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;, <span class="hljs-string"><span class="hljs-string">"Equal must be a callable of signature bool(const T&amp;, const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt;Float&gt;); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Quadtree(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GetBox&amp; getBox = GetBox(), <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Equal&amp; equal = Equal()) : mBox(box), mRoot(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;Node&gt;()), mGetBox(getBox), mEqual(equal) { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Threshold = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> MaxDepth = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt;, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; children; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; values; }; Box&lt;Float&gt; mBox; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt; mRoot; GetBox mGetBox; Equal mEqual; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLeaf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Node* node)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(node-&gt;children[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } };</code> </pre> <br>  Como você pode ver, <code>Quadtree</code> é uma classe de modelo.  Isso nos permitirá usar a classe para vários propósitos, dos quais falei no começo. <br><br>  Opções de modelo: <br><br><ul><li>  <code>T</code> : o tipo de valores que estarão contidos em quadtree.  <code>T</code> deve ser uma classe fácil, porque será armazenada dentro de um quadtree.  Idealmente, isso deve ser um ponteiro ou uma pequena estrutura de dados simples (POD). </li><li>  <code>GetBox</code> : o tipo do objeto chamado que receberá o valor na entrada e retornará um retângulo. </li><li>  <code>Equal</code> : o tipo do objeto chamado para verificar se dois valores são iguais.  Por padrão, usamos o operador de igualdade padrão. </li><li>  <code>Float</code> : O tipo aritmético usado nos cálculos.  Por padrão, usamos <code>float</code> . </li></ul><br>  No início da definição de classe, há três asserções estáticas para verificar a validade dos parâmetros do modelo. <br><br>  Vamos dar uma olhada na definição de um nó.  Um nó simplesmente armazena ponteiros para seus quatro nós filhos e uma lista dos valores contidos nele.  Não armazenamos nela sua caixa delimitadora ou profundidade, elas serão calculadas em tempo real. <br><br>  Conduzi benchmarks de ambas as abordagens (preservando um retângulo com profundidade e sem preservar) e não encontrei nenhuma degradação de desempenho ao calculá-las em tempo real.  Além disso, economiza um pouco de memória. <br><br>  Para poder distinguir um nó interno de uma planilha, o método <code>isLeaf</code> .  Apenas verifica se o primeiro filho não é nulo.  Como nulo são todos os nós filhos, ou nenhum deles, basta verificar apenas o primeiro. <br><br>  Agora podemos ver as <code>Quadtree</code> membro <code>Quadtree</code> : <br><br><ul><li>  <code>mBox</code> é uma caixa delimitadora global.  Todos os valores inseridos no quadtree devem estar contidos nele. </li><li>  <code>mRoot</code> é a raiz do quadtree. </li><li>  <code>mGetBox</code> é o objeto chamado, que usaremos para obter o retângulo do valor. </li><li>  <code>mEqual</code> é o objeto chamado, que usaremos para verificar a igualdade dos dois valores. </li></ul><br>  O construtor simplesmente define <code>mBox</code> , <code>mGetBox</code> e <code>mEqual</code> e também cria um nó raiz. <br><br>  Os dois últimos parâmetros sobre os quais ainda não falamos são <code>Threshold</code> e <code>MaxDepth</code> .  <code>Threshold</code> é o número máximo de valores que um nó pode conter antes de dividi-lo.  <code>MaxDepth</code> é a profundidade máxima de um nó, paramos de tentar dividir os nós que estão no <code>MaxDepth</code> , porque se você dividir demais, poderá prejudicar o desempenho.  Eu dei a essas constantes valores razoáveis ​​adequados para a maioria dos casos.  Você pode tentar otimizá-los para sua configuração. <br><br>  Agora estamos prontos para iniciar operações mais interessantes. <br><br><h1>  Inserir e excluir </h1><br>  Antes de mostrar o código de inserção, precisamos discutir quais nós conterão os valores.  Existem duas estratégias: <br><br><ul><li>  Os valores são armazenados apenas em folhas.  Como a caixa delimitadora de um valor pode interagir com várias folhas, o valor será armazenado em todas essas folhas. </li><li>  Os valores podem ser armazenados em todos os nós.  Armazenamos o valor no menor nó que contém completamente sua caixa delimitadora. </li></ul><br>  Se os retângulos delimitadores forem pequenos e aproximadamente do mesmo tamanho, a primeira estratégia será mais eficaz ao procurar cruzamentos.  No entanto, se existirem retângulos grandes, poderão ocorrer casos degenerados nos quais o desempenho será muito baixo.  Por exemplo, se inserirmos um valor cujo retângulo esteja na caixa delimitadora global, ele será adicionado a todas as folhas.  E se inserirmos um <code>Threshold</code> para esses valores, todos os nós serão divididos até que <code>MaxDepth</code> atingido e os valores não estejam em todas as folhas.  Portanto, quadtree conterá <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><msup><mn>4</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="37.45ex" height="2.539ex" viewBox="0 -987.6 16124.4 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-65" x="611" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-78" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="1650" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="2012" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="2373" y="0"></use><g transform="translate(2735,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-54" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-68" x="704" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-72" x="1281" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-65" x="1732" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-73" x="2199" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-68" x="2668" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-6F" x="3245" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-6C" x="3730" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-64" x="4029" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="7537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-69" x="7899" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-6D" x="8244" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-65" x="9123" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-73" x="9589" y="0"></use><g transform="translate(10059,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMAIN-34" x="0" y="0"></use><g transform="translate(500,404)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-65" x="715" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-78" x="1181" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="1754" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="2115" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="2477" y="0"></use><g transform="translate(2007,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-4D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-61" x="1051" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-78" x="1581" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-44" x="2153" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-65" x="2982" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-70" x="3448" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="3952" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-68" x="4313" y="0"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><mtext>&nbsp;</mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><msup><mn>4</mn><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ texttt {Threshold} \ times 4 ^ {\ texttt {MaxDepth}} </script>  significados, e isso é ... muito. <br><br>  Além disso, com a primeira estratégia, inserir e excluir será um pouco mais lento, porque temos que inserir (ou excluir) todos os nós que cruzam o valor. <br><br>  Portanto, usarei a segunda estratégia, na qual não há casos degenerados.  Como pretendo usar o quadtree em vários contextos, será mais conveniente.  Além disso, essa estratégia é mais adequada para contextos dinâmicos nos quais muitas inserções e exclusões são realizadas para atualizar valores, por exemplo, em um mecanismo físico para o qual as entidades são movidas. <br><br>  Para descobrir em qual nó inseriremos ou excluiremos um valor, usaremos duas funções auxiliares. <br><br>  O primeiro, <code>computeBox</code> , calcula o retângulo do nó filho pelo retângulo do nó pai e o índice do seu quadrante. <br><br><pre> <code class="cpp hljs">Box&lt;Float&gt; computeBox(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> origin = box.getTopLeft(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childSize = box.getSize() / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Float&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-comment"><span class="hljs-comment">// North West case 0: return Box&lt;Float&gt;(origin, childSize); // Norst East case 1: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x + childSize.x, origin.y), childSize); // South West case 2: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x, origin.y + childSize.y), childSize); // South East case 3: return Box&lt;Float&gt;(origin + childSize, childSize); default: assert(false &amp;&amp; "Invalid child index"); return Box&lt;Float&gt;(); } }</span></span></code> </pre> <br>  O segundo, <code>getQuadrant</code> , retorna o quadrante em que o valor está localizado: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getQuadrant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; nodeBox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; valueBox)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> center = nodeBox.getCenter(); <span class="hljs-comment"><span class="hljs-comment">// West if (valueBox.getRight() &lt; center.x) { // North West if (valueBox.getBottom() &lt; center.y) return 0; // South West else if (valueBox.top &gt;= center.y) return 2; // Not contained in any quadrant else return -1; } // East else if (valueBox.left &gt;= center.x) { // North East if (valueBox.getBottom() &lt; center.y) return 1; // South East else if (valueBox.top &gt;= center.y) return 3; // Not contained in any quadrant else return -1; } // Not contained in any quadrant else return -1; }</span></span></code> </pre> <br>  Retorna <code>-1</code> se não estiver contido em nenhum dos quadrantes. <br><br>  Agora estamos prontos para considerar os métodos de inserção e exclusão. <br><br><h2>  Inserir </h2><br>  O método <code>add</code> simplesmente chama um método auxiliar privado: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ add(mRoot.get(), <span class="hljs-number"><span class="hljs-number">0</span></span>, mBox, value); }</code> </pre> <br>  Aqui está o código do método auxiliar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Insert the value in this node if possible if (depth &gt;= MaxDepth || node-&gt;values.size() &lt; Threshold) node-&gt;values.push_back(value); // Otherwise, we split and we try again else { split(node, box); add(node, depth, box, value); } } else { auto i = getQuadrant(box, mGetBox(value)); // Add the value in a child if the value is entirely contained in it if (i != -1) add(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), depth + 1, computeBox(box, i), value); // Otherwise, we add the value in the current node else node-&gt;values.push_back(value); } }</span></span></code> </pre> <br>  No início, existem algumas suposições que confirmam que não estamos fazendo nada ilógico, por exemplo, não estamos inserindo um valor em um nó que não contém sua caixa delimitadora. <br><br>  Então, se o nó for uma planilha, e podemos inserir um novo valor nele, ou seja,  não atingimos <code>MaxDepth</code> ou <code>Threshold</code> , execute a inserção.  Caso contrário, compartilhamos esse nó e tentamos novamente. <br><br>  Se o nó for interno, calcularemos o quadrante que contém a caixa delimitadora do valor.  Se estiver completamente contido no nó filho, fazemos uma chamada recursiva.  Caso contrário, insira neste nó. <br><br>  Aqui está o procedimento de separação: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only leaves can be split"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Create children for (auto&amp; child : node-&gt;children) child = std::make_unique&lt;Node&gt;(); // Assign values to children auto newValues = std::vector&lt;T&gt;(); // New values for this node for (const auto&amp; value : node-&gt;values) { auto i = getQuadrant(box, mGetBox(value)); if (i != -1) node-&gt;children[static_cast&lt;std::size_t&gt;(i)]-&gt;values.push_back(value); else newValues.push_back(value); } node-&gt;values = std::move(newValues); }</span></span></code> </pre> <br>  Criamos quatro nós filhos e, para cada valor do nó pai, decidimos em qual nó (filho ou pai) o valor deve ser armazenado. <br><br><h2>  Excluir </h2><br>  O método <code>remove</code> também simplesmente chama um método auxiliar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ remove(mRoot.get(), <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, mBox, value); }</code> </pre> <br>  Aqui está o código do método auxiliar, é muito semelhante ao código de inserção: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, Node* parent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Remove the value from node removeValue(node, value); // Try to merge the parent if (parent != nullptr) tryMerge(parent); } else { // Remove the value in a child if the value is entirely contained in it auto i = getQuadrant(box, mGetBox(value)); if (i != -1) remove(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), node, computeBox(box, i), value); // Otherwise, we remove the value from the current node else removeValue(node, value); } }</span></span></code> </pre> <br>  Se o nó atual for uma planilha, removeremos o valor da lista de valores do nó atual <br>  e tente mesclar esse nó com os nós irmãos e seu pai.  Caso contrário, determinamos em qual quadrante a caixa delimitadora do valor está localizada.  Se estiver completamente contido no nó filho, faremos uma chamada recursiva.  Caso contrário, exclua dos valores do nó atual. <br><br>  Como não nos importamos com a ordem dos valores armazenados no nó, quando apago, uso um pouco de otimização: apenas altero o valor apagado pelo último e o apago: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the value in node-&gt;values auto it = std::find_if(std::begin(node-&gt;values), std::end(node-&gt;values), [this, &amp;value](const auto&amp; rhs){ return mEqual(value, rhs); }); assert(it != std::end(node-&gt;values) &amp;&amp; "Trying to remove a value that is not present in the node"); // Swap with the last element and pop back *it = std::move(node-&gt;values.back()); node-&gt;values.pop_back(); }</span></span></code> </pre> <br>  Também precisamos dar uma olhada no <code>tryMerge</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryMerge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(!isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only interior nodes can be merged"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> nbValues = node-&gt;values.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; child : node-&gt;children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(child.get())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; nbValues += child-&gt;values.size(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nbValues &lt;= Threshold) { node-&gt;values.reserve(nbValues); <span class="hljs-comment"><span class="hljs-comment">// Merge the values of all the children for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : child-&gt;values) node-&gt;values.push_back(value); } // Remove the children for (auto&amp; child : node-&gt;children) child.reset(); } }</span></span></code> </pre> <br>  <code>tryMerge</code> verifica se todos os nós filhos são abandonados e se o número total de seus valores e os valores dos nós filhos é menor que o limite.  Nesse caso, copiamos todos os valores dos nós filhos para o nó atual e excluímos os nós filhos. <br><br><h1>  Pesquisa de interseção </h1><br><h2>  Interseção com retângulo </h2><br>  Finalmente, chegamos ao mais interessante: a busca de cruzamentos.  A primeira maneira de usá-lo é obter todos os valores que cruzam um determinado retângulo.  Por exemplo, isso é necessário para executar o recorte. <br><br>  Isso será <code>query</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; query(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> values = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(); query(mRoot.get(), mBox, box, values); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values; }</code> </pre> <br>  Nesse método, simplesmente selecionamos <code>std::vector</code> , que conterá os valores que cruzam a caixa delimitadora e chamamos o método auxiliar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; queryBox, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; values)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(queryBox.intersects(box)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; value : node-&gt;values) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(mGetBox(value))) values.push_back(value); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(node)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); i &lt; node-&gt;children.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childBox = computeBox(box, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(i)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(childBox)) query(node-&gt;children[i].get(), childBox, queryBox, values); } } }</code> </pre> <br>  Primeiro, adicionamos todos os valores armazenados no nó atual que se cruzam com o retângulo solicitado.  Então, se o nó atual for interno, fazemos uma chamada recursiva para cada nó filho cujo retângulo delimitador se cruza com o retângulo solicitado. <br><br><h2>  Todas as interseções aos pares </h2><br>  O segundo caso de uso suportado é procurar todos os pares de valores armazenados na árvore do quadrante que se cruzam.  Isso é especialmente útil ao criar um mecanismo físico.  Esse problema pode ser resolvido usando o método de <code>query</code> .  E, de fato, podemos chamar <code>query</code> na caixa delimitadora de todos os valores.  No entanto, isso pode ser feito de forma mais eficiente, adicionando apenas uma interseção para um par (com a <code>query</code> , vamos encontrá-los duas vezes). <br><br>  Para perceber isso, precisamos considerar que a interseção só pode ocorrer <br><br><ul><li>  entre dois valores armazenados em um nó </li></ul><br>  ou <br><br><ul><li>  entre o valor armazenado no nó e outro valor armazenado no descendente desse nó. </li></ul><br>  Por esse motivo, devemos verificar apenas a interseção entre: <br><br><ul><li>  valor e os seguintes valores armazenados no mesmo nó </li></ul><br>  e <br><br><ul><li>  valor e valores armazenados no descendente. </li></ul><br>  Portanto, definitivamente não reportaremos a mesma interseção duas vezes. <br><br>  Aqui está o código <code>findAllIntersections</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt; findAllIntersections() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> intersections = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt;(); findAllIntersections(mRoot.get(), intersections); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intersections; }</code> </pre> <br>  Novamente, simplesmente alocamos <code>std::vector</code> para armazenar as interseções e chamar a função helper: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllIntersections</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find intersections between values stored in this node // Make sure to not report the same intersection twice for (auto i = std::size_t(0); i &lt; node-&gt;values.size(); ++i) { for (auto j = std::size_t(0); j &lt; i; ++j) { if (mGetBox(node-&gt;values[i]).intersects(mGetBox(node-&gt;values[j]))) intersections.emplace_back(node-&gt;values[i], node-&gt;values[j]); } } if (!isLeaf(node)) { // Values in this node can intersect values in descendants for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : node-&gt;values) findIntersectionsInDescendants(child.get(), value, intersections); } // Find intersections in children for (const auto&amp; child : node-&gt;children) findAllIntersections(child.get(), intersections); } }</span></span></code> </pre> <br>  No primeiro estágio, as interseções entre os valores armazenados no nó atual são verificadas.  Em seguida, se o nó atual for interno, <code>findIntersectionInDescendants</code> verificará as interseções entre os valores armazenados nesse nó e os valores armazenados em seus descendentes.  Finalmente, fazemos chamadas recursivas. <br><br>  <code>findIntersectionsInDescendants</code> localiza recursivamente interseções entre o valor fornecido e todos os valores armazenados na subárvore: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findIntersectionsInDescendants</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Test against the values stored in this node for (const auto&amp; other : node-&gt;values) { if (mGetBox(value).intersects(mGetBox(other))) intersections.emplace_back(value, other); } // Test against values stored into descendants of this node if (!isLeaf(node)) { for (const auto&amp; child : node-&gt;children) findIntersectionsInDescendants(child.get(), value, intersections); } }</span></span></code> </pre> <br>  Isso é tudo!  Repito, todo o código é publicado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br><h1>  Recursos úteis </h1><br>  Se você quiser saber mais sobre o reconhecimento de colisões e estruturas de dados de particionamento, recomendo a leitura do livro de Christer Erickson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Detecção de colisões em tempo real</a> .  Muitos tópicos são profundamente revelados e, ao mesmo tempo, o livro é escrito em uma linguagem muito compreensível.  Além disso, os capítulos podem ser lidos separadamente.  Esta é uma ótima fonte de referência. <br><br><h1>  Conclusão </h1><br>  Isso conclui o trabalho com reconhecimento de colisão.  No entanto, é apenas metade do mecanismo físico.  A segunda metade é a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">resolução de colisões</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt473066/">https://habr.com/ru/post/pt473066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt473056/index.html">Como Alice reconhece países a partir de fotografias. Pesquisa Yandex</a></li>
<li><a href="../pt473058/index.html">Sergey Sinitsyn: “OSM é mais do que apenas desenhar casas ou trilhas. São mais histórias! ”</a></li>
<li><a href="../pt473060/index.html">Relações informais em uma equipe: por que e como gerenciá-los</a></li>
<li><a href="../pt473062/index.html">User.js subjetivo para o Mozilla Firefox e não apenas</a></li>
<li><a href="../pt473064/index.html">Lágrimas batavianas, carros e Gorilla Glass: sobre alguns tipos de vidro reforçado</a></li>
<li><a href="../pt473072/index.html">Como a Gazpromneft cria um caminho digital para um cliente corporativo</a></li>
<li><a href="../pt473078/index.html">Gerencie facilmente configurações de microsserviços com o microconfig.io</a></li>
<li><a href="../pt473082/index.html">Como escrevemos microsserviços e por que não o fazemos rapidamente</a></li>
<li><a href="../pt473084/index.html">"Ivan" é uma profissão de bot de bate-papo. Ou experimentos criativos com assistentes virtuais</a></li>
<li><a href="../pt473086/index.html">Como o malware evita caixas de areia com o Visual Basic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>