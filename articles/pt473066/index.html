<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüë¶‚Äçüë¶ üöñ üíπ √Årvores de quadrante e reconhecimento de colis√£o ü§∞üèø ü§æüèø üíÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta semana foi curta, na segunda e na ter√ßa-feira continuei a trabalhar em um sistema de ilumina√ß√£o 2D . Passei o resto do tempo na implementa√ß√£o de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Årvores de quadrante e reconhecimento de colis√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473066/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/237/20a/59e23720a19b3109d80e62c6d2d539a0.gif" alt="imagem"></div><br>  Esta semana foi curta, na segunda e na ter√ßa-feira continuei a trabalhar em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um sistema de ilumina√ß√£o 2D</a> .  Passei o resto do tempo na implementa√ß√£o de √°rvores quadtree. <br><br>  Neste artigo, compartilharei minha implementa√ß√£o e pensamentos que surgiram no processo de seu design. <br><br>  Primeiro, preciso dizer por que decidi implementar uma √°rvore quadrante. <br><br>  Quadtree √© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrutura de dados de parti√ß√£o espacial</a> .  Sua principal vantagem sobre outras estruturas de dados √© sua adaptabilidade.  Ele fornece bom desempenho ao inserir, excluir e pesquisar.  Ou seja, podemos usar essa √°rvore em um contexto din√¢mico em que os dados geralmente mudam.  Al√©m disso, essa estrutura √© bastante f√°cil de entender e implementar. <br><br>  Se o particionamento de espa√ßo for um novo t√≥pico para voc√™, recomendo a leitura deste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo de</a> Robert Nistrom.  Se voc√™ quiser aprender mais sobre √°rvores de quadrante, leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> artigo. <br><a name="habracut"></a><br>  Existem √°reas no meu jogo nas quais o uso do quadtree compensa instantaneamente: <br><br><ul><li>  Ao reconhecer colis√µes, a √°rvore do quadrante √© muito mais eficiente que o m√©todo da for√ßa bruta (testando todos os pares).  Mas essa n√£o √© a abordagem mais eficaz, uma vis√£o geral de v√°rias t√©cnicas e refer√™ncias pode ser estudada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> .  No entanto, para a primeira vers√£o do meu mecanismo de f√≠sica, eu o uso.  Talvez mais tarde, se necess√°rio, escolha um algoritmo mais especializado. </li><li>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gr√°fico</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cena,</a> ao executar o recorte, posso usar o quadtree para procurar todos os n√≥s vis√≠veis. </li><li>  Em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um sistema de ilumina√ß√£o,</a> voc√™ pode usar o quadtree para encontrar paredes que cruzam o pol√≠gono de visibilidade da fonte de luz. </li><li>  No sistema de IA, voc√™ pode usar o quadtree para procurar todos os objetos ou inimigos que est√£o pr√≥ximos da ess√™ncia. </li><li>  E assim por diante ... </li></ul><br>  Como voc√™ pode ver, as √°rvores de quadrante s√£o bastante vers√°teis.  Eles ser√£o uma boa reposi√ß√£o no seu kit de ferramentas. <br><br>  Todo o c√≥digo mostrado no artigo pode ser encontrado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br><h1>  Prepara√ß√£o preliminar </h1><br>  Antes de detalhar o c√≥digo quadtree, precisamos de pequenas classes para primitivas geom√©tricas: a classe <code>Vector2</code> para definir pontos e a classe <code>Box</code> para definir ret√¢ngulos.  Ambos ser√£o padronizados. <br><br><h2>  Vector2 </h2><br>  A classe <a href=""><code>Vector2</code></a> minimalista.  Ele cont√©m apenas construtores, bem como operadores <code>+</code> e <code>/</code> .  √â tudo o que precisamos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T x; T y; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;(TX = <span class="hljs-number"><span class="hljs-number">0</span></span>, TY = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : x(X), y(Y) { } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x += other.x; y += other.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/=(T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x /= t; y /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vector2&lt;T&gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { lhs += rhs; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/(Vector2&lt;T&gt; vec, T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { vec /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec; }</code> </pre> <br><h2>  Box </h2><br>  A classe <a href=""><code>Box</code></a> n√£o √© muito mais complicada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T left; T top; T width; <span class="hljs-comment"><span class="hljs-comment">// Must be positive T height; // Must be positive constexpr Box(T Left = 0, T Top = 0, T Width = 0, T Height = 0) noexcept : left(Left), top(Top), width(Width), height(Height) { } constexpr Box(const Vector2&lt;T&gt;&amp; position, const Vector2&lt;T&gt;&amp; size) noexcept : left(position.x), top(position.y), width(size.x), height(size.y) { } constexpr T getRight() const noexcept { return left + width; } constexpr T getBottom() const noexcept { return top + height; } constexpr Vector2&lt;T&gt; getTopLeft() const noexcept { return Vector2&lt;T&gt;(left, top); } constexpr Vector2&lt;T&gt; getCenter() const noexcept { return Vector2&lt;T&gt;(left + width / 2, top + height / 2); } constexpr Vector2&lt;T&gt; getSize() const noexcept { return Vector2&lt;T&gt;(width, height); } constexpr bool contains(const Box&lt;T&gt;&amp; box) const noexcept { return left &lt;= box.left &amp;&amp; box.getRight() &lt;= getRight() &amp;&amp; top &lt;= box.top &amp;&amp; box.getBottom() &lt;= getBottom(); } constexpr bool intersects(const Box&lt;T&gt;&amp; box) const noexcept { return !(left &gt;= box.getRight() || getRight() &lt;= box.left || top &gt;= box.getBottom() || getBottom() &lt;= box.top); } };</span></span></code> </pre> <br>  Ele cont√©m alguns getters √∫teis. <br><br>  O mais interessante √© que ele cont√©m o m√©todo contains, que verifica se o ret√¢ngulo est√° dentro de outro, e o m√©todo de <code>intersects</code> , que verifica se o ret√¢ngulo se cruza com o outro. <br><br>  Usaremos os <code>contains</code> ao inserir e excluir e <code>intersects</code> ao reconhecer cruzamentos. <br><br><h1>  Quadtree </h1><br>  Aqui est√° o <a href=""><code>Quadtree</code></a> classe <a href=""><code>Quadtree</code></a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> GetBox, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Equal = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::equal_to&lt;T&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Float = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; class Quadtree { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;GetBox, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, Box&lt;Float&gt;&gt;, <span class="hljs-string"><span class="hljs-string">"GetBox must be a callable of signature Box&lt;Float&gt;(const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Equal, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;, <span class="hljs-string"><span class="hljs-string">"Equal must be a callable of signature bool(const T&amp;, const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt;Float&gt;); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Quadtree(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GetBox&amp; getBox = GetBox(), <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Equal&amp; equal = Equal()) : mBox(box), mRoot(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;Node&gt;()), mGetBox(getBox), mEqual(equal) { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Threshold = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> MaxDepth = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt;, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; children; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; values; }; Box&lt;Float&gt; mBox; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt; mRoot; GetBox mGetBox; Equal mEqual; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLeaf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Node* node)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(node-&gt;children[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } };</code> </pre> <br>  Como voc√™ pode ver, <code>Quadtree</code> √© uma classe de modelo.  Isso nos permitir√° usar a classe para v√°rios prop√≥sitos, dos quais falei no come√ßo. <br><br>  Op√ß√µes de modelo: <br><br><ul><li>  <code>T</code> : o tipo de valores que estar√£o contidos em quadtree.  <code>T</code> deve ser uma classe f√°cil, porque ser√° armazenada dentro de um quadtree.  Idealmente, isso deve ser um ponteiro ou uma pequena estrutura de dados simples (POD). </li><li>  <code>GetBox</code> : o tipo do objeto chamado que receber√° o valor na entrada e retornar√° um ret√¢ngulo. </li><li>  <code>Equal</code> : o tipo do objeto chamado para verificar se dois valores s√£o iguais.  Por padr√£o, usamos o operador de igualdade padr√£o. </li><li>  <code>Float</code> : O tipo aritm√©tico usado nos c√°lculos.  Por padr√£o, usamos <code>float</code> . </li></ul><br>  No in√≠cio da defini√ß√£o de classe, h√° tr√™s asser√ß√µes est√°ticas para verificar a validade dos par√¢metros do modelo. <br><br>  Vamos dar uma olhada na defini√ß√£o de um n√≥.  Um n√≥ simplesmente armazena ponteiros para seus quatro n√≥s filhos e uma lista dos valores contidos nele.  N√£o armazenamos nela sua caixa delimitadora ou profundidade, elas ser√£o calculadas em tempo real. <br><br>  Conduzi benchmarks de ambas as abordagens (preservando um ret√¢ngulo com profundidade e sem preservar) e n√£o encontrei nenhuma degrada√ß√£o de desempenho ao calcul√°-las em tempo real.  Al√©m disso, economiza um pouco de mem√≥ria. <br><br>  Para poder distinguir um n√≥ interno de uma planilha, o m√©todo <code>isLeaf</code> .  Apenas verifica se o primeiro filho n√£o √© nulo.  Como nulo s√£o todos os n√≥s filhos, ou nenhum deles, basta verificar apenas o primeiro. <br><br>  Agora podemos ver as <code>Quadtree</code> membro <code>Quadtree</code> : <br><br><ul><li>  <code>mBox</code> √© uma caixa delimitadora global.  Todos os valores inseridos no quadtree devem estar contidos nele. </li><li>  <code>mRoot</code> √© a raiz do quadtree. </li><li>  <code>mGetBox</code> √© o objeto chamado, que usaremos para obter o ret√¢ngulo do valor. </li><li>  <code>mEqual</code> √© o objeto chamado, que usaremos para verificar a igualdade dos dois valores. </li></ul><br>  O construtor simplesmente define <code>mBox</code> , <code>mGetBox</code> e <code>mEqual</code> e tamb√©m cria um n√≥ raiz. <br><br>  Os dois √∫ltimos par√¢metros sobre os quais ainda n√£o falamos s√£o <code>Threshold</code> e <code>MaxDepth</code> .  <code>Threshold</code> √© o n√∫mero m√°ximo de valores que um n√≥ pode conter antes de dividi-lo.  <code>MaxDepth</code> √© a profundidade m√°xima de um n√≥, paramos de tentar dividir os n√≥s que est√£o no <code>MaxDepth</code> , porque se voc√™ dividir demais, poder√° prejudicar o desempenho.  Eu dei a essas constantes valores razo√°veis ‚Äã‚Äãadequados para a maioria dos casos.  Voc√™ pode tentar otimiz√°-los para sua configura√ß√£o. <br><br>  Agora estamos prontos para iniciar opera√ß√µes mais interessantes. <br><br><h1>  Inserir e excluir </h1><br>  Antes de mostrar o c√≥digo de inser√ß√£o, precisamos discutir quais n√≥s conter√£o os valores.  Existem duas estrat√©gias: <br><br><ul><li>  Os valores s√£o armazenados apenas em folhas.  Como a caixa delimitadora de um valor pode interagir com v√°rias folhas, o valor ser√° armazenado em todas essas folhas. </li><li>  Os valores podem ser armazenados em todos os n√≥s.  Armazenamos o valor no menor n√≥ que cont√©m completamente sua caixa delimitadora. </li></ul><br>  Se os ret√¢ngulos delimitadores forem pequenos e aproximadamente do mesmo tamanho, a primeira estrat√©gia ser√° mais eficaz ao procurar cruzamentos.  No entanto, se existirem ret√¢ngulos grandes, poder√£o ocorrer casos degenerados nos quais o desempenho ser√° muito baixo.  Por exemplo, se inserirmos um valor cujo ret√¢ngulo esteja na caixa delimitadora global, ele ser√° adicionado a todas as folhas.  E se inserirmos um <code>Threshold</code> para esses valores, todos os n√≥s ser√£o divididos at√© que <code>MaxDepth</code> atingido e os valores n√£o estejam em todas as folhas.  Portanto, quadtree conter√° <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><msup><mn>4</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="37.45ex" height="2.539ex" viewBox="0 -987.6 16124.4 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-65" x="611" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-78" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="1650" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="2012" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="2373" y="0"></use><g transform="translate(2735,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-54" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-68" x="704" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-72" x="1281" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-65" x="1732" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-73" x="2199" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-68" x="2668" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-6F" x="3245" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-6C" x="3730" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-64" x="4029" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="7537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-69" x="7899" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-6D" x="8244" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-65" x="9123" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-73" x="9589" y="0"></use><g transform="translate(10059,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMAIN-34" x="0" y="0"></use><g transform="translate(500,404)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-65" x="715" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-78" x="1181" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="1754" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="2115" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="2477" y="0"></use><g transform="translate(2007,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-4D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-61" x="1051" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-78" x="1581" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-44" x="2153" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-65" x="2982" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-70" x="3448" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-74" x="3952" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhFy5xuvaHc8gwWXFrs8d5Pr4W5ig#MJMATHI-68" x="4313" y="0"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><mtext>&nbsp;</mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><msup><mn>4</mn><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ texttt {Threshold} \ times 4 ^ {\ texttt {MaxDepth}} </script>  significados, e isso √© ... muito. <br><br>  Al√©m disso, com a primeira estrat√©gia, inserir e excluir ser√° um pouco mais lento, porque temos que inserir (ou excluir) todos os n√≥s que cruzam o valor. <br><br>  Portanto, usarei a segunda estrat√©gia, na qual n√£o h√° casos degenerados.  Como pretendo usar o quadtree em v√°rios contextos, ser√° mais conveniente.  Al√©m disso, essa estrat√©gia √© mais adequada para contextos din√¢micos nos quais muitas inser√ß√µes e exclus√µes s√£o realizadas para atualizar valores, por exemplo, em um mecanismo f√≠sico para o qual as entidades s√£o movidas. <br><br>  Para descobrir em qual n√≥ inseriremos ou excluiremos um valor, usaremos duas fun√ß√µes auxiliares. <br><br>  O primeiro, <code>computeBox</code> , calcula o ret√¢ngulo do n√≥ filho pelo ret√¢ngulo do n√≥ pai e o √≠ndice do seu quadrante. <br><br><pre> <code class="cpp hljs">Box&lt;Float&gt; computeBox(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> origin = box.getTopLeft(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childSize = box.getSize() / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Float&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-comment"><span class="hljs-comment">// North West case 0: return Box&lt;Float&gt;(origin, childSize); // Norst East case 1: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x + childSize.x, origin.y), childSize); // South West case 2: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x, origin.y + childSize.y), childSize); // South East case 3: return Box&lt;Float&gt;(origin + childSize, childSize); default: assert(false &amp;&amp; "Invalid child index"); return Box&lt;Float&gt;(); } }</span></span></code> </pre> <br>  O segundo, <code>getQuadrant</code> , retorna o quadrante em que o valor est√° localizado: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getQuadrant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; nodeBox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; valueBox)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> center = nodeBox.getCenter(); <span class="hljs-comment"><span class="hljs-comment">// West if (valueBox.getRight() &lt; center.x) { // North West if (valueBox.getBottom() &lt; center.y) return 0; // South West else if (valueBox.top &gt;= center.y) return 2; // Not contained in any quadrant else return -1; } // East else if (valueBox.left &gt;= center.x) { // North East if (valueBox.getBottom() &lt; center.y) return 1; // South East else if (valueBox.top &gt;= center.y) return 3; // Not contained in any quadrant else return -1; } // Not contained in any quadrant else return -1; }</span></span></code> </pre> <br>  Retorna <code>-1</code> se n√£o estiver contido em nenhum dos quadrantes. <br><br>  Agora estamos prontos para considerar os m√©todos de inser√ß√£o e exclus√£o. <br><br><h2>  Inserir </h2><br>  O m√©todo <code>add</code> simplesmente chama um m√©todo auxiliar privado: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ add(mRoot.get(), <span class="hljs-number"><span class="hljs-number">0</span></span>, mBox, value); }</code> </pre> <br>  Aqui est√° o c√≥digo do m√©todo auxiliar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Insert the value in this node if possible if (depth &gt;= MaxDepth || node-&gt;values.size() &lt; Threshold) node-&gt;values.push_back(value); // Otherwise, we split and we try again else { split(node, box); add(node, depth, box, value); } } else { auto i = getQuadrant(box, mGetBox(value)); // Add the value in a child if the value is entirely contained in it if (i != -1) add(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), depth + 1, computeBox(box, i), value); // Otherwise, we add the value in the current node else node-&gt;values.push_back(value); } }</span></span></code> </pre> <br>  No in√≠cio, existem algumas suposi√ß√µes que confirmam que n√£o estamos fazendo nada il√≥gico, por exemplo, n√£o estamos inserindo um valor em um n√≥ que n√£o cont√©m sua caixa delimitadora. <br><br>  Ent√£o, se o n√≥ for uma planilha, e podemos inserir um novo valor nele, ou seja,  n√£o atingimos <code>MaxDepth</code> ou <code>Threshold</code> , execute a inser√ß√£o.  Caso contr√°rio, compartilhamos esse n√≥ e tentamos novamente. <br><br>  Se o n√≥ for interno, calcularemos o quadrante que cont√©m a caixa delimitadora do valor.  Se estiver completamente contido no n√≥ filho, fazemos uma chamada recursiva.  Caso contr√°rio, insira neste n√≥. <br><br>  Aqui est√° o procedimento de separa√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only leaves can be split"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Create children for (auto&amp; child : node-&gt;children) child = std::make_unique&lt;Node&gt;(); // Assign values to children auto newValues = std::vector&lt;T&gt;(); // New values for this node for (const auto&amp; value : node-&gt;values) { auto i = getQuadrant(box, mGetBox(value)); if (i != -1) node-&gt;children[static_cast&lt;std::size_t&gt;(i)]-&gt;values.push_back(value); else newValues.push_back(value); } node-&gt;values = std::move(newValues); }</span></span></code> </pre> <br>  Criamos quatro n√≥s filhos e, para cada valor do n√≥ pai, decidimos em qual n√≥ (filho ou pai) o valor deve ser armazenado. <br><br><h2>  Excluir </h2><br>  O m√©todo <code>remove</code> tamb√©m simplesmente chama um m√©todo auxiliar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ remove(mRoot.get(), <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, mBox, value); }</code> </pre> <br>  Aqui est√° o c√≥digo do m√©todo auxiliar, √© muito semelhante ao c√≥digo de inser√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, Node* parent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Remove the value from node removeValue(node, value); // Try to merge the parent if (parent != nullptr) tryMerge(parent); } else { // Remove the value in a child if the value is entirely contained in it auto i = getQuadrant(box, mGetBox(value)); if (i != -1) remove(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), node, computeBox(box, i), value); // Otherwise, we remove the value from the current node else removeValue(node, value); } }</span></span></code> </pre> <br>  Se o n√≥ atual for uma planilha, removeremos o valor da lista de valores do n√≥ atual <br>  e tente mesclar esse n√≥ com os n√≥s irm√£os e seu pai.  Caso contr√°rio, determinamos em qual quadrante a caixa delimitadora do valor est√° localizada.  Se estiver completamente contido no n√≥ filho, faremos uma chamada recursiva.  Caso contr√°rio, exclua dos valores do n√≥ atual. <br><br>  Como n√£o nos importamos com a ordem dos valores armazenados no n√≥, quando apago, uso um pouco de otimiza√ß√£o: apenas altero o valor apagado pelo √∫ltimo e o apago: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the value in node-&gt;values auto it = std::find_if(std::begin(node-&gt;values), std::end(node-&gt;values), [this, &amp;value](const auto&amp; rhs){ return mEqual(value, rhs); }); assert(it != std::end(node-&gt;values) &amp;&amp; "Trying to remove a value that is not present in the node"); // Swap with the last element and pop back *it = std::move(node-&gt;values.back()); node-&gt;values.pop_back(); }</span></span></code> </pre> <br>  Tamb√©m precisamos dar uma olhada no <code>tryMerge</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryMerge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(!isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only interior nodes can be merged"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> nbValues = node-&gt;values.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; child : node-&gt;children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(child.get())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; nbValues += child-&gt;values.size(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nbValues &lt;= Threshold) { node-&gt;values.reserve(nbValues); <span class="hljs-comment"><span class="hljs-comment">// Merge the values of all the children for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : child-&gt;values) node-&gt;values.push_back(value); } // Remove the children for (auto&amp; child : node-&gt;children) child.reset(); } }</span></span></code> </pre> <br>  <code>tryMerge</code> verifica se todos os n√≥s filhos s√£o abandonados e se o n√∫mero total de seus valores e os valores dos n√≥s filhos √© menor que o limite.  Nesse caso, copiamos todos os valores dos n√≥s filhos para o n√≥ atual e exclu√≠mos os n√≥s filhos. <br><br><h1>  Pesquisa de interse√ß√£o </h1><br><h2>  Interse√ß√£o com ret√¢ngulo </h2><br>  Finalmente, chegamos ao mais interessante: a busca de cruzamentos.  A primeira maneira de us√°-lo √© obter todos os valores que cruzam um determinado ret√¢ngulo.  Por exemplo, isso √© necess√°rio para executar o recorte. <br><br>  Isso ser√° <code>query</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; query(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> values = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(); query(mRoot.get(), mBox, box, values); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values; }</code> </pre> <br>  Nesse m√©todo, simplesmente selecionamos <code>std::vector</code> , que conter√° os valores que cruzam a caixa delimitadora e chamamos o m√©todo auxiliar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; queryBox, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; values)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(queryBox.intersects(box)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; value : node-&gt;values) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(mGetBox(value))) values.push_back(value); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(node)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); i &lt; node-&gt;children.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childBox = computeBox(box, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(i)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(childBox)) query(node-&gt;children[i].get(), childBox, queryBox, values); } } }</code> </pre> <br>  Primeiro, adicionamos todos os valores armazenados no n√≥ atual que se cruzam com o ret√¢ngulo solicitado.  Ent√£o, se o n√≥ atual for interno, fazemos uma chamada recursiva para cada n√≥ filho cujo ret√¢ngulo delimitador se cruza com o ret√¢ngulo solicitado. <br><br><h2>  Todas as interse√ß√µes aos pares </h2><br>  O segundo caso de uso suportado √© procurar todos os pares de valores armazenados na √°rvore do quadrante que se cruzam.  Isso √© especialmente √∫til ao criar um mecanismo f√≠sico.  Esse problema pode ser resolvido usando o m√©todo de <code>query</code> .  E, de fato, podemos chamar <code>query</code> na caixa delimitadora de todos os valores.  No entanto, isso pode ser feito de forma mais eficiente, adicionando apenas uma interse√ß√£o para um par (com a <code>query</code> , vamos encontr√°-los duas vezes). <br><br>  Para perceber isso, precisamos considerar que a interse√ß√£o s√≥ pode ocorrer <br><br><ul><li>  entre dois valores armazenados em um n√≥ </li></ul><br>  ou <br><br><ul><li>  entre o valor armazenado no n√≥ e outro valor armazenado no descendente desse n√≥. </li></ul><br>  Por esse motivo, devemos verificar apenas a interse√ß√£o entre: <br><br><ul><li>  valor e os seguintes valores armazenados no mesmo n√≥ </li></ul><br>  e <br><br><ul><li>  valor e valores armazenados no descendente. </li></ul><br>  Portanto, definitivamente n√£o reportaremos a mesma interse√ß√£o duas vezes. <br><br>  Aqui est√° o c√≥digo <code>findAllIntersections</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt; findAllIntersections() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> intersections = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt;(); findAllIntersections(mRoot.get(), intersections); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intersections; }</code> </pre> <br>  Novamente, simplesmente alocamos <code>std::vector</code> para armazenar as interse√ß√µes e chamar a fun√ß√£o helper: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllIntersections</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find intersections between values stored in this node // Make sure to not report the same intersection twice for (auto i = std::size_t(0); i &lt; node-&gt;values.size(); ++i) { for (auto j = std::size_t(0); j &lt; i; ++j) { if (mGetBox(node-&gt;values[i]).intersects(mGetBox(node-&gt;values[j]))) intersections.emplace_back(node-&gt;values[i], node-&gt;values[j]); } } if (!isLeaf(node)) { // Values in this node can intersect values in descendants for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : node-&gt;values) findIntersectionsInDescendants(child.get(), value, intersections); } // Find intersections in children for (const auto&amp; child : node-&gt;children) findAllIntersections(child.get(), intersections); } }</span></span></code> </pre> <br>  No primeiro est√°gio, as interse√ß√µes entre os valores armazenados no n√≥ atual s√£o verificadas.  Em seguida, se o n√≥ atual for interno, <code>findIntersectionInDescendants</code> verificar√° as interse√ß√µes entre os valores armazenados nesse n√≥ e os valores armazenados em seus descendentes.  Finalmente, fazemos chamadas recursivas. <br><br>  <code>findIntersectionsInDescendants</code> localiza recursivamente interse√ß√µes entre o valor fornecido e todos os valores armazenados na sub√°rvore: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findIntersectionsInDescendants</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Test against the values stored in this node for (const auto&amp; other : node-&gt;values) { if (mGetBox(value).intersects(mGetBox(other))) intersections.emplace_back(value, other); } // Test against values stored into descendants of this node if (!isLeaf(node)) { for (const auto&amp; child : node-&gt;children) findIntersectionsInDescendants(child.get(), value, intersections); } }</span></span></code> </pre> <br>  Isso √© tudo!  Repito, todo o c√≥digo √© publicado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br><h1>  Recursos √∫teis </h1><br>  Se voc√™ quiser saber mais sobre o reconhecimento de colis√µes e estruturas de dados de particionamento, recomendo a leitura do livro de Christer Erickson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Detec√ß√£o de colis√µes em tempo real</a> .  Muitos t√≥picos s√£o profundamente revelados e, ao mesmo tempo, o livro √© escrito em uma linguagem muito compreens√≠vel.  Al√©m disso, os cap√≠tulos podem ser lidos separadamente.  Esta √© uma √≥tima fonte de refer√™ncia. <br><br><h1>  Conclus√£o </h1><br>  Isso conclui o trabalho com reconhecimento de colis√£o.  No entanto, √© apenas metade do mecanismo f√≠sico.  A segunda metade √© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">resolu√ß√£o de colis√µes</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt473066/">https://habr.com/ru/post/pt473066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt473056/index.html">Como Alice reconhece pa√≠ses a partir de fotografias. Pesquisa Yandex</a></li>
<li><a href="../pt473058/index.html">Sergey Sinitsyn: ‚ÄúOSM √© mais do que apenas desenhar casas ou trilhas. S√£o mais hist√≥rias! ‚Äù</a></li>
<li><a href="../pt473060/index.html">Rela√ß√µes informais em uma equipe: por que e como gerenci√°-los</a></li>
<li><a href="../pt473062/index.html">User.js subjetivo para o Mozilla Firefox e n√£o apenas</a></li>
<li><a href="../pt473064/index.html">L√°grimas batavianas, carros e Gorilla Glass: sobre alguns tipos de vidro refor√ßado</a></li>
<li><a href="../pt473072/index.html">Como a Gazpromneft cria um caminho digital para um cliente corporativo</a></li>
<li><a href="../pt473078/index.html">Gerencie facilmente configura√ß√µes de microsservi√ßos com o microconfig.io</a></li>
<li><a href="../pt473082/index.html">Como escrevemos microsservi√ßos e por que n√£o o fazemos rapidamente</a></li>
<li><a href="../pt473084/index.html">"Ivan" √© uma profiss√£o de bot de bate-papo. Ou experimentos criativos com assistentes virtuais</a></li>
<li><a href="../pt473086/index.html">Como o malware evita caixas de areia com o Visual Basic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>