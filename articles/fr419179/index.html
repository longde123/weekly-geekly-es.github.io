<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔀 💀 👨🏿‍🔧 Architecture pragmatique pure. Remue-méninges 🙎🏽 👨🏻‍🏫 🛀🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'idée vous est-elle venue à l'esprit pour réécrire votre application d'entreprise audacieuse à partir de zéro? Si à partir de zéro, alors c'est wow. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Architecture pragmatique pure. Remue-méninges</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/419179/">  L'idée vous est-elle venue à l'esprit pour réécrire votre application d'entreprise audacieuse à partir de zéro?  Si à partir de zéro, alors c'est wow.  Au moins deux fois moins de code, non?  Mais quelques années passeront, et elles grandiront également, deviendront héritage ... il n'y a pas beaucoup de temps et d'argent pour que la réécriture fonctionne parfaitement. <br><br>  Calmez-vous, les autorités ne permettront toujours pas de réécrire quoi que ce soit.  Reste à refactoriser.  Quelle est la meilleure façon de dépenser vos petites ressources?  Comment refactoriser où nettoyer? <br><br>  Le titre de cet article comprend une référence au livre de l’oncle Bob <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Architecture propre»</a> , et il a été fait sur la base d’un merveilleux rapport de Victor Rentea ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site Web</a> ) sur JPoint (sous le chat, il commencera à parler à la première personne, mais pour le moment lisez l’introduction).  En lisant des livres intelligents, cet article ne remplace pas, mais pour une description aussi courte est très bien présentée. <br><br>  L'idée est que les choses populaires comme «l'architecture propre» sont vraiment utiles.  Surprise  Si vous devez résoudre un problème très spécifique, un code simple et élégant ne nécessite pas d'effort supplémentaire ni de sur-ingénierie.  L'architecture pure indique que vous devez protéger votre modèle de domaine contre les effets externes et vous indique exactement comment cela peut être fait.  Une approche évolutive pour augmenter le volume des microservices.  Des tests qui rendent le refactoring moins effrayant.  Vous savez déjà tout ça?  Ou vous savez, mais vous avez même peur d'y penser, car c'est une horreur que devrez-vous faire alors? <br><br>  Qui veut obtenir une pilule magique anti-procrastination qui aidera à arrêter de trembler et à commencer à refactoriser - bienvenue dans le reportage vidéo ou sous cat. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mBxpOvlbAow" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><a name="habracut"></a><br><br>  Je m'appelle Victor, je viens de Roumanie.  Formellement, je suis consultant, expert technique et architecte principal chez IBM roumain.  Mais si on me demandait de donner une définition de mon activité moi-même, alors je suis un évangéliste du code pur.  J'adore créer un code beau, propre et pris en charge - en règle générale, j'en parle dans les rapports.  Plus encore, je suis inspiré par l'enseignement: former les développeurs dans les domaines de Java EE, Spring, Dojo, Test Driven Development, Java Performance, ainsi que dans le domaine de l'évangélisation mentionné - les principes des modèles de code propre et leur développement. <br><br>  L'expérience sur laquelle ma théorie est basée est principalement le développement d'applications d'entreprise pour le plus grand client IBM en Roumanie - le secteur bancaire. <br><br>  Le plan de cet article est le suivant: <br><br><ul><li>  Modélisation des données: les structures de données ne doivent pas devenir nos ennemis; <br></li><li>  Organisation de la logique: le principe de "décomposition du code, qui est trop"; <br></li><li>  «Onion» est l'architecture de philosophie Transaction Script la plus pure; <br></li><li>  Les tests comme moyen de gérer les craintes des développeurs. <br></li></ul><br><br>  Mais d'abord, rappelons les grands principes dont nous, développeurs, devons toujours nous souvenir. <br><br><h4>  Principe de responsabilité exclusive </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/353/dd0/cd5/353dd0cd58012749b70e379e37231265.jpg"><br><br>  En d'autres termes, quantité vs qualité.  En règle générale, plus votre classe contient de fonctionnalités, pire elle se révèle dans un sens qualitatif.  En développant de grandes classes, le programmeur commence à devenir confus, à commettre des erreurs dans la construction des dépendances, et le code volumineux, entre autres, est plus difficile à déboguer.  Il est préférable de diviser une telle classe en plusieurs classes plus petites, chacune étant responsable d'une sous-tâche.  Mieux vaut avoir quelques modules étroitement couplés qu'un seul - grand et lent.  La modularité permet également la réutilisation de la logique. <br><br><h4>  Liaison de module faible </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/1c8/0f7/f721c80f7b3184be2218a01b66f7440a.jpg"><br><br>  Le degré de liaison est une mesure de la façon dont vos modules interagissent les uns avec les autres.  Il montre à quel point l'effet des modifications que vous apportez à un moment donné du système est en mesure de se propager.  Plus la liaison est élevée, plus il est difficile d'apporter des modifications: vous changez quelque chose dans un module, et l'effet s'étend loin et pas toujours de la manière attendue.  Par conséquent, l'indicateur de liaison doit être aussi bas que possible - cela fournira plus de contrôle sur le système en cours de modification. <br><br><h4>  Ne répétez pas </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b9/9de/5c0/2b99de5c00257d6123553c7bfaed0519.jpg"><br><br>  Vos propres implémentations peuvent être bonnes aujourd'hui, mais pas si bonnes demain.  Ne vous autorisez pas à copier vos propres bonnes pratiques et donc à les diffuser dans une base de code.  Vous pouvez copier à partir de StackOverflow, à partir de livres - à partir de toutes sources faisant autorité qui (comme vous le savez avec certitude) offrent une implémentation idéale (ou proche de cela).  L'amélioration de votre propre implémentation, qui se produit plus d'une fois, mais multipliée dans la base de code, peut être très fatigante. <br><br><h4>  Simplicité et concision </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d4/8d4/c85/7d48d4c85408c620ddcbe644c4acb6f9.jpg"><br><br>  À mon avis, c'est le principe principal qui doit être observé dans l'ingénierie et le développement de logiciels.  "L'encapsulation prématurée est la racine du mal", a déclaré Adam Bien.  En d'autres termes, la racine du mal réside dans la «réingénierie».  L'auteur de la citation, Adam Bien, a été à un moment donné engagé dans des applications héritées et, en réécrivant complètement leur code, a reçu une base de code 2-3 fois plus petite que celle d'origine.  D'où vient tant de code supplémentaire?  Après tout, cela se pose pour une raison.  Ses craintes nous font naître.  Il nous semble qu'en empilant un grand nombre de modèles, générant indirects et abstractions, nous assurons à notre code une protection - une protection contre les inconnues de demain et les exigences de demain.  Après tout, en fait, aujourd'hui, nous n'avons besoin de rien de tout cela, nous n'inventons tout cela que pour des «besoins futurs».  Et il est possible que ces structures de données interfèrent par la suite.  Pour être honnête, lorsque certains de mes développeurs viennent vers moi et disent qu'il a trouvé quelque chose d'intéressant qui peut être ajouté au code de production, je réponds toujours de la même manière: "Mon garçon, cela ne vous sera pas utile." <br><br>  Il ne devrait pas y avoir beaucoup de code, et celui qui est devrait être simple - la seule façon de travailler normalement avec lui.  C'est une préoccupation pour vos développeurs.  Vous devez vous rappeler qu'ils sont les chiffres clés de votre système.  Essayez de réduire leur consommation d'énergie, de réduire les risques avec lesquels ils devront travailler.  Cela ne signifie pas que vous devez créer votre propre framework, d'ailleurs, je ne vous conseillerais pas de le faire: il y aura toujours des bugs dans votre framework, tout le monde devra l'étudier, etc.  Il vaut mieux utiliser les actifs existants, qui sont aujourd'hui massifs.  Ces solutions devraient être simples.  Notez les gestionnaires d'erreurs globaux, appliquez la technologie d'aspect, les générateurs de code, les extensions Spring ou CDI, configurez les portées de demande / thread, utilisez la manipulation et la génération de bytecode à la volée, etc. Tout cela sera votre contribution à la chose la plus importante - le confort de votre développeur. <br><br>  En particulier, je voudrais vous démontrer l'application des zones Requête / Thread.  J'ai vu à plusieurs reprises comment cette chose a incroyablement simplifié les applications d'entreprise.  L'essentiel est qu'il vous donne la possibilité, en tant qu'utilisateur connecté, d'enregistrer les données RequestContext.  Ainsi, RequestContext stockera les données utilisateur sous une forme compacte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/341/6c5/474/3416c54740aca3b8f514696bf9cf7f3d.jpg"><br><br>  Comme vous pouvez le voir, l'implémentation ne prend que quelques lignes de code.  Après avoir écrit la demande dans l'annotation requise (il n'est pas difficile de le faire si vous utilisez Spring ou CDI), vous vous libérerez de la nécessité de passer la connexion utilisateur aux méthodes et autres: les métadonnées de la demande stockées dans le contexte navigueront de manière transparente dans l'application.  Un proxy limité vous permettra d'accéder à tout moment aux métadonnées de la demande en cours. <br><br><h4>  Tests de régression </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c5/edf/d7a/5c5edfd7a14d760bc335d8e65f0d5666.jpg"><br><br>  Les développeurs ont peur des exigences mises à jour car ils ont peur des procédures de refactoring (modifications de code).  Et le moyen le plus simple de les aider est de créer une suite de tests fiable pour les tests de régression.  Avec lui, le développeur aura la possibilité à tout moment de tester son temps de fonctionnement - pour s'assurer qu'il ne casse pas le système. <br><br>  Le développeur ne devrait avoir peur de rien casser.  Vous devez tout faire pour que le refactoring soit perçu comme quelque chose de bien. <br>  Le refactoring est un aspect essentiel du développement.  Rappelez-vous, exactement au moment où vos développeurs ont peur de refactoriser, l'application peut être considérée comme devenue Legacy. <br><br><h2>  Où implémenter la logique métier? </h2><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fb/8a2/08d/4fb8a208dc6d89279a663747de74369f.jpg"><br><br>  À partir de la mise en œuvre de tout système (ou composants du système), nous nous posons la question: où est-il préférable de mettre en œuvre la logique du domaine, c'est-à-dire les aspects fonctionnels de notre application?  Il existe deux approches opposées. <br>  Le premier est basé sur la philosophie <i>Transaction Script</i> .  Ici, la logique est implémentée dans des procédures qui fonctionnent avec des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">entités anémiques</a> (c'est-à-dire avec des structures de données).  Une telle approche est bonne car au cours de sa mise en œuvre, il est possible de s'appuyer sur les tâches métier formulées.  Tout en travaillant sur des applications pour le secteur bancaire, j'ai observé à plusieurs reprises le transfert de procédures métier vers des logiciels.  Je peux dire qu'il est vraiment très naturel de corréler des scénarios avec des logiciels. <br><br>  Une autre approche consiste à utiliser les principes de la <i>conception pilotée par domaine</i> .  Ici, vous devrez mettre en corrélation les spécifications et les exigences avec une méthodologie orientée objet.  Il est important de bien considérer les objets et d'assurer une bonne implication commerciale.  L'avantage des systèmes ainsi conçus est qu'à l'avenir ils seront facilement entretenus.  Cependant, d'après mon expérience, la maîtrise de cette méthodologie est assez difficile: vous vous sentirez plus ou moins courageux au plus tôt après six mois d'études. <br><br>  Pour mes développements, j'ai toujours choisi la première approche.  Je peux vous assurer que dans mon cas, cela a parfaitement fonctionné. <br><br><h2>  Modélisation des données </h2><br><br><h4>  Entités </h4><br><br>  Comment modélisons-nous les données?  Dès que l'application prend des tailles plus ou moins décentes, <i>des données persistantes</i> apparaîtront nécessairement.  C'est le type de données que vous devez stocker plus longtemps que les autres - ce sont les <i>entités de domaine de</i> votre système.  Où les stocker - que ce soit dans la base de données, dans un fichier ou en gérant directement la mémoire - n'a pas d'importance.  L'important est de <i>savoir comment</i> les stocker - dans quelles structures de données. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a8/56b/127/0a856b127ec938a8c17eb345610b0ee8.jpg"><br><br>  Ce choix vous est donné en tant que développeur et ne dépend que de vous que ces structures de données fonctionneront pour vous ou contre vous lors de la mise en œuvre des exigences fonctionnelles à l'avenir.  Pour que tout soit bon, vous devez implémenter des entités en y déposant des grains de <i>logique de domaine réutilisée</i> .  Comment spécifiquement?  Je vais démontrer plusieurs méthodes en utilisant un exemple. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c73/e56/7da/c73e567da2fb69ceb3d627fb408530cd.jpg"><br><br>  Voyons ce que j'ai fourni à l'entité Client.  Tout d'abord, j'ai implémenté un <code>getFullName()</code> <i>synthétique</i> <code>getFullName()</code> qui me renverra la concaténation de firstName et lastName.  J'ai également implémenté la méthode <code>activate()</code> - pour surveiller l'état de mon entité, l'encapsulant ainsi.  Dans cette méthode, j'ai placé, d'une part, une <i>opération de validation</i> , et, d'autre part, en <i>attribuant des valeurs aux champs</i> status et enabledBy, il n'y a donc pas besoin de setters pour eux.  J'ai également ajouté à l'entité Client les <code>isActive()</code> et <code>canPlaceOrders()</code> , qui implémentent la validation lambda en moi.  C'est ce qu'on appelle l'encapsulation des prédicats.  Ces prédicats sont utiles si vous utilisez des filtres Java 8: vous pouvez les passer comme arguments aux filtres.  Je vous conseille d'utiliser ces aides. <br><br>  Peut-être que vous utilisez une sorte d'ORM comme Hibernate.  Supposons que vous ayez deux entités avec une communication bidirectionnelle.  L'initialisation doit être effectuée des deux côtés, sinon, comme vous le comprenez, vous aurez des problèmes lors de l'accès à ces données à l'avenir.  Mais les développeurs oublient souvent d'initialiser un objet de l'une des parties.  Lors du développement de ces entités, vous pouvez fournir des méthodes spéciales qui garantissent une initialisation bidirectionnelle.  Jetez un œil à <code>addAddress()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c55/7fe/273/c557fe273cc1f2658573f9e78a70ca1d.png"><br><br>  Comme vous pouvez le voir, c'est une entité très ordinaire.  Mais à l'intérieur se trouve la logique du domaine.  Ces entités ne doivent pas être maigres et superficielles, mais ne doivent pas être submergées de logique.  Le débordement de logique se produit plus souvent: si vous décidez d'implémenter toute la logique du domaine, alors pour chaque cas d'utilisation, il sera tentant d'implémenter une méthode spécifique.  En règle générale, il existe de nombreux cas d'utilisation.  Vous ne recevrez pas une entité, mais une grande pile de toutes sortes de logiques.  Essayez d'observer la mesure ici: seule la <i>logique réutilisée</i> est placée dans le domaine et seulement <i>en petite quantité.</i> <i><br><br></i> <h4>  <i>Objets de valeur</i> </h4> <i><br><br></i>  En plus des entités, vous aurez probablement aussi besoin de valeurs d'objet.  Ce n'est rien d'autre qu'un moyen de regrouper les données de domaine afin de pouvoir les déplacer ultérieurement dans le système ensemble. <br><br>  L'objet valeur doit être: <br><br><ul><li>  <b>Petit</b> .  Pas de <code>float</code> pour les variables monétaires!  Soyez prudent lors du choix des types de données.  Plus votre objet est compact, plus il est facile pour un nouveau développeur de le comprendre.  C'est la base d'une vie confortable. <br></li><li>  <b>Inchangeable</b> .  Si l'objet est vraiment immuable, alors le développeur peut être calme que votre objet ne changera pas sa valeur et ne se cassera pas après la création.  Cela jette les bases d'un travail calme et confiant. <br></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/765/284/a0e76528432de8c55dc146805a8b286d.jpg"><br><br>  Et si vous ajoutez un appel de méthode <code>validate()</code> au constructeur, le développeur sera en mesure de se calmer pour la validité de l'entité créée (lors du passage, disons, d'une devise inexistante ou d'une somme d'argent négative, le constructeur ne fonctionnera pas). <br><br><h4>  La différence entre une entité et un objet de valeur </h4><br><br>  Les objets de valeur diffèrent des entités en ce qu'ils n'ont pas d'ID fixe.  Les entités auront toujours des champs associés à la clé étrangère d'une table (ou d'un autre stockage).  Les objets de valeur n'ont pas de tels champs.  La question se pose: les procédures de vérification de l'égalité de deux objets valeur et de deux entités sont-elles différentes?  Étant donné que les objets de valeur n'ont pas de champ ID, pour conclure que deux de ces objets sont égaux, vous devez comparer les valeurs de tous leurs champs par paires (c'est-à-dire examiner tout le contenu).  Lors de la comparaison d'entités, il suffit de faire une seule comparaison - par ID de champ.  C'est dans la procédure de comparaison que réside la principale différence entre les entités et les objets de valeur. <br><br><h4>  Objets de transfert de données (DTO) </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/72a/d31/681/72ad31681509cdef20509d4514b02139.jpg"><br><br>  Quelle est l'interaction avec l'interface utilisateur (UI)?  Vous devez lui transmettre les <i>données à afficher</i> .  Aurez-vous vraiment besoin d'une autre structure?  Il en est ainsi.  Et tout cela parce que l'interface utilisateur n'est pas du tout votre ami.  Il a ses propres demandes: il a besoin que les données soient stockées selon leur mode d'affichage.  C'est tellement merveilleux - que ce sont parfois les interfaces utilisateur et leurs développeurs qui nous demandent.  Ensuite, ils doivent obtenir des données pour cinq lignes;  il leur vient alors à l'esprit de créer un <code>isDeletable</code> booléen <code>isDeletable</code> pour l'objet (l'objet peut-il avoir un tel champ en principe?) afin de savoir si le bouton Supprimer est actif ou non.  Mais il n'y a rien à s'indigner.  Les interfaces utilisateur ont simplement des exigences différentes. <br><br>  La question est de savoir si nos entités peuvent leur être confiées pour utilisation?  Très probablement, ils vont les changer, et de la manière la plus indésirable pour nous.  Par conséquent, nous leur fournirons autre chose - <i>Data Transfer Objects</i> (DTO).  Ils seront spécialement adaptés aux exigences externes et à une logique différente de la nôtre.  Voici quelques exemples de structures DTO: Form / Request (provenant de l'interface utilisateur), View / Response (envoyé à l'interface utilisateur), SearchCriteria / SearchResult, etc. Vous pouvez, dans un sens, appeler cela un modèle d'API. <br><br>  Premier principe important: le DTO doit contenir un minimum de logique. <br>  Voici un exemple d'implémentation de <code>CustomerDto</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ec/3bb/716/4ec3bb716c630f3b39ca82f8fe4c5e33.jpg"><br><br>  Contenu: champs <i>privés</i> , getters <i>publics</i> et setters pour eux.  Tout semble super.  OOP dans toute sa splendeur.  Mais une chose est mauvaise: sous la forme de getters et setters, j'ai mis en œuvre trop de méthodes.  Dans DTO, il devrait y avoir aussi peu de logique que possible.  Et puis quelle est ma sortie?  Je rend les champs publics!  Vous direz que cela fonctionne mal avec les références de méthode de Java 8, qu'il y aura des limitations, etc. Mais croyez-le ou non, j'ai fait tous mes projets (10-11 pièces) avec de tels DTO.  Le frère est vivant.  Maintenant, comme mes champs sont publics, je peux facilement définir la valeur sur <code>dto.fullName</code> en mettant simplement un signe égal.  Quoi de plus beau et de plus simple? <br><br><h2>  Organisation logique </h2><br><br><h4>  Cartographie </h4><br><br>  Donc, nous avons une tâche: nous devons transformer nos entités en DTO.  Nous mettons en œuvre la transformation comme suit: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/995/dfd/ca8/995dfdca8c1945fb92a64cee09851259.jpg"><br><br>  Comme vous pouvez le voir, en déclarant un DTO, nous passons aux opérations de mappage (attribution de valeur).  Dois-je être un développeur senior pour écrire des affectations régulières dans de tels nombres?  Pour certains, c'est tellement inhabituel qu'ils commencent à changer de chaussures en cours de route: par exemple, copier des données en utilisant une sorte de cadre de cartographie en utilisant la réflexion.  Mais ils manquent l'essentiel - que tôt ou tard, l'interface utilisateur interagira avec le DTO, à la suite de quoi l'entité et le DTO divergent dans leurs significations. <br><br>  On pourrait, par exemple, mettre des opérations de mappage dans le constructeur.  Mais cela n'est possible pour aucune cartographie;  en particulier, le concepteur ne peut pas accéder à la base de données. <br><br>  Ainsi, nous sommes obligés de laisser les opérations de mappage dans la logique métier.  Et s'ils ont une apparence compacte, il n'y a rien à craindre.  Si le mappage ne prend pas quelques lignes, mais plus, il est préférable de le placer dans le soi-disant <i>mappeur</i> .  Un mappeur est une classe spécialement conçue pour copier des données.  Ceci, en général, est chose antédiluvienne et passe-partout.  Mais derrière eux, vous pouvez masquer nos nombreuses tâches - pour rendre le code plus propre et plus mince. <br><br>  N'oubliez pas: un <i>code devenu trop volumineux doit être déplacé vers une structure distincte</i> .  Dans notre cas, les opérations de mappage étaient vraiment un peu nombreuses, nous les avons donc déplacées vers une classe distincte - le mappeur. <br><br>  Les mappeurs doivent-ils autoriser l'accès à la base de données?  Vous pouvez l'activer par défaut - cela est souvent fait pour des raisons de simplicité et de pragmatisme.  Mais cela vous expose à certains risques. <br><br>  Je vais illustrer avec un exemple.  Sur la base du DTO existant, nous créons l'entité <code>Customer</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef3/9e8/b82/ef39e8b82a023a2fad6afe8e3c22b5ec.png"><br><br>  Pour la cartographie, nous devons obtenir un lien vers le groupe du client à partir de la base de données.  <code>getReference()</code> méthode <code>getReference()</code> , et elle me renvoie une entité.  La demande ira très probablement à la base de données (dans certains cas, cela ne se produit pas et la fonction de remplacement fonctionne). <br><br>  Mais le problème ne nous attend pas ici, mais dans la méthode qui effectue l'opération inverse - transformer l'entité en DTO. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6a/e27/7ff/e6ae277ff6b22588b5bc5aaffabf9d0e.png"><br><br>  À l'aide d'une boucle, nous parcourons toutes les adresses associées au client existant et les traduisons en adresses DTO.  Si vous utilisez ORM, alors, probablement, lorsque vous appelez la méthode <code>getAddresses()</code> , un chargement <code>getAddresses()</code> sera effectué.  Si vous n'utilisez pas ORM, ce sera une demande ouverte à tous les enfants de ce parent.  Et là, vous courez le risque de plonger dans le «problème N + 1».  Pourquoi? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/001/2bb/e540012bbb4a242d84e55a2dffa5ca11.jpg"><br><br>  Vous avez un ensemble de parents dont chacun a des enfants.  Pour tout cela, vous devez créer vos propres analogues à l'intérieur du DTO.  Vous devrez effectuer une requête <code>SELECT</code> pour parcourir N entités parentes puis N requêtes <code>SELECT</code> pour contourner les enfants de chacune d'entre elles.  Total N + 1 demande.  Pour 1000 entités <code>Customer</code> mères, une telle opération prendra 5 à 10 secondes, ce qui, bien sûr, prend beaucoup de temps. <br><br>  Supposons que, néanmoins, notre méthode <code>CustomerDto()</code> soit appelée à l'intérieur de la boucle, convertissant la liste des objets Customer en liste CustomerDto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/58c/9c3/2b3/58c9c32b3e8a01a96d500920dfe5ef07.jpg"><br><br>  Le problème avec les requêtes N + 1 a des solutions standard simples: dans <i>JPQL,</i> vous pouvez utiliser <code>FETCH</code> by customer.addresses pour récupérer des enfants, puis les connecter à l'aide de <code>JOIN</code> , et dans SQL, vous pouvez utiliser le contournement <code>IN</code> et la <code>WHERE</code> . <br><br>  Mais je le ferais différemment.  Vous pouvez savoir quelle est la longueur maximale de la liste des enfants (cela peut être fait, par exemple, sur la base d'une recherche avec pagination).  Si la liste ne contient que 15 entités, nous n'avons besoin que de 16 requêtes.  Au lieu de 5 ms, nous passerons à tout, disons 15 ms - l'utilisateur ne remarquera pas la différence. <br><br><h4>  À propos de l'optimisation </h4><br><br>  Je ne vous conseillerais pas de revenir sur les performances du système au stade initial de développement.  Comme l'a dit Donald Knud: «L'optimisation prématurée est la racine du mal.»  Vous ne pouvez pas optimiser dès le départ.  C'est exactement ce qui doit être laissé pour plus tard.  Et ce qui est particulièrement important: <i>pas d'hypothèses - uniquement des mesures et l'évaluation des mesures!</i> <br><br>  Etes-vous sûr que vous êtes compétent que vous êtes un vrai expert?  Soyez humble en vous évaluant.  Ne pensez pas que vous comprenez la JVM avant d'avoir lu au moins quelques livres sur la compilation JIT.  Il arrive que les meilleurs programmeurs de notre équipe viennent me voir et disent <i>qu'ils pensent</i> avoir trouvé une implémentation plus efficace.  Il s'avère qu'ils ont à nouveau inventé quelque chose qui ne fait que compliquer le code.  Alors je réponds encore et encore: YAGNI.  Nous n'en avons pas besoin. <br><br>  Souvent, pour les applications d'entreprise, aucune optimisation des algorithmes n'est nécessaire.  Le goulot d'étranglement pour eux, en règle générale, n'est pas la compilation et pas en ce qui concerne le processeur, mais toutes sortes d'opérations d'entrée-sortie.  Par exemple, en lisant un million de lignes d'une base de données, des écritures volumineuses dans un fichier, une interaction avec des sockets. <br><br>  Au fil du temps, vous commencez à comprendre quels goulots d'étranglement le système contient et, en renforçant le tout avec des mesures, vous commencerez à optimiser progressivement.  Pour l'instant, gardez le code aussi propre que possible.  Vous constaterez qu'un tel code est beaucoup plus facile à optimiser davantage. <br><br><h4>  Préfère la composition à l'héritage </h4><br><br>  Retour à notre DTO.  Supposons que nous définissions un DTO comme ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/180/39d/f91/18039df91fd1cc76a2413b7f373e7c0b.png"><br><br>  Nous pouvons en avoir besoin dans de nombreux workflows.  Mais ces flux sont différents et, très probablement, chaque cas d'utilisation supposera un degré différent de remplissage sur le terrain.  Par exemple, nous devrons évidemment créer un DTO plus tôt que lorsque nous disposons d'informations complètes sur l'utilisateur.  Vous pouvez temporairement laisser les champs vides.  Mais plus vous ignorerez de champs, plus vous voudrez créer un nouveau DTO plus strict pour ce cas d'utilisation. <br><br>  Vous pouvez également créer des copies d'un DTO trop volumineux (dans le nombre de cas d'utilisation disponibles), puis en supprimer des champs supplémentaires pour chaque copie.  Mais pour de nombreux programmeurs, en raison de leur intelligence et de leur alphabétisation, cela fait vraiment mal d'appuyer sur Ctrl + V.  L'axiome dit que le copier-coller est mauvais. <br><br>  Vous pouvez recourir au principe d' <i>héritage</i> connu dans la théorie de la POO: il suffit de définir un DTO de base et de créer un héritier pour chaque cas d'utilisation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f7/069/77f/6f706977fec8625d720323b64fe87ad8.png"><br><br>  Un principe bien connu est: «Préférez la composition à l'héritage».  Lisez ce qu'il dit: <i>«s'étend»</i> .  Il semble que nous aurions dû «élargir» la classe source.  Mais si vous y réfléchissez, alors ce que nous avons fait n'est pas du tout «l'expansion».  C'est la vraie «répétition» - le même copier-coller, vue latérale.  Par conséquent, nous n'utiliserons pas d'héritage. <br><br>  Mais que devons-nous donc être?  Comment aller à la composition?  Faisons-le de cette façon: écrivez un champ dans CustomerView qui pointera vers l'objet du DTO sous-jacent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f2/d49/831/1f2d49831b9b286b8bc069c824ac2871.jpg"><br><br>  Ainsi, notre structure de base sera imbriquée à l'intérieur.  C'est ainsi que la vraie composition sort. <br><br>  Que nous utilisions l'héritage ou résolvions le problème par composition - ce sont toutes des particularités, des subtilités qui ont surgi profondément au cours de notre mise en œuvre.  Ils sont très <i>fragiles</i> .  Que signifie fragile?  Jetez un œil à ce code: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/921/eb1/ef2/921eb1ef20effd43b129ad5d28b88253.png"><br><br>  La plupart des développeurs à qui j'ai montré cela ont immédiatement laissé entendre que le nombre "2" était répété, il fallait donc le supprimer comme une constante.  Ils n'ont pas remarqué que le diable dans les trois cas a une signification complètement différente (ou «valeur commerciale») et que sa répétition n'est rien de plus qu'une coïncidence.  Tirer un deux dans une constante est une décision légitime, mais très fragile.  Essayez de ne pas autoriser une logique fragile dans le domaine.  Ne travaillez jamais avec des structures de données externes, en particulier avec DTO. <br><br>  Alors, pourquoi le travail d'élimination de l'héritage et d'introduction de la composition est-il inutile?  Précisément parce que nous créons du DTO non pas pour nous, mais pour un client externe.  Et comment l'application client analysera le DTO reçu de vous - vous ne pouvez que deviner.  Mais évidemment, cela n'aura pas grand-chose à voir avec votre implémentation.  Les développeurs, d'autre part, peuvent ne pas faire de distinction pour les DTO de base et non de base que vous avez soigneusement réfléchis;  ils utilisent probablement l'héritage, et peut-être bêtement copier-coller c'est tout. <br><br><h4>  Façades </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/be7/31c/9e4/be731c9e4cfe002cb3b59c11a708f623.jpg"><br><br>  Revenons à l'image globale de l'application.  Je vous conseille d'implémenter la logique du domaine via le <i>modèle de façade</i> , en étendant les façades avec des <i>services de domaine</i> si nécessaire.  Un service de domaine est créé lorsque trop de logique s'accumule dans la façade, et il est plus pratique de le placer dans une classe distincte. <br>  Vos services de domaine doivent nécessairement parler la langue de votre modèle de domaine (ses entités et objets de valeur).  Ils ne doivent en aucun cas travailler avec DTO, car les DTO, comme vous vous en souvenez, sont des structures en constante évolution côté client, trop fragiles pour un domaine. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ad/eb8/657/3adeb86570a92f804ba491836c99b9e8.jpg"><br><br>  À quoi sert la façade? <br><br><ol><li>  Conversion de données.  Si nous avons des entités d'un côté et des DTO de l'autre, il faut effectuer des transformations de l'un à l'autre.  Et c'est la première chose à laquelle les façades sont destinées.  Si la procédure de conversion a augmenté en volume - utilisez les classes de mappage. <br></li><li>  L'implémentation de la logique.  Dans la façade, vous commencerez à écrire la logique principale de l'application.  Dès que cela devient beaucoup - apportez des pièces au service de domaine. <br></li><li>  Validation des données.  N'oubliez pas que toutes les données reçues de l'utilisateur sont, par définition, incorrectes (contenant des erreurs).  La façade a la capacité de valider les données.  Ces procédures, lorsque le volume est dépassé, sont généralement transmises aux <i>valideurs</i> . <br></li><li>  Aspects  Vous pouvez aller plus loin et faire passer chaque cas d'utilisation par sa façade.  Ensuite, il s'avérera ajouter des choses telles que les transactions, la journalisation, les gestionnaires d'exceptions globales aux méthodes de façade. Je note qu'il est très important d'avoir des gestionnaires d'exceptions globales dans toute application qui détectent toutes les erreurs non détectées par d'autres gestionnaires.  Ils aideront grandement vos programmeurs - ils leur donneront la tranquillité d'esprit et la liberté d'action. <br></li></ol><br><br><h4>  Décomposition de beaucoup de code </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/604/a9c/8e8/604a9c8e859ff1dc3fb38208d6bf836d.jpg"><br><br>  Encore quelques mots sur ce principe.  Si la classe a atteint une taille qui ne me convient pas (disons, 200 lignes), je devrais essayer de la diviser en morceaux.  Mais isoler une nouvelle classe d'une classe existante n'est pas toujours facile.  Nous devons trouver des moyens universels.  L'une de ces méthodes consiste à rechercher des noms: vous essayez de trouver un nom pour un sous-ensemble des méthodes de votre classe.  Dès que vous parvenez à trouver un nom, n'hésitez pas à créer une nouvelle classe.  Mais ce n'est pas si simple.  En programmation, comme vous le savez, il n'y a que deux choses complexes: cela invalide le cache et invente des noms.  Dans ce cas, inventer un nom implique d'identifier une sous-tâche - se cacher et donc pas préalablement identifié par quiconque. <br><br>  Un exemple: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81f/fe3/82b/81ffe382b74f6bbd4a91626d83249a97.jpg"><br><br>  Dans la façade d'origine de <code>CustomerFacade</code> certaines des méthodes sont directement liées au client, et certaines sont liées aux préférences du client.  Sur cette base, je pourrai diviser la classe en deux lorsqu'elle atteindra des tailles critiques.  J'obtiens deux façades: <code>CustomerFacade</code> et <code>CustomerPreferencesFacade</code> .  La seule mauvaise chose est que ces deux façades appartiennent au même niveau d'abstraction.  La séparation par niveaux d'abstraction implique quelque chose de différent. <br><br>  Un autre exemple: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ac/84e/788/2ac84e788af60fb038091aed273a390e.jpg"><br><br>  Supposons qu'il existe une classe <code>OrderService</code> dans notre système dans laquelle nous avons implémenté un mécanisme de notification par e-mail.  Nous créons maintenant un <code>DeliveryService</code> et souhaitons utiliser le même mécanisme de notification ici.  Le copier-coller est exclu.  Faisons-le de cette façon: extrayez la fonctionnalité de notification dans la nouvelle classe <code>AlertService</code> et écrivez-la en tant que dépendance pour les <code>OrderService</code> <code>DeliveryService</code> et <code>OrderService</code> .  Ici, contrairement à l'exemple précédent, la séparation s'est produite précisément aux niveaux d'abstraction. <code>DeliveryService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus abstrait que </font></font><code>AlertService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car il l'utilise </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le cadre de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son flux de travail. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La séparation par niveaux d'abstraction suppose toujours que la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classe extraite devient une dépendance</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extraction est effectuée pour être réutilisée</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tâche d'extraction n'est pas toujours facile. </font><font style="vertical-align: inherit;">Elle peut également entraîner certaines difficultés et nécessiter une refactorisation des tests unitaires. </font><font style="vertical-align: inherit;">Néanmoins, selon mes observations, il est encore plus difficile pour les développeurs de rechercher des fonctionnalités dans l'énorme base de code monolithique de l'application.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Programmation par paire </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/625/5b2/346/6255b23467294d6224107235443379f1.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De nombreux consultants parleront de la programmation en binôme, du fait qu'il s'agit d'une solution universelle à tous les problèmes de développement informatique d'aujourd'hui. Pendant ce temps, les programmeurs développent leurs compétences techniques et leurs connaissances fonctionnelles. De plus, le processus lui-même est intéressant, il rassemble l'équipe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne parlant pas en tant que consultants, mais humainement, la chose la plus importante est la suivante: la programmation par paires améliore le «facteur bus». L’essence du «facteur bus» est qu’il </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font><i><font style="vertical-align: inherit;">avoir autant de personnes qui connaissent la structure du système que possible</font></i><font style="vertical-align: inherit;"> . Perdre ces personnes signifie perdre les derniers indices de cette connaissance.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le refactoring de la programmation en binôme est un art qui nécessite de l'expérience et de la formation. Il est utile, par exemple, la pratique du refactoring agressif, de la réalisation de hackathons, de coupures, de codage de dojos, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La programmation par paire fonctionne bien dans les cas où vous devez résoudre des problèmes de grande complexité. Le processus de collaboration n'est pas toujours simple. Mais cela vous garantit que vous éviterez la "réingénierie" - au contraire, vous obtiendrez une implémentation qui répond aux exigences définies avec une complexité minimale. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a5a/5aa/666/a5a5aa666cb29c58dc9bb5b7d5bc6651.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'organisation d'un format de travail pratique est l'une de vos principales responsabilités envers l'équipe. Vous devez constamment prendre soin des conditions de travail du développeur - leur fournir un confort complet et une liberté de créativité, surtout si elles sont nécessaires pour augmenter l'architecture de conception et sa complexité.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Je suis architecte. </font><font style="vertical-align: inherit;">Par définition, j'ai toujours raison. »</font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette stupidité s'exprime périodiquement publiquement ou en coulisses. </font><font style="vertical-align: inherit;">Dans la pratique d'aujourd'hui, les architectes en tant que tels se retrouvent de moins en moins. </font><font style="vertical-align: inherit;">Avec l'avènement d'Agile, ce rôle est progressivement passé aux développeurs seniors, car généralement tout le travail, d'une manière ou d'une autre, est construit autour d'eux. </font><font style="vertical-align: inherit;">La taille de l'implémentation augmente progressivement, et avec cela il y a un besoin de refactoring et de nouvelles fonctionnalités sont en cours de développement.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Architecture de l'oignon </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oignon est la philosophie de script de transaction la plus pure. En le construisant, nous sommes guidés par l'objectif de protéger le code que nous considérons comme critique, et pour cela nous le déplaçons vers le module de domaine. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a45/bb4/94a/a45bb494a51b04ecfe92606b744c0857.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans notre application, les plus importants sont les services de domaine: ils mettent en œuvre les flux les plus critiques. Déplacez-les vers le module de domaine. Bien sûr, il vaut également la peine de déplacer tous vos objets de domaine ici - entités et objets de valeur. Tout le reste que nous avons compilé aujourd'hui - DTO, mappeurs, validateurs, etc. - devient, pour ainsi dire, la première ligne de défense de l'utilisateur. Parce que l'utilisateur, hélas, n'est pas notre ami, et il est nécessaire de protéger le système contre lui. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention à cette dépendance:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/273/6bd/c7d2736bdc016b732c5c431299bf32ea.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le module d'application dépendra du module de domaine, c'est-à-dire pas l'inverse. En enregistrant une telle connexion, nous garantissons que le DTO ne pénètrera jamais dans le territoire sacré du module de domaine: ils ne sont tout simplement pas visibles et inaccessibles depuis le module de domaine. Il s'avère que dans un sens, nous avons clôturé le territoire du domaine - nous avons restreint l'accès à celui-ci par des étrangers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, le domaine peut avoir besoin d'interagir avec certains services externes. Avec des moyens extérieurs peu amicaux, car il est équipé de son DTO. Quelles sont nos options? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Premièrement: évitez l'ennemi à l'intérieur du module. </font></font><br><br><img src="https://habrastorage.org/webt/un/tn/hk/untnhkiksv5id_i-6c4qwdjxy1c.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Évidemment, c'est une mauvaise option: il est possible que demain le service externe ne passe pas à la version 2.0, et nous devrons redessiner notre domaine. Ne laissez pas l'ennemi à l'intérieur du domaine!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je propose une approche différente: nous allons créer un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptateur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> spécial pour l'interaction </font><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/8b1/09c/1238b109c54ac8f19524e6d41b32e85e.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'adaptateur recevra les données d'un service externe, extraira les données dont notre domaine a besoin et les convertira en types de structures requis. </font><font style="vertical-align: inherit;">Dans ce cas, tout ce qui nous est demandé pendant le développement est de corréler les appels vers le système externe avec les exigences du domaine. </font><font style="vertical-align: inherit;">Considérez-le comme un énorme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptateur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme celui-ci </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">J'appelle cette couche «anti-corruption». </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, nous pouvons avoir besoin d'exécuter des requêtes LDAP à partir d'un domaine. </font><font style="vertical-align: inherit;">Pour ce faire, nous mettons en œuvre le «module anti-corruption» </font></font><code>LDAPUserServiceAdapter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/520/fdc/84a/520fdc84a53641a26b957ac010a19c42.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'adaptateur, nous pouvons:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masquer les appels d'API laids (dans notre cas, masquer la méthode qui prend le tableau Object); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pack d'exceptions dans nos propres implémentations; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Convertir les structures de données des autres en leurs propres (dans nos objets de domaine); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vérifiez la validité des données entrantes. </font></font><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est le but de l'adaptateur. </font><font style="vertical-align: inherit;">Bon, à l'interface avec chaque système externe avec lequel vous devez interagir, votre adaptateur doit être installé. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/b1a/663/9c5/b1a6639c58457537fb6a4d9c15e09eae.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, le domaine ne dirigera pas l'appel vers un service externe, mais vers l'adaptateur. </font><font style="vertical-align: inherit;">Pour ce faire, la dépendance correspondante doit être enregistrée dans le domaine (depuis l'adaptateur ou depuis le module d'infrastructure dans lequel elle se trouve). </font><font style="vertical-align: inherit;">Mais cette dépendance est-elle sûre? </font><font style="vertical-align: inherit;">Si vous l'installez comme ceci, un DTO de service externe peut entrer dans notre domaine. </font><font style="vertical-align: inherit;">Nous ne devons pas permettre cela. </font><font style="vertical-align: inherit;">Par conséquent, je vous suggère une autre façon de modéliser les dépendances.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Principe d'inversion de dépendance </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/058/4a1/f7c/0584a1f7c309505e4e5ea0c2b0b26c21.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créons une interface, écrivons-y la signature des méthodes nécessaires et plaçons-la dans notre domaine. La tâche de l'adaptateur est d'implémenter cette interface. Il s'avère que l'interface est à l'intérieur du domaine, et l'adaptateur est à l'extérieur, dans le module d'infrastructure qui importe l'interface. Ainsi, nous avons tourné la direction de la dépendance dans la direction opposée. Au moment de l'exécution, le système de domaine appellera n'importe quelle classe via des interfaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir, rien qu'en introduisant des interfaces dans l'architecture, nous avons pu déployer des dépendances et ainsi sécuriser notre domaine contre les structures étrangères et les API qui y tombent. Cette approche est appelée </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inversion de dépendance</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c2c/cc2/cd0/c2ccc2cd0309a4c8f97b7521cfc63fb7.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En général, l'inversion de dépendance suppose que vous placez les méthodes qui vous intéressent dans l'interface à l'intérieur de votre module de haut niveau (dans le domaine), et implémentez cette interface de l'extérieur - dans l'un ou l'autre module laid de bas niveau (infrastructure). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'interface implémentée à l'intérieur du module de domaine doit parler la langue du domaine, c'est-à-dire qu'elle fonctionnera sur ses entités, ses paramètres et ses types de retour. Au moment de l'exécution, le domaine appellera n'importe quelle classe via un appel polymorphe à l'interface. Les frameworks d'injection de dépendances (comme Spring et CDI) nous fournissent une instance concrète de la classe directement à l'exécution.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais l'essentiel est que pendant la compilation, le module de domaine ne verra pas le contenu du module externe. </font><font style="vertical-align: inherit;">Voilà ce dont nous avons besoin. </font><font style="vertical-align: inherit;">Aucune entité externe ne doit tomber dans le domaine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selon l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oncle Bob</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le principe de l'inversion de contrôle (ou, comme il l'appelle, «architecture plug-in») est peut-être le meilleur que le paradigme OOP offre en général. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a96/3cf/e13/a963cfe13d030fb1d7ec2bf0f780fe43.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette stratégie peut être utilisée pour l'intégration avec tous les systèmes, pour les appels et messages synchrones et asynchrones, pour l'envoi de fichiers, etc.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Présentation de l'ampoule </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc3/64d/cdb/dc364dcdb589b35a0597b6e478aace46.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc décidé de protéger le module de domaine. </font><font style="vertical-align: inherit;">À l'intérieur, il y a un service de domaine, des entités, des objets de valeur, et maintenant des interfaces pour les services externes, ainsi que des interfaces pour le référentiel (pour interagir avec la base de données). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La structure ressemble à ceci: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/07e/983/0c7/07e9830c76d3b263743f8514b13bf42a.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le module d'application, le module d'infrastructure (via l'inversion de dépendance), le module de référentiel (nous considérons également la base de données comme un système externe), le module batch et éventuellement certains autres modules sont des dépendances déclarées pour le domaine. </font><font style="vertical-align: inherit;">Cette architecture est appelée </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«oignon»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">il est également appelé «propre», «hexagonal» et «ports et adaptateurs».</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Module de référentiel </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je vais parler brièvement du module de référentiel. Que ce soit pour le retirer du domaine est une question. La tâche du référentiel est de rendre la logique plus propre, en nous cachant l'horreur de travailler avec des données persistantes. L'option pour les gars de la vieille école est d'utiliser JDBC pour interagir avec la base de données: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/d70/44a/7edd7044a76373b2c513e246bf6eabaa.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez également utiliser Spring et son JdbcTemplate: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/64b/d68/749/64bd68749f5b3de16591a23a8acda193.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou MyBatis DataMapper: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/423/31b/aa1/42331baa178ff3ad8f0ea8fb92704265.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais c'est tellement compliqué et laid que cela décourage tout désir de faire quoi que ce soit d'autre. Par conséquent, je suggère d'utiliser JPA / Hibernate ou Spring Data JPA. Ils nous donneront la possibilité d'envoyer des requêtes construites non pas sur le schéma de la base de données, mais directement sur la base du modèle de nos entités. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implémentation pour JPA / Hibernate: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/110/ebf/ef7/110ebfef7dad2a2bb278c50668eecda9.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le cas de Spring Data JPA:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/10b/e2a/0ff/10be2a0ff082a8c1ac962c4754ec55a8.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Data JPA peut générer automatiquement des méthodes au moment de l'exécution, telles que, par exemple, getById (), getByName (). Il vous permet également d'exécuter des requêtes JPQL si nécessaire - et non vers la base de données, mais vers votre propre modèle d'entité. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code Hibernate JPA et Spring Data JPA est vraiment très bon. Avons-nous besoin de l'extraire du domaine? À mon avis, ce n'est pas ainsi et nécessaire. Très probablement, le code sera encore plus propre si vous laissez ce fragment à l'intérieur du domaine. Alors agissez sur la situation.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/055/f04/37c/055f0437cf059c9f7001db6b3d231e70.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous créez néanmoins un module de référentiel, alors pour l'organisation des dépendances il vaut mieux utiliser le principe de l'inversion de contrôle de la même manière. </font><font style="vertical-align: inherit;">Pour ce faire, placez l'interface dans le domaine et implémentez-la dans le module de référentiel. </font><font style="vertical-align: inherit;">Quant à la logique du référentiel, il est préférable de la transférer vers le domaine. </font><font style="vertical-align: inherit;">Cela rend le test pratique, car vous pouvez utiliser des objets Mock dans le domaine. </font><font style="vertical-align: inherit;">Ils vous permettront de tester la logique rapidement et à plusieurs reprises. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traditionnellement, une seule entité est créée pour un référentiel dans un domaine. </font><font style="vertical-align: inherit;">Ils ne le cassent en morceaux que lorsqu'il devient trop volumineux. </font><font style="vertical-align: inherit;">N'oubliez pas que les classes doivent être compactes.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c8/9e1/7e7/1c89e17e784e4db6fe8d7c713bcf1ab6.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez créer un module séparé, placer l'interface extraite de la façade et les DTO qui en dépendent, puis l'emballer dans un JAR et le transférer vers vos clients Java sous cette forme. </font><font style="vertical-align: inherit;">Ayant ce dossier, ils pourront envoyer des demandes aux façades.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ampoule pragmatique </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus de ceux de nos «ennemis» à qui nous livrons des fonctionnalités, c'est-à-dire des clients, nous avons également des ennemis et, d'autre part, les modules dont nous dépendons nous-mêmes. </font><font style="vertical-align: inherit;">Nous devons également nous protéger de ces modules. </font><font style="vertical-align: inherit;">Et pour cela, je vous propose un «oignon» légèrement modifié - en lui toute l'infrastructure est combinée en un module. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/265/1f1/481/2651f1481062cfe6c18974df9a6dde9b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'appelle cette architecture une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«ampoule pragmatique»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ici, la séparation des composants s'effectue selon le principe du «mien» et du «intégrable»: séparément, cela concerne mon domaine, et séparément, cela fait référence à l'intégration avec des collaborateurs externes. Ainsi, seuls deux modules sont obtenus: le domaine et l'application. Une telle architecture est très bonne, mais uniquement lorsque le module d'application est petit. Sinon, vous feriez mieux de revenir à l'oignon traditionnel.</font></font><br><br><h2>  Les tests </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme je l'ai dit plus tôt, si tout le monde a peur de votre candidature, considérez qu'elle a reconstitué les rangs de Legacy. </font></font><img src="https://habrastorage.org/getpro/habr/post_images/12a/508/d1b/12a508d1b9595239f6d9b9a8a72c9474.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais les tests sont bons. Ils nous donnent un sentiment de confiance qui nous permet de continuer le refactoring. Mais malheureusement, cette confiance peut facilement se révéler injustifiée. Je vais vous expliquer pourquoi. TDD (développement par le biais de tests) suppose que vous êtes à la fois l'auteur du code et l'auteur des cas de test: vous lisez les spécifications, implémentez la fonctionnalité et écrivez immédiatement une suite de tests. Les tests, par exemple, réussiront. Mais que faire si vous avez mal compris les exigences du cahier des charges? Ensuite, les tests ne vérifieront pas ce qui est nécessaire. Votre confiance est donc sans valeur. Et tout cela parce que vous avez écrit du code et des tests seuls.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais essayez de fermer les yeux sur cela. </font><font style="vertical-align: inherit;">Des tests sont encore nécessaires, et en tout cas ils nous donnent confiance. </font><font style="vertical-align: inherit;">Surtout, bien sûr, nous aimons les tests fonctionnels: ils n'impliquent aucun effet secondaire, aucune dépendance - uniquement des données d'entrée et de sortie. </font><font style="vertical-align: inherit;">Pour tester un domaine, vous devez utiliser des objets fantômes: ils vous permettront de tester des classes isolément. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quant aux requêtes de base de données, les tester est désagréable. </font><font style="vertical-align: inherit;">Ces tests sont fragiles, ils nécessitent que vous ajoutiez d'abord des données de test à la base de données - et seulement après cela, vous pouvez procéder au test de la fonctionnalité. </font><font style="vertical-align: inherit;">Mais comme vous le comprenez, ces tests sont également nécessaires, même si vous utilisez JPA.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tests unitaires </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/332/6ec/8bd3326ec6ca9886c78b4239491dc936.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je dirais que la puissance des tests unitaires n'est pas dans la possibilité de les exécuter, mais dans ce que le processus de leur écriture englobe. Pendant que vous écrivez un test, vous repensez et travaillez sur le code - réduisez la connectivité, divisez-le en classes - en un mot, effectuez le prochain refactoring. Le code testé est du code pur; c'est plus simple, la connectivité y est réduite; en général, il est également documenté (un test unitaire bien écrit décrit parfaitement le fonctionnement de la classe). Il n'est pas surprenant que l'écriture des tests unitaires soit difficile, en particulier les premières pièces. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/116/be7/361/116be7361d4d6a2dc8cac91983808378.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au stade des premiers tests unitaires, beaucoup de gens ont vraiment peur des perspectives qu'ils </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doivent vraiment</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tester quelque chose. Pourquoi sont-ils si durs? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parce que ces tests sont le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">premier fardeau pour votre classe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il s'agit du premier coup porté au système, qui montrera peut-être qu'il est fragile et fragile. Mais vous devez comprendre que ces quelques tests sont les plus importants pour votre développement. Ils sont, par essence, vos meilleurs amis, car ils diront tout car il s'agit de la qualité de votre code. Si vous avez peur de cette étape, vous n'irez pas loin. Vous devez exécuter des tests pour votre système. Après cela, la complexité diminuera, les tests seront écrits plus rapidement. En les ajoutant un par un, vous créerez une </font><i><font style="vertical-align: inherit;">base de test de régression</font></i><font style="vertical-align: inherit;"> fiable pour votre système</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Et cela est extrêmement important pour le travail futur de vos développeurs. </font><font style="vertical-align: inherit;">Il leur sera plus facile de refactoriser; </font><font style="vertical-align: inherit;">Ils comprendront que le système peut être testé en régression à tout moment, c'est pourquoi travailler avec la base de code est sûr. </font><font style="vertical-align: inherit;">Et, je vous assure, ils s'engageront beaucoup plus volontiers dans la refactorisation. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb5/3d7/cbd/eb53d7cbdc3b190b2b597d6427088b1a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mon conseil: si vous sentez que vous avez beaucoup de force et d'énergie aujourd'hui, consacrez-vous à la rédaction de tests unitaires. </font><font style="vertical-align: inherit;">Et assurez-vous que chacun est propre, rapide, a son propre poids et ne répète pas les autres.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Astuces </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résumant tout ce qui a été dit aujourd'hui, je voudrais vous avertir avec les conseils suivants: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Restez </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simple</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aussi longtemps que possible (et quel qu'en soit le coût) </font><font style="vertical-align: inherit;">: évitez la «réingénierie» et l'optimisation tardive, ne surchargez pas l'application;</font></font><br></li><li> <i>   </i> ,        ,   ; <br></li><li>  «»           — <i>     </i> ; <br></li><li>   ,        — <i></i> :         ; <br></li><li>    «»,  ,     — <i>           </i> ; <br></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N'ayez pas peur des tests</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : donnez-leur la possibilité de faire tomber votre système, ressentez tous leurs avantages - au final, ce sont vos amis car ils sont capables de signaler honnêtement les problèmes.</font></font><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En faisant ces choses, vous aiderez votre équipe et vous-même. </font><font style="vertical-align: inherit;">Et puis, le jour de la livraison du produit, vous serez prêt.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Que lire </font></font></h2><br><br><img src="https://habrastorage.org/getpro/habr/post_images/852/a4c/37d/852a4c37d17677fa3fb1e7e021f29e4a.jpg"><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 vertus d'un bon objet</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL est la pire erreur en informatique</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'architecture propre</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nouveau jargon de programmation</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualité du code: WTF / minute</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi chaque élément de SOLID est faux!</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un bon logiciel est écrit 3 fois</font></font></a> <br></li></ul><br><br><blockquote>  .        <b>JPoint</b> —  ,  19-20   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Joker 2018</a> —    Java-.       .        . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419179/">https://habr.com/ru/post/fr419179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419165/index.html">Nous envoyons des SMS "anonymes" de la console au numéro souhaité en utilisant le service bytehand et C ++</a></li>
<li><a href="../fr419169/index.html">"World of the Wild West" à travers les yeux du développeur</a></li>
<li><a href="../fr419171/index.html">Désactivation des vérifications de l'état d'exécution dans une application Android</a></li>
<li><a href="../fr419173/index.html">Architecture propre dans le contexte du développement multiplateforme</a></li>
<li><a href="../fr419177/index.html">Amazon Light Patterns</a></li>
<li><a href="../fr419181/index.html">Programmation de la souris: comment nous nous éloignons de la routine CRM</a></li>
<li><a href="../fr419183/index.html">Demopati à Helsinki «Assemblée 2018», reportage photo, premier jour</a></li>
<li><a href="../fr419185/index.html">Aperçu des protocoles actuels de recherche de consensus dans un environnement décentralisé</a></li>
<li><a href="../fr419189/index.html">Pourquoi les forfaits formeront bientôt la base du commerce de détail</a></li>
<li><a href="../fr419193/index.html">Nous traitons des objets en JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>