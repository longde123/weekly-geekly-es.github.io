<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèø ü¶É üßìüèæ Unterst√ºtzung f√ºr hardwarespezifische Anweisungen in .NET Core (jetzt nicht nur SIMD) ‚ÑπÔ∏è üë¨ üí™üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Vor einigen Jahren haben wir beschlossen, den SIMD-Code in .NET zu unterst√ºtzen . Wir haben den System.Numerics Namespace mit den Typen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unterst√ºtzung f√ºr hardwarespezifische Anweisungen in .NET Core (jetzt nicht nur SIMD)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/467663/"><h2 id="vvedenie">  Einf√ºhrung </h2><br><p> Vor einigen Jahren haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir beschlossen, den SIMD-Code in .NET zu unterst√ºtzen</a> .  Wir haben den <code>System.Numerics</code> Namespace mit den Typen <code>Vector2</code> , <code>Vector3</code> , <code>Vector4</code> und <code>Vector&lt;T&gt;</code> .  Diese Typen stellen eine universelle API zum Erstellen, Zugreifen auf und Bearbeiten von Vektoranweisungen dar, wann immer dies m√∂glich ist.  Sie bieten auch Softwarekompatibilit√§t f√ºr F√§lle, in denen die Hardware keine geeigneten Anweisungen unterst√ºtzt.  Dies erm√∂glichte es mit minimalem Refactoring, eine Reihe von Algorithmen zu vektorisieren.  Wie dem auch sei, die Allgemeing√ºltigkeit dieses Ansatzes macht es schwierig, ihn anzuwenden, um den vollen Vorteil aller verf√ºgbaren Vektoranweisungen auf moderner Hardware zu erhalten.  Dar√ºber hinaus bietet moderne Hardware eine Reihe spezialisierter Anweisungen, die keine Vektoren sind und die Leistung erheblich verbessern k√∂nnen.  In diesem Artikel werde ich dar√ºber sprechen, wie wir diese Einschr√§nkungen in .NET Core 3.0 umgangen haben. </p><br><p><img src="https://habrastorage.org/webt/4d/mx/lt/4dmxlt8xgnpgncvellsujvoe_rk.jpeg"><br>  <strong>Hinweis: Es</strong> <em>gibt noch keinen festgelegten Begriff f√ºr <strong>die</strong> √úbersetzung von <strong>Intrisics</strong> .</em>  <em>Am Ende des Artikels wird √ºber die √úbersetzungsoption abgestimmt.</em>  <em>Wenn wir eine gute Option w√§hlen, werden wir den Artikel √§ndern</em> </p><a name="habracut"></a><br><h2 id="chto-takoe-vstroennye-funkcii">  Was sind die eingebauten Funktionen </h2><br><p>  In .NET Core 3.0 haben wir neue Funktionen hinzugef√ºgt, die als <em>hardwarespezifische integrierte Funktionen</em> (Far WF) bezeichnet werden.  Diese <em>Funktionalit√§t</em> bietet Zugriff auf viele spezifische Hardwareanweisungen, die nicht einfach durch allgemeinere Mechanismen dargestellt werden k√∂nnen.  Sie unterscheiden sich von vorhandenen SIMD-Anweisungen darin, dass sie keinen allgemeinen Zweck haben (neue <em>WFs</em> sind nicht plattform√ºbergreifend und ihre Architektur bietet keine Softwarekompatibilit√§t).  Stattdessen bieten sie .NET-Entwicklern direkt plattform- und hardwarespezifische Funktionen.  Bestehende SIMD-Funktionen, z. B. plattform√ºbergreifend, bieten Softwarekompatibilit√§t und sind geringf√ºgig von der zugrunde liegenden Hardware abstrahiert.  Diese Abstraktion kann teuer sein und au√üerdem die Offenlegung einiger Funktionen verhindern (wenn beispielsweise Funktionen nicht vorhanden sind oder auf allen Zielplattformen schwer zu emulieren sind). </p><br><p>  Neue <em>integrierte Funktionen</em> und unterst√ºtzte Typen befinden sich im <code>System.Runtime.Intrinsics</code> .  F√ºr .NET Core 3.0 gibt es <code>System.Runtime.Intrinsics.X86</code> einen <code>System.Runtime.Intrinsics.X86</code> .  Wir arbeiten an der Unterst√ºtzung <em>integrierter Funktionen</em> f√ºr andere Plattformen wie <code>System.Runtime.Intrinsics.Arm</code> . </p><br><p>  Unter plattformspezifischen Namespaces werden <em>WFs</em> in Klassen gruppiert, die Gruppen logisch integrierter Hardwareanweisungen darstellen (h√§ufig als Befehlssatzarchitektur (ISA) bezeichnet).  Jede Klasse stellt eine <code>IsSupported</code> Eigenschaft <code>IsSupported</code> angibt, ob die Hardware, auf der der Code ausgef√ºhrt wird, diese Anweisungen unterst√ºtzt.  Ferner enth√§lt jede solche Klasse einen Satz von Methoden, die einem entsprechenden Satz von Anweisungen zugeordnet sind.  Manchmal gibt es eine zus√§tzliche Unterklasse, die einem Teil desselben Befehlssatzes entspricht, der m√∂glicherweise durch bestimmte Hardware eingeschr√§nkt (unterst√ºtzt) wird.  Beispielsweise bietet die <code>Lzcnt</code> Klasse Zugriff auf <em>Anweisungen zum Z√§hlen f√ºhrender Nullen</em> .  Er hat eine Unterklasse namens <code>X64</code> , die die Form dieser Anweisungen enth√§lt, die nur auf Computern mit 64-Bit-Architektur verwendet werden. </p><br><p>  Einige dieser Klassen sind nat√ºrlich hierarchischer Natur.  Wenn beispielsweise <code>Lzcnt.X64.IsSupported</code> true <code>Lzcnt.IsSupported</code> sollte <code>Lzcnt.IsSupported</code> auch true zur√ºckgeben, da dies eine explizite Unterklasse ist.  Wenn beispielsweise <code>Sse2.IsSupported</code> true <code>Sse.IsSupported</code> sollte <code>Sse.IsSupported</code> true zur√ºckgeben, da <code>Sse2</code> explizit von <code>Sse</code> erbt.  Es ist jedoch anzumerken, dass die √Ñhnlichkeit von Klassennamen kein Indikator f√ºr ihre Zugeh√∂rigkeit zu derselben Vererbungshierarchie ist.  Beispielsweise wird <code>Bmi2</code> nicht von <code>Bmi1</code> geerbt, sodass die von <code>IsSupported</code> f√ºr diese beiden Befehlss√§tze zur√ºckgegebenen Werte unterschiedlich sind.  Das Grundprinzip bei der Entwicklung dieser Klassen war die explizite Darstellung der ISA-Spezifikationen.  SSE2 erfordert Unterst√ºtzung f√ºr SSE1, sodass die Klassen, die sie darstellen, durch Vererbung verbunden sind.  Gleichzeitig ben√∂tigt BMI2 keine Unterst√ºtzung f√ºr BMI1, sodass wir keine Vererbung verwendet haben.  Das Folgende ist ein Beispiel f√ºr die obige API. </p><br><pre> <code class="plaintext hljs">namespace System.Runtime.Intrinsics.X86 { public abstract class Sse { public static bool IsSupported { get; } public static Vector128&lt;float&gt; Add(Vector128&lt;float&gt; left, Vector128&lt;float&gt; right); // Additional APIs public abstract class X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;float&gt; value); // Additional APIs } } public abstract class Sse2 : Sse { public static new bool IsSupported { get; } public static Vector128&lt;byte&gt; Add(Vector128&lt;byte&gt; left, Vector128&lt;byte&gt; right); // Additional APIs public new abstract class X64 : Sse.X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;double&gt; value); // Additional APIs } } }</code> </pre> <br><p>  <a href="">Weitere Informationen</a> finden Sie im Quellcode unter den folgenden Links <a href="">source.dot.net oder dotnet / coreclr auf GitHub</a> </p><br><p>  <code>IsSupported</code> Pr√ºfungen <code>IsSupported</code> vom JIT-Compiler als Laufzeitkonstanten verarbeitet (wenn die Optimierung aktiviert ist), sodass Sie keine <code>IsSupported</code> ben√∂tigen, um mehrere ISAs, Plattformen oder Architekturen zu unterst√ºtzen.  Stattdessen m√ºssen Sie den Code nur mit <code>if</code> Ausdr√ºcken schreiben, wodurch nicht verwendete Codeverzweigungen (d. H. Diejenigen Verzweigungen, die aufgrund des Werts der Variablen in der bedingten Anweisung nicht erreichbar sind) verworfen werden, wenn der native Code generiert wird. </p><br><p>  Es ist wichtig, dass die √úberpr√ºfung des entsprechenden <code>IsSupported</code> der Verwendung der integrierten Hardwarebefehle vorausgeht.  Wenn es keine solche Pr√ºfung gibt, l√∂st Code mit plattformspezifischen Befehlen, die auf Plattformen / Architekturen ausgef√ºhrt werden, auf denen diese Befehle nicht unterst√ºtzt werden, eine Laufzeitausnahme von <code>PlatformNotSupportedException</code> . </p><br><h2 id="kakie-preimuschestva-oni-dayut">  Welche Vorteile bieten sie? </h2><br><p>  Nat√ºrlich sind <em>hardwarespezifische integrierte Funktionen</em> nicht jedermanns Sache, aber sie k√∂nnen verwendet werden, um die Leistung bei Operationen zu verbessern, die mit Berechnungen geladen sind.  Die <code>CoreFX</code> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>ML.NET</code></a> verwenden diese Methoden, um Vorg√§nge wie das Kopieren im Speicher, das Suchen nach dem Index eines Elements in einem Array oder einer Zeichenfolge, das √Ñndern der Bildgr√∂√üe oder das Arbeiten mit Vektoren / Matrizen / Tensoren zu beschleunigen.  Die manuelle Vektorisierung von Code, der sich als Engpass herausstellte, kann auch einfacher sein, als es sich anh√∂rt.  Die Vektorisierung des Codes besteht in der Tat darin, im Allgemeinen mehrere Operationen gleichzeitig unter Verwendung von SIMD-Befehlen (ein Befehlsstrom, mehrere Datenstr√∂me) auszuf√ºhren. </p><br><p>  Bevor Sie sich f√ºr die Vektorisierung von Code entscheiden, m√ºssen Sie eine Profilerstellung durchf√ºhren, um sicherzustellen, dass dieser Code wirklich Teil des "Hot Spots" ist (und Ihre Optimierung daher zu einer erheblichen Leistungssteigerung f√ºhrt).  Es ist auch wichtig, in jeder Phase der Vektorisierung eine Profilerstellung durchzuf√ºhren, da die Vektorisierung nicht des gesamten Codes zu einer erh√∂hten Produktivit√§t f√ºhrt. </p><br><h2 id="vektorizaciya-prostogo-algoritma">  Vektorisierung eines einfachen Algorithmus </h2><br><p>  Um die Verwendung <em>integrierter Funktionen</em> zu veranschaulichen <em>, verwenden</em> wir den Algorithmus zum Summieren aller Elemente eines Arrays oder Bereichs.  Diese Art von Code ist ein idealer Kandidat f√ºr die Vektorisierung, weil  Bei jeder Iteration wird dieselbe triviale Operation ausgef√ºhrt. </p><br><p>  Eine beispielhafte Implementierung eines solchen Algorithmus kann wie folgt aussehen: </p><br><pre> <code class="plaintext hljs">public int Sum(ReadOnlySpan&lt;int&gt; source) { int result = 0; for (int i = 0; i &lt; source.Length; i++) { result += source[i]; } return result; }</code> </pre> <br><p>  Dieser Code ist recht einfach und unkompliziert, aber gleichzeitig langsam genug f√ºr gro√üe Eingabedaten  f√ºhrt nur eine triviale Operation pro Iteration aus. </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 AMD Ryzen 7 1800X, 1 CPU, 16 logical and 8 physical cores .NET Core SDK=3.0.100-preview9-013775 [Host] : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT [AttachedDebugger] DefaultJob : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Z√§hlen </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Summe </td><td>  1 </td><td>  2,477 ns </td><td>  0,0192 ns </td><td>  0,0179 ns </td></tr><tr><td>  Summe </td><td>  2 </td><td>  2,164 ns </td><td>  0,0265 ns </td><td>  0,0235 ns </td></tr><tr><td>  Summe </td><td>  4 </td><td>  3,224 ns </td><td>  0,0302 ns </td><td>  0,0267 ns </td></tr><tr><td>  Summe </td><td>  8 </td><td>  4,347 ns </td><td>  0,0665 ns </td><td>  0,0622 ns </td></tr><tr><td>  Summe </td><td>  16 </td><td>  8,444 ns </td><td>  0,2042 ns </td><td>  0,3734 ns </td></tr><tr><td>  Summe </td><td>  32 </td><td>  13.963 ns </td><td>  0,2182 ns </td><td>  0,2041 ns </td></tr><tr><td>  Summe </td><td>  64 </td><td>  50,374 ns </td><td>  0,2955 ns </td><td>  0,2620 ns </td></tr><tr><td>  Summe </td><td>  128 </td><td>  60,139 ns </td><td>  0,3890 ns </td><td>  0,3639 ns </td></tr><tr><td>  Summe </td><td>  256 </td><td>  106,416 ns </td><td>  0,6404 ns </td><td>  0,5990 ns </td></tr><tr><td>  Summe </td><td>  512 </td><td>  291.450 ns </td><td>  3,5148 ns </td><td>  3,2878 ns </td></tr><tr><td>  Summe </td><td>  1024 </td><td>  574,243 ns </td><td>  9,5851 ns </td><td>  8,4970 ns </td></tr><tr><td>  Summe </td><td>  2048 </td><td>  1 137,819 ns </td><td>  5,9363 ns </td><td>  5,5529 ns </td></tr><tr><td>  Summe </td><td>  4096 </td><td>  2 228,341 ns </td><td>  22.8882 ns </td><td>  21.4097 ns </td></tr><tr><td>  Summe </td><td>  8192 </td><td>  2 973.040 ns </td><td>  14.2863 ns </td><td>  12.6644 ns </td></tr><tr><td>  Summe </td><td>  16384 </td><td>  5 883,504 ns </td><td>  15.9619 ns </td><td>  14.9308 ns </td></tr><tr><td>  Summe </td><td>  32768 </td><td>  11 699,237 ns </td><td>  104.0970 ns </td><td>  97,3724 ns </td></tr></tbody></table></div><br><h2 id="povyshenie-proizvoditelnosti-za-schet-razvertyvaniya-ciklov">  Steigern Sie die Produktivit√§t durch Bereitstellungszyklen </h2><br><p>  Moderne Prozessoren bieten verschiedene M√∂glichkeiten zur Verbesserung der Codeleistung.  F√ºr Single-Threaded-Anwendungen besteht eine solche Option darin, mehrere primitive Operationen in einem einzelnen Prozessorzyklus auszuf√ºhren. </p><br><p>  Die meisten modernen Prozessoren k√∂nnen vier Additionsoperationen in einem Taktzyklus (unter optimalen Bedingungen) ausf√ºhren, wodurch Sie mit dem richtigen "Layout" des Codes manchmal die Leistung verbessern k√∂nnen, selbst in einer Single-Threaded-Implementierung. </p><br><p>  Obwohl JIT das Abrollen von Schleifen selbst durchf√ºhren kann, ist JIT aufgrund der Gr√∂√üe des generierten Codes bei dieser Art von Entscheidung konservativ.  Daher kann es vorteilhaft sein, eine Schleife im Code manuell bereitzustellen. </p><br><p>  Sie k√∂nnen die Schleife im obigen Code wie folgt erweitern: </p><br><pre> <code class="plaintext hljs">public unsafe int SumUnrolled(ReadOnlySpan&lt;int&gt; source) { int result = 0; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); // Pin source so we can elide the bounds checks fixed (int* pSource = source) { while (i &lt; lastBlockIndex) { result += pSource[i + 0]; result += pSource[i + 1]; result += pSource[i + 2]; result += pSource[i + 3]; i += 4; } while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p>  Dieser Code ist etwas komplizierter, nutzt jedoch die Hardwarefunktionen besser aus. </p><br><p>  Bei sehr kleinen Schleifen l√§uft dieser Code etwas langsamer.  Dieser Trend √§ndert sich jedoch bereits f√ºr Eingabedaten von acht Elementen, wonach die Ausf√ºhrungsgeschwindigkeit zu steigen beginnt (die Ausf√ºhrungszeit des optimierten Codes f√ºr 32.000 Elemente ist 26% k√ºrzer als die Zeit der Originalversion).  Es ist erw√§hnenswert, dass eine solche Optimierung nicht immer die Produktivit√§t erh√∂ht.  Wenn Sie beispielsweise mit Sammlungen mit Elementen vom Typ <code>float</code> "bereitgestellte" Version des Algorithmus fast die gleiche Geschwindigkeit wie die urspr√ºngliche.  Daher ist es sehr wichtig, eine Profilerstellung durchzuf√ºhren. </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Z√§hlen </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sumunrolled </td><td>  1 </td><td>  2,922 ns </td><td>  0,0651 ns </td><td>  0,0609 ns </td></tr><tr><td>  Sumunrolled </td><td>  2 </td><td>  3,576 ns </td><td>  0,0116 ns </td><td>  0,0109 ns </td></tr><tr><td>  Sumunrolled </td><td>  4 </td><td>  3,708 ns </td><td>  0,0157 ns </td><td>  0,0139 ns </td></tr><tr><td>  Sumunrolled </td><td>  8 </td><td>  4,832 ns </td><td>  0,0486 ns </td><td>  0,0454 ns </td></tr><tr><td>  Sumunrolled </td><td>  16 </td><td>  7,490 ns </td><td>  0,1131 ns </td><td>  0,1058 ns </td></tr><tr><td>  Sumunrolled </td><td>  32 </td><td>  11,277 ns </td><td>  0,0910 ns </td><td>  0,0851 ns </td></tr><tr><td>  Sumunrolled </td><td>  64 </td><td>  19.761 ns </td><td>  0,2016 ns </td><td>  0,1885 ns </td></tr><tr><td>  Sumunrolled </td><td>  128 </td><td>  36,639 ns </td><td>  0,3043 ns </td><td>  0,2847 ns </td></tr><tr><td>  Sumunrolled </td><td>  256 </td><td>  77,969 ns </td><td>  0,8409 ns </td><td>  0,7866 ns </td></tr><tr><td>  Sumunrolled </td><td>  512 </td><td>  146,357 ns </td><td>  1,3209 ns </td><td>  1,2356 ns </td></tr><tr><td>  Sumunrolled </td><td>  1024 </td><td>  287,354 ns </td><td>  0,9223 ns </td><td>  0,8627 ns </td></tr><tr><td>  Sumunrolled </td><td>  2048 </td><td>  566,405 ns </td><td>  4,0155 ns </td><td>  3,5596 ns </td></tr><tr><td>  Sumunrolled </td><td>  4096 </td><td>  1 131.016 ns </td><td>  7,3601 ns </td><td>  6,5246 ns </td></tr><tr><td>  Sumunrolled </td><td>  8192 </td><td>  2 259,836 ns </td><td>  8,6539 ns </td><td>  8,0949 ns </td></tr><tr><td>  Sumunrolled </td><td>  16384 </td><td>  4 501,295 ns </td><td>  6,4186 ns </td><td>  6.0040 ns </td></tr><tr><td>  Sumunrolled </td><td>  32768 </td><td>  8 979.690 ns </td><td>  19.5265 ns </td><td>  18.2651 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4b7/180/775/4b71807758bdae4be2fba1eb6af8360b.png"></p><br><h2 id="povyshenie-proizvoditelnosti-za-schet-vektorizacii-ciklov">  Steigern Sie die Produktivit√§t durch Schleifenvektorisierung </h2><br><p>  Wie dem auch sei, wir k√∂nnen diesen Code dennoch leicht optimieren.  SIMD-Anweisungen sind eine weitere Option moderner Prozessoren, um die Leistung zu verbessern.  Mit einem einzigen Befehl k√∂nnen Sie mehrere Operationen in einem einzigen Taktzyklus ausf√ºhren.  Dies ist m√∂glicherweise besser als das Entfalten einer direkten Schleife, da tats√§chlich dasselbe getan wird, jedoch mit einer geringeren Menge an generiertem Code. </p><br><p>  Zur Verdeutlichung ben√∂tigt jede Additionsoperation in einem bereitgestellten Zyklus 4 Bytes.  Somit ben√∂tigen wir 16 Bytes f√ºr 4 Additionsoperationen in der erweiterten Form.  Gleichzeitig f√ºhrt der SIMD-Additionsbefehl 4 Additionsoperationen aus, ben√∂tigt jedoch nur 4 Bytes.  Dies bedeutet, dass wir weniger Anweisungen f√ºr die CPU haben.  Dar√ºber hinaus kann die CPU im Fall eines SIMD-Befehls <em>Annahmen</em> treffen und Optimierungen durchf√ºhren, was jedoch den Rahmen dieses Artikels sprengt.  Was noch besser ist, ist, dass moderne Prozessoren mehr als einen SIMD-Befehl gleichzeitig ausf√ºhren k√∂nnen, d. H. In einigen F√§llen k√∂nnen Sie eine gemischte Strategie anwenden und gleichzeitig einen Teilzyklus-Scan und eine Vektorisierung durchf√ºhren. </p><br><p>  Im Allgemeinen m√ºssen Sie zun√§chst die Allzweckklasse <code>Vector&lt;T&gt;</code> f√ºr Ihre Aufgaben betrachten.  Er wird wie die neuen <em>WFs</em> SIMD-Anweisungen einbetten, kann aber angesichts der Vielseitigkeit dieser Klasse gleichzeitig die Anzahl der ‚Äûmanuellen‚Äú Codierungen reduzieren. </p><br><p>  Der Code k√∂nnte folgenderma√üen aussehen: </p><br><pre> <code class="plaintext hljs">public int SumVectorT(ReadOnlySpan&lt;int&gt; source) { int result = 0; Vector&lt;int&gt; vresult = Vector&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % Vector&lt;int&gt;.Count); while (i &lt; lastBlockIndex) { vresult += new Vector&lt;int&gt;(source.Slice(i)); i += Vector&lt;int&gt;.Count; } for (int n = 0; n &lt; Vector&lt;int&gt;.Count; n++) { result += vresult[n]; } while (i &lt; source.Length) { result += source[i]; i += 1; } return result; }</code> </pre> <br><p>  Dieser Code funktioniert schneller, aber wir m√ºssen bei der Berechnung des Endbetrags auf jedes Element separat verweisen.  Au√üerdem hat <code>Vector&lt;T&gt;</code> keine genau definierte Gr√∂√üe und kann je nach Ger√§t, auf dem der Code ausgef√ºhrt wird, variieren.  <em>Hardwarespezifische integrierte Funktionen</em> bieten zus√§tzliche Funktionen, die diesen Code geringf√ºgig verbessern und etwas schneller machen k√∂nnen (auf Kosten zus√§tzlicher Codekomplexit√§t und Wartungsanforderungen). </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Z√§hlen </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  SumVectorT </td><td>  1 </td><td>  4,517 ns </td><td>  0,0752 ns </td><td>  0,0703 ns </td></tr><tr><td>  SumVectorT </td><td>  2 </td><td>  4,853 ns </td><td>  0,0609 ns </td><td>  0,0570 ns </td></tr><tr><td>  SumVectorT </td><td>  4 </td><td>  5,047 ns </td><td>  0,0909 ns </td><td>  0,0850 ns </td></tr><tr><td>  SumVectorT </td><td>  8 </td><td>  5,671 ns </td><td>  0,0251 ns </td><td>  0,0223 ns </td></tr><tr><td>  SumVectorT </td><td>  16 </td><td>  6,579 ns </td><td>  0,0330 ns </td><td>  0,0276 ns </td></tr><tr><td>  SumVectorT </td><td>  32 </td><td>  10.460 ns </td><td>  0,0241 ns </td><td>  0,0226 ns </td></tr><tr><td>  SumVectorT </td><td>  64 </td><td>  17.148 ns </td><td>  0,0407 ns </td><td>  0,0381 ns </td></tr><tr><td>  SumVectorT </td><td>  128 </td><td>  23,239 ns </td><td>  0,0853 ns </td><td>  0,0756 ns </td></tr><tr><td>  SumVectorT </td><td>  256 </td><td>  62,146 ns </td><td>  0,8319 ns </td><td>  0,7782 ns </td></tr><tr><td>  SumVectorT </td><td>  512 </td><td>  114,863 ns </td><td>  0,4175 ns </td><td>  0,3906 ns </td></tr><tr><td>  SumVectorT </td><td>  1024 </td><td>  172,129 ns </td><td>  1,8673 ns </td><td>  1,7467 ns </td></tr><tr><td>  SumVectorT </td><td>  2048 </td><td>  429,722 ns </td><td>  1,0461 ns </td><td>  0,9786 ns </td></tr><tr><td>  SumVectorT </td><td>  4096 </td><td>  654,209 ns </td><td>  3,6215 ns </td><td>  3,0241 ns </td></tr><tr><td>  SumVectorT </td><td>  8192 </td><td>  1 675,046 ns </td><td>  14.5231 ns </td><td>  13.5849 ns </td></tr><tr><td>  SumVectorT </td><td>  16384 </td><td>  2 514,778 ns </td><td>  5,3369 ns </td><td>  4,9921 ns </td></tr><tr><td>  SumVectorT </td><td>  32768 </td><td>  6.689,829 ns </td><td>  13.9947 ns </td><td>  13.0906 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00e/0be/5d4/00e0be5d469067af095f34beccf8c45c.png"></p><br><p>  <em>HINWEIS</em> In diesem Artikel habe ich die Gr√∂√üe des <code>Vector&lt;T&gt;</code> mithilfe des internen Konfigurationsparameters ( <code>COMPlus_SIMD16ByteOnly=1</code> ) mit <code>COMPlus_SIMD16ByteOnly=1</code> auf 16 Byte festgelegt.  Diese Optimierung normalisierte die Ergebnisse beim Vergleich von <code>SumVectorT</code> mit <code>SumVectorizedSse</code> und erm√∂glichte es uns, den Code einfach zu halten.  Insbesondere wurde vermieden, einen bedingten Sprung zu schreiben, <code>if (Avx2.IsSupported) { }</code> .  Dieser Code ist fast identisch mit dem Code f√ºr <code>Sse2</code> , behandelt jedoch <code>Vector256&lt;T&gt;</code> (32 Byte) und verarbeitet noch mehr Elemente in einer Iteration der Schleife. </p><br><p>  Mit den neuen <em>integrierten Funktionen</em> kann der Code daher wie folgt umgeschrieben werden: </p><br><pre> <code class="plaintext hljs">public int SumVectorized(ReadOnlySpan&lt;int&gt; source) { if (Sse2.IsSupported) { return SumVectorizedSse2(source); } else { return SumVectorT(source); } } public unsafe int SumVectorizedSse2(ReadOnlySpan&lt;int&gt; source) { int result; fixed (int* pSource = source) { Vector128&lt;int&gt; vresult = Vector128&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); while (i &lt; lastBlockIndex) { vresult = Sse2.Add(vresult, Sse2.LoadVector128(pSource + i)); i += 4; } if (Ssse3.IsSupported) { vresult = Ssse3.HorizontalAdd(vresult, vresult); vresult = Ssse3.HorizontalAdd(vresult, vresult); } else { vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0x4E)); vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0xB1)); } result = vresult.ToScalar(); while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p>  Dieser Code ist wiederum etwas komplizierter, aber f√ºr alle au√üer den kleinsten Eingabes√§tzen erheblich schneller.  Bei 32.000 Elementen wird dieser Code 75% schneller als der erweiterte Zyklus und 81% schneller als der Quellcode des Beispiels ausgef√ºhrt. </p><br><p>  Sie haben festgestellt, dass wir einige <code>IsSupported</code> Schecks ausgestellt haben.  Der erste pr√ºft, ob die aktuelle Hardware den erforderlichen Satz <em>integrierter Funktionen</em> unterst√ºtzt. Wenn nicht, wird die Optimierung durch eine Kombination aus Sweep und <code>Vector&lt;T&gt;</code> .  Die letztere Option wird f√ºr Plattformen wie ARM / ARM64 ausgew√§hlt, die den erforderlichen Befehlssatz nicht unterst√ºtzen oder wenn der Satz f√ºr die Plattform deaktiviert wurde.  Der zweite <code>IsSupported</code> Test in der <code>SumVectorizedSse2</code> Methode wird zur zus√§tzlichen Optimierung verwendet, wenn die Hardware den <code>Ssse3</code> Befehlssatz unterst√ºtzt. </p><br><p>  Ansonsten ist der gr√∂√üte Teil der Logik im Wesentlichen derselbe wie f√ºr die erweiterte Schleife.  <code>Vector128&lt;T&gt;</code> ist ein 128-Bit-Typ, der <code>Vector128&lt;T&gt;.Count</code> Elemente enth√§lt.  In diesem Fall kann <code>uint</code> , das selbst 32-Bit ist, 4 (128/32) Elemente enthalten. Auf diese Weise haben wir die Schleife gestartet. </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Z√§hlen </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sumvectorized </td><td>  1 </td><td>  4,555 ns </td><td>  0,0192 ns </td><td>  0,0179 ns </td></tr><tr><td>  Sumvectorized </td><td>  2 </td><td>  4,848 ns </td><td>  0,0147 ns </td><td>  0,0137 ns </td></tr><tr><td>  Sumvectorized </td><td>  4 </td><td>  5,381 ns </td><td>  0,0210 ns </td><td>  0,0186 ns </td></tr><tr><td>  Sumvectorized </td><td>  8 </td><td>  4,838 ns </td><td>  0,0209 ns </td><td>  0,0186 ns </td></tr><tr><td>  Sumvectorized </td><td>  16 </td><td>  5,107 ns </td><td>  0,0175 ns </td><td>  0,0146 ns </td></tr><tr><td>  Sumvectorized </td><td>  32 </td><td>  5,646 ns </td><td>  0,0230 ns </td><td>  0,0204 ns </td></tr><tr><td>  Sumvectorized </td><td>  64 </td><td>  6,763 ns </td><td>  0,0338 ns </td><td>  0,0316 ns </td></tr><tr><td>  Sumvectorized </td><td>  128 </td><td>  9.308 ns </td><td>  0,1041 ns </td><td>  0,0870 ns </td></tr><tr><td>  Sumvectorized </td><td>  256 </td><td>  15.634 ns </td><td>  0,0927 ns </td><td>  0,0821 ns </td></tr><tr><td>  Sumvectorized </td><td>  512 </td><td>  34.706 ns </td><td>  0,2851 ns </td><td>  0,2381 ns </td></tr><tr><td>  Sumvectorized </td><td>  1024 </td><td>  68.110 ns </td><td>  0,4016 ns </td><td>  0,3756 ns </td></tr><tr><td>  Sumvectorized </td><td>  2048 </td><td>  136,533 ns </td><td>  1,3104 ns </td><td>  1,2257 ns </td></tr><tr><td>  Sumvectorized </td><td>  4096 </td><td>  277.930 ns </td><td>  0,5913 ns </td><td>  0,5531 ns </td></tr><tr><td>  Sumvectorized </td><td>  8192 </td><td>  554.720 ns </td><td>  3,5133 ns </td><td>  3,2864 ns </td></tr><tr><td>  Sumvectorized </td><td>  16384 </td><td>  1 110,730 ns </td><td>  3,3043 ns </td><td>  3,0909 ns </td></tr><tr><td>  Sumvectorized </td><td>  32768 </td><td>  2 200,996 ns </td><td>  21.0538 ns </td><td>  19.6938 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/311/e70/320/311e7032050337fe946103244e749076.png"></p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Neue <em>integrierte Funktionen</em> bieten Ihnen die M√∂glichkeit, die hardwarespezifischen Funktionen des Computers zu nutzen, auf dem Sie den Code ausf√ºhren.  Es gibt ungef√§hr 1.500 APIs f√ºr X86 und X64, die auf 15 S√§tze verteilt sind. Es gibt zu viele, um sie in einem Artikel zu beschreiben.  Durch Profilerstellung von Code zur Identifizierung von Engp√§ssen k√∂nnen Sie den Teil des Codes bestimmen, der von der Vektorisierung profitiert, und einen ziemlich guten Leistungsschub beobachten.  Es gibt viele Szenarien, in denen eine Vektorisierung angewendet werden kann und das Entfalten von Schleifen nur der Anfang ist. </p><br><p>  Jeder, der weitere Beispiele sehen m√∂chte, kann nach der Verwendung <em>integrierter Funktionen</em> im Framework (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dotnet</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aspnet</a> ) oder in anderen Community-Artikeln <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">suchen</a> .  Und obwohl die aktuellen <em>WFs</em> sehr umfangreich sind, m√ºssen noch viele Funktionen eingef√ºhrt werden.  Wenn Sie √ºber die Funktionen verf√ºgen, die Sie einf√ºhren m√∂chten, k√∂nnen Sie Ihre API-Anfrage √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotnet / corefx auf GitHub</a> registrieren.  Der API-√úberpr√ºfungsprozess wird <a href="">hier</a> beschrieben und es gibt ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gutes Beispiel</a> f√ºr eine in Schritt 1 angegebene API-Anforderungsvorlage. </p><br><h2 id="osobye-blagodarnosti">  Besonderer Dank </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mein</a> besonderer Dank gilt den Mitgliedern unserer Community <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fei Peng (@fiigii)</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jacek Blaszczynski (@ 4creators)</a> f√ºr ihre Hilfe bei der Implementierung des <em>WF</em> sowie allen Mitgliedern der Community f√ºr wertvolles Feedback zur Entwicklung, Implementierung und Benutzerfreundlichkeit dieser Funktionalit√§t. </p><br><hr><br><h3 id="posleslovie-k-perevodu">  Nachwort zur √úbersetzung </h3><br><p>  Ich beobachte gerne die Entwicklung der .NET-Plattform und insbesondere der C # -Sprache.  Ich kam aus der Welt von C ++ und hatte wenig Erfahrung mit der Entwicklung in Delphi und Java. Ich war sehr zufrieden damit, Programme in C # zu schreiben.  Im Jahr 2006 erschien mir diese Programmiersprache (die Sprache selbst) in der Welt der verwalteten Speicherbereinigung und plattform√ºbergreifenden Arbeit pr√§gnanter und praktischer als Java.  Daher fiel meine Wahl auf C # und ich bereute es nicht.  Die erste Stufe in der Entwicklung einer Sprache war einfach ihr Aussehen.  Bis 2006 hat C # das Beste aus dieser Zeit in den besten Sprachen und Plattformen aufgenommen: C ++ / Java / Delphi.  Im Jahr 2010 ging F # an die B√∂rse.  Es war eine experimentelle Plattform zur Untersuchung des Funktionsparadigmas mit dem Ziel, es in die Welt von .NET einzuf√ºhren.  Das Ergebnis der Experimente war die n√§chste Stufe in der Entwicklung von C # - die Erweiterung seiner F√§higkeiten in Richtung FP durch die Einf√ºhrung anonymer Funktionen, Lambda-Ausdr√ºcke und letztendlich LINQ.  Diese Erweiterung der Sprache machte C # aus meiner Sicht zur fortschrittlichsten Allzwecksprache.  Der n√§chste Evolutionsschritt betraf die Unterst√ºtzung von Parallelit√§t und Asynchronit√§t.  Task / Task &lt;T&gt;, das gesamte Konzept von TPL, die Entwicklung von LINQ - PLINQ und schlie√ülich async / await.  ,   - ,       .NET   C# ‚Äî      .    Span&lt;T&gt;  Memory&lt;T&gt;, ValueTask/ValueTask&lt;T&gt;, IAsyncDispose, ref readonly struct   in,  foreach, IO.Streams.         GC    .   ,       ‚Äî       .  ,     .NET   C#,  ,          .   (       )         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467663/">https://habr.com/ru/post/de467663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467653/index.html">Habrastatistik: Analyse von Leserkommentaren</a></li>
<li><a href="../de467655/index.html">Wie ich den Sommer mit C # 8 verbracht habe</a></li>
<li><a href="../de467657/index.html">Inventar von I bis Z. Wir z√§hlen Softwarelizenzen</a></li>
<li><a href="../de467659/index.html">Beschleunigen Sie die Ausf√ºhrung von Aufgaben am Beispiel einer zus√§tzlichen Konfiguration des aktualisierten HyperX FURY DDR4-Speichers erheblich</a></li>
<li><a href="../de467661/index.html">Dosimeter f√ºr Seryozha. Teil I. Polimaster - Nuklidj√§ger</a></li>
<li><a href="../de467665/index.html">ROS LKW Wagen. Teil 5. Arbeiten in Rviz und Pavillon: Xacro, neue Sensoren</a></li>
<li><a href="../de467667/index.html">Organisation Projektplanung (Teil 4)</a></li>
<li><a href="../de467669/index.html">Beobachten Sie mich in vollem Umfang: Nutzen Sie das Beste aus Live-Videos auf mobilen Plattformen</a></li>
<li><a href="../de467671/index.html">NLX Retro Computer</a></li>
<li><a href="../de467673/index.html">Eingebaute Go-Funktionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>