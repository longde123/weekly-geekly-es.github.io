<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵 🚜 🛳️ Schmutzige Assembler-Hacks 6502 👩🏽‍🔧 🤜🏽 🙎🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel listet einige der Tricks auf, die Teilnehmer meines kleinen Commodore 64-Programmierwettbewerbs verwendet haben. Die Regeln des Wettbew...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schmutzige Assembler-Hacks 6502</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464377/">  Dieser Artikel listet einige der Tricks auf, die Teilnehmer meines kleinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commodore 64-Programmierwettbewerbs</a> verwendet haben.  Die Regeln des Wettbewerbs waren einfach: Erstellen Sie eine ausführbare C64-Datei (PRG), die zwei Linien zeichnet, um das folgende Bild zu erstellen.  Derjenige, dessen Datei kleiner ist, hat gewonnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/5d1/afc/3f45d1afc9817c6530b6b34c44dd0497.png"></div><br>  Wettbewerbsbeiträge wurden in offenen Tweets und in privaten Nachrichten veröffentlicht, die nur Bytes der PRG-Datei und einen MD5-Hash enthielten. <br><a name="habracut"></a><br>  Teilnehmerliste mit Links zum Quellcode: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Philip Heron</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 34 Bytes, Gewinner) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geir Straume</a> ( <a href="">Code</a> - 34 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Petri Hakkinen</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 37 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matlev Raksenblatts</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 38 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jan Ahrenius</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 48 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jamie Fuller</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 50 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">David A. Gershman</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 53 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Janne Hellsten</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 56 Bytes) </li></ul><br>  (Wenn ich jemanden vermisst habe, lass es mich wissen, ich werde die Liste aktualisieren). <br><br>  Der Rest des Artikels ist einigen Assembler-Tricks gewidmet, die im Wettbewerb verwendet wurden. <br><br><h1>  Die Grundlagen </h1><br>  Grafik C64 funktioniert standardmäßig im 40x25-Zeichencodierungsmodus.  Der Framebuffer im RAM ist in zwei Arrays unterteilt: <br><br><ul><li> <code>$0400</code> (Bildschirm-RAM, 40 x 25 Byte) <br></li><li>  <code>$d800</code> (Farb-RAM, 40 x 25 Byte) </li></ul><br>  Um ein Zeichen festzulegen, speichern Sie das Byte im Bildschirm-RAM bei <code>$0400</code> (z. B. <code>$0400+y*40+x</code> ).  Der Farb-RAM wird standardmäßig hellblau initialisiert (Farbe 14): Dies ist die Farbe, die wir für die Linien verwenden, dh der Farb-RAM kann ohne Berührung belassen werden. <br><br>  Sie steuern die Farben des <code>$d020</code> und des Hintergrunds mithilfe der Speicher-E / A-Register in <code>$d020</code> (Rand) und <code>$d021</code> (Hintergrund). <br><br>  Das Zeichnen von zwei Linien ist ziemlich einfach, wenn Sie die Steigung einer festen Linie direkt programmieren.  Hier ist eine C-Implementierung, die Linien zeichnet und den Inhalt des Bildschirms auf stdout leert ( <code>malloc()</code> wird verwendet, damit der Code auf einem PC funktioniert): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void dump(const uint8_t* screen) { const uint8_t* s = screen; for (int y = 0; y &lt; 25; y++) { for (int x = 0; x &lt; 40; x++, s++) { printf("%c", *s == 0xa0 ? '#' : '.'); } printf("\n"); } } void setreg(uintptr_t dst, uint8_t v) { // *((uint8_t *)dst) = v; } int main() { // uint8_t* screenRAM = (uint_8*)0x0400; uint8_t* screenRAM = (uint8_t *)calloc(40*25, 0x20); setreg(0xd020, 0); // Set border color setreg(0xd021, 0); // Set background color int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; for (int x = 0; x &lt; 40; x++) { int yi = yf &gt;&gt; 8; // First line screenRAM[x + yi*40] = 0xa0; // Second line (X-mirrored) screenRAM[(39-x) + yi*40] = 0xa0; yf += yslope; } dump(screenRAM); }</span></span></span></span></code> </pre> <br>  Die obigen Bildschirmcodes sind <code>$20</code> (leer) und <code>$a0</code> (gefüllter 8 × 8-Block).  Wenn Sie ausführen, wird ein ASCII-Bild mit zwei Zeilen angezeigt: <br><br><pre>  ## .................................... ##
 .. # .................................. # ..
 ... ## .............................. ## ...
 ..... # ............................ # .....
 ...... ## ........................ ## ......
 ........ ## .................... ## ........
 .......... # .................. # ..........
 ........... ## .............. ## ...........
 ............. # ............ # .............
 .............. ## ........ ## ..............
 ................ ## .... ## ................
 .................. # .. # ..................
 ................... ## ...................
 .................. # .. # ..................
 ................ ## .... ## ................
 .............. ## ........ ## ..............
 ............. # ............ # .............
 ........... ## .............. ## ...........
 .......... # .................. # ..........
 ........ ## .................... ## ........
 ...... ## ........................ ## ......
 ..... # ............................ # .....
 ... ## .............................. ## ...
 .. # .................................. # ..
 ## .................................... ## </pre><br>  Dasselbe ist in Assembler trivial implementiert: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) entry: { lda #0 ; black color sta $d020 ; set border to 0 sta $d021 ; set background to 0 ; clear the screen ldx #0 lda #$20 clrscr: !for i in [0, $100, $200, $300] { sta $0400 + i, x } inx bne clrscr ; line drawing, completely unrolled ; with assembly pseudos lda #$a0 !for i in range(40) { !let y0 = Math.floor(25/40*(i+0.5)) sta $0400 + y0*40 + i sta $0400 + (24-y0)*40 + i } inf: jmp inf ; halt }</code> </pre> <br>  Es stellt sich heraus, dass PRG eine ziemlich große Größe von 286 Bytes hat. <br><br>  Bevor wir uns mit der Optimierung befassen, machen wir einige Beobachtungen. <br><br>  Zunächst arbeiten wir an C64 mit den vorhandenen ROM-Routinen.  Es gibt Unmengen von Routinen, die nützlich sein können.  Zum Beispiel das Löschen des Bildschirms mit <code>JSR $E544</code> . <br><br>  Zweitens können Adressberechnungen auf einem 8-Bit-Prozessor wie 6502 umständlich sein und viele Bytes verbrauchen.  Dieser Prozessor hat auch keinen Multiplikator, daher enthält eine Berechnung wie <code>y*40+i</code> normalerweise entweder eine Reihe logischer Verschiebungen oder eine Nachschlagetabelle, die auch Bytes frisst.  Um ein Multiplizieren mit 40 zu vermeiden, bewegen Sie den Bildschirmcursor am besten schrittweise vorwärts: <br><br><pre> <code class="plaintext hljs"> int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xa0; dst[(39-x)] = 0xa0; yf += yslope; if (yf &amp; 256) { // Carry set? dst += 40; yf &amp;= 255; } }</code> </pre> <br>  Wir addieren weiterhin die Steigung der Linie zum festen Zähler <code>yf</code> , und wenn die 8-Bit-Addition das Übertragsflag setzt, addieren wir 40. <br><br>  Hier ist ein inkrementeller Assembler-Ansatz: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) !let screenptr = $20 !let x0 = $40 !let x1 = $41 !let yf = $60 entry: { lda #0 sta x0 sta $d020 sta $d021 ; kernal clear screen jsr $e544 ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1 lda #80 sta yf lda #39 sta x1 xloop: lda #$a0 ldy x0 ; screenRAM[x] = 0xA0 sta (screenptr), y ldy x1 ; screenRAM[39-x] = 0xA0 sta (screenptr), y clc lda #160 ; line slope adc yf sta yf bcc no_add ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1 no_add: inc x0 dec x1 bpl xloop inf: jmp inf }</code> </pre> <br>  Mit 82 Bytes ist es immer noch ziemlich heftig.  Ein offensichtliches Problem sind 16-Bit-Adressberechnungen.  <code>screenptr</code> Sie den <code>screenptr</code> Wert für die indirekte <code>screenptr</code> : <br><br><pre> <code class="plaintext hljs"> ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1</code> </pre> <br>  Wir übersetzen <code>screenptr</code> in die nächste Zeile, indem wir 40 hinzufügen: <br><br><pre> <code class="plaintext hljs"> ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1</code> </pre> <br>  Natürlich kann dieser Code optimiert werden, aber was ist, wenn Sie 16-Bit-Adressen überhaupt entfernen?  Mal sehen, wie es geht. <br><br><h1>  Trick 1. Scrollen! </h1><br>  Anstatt eine Linie im Bildschirm-RAM zu erstellen, zeichnen wir nur in der letzten Bildschirmzeile Y = 24 und scrollen den gesamten Bildschirm nach oben, wobei wir die ROM-Scroll-Funktion mit <code>JSR $E8EA</code> ! <br><br>  So wird xloop optimiert: <br><br><pre> <code class="plaintext hljs"> lda #0 sta x0 lda #39 sta x1 xloop: lda #$a0 ldx x0 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: inc x0 dec x1 bpl xloop</code> </pre> <br>  So sieht das Rendering aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/081/6a6/63f0816a6728ec839de0197b6e0a3179.gif"></div><br><br>  Dies ist einer meiner Lieblingstricks in diesem Programm.  Fast alle Teilnehmer fanden es alleine. <br><br><h1>  Trick 2. Selbstmodifizierender Code </h1><br>  Der Code zum Speichern von Pixelwerten endet wie folgt: <br><br><pre> <code class="plaintext hljs"> ldx x1 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x0 sta $0400 + 24*40, x inc x0 dec x1</code> </pre> <br>  Dies wird in der folgenden Folge von 14 Bytes codiert: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: A6 20 LDX $20 080A: 9D C0 07 STA $07C0,X 080D: E6 22 INC $22 080F: C6 20 DEC $20</code> </pre> <br>  Mit selbstmodifizierendem Code (SMC) können Sie dies kompakter schreiben: <br><br><pre> <code class="plaintext hljs"> ldx x1 sta $0400 + 24*40, x addr0: sta $0400 + 24*40 ; advance the second x-coord with SMC inc addr0+1 dec x1</code> </pre> <br>  ... die mit 13 Bytes codiert ist: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: 8D C0 07 STA $07C0 080B: EE 09 08 INC $0809 080E: C6 22 DEC $22</code> </pre> <br><h1>  Trick 3. Betriebszustand 'Einschalten' </h1><br>  Es wurde im Wettbewerb als normal angesehen, wilde Annahmen über das Arbeitsumfeld zu treffen.  Zum Beispiel, dass die Strichzeichnung das erste ist, was nach dem Einschalten des C64 beginnt, und es keine Anforderungen für eine saubere Ausgabe zurück in die BASIC-Befehlszeile gibt.  Daher kann und sollte alles, was Sie in der Ausgangsumgebung beim Betreten der PRG finden, zu Ihrem Vorteil genutzt werden: <br><br><ul><li>  Die Register A, X, Y werden als Nullen genommen <br></li><li>  Alle CPU-Flags gelöscht <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeropage-</a> Inhalt (Adressen <code>$00</code> - <code>$ff</code> ) </li></ul><br>  Auf die gleiche Weise können Sie beim Aufrufen einiger KERNAL ROM-Prozeduren alle Nebenwirkungen voll ausnutzen: zurückgegebene CPU-Flags, temporäre Nullseitenwerte usw. <br><br>  Suchen wir nach den ersten Optimierungen nach etwas Interessantem im Maschinenspeicher: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/43f/93c/0df43f93c58a142911607d3ba5ba44dd.png"></div><br><br>  Zeropage enthält einige nützliche Werte für unsere Zwecke: <br><br><ul><li>  <code>$d5</code> : 39 / $ 27 == Zeilenlänge - 1 <br></li><li>  <code>$22</code> : 64 / $ 40 == Anfangswert für den Liniensteigungszähler </li></ul><br>  Dadurch werden während der Initialisierung einige Bytes eingespart.  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">!let x0 = $20 lda #39 ; 0801: A9 27 LDA #$27 sta x0 ; 0803: 85 20 STA $20 xloop: dec x0 ; 0805: C6 20 DEC $20 bpl xloop ; 0807: 10 FC BPL $0805</code> </pre> <br>  Da <code>$d5</code> den Wert 39 enthält, können Sie ihn dem Zähler <code>x0</code> und das LDA / STA-Paar <code>x0</code> : <br><br><pre> <code class="plaintext hljs">!let x0 = $d5 ; nothing here! xloop: dec x0 ; 0801: C6 D5 DEC $D5 bpl xloop ; 0803: 10 FC BPL $0801</code> </pre> <br>  Philip, der Gewinner des Wettbewerbs, bringt dies auf das Äußerste.  <code>$07C0</code> Sie die Adresse des letzten Zeichens der Zeichenfolge <code>$07C0</code> (== <code>$0400+24*40</code> ) auf.  Dieser Wert ist während der Initialisierung nicht in Nullseiten vorhanden.  Als Nebeneffekt der Verwendung temporärer Nullseitenwerte durch die Bildlaufroutine aus dem ROM enthalten die Adressen <code>$D1-$D2</code> am Ausgang der Funktion den Wert <code>$07C0</code> .  Daher können Sie zum Speichern eines Pixels anstelle von <code>STA $07C0,x</code> die kürzere indirekte <code>STA $07C0,x</code> <code>STA ($D1),y</code> für ein Byte verwenden. <br><br><h1>  Trick 4. Download-Optimierung </h1><br>  Eine typische C64 PRG-Binärdatei enthält Folgendes: <br><br><ul><li>  Erste 2 Bytes: Download-Adresse (normalerweise <code>$0801</code> ) <br></li><li>  12 Bytes der BASIC-Startsequenz </li></ul><br>  Die Hauptstartsequenz sieht folgendermaßen aus (Adressen <code>$801-$80C</code> ): <br><br><pre> <code class="plaintext hljs">0801: 0B 08 0A 00 9E 32 30 36 31 00 00 00 080D: 8D 20 D0 STA $D020</code> </pre> <br>  Ohne auf Details des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BASIC-Token-Speicherlayouts einzugehen</a> , entspricht diese Sequenz mehr oder weniger '10 SYS 2061 '.  In der Adresse <code>2061</code> ( <code>$080D</code> ) wird unser eigentliches Maschinencode-Programm ausgeführt, wenn der BASIC-Interpreter den SYS-Befehl ausführt. <br><br>  Es scheint nur, dass 14 Bytes zu viel sind.  Philip, Matlev und Geir verwendeten mehrere knifflige Tricks, um die Hauptsequenz vollständig loszuwerden.  Dies erfordert das Laden des PRG mit <code>LOAD"*",8,1</code> , da <code>LOAD"*",8</code> die PRG-Ladeadresse (die ersten zwei Bytes) ignoriert und immer bei <code>$0801</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/911/d07/fdb/911d07fdb2c0e2e13b07e360bb16d03c.png"></div><br><br>  Hier wurden zwei Methoden angewendet: <br><br><ul><li>  Stapeltrick <br></li><li>  BASIC Warm Reset Trick </li></ul><br><h3>  Stapeltrick </h3><br>  Der Trick besteht darin, mit <code>$01F8</code> Wert in den Prozessorstapel <code>$01F8</code> , der unseren gewünschten Einstiegspunkt angibt.  Dazu erstellen Sie eine PRG, die mit einem 16-Bit-Zeiger auf unseren Code beginnt, und laden die PRG bei <code>$01F8</code> : <br><br><pre> <code class="plaintext hljs"> * = $01F8 !word scroll - 1 ; overwrite stack scroll: jsr $E8EA</code> </pre> <br>  Sobald der BASIC-Loader (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code nach der Demontage</a> ) vollständig geladen ist und mit <code>RTS</code> zum Anrufer zurückkehren möchte, kehrt er direkt zu unserem PRG zurück. <br><br><h3>  BASIC Warm Reset Trick </h3><br>  Dies ist etwas einfacher zu erklären, indem Sie sich nach dem Zerlegen die PRG ansehen. <br><br><pre> <code class="plaintext hljs">02E6: 20 EA E8 JSR $E8EA 02E9: A4 D5 LDY $D5 02EB: A9 A0 LDA #$A0 02ED: 99 20 D0 STA $D020,Y 02F0: 91 D1 STA ($D1),Y 02F2: 9D B5 07 STA $07B5,X 02F5: E6 D6 INC $D6 02F7: 65 90 ADC $90 02F9: 85 90 STA $90 02FB: C6 D5 DEC $D5 02FD: 30 FE BMI $02FD 02FF: 90 E7 BCC $02E8 0301: 4C E6 02 JMP $02E6</code> </pre> <br>  <code>JMP $02E6</code> auf die letzte Zeile ( <code>JMP $02E6</code> ).  Der JMP-Befehl beginnt bei <code>$0301</code> mit einer Sprungadresse von <code>$0302-$0303</code> . <br><br>  Wenn dieser Code ab der Adresse <code>$02E6</code> in den Speicher <code>$02E6</code> , wird der Wert <code>$02E6</code> die Adressen <code>$0302-$0303</code> .  Nun, dieser Ort hat eine besondere Bedeutung: Er enthält einen Zeiger auf den „BASIC-Wartezyklus“ (weitere Informationen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C64-Speicherkarte</a> ).  Das Herunterladen von PRG überschreibt es mit <code>$02E6</code> . Wenn der BASIC-Interpreter nach einem Warm-Reset versucht, in die Warteschleife zu wechseln, tritt er nie in diese Schleife ein, sondern gelangt in das Rendering-Programm! <br><br><h3>  Weitere Tricks mit dem Start von BASIC </h3><br>  Petri hat <a href="">einen weiteren BASIC-Starttrick entdeckt</a> , mit dem Sie Ihre eigenen Konstanten in Nullseiten eingeben können.  Bei dieser Methode erstellen Sie manuell Ihre eigene tokenisierte BASIC-Startsequenz und codieren die Konstanten in die Zeilennummern des BASIC-Programms.  Bei der Eingabe werden die BASIC-Zeilennummern, ahem, dh Ihre Konstanten, in den Adressen <code>$39-$3A</code> gespeichert.  Sehr schlau! <br><br><h1>  Trick 5. Benutzerdefinierter Kontrollfluss </h1><br>  Hier ist eine leicht vereinfachte Version von x-loop, die nur eine Zeile druckt und dann die Ausführung stoppt: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: dec x1 bpl xloop ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  Aber es gibt einen Fehler.  Wenn wir das letzte Pixel gezeichnet haben, können wir den Bildschirm nicht mehr scrollen.  Daher sind zusätzliche Verzweigungen erforderlich, um das Scrollen nach dem Aufzeichnen des letzten Pixels zu beenden: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x dec x1 ; skip scrolling if last pixel bmi done adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: jmp xloop done: ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  Der Kontrollfluss ist dem sehr ähnlich, was der C-Compiler aus einem strukturierten Programm erzeugt.  Der Code zum Überspringen des letzten Bildlaufs führt einen neuen <code>JMP abs</code> Befehl ein, der 3 Bytes benötigt.  Bedingte Sprünge sind nur zwei Bytes lang, da sie Sprungadressen unter Verwendung eines relativen 8-Bit-Operanden mit direkter Adressierung codieren. <br><br>  JMP zum „Überspringen des letzten Bildlaufs“ kann vermieden werden, indem der Bildlaufaufruf an den oberen Rand der Schleife verschoben und die Kontrollflussstruktur geringfügig geändert wird.  So hat Philip es implementiert: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 scroll: jsr $e8ea xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf dec x1 ; doesn't set carry! inf: bmi inf ; hang here if last pixel! bcc xloop ; next pixel if no scroll bcs scroll ; scroll up and continue</code> </pre> <br>  Dadurch wird ein Drei-Byte-JMP vollständig eliminiert und der andere JMP in einen bedingten Zwei-Byte-Zweig konvertiert, wodurch insgesamt 4 Byte eingespart werden. <br><br><h1>  Trick 6. Linien mit Bitkomprimierung </h1><br>  Einige Elemente verwenden nicht den Zeilenneigungszähler, sondern komprimieren die Bits in eine 8-Bit-Konstante.  Eine solche Verpackung basiert auf der Tatsache, dass die Position des Pixels entlang der Linie einem sich wiederholenden 8-Pixel-Muster entspricht: <br><br><pre> <code class="plaintext hljs">int mask = 0xB6; // 10110110 uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xA0; if (mask &amp; (1 &lt;&lt; (x&amp;7))) { dst += 40; // go down a row } }</code> </pre> <br>  Dies führt zu einem ziemlich kompakten Assembler.  Die Optionen für den Neigungszähler sind jedoch normalerweise noch kleiner. <br><br><h3>  Gewinner </h3><br>  Hier <a href="">ist das 34-Byte-Wettbewerbsprogramm</a> von Philip.  Die meisten der oben genannten Tricks funktionieren gut in seinem Code: <br><br><pre> <code class="plaintext hljs">ov = $22 ; == $40, initial value for the overflow counter ct = $D5 ; == $27 / 39, number of passes. Decrementing, finished at -1 lp = $D1 ; == $07C0, pointer to bottom line. Set by the kernal scroller ; Overwrite the return address of the kernal loader on the stack ; with a pointer to our own code * = $01F8 .word scroll - 1 scroll: jsr $E8EA ; Kernal scroll up, also sets lp pointer to $07C0 loop: ldy ct ; Load the decrementing counter into Y (39 &gt; -1) lda #$A0 ; Load the PETSCII block / black col / ov step value sta $D020, y ; On the last two passes, sets the background black p1: sta $07C0 ; Draw first block (left &gt; right line) sta (lp), y ; Draw second block (right &gt; left line) inc p1 + 1 ; Increment pointer for the left &gt; right line adc ov ; Add step value $A0 to ov sta ov dec ct ; Decrement the Y counter bmi * ; If it goes negative, we're finished bcc loop ; Repeat. If ov didn't overflow, don't scroll bcs scroll ; Repeat. If ov overflowed, scroll</code> </pre> <br><h3>  Aber warum bei 34 Bytes verweilen? </h3><br>  Sobald der Wettbewerb beendet war, teilten alle ihren Code und ihre Notizen mit - und es fanden eine Reihe lebhafter Diskussionen darüber statt, wie man ihn weiter verbessern kann.  Nach Ablauf der Frist wurden mehrere weitere Optionen vorgestellt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Philip - 33 Bytes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Philip - 32 Bytes</a> <br></li><li>  <a href="">Petri - 31 Bytes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Philip - 29 Bytes</a> </li></ul><br>  Achten Sie darauf - es gibt mehrere echte Perlen. <br><br><hr><br>  Danke fürs Lesen.  Ein besonderer Dank geht an Matlev, Phil, Geir, Petri, Jamie, Ian und David für die Teilnahme (ich hoffe, ich habe niemanden vermisst - es war wirklich schwierig, alle Erwähnungen auf Twitter zu verfolgen!) <br><br>  PS Petri nannte meinen Wettbewerb "jährlich", also bis zum nächsten Jahr. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464377/">https://habr.com/ru/post/de464377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464367/index.html">Und ein weiterer Steam Windows Client Local Privilege Escalation 0day</a></li>
<li><a href="../de464369/index.html">Welchen Blocker benutzt du? Ergebnisse</a></li>
<li><a href="../de464371/index.html">/etc/resolv.conf für Kubernetes-Pods, Option ndots: 5, da dies die Anwendungsleistung beeinträchtigen kann</a></li>
<li><a href="../de464373/index.html">Edge-to-Edge unter Android: Richtig machen</a></li>
<li><a href="../de464375/index.html">Wie Suchmaschinen funktionieren</a></li>
<li><a href="../de464381/index.html">Reise nach Alaska oder KDD'19 mit den Augen eines Augenzeugen</a></li>
<li><a href="../de464383/index.html">Wie ich die Dinge in einem Projekt in Ordnung bringe, in dem es einen Wald direkter Hände gibt (tslint, hübscher usw. Einstellungen)</a></li>
<li><a href="../de464385/index.html">Python als ultimativer Fall von C ++. Teil 1/2</a></li>
<li><a href="../de464387/index.html">Russischer Fußabdruck in der skandinavischen Saga der Videospiele, Ende</a></li>
<li><a href="../de464391/index.html">10 interessante Berichte von Hacker-Konferenzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>