<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µ üöú üõ≥Ô∏è Schmutzige Assembler-Hacks 6502 üë©üèΩ‚Äçüîß ü§úüèΩ üôéüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel listet einige der Tricks auf, die Teilnehmer meines kleinen Commodore 64-Programmierwettbewerbs verwendet haben. Die Regeln des Wettbew...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schmutzige Assembler-Hacks 6502</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464377/">  Dieser Artikel listet einige der Tricks auf, die Teilnehmer meines kleinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commodore 64-Programmierwettbewerbs</a> verwendet haben.  Die Regeln des Wettbewerbs waren einfach: Erstellen Sie eine ausf√ºhrbare C64-Datei (PRG), die zwei Linien zeichnet, um das folgende Bild zu erstellen.  Derjenige, dessen Datei kleiner ist, hat gewonnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/5d1/afc/3f45d1afc9817c6530b6b34c44dd0497.png"></div><br>  Wettbewerbsbeitr√§ge wurden in offenen Tweets und in privaten Nachrichten ver√∂ffentlicht, die nur Bytes der PRG-Datei und einen MD5-Hash enthielten. <br><a name="habracut"></a><br>  Teilnehmerliste mit Links zum Quellcode: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Philip Heron</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 34 Bytes, Gewinner) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geir Straume</a> ( <a href="">Code</a> - 34 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Petri Hakkinen</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 37 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matlev Raksenblatts</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 38 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jan Ahrenius</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 48 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jamie Fuller</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 50 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">David A. Gershman</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 53 Bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Janne Hellsten</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> - 56 Bytes) </li></ul><br>  (Wenn ich jemanden vermisst habe, lass es mich wissen, ich werde die Liste aktualisieren). <br><br>  Der Rest des Artikels ist einigen Assembler-Tricks gewidmet, die im Wettbewerb verwendet wurden. <br><br><h1>  Die Grundlagen </h1><br>  Grafik C64 funktioniert standardm√§√üig im 40x25-Zeichencodierungsmodus.  Der Framebuffer im RAM ist in zwei Arrays unterteilt: <br><br><ul><li> <code>$0400</code> (Bildschirm-RAM, 40 x 25 Byte) <br></li><li>  <code>$d800</code> (Farb-RAM, 40 x 25 Byte) </li></ul><br>  Um ein Zeichen festzulegen, speichern Sie das Byte im Bildschirm-RAM bei <code>$0400</code> (z. B. <code>$0400+y*40+x</code> ).  Der Farb-RAM wird standardm√§√üig hellblau initialisiert (Farbe 14): Dies ist die Farbe, die wir f√ºr die Linien verwenden, dh der Farb-RAM kann ohne Ber√ºhrung belassen werden. <br><br>  Sie steuern die Farben des <code>$d020</code> und des Hintergrunds mithilfe der Speicher-E / A-Register in <code>$d020</code> (Rand) und <code>$d021</code> (Hintergrund). <br><br>  Das Zeichnen von zwei Linien ist ziemlich einfach, wenn Sie die Steigung einer festen Linie direkt programmieren.  Hier ist eine C-Implementierung, die Linien zeichnet und den Inhalt des Bildschirms auf stdout leert ( <code>malloc()</code> wird verwendet, damit der Code auf einem PC funktioniert): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void dump(const uint8_t* screen) { const uint8_t* s = screen; for (int y = 0; y &lt; 25; y++) { for (int x = 0; x &lt; 40; x++, s++) { printf("%c", *s == 0xa0 ? '#' : '.'); } printf("\n"); } } void setreg(uintptr_t dst, uint8_t v) { // *((uint8_t *)dst) = v; } int main() { // uint8_t* screenRAM = (uint_8*)0x0400; uint8_t* screenRAM = (uint8_t *)calloc(40*25, 0x20); setreg(0xd020, 0); // Set border color setreg(0xd021, 0); // Set background color int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; for (int x = 0; x &lt; 40; x++) { int yi = yf &gt;&gt; 8; // First line screenRAM[x + yi*40] = 0xa0; // Second line (X-mirrored) screenRAM[(39-x) + yi*40] = 0xa0; yf += yslope; } dump(screenRAM); }</span></span></span></span></code> </pre> <br>  Die obigen Bildschirmcodes sind <code>$20</code> (leer) und <code>$a0</code> (gef√ºllter 8 √ó 8-Block).  Wenn Sie ausf√ºhren, wird ein ASCII-Bild mit zwei Zeilen angezeigt: <br><br><pre>  ## .................................... ##
 .. # .................................. # ..
 ... ## .............................. ## ...
 ..... # ............................ # .....
 ...... ## ........................ ## ......
 ........ ## .................... ## ........
 .......... # .................. # ..........
 ........... ## .............. ## ...........
 ............. # ............ # .............
 .............. ## ........ ## ..............
 ................ ## .... ## ................
 .................. # .. # ..................
 ................... ## ...................
 .................. # .. # ..................
 ................ ## .... ## ................
 .............. ## ........ ## ..............
 ............. # ............ # .............
 ........... ## .............. ## ...........
 .......... # .................. # ..........
 ........ ## .................... ## ........
 ...... ## ........................ ## ......
 ..... # ............................ # .....
 ... ## .............................. ## ...
 .. # .................................. # ..
 ## .................................... ## </pre><br>  Dasselbe ist in Assembler trivial implementiert: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) entry: { lda #0 ; black color sta $d020 ; set border to 0 sta $d021 ; set background to 0 ; clear the screen ldx #0 lda #$20 clrscr: !for i in [0, $100, $200, $300] { sta $0400 + i, x } inx bne clrscr ; line drawing, completely unrolled ; with assembly pseudos lda #$a0 !for i in range(40) { !let y0 = Math.floor(25/40*(i+0.5)) sta $0400 + y0*40 + i sta $0400 + (24-y0)*40 + i } inf: jmp inf ; halt }</code> </pre> <br>  Es stellt sich heraus, dass PRG eine ziemlich gro√üe Gr√∂√üe von 286 Bytes hat. <br><br>  Bevor wir uns mit der Optimierung befassen, machen wir einige Beobachtungen. <br><br>  Zun√§chst arbeiten wir an C64 mit den vorhandenen ROM-Routinen.  Es gibt Unmengen von Routinen, die n√ºtzlich sein k√∂nnen.  Zum Beispiel das L√∂schen des Bildschirms mit <code>JSR $E544</code> . <br><br>  Zweitens k√∂nnen Adressberechnungen auf einem 8-Bit-Prozessor wie 6502 umst√§ndlich sein und viele Bytes verbrauchen.  Dieser Prozessor hat auch keinen Multiplikator, daher enth√§lt eine Berechnung wie <code>y*40+i</code> normalerweise entweder eine Reihe logischer Verschiebungen oder eine Nachschlagetabelle, die auch Bytes frisst.  Um ein Multiplizieren mit 40 zu vermeiden, bewegen Sie den Bildschirmcursor am besten schrittweise vorw√§rts: <br><br><pre> <code class="plaintext hljs"> int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xa0; dst[(39-x)] = 0xa0; yf += yslope; if (yf &amp; 256) { // Carry set? dst += 40; yf &amp;= 255; } }</code> </pre> <br>  Wir addieren weiterhin die Steigung der Linie zum festen Z√§hler <code>yf</code> , und wenn die 8-Bit-Addition das √úbertragsflag setzt, addieren wir 40. <br><br>  Hier ist ein inkrementeller Assembler-Ansatz: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) !let screenptr = $20 !let x0 = $40 !let x1 = $41 !let yf = $60 entry: { lda #0 sta x0 sta $d020 sta $d021 ; kernal clear screen jsr $e544 ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1 lda #80 sta yf lda #39 sta x1 xloop: lda #$a0 ldy x0 ; screenRAM[x] = 0xA0 sta (screenptr), y ldy x1 ; screenRAM[39-x] = 0xA0 sta (screenptr), y clc lda #160 ; line slope adc yf sta yf bcc no_add ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1 no_add: inc x0 dec x1 bpl xloop inf: jmp inf }</code> </pre> <br>  Mit 82 Bytes ist es immer noch ziemlich heftig.  Ein offensichtliches Problem sind 16-Bit-Adressberechnungen.  <code>screenptr</code> Sie den <code>screenptr</code> Wert f√ºr die indirekte <code>screenptr</code> : <br><br><pre> <code class="plaintext hljs"> ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1</code> </pre> <br>  Wir √ºbersetzen <code>screenptr</code> in die n√§chste Zeile, indem wir 40 hinzuf√ºgen: <br><br><pre> <code class="plaintext hljs"> ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1</code> </pre> <br>  Nat√ºrlich kann dieser Code optimiert werden, aber was ist, wenn Sie 16-Bit-Adressen √ºberhaupt entfernen?  Mal sehen, wie es geht. <br><br><h1>  Trick 1. Scrollen! </h1><br>  Anstatt eine Linie im Bildschirm-RAM zu erstellen, zeichnen wir nur in der letzten Bildschirmzeile Y = 24 und scrollen den gesamten Bildschirm nach oben, wobei wir die ROM-Scroll-Funktion mit <code>JSR $E8EA</code> ! <br><br>  So wird xloop optimiert: <br><br><pre> <code class="plaintext hljs"> lda #0 sta x0 lda #39 sta x1 xloop: lda #$a0 ldx x0 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: inc x0 dec x1 bpl xloop</code> </pre> <br>  So sieht das Rendering aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/081/6a6/63f0816a6728ec839de0197b6e0a3179.gif"></div><br><br>  Dies ist einer meiner Lieblingstricks in diesem Programm.  Fast alle Teilnehmer fanden es alleine. <br><br><h1>  Trick 2. Selbstmodifizierender Code </h1><br>  Der Code zum Speichern von Pixelwerten endet wie folgt: <br><br><pre> <code class="plaintext hljs"> ldx x1 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x0 sta $0400 + 24*40, x inc x0 dec x1</code> </pre> <br>  Dies wird in der folgenden Folge von 14 Bytes codiert: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: A6 20 LDX $20 080A: 9D C0 07 STA $07C0,X 080D: E6 22 INC $22 080F: C6 20 DEC $20</code> </pre> <br>  Mit selbstmodifizierendem Code (SMC) k√∂nnen Sie dies kompakter schreiben: <br><br><pre> <code class="plaintext hljs"> ldx x1 sta $0400 + 24*40, x addr0: sta $0400 + 24*40 ; advance the second x-coord with SMC inc addr0+1 dec x1</code> </pre> <br>  ... die mit 13 Bytes codiert ist: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: 8D C0 07 STA $07C0 080B: EE 09 08 INC $0809 080E: C6 22 DEC $22</code> </pre> <br><h1>  Trick 3. Betriebszustand 'Einschalten' </h1><br>  Es wurde im Wettbewerb als normal angesehen, wilde Annahmen √ºber das Arbeitsumfeld zu treffen.  Zum Beispiel, dass die Strichzeichnung das erste ist, was nach dem Einschalten des C64 beginnt, und es keine Anforderungen f√ºr eine saubere Ausgabe zur√ºck in die BASIC-Befehlszeile gibt.  Daher kann und sollte alles, was Sie in der Ausgangsumgebung beim Betreten der PRG finden, zu Ihrem Vorteil genutzt werden: <br><br><ul><li>  Die Register A, X, Y werden als Nullen genommen <br></li><li>  Alle CPU-Flags gel√∂scht <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeropage-</a> Inhalt (Adressen <code>$00</code> - <code>$ff</code> ) </li></ul><br>  Auf die gleiche Weise k√∂nnen Sie beim Aufrufen einiger KERNAL ROM-Prozeduren alle Nebenwirkungen voll ausnutzen: zur√ºckgegebene CPU-Flags, tempor√§re Nullseitenwerte usw. <br><br>  Suchen wir nach den ersten Optimierungen nach etwas Interessantem im Maschinenspeicher: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/43f/93c/0df43f93c58a142911607d3ba5ba44dd.png"></div><br><br>  Zeropage enth√§lt einige n√ºtzliche Werte f√ºr unsere Zwecke: <br><br><ul><li>  <code>$d5</code> : 39 / $ 27 == Zeilenl√§nge - 1 <br></li><li>  <code>$22</code> : 64 / $ 40 == Anfangswert f√ºr den Liniensteigungsz√§hler </li></ul><br>  Dadurch werden w√§hrend der Initialisierung einige Bytes eingespart.  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">!let x0 = $20 lda #39 ; 0801: A9 27 LDA #$27 sta x0 ; 0803: 85 20 STA $20 xloop: dec x0 ; 0805: C6 20 DEC $20 bpl xloop ; 0807: 10 FC BPL $0805</code> </pre> <br>  Da <code>$d5</code> den Wert 39 enth√§lt, k√∂nnen Sie ihn dem Z√§hler <code>x0</code> und das LDA / STA-Paar <code>x0</code> : <br><br><pre> <code class="plaintext hljs">!let x0 = $d5 ; nothing here! xloop: dec x0 ; 0801: C6 D5 DEC $D5 bpl xloop ; 0803: 10 FC BPL $0801</code> </pre> <br>  Philip, der Gewinner des Wettbewerbs, bringt dies auf das √Ñu√üerste.  <code>$07C0</code> Sie die Adresse des letzten Zeichens der Zeichenfolge <code>$07C0</code> (== <code>$0400+24*40</code> ) auf.  Dieser Wert ist w√§hrend der Initialisierung nicht in Nullseiten vorhanden.  Als Nebeneffekt der Verwendung tempor√§rer Nullseitenwerte durch die Bildlaufroutine aus dem ROM enthalten die Adressen <code>$D1-$D2</code> am Ausgang der Funktion den Wert <code>$07C0</code> .  Daher k√∂nnen Sie zum Speichern eines Pixels anstelle von <code>STA $07C0,x</code> die k√ºrzere indirekte <code>STA $07C0,x</code> <code>STA ($D1),y</code> f√ºr ein Byte verwenden. <br><br><h1>  Trick 4. Download-Optimierung </h1><br>  Eine typische C64 PRG-Bin√§rdatei enth√§lt Folgendes: <br><br><ul><li>  Erste 2 Bytes: Download-Adresse (normalerweise <code>$0801</code> ) <br></li><li>  12 Bytes der BASIC-Startsequenz </li></ul><br>  Die Hauptstartsequenz sieht folgenderma√üen aus (Adressen <code>$801-$80C</code> ): <br><br><pre> <code class="plaintext hljs">0801: 0B 08 0A 00 9E 32 30 36 31 00 00 00 080D: 8D 20 D0 STA $D020</code> </pre> <br>  Ohne auf Details des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BASIC-Token-Speicherlayouts einzugehen</a> , entspricht diese Sequenz mehr oder weniger '10 SYS 2061 '.  In der Adresse <code>2061</code> ( <code>$080D</code> ) wird unser eigentliches Maschinencode-Programm ausgef√ºhrt, wenn der BASIC-Interpreter den SYS-Befehl ausf√ºhrt. <br><br>  Es scheint nur, dass 14 Bytes zu viel sind.  Philip, Matlev und Geir verwendeten mehrere knifflige Tricks, um die Hauptsequenz vollst√§ndig loszuwerden.  Dies erfordert das Laden des PRG mit <code>LOAD"*",8,1</code> , da <code>LOAD"*",8</code> die PRG-Ladeadresse (die ersten zwei Bytes) ignoriert und immer bei <code>$0801</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/911/d07/fdb/911d07fdb2c0e2e13b07e360bb16d03c.png"></div><br><br>  Hier wurden zwei Methoden angewendet: <br><br><ul><li>  Stapeltrick <br></li><li>  BASIC Warm Reset Trick </li></ul><br><h3>  Stapeltrick </h3><br>  Der Trick besteht darin, mit <code>$01F8</code> Wert in den Prozessorstapel <code>$01F8</code> , der unseren gew√ºnschten Einstiegspunkt angibt.  Dazu erstellen Sie eine PRG, die mit einem 16-Bit-Zeiger auf unseren Code beginnt, und laden die PRG bei <code>$01F8</code> : <br><br><pre> <code class="plaintext hljs"> * = $01F8 !word scroll - 1 ; overwrite stack scroll: jsr $E8EA</code> </pre> <br>  Sobald der BASIC-Loader (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code nach der Demontage</a> ) vollst√§ndig geladen ist und mit <code>RTS</code> zum Anrufer zur√ºckkehren m√∂chte, kehrt er direkt zu unserem PRG zur√ºck. <br><br><h3>  BASIC Warm Reset Trick </h3><br>  Dies ist etwas einfacher zu erkl√§ren, indem Sie sich nach dem Zerlegen die PRG ansehen. <br><br><pre> <code class="plaintext hljs">02E6: 20 EA E8 JSR $E8EA 02E9: A4 D5 LDY $D5 02EB: A9 A0 LDA #$A0 02ED: 99 20 D0 STA $D020,Y 02F0: 91 D1 STA ($D1),Y 02F2: 9D B5 07 STA $07B5,X 02F5: E6 D6 INC $D6 02F7: 65 90 ADC $90 02F9: 85 90 STA $90 02FB: C6 D5 DEC $D5 02FD: 30 FE BMI $02FD 02FF: 90 E7 BCC $02E8 0301: 4C E6 02 JMP $02E6</code> </pre> <br>  <code>JMP $02E6</code> auf die letzte Zeile ( <code>JMP $02E6</code> ).  Der JMP-Befehl beginnt bei <code>$0301</code> mit einer Sprungadresse von <code>$0302-$0303</code> . <br><br>  Wenn dieser Code ab der Adresse <code>$02E6</code> in den Speicher <code>$02E6</code> , wird der Wert <code>$02E6</code> die Adressen <code>$0302-$0303</code> .  Nun, dieser Ort hat eine besondere Bedeutung: Er enth√§lt einen Zeiger auf den ‚ÄûBASIC-Wartezyklus‚Äú (weitere Informationen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C64-Speicherkarte</a> ).  Das Herunterladen von PRG √ºberschreibt es mit <code>$02E6</code> . Wenn der BASIC-Interpreter nach einem Warm-Reset versucht, in die Warteschleife zu wechseln, tritt er nie in diese Schleife ein, sondern gelangt in das Rendering-Programm! <br><br><h3>  Weitere Tricks mit dem Start von BASIC </h3><br>  Petri hat <a href="">einen weiteren BASIC-Starttrick entdeckt</a> , mit dem Sie Ihre eigenen Konstanten in Nullseiten eingeben k√∂nnen.  Bei dieser Methode erstellen Sie manuell Ihre eigene tokenisierte BASIC-Startsequenz und codieren die Konstanten in die Zeilennummern des BASIC-Programms.  Bei der Eingabe werden die BASIC-Zeilennummern, ahem, dh Ihre Konstanten, in den Adressen <code>$39-$3A</code> gespeichert.  Sehr schlau! <br><br><h1>  Trick 5. Benutzerdefinierter Kontrollfluss </h1><br>  Hier ist eine leicht vereinfachte Version von x-loop, die nur eine Zeile druckt und dann die Ausf√ºhrung stoppt: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: dec x1 bpl xloop ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  Aber es gibt einen Fehler.  Wenn wir das letzte Pixel gezeichnet haben, k√∂nnen wir den Bildschirm nicht mehr scrollen.  Daher sind zus√§tzliche Verzweigungen erforderlich, um das Scrollen nach dem Aufzeichnen des letzten Pixels zu beenden: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x dec x1 ; skip scrolling if last pixel bmi done adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: jmp xloop done: ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  Der Kontrollfluss ist dem sehr √§hnlich, was der C-Compiler aus einem strukturierten Programm erzeugt.  Der Code zum √úberspringen des letzten Bildlaufs f√ºhrt einen neuen <code>JMP abs</code> Befehl ein, der 3 Bytes ben√∂tigt.  Bedingte Spr√ºnge sind nur zwei Bytes lang, da sie Sprungadressen unter Verwendung eines relativen 8-Bit-Operanden mit direkter Adressierung codieren. <br><br>  JMP zum ‚Äû√úberspringen des letzten Bildlaufs‚Äú kann vermieden werden, indem der Bildlaufaufruf an den oberen Rand der Schleife verschoben und die Kontrollflussstruktur geringf√ºgig ge√§ndert wird.  So hat Philip es implementiert: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 scroll: jsr $e8ea xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf dec x1 ; doesn't set carry! inf: bmi inf ; hang here if last pixel! bcc xloop ; next pixel if no scroll bcs scroll ; scroll up and continue</code> </pre> <br>  Dadurch wird ein Drei-Byte-JMP vollst√§ndig eliminiert und der andere JMP in einen bedingten Zwei-Byte-Zweig konvertiert, wodurch insgesamt 4 Byte eingespart werden. <br><br><h1>  Trick 6. Linien mit Bitkomprimierung </h1><br>  Einige Elemente verwenden nicht den Zeilenneigungsz√§hler, sondern komprimieren die Bits in eine 8-Bit-Konstante.  Eine solche Verpackung basiert auf der Tatsache, dass die Position des Pixels entlang der Linie einem sich wiederholenden 8-Pixel-Muster entspricht: <br><br><pre> <code class="plaintext hljs">int mask = 0xB6; // 10110110 uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xA0; if (mask &amp; (1 &lt;&lt; (x&amp;7))) { dst += 40; // go down a row } }</code> </pre> <br>  Dies f√ºhrt zu einem ziemlich kompakten Assembler.  Die Optionen f√ºr den Neigungsz√§hler sind jedoch normalerweise noch kleiner. <br><br><h3>  Gewinner </h3><br>  Hier <a href="">ist das 34-Byte-Wettbewerbsprogramm</a> von Philip.  Die meisten der oben genannten Tricks funktionieren gut in seinem Code: <br><br><pre> <code class="plaintext hljs">ov = $22 ; == $40, initial value for the overflow counter ct = $D5 ; == $27 / 39, number of passes. Decrementing, finished at -1 lp = $D1 ; == $07C0, pointer to bottom line. Set by the kernal scroller ; Overwrite the return address of the kernal loader on the stack ; with a pointer to our own code * = $01F8 .word scroll - 1 scroll: jsr $E8EA ; Kernal scroll up, also sets lp pointer to $07C0 loop: ldy ct ; Load the decrementing counter into Y (39 &gt; -1) lda #$A0 ; Load the PETSCII block / black col / ov step value sta $D020, y ; On the last two passes, sets the background black p1: sta $07C0 ; Draw first block (left &gt; right line) sta (lp), y ; Draw second block (right &gt; left line) inc p1 + 1 ; Increment pointer for the left &gt; right line adc ov ; Add step value $A0 to ov sta ov dec ct ; Decrement the Y counter bmi * ; If it goes negative, we're finished bcc loop ; Repeat. If ov didn't overflow, don't scroll bcs scroll ; Repeat. If ov overflowed, scroll</code> </pre> <br><h3>  Aber warum bei 34 Bytes verweilen? </h3><br>  Sobald der Wettbewerb beendet war, teilten alle ihren Code und ihre Notizen mit - und es fanden eine Reihe lebhafter Diskussionen dar√ºber statt, wie man ihn weiter verbessern kann.  Nach Ablauf der Frist wurden mehrere weitere Optionen vorgestellt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Philip - 33 Bytes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Philip - 32 Bytes</a> <br></li><li>  <a href="">Petri - 31 Bytes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Philip - 29 Bytes</a> </li></ul><br>  Achten Sie darauf - es gibt mehrere echte Perlen. <br><br><hr><br>  Danke f√ºrs Lesen.  Ein besonderer Dank geht an Matlev, Phil, Geir, Petri, Jamie, Ian und David f√ºr die Teilnahme (ich hoffe, ich habe niemanden vermisst - es war wirklich schwierig, alle Erw√§hnungen auf Twitter zu verfolgen!) <br><br>  PS Petri nannte meinen Wettbewerb "j√§hrlich", also bis zum n√§chsten Jahr. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464377/">https://habr.com/ru/post/de464377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464367/index.html">Und ein weiterer Steam Windows Client Local Privilege Escalation 0day</a></li>
<li><a href="../de464369/index.html">Welchen Blocker benutzt du? Ergebnisse</a></li>
<li><a href="../de464371/index.html">/etc/resolv.conf f√ºr Kubernetes-Pods, Option ndots: 5, da dies die Anwendungsleistung beeintr√§chtigen kann</a></li>
<li><a href="../de464373/index.html">Edge-to-Edge unter Android: Richtig machen</a></li>
<li><a href="../de464375/index.html">Wie Suchmaschinen funktionieren</a></li>
<li><a href="../de464381/index.html">Reise nach Alaska oder KDD'19 mit den Augen eines Augenzeugen</a></li>
<li><a href="../de464383/index.html">Wie ich die Dinge in einem Projekt in Ordnung bringe, in dem es einen Wald direkter H√§nde gibt (tslint, h√ºbscher usw. Einstellungen)</a></li>
<li><a href="../de464385/index.html">Python als ultimativer Fall von C ++. Teil 1/2</a></li>
<li><a href="../de464387/index.html">Russischer Fu√üabdruck in der skandinavischen Saga der Videospiele, Ende</a></li>
<li><a href="../de464391/index.html">10 interessante Berichte von Hacker-Konferenzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>