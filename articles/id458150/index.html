<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◀️ 👏 🥪 Peoptimasi mikro optimasi dalam kompiler C ++ dan C # 😿 🚲 🤾🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di sekolah, ketika kami memecahkan persamaan atau rumus yang dianggap, kami mencoba menguranginya beberapa kali, misalnya, Z = X - (Y + X) dikurangi m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Peoptimasi mikro optimasi dalam kompiler C ++ dan C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458150/"><p> Di sekolah, ketika kami memecahkan persamaan atau rumus yang dianggap, kami mencoba menguranginya beberapa kali, misalnya, <code>Z = X - (Y + X)</code> dikurangi menjadi <code>Z = -Y</code> .  Dalam kompiler modern, ini adalah subset dari apa yang disebut optimisasi lubang, di mana, secara kasar, seperangkat pola yang kita kurangi ekspresi, ganti instruksi dengan yang lebih cepat untuk prosesor tertentu, dll.  Dalam artikel ini, saya telah mengumpulkan kumpulan optimisasi yang ditemukan di sumber LLVM, GCC, dan .NET Core (CoreCLR). </p><br><p>  Mari kita mulai dengan contoh sederhana: </p><br><pre> <code class="cpp hljs"> X * <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X -X * -Y =&gt; X * Y -(X - Y) =&gt; Y - XX * Z - Y * Z =&gt; Z * (X - Y)</code> </pre> <br><p>  periksa contoh terakhir di C ++ dan di C #: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * z - y * z; <span class="hljs-comment"><span class="hljs-comment">// =&gt; z * (x - y) }</span></span></code> </pre> <br><p>  dan lihat assembler dari Dentang (LLVM), GCC, MSVC, dan .NET Core: <br><img src="https://habrastorage.org/webt/up/xl/zo/upxlzopwz17gkq290kycswi4_qq.png"></p><a name="habracut"></a><br><p>  Ketiga kompiler C ++ (GCC, Dentang dan MSVC) mengurangi satu multiplikasi (kita hanya melihat satu instruksi <code>imul</code> ).  C # tidak melakukan ini dengan RyuJIT, tetapi jangan buru-buru memarahinya karena itu, hanya saja kelas optimisasi ini tersedia dalam komposisi terbatas di sana.  Untuk membuat Anda mengerti, implementasi seluruh transformasi InstCombine di LLVM membutuhkan lebih dari 30k baris kode (+ 20k baris pada DAGCombiner.cpp), terlebih lagi, transformasi ini sering menyebabkan kompilasi yang panjang.  <a href="">Omong-omong, situs yang</a> bertanggung jawab untuk optimasi ini ada di sana.  GCC memiliki DSL khusus yang menjelaskan lubang optimasi, di <a href="">sini adalah cuplikan</a> ). </p><br><p>  Saya memutuskan, demi artikel ini, untuk mencoba mengimplementasikan pengoptimalan ini di C # JIT (tahan bir saya): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/692/14c/c65/69214cc65fd41d79f8d53caf4021c9af.png" alt="gambar"></p><br><p>  Komit penuh dapat dilihat di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EgorBo / coreclr</a> .  Mari kita periksa peningkatan saya sekarang (di Visual Studio 2019 + Disasmo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/e77/de9/e53e77de91d647f78f021d10fb57a8c9.png" alt="gambar"></p><br><p>  Itu berhasil!  <code>lea</code> + <code>imul</code> bukannya <code>imul</code> , <code>imul</code> dan <code>add</code> . </p><br><p>  Mari kita kembali ke C ++ dan melacak pengoptimalan ini di Dentang.  Untuk melakukan ini, mintalah dentang untuk memberikan kami LLVM IR awal melalui <code>-emit-llvm -g0</code> , dan kemudian berikan kepada LLVM ke pengoptimal, menggunakan parameter <code>-O2 -print-before-all -print-after-all</code> untuk menangkap momen transformasi yang tepat menghapus perkalian dari set <code>-O2</code> (semua ini dapat dilihat pada sumber daya yang luar biasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">godbolt.org</a> ): </p><br><pre> <code class="plaintext hljs">; *** IR Dump Before Combine redundant instructions *** define dso_local i32 @_Z5Case1iii(i32, i32, i32) { %4 = mul nsw i32 %0, %2 %5 = mul nsw i32 %1, %2 %6 = sub nsw i32 %4, %5 ret i32 %6 } ; *** IR Dump After Combine redundant instructions *** define dso_local i32 @_Z5Case1iii(i32, i32, i32) { %4 = sub i32 %0, %1 %5 = mul i32 %4, %2 ret i32 %5 }</code> </pre> <br><p>  Anda juga dapat bersenang-senang di godbolt dengan alat LLVM - opt (pengoptimal) dan llc (untuk mengkompilasi LLVM IR ke asm): </p><br><p><img src="https://habrastorage.org/webt/yr/x-/dw/yrx-dw9mx9tqbrp97ts3smndy0i.png"></p><br><p>  Kembali ke contoh.  Saya menemukan contoh yang sangat bagus di GCC. </p><br><pre> <code class="cpp hljs">X == C - X =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> C is odd</code> </pre> <br><p>  Dan memang benar: jika <code></code> (konstan, literal) itupun, misalnya, Anda dapat menulis <code>4 == 8 - 4</code> .  Tetapi jika alih-alih 8 Anda menulis yang aneh, maka Anda tidak dapat menemukan <code>X</code> sedemikian rupa sehingga kesetaraan terpenuhi: </p><br><p><img src="https://habrastorage.org/webt/lt/qn/pq/ltqnpqgmnbcyszoj0dv7nawouk8.png"></p><br><h3 id="ieee754-nanosit-otvetnyy-udar">  IEEE754 Menyerang Kembali </h3><br><p>  Banyak optimasi bekerja untuk tipe data yang berbeda, misalnya, <code>byte</code> , <code>int</code> , <code>unsigned</code> , <code>float</code> , <code>double</code> .  Dengan yang terakhir, semuanya tidak begitu sederhana dan optimisasi ditangani oleh spesifikasi IEEE754, yang akan menjadi gila jika Anda mengurangi <code>A - B - A</code> ke <code>-B</code> atau <code>(A * B) * C</code> mengatur ulang ke <code>A * (B * C)</code> t. untuk.  operasi tidak asosiatif.  Tetapi ada mode khusus dalam kompiler modern yang memungkinkan Anda untuk mengabaikan nilai spec dan batas (NaN, + -Inf, + -0.0) dalam kasus seperti itu dan melakukan optimasi dengan aman - ini adalah Matematika Cepat (permintaan PR saya untuk menambahkan mode seperti itu ke C # dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> ) </p><br><p>  Seperti yang Anda lihat di <code>-ffast-math</code> tidak ada lagi dua <code>vsubss</code> : <br><img src="https://habrastorage.org/webt/s3/et/-9/s3et-9dc6vml6f-ous27z-1xlhm.png"></p><br><p>  Selain ekspresi, pengoptimal juga memperhitungkan juggling dengan fungsi matematika dari <code>math.h</code> , misalnya, produk moduli angka X sama dengan produk angka X: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(X) =&gt; X * X</code> </pre> <br><p>  Akar kuadrat selalu positif: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &lt; Y =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Y is negative. <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  Mengapa menghitung root, jika mungkin pada tahap kompilasi untuk menghitung kuadrat konstanta di sebelah kanan?: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &gt; C =&gt; X &gt; C * C</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/988/d7e/cbd/988d7ecbd50be253a6b3314760ed3348.png" alt="gambar"></p><br><p>  Lebih banyak operasi root: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) == <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(Y) =&gt; X == Y <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) =&gt; X <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(Y) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X * Y) logN(<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X)) =&gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>*logN(X)</code> </pre> <br><p>  Beberapa matematika sekolah lagi: </p><br><pre> <code class="cpp hljs">expN(X) * expN(Y) -&gt; expN(X + Y)</code> </pre> <br><p>  Dan pengoptimalan favorit saya: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(X) / <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(X) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(X)</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/93a/875/4dd/93a8754dd42b07497f6a164bb60172af.png" alt="gambar"></p><br><p>  Banyak operasi bit dan boolean yang membosankan: </p><br><pre> <code class="cpp hljs">((a ^ b) | a) -&gt; (a | b) (a &amp; ~b) | (a ^ b) --&gt; a ^ b ((a ^ b) | a) -&gt; (a | b) (X &amp; ~Y) |^+ (~X &amp; Y) -&gt; X ^ Y A - (A &amp; B) into ~B &amp; A X &lt;= Y - <span class="hljs-number"><span class="hljs-number">1</span></span> equals to X &lt; Y A &lt; B || A &gt;= B -&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> ...   !</code> </pre> <br><h3 id="nizkourovnevye-optimizacii">  Optimalisasi tingkat rendah </h3><br><p>  Ada serangkaian optimisasi yang pada pandangan pertama tidak masuk akal  matematikawan, tetapi lebih ramah terhadap besi. </p><br><pre> <code class="cpp hljs">X / <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; X * <span class="hljs-number"><span class="hljs-number">0.5</span></span></code> </pre> <br><p>  ganti pembagian dengan perkalian: </p><br><p><img src="https://habrastorage.org/webt/1n/nz/d2/1nnzd2msn5lxzxlx5t3-hr680cc.png"></p><br><p>  Pengoperasian multiplikasi armada biasanya memiliki karakteristik latensi / throughput yang lebih baik daripada divisi.  Misalnya, berikut adalah opsi untuk Intel Haswell: <br><img src="https://habrastorage.org/webt/i1/ej/l_/i1ejl__p9hfkduty-cn4vq0vzvu.png"></p><br><p>  Dalam mode non-cepat-matematika, itu hanya dapat digunakan jika konstanta adalah kekuatan dua. <br>  Ngomong-ngomong, saya baru-baru ini mencoba menambahkan optimasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti itu</a> di C #.  Yaitu  jika, misalnya, Anda perlu membuka file dengan model 3D dan mengurangi semua koordinat sebanyak 10 kali, maka * 0,1 akan menangani ini 20-100% lebih cepat, yang bisa jadi signifikan. </p><br><p>  Alasan yang sama untuk: </p><br><pre> <code class="cpp hljs">X * <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; X + X</code> </pre> <br><p>  Membandingkan dengan nol ( <code>test</code> ) lebih baik daripada membandingkan dengan satuan ( <code>cmp</code> ) - PR saya untuk detailnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotnet / coreclr # 25458</a> : </p><br><pre> <code class="plaintext hljs">X &gt;= 1 =&gt; X &gt; 0 X &lt; 1 =&gt; X &lt;= 0 X &lt;= -1 =&gt; X &gt;= 0 X &gt; -1 =&gt; X &gt;= 0</code> </pre> <br><p>  Dan bagaimana Anda suka ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">0.5</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x) <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">0.25</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X)) <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; X * X ; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">mul </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>=&gt; X * X * X ; <span class="hljs-number"><span class="hljs-number">2</span></span> mul</code> </pre> <br><p><img src="https://habrastorage.org/webt/hd/ag/lm/hdaglmbx5f7zfibbpgzdre0swjo.png"></p><br><p>  Bagaimana menurut Anda, berapa banyak operasi multiplikasi yang Anda perlukan untuk menghitung <code>mod(X, 4)</code> atau <code>X * X * X * X</code> ? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f5d/118/3c0/f5d1183c005a7f72b6fbabdd18995d7e.png" alt="gambar"></p><br><p>  Dua!  Serta untuk menghitung derajat ke-3, dan dalam kasus 4 kita hanya menggunakan satu register <code>xmm0</code> . </p><br><p>  Banyak prosesor mendukung instruksi khusus (FMA), yang memungkinkan Anda untuk melakukan perkalian dan penambahan pada satu waktu, sambil menjaga akurasi selama perkalian: </p><br><pre> <code class="cpp hljs">X * Y + Z =&gt; fmadd(X, Y, Z)</code> </pre> <br><p><img src="https://habrastorage.org/webt/jf/z5/nh/jfz5nh9fl6-wkx8cfmubntv7o4g.png"></p><br><p>  Dua contoh favorit saya melipat beberapa algoritma menjadi satu instruksi (jika prosesor mendukungnya): <br><img src="https://habrastorage.org/webt/qj/pv/ya/qjpvya5-s-itzzxubosjpnwonkc.png"></p><br><h3 id="lovushki-dlya-optimizaciy">  Jebakan Optimasi </h3><br><p>  Saya pikir semua orang mengerti bahwa Anda tidak bisa terburu-buru dan mengurangi ekspresi karena tiga alasan: </p><br><ul><li>  Anda dapat memecahkan kode pada beberapa nilai batas, overflow, efek samping tersembunyi, dll ... Bugzilla LLVM berisi banyak bug InstCombine. </li><li>  Idealnya, optimasi harus bekerja bersama dalam urutan tertentu. </li><li>  Ekspresi atau bagiannya yang ingin Anda kurangi dapat digunakan di tempat lain dan pengurangannya akan menyebabkan penurunan kinerja. </li></ul><br><p>  Mari kita lihat contoh paragraf terakhir (lihat di artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Future Directions for Optimizing Compiler</a> ). </p><br><p>  Bayangkan kita memiliki kode ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> na = -a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nb = -b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> na + nb; }</code> </pre> <br><p>  kita perlu melakukan tiga operasi: <code>0 - a</code> , <code>0 - b</code> , dan <code>na + nb</code> .  Tetapi pengoptimal bagi kita mengurangi ini menjadi dua - <code>return -(a + b);</code>  : </p><br><pre> <code class="plaintext hljs">define dso_local i32 @_Z4Foo1ii(i32, i32) { %3 = add i32 %0, %1 ; a + b %4 = sub i32 0, %3 ; 0 - %3 ret i32 %4 }</code> </pre> <br><p>  Sekarang bayangkan bahwa kita perlu menulis nilai antara <code>na</code> dan <code>nb</code> ke variabel global: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> na = -a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nb = -b; x = na; y = nb; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> na + nb; }</code> </pre> <br><p>  Pengoptimal masih menemukan pola ini dan menghapus operasi <code>0 - a</code> dan <code>0 - b</code> tidak perlu (dari sudut pandangnya), tetapi ternyata itu diperlukan!  kami menulis hasil dari operasi "yang tidak perlu" ini ke dalam variabel global!  Ini mengarah ke kode ini: </p><br><pre> <code class="cpp hljs">define dso_local i32 @_Z4Foo2ii(i32, i32) { %<span class="hljs-number"><span class="hljs-number">3</span></span> = sub nsw i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - a %<span class="hljs-number"><span class="hljs-number">4</span></span> = sub nsw i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - b store i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, i32* @x, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> store i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>, i32* @y, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = add i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ; a + b %<span class="hljs-number"><span class="hljs-number">6</span></span> = sub i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">5</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - %<span class="hljs-number"><span class="hljs-number">5</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">6</span></span> }</code> </pre> <br><p>  Empat operasi matematika, bukan tiga!  Pengoptimal kami gagal dan tidak yakin bahwa ekspresi perantara yang ia optimalkan masih diperlukan oleh seseorang.  Sekarang mari kita lihat output C # RuyJIT, di mana tidak ada optimasi pintar seperti itu: </p><br><p><img src="https://habrastorage.org/webt/fs/ar/jf/fsarjfwtbnpmp5hzbidevgo3eui.png"></p><br><p>  Tiga operasi bukannya empat - C # ternyata lebih cepat daripada C ++ :-)! </p><br><h3 id="a-nuzhny-li-takie-optimizacii">  Apakah optimasi seperti itu diperlukan? </h3><br><p>  Anda tidak pernah tahu bagaimana kode akan terlihat setelah kompiler menyatukan semua yang dapat dan dilakukannya pelipatan konstan, penyalinan salinan, CSE, dll.  - gambar yang sama sekali berbeda akan terbuka untuknya.  LLVM IR dan .NET IL tidak terikat dengan bahasa pemrograman tertentu, dan Anda tidak dapat memastikan bahwa PL tertentu / baru dapat secara efektif menerjemahkan dirinya ke dalam IR.  Nah, mengapa membicarakannya jika Anda dapat menguji kinerja InstCombine hidup dan mati pada aplikasi tertentu ;-).  Tidak mungkin ini akan menjadi perbedaan yang mengesankan, tetapi siapa yang tahu. </p><br><h3 id="a-chto-na-schet-c">  Bagaimana dengan C #? </h3><br><p>  Seperti yang saya katakan, optimisasi ekspresi yang kami periksa kemungkinan besar tidak ada di C #.  Tetapi ketika saya mengatakan C # Maksud saya runtime paling populer adalah CoreCLR dan RyuJIT.  Tapi selain CoreCLR ada runtime lain, termasuk yang menggunakan LLVM sebagai backend: Mono (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tweet</a> saya), Unity Burst, IL2CPP (via dentang) dan LILLC - di sini Anda dapat dengan aman membandingkan hasil C ++ dengan dentang.  Orang-orang dari Unity bahkan menulis ulang kode C ++ internal di C # tanpa kehilangan kinerja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buktikan</a> ! </p><br><p>  Berikut adalah beberapa lubang optimasi yang dapat ditemukan di file <code>morph.cpp</code> dalam kode sumber <code>morph.cpp</code> dari komentar (jelas ada sedikit lebih banyak): </p><br><pre> <code class="cpp hljs">*(&amp;X) =&gt; X X % <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> X / <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X X % Y =&gt; X - (X / Y) * Y X ^ <span class="hljs-number"><span class="hljs-number">-1</span></span> =&gt; ~x X &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> X &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> X + <span class="hljs-number"><span class="hljs-number">1</span></span> == C2 =&gt; X == C2 - C1 ((X + C1) + C2) =&gt; (X + (C1 + C2)) ((X + C1) + (Y + C2)) =&gt; ((X + Y) + (C1 + C2))</code> </pre> <br><p>  Beberapa lagi dapat ditemukan di <code>lowering.cpp</code> (level rendah), tetapi secara umum RyuJIT jelas kehilangan di sini karena kompiler C ++.  RyuJIT memiliki prioritas yang sedikit berbeda - sebelum munculnya Tiering Compilation, ia perlu memberikan kecepatan kompilasi yang dapat diterima, yang ia lakukan dengan sangat baik tidak seperti kompiler C ++ (ingat tentang 30-baris InstCombine yang lulus dalam LLVM dan membaca posting yang menarik secara umum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">" Modern "C ++ Ratapan</a> ) dan itu jauh lebih berguna untuk mengembangkan optimasi di bidang devirtualisasi panggilan, penghapusan tinju dan alokasi (Alokasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Objek Tumpukan yang</a> sama) - semua ini, jelas, jauh lebih penting daripada meminimalkan pembagian sinus oleh cosinus menjadi tangen. </p><br><p>  Mungkin dengan munculnya Tiering Compilation, seiring waktu akan ada banyak optimasi baru yang tidak penting untuk waktu kompilasi untuk tier1 atau bahkan tier2.  Mungkin bahkan dengan Add-in API dan DSL Anda - Anda baru saja membaca artikel ini, di dalamnya Prathamesh Kulkarni menambahkan pengoptimalan ekspresi dalam GCC hanya dalam beberapa jalur DSL: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">simplify</span></span> (<span class="hljs-name"><span class="hljs-name">plus</span></span> (<span class="hljs-name"><span class="hljs-name">mult</span></span> (<span class="hljs-name"><span class="hljs-name">SIN</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">SIN</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">mult</span></span> (<span class="hljs-name"><span class="hljs-name">COS</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">COS</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag_unsafe_math_optimizations</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span>. { build_one_cst (<span class="hljs-name"><span class="hljs-name">TREE_TYPE</span></span> (@<span class="hljs-number"><span class="hljs-number">0</span></span>))<span class="hljs-comment"><span class="hljs-comment">; }))</span></span></code> </pre> <br><p>  untuk ungkapan ini dari buku teks matematika ;-): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span>(X) + <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span>(X) equals to <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h3 id="poleznye-ssylki">  Tautan yang bermanfaat </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Arah Masa Depan untuk Mengoptimalkan Kompiler"</a> , Nuno P. Lopes dan John Regehr </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Bagaimana LLVM Mengoptimalkan Fungsi"</a> , John Regehr </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Kecerdasan mengejutkan kompiler modern"</a> , Daniel Lemire </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Menambahkan optimalisasi lubang intip ke GCC"</a> , Prathamesh Kulkarni </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"1. C ++, C # dan Unity"</a> , Lucas Meijer </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Modern" C ++ Ratapan "</a> , Aras Pranckevičius </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Optimalisasi Optimal Lubang Pengamatan dengan Hidup"</a> , Nuno P. Lopes, David Menendez, Santosh Nagarakatte dan John Regehr </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458150/">https://habr.com/ru/post/id458150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458124/index.html">Jejak Rusia di Saga Skandinavia Game</a></li>
<li><a href="../id458130/index.html">“Kata Ajaib” untuk pengusaha - pengalaman IIBS NITU “MISiS”</a></li>
<li><a href="../id458134/index.html">Komputasi kuantum dapat mengubah segalanya, dan IBM bersaing dengan Microsoft, Intel, dan Google untuk mengendalikannya.</a></li>
<li><a href="../id458136/index.html">GitLab 12.0 baru dengan ulasan visual dan daftar dependensi</a></li>
<li><a href="../id458142/index.html">Mengembangkan Breakout on Svelte</a></li>
<li><a href="../id458154/index.html">Kisah luar biasa tentang asal port USB yang mengubah segalanya</a></li>
<li><a href="../id458156/index.html">Benchmarking PostgreSQL dengan FreeBSD, CentOS, Ubuntu Debian, dan openSUSE</a></li>
<li><a href="../id458158/index.html">Mencari asteroid - proyek Hubble Asteroid Hunter</a></li>
<li><a href="../id458160/index.html">Kunci Prioritas di .NET</a></li>
<li><a href="../id458168/index.html">Juni Machine Learning dan Intelijen Berita Buatan Intisari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>