<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕯️ ⚖️ 🏓 Wir brechen in Top10 aus. Telegrammbot 🤛🏾 😰 💅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir brechen in Top10 aus. Telegrammbot 
 Hintergrund 


 Alles begann damit, dass sie mir einen Link zu einem Bot in Telegram mit einem Angebot zum Sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir brechen in Top10 aus. Telegrammbot</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432278/"><h1 id="vyryvaemsya-v-top10-bot-dlya-igry-v-telegram">  Wir brechen in Top10 aus.  Telegrammbot </h1><br><h2 id="predystoriya">  Hintergrund </h2><br><p>  Alles begann damit, dass sie mir einen Link zu einem Bot in Telegram mit einem Angebot zum Spielen schickten. <br>  Es sieht ungefähr so ​​aus. </p><br><p><img src="https://habrastorage.org/webt/gr/3p/ye/gr3pye7auph3f3dheiace847jci.png"></p><br><p>  Nach meinem ersten Spiel habe ich 28 Punkte verdient, kein sehr beeindruckendes Ergebnis.  Sie brauchen also überhaupt nichts - ein Programm, das Wörter aus den Buchstaben des Originalworts findet, und eine Datenbank mit Substantiven russischer Wörter. </p><br><h2 id="poehali">  Lass uns gehen </h2><br><p>  Ich habe beschlossen, sqlite3 für die Datenbank zu verwenden, es ist mobil und für diese Aufgabe am meisten. </p><br><p>  Die Struktur der Basis sieht so aus. </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> words ( word <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">225</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> );</code> </pre> <br><ul><li>  Wort - Aus dem Namen geht hervor, dass dies die gespeicherte wörtliche Bedeutung des Wortes ist. </li><li>  Länge - Zeichenlänge. </li></ul><br><p>  Es gibt eine Struktur, um sie zu füllen, habe ich eine Liste von Substantiven <a href="">russischer Wörter verwendet</a> . </p><br><p>  Nachdem die Datenbank gefüllt und nach Wörtern gesucht wurde, wurde beschlossen, die Verarbeitung der Flags in einem Code zu implementieren. </p><br><p>  Die Erstellung der Basisdatei und die Erstellung der Tabelle sind ebenfalls in init () implementiert. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error connection, err = sql.Open(<span class="hljs-string"><span class="hljs-string">"sqlite3"</span></span>, <span class="hljs-string"><span class="hljs-string">"./words.db"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatalf(<span class="hljs-string"><span class="hljs-string">"Failed connection: %v"</span></span>, err) } _, err = connection.Exec(<span class="hljs-string"><span class="hljs-string">`CREATE TABLE IF NOT EXISTS words (word VARCHAR(225) UNIQUE NOT NULL, length INTEGER NOT NULL);`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatalf(<span class="hljs-string"><span class="hljs-string">"Failed create database table words: %v"</span></span>, err) } }</code> </pre> <a name="habracut"></a><br><h4 id="funkciya-insert">  Insert () Funktion </h4><br><p>  Wenn Sie Wörter hinzufügen, müssen Sie berücksichtigen, dass wir das kyrillische Alphabet verwenden. Aus diesem Grund passt die übliche <code>len()</code> Funktion nicht zu uns. Wir verwenden <code>utf8.RuneCountInString()</code> , um die Wortlänge korrekt zu berechnen. </p><br><p>  Fügen Sie eine Fehlerprüfung hinzu, <code>if err.Error() != "UNIQUE constraint failed: words.word"</code> - erforderlich, um neue Wörterbücher einzuführen, die eine Kopie der Wörter aus der Datenbank enthalten. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := connection.Exec(<span class="hljs-string"><span class="hljs-string">"INSERT INTO words (word,length) VALUES(?,?)"</span></span>, word, utf8.RuneCountInString(word)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> &amp;&amp; err.Error() != <span class="hljs-string"><span class="hljs-string">"UNIQUE constraint failed: words.word"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Um nach Wörtern zu suchen, aus denen die Quelle besteht, müssen Sie sie in Buchstaben zerlegen.  Ein Wort kann mehrere identische Buchstaben enthalten, um den Betrag zu berechnen, den wir verwenden <code>map[rune]int</code> wobei <code>int</code> die Anzahl der im Wort gefundenen Buchstaben ist. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-function">[</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rune</span></span></span><span class="hljs-function">]</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">rune</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, char := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> word { m[char]++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m }</code> </pre> <br><p>  Die Suche selbst wird im Multithread-Modus durchgeführt, wobei die Anzahl der Gorutinen = die Länge des ursprünglichen Wortes abzüglich einer Gorutine seitdem ist  Wir beginnen mit der Suche nach Wörtern, die aus zwei oder mehr Buchstaben bestehen. </p><br><blockquote>  Bei diesem Ansatz arbeitete das Programm zu schnell und schickte die Anzahl der Antworten = Gorutine an den Chat an den Bot, obwohl es Zeit gab. <code>time.Sleap(1 * time.Second)</code> in jeder Gorutine - dies führte dazu, dass mein Telegramm für 10 Minuten von allen Geräten blockiert wurde.  Ich habe dies berücksichtigt und in der aktuellen Version eine Verzögerung für das Senden festgelegt und die Sendefunktion selbst in eine separate Gorutine gestellt, die über einen gemeinsamen Kanal mit den anderen kommuniziert.  Die Suche wird wie bisher durchgeführt. </blockquote><p>  Wir verwenden <code>waitGroup{}</code> als Mechanismus, um die Suche nach allen Wörtern aus der Datenbank zu beenden und dann den Kanal zu schließen. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findSubWords</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { list := decay(word) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> length := <span class="hljs-number"><span class="hljs-number">2</span></span>; length &lt;= utf8.RuneCountInString(word); length++ { wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;- </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, length </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { search(out, list, length) wg.Done() fmt.Println(<span class="hljs-string"><span class="hljs-string">"Done: "</span></span>, length) }(out, length) } wg.Wait() fmt.Println(<span class="hljs-string"><span class="hljs-string">"search done"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(out) }</code> </pre> <br><p>  Die Suchfunktion wählt aus der Datenbank alle Wörter mit der gewünschten Länge aus und durchläuft die Schleife, um zu prüfen, ob das Wort geeignet ist.  Die Überprüfung erfolgt in mehreren Schritten.  Aufgrund der Verwendung der <code>map</code> erstellen wir jedes Mal, wenn wir den Schleifenzyklus abschließen, eine neue Kopie.  Wir benötigen eine Kopie der <code>map</code> , um die Anzahl der Buchstaben in einem Wort zu überprüfen. Jedes Mal, wenn ein Buchstabe übereinstimmt, verringern wir den Wert um einen Schlüssel um eins, bis er auf Null abfällt. Wenn ein solcher Buchstabe den Wert 0 hat, weisen wir <code>ontain=false</code> Variablen und <code>ontain=false</code> Variable <code>ontain=false</code> Wenn der Zyklus endet, wird das Wort nicht zum Kanal hinzugefügt. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;- </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, wordRuneList </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rune</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, length </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { wordList, err := selects(length) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"fail length %v, error: %v"</span></span>, length, err) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, word := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> wordList { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( wordCopyList = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">rune</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) contain = <span class="hljs-literal"><span class="hljs-literal">true</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> wordRuneList { wordCopyList[k] = v } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, r := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> word { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, ok := wordCopyList[r]; ok &amp;&amp; wordCopyList[r] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { wordCopyList[r]-- } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contain = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> contain { out &lt;- word } } }</code> </pre> <br><p>  Es bleibt der Fall für kleine, so dass das Programm selbst die Antworten an den Chat sendet.  Da der Bot nicht mit einem anderen Bot kommunizieren kann, musste ich mein persönliches Konto verwenden.  Ich habe mich für einen Open <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Source Client entschieden</a> . </p><br><p>  Ausführen auf dem Port: 9090.  Wir senden Nachrichten an den Chat an den Bot. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(in &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { conn, _ := net.Dial(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">"localhost:9090"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// conncect to client telegram for word := range in { fmt.Fprintf(conn, "msg WordsGame-bot %v\n", word) time.Sleep(5 * time.Second) } }</span></span></code> </pre> <br><h4 id="komandy-dlya-bystrogo-zapuska-telegram-cli-na-debian">  Befehle zum schnellen Starten von telegram-cli auf debian. </h4><br><p>  Installieren Sie die erforderlichen Bibliotheken. </p><br><pre> <code class="plaintext hljs">sudo apt install libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev libevent-dev libjansson-dev libpython-dev libgcrypt20 libz-dev make git</code> </pre> <br><p>  Klonen eines Repositorys. </p><br><pre> <code class="plaintext hljs">git clone --recursive https://github.com/vysheng/tg.git &amp;&amp; cd tg</code> </pre> <br><p>  Die Ausführung der Konfiguration. </p><br><pre> <code class="plaintext hljs">./configure make</code> </pre> <br><p>  Client-Start auf Port 9090 </p><br><pre> <code class="plaintext hljs">bin/telegram-cli -P 9090</code> </pre> <br><blockquote>  Damit der Client den Bot finden kann, muss der <code>search WordsGame-bot</code> bereits im Client ausgeführt und das Ergebnis mit dem Befehl <code>msg WordsGame-bot test</code> werden. Wenn Sie nach den Aktionen den <code>msg WordsGame-bot test</code> nicht in den Chat-Chat geschrieben haben, versuchen Sie, das Spiel persönlich damit zu spielen. <br>  Vergessen Sie nicht, sich anzumelden, damit der Kunde mit der Arbeit beginnen kann. Er schlägt vor, wenn Sie sich zum ersten Mal anmelden. </blockquote><p>  Alles scheint fertig zu sein.  Das Programm kann die Basis füllen und das Spiel mit dem Bot spielen, aber nur, wenn Sie selbst nach Worten vom Bot fragen. </p><br><p>  Aber das alles ist langsam, aber wir wollen sofort die erste Zeile nehmen, und dafür müssen wir dem Programm beibringen, Wörter vom Bot anzufordern.  Wir werden eine Verbindung herstellen und den Befehl <code>msg WordsGame-bot /play</code> senden. Der Bot hat eine Verzögerung, also warten wir 5 Sekunden.  Danach fordern wir die letzte Nachricht aus der Geschichte mit dem <code>history WordsGame-bot 1</code> Dies ist die Antwort bzw. das Wort, das wir als Quelle verwenden sollten.  Um aus <code>conn</code> zu lesen <code>conn</code> erstellen Sie die Variable <code>reply = make([]byte, 512)</code> .  Nachdem wir die ganze Antwort mit <code>onn</code> sieht es <code>onn</code> so aus. </p><br><pre> <code class="plaintext hljs"> history @manymanywords_bot 1 ANSWER 58 [16:10] WordsGame-bot »»» </code> </pre> <br><p>  Erstellen Sie <code>regexp.MustCompile("([-]{1,100})")</code> , um nach Wörtern aus dem kyrillischen Alphabet zu suchen.  Danach wählen wir unser Wort. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *god { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> send(out) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( conn, _ = net.Dial(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">"localhost:9090"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// conncect to client telegram reply = make([]byte, 512) r = regexp.MustCompile("([-]{1,100})") ) fmt.Fprintln(conn, "msg WordsGame-bot /play") time.Sleep(5 * time.Second) fmt.Fprintln(conn, "history WordsGame-bot 1") time.Sleep(2 * time.Second) _, err := conn.Read(reply) if err != nil { log.Fatalf("failed read connection %v", err) } word := r.FindAllString(string(reply), 1) if len(word) &lt;= 0 { log.Fatalf("somthing wrong %s", reply) } findSubWords(word[0]) time.Sleep(5 * time.Minute) }</span></span></code> </pre> <br><p>  Aber es gibt ein Problem, weil  Wir haben den Kanal geschlossen, nachdem wir alle Wörter gefunden hatten.  Um dies zu beheben, benötigen wir die globale Variable <code>GODMOD</code> .  Fügen Sie <code>findSubWords</code> eine Bedingung <code>findSubWords</code> .  Wenn wir nun den Schalter -g verwenden, wird die Variable GODMOD auf true gesetzt und der Kanal wird nicht geschlossen. Nach Abschluss der Schleife fordern wir ein neues Wort an. </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !GODMOD { <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(out) }</code> </pre> <br><p>  Jetzt können Sie sich das Ergebnis ansehen. </p><br><p><img src="https://habrastorage.org/webt/pm/az/vr/pmazvrl9bb1j5vizsbhuvcdgcpw.png"></p><br><h1 id="poleznye-ssylki">  Nützliche Links </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> </li><li>  <a href="">Telegramm-Cli</a> </li><li>  <a href="">Link zum Zip-Word-Basisarchiv</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432278/">https://habr.com/ru/post/de432278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432264/index.html">GitLab 11.5 mit Control Panels für Bediener und Sicherheits- und Zugriffskontrollspezialisten GitLab Pages veröffentlicht</a></li>
<li><a href="../de432268/index.html">So verwandeln Sie einen Kunden in Daten: Wir ändern die Videoüberwachung und Videoanalyse für den Einzelhandel</a></li>
<li><a href="../de432270/index.html">HappySecretSantaBot - Telegrammbot für das Spiel "Secret Santa"</a></li>
<li><a href="../de432272/index.html">Wie wir die Geschäfte auf das neue Jahr vorbereiten</a></li>
<li><a href="../de432276/index.html">Fehler beim Kompilieren von UTP</a></li>
<li><a href="../de432280/index.html">Ich fasse die Kommentare zum Artikel über IP zusammen</a></li>
<li><a href="../de432282/index.html">Maze Runner: Echtzeitanalyse der neuronalen Aktivität des Rattenhirns</a></li>
<li><a href="../de432284/index.html">Leben in einer Flasche</a></li>
<li><a href="../de432286/index.html">Die Blütezeit und der Untergang von Dreamcast</a></li>
<li><a href="../de432288/index.html">LED-Lampen von / nach Ukraine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>