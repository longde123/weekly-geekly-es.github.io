<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔶 👍🏿 ⛎ RabbitMQ - SQL Server 🤳🏿 👴🏾 🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Satu atau dua minggu yang lalu, saya melihat pesan di forum Pengguna RabbitMQ tentang cara mengatur pengiriman pesan dari SQL Server ke RabbitMQ. Kare...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ - SQL Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419457/">  Satu atau dua minggu yang lalu, saya melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pesan</a> di forum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengguna RabbitMQ</a> tentang cara mengatur pengiriman pesan dari SQL Server ke RabbitMQ.  Karena kami bekerja sama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Derivco</a> , saya meninggalkan beberapa saran di sana, dan juga mengatakan bahwa saya menulis blog tentang cara melakukan ini.  Sebagian dari pesan saya tidak sepenuhnya benar - setidaknya sampai saat itu (maaf, Bro, dia sangat sibuk). <br><br>  Hebatnya, ini adalah <b>SQL Server Anda</b> .  Menggunakannya sangat mudah untuk memasukkan informasi ke dalam basis data.  Mengambil data dari database menggunakan kueri juga mudah.  Tetapi mendapatkan data yang baru saja diperbarui atau ditempelkan sudah sedikit lebih sulit.  Pikirkan tentang peristiwa waktu nyata;  pembelian dilakukan - seseorang harus diberi tahu tentang hal ini segera setelah hal ini terjadi.  Mungkin seseorang akan mengatakan bahwa data tersebut tidak boleh muncul dari database, tetapi dari tempat lain.  Tentu saja, ini masalahnya, tetapi seringkali kita tidak punya pilihan. <br><a name="habracut"></a><br>  Kami memiliki tugas: mengirim peristiwa dari database di luar untuk diproses lebih lanjut, dan pertanyaannya adalah - bagaimana melakukan ini? <br><br><h3>  SQL Server dan komunikasi eksternal </h3><br>  Selama keberadaan SQL Server, ada beberapa upaya untuk mengatur komunikasi di luar database;  <b>SQL Server Notification Services</b> (NS), yang muncul di SQL Server 2000, dan kemudian, di SQL Server 2005, <b>SQL Server Service Broker</b> (SSB) muncul.  Saya menggambarkan mereka dalam buku saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pandangan Pertama di SQL Server 2005 untuk Pengembang</a> , bersama dengan Bob Boshemen dan Dan Sullivan.  NS muncul di SQL Server 2000, seperti yang saya katakan, dan dirancang ulang dalam versi beta SQL Server 2005. Namun, NS <s>sepenuhnya</s> dikecualikan dari versi siap-jual (RTM) SQL Server 2005. <br><blockquote>  <b>Catatan:</b> Jika Anda membaca buku, Anda akan menemukan ada sejumlah fitur yang tidak ada dalam versi RTM. </blockquote>  SSB selamat, dan Microsoft memperkenalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Service Broker External Activator</a> (EA) dalam SQL Server 2008 Feature Pack-nya.  Itu memungkinkan melalui SSB untuk berinteraksi di luar database lokal.  Secara teori, ini terdengar bagus, tetapi dalam praktiknya - ini rumit dan membingungkan.  Kami melakukan beberapa tes dan dengan cepat menyadari bahwa itu tidak melakukan apa yang kami butuhkan.  Selain itu, SSB tidak memberi kami kinerja yang diperlukan, jadi kami harus menciptakan sesuatu yang lain. <br><br><h3>  SQLCLR </h3><br>  Apa yang kami dapatkan sebagai hasilnya didasarkan pada teknologi SQLCLR.  SQLCLR adalah platform .NET yang dibangun ke dalam inti SQL Server dan dapat digunakan untuk mengeksekusi kode .NET di dalam kernel.  Karena kami menjalankan kode .NET, kami dapat melakukan hampir semua hal seperti pada aplikasi .NET biasa. <br><blockquote>  <b>Catatan:</b> Saya menulis "hampir" di atas, karena sebenarnya ada beberapa batasan.  Dalam konteks ini, pembatasan ini hampir tidak berpengaruh pada apa yang akan kita lakukan. <br></blockquote>  Prinsip operasi SQLCLR adalah sebagai berikut: kode dikompilasi ke perpustakaan dll, dan kemudian perpustakaan ini terdaftar menggunakan alat SQL Server: <br><br>  Bangun Majelis <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASSEMBLY</span></span> [RabbitMQ.SqlServer] AUTHORIZATION rmq <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">'F:\some_path\RabbitMQSqlClr4.dll'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> PERMISSION_SET = <span class="hljs-keyword"><span class="hljs-keyword">UNSAFE</span></span>; GO</code> </pre> <br>  <b>Cuplikan Kode 1:</b> Membuat Majelis di sepanjang Jalan Absolut <br><br>  Kode melakukan tindakan berikut: <br><br><ul><li>  <code>CREATE ASSEMBLY</code> - Membuat perakitan dengan nama yang diberikan (tidak peduli apa yang seharusnya). </li><li>  <code>AUTHORIZATION</code> - Menunjukkan pemilik rakitan.  Dalam hal ini, rmq adalah peran SQL Server yang telah ditentukan. </li><li>  <code>FROM</code> - Menentukan lokasi perakitan asli.  Di <code>FROM</code> , Anda juga bisa menentukan lintasan dalam format biner atau UNC.  File instalasi untuk proyek ini menggunakan representasi biner. </li><li>  <code>WITH PERMISSION_SET</code> - Menetapkan izin.  <code>UNSAFE</code> adalah yang paling tidak ketat dan diperlukan dalam kasus ini. </li></ul><br><blockquote>  <b>Catatan:</b> terlepas dari peran atau login yang digunakan dalam klausa <code>AUTHORIZATION</code> , kelas appdomain harus dibuat dengan nama yang sama seperti ketika memuat perakitan ke dalam domain.  Disarankan untuk memisahkan rakitan dengan berbagai nama kelas appdomain sehingga ketika satu rakitan gagal, sisanya tidak jatuh.  Namun, jika majelis bergantung satu sama lain, mereka tidak dapat dibagi ke dalam kelas yang berbeda. <br></blockquote>  Ketika perakitan dibuat, kami membuat pembungkus metode .NET di dalamnya: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> rmq.pr_clr_PostRabbitMsg @EndpointID <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, @Message <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">max</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> [RabbitMQ.SqlServer].[RabbitMQSqlClr.RabbitMQSqlServer].[pr_clr_PostRabbitMsg]; GO</code> </pre><br>  <b>Kode 2:</b> Pembungkus Metode .NET <br><br>  Kode melakukan tindakan berikut: <br><br><ul><li>  Membuat prosedur tersimpan T-SQL bernama <code>rmq.pr_clr_PostRabbitMsg</code> yang mengambil dua parameter;  <code>@EndpointID</code> dan <code>@Message</code> . </li><li>  Alih-alih badan prosedur, sumber eksternal digunakan, yang terdiri dari: <br><ul><li>  Majelis yang bernama <code>RabbitMQ.SqlServer</code> , mis. Agregat yang kami buat di atas dalam <b>cuplikan kode 1</b> . </li><li>  Tipe lengkap (namespace dan kelas): <code>RabbitMQSqlClr.RabbitMQSqlServer</code> </li><li>  Metode dari namespace dan kelas di atas adalah: <code>pr_clr_PostRabbitMsg</code> . </li></ul></li></ul><br>  Ketika <code>rmq.pr_clr_PostRabbitMsg</code> , metode <code>pr_clr_PostRabbitMsg</code> akan dipanggil. <br><blockquote>  <b>Catatan:</b> saat membuat prosedur, nama rakitan tidak peka huruf besar-kecil, tidak seperti nama lengkap jenis dan metode.  Tidak perlu bahwa nama prosedur yang dibuat cocok dengan nama metode.  Namun, tipe data akhir untuk parameter harus cocok. </blockquote>  Seperti yang saya katakan sebelumnya, kami di Derivco perlu mengirim data di luar SQL Server, jadi kami menggunakan SQLCLR dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RabbitMQ</a> (RMQ). <br><br><h3>  Rabbitmq </h3><br>  RMQ adalah broker pesan sumber terbuka yang mengimplementasikan Advanced Message Queuing Protocol (AMQP) dan ditulis dalam bahasa Erlang. <br><br>  Karena RMQ adalah pialang pesan, pustaka klien AMQP diharuskan untuk terhubung dengannya.  Aplikasi merujuk ke pustaka klien dan, dengan bantuan mereka, membuka koneksi dan mengirim pesan - seperti, misalnya, ada panggilan melalui ADO.NET ke SQL Server.  Tetapi tidak seperti ADO.NET, di mana, kemungkinan besar, koneksi terbuka setiap kali Anda mengakses database, di sini koneksi tetap terbuka untuk seluruh periode aplikasi. <br><br>  Dengan demikian, untuk dapat berinteraksi dari database dengan RabbitMQ, kita membutuhkan aplikasi dan pustaka klien .NET untuk RabbitMQ. <br><blockquote>  <b>Catatan:</b> di bagian selanjutnya artikel ini, fragmen kode RabbitMQ akan ditemukan, tetapi tanpa penjelasan rinci tentang apa yang mereka lakukan.  Jika Anda baru bekerja dengan RabbitMQ, maka saya sarankan untuk melihat berbagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial RabbitMQ</a> untuk memahami tujuan kode.  Tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hello World</a> C # adalah awal yang baik.  Salah satu perbedaan antara buku teks dan contoh kode adalah bahwa penukar tidak dinyatakan dalam contoh.  Mereka seharusnya sudah ditentukan sebelumnya. </blockquote><h3>  RabbitMQ.SqlServer </h3><br>  <b>RabbitMQ.SqlServer</b> adalah perakitan yang menggunakan perpustakaan .NET klien untuk RabbitMQ dan menyediakan kemampuan untuk mengirim pesan dari database ke satu atau lebih titik akhir RabbitMQ (VHosts dan penukar).  Kode dapat diunduh / bercabang dari repositori saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RabbitMQ-SqlServer</a> di GitHub.  Ini berisi sumber rakitan dan file instalasi (mis. Anda tidak harus mengompilasinya sendiri). <br><blockquote>  <b>Catatan:</b> ini hanyalah contoh untuk menunjukkan bagaimana SQL Server dapat berinteraksi dengan RabbitMQ.  Ini BUKAN produk jadi atau bahkan bagian dari itu.  Jika kode ini menghancurkan otak Anda - jangan salahkan saya, karena ini hanyalah sebuah contoh. <br></blockquote><h3>  Fungsionalitas </h3><br>  Ketika rakitan dimuat, atau ketika inisialisasi secara eksplisit dipanggil, atau ketika itu disebut secara tidak langsung, pada saat prosedur pembungkus dipanggil, rakitan memuat string koneksi ke dalam database lokal di mana ia dipasang, serta titik akhir RabbitMQ yang terhubung: <br><br>  Koneksi <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { connFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConnectionFactory(); connFactory.Uri = connString; connFactory.AutomaticRecoveryEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; connFactory.TopologyRecoveryEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; RabbitConn = connFactory.CreateConnection(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; channels; x++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ch = RabbitConn.CreateModel(); rabbitChannels.Push(ch); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception ex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  <b>Cuplikan Kode 3:</b> Sambungkan ke Titik Akhir <br><br>  Pada saat yang sama, bagian dari koneksi ke titik akhir juga membuat IModels pada koneksi, dan mereka digunakan saat mengirim (menambahkan ke antrian) pesan: <br><br>  Pengiriman pesan <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> exchange, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] msg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topic</span></span></span><span class="hljs-function">)</span></span> { IModel <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> channelTryCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((!rabbitChannels.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) &amp;&amp; channelTryCount &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) { channelTryCount += <span class="hljs-number"><span class="hljs-number">1</span></span>; Thread.Sleep(<span class="hljs-number"><span class="hljs-number">50</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (channelTryCount == <span class="hljs-number"><span class="hljs-number">100</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errMsg = <span class="hljs-string"><span class="hljs-string">$"Channel pool blocked when trying to post message to Exchange: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{exchange}</span></span></span><span class="hljs-string">."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(errMsg); } <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.BasicPublish(exchange, topic, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, msg); rabbitChannels.Push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _rabbitChannels.Push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre> <br>  Metode <code>Post</code> dipanggil dari metode <code>pr_clr_PostRabbitMsg(int endPointId, string msgToPost)</code> , yang disajikan sebagai prosedur menggunakan klausa <code>CREATE PROCEDURE</code> dalam fragmen kode 2: <br><br>  Metode pemanggilan pos <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pr_clr_PostRabbitMsg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endPointId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msgToPost</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(endPointId == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(<span class="hljs-string"><span class="hljs-string">"EndpointId cannot be 0"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isInitialised) { pr_clr_InitialiseRabbitMq(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> msg = Encoding.UTF8.GetBytes(msgToPost); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endPointId == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rep <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> remoteEndpoints) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exch = rep.Value.Exchange; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> topic = rep.Value.RoutingKey; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pub <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rabbitPublishers.Values) { pub.Post(exch, msg, topic); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { RabbitPublisher pub; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rabbitPublishers.TryGetValue(endPointId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> pub)) { pub.Post(remoteEndpoints[endPointId].Exchange, msg, remoteEndpoints[endPointId].RoutingKey); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(<span class="hljs-string"><span class="hljs-string">$"EndpointId: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{endPointId}</span></span></span><span class="hljs-string">, does not exist"</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre> <br>  <b>Cuplikan Kode 5:</b> Mewakili Metode sebagai Prosedur <br><br>  Ketika metode dieksekusi, diasumsikan bahwa penelepon mengirimkan pengidentifikasi titik akhir di mana pesan harus dikirim, dan, pada kenyataannya, pesan itu sendiri.  Jika nilai -1 dilewatkan sebagai pengidentifikasi titik akhir, maka kami mengulangi semua titik dan mengirim pesan ke masing-masing.  Pesan itu datang dalam bentuk string dari mana kita mendapatkan byte menggunakan <code>Encoding.UTF8.GetBytes</code> .  Dalam lingkungan produksi, panggilan <code>Encoding.UTF8.GetBytes</code> harus diganti dengan serialisasi. <br><br><h3>  Instalasi </h3><br>  Untuk menginstal dan menjalankan contoh, Anda memerlukan semua file di folder <code>src\SQL</code> .  Untuk menginstal, ikuti langkah-langkah ini: <br><br><ul><li>  Jalankan skrip <code>01.create_database_and_role.sql</code> .  Dia akan menciptakan: <br><ul><li>  <code>RabbitMQTest</code> data uji <code>RabbitMQTest</code> tempat perakitan akan dibuat. </li><li>  peran <code>rmq</code> untuk ditugaskan sebagai pemilik majelis </li><li>  skema, yang juga akan disebut <code>rmq</code> .  Dalam diagram ini, berbagai objek basis data dibuat. <br></li></ul><br></li><li>  Jalankan file <code>02.create_database_objects.sql</code> .  Dia akan menciptakan: <br><br><ul><li>  tabel <code>rmq.tb_RabbitSetting</code> , yang akan menyimpan string koneksi ke database lokal. </li><li>  Tabel <code>rmq.tb_RabbitEndpoint</code> , di mana satu atau lebih titik akhir <code>RabbitMQ</code> akan disimpan. </li></ul><br></li><li>  Dalam file <code>03.create_localhost_connstring.sql</code> ubah nilai variabel <code>@connString</code> ke string koneksi yang benar untuk database <code>RabbitMQTest</code> dibuat pada langkah 1 dan jalankan skrip. <br></li></ul><br>  Sebelum melanjutkan, Anda harus memiliki instance berjalan broker RabbitMQ dan VHost (secara default, VHost direpresentasikan sebagai /).  Sebagai aturan, kami memiliki beberapa VHost, hanya untuk isolasi.  Tuan rumah ini juga membutuhkan penukar, dalam contoh kita menggunakan <code>amq.topic</code> .  Ketika broker RabbitMQ Anda siap, edit <code>rmq.pr_UpsertRabbitEndpoint</code> prosedur <code>rmq.pr_UpsertRabbitEndpoint</code> , yang terletak di file <code>04.upsert_rabbit_endpoint.sql</code> : <br><br>  Endpoint RabbitMQ <br><br><pre> <code class="cs hljs">EXEC rmq.pr_UpsertRabbitEndpoint @Alias = <span class="hljs-string"><span class="hljs-string">'rabbitEp1'</span></span>, @ServerName = <span class="hljs-string"><span class="hljs-string">'RabbitServer'</span></span>, @Port = <span class="hljs-number"><span class="hljs-number">5672</span></span>, @VHost = <span class="hljs-string"><span class="hljs-string">'testHost'</span></span>, @LoginName = <span class="hljs-string"><span class="hljs-string">'rabbitAdmin'</span></span>, @LoginPassword = <span class="hljs-string"><span class="hljs-string">'some_secret_password'</span></span>, @Exchange = <span class="hljs-string"><span class="hljs-string">'amq.topic'</span></span>, @RoutingKey = <span class="hljs-string"><span class="hljs-string">'#'</span></span>, @ConnectionChannels = <span class="hljs-number"><span class="hljs-number">5</span></span>, @IsEnabled = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <b>Kode 6:</b> Menciptakan Endpoint di RabbitMQ <br><br>  Pada titik ini, sekarang saatnya untuk menggelar majelis.  Ada perbedaan dalam opsi penyebaran untuk versi SQL Server sebelum SQL Server 2014 (2005, 2008, 2008R2, 2012), dan untuk 2014 dan yang lebih baru.  Perbedaannya terletak pada versi CLR yang didukung.  Sebelum SQL Server 2014, platform .NET berjalan di CLR versi 2, dan di SQL Server 2014 dan di atasnya, versi 4 digunakan. <br><br><h3>  SQL Server 2005 - 2012 </h3><br>  Mari kita mulai dengan versi SQL Server yang berjalan pada CLR 2, karena mereka memiliki karakteristik sendiri.  Kita perlu menggunakan rakitan yang dibuat, dan pada saat yang sama menyebarkan pustaka RabbitMQ klien .NET ( <code>RabbitMQ.Client</code> ).  Dari pertemuan kami, kami akan merujuk ke perpustakaan klien RabbitMQ.  Karena  Karena kami berencana untuk menggunakan CLR 2, perakitan kami dan <code>RabbitMQ.Client</code> harus dikompilasi berdasarkan .NET 3.5.  Ada masalah. <br><br>  Semua versi terbaru dari perpustakaan <code>RabbitMQ.Client</code> dikompilasi untuk lingkungan CLR 4, sehingga mereka tidak dapat digunakan dalam perakitan kami.  Versi terbaru dari perpustakaan klien untuk CLR 2 dikompilasi di .NET 3.4.3.  Tetapi bahkan jika kami mencoba menggunakan majelis ini, kami mendapatkan pesan kesalahan: <br><br><img src="https://habrastorage.org/webt/db/yo/uj/dbyouj4az0fzhnwpkvtdkgj6i-q.png"><br>  <i><b>Gambar 1:</b> Sistem Hilang. Perakitan Model Layanan</i> <br><br>  Versi <code>RabbitMQ.Client</code> merujuk ke perakitan yang bukan bagian dari SQL Server CLR.  Ini adalah perakitan WCF, dan ini adalah salah satu keterbatasan dalam SQLCLR yang saya sebutkan di atas: perakitan khusus ini untuk jenis tugas yang tidak diperbolehkan dilakukan dalam SQL Server.  Versi terbaru dari <code>RabbitMQ.Client</code> tidak memiliki dependensi ini, sehingga mereka dapat digunakan tanpa masalah, kecuali untuk persyaratan mengganggu dari CLR 4. Apa yang harus saya lakukan? <br><br>  Seperti yang Anda ketahui, RabbitMQ adalah open source, tetapi kami adalah pengembang, bukan?  ;) Jadi mari kita kompilasi ulang!  Dalam versi sebelum rilis terbaru (mis. Versi &lt;3.5.0) dari <code>RabbitMQ.Client</code> saya menghapus tautan ke <code>System.ServiceModel</code> dan dikompilasi ulang.  Saya harus mengubah beberapa baris kode menggunakan fungsionalitas <code>System.ServiceModel</code> , tetapi ini adalah perubahan kecil. <br><br>  Dalam contoh ini, saya tidak menggunakan versi klien 3.4.3, tapi saya mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rilis stabil 3.6.6</a> dan dikompilasi ulang menggunakan .NET 3.5 (CLR 2).  Itu hampir berhasil :), kecuali bahwa rilis kemudian dari <code>RabbitMQ.Client</code> menggunakan <code>Task</code> 'dan yang awalnya bukan bagian dari. NET 3.5. <br><br>  Untungnya, ada versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>System.Threading.dll</code></a> untuk .NET 3.5 yang mencakup <code>Task</code> .  Saya mengunduhnya, mengatur tautan dan semuanya berjalan!  Di sini trik utamanya adalah <code>System.Threading.dll</code> harus diinstal dengan perakitan. <br><blockquote>  <b>Catatan:</b> sumber <code>RabbitMQ.Client</code> , dari mana saya menyusun versi .NET 3.5, ada di repositori saya di GitHub <a href="">RabbitMQ Client 3.6.6 .NET 3.5</a> .  Biner dll bersama dengan <code>System.Threading.dll</code> untuk. NET 3.5 juga terletak di <code>lib\NET3.5</code> repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(RabbitMQ-SqlServer)</a> . <br></blockquote>  Untuk menginstal rakitan yang diperlukan ( <code>System.Threading</code> , <code>RabbitMQ.Client</code> dan <code>RabbitMQ.SqlServer</code> ) jalankan skrip instalasi dari direktori <code>src\sql</code> dengan urutan sebagai berikut: <br><br><ol><li>  <code>05.51.System.Threading.sql2k5-12.sql</code> - System.Threading </li><li>  <code>05.52.RabbitMQ.Client.sql2k5-12.sql</code> - RabbitMQ.Client </li><li>  <code>05.53.RabbitMQ.SqlServer.sql2k5-12.sql</code> - RabbitMQ.SqlServer </li></ol><br><h3>  SQL Server 2014+ </h3><br>  Di SQL Server 2014 dan yang lebih baru, kumpulan mengkompilasi di bawah. NET 4.XX (contoh saya ada di 4.5.2), dan Anda dapat mereferensikan salah satu versi terbaru dari <code>RabbitMQ.Client</code> , yang dapat diperoleh dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NuGet</a> .  Dalam contoh saya, saya menggunakan 4.1.1.  <code>RabbitMQ.Client</code> , yang juga ada di <code>lib\NET4</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori (RabbitMQ-SqlServer)</a> . <br><br>  Untuk menginstal, jalankan skrip dari direktori <code>src\sql</code> dengan urutan sebagai berikut: <br><br><ol><li>  <code>05.141.RabbitMQ.Client.sql2k14+.sql</code> .sql - RabbitMQ.Client </li><li>  <code>05.142.RabbitMQ.SqlServer.sql2k14+.sql</code> .sql - RabbitMQ.SqlServer </li></ol><br><h3>  Pembungkus Metode SQL </h3><br>  Untuk membuat prosedur yang akan digunakan dari perakitan kami (3,5 atau 4), jalankan skrip <code>06.create_sqlclr_procedures.sql</code> .  Dia akan membuat prosedur T-SQL untuk tiga metode .NET: <br><br><ul><li>  <code>rmq.pr_clr_InitialiseRabbitMq</code> memanggil <code>pr_clr_InitialiseRabbitMq</code> .  Digunakan untuk memuat dan menginisialisasi perakitan RabbitMQ.SqlServer. </li><li>  <code>rmq.pr_clr_ReloadRabbitEndpoints</code> memanggil <code>pr_clr_ReloadRabbitEndpoints</code> .  Memuat berbagai titik akhir RabbitMQ. </li><li>  <code>rmq.pr_clr_PostRabbitMsg</code> memanggil <code>pr_clr_PostRabbitMsg</code> .  Digunakan untuk mengirim pesan ke RabbitMQ. </li></ul><br>  Script juga membuat prosedur T-SQL sederhana - <code>rmq.pr_PostRabbitMsg</code> , yang berlaku untuk <code>rmq.pr_clr_PostRabbitMsg</code> .  Ini adalah prosedur pembungkus yang tahu apa yang harus dilakukan dengan data, menangani pengecualian, dll.  Dalam lingkungan produksi, kami memiliki beberapa prosedur serupa yang memproses berbagai jenis pesan.  Baca lebih lanjut tentang ini di bawah ini. <br><br><h3>  Gunakan </h3><br>  Dari semua hal di atas, jelas bahwa untuk mengirim pesan ke RabbitMQ kita sebut <code>rmq.pr_PostRabbitMsg</code> atau <code>rmq.pr_clr_PostRabbitMsg</code> , dengan mengirimkan parameter pengidentifikasi titik akhir dan pesan itu sendiri sebagai string.  Semua ini, tentu saja, keren, tetapi saya ingin melihat bagaimana ini akan bekerja dalam kenyataan. <br><br>  Apa yang kami lakukan di lingkungan produksi adalah bahwa dalam prosedur tersimpan yang memproses data yang harus dikirim ke RabbitMQ, kami mengumpulkan data yang akan dikirim dan di blok koneksi kami memanggil prosedur seperti <code>rmq.pr_PostRabbitMsg</code> .  Berikut ini adalah contoh prosedur yang sangat disederhanakan: <br><br>  Prosedur pemrosesan data <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> dbo.pr_SomeProcessingStuff @<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> NOCOUNT <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY <span class="hljs-comment"><span class="hljs-comment">--     DECLARE @endPointId int; --    DECLARE @msg nvarchar(max) = '{' --        SET @msg = @msg + '"Id":' + CAST(@id AS varchar(10)) + ',' --  -  SET @msg = @msg + '"FName":"Hello",'; SET @msg = @msg + '"LName":"World"'; SET @msg = @msg + '}'; -- -  --     -,  -  SELECT @endPointId = 1; --    --     EXEC rmq.pr_PostRabbitMsg @Message = @msg, @EndpointID = @endPointId; END TRY BEGIN CATCH DECLARE @errMsg nvarchar(max); DECLARE @errLine int; SELECT @errMsg = ERROR_MESSAGE(), @errLine = ERROR_LINE(); RAISERROR('Error: %s at line: %d', 16, -1, @errMsg, @errLine); END CATCH END</span></span></code> </pre> <br>  Dalam <b>fragmen kode 7,</b> kita melihat bagaimana data yang diperlukan ditangkap dan diproses dalam prosedur dan dikirim setelah pemrosesan.  Untuk menggunakan prosedur ini, jalankan skrip <code>07.create_processing_procedure.sql</code> dari direktori <code>src\SQL</code> . <br><br><h3>  Mari kita jalankan semuanya </h3><br>  Pada titik ini, Anda harus siap untuk mengirim beberapa pesan.  Sebelum pengujian, pastikan Anda memiliki antrian di RabbitMQ yang terpasang pada penukar titik akhir di <code>rmq.tb_RabbitEndpoint</code> . <br><br>  Jadi, untuk memulai Anda perlu melakukan hal berikut: <br>  Buka file <code>99.test_send_message.sql</code> . <br>  Lari <br><br><pre> <code class="sql hljs">EXEC rmq.pr_clr_InitialiseRabbitMq;</code> </pre> <br>  untuk menginisialisasi perakitan dan memuat titik akhir RabbitMQ.  Ini bukan langkah yang diperlukan, tetapi Anda disarankan untuk melakukan preload perakitan setelah membuat atau memodifikasinya. <br><br>  Lari <br><br><pre> <code class="sql hljs">EXEC dbo.pr_SomeProcessingStuff @id = 101</code> </pre> <br>  (Anda dapat menggunakan pengenal lain yang Anda suka). <br><br>  Jika semuanya berfungsi tanpa kesalahan, maka sebuah pesan akan muncul di antrian RabbitMQ!  Jadi, Anda menggunakan SQLCLR untuk mengirim pesan ke RabbitMQ. <br><br>  Selamat! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419457/">https://habr.com/ru/post/id419457/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419439/index.html">Bagaimana e-commerce bertahan dalam promosi skala besar. Bersiap untuk beban puncak di web [Bagian 2]</a></li>
<li><a href="../id419441/index.html">SpaceX pertama menggunakan kembali roket Falcon 9 Block 5 hari ini</a></li>
<li><a href="../id419449/index.html">API Redux vs. Bereaksi Konteks</a></li>
<li><a href="../id419451/index.html">Buat bundel untuk Symfony 4 langkah demi langkah</a></li>
<li><a href="../id419453/index.html">Metode numerik untuk memecahkan sistem persamaan nonlinier</a></li>
<li><a href="../id419459/index.html">Baterai timbal-asam: alfabet pengisian daya pulsa</a></li>
<li><a href="../id419461/index.html">Ventilasi kamar kecil</a></li>
<li><a href="../id419467/index.html">Dari bola lampu hingga penyedot debu dan dengung - bagaimana kami mengajari Alice mengelola ratusan perangkat</a></li>
<li><a href="../id419469/index.html">UE4 | Siklus siang dan malam | Modifikasi SkySphere</a></li>
<li><a href="../id419471/index.html">Opsi migrasi dari jQuery ke javascript murni</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>