<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úñÔ∏è üóº üéÖüèæ Por que rasguei um CD 300 vezes üôáüèΩ üêö ü§≤üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Coleciono m√∫sicas: compro CDs, digitalizo com Exact Audio Copy e digitalizo capas e inser√ß√µes. √Äs vezes, n√£o √© f√°cil se o CD foi lan√ßado em uma edi√ß√£o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por que rasguei um CD 300 vezes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418995/"> Coleciono m√∫sicas: compro CDs, digitalizo com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exact Audio Copy</a> e digitalizo capas e inser√ß√µes.  √Äs vezes, n√£o √© f√°cil se o CD foi lan√ßado em uma edi√ß√£o limitada no exterior h√° 10 anos.  O mais dif√≠cil √© se o CD tiver um defeito de fabrica√ß√£o - e algumas faixas n√£o puderem ser lidas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f5/e32/a86/6f5e32a86569ad14e42c0ea28a8de301.jpg" align="left">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O</a> √°lbum de arranjos para piano de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Altneuland Â∏∞ „Çã „Åπ „Åç Âüé</a> foi lan√ßado em 2005.  Eu o encontrei tr√™s anos depois (provavelmente no YouTube), baixei a melhor c√≥pia - e coloquei na lista de compras futuras.  Avan√ßos recentes na tecnologia de correio internacional tornaram poss√≠vel comprar um disco usado no ano passado.  Infelizmente, nenhuma das minhas unidades de CD conseguiu ler a faixa n√∫mero 3. Isso geralmente acontece na compra de discos antigos, principalmente quando eles passam pelo centro de expedi√ß√£o internacional do USPS.  Coloquei de lado e comecei a procurar outra c√≥pia que encontrei no m√™s passado.  Ele chegou na sexta-feira - e eu imediatamente tentei rasg√°-lo.  Mas com empurrado com <i>exatamente o mesmo erro</i> .  Parece que isso n√£o √© uma quest√£o de desgaste ou dano - o disco provavelmente saiu defeituoso diretamente da f√°brica. <br><br>  ADI√á√ÉO: Ap√≥s a investiga√ß√£o, n√£o acredito mais que se trata de um defeito de f√°brica.  Quando gravo o in√≠cio ou o fim de uma faixa ruim em um CD-R vazio e a copio, o estripador produz o mesmo erro!  Tente voc√™ mesmo com o arquivo <a href="">minimal.flac</a> . <br><a name="habracut"></a><br>  Existem duas op√ß√µes: tente um dia encontrar outra c√≥pia que ser√° copiada com √™xito (improv√°vel) ou, de alguma forma, restaurar os dados de som originais de discos danificados.  Voc√™ j√° sabe qual op√ß√£o eu escolhi. <br><br><h1>  Como o estripador funciona </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/9b0/ff6/69e9b0ff62e391da0701a6a4cd02b57d.png"><br>  <i><font color="gray">O EAC n√£o p√¥de ler a faixa n ¬∞ 3 do disco [Â∏∞ „Çã „Åπ „Åç Âüé]</font></i> <br><br>  Os CDs armazenam dados digitais, mas h√° uma interface completamente anal√≥gica entre discos, lasers e diodos √≥pticos.  Os erros de leitura ocorrem por v√°rios motivos: m√≠dia suja, arranh√µes na camada protetora de policarbonato, vibra√ß√£o da pr√≥pria unidade.  Os c√≥digos de corre√ß√£o de erros primitivos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padr√£o CDDA</a> ajudam a minimizar a distor√ß√£o do som em discos raramente usados, mas n√£o conseguem restaurar completamente o fluxo de bits em um CD com um grande n√∫mero de erros.  Os ripadores modernos resolvem o problema com dois m√©todos importantes de detec√ß√£o de erros: leitura redundante e AccurateRip. <br><br>  A p√°gina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">EAC: Extraction Technology</a> descreve como o EAC produz leituras redundantes: <br><br><blockquote>  No modo de seguran√ßa, o programa l√™ cada setor pelo menos duas vezes [...] Se ocorrer um erro (ler ou sincronizar), o programa continuar√° lendo esse setor at√© que 8 de 16 tentativas sejam id√™nticas.  Esse procedimento √© realizado no m√°ximo uma vez, tr√™s ou cinco vezes (de acordo com a qualidade selecionada de recupera√ß√£o de erro).  Portanto, na pior das hip√≥teses, setores defeituosos s√£o lidos 82 vezes! </blockquote><br>  Tudo √© simples.  Se uma solicita√ß√£o de leitura √†s vezes retornar dados incorretos, leia-os novamente e, em seguida, tenha especial cuidado se as duas primeiras leituras fornecerem resultados diferentes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O AccurateRip</a> usa o mesmo princ√≠pio, mas de maneira distribu√≠da: os ripadores enviam somas de verifica√ß√£o dos arquivos de √°udio copiados para este servi√ßo.  A id√©ia √© que, se mil pessoas copiam uma faixa com os mesmos bits, esse provavelmente √© o rasgo certo. <br><br>  Este artigo √© sobre o que fazer se ambos os m√©todos n√£o puderem ajudar.  O EAC n√£o fornece um resultado se cada leitura retornar dados diferentes, e no banco de dados AccurateRip h√° apenas um registro sobre um disco raro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[1]</a> <a name="1_1"></a>  . <br><br><h1>  "Passei dez mil passagens, dez mil passagens para v√™-lo" </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/1ab/850/44a1ab850b96409640f45e9425f73652.jpg"><br>  <i><font color="gray">Drives √≥pticos Asus, LG, Lite-On, Pioneer e OEM desconhecido</font></i> <br><br>  Se o CD n√£o for copiado, √© l√≥gico usar uma unidade diferente.  √Äs vezes, um modelo espec√≠fico √© mais condescendente com as especifica√ß√µes do CDDA, ou existe um firmware melhor para corrigir erros ou algo mais.  O f√≥rum DBpoweramp possui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma classifica√ß√£o de precis√£o da unidade de CD / DVD</a> para selecionar a unidade rip adequada. <br><br>  No s√°bado de manh√£, comprei cinco novas unidades de CD de diferentes fabricantes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[2]</a> <a name="2_2"></a>  , Tentei todos eles - e encontrei um que era capaz de manter a sincroniza√ß√£o em uma faixa de batida.  Infelizmente, n√£o foi poss√≠vel obter a confirma√ß√£o do rip - entre todos os rasgos, havia cerca de 20.000 bytes diferentes. <br><br>  Mas agora eu tinha arquivos .wav no disco e voc√™ pode se beneficiar disso.  Eu raciocinei que os erros de leitura em uma faixa ruim est√£o pr√≥ximos do "correto".  Portanto, faz sentido fazer v√°rios rasgos e encontrar um valor de "consenso" para bytes inst√°veis.  Essa abordagem acabou sendo bem-sucedida, mas exigiu muito mais trabalho do que eu esperava. <br><br><h1>  "Quantidade entra em qualidade" </h1><br>  Comecei copiando um disco v√°rias vezes em uma das unidades, escrevendo todos os valores para cada byte e declarando o erro ‚Äúcorrig√≠vel‚Äù se mais da metade dos rasgos produzir um valor de byte espec√≠fico para esta posi√ß√£o.  O come√ßo foi bom: o n√∫mero de erros incorrig√≠veis diminuiu de quase ~ 6900 bytes em N = 4 para ~ 5000 bytes em N = 10.  O benef√≠cio de cada rip adicional diminuiu ao longo do tempo, at√© cerca de N = 80, o n√∫mero de erros incorrig√≠veis estabilizados em ~ 3700.  Parei de rasgar em N = 100. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b87/aaa/809/b87aaa809a043eaeaa2d049258fe0cb9.png"><br>  <i><font color="gray">Erros corrigidos e fatais no n√∫mero de rip</font></i> <br><br>  Tentei copiar o disco 100 vezes na segunda unidade e usar duas placas de corre√ß√£o para "preencher" as posi√ß√µes de erro incorrig√≠veis da primeira unidade.  Mas n√£o funcionou: em cada unidade, havia milhares de corre√ß√µes que n√£o correspondiam √†s corre√ß√µes na outra!  Acontece que o ru√≠do n√£o pode ser eliminado combinando-o com outra fonte de ru√≠do, mas relacionada. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/911/6d5/c33/9116d5c339461cb286edc4537c712a71.png"><br>  <i><font color="gray">A mesma coisa, mas para dois discos de valida√ß√£o cruzada</font></i> <br><br><h1>  Arte artesanal </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/ec7/829/554/ec78295544b0a161b472598114e2be2d.jpg"><br><br>  H√° outro bom recurso no site da EAC: o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teste de qualidade DAE</a> , que determina a qualidade do firmware de uma unidade pelo n√≠vel de erros que est√£o sendo corrigidos.  Este √© um tratamento de erro de n√≠vel inferior quando a unidade <i>corrige</i> erros de leitura em vez de apenas relat√°-los.  O problema √© que o "modo de seguran√ßa" do EAC s√≥ est√° dispon√≠vel quando voc√™ desabilita esse c√≥digo de corre√ß√£o de erros interno, sugerindo que ele n√£o funciona corretamente. <br><br>  Preparei o teste gravando o arquivo .wav em CD-R, destacando o setor exato na superf√≠cie dos dados e pintando-o cuidadosamente com um marcador preto.  Esses s√£o erros fatais garantidos em um padr√£o determin√≠stico. <br><br>  Testei todas as unidades e obtive dois resultados interessantes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11f/4c6/f55/11f4c6f554062ec91d1f5d4160b40a43.png"><br><br>  Usei a unidade Lite-On para solucionar os erros de sincroniza√ß√£o.  Ele mastigou o marcador m√°gico com prazer, mas ficou muito confuso com as linhas retas na superf√≠cie dos dados.  Voc√™ pode ver como, em vez de tr√™s picos separados √† direita, h√° um blob gigante com falha. <br><br> <code>Errors total Num : 206645159 <br> Errors (Loudness) Num : 965075 - Avg : -21.7 dB(A) - Max : -5.5 dB(A) <br> Error Muting Num : 154153 - Avg : 99.1 Samples - Max : 3584 Samples <br> Skips Num : 103 - Avg : 417.3 Samples - Max : 2939 Samples <br> <br> Total Test Result : 45.3 points (of 100.0 maximum)</code> <br> <br><img src="https://habrastorage.org/getpro/habr/post_images/07b/beb/2d7/07bbeb2d7534a3eb062e176c8b059182.png"><br><br>  A unidade Pioneer recebeu a maior pontua√ß√£o no DAE.  Na minha opini√£o, o gr√°fico n√£o parece ser especial, mas a ferramenta de an√°lise disse que este √© o melhor firmware para corrigir erros no meu pequeno conjunto. <br><br> <code>Errors total Num : 2331952 <br> Errors (Loudness) Num : 147286 - Avg : -77.2 dB(A) - Max : -13.2 dB(A) <br> Error Muting Num : 8468 - Avg : 1.5 Samples - Max : 273 Samples <br> Skips Num : 50 - Avg : 6.5 Samples - Max : 30 Samples <br> <br> Total Test Result : 62.7 points (of 100.0 maximum)</code> <br> <br><h1>  "A partir de um certo momento, os n√∫meros s√£o importantes" </h1><br>  Como usar o firmware da Pioneer com boa corre√ß√£o de erro se o EAC do "modo de seguran√ßa" o ignora?  Muito simples: alterne o EAC para o "modo burst" e escreva no disco o fluxo de bits na forma em que o firmware os relata.  Como ent√£o transformar esse monte de arquivos .wav n√£o verificados em um arquivo de boa qualidade, como no "modo de seguran√ßa"?  Sim, a mesma ferramenta de an√°lise de erro que usamos nos rasgos com o Lite-On! <br><br>  Ap√≥s algumas defini√ß√µes de configura√ß√£o do EAC e depois de cem rasgos, obtemos um diagrama t√£o bonito. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/405/323/e9f/405323e9fad21af9069c1983e25a7025.png"><br>  <i><font color="gray">Erros corrigidos e incorrig√≠veis no n√∫mero de rasgos (Pioneer)</font></i> <br><br>  O que pode ser observado: <br><br><ul><li>  Erros de bits fatais rapidamente tendem a zero, mas nunca atingem. </li><li>  Um enorme salto em bugs corrigidos em 53-54 rasgos. </li><li>  O n√∫mero de erros antes e depois desse grande salto praticamente n√£o muda, o que indica √°reas de estabilidade nos dados copiados. </li></ul><br><h1>  0xA595BC09 </h1><br>  Usando uma corre√ß√£o de erro quase perfeita da Pioneer, gerei um arquivo de "melhor palpite" e comecei a compar√°-lo com os rasgos da Pioneer.  Como esperado, v√°rias se√ß√µes de baixa qualidade foram descobertas, que eu corrigi fazendo mais 10 rasgos: <br><br> <code>$ for RIP_ID in $(seq -w 1 100); do echo -n "rip$RIP_ID: "; cmp -l analysis-out.wav rips-cd1-pioneer/rip${RIP_ID}/*.wav | wc -l ; done | sort -rgk2 | head -n 10 <br> rip054: 2865 <br> rip099: 974 <br> rip007: 533 <br> rip037: 452 <br> rip042: 438 <br> rip035: 404 <br> rip006: 392 <br> rip059: 381 <br> rip043: 327 <br> rip014: 323</code> <br> <br>  Tamb√©m achei algo realmente interessante: v√°rios rasgos produziram <i>exatamente o</i> mesmo conte√∫do!  Lembre-se, este √© precisamente o crit√©rio para o sucesso no EAC "modo de seguran√ßa".  <code>shncat -q -e | rhash --print="%C"</code>  <code>shncat -q -e | rhash --print="%C"</code> usado para calcular a soma de verifica√ß√£o CRC32 dos dados de √°udio brutos: √© o que o EAC usa. <br><br> <code>$ for wav in rips-cd1-pioneer/*/*.wav; do shncat "$wav" -q -e | rhash --printf="%C $wav\n" - ; done | sort -k1 <br> [...] <br> 9DD05FFF rips-cd1-pioneer/rip059/rip.wav <br> 9F8D1B53 rips-cd1-pioneer/rip072/rip.wav <br> A2EA0283 rips-cd1-pioneer/rip082/rip.wav <br> A595BC09 rips-cd1-pioneer/rip021/rip.wav <br> A595BC09 rips-cd1-pioneer/rip022/rip.wav <br> A595BC09 rips-cd1-pioneer/rip023/rip.wav <br> A595BC09 rips-cd1-pioneer/rip024/rip.wav <br> A595BC09 rips-cd1-pioneer/rip025/rip.wav <br> A595BC09 rips-cd1-pioneer/rip026/rip.wav <br> A595BC09 rips-cd1-pioneer/rip027/rip.wav <br> A595BC09 rips-cd1-pioneer/rip028/rip.wav <br> A595BC09 rips-cd1-pioneer/rip030/rip.wav <br> A595BC09 rips-cd1-pioneer/rip031/rip.wav <br> A595BC09 rips-cd1-pioneer/rip040/rip.wav <br> A595BC09 rips-cd1-pioneer/rip055/rip.wav <br> A595BC09 rips-cd1-pioneer/rip058/rip.wav <br> AA3B5929 rips-cd1-pioneer/rip043/rip.wav <br> ABAAE784 rips-cd1-pioneer/rip033/rip.wav <br> [...]</code> <br> <br>  Enquanto isso, rasgos repetidos de se√ß√µes de baixa qualidade nos permitiram concluir a an√°lise com zero erro fatal.  E quando eu verifiquei este arquivo, havia exatamente o mesmo conte√∫do de √°udio que no rasgo "normal"!  Isso √© suficiente para declarar vit√≥ria. <br><br>  Tenho 99% de certeza de que copiei com √™xito este CD problem√°tico e 0xA595BC09 √© a quantidade certa de CRC para a faixa n√∫mero 3. <br><br><h1>  Ap√™ndice A: compare.rs </h1><br>  Eu usei essa ferramenta para calcular erros prov√°veis ‚Äã‚Äãde bytes.  Ele n√£o se destina ao uso a longo prazo, por isso √© um pouco feio, mas pode ser interessante para quem se deparou com esta p√°gina, resolvendo o mesmo problema. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> memmap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cmp; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::collections::HashMap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::env; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync::mpsc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::thread; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> memmap::Mmap; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHUNK_SIZE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suspect_positions</span></span></span></span>( mmaps: &amp;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt;, start_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, end_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, ) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> positions = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> start_idx..end_idx { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (_file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { byte = file_content[ii]; first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> byte != file_content[ii] { positions.push(ii); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } positions } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> args: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = env::args().collect(); args.remove(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> files: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;fs::File&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmaps: HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt; = HashMap::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> args { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = fs::File::open(&amp;filename).unwrap(); files.push(file); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { Mmap::map(files.last().unwrap()).unwrap() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; size = mmap.len(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(size == mmap.len()); } mmaps.insert(filename, mmap); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (suspects_tx, suspects_rx) = mpsc::channel(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> start_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = sync::Arc::new(mmaps); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_start_idx = start_idx; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_end_idx = cmp::min(start_idx + CHUNK_SIZE, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_idx == t_end_idx { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = mmaps_ref.clone(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects_tx = suspects_tx.clone(); thread::spawn(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects = suspect_positions(mmaps_ref.as_ref(), t_start_idx, t_end_idx); suspects_tx.send(suspects).unwrap(); }); start_idx = t_end_idx; } <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span>(suspects_tx); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects_rx { suspects.append(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk); } suspects.sort(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{{\"files\": ["</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first_file = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps_ref.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file_comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first_file { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; first_file = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}{{\"name\": \"{}\", \"suspect_bytes\": ["</span></span>, file_comma, file_name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ii, position) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects.iter().enumerate() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ii == suspects.len() - <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"[{}, {}]{}"</span></span>, position, file_content[*position], comma); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); }</code> </pre> <br>  1 <a name="1"></a>  Neste √∫nico registro AccurateRip, o CRC de todas as faixas, exceto a faixa n√∫mero 3, corresponde ao meu disco: a soma √© 0x84B9DD1A e eu tenho 0xA595BC09.  Eu suspeito que o estripador n√£o entendeu que ele tem uma m√° condu√ß√£o.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[voltar]</a> <br><br>  2) <a name="2"></a>  A pergunta √≥bvia ao comprar uma unidade de CD ou DVD em 2018 √©: "Droga, onde posso compr√°-los?"  E eu n√£o precisava de um, mas de <i>v√°rias</i> <i>marcas diferentes</i> .  Eu conhe√ßo apenas uma loja pr√≥xima que possui unidades de DVD de 5,25 "dispon√≠veis. Somente uma loja √© grande o suficiente para n√£o se arrepender do espa√ßo de prateleira para essas unidades e estranha o suficiente para n√£o parecer fora de lugar por l√°. falando sobre a Frys Electronics. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[voltar]</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418995/">https://habr.com/ru/post/pt418995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418979/index.html">Enquanto eu voava pelo pa√≠s, implementando um projeto para v√°rios milhares de empregos</a></li>
<li><a href="../pt418981/index.html">M√©todos num√©ricos para resolver equa√ß√µes el√≠pticas</a></li>
<li><a href="../pt418985/index.html">An√°lise e design como um todo</a></li>
<li><a href="../pt418987/index.html">O Firefox ignora facilmente a prote√ß√£o na nova interface do Gmail</a></li>
<li><a href="../pt418991/index.html">O microfilme existir√° por meio mil√™nio</a></li>
<li><a href="../pt418997/index.html">Contribui√ß√£o real para c√≥digo-fonte aberto real</a></li>
<li><a href="../pt418999/index.html">[An√∫ncio, Peter] Reuni√£o do JUG.ru com Andrei Belyaev e Alexei Stukalov - Troll oprime CUBA: FAQ</a></li>
<li><a href="../pt419001/index.html">5 "super habilidades" necess√°rias para o trabalho do futuro</a></li>
<li><a href="../pt419003/index.html">Resumo de not√≠cias do Blockchain</a></li>
<li><a href="../pt419005/index.html">Excurs√£o √† subesta√ß√£o 220/110/20</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>