<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶🏻 🎡 👨🏽‍🚀 Composants de Final React 🚯 🌶️ 🍫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce que j'aime dans l'écosystème React, c'est que IDEA est à l'origine de nombreuses décisions. Divers auteurs écrivent divers articles à l'appui de l'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Composants de Final React</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434830/"><p>  Ce que j'aime dans l'écosystème React, c'est que IDEA est à l'origine de nombreuses décisions.  Divers auteurs écrivent divers articles à l'appui de l'ordonnance existante et expliquent pourquoi tout est «bien», afin que tout le monde comprenne que le parti est sur la bonne voie. </p><br><p>  Après un certain temps, l'IDEA change un peu et tout recommence depuis le début. </p><br><p>  Et le début de cette histoire est la séparation des composants en conteneurs et non-conteneurs (communément appelés composants muets, désolé pour mon français). </p><br><p><img src="https://habrastorage.org/webt/p3/cl/nl/p3clnlwh5eus18t7l4xkoxgc09a.jpeg"></p><a name="habracut"></a><br><h3 id="problema">  Le problème </h3><br><p>  Le problème est très simple - les tests unitaires.  Récemment, il y a eu un certain mouvement vers les tests d'intégration - eh bien, vous savez <em>"Ecrire des tests. Pas trop. Surtout l'intégration."</em>  .  Ce n'est pas une mauvaise idée, et si le temps est court (et que les tests ne sont pas particulièrement nécessaires) - c'est ce que vous devez faire.  Appelons cela des tests de fumée - pour vérifier que rien ne <em>semble</em> exploser. </p><br><p> S'il y a beaucoup de temps et que des tests sont nécessaires, il vaut mieux ne pas suivre cette voie, car écrire de bons tests d'intégration est très, très long.  Tout simplement parce qu'ils vont grandir et grandir, et pour tester le troisième bouton à droite, vous devrez d'abord cliquer sur 3 boutons dans le menu, et n'oubliez pas de vous connecter.  En général - voici une <u>explosion combinatoire</u> sur un plateau d'argent. </p><br><p>  La solution ici est un et simple (par définition) - tests unitaires.  La possibilité de démarrer des tests avec un état prêt à l'emploi d'une partie de l'application.  Plus précisément, pour réduire (rétrécir) la zone de test de l'Application ou du <em>Big Block</em> à quelque chose de petit - une unité, quelle qu'elle soit.  Il n'est pas nécessaire d'utiliser une enzyme - vous pouvez exécuter des tests de navigateur, si l'âme le demande.  La chose la plus importante ici est de pouvoir tester quelque chose <em>isolément</em> .  Et sans trop de peine. </p><br><p>  L'isolement est l'un des points clés des tests unitaires, et c'est pourquoi les tests unitaires n'aiment pas.  Ils ne l'aiment pas pour diverses raisons: </p><br><ul><li>  par exemple, votre «unité» est arrachée à l'application et ne fonctionne pas dans sa composition même lorsque ses propres tests sont verts. </li><li>  ou par exemple parce que l'isolement est un cheval si sphérique dans le vide que personne n'a vu.  Comment y parvenir et comment le mesurer? </li></ul><br><p>  Personnellement, je ne vois aucun problème ici.  Dans le premier paragraphe, <em>bien sûr,</em> vous pouvez recommander des tests d'intégration, ils ont été inventés pour cela - pour vérifier comment les composants pré-testés sont assemblés correctement.  Vous faites confiance aux packages npm qui testent, bien sûr, uniquement eux-mêmes et non eux-mêmes dans le cadre de votre application.  En quoi vos «composants» diffèrent-ils de «pas vos» packages? </p><br><p>  Avec le deuxième paragraphe, tout est un peu plus compliqué.  Et cet article sera exactement sur ce point (et tout ce qui était auparavant - une introduction) - sur la façon de rendre une unité « <em>testable»</em> . </p><br><h3 id="razdelyay-i-vlastvuy">  Diviser et conquérir </h3><br><p>  L'idée de séparer les composants React en "Container" et "Presentation" n'est pas nouvelle, bien décrite et a déjà réussi à devenir un peu dépassée.  Si nous prenons comme base (ce que font 99% des développeurs) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article de Dan Abramov</a> , alors le volet Présentation: </p><br><ul><li>  Sont concernés par l'apparence des choses </li><li> Peut contenir à la fois des composants de présentation et de conteneur <code>**</code> intérieur, et possède généralement un balisage DOM et des styles qui lui sont propres) </li><li>  Emplacements de support (permettent souvent le confinement via this.props.children) </li><li>  Indépendant de l'application (ne dépend pas du reste de l'application, comme les actions de Flux ou les magasins) </li><li>  Ne dépend pas des données (ne spécifiez pas comment les données sont chargées ou mutées) </li><li>  L'interface est basée sur des accessoires (recevoir des données et des rappels exclusivement via des accessoires) </li><li>  Souvent apatrides (ont rarement leur propre état (quand c'est le cas, c'est l'état de l'interface utilisateur plutôt que les données)) </li><li>  Souvent SFC (sont écrits en tant que composants fonctionnels, sauf s'ils nécessitent un état, des crochets de cycle de vie ou des optimisations de performances) </li></ul><br><p>  Eh bien, les conteneurs sont toute la logique, tous les accès aux données et toute l'application en principe. </p><br><blockquote>  Dans un monde idéal, les conteneurs sont le tronc et les composants de présentation sont les feuilles. </blockquote><p>  Il y a deux points clés dans la définition de Dan: <em>"Application indépendante"</em> , qui est presque une définition académique de "unité", et * "Peut contenir à la fois d'autres composants de présentation et conteneurs <code>**</code> " *, où ces étoiles sont particulièrement intéressantes. </p><br><blockquote>  (traduction gratuite) ** Dans les premières versions de mon article, j'ai (Dan) dit que les composants de présentation ne devraient contenir que d'autres composants de présentation.  Je ne pense plus.  Le type de composant est les détails et peut changer avec le temps.  En général, ne le partagez pas et tout ira bien. </blockquote><p>  Rappelons-nous ce qui se passe après cela: </p><br><ul><li>  Dans le livre de contes, tout tombe, car une sorte de conteneur, dans le troisième bouton à gauche, se glisse dans le côté duquel il n'y en a pas.  Salutations spéciales à graphql, react-router et autres react-intl. </li><li>  La possibilité d'utiliser mount dans les tests est perdue, car elle rend tout de A à Z, et encore une fois, quelque part dans les profondeurs de l'arbre de rendu, quelqu'un fait quelque chose et les tests tombent. </li><li>  La capacité de contrôler l'état de l'application est perdue, car (au sens figuré), la capacité de mouiller les sélecteurs / résolveurs (en particulier avec proxyquire) est perdue et tout le côté doit être mouillé.  Et c'est cool pour les tests unitaires. </li></ul><br><blockquote>  Si vous pensez que les problèmes sont un peu farfelus, essayez de travailler en équipe lorsque ces conteneurs, qui seront utilisés dans vos non-conteneurs, changent dans d'autres départements, et en conséquence, vous et eux regardent les tests et vous ne pouvez pas comprendre pourquoi hier tout cela a fonctionné, et maintenant encore. </blockquote><p>  En conséquence, vous devez utiliser peu profond, ce qui, <em>par conception,</em> élimine tous les effets secondaires nocifs (et inattendus).  Voici un exemple simple de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Pourquoi j'utilise toujours peu profond»</a> </p><br><p>  Imaginez que l'infobulle affiche "?", Lorsque vous cliquez dessus, le type lui-même sera affiché. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Tooltip <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-cool-tooltip'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { &lt;Tooltip&gt; hint: {veryImportantTextYouHaveToTest} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Tooltip&gt; }</span></span></code> </pre> <br><p>  Comment le tester?  Monter + cliquer + vérifier ce qui est visible.  Il s'agit d'un test d'intégration, pas d'une unité, et la question est de savoir comment cliquer sur un composant "étranger" pour vous.  Il n'y a pas de problème avec le superficiel, car il n'y a pas de <em>cerveau</em> et la «composante extraterrestre» elle-même.  Mais il y a des cerveaux ici, car Tooltip est un conteneur, tandis que MyComponent est <em>pratiquement une</em> présentation. </p><br><pre> <code class="javascript hljs">jest.mock(<span class="hljs-string"><span class="hljs-string">'react-cool-tooltip'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">default</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{children}</span></span></span><span class="hljs-function">) =&gt;</span></span> childlren});</code> </pre> <br><p>  Mais si vous réagissez-cool-info-bulle, il n'y aura aucun problème avec les tests.  La «composante» est devenue nettement plus bête, beaucoup plus courte, beaucoup plus <em>finie</em> . </p><br><p>  <strong>Composant final</strong> </p><br><ul><li>  un composant avec une taille bien connue, qui peut comprendre d'autres composants finaux précédemment connus, ou ne pas les contenir du tout. </li><li>  ne contient pas d'autres conteneurs, car ils contiennent un état non contrôlé et "augmentent" la taille, c'est-à-dire  rendre le composant actuel <em>infini</em> . </li><li>  sinon c'est un composant de présentation régulier.  En fait, exactement comme décrit dans la <em>première</em> version de l'article de Dan. </li></ul><br><p>  Le dernier élément n'est qu'un engrenage sorti d'un grand mécanisme. </p><br><p>  Toute la question est de savoir comment l'enlever. </p><br><h3 id="reshenie-1---di">  Solution 1 - DI </h3><br><p>  Mon préféré est l'injection de dépendance.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dan l'aime aussi</a> .  En général, ce n'est pas DI, mais des "slots".  En un mot - pas besoin d'utiliser des conteneurs à l'intérieur de la présentation - ils doivent y être <em>injectés</em> .  Et dans les tests, il sera possible d'injecter autre chose. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    mount     const PageChrome = ({children, aside}) =&gt; ( &lt;section&gt; &lt;aside&gt;{aside}&lt;/aside&gt; {children} &lt;/section&gt; ); //     shallow,       //     mount ? , ,   wiring? const PageChromeContainer = () =&gt; ( &lt;PageChrome aside={&lt;ASideContainer /&gt;}&gt; &lt;Page /&gt; &lt;/PageChrome&gt; );</span></span></code> </pre> <br><p>  C'est exactement le cas lorsque <em>"les conteneurs sont le tronc et les composants de présentation sont des feuilles"</em> </p><br><h3 id="reshenie-2---granicy">  Solution 2 - Limites </h3><br><p>  DI peut souvent être cool.  Probablement maintenant% username% pense comment il peut être appliqué sur la base de code actuelle, et la solution n'est pas inventée ... </p><br><p>  Dans de tels cas, <strong>Borders</strong> vous sauvera. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Boundary = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{children}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'test'</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : children <span class="hljs-comment"><span class="hljs-comment">// //  jest.mock ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Boundary&gt;&lt;ASideContainer /&gt;&lt;/Boundary&gt;&lt;/aside&gt; &lt;Boundary&gt;&lt;Page /&gt;&lt;/Boundary&gt; &lt;/section&gt; );</span></span></code> </pre> <br><p>  Ici, au lieu de «fentes», tous les «points de transition» se transforment simplement en limites, ce qui rendra <em>tout</em> pendant les tests.  <em>De façon</em> assez <em>déclarative</em> , et exactement ce dont vous avez besoin pour "sortir l'équipement". </p><br><h3 id="reshenie-3---tier">  Solution 3 - Niveau </h3><br><p>  Les bordures peuvent être un peu grossières, et il pourrait être plus facile de les rendre un peu plus intelligentes en ajoutant un peu de connaissances sur la couche. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkTier = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tier</span></span></span><span class="hljs-function"> =&gt;</span></span> tier === currentTier; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withTier = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tier</span></span></span><span class="hljs-function"> =&gt;</span></span> WrapperComponent =&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">process.env.NODE_ENV !== </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'test'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || checkTier(tier</span></span></span><span class="hljs-function">)) &amp;&amp; &lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WrapperComponent</span></span></span><span class="hljs-function">{...</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">} /&gt; ); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PageChrome</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ASideContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Page</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASideContainer = withTier(<span class="hljs-string"><span class="hljs-string">'UI'</span></span>)(...) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Page = withTier(<span class="hljs-string"><span class="hljs-string">'Page'</span></span>)(...) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageChromeContainer = withTier(<span class="hljs-string"><span class="hljs-string">'UI'</span></span>)(PageChrome);</code> </pre> <br><p>  Sous le nom Tier / Layer, il peut y avoir différentes choses - fonctionnalité, canard, module, ou simplement cette couche / couche.  Le point n'est pas important, l'essentiel est que vous pouvez tirer l'engrenage, peut-être pas un, mais le nombre final, en tirant en <em>quelque sorte</em> une ligne entre ce dont vous avez besoin et ce dont vous n'avez pas besoin (pour différents tests, c'est une frontière différente). </p><br><p>  Et rien n'empêche de marquer ces limites différemment. </p><br><h3 id="reshenie-4separate-concerns">  Solution 4 - Préoccupations distinctes </h3><br><p>  Si la solution (par définition) réside dans la séparation des entités - que se passera-t-il si nous les prenons et les séparons? </p><br><p>  Les «conteneurs», que nous n'aimons pas tellement, sont généralement appelés <em>conteneurs</em> .  Et sinon - rien n'empêche dès maintenant de commencer à nommer les composants d'une manière plus sonore.  Ou ils ont un certain modèle dans leur nom - Connect (WrappedComonent) ou GraphQL / Query. </p><br><p>  Que se passe-t-il si au moment de l'exécution tracer une ligne entre les entités sur la base d'un nom? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageChrome = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ASideContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Page</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); <span class="hljs-comment"><span class="hljs-comment">// remove all components matching react-redux pattern reactRemock.mock(/Connect\(\w\)/) // all any other container reactRemock.mock(/Container/)</span></span></code> </pre> <br><p>  Plus une ligne dans les tests, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">react-remock</a> supprimera tous les conteneurs susceptibles d'interférer avec les tests. </p><br><p>  En principe, cette approche peut être utilisée pour tester les conteneurs eux-mêmes - il vous suffit <em>de supprimer</em> tout sauf le premier conteneur. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {createElement, remock} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-remock'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  "" const ContainerCondition = React.createContext(true); reactRemock.mock(/Connect\(\w\)/, (type, props, children) =&gt; ( &lt;ContainerCondition.Consumer&gt; { opened =&gt; ( opened ? ( // ""     &lt;ContainerCondition.Provider value={false}&gt; {createElement(type, props, ...children)} &lt;ContainerCondition.Provider&gt; ) // "" : null )} &lt;/ContainerCondition.Consumer&gt; )</span></span></code> </pre> <br><p>  Encore une fois - quelques lignes et équipement enlevés. </p><br><h2 id="itogo">  Total </h2><br><p>  Au cours de la dernière année, le test des composants React est devenu plus compliqué, en particulier pour le montage - vous devez écraser les 10 fournisseurs et contextes, et il devient de plus en plus difficile de tester le bon composant dans le bon style - il y a trop de cordes à tirer. <br>  Quelqu'un crache et entre dans le monde peu profond.  Quelqu'un a agité la main lors des tests unitaires et a tout transféré à Cypress (marche comme marche!). </p><br><p>  Quelqu'un d'autre pointe du doigt la réaction, dit que ce sont <em>des effets algébriques</em> et que vous pouvez faire ce que vous voulez.  Tous les exemples ci-dessus sont essentiellement l'utilisation de ces <em>effets</em> et simulations <em>algébriques</em> .  Pour moi et DI, ce sont des moki. </p><br><blockquote>  PS: Ce message a été écrit en réponse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aux commentaires dans React / RFC sur le fait que l'équipe React a tout cassé, et tous les polymères là-bas aussi</a> <br>  PPS: Ce message est en fait une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction très gratuite d'un autre</a> <br>  PPPS: en général, pour un véritable isolement, regardez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rewiremock</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434830/">https://habr.com/ru/post/fr434830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434818/index.html">Un accident au centre de données CenturyLink a causé des pannes de service au 911</a></li>
<li><a href="../fr434822/index.html">Programme PRC "Voitures avec de nouvelles sources d'énergie". À quoi s'attendre en 2019</a></li>
<li><a href="../fr434824/index.html">Génie politico-électrique. Modélisation des processus socio-politiques par des circuits électriques</a></li>
<li><a href="../fr434826/index.html">Le champ de lit à l'heure, ou 5 signes de problèmes cachés dans l'équipe</a></li>
<li><a href="../fr434828/index.html">Devenez un professionnel. Habitudes utiles des concepteurs UX</a></li>
<li><a href="../fr434836/index.html">Annotation de Wonderful Version dans JPA</a></li>
<li><a href="../fr434838/index.html">Création d'un bot pour participer à la Russian AI Cup 2018 CodeBall</a></li>
<li><a href="../fr434840/index.html">Comment ai-je réalisé "Your Diary" - ou la situation sur le marché des agendas électroniques</a></li>
<li><a href="../fr434842/index.html">Les fermes urbaines peuvent être extrêmement efficaces, mais pas pour le moment</a></li>
<li><a href="../fr434844/index.html">Récupération des capacités cognitives de 100 patients (traduction d'un article de Dale Bredesen)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>