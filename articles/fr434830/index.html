<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¶ğŸ» ğŸ¡ ğŸ‘¨ğŸ½â€ğŸš€ Composants de Final React ğŸš¯ ğŸŒ¶ï¸ ğŸ«</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce que j'aime dans l'Ã©cosystÃ¨me React, c'est que IDEA est Ã  l'origine de nombreuses dÃ©cisions. Divers auteurs Ã©crivent divers articles Ã  l'appui de l'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Composants de Final React</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434830/"><p>  Ce que j'aime dans l'Ã©cosystÃ¨me React, c'est que IDEA est Ã  l'origine de nombreuses dÃ©cisions.  Divers auteurs Ã©crivent divers articles Ã  l'appui de l'ordonnance existante et expliquent pourquoi tout est Â«bienÂ», afin que tout le monde comprenne que le parti est sur la bonne voie. </p><br><p>  AprÃ¨s un certain temps, l'IDEA change un peu et tout recommence depuis le dÃ©but. </p><br><p>  Et le dÃ©but de cette histoire est la sÃ©paration des composants en conteneurs et non-conteneurs (communÃ©ment appelÃ©s composants muets, dÃ©solÃ© pour mon franÃ§ais). </p><br><p><img src="https://habrastorage.org/webt/p3/cl/nl/p3clnlwh5eus18t7l4xkoxgc09a.jpeg"></p><a name="habracut"></a><br><h3 id="problema">  Le problÃ¨me </h3><br><p>  Le problÃ¨me est trÃ¨s simple - les tests unitaires.  RÃ©cemment, il y a eu un certain mouvement vers les tests d'intÃ©gration - eh bien, vous savez <em>"Ecrire des tests. Pas trop. Surtout l'intÃ©gration."</em>  .  Ce n'est pas une mauvaise idÃ©e, et si le temps est court (et que les tests ne sont pas particuliÃ¨rement nÃ©cessaires) - c'est ce que vous devez faire.  Appelons cela des tests de fumÃ©e - pour vÃ©rifier que rien ne <em>semble</em> exploser. </p><br><p> S'il y a beaucoup de temps et que des tests sont nÃ©cessaires, il vaut mieux ne pas suivre cette voie, car Ã©crire de bons tests d'intÃ©gration est trÃ¨s, trÃ¨s long.  Tout simplement parce qu'ils vont grandir et grandir, et pour tester le troisiÃ¨me bouton Ã  droite, vous devrez d'abord cliquer sur 3 boutons dans le menu, et n'oubliez pas de vous connecter.  En gÃ©nÃ©ral - voici une <u>explosion combinatoire</u> sur un plateau d'argent. </p><br><p>  La solution ici est un et simple (par dÃ©finition) - tests unitaires.  La possibilitÃ© de dÃ©marrer des tests avec un Ã©tat prÃªt Ã  l'emploi d'une partie de l'application.  Plus prÃ©cisÃ©ment, pour rÃ©duire (rÃ©trÃ©cir) la zone de test de l'Application ou du <em>Big Block</em> Ã  quelque chose de petit - une unitÃ©, quelle qu'elle soit.  Il n'est pas nÃ©cessaire d'utiliser une enzyme - vous pouvez exÃ©cuter des tests de navigateur, si l'Ã¢me le demande.  La chose la plus importante ici est de pouvoir tester quelque chose <em>isolÃ©ment</em> .  Et sans trop de peine. </p><br><p>  L'isolement est l'un des points clÃ©s des tests unitaires, et c'est pourquoi les tests unitaires n'aiment pas.  Ils ne l'aiment pas pour diverses raisons: </p><br><ul><li>  par exemple, votre Â«unitÃ©Â» est arrachÃ©e Ã  l'application et ne fonctionne pas dans sa composition mÃªme lorsque ses propres tests sont verts. </li><li>  ou par exemple parce que l'isolement est un cheval si sphÃ©rique dans le vide que personne n'a vu.  Comment y parvenir et comment le mesurer? </li></ul><br><p>  Personnellement, je ne vois aucun problÃ¨me ici.  Dans le premier paragraphe, <em>bien sÃ»r,</em> vous pouvez recommander des tests d'intÃ©gration, ils ont Ã©tÃ© inventÃ©s pour cela - pour vÃ©rifier comment les composants prÃ©-testÃ©s sont assemblÃ©s correctement.  Vous faites confiance aux packages npm qui testent, bien sÃ»r, uniquement eux-mÃªmes et non eux-mÃªmes dans le cadre de votre application.  En quoi vos Â«composantsÂ» diffÃ¨rent-ils de Â«pas vosÂ» packages? </p><br><p>  Avec le deuxiÃ¨me paragraphe, tout est un peu plus compliquÃ©.  Et cet article sera exactement sur ce point (et tout ce qui Ã©tait auparavant - une introduction) - sur la faÃ§on de rendre une unitÃ© Â« <em>testableÂ»</em> . </p><br><h3 id="razdelyay-i-vlastvuy">  Diviser et conquÃ©rir </h3><br><p>  L'idÃ©e de sÃ©parer les composants React en "Container" et "Presentation" n'est pas nouvelle, bien dÃ©crite et a dÃ©jÃ  rÃ©ussi Ã  devenir un peu dÃ©passÃ©e.  Si nous prenons comme base (ce que font 99% des dÃ©veloppeurs) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article de Dan Abramov</a> , alors le volet PrÃ©sentation: </p><br><ul><li>  Sont concernÃ©s par l'apparence des choses </li><li> Peut contenir Ã  la fois des composants de prÃ©sentation et de conteneur <code>**</code> intÃ©rieur, et possÃ¨de gÃ©nÃ©ralement un balisage DOM et des styles qui lui sont propres) </li><li>  Emplacements de support (permettent souvent le confinement via this.props.children) </li><li>  IndÃ©pendant de l'application (ne dÃ©pend pas du reste de l'application, comme les actions de Flux ou les magasins) </li><li>  Ne dÃ©pend pas des donnÃ©es (ne spÃ©cifiez pas comment les donnÃ©es sont chargÃ©es ou mutÃ©es) </li><li>  L'interface est basÃ©e sur des accessoires (recevoir des donnÃ©es et des rappels exclusivement via des accessoires) </li><li>  Souvent apatrides (ont rarement leur propre Ã©tat (quand c'est le cas, c'est l'Ã©tat de l'interface utilisateur plutÃ´t que les donnÃ©es)) </li><li>  Souvent SFC (sont Ã©crits en tant que composants fonctionnels, sauf s'ils nÃ©cessitent un Ã©tat, des crochets de cycle de vie ou des optimisations de performances) </li></ul><br><p>  Eh bien, les conteneurs sont toute la logique, tous les accÃ¨s aux donnÃ©es et toute l'application en principe. </p><br><blockquote>  Dans un monde idÃ©al, les conteneurs sont le tronc et les composants de prÃ©sentation sont les feuilles. </blockquote><p>  Il y a deux points clÃ©s dans la dÃ©finition de Dan: <em>"Application indÃ©pendante"</em> , qui est presque une dÃ©finition acadÃ©mique de "unitÃ©", et * "Peut contenir Ã  la fois d'autres composants de prÃ©sentation et conteneurs <code>**</code> " *, oÃ¹ ces Ã©toiles sont particuliÃ¨rement intÃ©ressantes. </p><br><blockquote>  (traduction gratuite) ** Dans les premiÃ¨res versions de mon article, j'ai (Dan) dit que les composants de prÃ©sentation ne devraient contenir que d'autres composants de prÃ©sentation.  Je ne pense plus.  Le type de composant est les dÃ©tails et peut changer avec le temps.  En gÃ©nÃ©ral, ne le partagez pas et tout ira bien. </blockquote><p>  Rappelons-nous ce qui se passe aprÃ¨s cela: </p><br><ul><li>  Dans le livre de contes, tout tombe, car une sorte de conteneur, dans le troisiÃ¨me bouton Ã  gauche, se glisse dans le cÃ´tÃ© duquel il n'y en a pas.  Salutations spÃ©ciales Ã  graphql, react-router et autres react-intl. </li><li>  La possibilitÃ© d'utiliser mount dans les tests est perdue, car elle rend tout de A Ã  Z, et encore une fois, quelque part dans les profondeurs de l'arbre de rendu, quelqu'un fait quelque chose et les tests tombent. </li><li>  La capacitÃ© de contrÃ´ler l'Ã©tat de l'application est perdue, car (au sens figurÃ©), la capacitÃ© de mouiller les sÃ©lecteurs / rÃ©solveurs (en particulier avec proxyquire) est perdue et tout le cÃ´tÃ© doit Ãªtre mouillÃ©.  Et c'est cool pour les tests unitaires. </li></ul><br><blockquote>  Si vous pensez que les problÃ¨mes sont un peu farfelus, essayez de travailler en Ã©quipe lorsque ces conteneurs, qui seront utilisÃ©s dans vos non-conteneurs, changent dans d'autres dÃ©partements, et en consÃ©quence, vous et eux regardent les tests et vous ne pouvez pas comprendre pourquoi hier tout cela a fonctionnÃ©, et maintenant encore. </blockquote><p>  En consÃ©quence, vous devez utiliser peu profond, ce qui, <em>par conception,</em> Ã©limine tous les effets secondaires nocifs (et inattendus).  Voici un exemple simple de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Â«Pourquoi j'utilise toujours peu profondÂ»</a> </p><br><p>  Imaginez que l'infobulle affiche "?", Lorsque vous cliquez dessus, le type lui-mÃªme sera affichÃ©. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Tooltip <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-cool-tooltip'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { &lt;Tooltip&gt; hint: {veryImportantTextYouHaveToTest} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Tooltip&gt; }</span></span></code> </pre> <br><p>  Comment le tester?  Monter + cliquer + vÃ©rifier ce qui est visible.  Il s'agit d'un test d'intÃ©gration, pas d'une unitÃ©, et la question est de savoir comment cliquer sur un composant "Ã©tranger" pour vous.  Il n'y a pas de problÃ¨me avec le superficiel, car il n'y a pas de <em>cerveau</em> et la Â«composante extraterrestreÂ» elle-mÃªme.  Mais il y a des cerveaux ici, car Tooltip est un conteneur, tandis que MyComponent est <em>pratiquement une</em> prÃ©sentation. </p><br><pre> <code class="javascript hljs">jest.mock(<span class="hljs-string"><span class="hljs-string">'react-cool-tooltip'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">default</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{children}</span></span></span><span class="hljs-function">) =&gt;</span></span> childlren});</code> </pre> <br><p>  Mais si vous rÃ©agissez-cool-info-bulle, il n'y aura aucun problÃ¨me avec les tests.  La Â«composanteÂ» est devenue nettement plus bÃªte, beaucoup plus courte, beaucoup plus <em>finie</em> . </p><br><p>  <strong>Composant final</strong> </p><br><ul><li>  un composant avec une taille bien connue, qui peut comprendre d'autres composants finaux prÃ©cÃ©demment connus, ou ne pas les contenir du tout. </li><li>  ne contient pas d'autres conteneurs, car ils contiennent un Ã©tat non contrÃ´lÃ© et "augmentent" la taille, c'est-Ã -dire  rendre le composant actuel <em>infini</em> . </li><li>  sinon c'est un composant de prÃ©sentation rÃ©gulier.  En fait, exactement comme dÃ©crit dans la <em>premiÃ¨re</em> version de l'article de Dan. </li></ul><br><p>  Le dernier Ã©lÃ©ment n'est qu'un engrenage sorti d'un grand mÃ©canisme. </p><br><p>  Toute la question est de savoir comment l'enlever. </p><br><h3 id="reshenie-1---di">  Solution 1 - DI </h3><br><p>  Mon prÃ©fÃ©rÃ© est l'injection de dÃ©pendance.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dan l'aime aussi</a> .  En gÃ©nÃ©ral, ce n'est pas DI, mais des "slots".  En un mot - pas besoin d'utiliser des conteneurs Ã  l'intÃ©rieur de la prÃ©sentation - ils doivent y Ãªtre <em>injectÃ©s</em> .  Et dans les tests, il sera possible d'injecter autre chose. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    mount     const PageChrome = ({children, aside}) =&gt; ( &lt;section&gt; &lt;aside&gt;{aside}&lt;/aside&gt; {children} &lt;/section&gt; ); //     shallow,       //     mount ? , ,   wiring? const PageChromeContainer = () =&gt; ( &lt;PageChrome aside={&lt;ASideContainer /&gt;}&gt; &lt;Page /&gt; &lt;/PageChrome&gt; );</span></span></code> </pre> <br><p>  C'est exactement le cas lorsque <em>"les conteneurs sont le tronc et les composants de prÃ©sentation sont des feuilles"</em> </p><br><h3 id="reshenie-2---granicy">  Solution 2 - Limites </h3><br><p>  DI peut souvent Ãªtre cool.  Probablement maintenant% username% pense comment il peut Ãªtre appliquÃ© sur la base de code actuelle, et la solution n'est pas inventÃ©e ... </p><br><p>  Dans de tels cas, <strong>Borders</strong> vous sauvera. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Boundary = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{children}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'test'</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : children <span class="hljs-comment"><span class="hljs-comment">// //  jest.mock ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Boundary&gt;&lt;ASideContainer /&gt;&lt;/Boundary&gt;&lt;/aside&gt; &lt;Boundary&gt;&lt;Page /&gt;&lt;/Boundary&gt; &lt;/section&gt; );</span></span></code> </pre> <br><p>  Ici, au lieu de Â«fentesÂ», tous les Â«points de transitionÂ» se transforment simplement en limites, ce qui rendra <em>tout</em> pendant les tests.  <em>De faÃ§on</em> assez <em>dÃ©clarative</em> , et exactement ce dont vous avez besoin pour "sortir l'Ã©quipement". </p><br><h3 id="reshenie-3---tier">  Solution 3 - Niveau </h3><br><p>  Les bordures peuvent Ãªtre un peu grossiÃ¨res, et il pourrait Ãªtre plus facile de les rendre un peu plus intelligentes en ajoutant un peu de connaissances sur la couche. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkTier = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tier</span></span></span><span class="hljs-function"> =&gt;</span></span> tier === currentTier; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withTier = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tier</span></span></span><span class="hljs-function"> =&gt;</span></span> WrapperComponent =&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">process.env.NODE_ENV !== </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'test'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || checkTier(tier</span></span></span><span class="hljs-function">)) &amp;&amp; &lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WrapperComponent</span></span></span><span class="hljs-function">{...</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">} /&gt; ); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PageChrome</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ASideContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Page</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASideContainer = withTier(<span class="hljs-string"><span class="hljs-string">'UI'</span></span>)(...) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Page = withTier(<span class="hljs-string"><span class="hljs-string">'Page'</span></span>)(...) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageChromeContainer = withTier(<span class="hljs-string"><span class="hljs-string">'UI'</span></span>)(PageChrome);</code> </pre> <br><p>  Sous le nom Tier / Layer, il peut y avoir diffÃ©rentes choses - fonctionnalitÃ©, canard, module, ou simplement cette couche / couche.  Le point n'est pas important, l'essentiel est que vous pouvez tirer l'engrenage, peut-Ãªtre pas un, mais le nombre final, en tirant en <em>quelque sorte</em> une ligne entre ce dont vous avez besoin et ce dont vous n'avez pas besoin (pour diffÃ©rents tests, c'est une frontiÃ¨re diffÃ©rente). </p><br><p>  Et rien n'empÃªche de marquer ces limites diffÃ©remment. </p><br><h3 id="reshenie-4separate-concerns">  Solution 4 - PrÃ©occupations distinctes </h3><br><p>  Si la solution (par dÃ©finition) rÃ©side dans la sÃ©paration des entitÃ©s - que se passera-t-il si nous les prenons et les sÃ©parons? </p><br><p>  Les Â«conteneursÂ», que nous n'aimons pas tellement, sont gÃ©nÃ©ralement appelÃ©s <em>conteneurs</em> .  Et sinon - rien n'empÃªche dÃ¨s maintenant de commencer Ã  nommer les composants d'une maniÃ¨re plus sonore.  Ou ils ont un certain modÃ¨le dans leur nom - Connect (WrappedComonent) ou GraphQL / Query. </p><br><p>  Que se passe-t-il si au moment de l'exÃ©cution tracer une ligne entre les entitÃ©s sur la base d'un nom? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageChrome = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ASideContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Page</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); <span class="hljs-comment"><span class="hljs-comment">// remove all components matching react-redux pattern reactRemock.mock(/Connect\(\w\)/) // all any other container reactRemock.mock(/Container/)</span></span></code> </pre> <br><p>  Plus une ligne dans les tests, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">react-remock</a> supprimera tous les conteneurs susceptibles d'interfÃ©rer avec les tests. </p><br><p>  En principe, cette approche peut Ãªtre utilisÃ©e pour tester les conteneurs eux-mÃªmes - il vous suffit <em>de supprimer</em> tout sauf le premier conteneur. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {createElement, remock} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-remock'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  "" const ContainerCondition = React.createContext(true); reactRemock.mock(/Connect\(\w\)/, (type, props, children) =&gt; ( &lt;ContainerCondition.Consumer&gt; { opened =&gt; ( opened ? ( // ""     &lt;ContainerCondition.Provider value={false}&gt; {createElement(type, props, ...children)} &lt;ContainerCondition.Provider&gt; ) // "" : null )} &lt;/ContainerCondition.Consumer&gt; )</span></span></code> </pre> <br><p>  Encore une fois - quelques lignes et Ã©quipement enlevÃ©s. </p><br><h2 id="itogo">  Total </h2><br><p>  Au cours de la derniÃ¨re annÃ©e, le test des composants React est devenu plus compliquÃ©, en particulier pour le montage - vous devez Ã©craser les 10 fournisseurs et contextes, et il devient de plus en plus difficile de tester le bon composant dans le bon style - il y a trop de cordes Ã  tirer. <br>  Quelqu'un crache et entre dans le monde peu profond.  Quelqu'un a agitÃ© la main lors des tests unitaires et a tout transfÃ©rÃ© Ã  Cypress (marche comme marche!). </p><br><p>  Quelqu'un d'autre pointe du doigt la rÃ©action, dit que ce sont <em>des effets algÃ©briques</em> et que vous pouvez faire ce que vous voulez.  Tous les exemples ci-dessus sont essentiellement l'utilisation de ces <em>effets</em> et simulations <em>algÃ©briques</em> .  Pour moi et DI, ce sont des moki. </p><br><blockquote>  PS: Ce message a Ã©tÃ© Ã©crit en rÃ©ponse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aux commentaires dans React / RFC sur le fait que l'Ã©quipe React a tout cassÃ©, et tous les polymÃ¨res lÃ -bas aussi</a> <br>  PPS: Ce message est en fait une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction trÃ¨s gratuite d'un autre</a> <br>  PPPS: en gÃ©nÃ©ral, pour un vÃ©ritable isolement, regardez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rewiremock</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434830/">https://habr.com/ru/post/fr434830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434818/index.html">Un accident au centre de donnÃ©es CenturyLink a causÃ© des pannes de service au 911</a></li>
<li><a href="../fr434822/index.html">Programme PRC "Voitures avec de nouvelles sources d'Ã©nergie". Ã€ quoi s'attendre en 2019</a></li>
<li><a href="../fr434824/index.html">GÃ©nie politico-Ã©lectrique. ModÃ©lisation des processus socio-politiques par des circuits Ã©lectriques</a></li>
<li><a href="../fr434826/index.html">Le champ de lit Ã  l'heure, ou 5 signes de problÃ¨mes cachÃ©s dans l'Ã©quipe</a></li>
<li><a href="../fr434828/index.html">Devenez un professionnel. Habitudes utiles des concepteurs UX</a></li>
<li><a href="../fr434836/index.html">Annotation de Wonderful Version dans JPA</a></li>
<li><a href="../fr434838/index.html">CrÃ©ation d'un bot pour participer Ã  la Russian AI Cup 2018 CodeBall</a></li>
<li><a href="../fr434840/index.html">Comment ai-je rÃ©alisÃ© "Your Diary" - ou la situation sur le marchÃ© des agendas Ã©lectroniques</a></li>
<li><a href="../fr434842/index.html">Les fermes urbaines peuvent Ãªtre extrÃªmement efficaces, mais pas pour le moment</a></li>
<li><a href="../fr434844/index.html">RÃ©cupÃ©ration des capacitÃ©s cognitives de 100 patients (traduction d'un article de Dale Bredesen)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>