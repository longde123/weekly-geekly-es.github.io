<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♈️ 👨🏿‍🏭 🎂 Golang et l'évolution de l'interaction des bases de données 📿 👩 😣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je veux résumer les problèmes de travail avec des bases de données exécutant golang. Lors de la résolution de problèmes simples, ces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang et l'évolution de l'interaction des bases de données</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445908/"><p> Dans cet article, je veux résumer les problèmes de travail avec des bases de données exécutant golang.  Lors de la résolution de problèmes simples, ces problèmes ne sont généralement pas visibles.  À mesure que le projet se développe, le problème augmente également.  Le plus d'actualité: </p><br><ul><li>  Diminution de la connectivité d'une application de base de données </li><li>  Journalisation des requêtes en mode débogage </li><li>  Travailler avec des répliques </li></ul><br><p>  L'article est basé sur le package github.com/adverax/echo/database/sql.  La sémantique de l'utilisation de ce package est aussi proche que possible du package standard de base de données / sql, donc je ne pense pas que quiconque aura des problèmes à l'utiliser. </p><a name="habracut"></a><br><h1 id="oblast-vidimosti">  Portée </h1><br><p>  En règle générale, les grands systèmes essaient de se connecter de manière lâche avec une zone de responsabilité claire pour chaque composant du système.  Par conséquent, les modèles de conception éditeur / abonné sont largement pratiqués.  Prenons un petit exemple d'enregistrement d'un nouvel utilisateur dans le système. </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Id <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Language <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Manager <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB OnSignup <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span> { id, err = m.insert(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } user.Id = id err = m.OnSignup(m.DB, user) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { res, err := m.DB.Exec(<span class="hljs-string"><span class="hljs-string">"INSERT ..."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } id, err := res.LastInsertId() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id, err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { manager := &amp;Manager{ <span class="hljs-comment"><span class="hljs-comment">// ... OnSignup: func(db *sql.DB, user *User) error { }, } err := manager.Signup(&amp;User{...}) if err != nil { panic(err) } }</span></span></code> </pre> <br><p>  Dans cet exemple, nous nous intéressons principalement à l'événement OnSignup.  Pour simplifier, le gestionnaire est représenté par une seule fonction (dans la vie réelle, tout est plus compliqué).  Dans la signature de l'événement, nous prescrivons de manière rigide le type du premier paramètre, ce qui a généralement des conséquences de grande portée. <br>  Supposons que maintenant nous voulons étendre les fonctionnalités de notre application et en cas d'enregistrement réussi de l'utilisateur, envoyer un message à son compte personnel.  Idéalement, le message doit être placé dans la même transaction que l'enregistrement de l'utilisateur. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Manager <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB OnSignup <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *sql.Tx, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { tx, err := m.DB.Begin() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> tx.Rollback() id, err := m.insert(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } user.Id = id err = m.OnSignup(tx, id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tx.Commit() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { manager := &amp;Manager{ <span class="hljs-comment"><span class="hljs-comment">// ... OnSignup: func(db *sql.Tx, user *User) error { }, } err := manager.Signup(&amp;User{...}) if err != nil { panic(err) } }</span></span></code> </pre> <br><p>  Comme vous pouvez le voir sur l'exemple, nous avons été obligés de changer la signature de l'événement.  Cette solution n'est pas propre et implique que les gestionnaires ont connaissance du contexte de l'exécution de la requête de base de données.  Une solution beaucoup plus propre consisterait à utiliser une base de données générique et une interface de transaction - portée. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/adverax/echo/database/sql"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Manager <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB sql.DB OnSignup <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope sql.Scope, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { tx, err := m.DB.Begin() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> tx.Rollback() id, err := m.insert(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } err = m.OnSignup(tx, id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tx.Commit() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { manager := &amp;Manager{ <span class="hljs-comment"><span class="hljs-comment">// ... OnSignup: func(scope sql.Scope, user *User) error { }, } err := manager.Signup(&amp;User{...}) if err != nil { panic(err) } }</span></span></code> </pre> <br><p>  Pour implémenter cette approche, nous aurons besoin de la prise en charge des transactions imbriquées, car le gestionnaire, à son tour, peut utiliser les transactions.  Heureusement, ce n'est pas un problème, car la plupart des SGBD prennent en charge le mécanisme SAVEPOINT. </p><br><h1 id="baza-dannyh-i-kontekst">  Base de données et contexte </h1><br><p>  Dans la pratique normale, la connexion à la base de données n'est pas transmise en tant que paramètre, comme indiqué ci-dessus, et chaque gestionnaire conserve un lien vers la connexion à la base de données.  Cela simplifie les signatures de méthode et améliore la lisibilité du code.  Dans notre cas, il est impossible d'éviter cela, car vous devez transférer un lien vers la transaction. <br>  Une solution assez élégante consiste à placer le lien vers la transaction (portée) dans le contexte, car le contexte est positionné comme un paramètre d'intercommunication.  Ensuite, nous pouvons simplifier davantage notre code: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/adverax/echo/database/sql"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Manager <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { sql.Repository OnSignup <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.Transaction( ctx, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, scope sql.Scope)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { id, err := m.insert(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } user.Id = id <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.OnSignup(ctx, user) }, ) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Messenger <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { sql.Repository } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messenger *Messenger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSignupUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, user *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := messenger.Scope(ctx).Exec(<span class="hljs-string"><span class="hljs-string">"INSERT ..."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db := ... messenger := &amp;Messenger{ Repository: sql.NewRepository(db), } manager := &amp;Manager{ Repository: sql.NewRepository(db), OnSignup: messenger.onSignup, } err := manager.Signup(&amp;User{...}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } }</code> </pre> <br><p>  Cet exemple montre que nous avons maintenu l'isolement complet des managers, augmenté la lisibilité du code et réalisé leur travail commun dans un seul périmètre. </p><br><h1 id="podderzhka-replikaciy">  Prise en charge de la réplication </h1><br><p>  La bibliothèque prend également en charge l'utilisation de la réplication.  Toutes les demandes de type Exec sont envoyées au maître.  Les demandes de type esclave sont transférées vers un esclave sélectionné au hasard.  Pour prendre en charge la réplication, spécifiez simplement plusieurs sources de données: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { dsc := &amp;sql.DSC{ Driver: <span class="hljs-string"><span class="hljs-string">"mysql"</span></span>, DSN: []*sql.DSN{ { Host: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, Database: <span class="hljs-string"><span class="hljs-string">"echo"</span></span>, Username: <span class="hljs-string"><span class="hljs-string">"root"</span></span>, Password: <span class="hljs-string"><span class="hljs-string">"password"</span></span>, }, { Host: <span class="hljs-string"><span class="hljs-string">"192.168.44.01"</span></span>, Database: <span class="hljs-string"><span class="hljs-string">"echo"</span></span>, Username: <span class="hljs-string"><span class="hljs-string">"root"</span></span>, Password: <span class="hljs-string"><span class="hljs-string">"password"</span></span>, }, }, } db := dsc.Open(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> db.Close() ... }</code> </pre> <br><p>  Si vous utilisez une seule source de données lors de l'ouverture d'une base de données, elle sera ouverte en mode normal sans surcharge supplémentaire. </p><br><h1 id="metriki">  Mesures </h1><br><p>  Comme vous le savez, les mesures sont bon marché et les journaux sont chers.  Par conséquent, il a été décidé d'ajouter la prise en charge des mesures par défaut. </p><br><h1 id="profilirovanie-i-loggirovanie-zaprosov">  Profilage et journalisation des requêtes </h1><br><p>  Il est très nécessaire de consigner les requêtes de base de données pendant le débogage.  Cependant, je n'ai pas vu un mécanisme de journalisation de haute qualité avec zéro frais généraux en production.  La bibliothèque vous permet de résoudre élégamment ce problème en encapsulant la base de données.  Pour profiler la base de données, il suffit de lui passer l'activateur approprié: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openDatabase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dsc sql.DSC, debug </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sql.DB, error)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> debug { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dsc.Open(sql.OpenWithProfiler(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dsc.Open(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { dsc := ... db, err := openDatabase(dsc, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> db.Close() ... }</code> </pre> <br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Le package proposé vous permet d'étendre les possibilités d'interaction avec la base de données, tout en cachant des détails inutiles.  Cela vous permet d'améliorer la qualité du code, le laissant vaguement connecté et transparent, malgré la complexité croissante de l'application. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445908/">https://habr.com/ru/post/fr445908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445896/index.html">Pourquoi les scanners 3D économiques ne conviennent pas aux tâches professionnelles</a></li>
<li><a href="../fr445898/index.html">À propos de nouvelles idées, de vues étroites et du bouche à oreille</a></li>
<li><a href="../fr445900/index.html">Comment résister à des charges système accrues: parlez de préparations à grande échelle pour le Black Friday</a></li>
<li><a href="../fr445904/index.html">Types d'infinis et de tronc cérébral</a></li>
<li><a href="../fr445906/index.html">Ne mangez pas d'aspirine</a></li>
<li><a href="../fr445910/index.html">Comment nous sommes devenus amis avec EF 6 MSSQL et PostgresSQL</a></li>
<li><a href="../fr445912/index.html">Salut, Habr, nous sommes Advantech</a></li>
<li><a href="../fr445914/index.html">Docker est-il un jouet ou non? Ou est-ce vraiment le cas?</a></li>
<li><a href="../fr445918/index.html">20 ans de RollerCoaster Tycoon: une interview avec le créateur du jeu</a></li>
<li><a href="../fr445920/index.html">En direct: comment freiner le développement iOS dans de grandes équipes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>