<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ¢Ô∏è üï¥üèª üçè Entwerfen einer eingebetteten Anwendungsarchitektur ü•ù üçç üíáüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag! Ich m√∂chte √ºber die Architektur eingebetteter Anwendungen sprechen. Leider gibt es nur sehr wenige B√ºcher zu diesem Thema, und da in letzte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwerfen einer eingebetteten Anwendungsarchitektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419717/"><img src="https://habrastorage.org/webt/se/ih/lo/seihlokwvk9vibfz3mkosad4s0s.jpeg"><br><br>  Guten Tag!  Ich m√∂chte √ºber die Architektur eingebetteter Anwendungen sprechen.  Leider gibt es nur sehr wenige B√ºcher zu diesem Thema, und da in letzter Zeit das Interesse an Embedded und IoT zunimmt, m√∂chte ich diesem Thema Aufmerksamkeit schenken.  In diesem Artikel m√∂chte ich eine der m√∂glichen Optionen f√ºr das Design solcher Anwendungen beschreiben. <br><a name="habracut"></a><br>  Dies ist eine umstrittene Frage!  Deshalb bieten sie an, ihre Vision in den Kommentaren zu teilen! <br>  Zun√§chst werden wir den Bereich bestimmen: Im Rahmen dieses Artikels meinen wir unter eingebetteter Entwicklung Softwareentwicklung f√ºr Mikrocontroller (im Folgenden MK, zum Beispiel STM32) in der Sprache C / Asm. <br>  Projekte f√ºr MK-basierte Systeme k√∂nnen bedingt in Projekte unterteilt werden <b>, die kein</b> Multitasking <b>erfordern</b> und <b>erfordern</b> .  Die L√∂sungen des ersten Typs sind normalerweise nicht sehr komplex (aus struktureller Sicht).  Beispielsweise erfordert ein einfaches Projekt, bei dem Daten vom Sensor gelesen und auf dem Bildschirm angezeigt werden m√ºssen, kein Multitasking. Es reicht aus, die sequentielle Ausf√ºhrung der oben genannten Operationen zu implementieren. <br><br><img src="https://habrastorage.org/webt/ds/cg/nk/dscgnkhungdn4r6lo0lknunuwr8.png"><br><br>  Wenn die Anwendung komplexer ist: In diesem Rahmen m√ºssen Daten sowohl von digitalen als auch von analogen Sensoren gelesen werden. Speichern Sie die erhaltenen Werte im Speicher (z. B. auf einer SD-Karte), pflegen Sie die Benutzeroberfl√§che (Display + Tastatur) und erm√∂glichen Sie den Zugriff auf Daten √ºber eine digitale Schnittstelle (z. B. RS-485 / Modbus oder Ethernet / TCP / IP) und reagieren so schnell wie m√∂glich auf bestimmte Ereignisse im System (Dr√ºcken von Notruftasten usw.). In diesem Fall ist es schwierig, auf Multitasking zu verzichten.  Es gibt zwei M√∂glichkeiten, um das Multitasking-Problem zu l√∂sen: Sie k√∂nnen es selbst implementieren oder ein Betriebssystem verwenden (im Folgenden als Betriebssystem bezeichnet).  Heute ist FreeRTOS eines der beliebtesten Echtzeitbetriebssysteme f√ºr eingebettete Systeme. <br><br>  Stellen wir uns vor, wie die Architektur einer ‚Äûkomplexen‚Äú eingebetteten Anwendung aussehen soll, die eine relativ gro√üe Anzahl heterogener Vorg√§nge ausf√ºhrt.  Ich gebe zu, dass es m√∂glich ist, eine noch kompliziertere Option vorzuschlagen, bei der Probleme der Tonverarbeitung, Kryptographie usw. gel√∂st werden, aber wir werden uns mit der oben beschriebenen Option befassen. <br><br>  Wir setzen die Aufgabe klarer, auch wenn es im Rahmen unserer Anwendung notwendig ist: <br><br><ul><li>  Lesen Sie Daten von Sensoren am RS-485 / Modbus. </li><li>  Lesen Sie Daten von Sensoren am I2C-Bus. </li><li>  Lesen Sie Daten von digitalen Eing√§ngen. </li><li>  Steuerrelaisausgang. </li><li>  Benutzeroberfl√§che pflegen (Display + Tastatur). </li><li>  Erm√∂glichen Sie den Zugriff auf Daten √ºber RS-485 / Modbus. </li><li>  Speichern Sie Daten auf externen Medien. </li></ul><br>  Weil  Wir m√ºssen eine ausreichend gro√üe Anzahl verschiedener Unteraufgaben implementieren, wir werden das Echtzeit-Betriebssystem (zum Beispiel das bereits erw√§hnte FreeRTOS) als Basis verwenden.  Threads im Betriebssystem werden manchmal als Aufgaben bezeichnet - √§hnlich wie bei FreeRTOS.  Ich m√∂chte Sie sofort warnen: Der Artikel enth√§lt keinen Quellcode. Es ist der architektonische Aspekt dieses Problems, der von Interesse ist. <br><br>  Wenn wir die Aufgabe analysieren, k√∂nnen wir sehen, dass verschiedene Komponenten des Systems dieselben Daten verwenden.  Beispiel: Daten von Sensoren m√ºssen abgerufen, auf einem Bildschirm angezeigt, auf ein Medium geschrieben und externen Systemen zum Lesen bereitgestellt werden.  Dies legt nahe, dass eine Art Echtzeitdatenbank (RTDB) erforderlich ist, um die relevantesten Daten f√ºr verschiedene Subsysteme zu speichern und bereitzustellen. <br><br>  Im System ausgef√ºhrte Aufgaben (Lesen von Daten, Schreiben, Anzeigen usw.) k√∂nnen unterschiedliche Anforderungen an die H√§ufigkeit ihres Anrufs stellen.  Es macht keinen Sinn, die Daten auf dem Display mit einer Frequenz von 1 Mal pro 100 ms zu aktualisieren, weil  Dies ist f√ºr eine Person nicht kritisch, aber es ist h√§ufig erforderlich, Daten von Sensoren zu lesen (insbesondere, wenn Kontrollma√ünahmen f√ºr sie erforderlich sind) (obwohl dies je nach TK m√∂glicherweise nicht m√∂glich ist).  Ein weiterer wichtiger Punkt betrifft die L√∂sung des Problems des Zugriffs auf dieselben Daten zum Lesen und Schreiben.  Beispiel: Ein Stream, der Sensoren abfragt, schreibt die empfangenen Werte in die RTDB, und in diesem Moment liest der Stream, der f√ºr die Aktualisierung der Informationen auf dem Display verantwortlich ist, diese.  Hier helfen uns die Synchronisationsmechanismen, die das Betriebssystem bietet. <br><br>  Beginnen wir mit dem Entwurf der Architektur unserer Anwendung! <br><br><h2>  Echtzeitdatenbank </h2><br><img src="https://habrastorage.org/webt/pb/u1/bu/pbu1bu9dgrjklvl0p_xr-svgsau.png"><br><br>  Eine gew√∂hnliche Struktur, die den erforderlichen Satz von Feldern oder ein Array enth√§lt, kann als solche Basis dienen.  F√ºr den Zugriff auf "RTDB" verwenden wir die API, mit der wir Daten aus der Datenbank schreiben und lesen k√∂nnen.  Die Datenzugriffssynchronisation innerhalb der API-Funktionen kann auf den vom Betriebssystem bereitgestellten Mutexen basieren (oder einen anderen Mechanismus verwenden). <br><br><img src="https://habrastorage.org/webt/x3/bl/1i/x3bl1ihf07mt6nf-hgpfyrr9mrk.png"><br><br><h2>  Arbeiten mit Sensoren an den Reifen </h2><br>  Die Arbeit mit Sensoren umfasst Folgendes: <br><br><ul><li>  Daten lesen; </li><li>  Datenverarbeitung (falls erforderlich), einschlie√ülich: <br><ul><li>  Validierungspr√ºfung; </li><li>  Skalierung </li><li>  Filtern </li><li>  Validierung g√ºltiger Werte; </li></ul><br></li><li>  Aufzeichnung empfangener Daten in RTDB. </li></ul><br>  All diese Arbeiten k√∂nnen in einer Aufgabe erledigt werden. <br><br><img src="https://habrastorage.org/webt/la/ua/sb/lauasbvner90pd5zzw3fs0wn41c.png"><br><br>  "Port" - der wahre Hafen von MK; <br>  "Protokolltreiber" - Protokolltreiber (z. B. Modbus).  F√ºr einen solchen Treiber ist es ratsam, die Benutzeroberfl√§che zu erstellen und durchzuarbeiten.  Im Rahmen einer solchen Schnittstelle ist es m√∂glich, die Kontrolle des Zugriffs auf die Ressource √ºber Mutexe zu implementieren, wie dies f√ºr ‚ÄûRTDB‚Äú geschehen ist.  Einige Entwickler schlagen vor, dies auf Portebene zu tun, um sicherzustellen, dass niemand anderes etwas auf diesen Port schreibt, w√§hrend wir unsere Modbus-Pakete √ºber diesen Port √ºbertragen. <br>  "Sensor Reader" - eine Aufgabe (Task), die Sensoren abfragt, die empfangenen Informationen aufr√§umt und in "RTDB" schreibt. <br><br>  "RTDB" ist die oben im entsprechenden Abschnitt beschriebene Echtzeitdatenbank. <br>  Die Aufschrift ‚ÄûPr: 1‚Äú √ºber der Aufgabe bedeutet Priorit√§t. Unter dem Strich kann jede Aufgabe Priorit√§t haben, wenn zwei Aufgaben, die auf die Prozessorzeit warten, unterschiedliche Priorit√§ten haben. Die Ressource erh√§lt die Aufgabe mit der h√∂heren Priorit√§t.  Wenn die Aufgaben dieselbe Priorit√§t haben, wird die Aufgabe mit der l√§ngeren Wartezeit gestartet. <br><br><h2>  Arbeiten Sie mit diskreten Eing√§ngen </h2><br>  Im Allgemeinen kann die Arbeit mit digitalen Eing√§ngen genauso organisiert werden wie mit digitalen Sensoren.  Es kann jedoch erforderlich sein, schnell auf √Ñnderungen im Status der Eing√§nge zu reagieren.  Schlie√üen Sie beispielsweise auf Knopfdruck den Relaisausgang so schnell wie m√∂glich.  In diesem Fall ist es besser, den folgenden Ansatz zu verwenden: Um den Relaisausgang zu verarbeiten, erstellen wir eine spezielle separate Aufgabe mit einer h√∂heren Priorit√§t als die anderen.  In dieser Aufgabe befindet sich ein Semaphor, das erfasst werden soll.  Ein Interrupt wird ausgel√∂st, um einen bestimmten Digitaleingang auszul√∂sen, bei dem das oben erw√§hnte Semaphor zur√ºckgesetzt wird.  Weil  Die Interrupt-Priorit√§t ist maximal, dann wird die damit verbundene Funktion fast sofort ausgef√ºhrt. In unserem Fall wird das Semaphor zur√ºckgesetzt, und danach ist die n√§chste Aufgabe in der Ausf√ºhrungswarteschlange diejenige, innerhalb derer das Relais gesteuert wird (weil es hat) Die Priorit√§t ist h√∂her als bei anderen Aufgaben und die Sperre beim Warten auf das Semaphor wird aufgehoben. <br>  So kann das Schema dieses Subsystems aussehen. <br><br><img src="https://habrastorage.org/webt/cr/ow/2_/crow2_gsalrlns7yorool3w6hwu.png"><br><br>  Neben der schnellen Reaktion auf die √Ñnderung des Status eines bestimmten Eingangs k√∂nnen Sie zus√§tzlich die Aufgabe ‚ÄûDI-Leser‚Äú festlegen, um den Status diskreter Eing√§nge zu lesen.  Diese Aufgabe kann entweder unabh√§ngig sein oder vom Timer aufgerufen werden. <br><br>  Die Arbeit des ‚ÄûInterrupt-Handlers‚Äú und des ‚ÄûRelais-Controllers‚Äú in Form von Diagrammen wird nachfolgend dargestellt. <br><br><img src="https://habrastorage.org/webt/yz/1r/yu/yz1ryutqdblpajcszdhhonkfkk8.png"><br><br><h2>  Daten auf externe Medien schreiben </h2><br>  Das Schreiben von Daten auf ein externes Medium ist ideologisch dem Lesen von Daten von digitalen Sensoren sehr √§hnlich, nur die Bewegung von Daten erfolgt in die entgegengesetzte Richtung. <br><br><img src="https://habrastorage.org/webt/dd/re/op/ddreop78fgjkhdhs4ncjzs6wadm.png"><br><br>  Wir lesen von ‚ÄûRTDB‚Äú und schreiben √ºber den ‚ÄûStore-Treiber‚Äú auf ein externes Medium - es kann sich um eine SD-Karte, ein USB-Flash-Laufwerk oder etwas anderes handeln.  Vergessen Sie auch hier nicht, Mutex-Wrapper (oder andere Tools zum Organisieren des Zugriffs auf die Ressource) in die Schnittstellenfunktionen aufzunehmen! <br><br><h2>  Bereitstellung des Zugriffs auf Echtzeitdaten </h2><br>  Ein wichtiger Punkt ist die Bereitstellung von Daten aus ‚ÄûRTDB‚Äú f√ºr externe Systeme.  Es k√∂nnen fast alle Schnittstellen und Protokolle sein.  Im Gegensatz zu einer Reihe von betrachteten Subsystemen besteht der Hauptunterschied darin, dass einige der in Automatisierungssystemen weit verbreiteten Protokolle spezielle Anforderungen an die Antwortzeit auf die Anforderung stellen. Wenn die Antwort nicht innerhalb einer bestimmten Zeit eintrifft, wird davon ausgegangen, dass es keine gibt Kommunikation, auch wenn er (die Antwort) nach einer Weile kommen wird.  Und seitdem  Der Zugriff auf "RTDB" in unserem Beispiel kann vor√ºbergehend blockiert werden (durch Mutex). Es ist erforderlich, das externe Master-Ger√§t (Master ist ein Ger√§t, das versucht, Daten von unserem zu lesen) vor einer solchen Blockierung zu sch√ºtzen.  Es ist auch erw√§genswert, den Schutz des Ger√§ts selbst vor der Tatsache zu ber√ºcksichtigen, dass der Master es mit hoher Frequenz abfragt, wodurch der Betrieb des Systems durch st√§ndiges Lesen von "RTDB" behindert wird.  Eine L√∂sung besteht darin, einen Zwischenpuffer zu verwenden. <br><br><img src="https://habrastorage.org/webt/wl/km/rr/wlkmrrvydtlmq8jxzxkofdvjrzg.png"><br><br>  Der "Datenaktualisierer" liest Daten aus "RTDB" mit einer bestimmten Frequenz und addiert das, was er im "Protokollcache" gelesen hat, von dem der "Protokollhandler" Daten aufnimmt.  In diesem Fall besteht das Problem des Blockierens auf Protokoll-Cache-Ebene. Um dieses Problem zu beheben, k√∂nnen Sie einen weiteren Cache erstellen, in dem der ‚ÄûProtokoll-Handler‚Äú Daten speichert, falls diese nicht aus dem blockierten ‚ÄûProtokoll-Cache‚Äú gelesen werden konnten. Sie k√∂nnen zus√§tzlich: <br>  - "Protokollhandler" zu einer h√∂heren Priorit√§t machen; <br>  - Erh√∂hen Sie die Lesezeit von "RTDB" f√ºr "Data Updater" (was eine mittelm√§√üige L√∂sung ist). <br><br><h2>  Arbeiten Sie mit der Benutzeroberfl√§che </h2><br>  Das Arbeiten mit der Benutzeroberfl√§che umfasst das Aktualisieren der Daten auf dem Bildschirm und das Arbeiten mit der Tastatur.  Die Architektur dieses Subsystems kann folgenderma√üen aussehen. <br><br><img src="https://habrastorage.org/webt/ky/gi/lb/kygilbpcxnocpiibditqifuysre.png"><br><br>  Der UI-Mitarbeiter ist daf√ºr verantwortlich, Tastenanschl√§ge zu lesen, Daten aus ‚ÄûRTDB‚Äú zu entnehmen und die Anzeige zu aktualisieren, die der Benutzer sieht. <br><br><h2>  Allgemeine Systemstruktur </h2><br>  Schauen Sie sich jetzt an, was am Ende passiert ist. <br><br><img src="https://habrastorage.org/webt/t9/kg/tp/t9kgtp-kujcs9plimib5txgrrb0.png"><br><br>  Um die Last auszugleichen, k√∂nnen Sie zus√§tzliche Caches festlegen, wie wir es in dem Subsystem getan haben, das f√ºr den Zugriff auf diese externen Systeme verantwortlich ist.  Einige Aufgaben der Daten√ºbertragung k√∂nnen mithilfe von Warteschlangen gel√∂st werden, da sie normalerweise von Echtzeitbetriebssystemen unterst√ºtzt werden (sicher in FreeRTOS). <br>  Das ist alles, ich hoffe es war interessant. <br><br>  <b>PS</b> <br>  Als Literatur w√ºrde ich "Making Embedded Systems: Entwurfsmuster f√ºr gro√üartige Software" Elecia White und Artikel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrey Kournits "FreeRTOS - ein Betriebssystem f√ºr Mikrocontroller" empfehlen.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419717/">https://habr.com/ru/post/de419717/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419705/index.html">Wir wollen Devops durch ein Skript ersetzen (eigentlich nicht): Entwickler, Sie brauchen Ihre Meinung</a></li>
<li><a href="../de419707/index.html">Gamification von Anwendungen - 5 Dinge zu beachten</a></li>
<li><a href="../de419711/index.html">Die erste IT Bike Quest in St. Petersburg. Wie war es</a></li>
<li><a href="../de419713/index.html">Mail.Ru Design Konferenz + Dribbble Meetup 2018</a></li>
<li><a href="../de419715/index.html">Sie wissen nicht, wie Sie mit Transaktionen arbeiten sollen</a></li>
<li><a href="../de419719/index.html">[Lesezeichen] 23 Empfehlungen zum Schutz von Node.js-Anwendungen</a></li>
<li><a href="../de419721/index.html">Biomarker des Alterns. Panel Gebrechlichkeit. Teil 1</a></li>
<li><a href="../de419725/index.html">Pfeile, W√ºrfel und M√ºnzen: Diskrete Verteilungsalgorithmen</a></li>
<li><a href="../de419727/index.html">Harbour - eine Registrierung f√ºr sofort einsatzbereite Docker-Container</a></li>
<li><a href="../de419729/index.html">Wohlt√§tigkeitsveranstaltung ‚ÄûGeben Sie Kindern Fl√ºgel‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>