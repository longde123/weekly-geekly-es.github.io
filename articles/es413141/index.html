<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∞Ô∏è ‚úäüèº üë©üèæ‚Äçü§ù‚Äçüë®üèº Clasifique grandes cantidades de datos en Apache Spark utilizando modelos arbitrarios de aprendizaje autom√°tico üö≥ üë©üèø‚ÄçüöÄ üíù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 2: soluci√≥n 
 Hola de nuevo Hoy continuar√© mi historia sobre c√≥mo clasificamos grandes cantidades de datos en Apache Spark utilizando modelos ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clasifique grandes cantidades de datos en Apache Spark utilizando modelos arbitrarios de aprendizaje autom√°tico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/413141/"><h2>  Parte 2: soluci√≥n </h2><br>  Hola de nuevo  Hoy continuar√© mi historia sobre c√≥mo clasificamos grandes cantidades de datos en Apache Spark utilizando modelos arbitrarios de aprendizaje autom√°tico.  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte del art√≠culo,</a> examinamos la declaraci√≥n del problema en s√≠, as√≠ como los principales problemas que surgen al organizar la interacci√≥n entre el cl√∫ster en el que se almacenan y procesan los datos iniciales, y el servicio de clasificaci√≥n externo.  En la segunda parte, consideraremos una de las opciones para resolver este problema usando el enfoque Reactive Streams y su implementaci√≥n usando la biblioteca akka-streams. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div><a name="habracut"></a><br><h3>  Concepto de corrientes reactivas </h3><br>  Para resolver los problemas descritos en la primera parte, puede usar el enfoque, llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Corrientes reactivas</a> .  Le permite controlar el proceso de transferencia de flujos de datos entre etapas de procesamiento, operando a diferentes velocidades e independientemente entre s√≠ sin la necesidad de almacenamiento en b√∫fer.  Si una de las etapas de procesamiento es m√°s lenta que la anterior, entonces es necesario indicarle a la etapa m√°s r√°pida cu√°ntos datos de entrada est√°n listos para procesar en este momento.  Esta interacci√≥n se llama contrapresi√≥n.  Consiste en el hecho de que las etapas m√°s r√°pidas procesan exactamente tantos elementos como se requieren para la etapa m√°s lenta, y no m√°s, y luego liberan recursos inform√°ticos. <br><br>  En general, Reactive Streams es una especificaci√≥n para implementar la plantilla <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Publisher-Subscriber</a> .  Esta especificaci√≥n define un conjunto de cuatro interfaces (editor, suscriptor, procesador y suscripci√≥n) y un contrato para sus m√©todos. <br><br>  Consideremos estas interfaces con m√°s detalle: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Hay dos lados en el modelo de editor-suscriptor: transmitir y recibir.  Al implementar las secuencias reactivas, la clase que implementa la interfaz del editor es responsable de la transferencia de datos, y el suscriptor es responsable de la recepci√≥n.  Para establecer comunicaci√≥n entre ellos, el suscriptor debe estar registrado con Publisher llamando a su m√©todo de suscripci√≥n.  Seg√∫n la especificaci√≥n, despu√©s de registrar un suscriptor, el editor debe llamar a sus m√©todos en el siguiente orden: <br><br><ol><li>  onSubscribe.  Este m√©todo se llama inmediatamente despu√©s de registrar al suscriptor con Publisher.  Como par√°metro, se le pasa un objeto de Suscripci√≥n a trav√©s del cual el Suscriptor solicitar√° datos del Editor.  Este objeto debe almacenarse y llamarse solo en el contexto de este suscriptor. </li><li>  Despu√©s de que el Suscriptor haya solicitado datos del Editor llamando al m√©todo de solicitud en el objeto de Suscripci√≥n correspondiente, el Editor puede llamar al m√©todo Suscriptor onNext, pasando el siguiente elemento. </li><li>  El suscriptor puede llamar peri√≥dicamente al m√©todo de solicitud en la Suscripci√≥n, pero Publisher no puede llamar al m√©todo onNext m√°s que el total solicitado a trav√©s del m√©todo de solicitud. </li><li>  Si el flujo de datos es finito, despu√©s de pasar todos los elementos a trav√©s del m√©todo onNext, Publisher debe llamar al m√©todo onComplete. </li><li>  Si se produjo un error en Publisher y el procesamiento posterior de los elementos no es posible, debe llamar al m√©todo onError </li><li>  Despu√©s de llamar a los m√©todos onComplete o onError, debe excluirse la interacci√≥n adicional del editor con el suscriptor. </li></ol><br>  Se puede considerar que las llamadas a m√©todos env√≠an se√±ales entre el publicador y el suscriptor.  El suscriptor le indica al editor cu√°ntos elementos est√° listo para procesar, y el editor, a su vez, le indica que hay el siguiente elemento, que no hay m√°s elementos o que se ha producido alg√∫n error. <br><br>  Para excluir otra influencia del publicador y del suscriptor entre s√≠, las llamadas a todos los m√©todos que implementan las interfaces de Reactive Streams deben ser sin bloqueo.  En este caso, la interacci√≥n entre ellos ser√° completamente as√≠ncrona. <br><br>  Puede encontrar m√°s detalles sobre la especificaci√≥n para las interfaces de Reactive Streams <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Por lo tanto, al vincular los iteradores originales y resultantes mediante la conversi√≥n a Publicador y Suscriptor, respectivamente, podemos resolver los problemas identificados en la parte anterior del art√≠culo.  El problema del desbordamiento del b√∫fer entre etapas se resuelve solicitando un cierto n√∫mero de elementos por el suscriptor.  El problema de la finalizaci√≥n exitosa o incorrecta se resuelve enviando se√±ales al suscriptor a trav√©s de los m√©todos onComplete u onError, respectivamente.  El editor se hace responsable del env√≠o de estas se√±ales, que en nuestro caso deben controlar cu√°ntas solicitudes HTTP se enviaron y cu√°ntas de ellas recibieron respuestas.  Despu√©s de recibir la √∫ltima respuesta y procesar todos los resultados que se obtuvieron, debe enviar una se√±al onComplete.  En caso de que una de las solicitudes fallara, deber√≠a enviar una se√±al onError y dejar de enviar m√°s elementos al suscriptor, as√≠ como restar elementos del iterador original. <br><br>  El iterador resultante debe implementarse como un suscriptor.  En este caso, no podemos prescindir de un b√∫fer en el que los elementos se escribir√°n cuando se llame al m√©todo onNext desde la interfaz del suscriptor y se reste utilizando los m√©todos hasNext y next de la interfaz Iterator.  Como implementaci√≥n de b√∫fer, puede usar una cola de bloqueo, por ejemplo, LinkedBlockedQueue. <br><br>  Un lector atento har√° inmediatamente la pregunta: ¬øpor qu√© es la cola de bloqueo, porque de acuerdo con la especificaci√≥n de Reactive Streams, la implementaci√≥n de todos los m√©todos debe ser sin bloqueo?  Pero todo est√° bien aqu√≠: dado que le estamos pidiendo a Publisher un n√∫mero estrictamente definido de elementos, el m√©todo onNext no se llamar√° m√°s de este n√∫mero de veces, y la cola siempre puede agregar un nuevo elemento sin bloquear. <br><br>  Por otro lado, el bloqueo puede ocurrir cuando se llama al m√©todo hasNext en caso de una cola vac√≠a.  Sin embargo, esto est√° bien: el m√©todo hasNext no forma parte del contrato de la interfaz del suscriptor, se define en la interfaz Iterator, que, como explicamos anteriormente, es una estructura de datos de bloqueo.  Al llamar al siguiente m√©todo, restamos el siguiente elemento de la cola, y cuando su tama√±o se vuelve menor que un cierto umbral, necesitaremos solicitar la siguiente porci√≥n de los elementos a trav√©s de una llamada al m√©todo de solicitud. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/xy/8t/tzxy8tn05km8fox0bkwk_zsxvcg.png" width="650"></div>  <i>Figura 7. Interacci√≥n asincr√≥nica con un servicio externo utilizando el enfoque de Reactive Streams</i> <br><br>  Por supuesto, en este caso no eliminaremos por completo el bloqueo de llamadas.  Esto se debe a una falta de coincidencia de paradigmas entre las secuencias reactivas, que suponen una interacci√≥n completamente asincr√≥nica, y un iterador, que debe llamar a trueN o false al llamar al m√©todo hasNext.  Sin embargo, a diferencia de la interacci√≥n s√≠ncrona con un servicio externo, el tiempo de inactividad debido a bloqueos puede reducirse significativamente al aumentar la carga general de los n√∫cleos del procesador. <br><br>  Ser√≠a conveniente que los desarrolladores de Apache Spark en futuras versiones implementaran un an√°logo del m√©todo mapPartitions, que funciona con Publisher y Subscriber.  Esto permitir√≠a una interacci√≥n completamente asincr√≥nica, eliminando as√≠ la posibilidad de bloquear hilos. <br><br><h3>  Akka-streams y akka-http como implementaci√≥n de la especificaci√≥n Reactive Streams </h3><br>  Actualmente, ya hay m√°s de una docena de implementaciones de la especificaci√≥n Reactive Streams.  Una de esas implementaciones es el m√≥dulo akka-streams de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">akka</a> .  En el mundo de JVM, Akka se ha establecido como uno de los medios m√°s efectivos para escribir sistemas paralelos y distribuidos.  Esto se logra debido al hecho de que el principio b√°sico establecido en su base es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el modelo de actor</a> , que le permite escribir aplicaciones altamente competitivas sin el control directo de los hilos y sus grupos. <br><br>  Se ha escrito mucha literatura sobre la implementaci√≥n del concepto de actores en akka, por lo que no nos detendremos aqu√≠ (el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio oficial de akka</a> es una muy buena fuente de informaci√≥n, tambi√©n recomiendo el libro de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acci√≥n de akka</a> ).  Aqu√≠ veremos m√°s de cerca el lado tecnol√≥gico de la implementaci√≥n bajo la JVM. <br><br>  En general, los actores no existen por s√≠ mismos, sino que forman un sistema jer√°rquico.  Para crear un sistema de actor, debe asignar recursos para √©l, por lo que el primer paso al trabajar con akka es crear una instancia del objeto ActorSystem.  Cuando se inicia ActorSystem, se crea un grupo separado de subprocesos, denominado despachador, en el que se ejecuta todo el c√≥digo definido en los actores.  T√≠picamente, un solo hilo ejecuta el c√≥digo de m√∫ltiples actores, sin embargo, si es necesario, puede configurar un despachador separado para un grupo espec√≠fico de actores (por ejemplo, para actores que interact√∫an directamente con una API de bloqueo). <br><br>  Una de las tareas m√°s comunes resueltas usando actores es el procesamiento secuencial de flujos de datos.  Anteriormente, para esto, era necesario construir manualmente cadenas de actores y asegurarse de que no hubiera cuellos de botella entre ellos (por ejemplo, si un actor procesa los mensajes m√°s r√°pido que el siguiente, entonces puede tener un desbordamiento de la cola de mensajes entrantes, lo que lleva a un error OutOfMemoryError). <br><br>  A partir de la versi√≥n 2.4, se agreg√≥ el m√≥dulo akka-streams a akka, que le permite definir declarativamente el proceso de procesamiento de datos y luego crear los actores necesarios para su ejecuci√≥n.  Akka-streams tambi√©n implementa el principio de contrapresi√≥n, que elimina la posibilidad de desbordar la cola de mensajes entrantes para todos los actores involucrados en el procesamiento. <br><br>  Los elementos principales para definir el esquema de procesamiento del flujo de datos en los flujos de akka son Source, Flow y Sink.  Al combinarlos entre s√≠, obtenemos un gr√°fico ejecutable.  Para comenzar el proceso de procesamiento, se utiliza un materializador, que crea actores que trabajan de acuerdo con el gr√°fico definido por nosotros (la interfaz del Materializador y su implementaci√≥n ActorMaterializer). <br><br>  Consideremos las etapas Fuente, Flujo y Sumidero con m√°s detalle.  Fuente define la fuente de datos.  Akka-streams admite m√°s de una docena de formas diferentes de crear fuentes, incluso desde un iterador: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> featuresSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">Float</span></span>], <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator { () =&gt; featuresIterator }</code> </pre><br>  La fuente tambi√©n se puede obtener convirtiendo una fuente existente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = source.map(item =&gt; transform(item))</code> </pre> <br>  Si la transformaci√≥n es una operaci√≥n no trivial, se puede representar como una entidad Flow.  Akka-streams admite muchas formas diferentes de crear Flow.  La forma m√°s f√°cil es crear desde una funci√≥n: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Flow</span></span>.fromFunction((x: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; x.length)</code> </pre> <br>  Al combinar Source y Flow, obtenemos una nueva Fuente. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = oldSource.via(someFlow)</code> </pre> <br>  El sumidero se utiliza como la etapa final del procesamiento de datos.  Como en el caso de Source, akka-streams proporciona m√°s de una docena de opciones diferentes de Sink, por ejemplo, Sink.foreach realiza una determinada operaci√≥n para cada elemento, Sink.seq recopila todos los elementos de una colecci√≥n, etc. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> printSink: <span class="hljs-type"><span class="hljs-type">Sink</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>, <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = <span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println)</code> </pre> <br>  Fuente, flujo y sumidero se parametrizan por los tipos de elementos de entrada y / o salida, respectivamente.  Adem√°s, cada etapa de procesamiento puede tener alg√∫n resultado de su trabajo.  Para esto, Source, Flow y Sink tambi√©n se parametrizan mediante un tipo adicional que determina el resultado de la operaci√≥n.  Este tipo se llama el tipo de valor materializado.  Si la operaci√≥n no implica la presencia de un resultado adicional de su trabajo, por ejemplo, cuando definimos Flujo a trav√©s de una funci√≥n, entonces el tipo NotUsed se usa como el valor materializado. <br><br>  Combinando la fuente, el flujo y el sumidero necesarios, obtenemos RunnableGraph.  Est√° parametrizado por un tipo, que determina el tipo de valor obtenido como resultado de la ejecuci√≥n de este gr√°fico.  Si es necesario, al combinar las etapas, puede especificar el resultado de cu√°l de las etapas ser√° el resultado de toda la gr√°fica de operaciones.  Por defecto, se toma el resultado de la etapa Fuente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = someSource.to(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))</code> </pre> <br>  Sin embargo, si el resultado de la etapa Sink es m√°s importante para nosotros, entonces debemos indicarlo expl√≠citamente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = someSource.toMat(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))(<span class="hljs-type"><span class="hljs-type">Keep</span></span>.right)</code> </pre><br>  Despu√©s de haber definido el gr√°fico de operaciones, debemos ejecutarlo.  Para hacer esto, runnableGraph necesita llamar al m√©todo de ejecuci√≥n.  Como par√°metro, este m√©todo toma un objeto ActorMaterializer (que tambi√©n puede estar en un alcance impl√≠cito), que es responsable de crear actores que realizar√°n operaciones.  Por lo general, un ActorMaterializer se crea inmediatamente despu√©s de la creaci√≥n de un ActorSystem, adjunto a su ciclo de vida, y lo utiliza para crear actores.  Considere un ejemplo: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   ActorSystem,       implicit val system = ActorSystem(‚Äúsystem name‚Äù) // ,       ActorSystem implicit val materializer = ActorMaterializer() //    ,       Sink val graph: RunnableGraph[Future[immutable.Seq[Int]]] = Source.fromIterator(() =&gt; (1 to 10).iterator).toMat(Sink.seq)(Keep.right) //   ,    implicit scope. val result: Future[immutable.Seq[Int]] = graph.run()</span></span></code> </pre><br>  En el caso de combinaciones simples, puede hacerlo sin crear un RunnableGraph separado, sino simplemente conectar Source a Sink e iniciarlos llamando al m√©todo runWith en Source.  Este m√©todo tambi√©n supone que un objeto ActorMaterializer est√° presente en el √°mbito impl√≠cito.  Adem√°s, en este caso, se utilizar√° el valor materializado definido en Sink.  Por ejemplo, usando el siguiente c√≥digo, podemos convertir Source a Publisher desde la especificaci√≥n Reactive Streams: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator(() =&gt; sourceIterator).map(item =&gt; transform(item)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> publisher: <span class="hljs-type"><span class="hljs-type">Publisher</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>] = source.runWith(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.asPublisher(<span class="hljs-literal"><span class="hljs-literal">false</span></span>))</code> </pre><br>  Entonces, ahora hemos mostrado c√≥mo puede obtener Reactive Streams Publisher creando una Fuente desde el iterador de fuente y realizando algunas transformaciones en sus elementos.  Ahora podemos asociarlo con un suscriptor que suministre datos al iterador resultante.  Queda por considerar la √∫ltima pregunta: c√≥mo organizar la interacci√≥n HTTP con un servicio externo. <br><br>  La estructura de akka incluye el m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://doc.akka.io/docs/akka-">akka-http</a> , que le permite organizar la comunicaci√≥n asincr√≥nica sin bloqueo a trav√©s de HTTP.  Adem√°s, este m√≥dulo est√° construido sobre la base de flujos de akka, lo que le permite agregar interacci√≥n HTTP como un paso adicional en el gr√°fico de las operaciones de procesamiento de flujo de datos. <br><br>  Para conectarse a servicios externos, akka-http proporciona tres interfaces diferentes. <br><br><ol><li>  API de nivel de solicitud: es la opci√≥n m√°s simple para el caso de solicitudes individuales a una m√°quina arbitraria.  En este nivel, las conexiones HTTP se gestionan de forma completamente autom√°tica, y en cada solicitud es necesario transferir la direcci√≥n completa de la m√°quina a la que se dirige la solicitud. </li><li>  API de nivel de host: adecuada cuando sabemos a qu√© puerto en qu√© m√°quina accederemos.  En este caso, akka-http toma el control del conjunto de conexiones HTTP, y en las solicitudes es suficiente para especificar la ruta relativa al recurso solicitado. </li><li>  API de nivel de conexi√≥n: le permite obtener un control total sobre la administraci√≥n de las conexiones HTTP, es decir, abrir, cerrar y distribuir solicitudes entre conexiones. </li></ol><br>  En nuestro caso, la direcci√≥n del servicio de clasificaci√≥n la conocemos de antemano, por lo tanto, es necesario organizar la interacci√≥n HTTP solo con esta m√°quina en particular.  Por lo tanto, la API de nivel de host es la mejor para nosotros.  Ahora, veamos c√≥mo se crea el grupo de conexiones HTTP cuando se usa: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[(<span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>,<span class="hljs-type"><span class="hljs-type">Id</span></span>), (<span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">HttpResponse</span></span>],<span class="hljs-type"><span class="hljs-type">Id</span></span>), <span class="hljs-type"><span class="hljs-type">Http</span></span>.<span class="hljs-type"><span class="hljs-type">HostConnectionPool</span></span>] = <span class="hljs-type"><span class="hljs-type">Http</span></span>().cachedHostConnectionPool[<span class="hljs-type"><span class="hljs-type">Id</span></span>](hostAddress, portNumber)</code> </pre><br>  Al llamar a Http (). CachedHostConnectionPool [T] (hostAddress, portNumber) en el ActorSystem, que est√° en un √°mbito impl√≠cito, los recursos se asignan para crear un grupo de conexiones, pero las conexiones en s√≠ no est√°n establecidas.  Como resultado de esta llamada, se devuelve Flow, que recibe un par de una solicitud HTTP y alg√∫n objeto de identificaci√≥n Id como entrada.  El objeto de identificaci√≥n es necesario para hacer coincidir la solicitud con la respuesta correspondiente debido al hecho de que la llamada HTTP en akka-http es una operaci√≥n asincr√≥nica, y el orden en que se reciben las respuestas no corresponde necesariamente al orden en que se env√≠an las solicitudes.  Por lo tanto, en la salida, Flow da un par del resultado de la consulta y el objeto de identificaci√≥n correspondiente. <br><br>  Directamente, las conexiones HTTP se establecen cuando se inicia (materializa) un gr√°fico (incluido este Flujo).  Akka-http se implementa de tal manera que no importa cu√°ntas veces se hayan materializado los gr√°ficos que contienen httpFlow, dentro de un ActorSystem siempre habr√° un grupo com√∫n de conexiones HTTP que ser√°n utilizadas por todas las materializaciones.  Esto le permite controlar mejor el uso de los recursos de la red y evitar sobrecargarlos. <br><br>  Por lo tanto, el ciclo de vida del grupo de conexiones HTTP est√° vinculado al ActorSystem.  Como ya se mencion√≥, tambi√©n se adjunta el ciclo de vida del grupo de subprocesos, en el que se realizan las operaciones definidas en los actores (o en nuestro caso, definidas como las etapas akka-streams y akka-http).  Por lo tanto, para lograr la m√°xima eficiencia, debemos reutilizar una instancia de ActorSystem dentro del mismo proceso JVM. <br><br><h3>  Poniendo todo esto junto: un ejemplo de implementaci√≥n de interacci√≥n con el servicio de clasificaci√≥n </h3><br>  Entonces, ahora podemos pasar al proceso de clasificar grandes vol√∫menes de datos distribuidos en Apache Spark utilizando la interacci√≥n asincr√≥nica con servicios externos.  El esquema general de esta interacci√≥n ya se ha mostrado en la Figura 7. <br><br>  Supongamos que tenemos un conjunto de datos inicial [Caracter√≠sticas] definido.  Al aplicarle la operaci√≥n mapPartitions, deber√≠amos obtener un conjunto de datos, en el que cada identificaci√≥n del conjunto fuente se estampa con un cierto valor obtenido como resultado de la clasificaci√≥n (conjunto de datos [puntuaci√≥n]).  Para organizar el procesamiento asincr√≥nico en los ejecutores, debemos ajustar los iteradores de origen y resultantes en Publisher y Subscriber, respectivamente, de la especificaci√≥n de flujos reactivos y vincularlos. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Features</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Score</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, score: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">batchesRequestCount</span></span></span><span class="hljs-class"> </span></span>= config.getInt(‚ÄúscoreService. batchesRequestCount‚Äù)<span class="hljs-comment"><span class="hljs-comment">//(2) //... val scoreDs: Dataset[Score] = featuresDs.mapPartitions { fi: Iterator[Features] =&gt; val publisher: Publisher[Iterable[Score]] = createPublisher(fi) //(3) val iteratorSubscriber: Iterator[Score] = new IteratorSubscriber(batchesRequestCount) //(4) publisher.subscribe(batchesRequestCount) //(5) iteratorSubscriber //(6) }</span></span></code> </pre> <br>  En esta implementaci√≥n, se tiene en cuenta que el servicio de clasificaci√≥n para una llamada puede procesar un grupo de vectores de caracter√≠sticas a la vez, por lo tanto, el resultado de la clasificaci√≥n despu√©s de una llamada tambi√©n estar√° disponible de inmediato para todo el grupo.  Por lo tanto, como un tipo de par√°metro para Publisher, no solo tenemos Score, como es de esperar, sino Iterable [Score].  Por lo tanto, enviamos los resultados de clasificaci√≥n para este grupo al iterador resultante (que tambi√©n es un Suscriptor) mediante una sola llamada al m√©todo onNext.  Esto es mucho m√°s eficiente que llamar a Next para cada elemento.  Ahora analizaremos este c√≥digo con m√°s detalle. <br><br><ol><li>  Determinamos la estructura de los datos de entrada y salida.  Como entrada, tendremos un grupo de algunos identificadores con un vector de caracter√≠sticas, y como salida, tendremos un grupo de identificadores con un valor num√©rico obtenido como resultado de la clasificaci√≥n. </li><li>  Determinamos el n√∫mero de grupos que el suscriptor solicitar√° al editor a la vez.  Dado que se supone que estos valores permanecer√°n en el b√∫fer y esperar√°n hasta que se lean desde el iterador resultante, este valor depende de la cantidad de memoria asignada al ejecutor. </li><li>  Crear editor desde el iterador de origen.  Ser√° responsable de interactuar con el servicio de clasificaci√≥n.  La funci√≥n createPublisher se analiza a continuaci√≥n. </li><li>  Cree un suscriptor, que ser√° el iterador resultante.  El c√≥digo de clase IteratorSubscriber tambi√©n se proporciona a continuaci√≥n. </li><li>  Registro de suscriptor con Publisher. </li><li>  Devuelve IteratorSubscriber como resultado de la operaci√≥n mapPartitions. </li></ol><br>  Ahora considere la implementaci√≥n de la funci√≥n createPublisher. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ids</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-comment"><span class="hljs-comment">//(1) val batchSize = config.getInt("scoreService.batchSize") val parallelismLevel = config.getInt("scoreService.parallelismLevel") //(2) //... def createPublisher(fi: Iterator[Features]): Publisher[Iterable[Score]] = { import ActorSystemHolder._ //(3) Source .fromIterator(() =&gt; fi) //(4) .grouped(batchSize) //(5) .map { groupedFeatures: Seq[Features] =&gt; val request: (HttpRequest, Ids) = createHttpRequest(groupedFeatures) //(6) logger.debug(s"Sending request for the first id: ${request._2(0)}") request } .via(httpFlow) //(7) .flatMapMerge(parallelismLevel, { //(8) case (Success(response), ids) if response.status.isSuccess() =&gt; logger.debug(s"Processing successful result for the first id: ${ids(0)}") val resultSource: Source[Iterable[Score], _] = response.entity.dataBytes.reduce(_ ++ _).map { responseBytes =&gt; processSuccessfulResponse(responseBytes, ids) } //(9) resultScore case (Success(response), ids) =&gt; logger.warn( s"Failed result for the first id: ${ids(0)}, HTTP status: ${response.status}" ) response.discardEntityBytes() Source.failed( new IOException(s"Non-successful HTTP status: ${response.status}") ) //(10) case (Failure(ex), ids) =&gt; logger.warn(s"Failed result: an exception has occured", ex) Source.failed(ex) //(11) }) .runWith(Sink.asPublisher(false)) //(12) } def createHttpRequest(featuresSeq: Seq[Features]): (HttpRequest, ProfileIds) = { val requestBytes: Array[Byte] = featuresToMatrixBytes(featuresSeq) val ids: ProfileIds = extractIds(featuresSeq) val httpRequest = HttpRequest( method = HttpMethods.PUT, uri = "/score", entity = requestBytes ) httpRequest -&gt; ids }</span></span></code> </pre><br><ol><li>    -   ,   .         httpFlow,           . </li><li>     :     ,     (batchSize)        (parallelismLevel). </li><li>   implicit scope ActorSystem, ActorMaterializer  httpFlow.        Spark-.  ActorSystemHolder    . </li><li>     akka-streams   .     Source[Features]   . </li><li>            batchSize       . </li><li>     HttpRequest       .   HttpRequest      createHttpRequest.      createPublisher.      feature-,   ,      (            predict).       ,      HTTP-.      ,   HTTP-,    HTTP-, URI      . </li><li>        httpFlow. </li><li>     ,   .      flatMapMerge,        akka-http    Source[ByteString],      ,       .           .  parallelismLevel ,      (     ).      HTTP-:   ,  ,  ,   . </li><li>       :          .      akka    ByteString.    ,    ByteString    O(1),    ByteString        .       ,    ,         .                ,     . </li><li>       HTTP-     ,  Stream .         ,      discardEntityBytes    ,    ,  . </li><li>         .      akka-http    ,       . </li><li>       ,    Publisher,     .    ,    .  false   Sink.asPublisher ,   Publisher    Subscriber-. </li></ol><br>      ,    akka  ActorSystem,        .  ,        Spark ,          .   Spark    JVM , ,        ,     ActorSystem    ActorMatrializer  httpFlow. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActorSystemHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actorSystem: <span class="hljs-type"><span class="hljs-type">ActorSystem</span></span> = { <span class="hljs-comment"><span class="hljs-comment">//(1) val actorSystemName = s"score-service-client" logger.debug(s"Creating actor system $actorSystemName") val as = ActorSystem(actorSystemName) //(2) logger.debug("Adding shutdown hook for the actor system") scala.sys.addShutdownHook { //(3) logger.debug(s"Terminating actor system $actorSystemName") Await.result(as.terminate(), 30.seconds) //to Mars :) logger.debug(s"The actor system $actorSystemName has been terminated") } as } implicit lazy val materializer: ActorMaterializer = { //(4) logger.debug(s"Creating actor materializer for actor system ${actorSystem.name}") ActorMaterializer() } lazy val httpFlow: Flow[ (HttpRequest,ProfileIds), (Try[HttpResponse], ProfileIds), Http.HostConnectionPool] = { //(5) val httpFlowSettings = ConnectionPoolSettings(actorSystem) logger.debug(s"Creating http flow with settings $httpFlowSettings") Http().cachedHostConnectionPool[ProfileIds]( config.getString("scoreService.host"), config.getInt("scoreService.int"), settings = httpFlowSettings ) } }</span></span></code> </pre><br><ol><li>     ,   ,       ,     . </li><li>    ActorSystem   . </li><li>  ,     ,    ActorSystem,       terminate, ,   ,   ,     .      ,     JVM-. </li><li>    ActorMaterializer,      akka-streams,   ActorSystem. </li><li> ,   httpFlow     .      ,       HTTP-   ActorSystem. </li></ol><br>       Subscriber-    HTTP-. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">item: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Done</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamErrorCompletionException</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">2</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorSubscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">requestSize: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Iterable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//(3) private val buffer: BlockingQueue[QueueItem[Iterable[T]]] = new LinkedBlockingQueue[QueueItem[Iterable[T]]]() //(4) private var expecting: Int = 0 //(5) private val subscriptionPromise: Promise[Subscription] = Promise() private lazy val subscription: Subscription = Await.result(subscriptionPromise.future, 5.minutes) //(6) private var currentIterator: Iterator[T] = Iterator.empty //(7) private var isDone = false //(8) override def onSubscribe(s: Subscription): Unit = { subscriptionPromise.success(s) //(9) logger.trace("The iterator has been subscribed") } override def onNext(t: Iterable[T]): Unit = { logger.trace("Putting a next batch to the buffer") buffer.put(Item(t)) //(10) } override def onComplete(): Unit = { logger.debug("The stream has been succesfully completed") buffer.put(Done) //(11) } override def onError(t: Throwable): Unit = { logger.warn("The stream has been completed with error", t) buffer.put(Failure(t)) //(12) } override def hasNext: Boolean = { logger.trace("Asking hasNext") if (currentIterator.hasNext) { //(13) true } else if (isDone) { //(14) false } else { if (expecting &lt; requestSize) { requestNextBatches() //(15) } buffer.take() match { //(16) case Item(batch) =&gt; currentIterator = batch.iterator expecting -= 1 this.hasNext //(17) case Done =&gt; isDone = true false //(18) case Failure(exception) =&gt; throw new StreamErrorCompletionException(exception) //(19) } } } override def next(): T = { val out = currentIterator.next() logger.trace("The next element is {}", out) out //(20) } private def requestNextBatches(): Unit = { logger.debug(s"Requesting {} batches", requestSize) subscription.request(requestSize) expecting += requestSize //(21) } }</span></span></code> </pre><br>  IteratorSubscriber    Producer-Consumer.   ,    Subscriber,  Producer-,  ,   Iterator, ‚Äì Consumer-.      ,     .    Iterator       Apache Spark,    Subscriber ‚Äì  ,  ActorSystem. <br><br>      IteratorSubscriber  . <br><br><ol><li>          .          ,     Done,    ,  Throwable,    . </li><li>      ,        hasNext    . </li><li>  ,    ,        Publisher-. </li><li>    ,     .    LinkedBlockingQueue,      . ,         . </li><li>     ,    .     ,         ,       Publisher-.   ,    ,      Publisher-   .         hasNext  next ( requestNextBatches    hasNext),       ,       . </li><li>  subscriptionPromise  subscription     Subscription,    Publisher    onSubscribe. ,    Reactive Streams        Subscriber-  Publisher-     ,   ,   hasNext   ,  onSubscribe.      ,     subscription,          Publisher-.     lazy   subscription,    Promise. </li><li>       .          hasNext  next,     ,       . </li><li>     ,        ,  hasNext   false     .           hasNext,         . </li><li>    onSubscribe    Publisher-  Subscription    Promise,        subscription. </li><li> onNext  Publisher-,        .      . </li><li>       Publisher   onComplete,          Done. </li><li>    Publisher   onError.       . </li><li>    hasNext     ,      .      ,    true,       .     ,         . </li><li>        ,            false. </li><li>  ,   ,        requestSize,       Publisher.         ,    ,     ,   Publisher-    ,   HTTP-     . </li><li>        .  ,   ,      ,      .  ,       ,     (  ,    ,        subscription), ,     ,   ,      . </li><li>       ,           currentIterator.        ,          . ,       hasNext  ,         (    ,   ),        . </li><li>     ,    false        hasNext. ,     isDone,   ,     .   - ,   hasNext        ,         false.        ,       hasNext  ,    false      ,      .          ,      . </li><li>        ,    ,     ,     . </li><li>  next      .    ,        hasNext,    next        . </li><li>     Publisher-  ,       ,   subscription,       Publisher-.     requestSize.         . </li></ol><br>  ,       ,   ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div> <i> 8.       .</i> <br><br><h3>  :      </h3><br>      ,        ,      .     ,       HTTP ,      .         . <br><br>    ‚Äì         .    ,     ,       Hadoop ,      .  ,    ,       -       .     ,  ,   hdfs, ,          , ,       . <br><br>  ,         . ,   akka-http              ,         .   ,      -,       -       Apache Spark ,       ,  ,    -. <br><br> ,   ,         .   ,   ,        http-,          ,     . <br><br>          ,         .  ,        ,    .     ,   .  ,         . <br><br>                ,    . ,  ,    Hadoop    ,           ,     . <br><br>  ,  ,  Hadoop-    ,     ,         . <br><br>  ,  ,          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CleverDATA</a> .                      .  ,  ,     ,  ,    ,            .  ,            . <br><br><div class="spoiler"> <b class="spoiler_title">,      .</b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desarrollador de Java</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingeniero de sistemas</font></font></a> </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413141/">https://habr.com/ru/post/es413141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413129/index.html">25 errores de un programador novato</a></li>
<li><a href="../es413133/index.html">Antipatrones populares: paginaci√≥n</a></li>
<li><a href="../es413135/index.html">Asignaci√≥n de prueba de revisi√≥n de c√≥digo de desarrolladores junior react</a></li>
<li><a href="../es413137/index.html">Clasifique grandes cantidades de datos en Apache Spark utilizando modelos arbitrarios de aprendizaje autom√°tico</a></li>
<li><a href="../es413139/index.html">Coches el√©ctricos: se acerca la revoluci√≥n</a></li>
<li><a href="../es413143/index.html">Bobby Urban Lite: la nueva mochila urbana de XD Design</a></li>
<li><a href="../es413145/index.html">Analista ayuda a las empresas a ganar dinero</a></li>
<li><a href="../es413147/index.html">¬øEs posible usar Tibero en lugar de Oracle? Y es necesario</a></li>
<li><a href="../es413149/index.html">Almac√©n de datos distribuidos en el concepto de Data Lake: por d√≥nde empezar</a></li>
<li><a href="../es413151/index.html">La NSA propuso el est√°ndar de cifrado para dispositivos IoT, pero ISO lo rechaz√≥</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>