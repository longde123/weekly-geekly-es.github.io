<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕰️ ✊🏼 👩🏾‍🤝‍👨🏼 Clasifique grandes cantidades de datos en Apache Spark utilizando modelos arbitrarios de aprendizaje automático 🚳 👩🏿‍🚀 💝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 2: solución 
 Hola de nuevo Hoy continuaré mi historia sobre cómo clasificamos grandes cantidades de datos en Apache Spark utilizando modelos ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clasifique grandes cantidades de datos en Apache Spark utilizando modelos arbitrarios de aprendizaje automático</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/413141/"><h2>  Parte 2: solución </h2><br>  Hola de nuevo  Hoy continuaré mi historia sobre cómo clasificamos grandes cantidades de datos en Apache Spark utilizando modelos arbitrarios de aprendizaje automático.  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte del artículo,</a> examinamos la declaración del problema en sí, así como los principales problemas que surgen al organizar la interacción entre el clúster en el que se almacenan y procesan los datos iniciales, y el servicio de clasificación externo.  En la segunda parte, consideraremos una de las opciones para resolver este problema usando el enfoque Reactive Streams y su implementación usando la biblioteca akka-streams. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div><a name="habracut"></a><br><h3>  Concepto de corrientes reactivas </h3><br>  Para resolver los problemas descritos en la primera parte, puede usar el enfoque, llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Corrientes reactivas</a> .  Le permite controlar el proceso de transferencia de flujos de datos entre etapas de procesamiento, operando a diferentes velocidades e independientemente entre sí sin la necesidad de almacenamiento en búfer.  Si una de las etapas de procesamiento es más lenta que la anterior, entonces es necesario indicarle a la etapa más rápida cuántos datos de entrada están listos para procesar en este momento.  Esta interacción se llama contrapresión.  Consiste en el hecho de que las etapas más rápidas procesan exactamente tantos elementos como se requieren para la etapa más lenta, y no más, y luego liberan recursos informáticos. <br><br>  En general, Reactive Streams es una especificación para implementar la plantilla <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Publisher-Subscriber</a> .  Esta especificación define un conjunto de cuatro interfaces (editor, suscriptor, procesador y suscripción) y un contrato para sus métodos. <br><br>  Consideremos estas interfaces con más detalle: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Hay dos lados en el modelo de editor-suscriptor: transmitir y recibir.  Al implementar las secuencias reactivas, la clase que implementa la interfaz del editor es responsable de la transferencia de datos, y el suscriptor es responsable de la recepción.  Para establecer comunicación entre ellos, el suscriptor debe estar registrado con Publisher llamando a su método de suscripción.  Según la especificación, después de registrar un suscriptor, el editor debe llamar a sus métodos en el siguiente orden: <br><br><ol><li>  onSubscribe.  Este método se llama inmediatamente después de registrar al suscriptor con Publisher.  Como parámetro, se le pasa un objeto de Suscripción a través del cual el Suscriptor solicitará datos del Editor.  Este objeto debe almacenarse y llamarse solo en el contexto de este suscriptor. </li><li>  Después de que el Suscriptor haya solicitado datos del Editor llamando al método de solicitud en el objeto de Suscripción correspondiente, el Editor puede llamar al método Suscriptor onNext, pasando el siguiente elemento. </li><li>  El suscriptor puede llamar periódicamente al método de solicitud en la Suscripción, pero Publisher no puede llamar al método onNext más que el total solicitado a través del método de solicitud. </li><li>  Si el flujo de datos es finito, después de pasar todos los elementos a través del método onNext, Publisher debe llamar al método onComplete. </li><li>  Si se produjo un error en Publisher y el procesamiento posterior de los elementos no es posible, debe llamar al método onError </li><li>  Después de llamar a los métodos onComplete o onError, debe excluirse la interacción adicional del editor con el suscriptor. </li></ol><br>  Se puede considerar que las llamadas a métodos envían señales entre el publicador y el suscriptor.  El suscriptor le indica al editor cuántos elementos está listo para procesar, y el editor, a su vez, le indica que hay el siguiente elemento, que no hay más elementos o que se ha producido algún error. <br><br>  Para excluir otra influencia del publicador y del suscriptor entre sí, las llamadas a todos los métodos que implementan las interfaces de Reactive Streams deben ser sin bloqueo.  En este caso, la interacción entre ellos será completamente asíncrona. <br><br>  Puede encontrar más detalles sobre la especificación para las interfaces de Reactive Streams <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Por lo tanto, al vincular los iteradores originales y resultantes mediante la conversión a Publicador y Suscriptor, respectivamente, podemos resolver los problemas identificados en la parte anterior del artículo.  El problema del desbordamiento del búfer entre etapas se resuelve solicitando un cierto número de elementos por el suscriptor.  El problema de la finalización exitosa o incorrecta se resuelve enviando señales al suscriptor a través de los métodos onComplete u onError, respectivamente.  El editor se hace responsable del envío de estas señales, que en nuestro caso deben controlar cuántas solicitudes HTTP se enviaron y cuántas de ellas recibieron respuestas.  Después de recibir la última respuesta y procesar todos los resultados que se obtuvieron, debe enviar una señal onComplete.  En caso de que una de las solicitudes fallara, debería enviar una señal onError y dejar de enviar más elementos al suscriptor, así como restar elementos del iterador original. <br><br>  El iterador resultante debe implementarse como un suscriptor.  En este caso, no podemos prescindir de un búfer en el que los elementos se escribirán cuando se llame al método onNext desde la interfaz del suscriptor y se reste utilizando los métodos hasNext y next de la interfaz Iterator.  Como implementación de búfer, puede usar una cola de bloqueo, por ejemplo, LinkedBlockedQueue. <br><br>  Un lector atento hará inmediatamente la pregunta: ¿por qué es la cola de bloqueo, porque de acuerdo con la especificación de Reactive Streams, la implementación de todos los métodos debe ser sin bloqueo?  Pero todo está bien aquí: dado que le estamos pidiendo a Publisher un número estrictamente definido de elementos, el método onNext no se llamará más de este número de veces, y la cola siempre puede agregar un nuevo elemento sin bloquear. <br><br>  Por otro lado, el bloqueo puede ocurrir cuando se llama al método hasNext en caso de una cola vacía.  Sin embargo, esto está bien: el método hasNext no forma parte del contrato de la interfaz del suscriptor, se define en la interfaz Iterator, que, como explicamos anteriormente, es una estructura de datos de bloqueo.  Al llamar al siguiente método, restamos el siguiente elemento de la cola, y cuando su tamaño se vuelve menor que un cierto umbral, necesitaremos solicitar la siguiente porción de los elementos a través de una llamada al método de solicitud. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/xy/8t/tzxy8tn05km8fox0bkwk_zsxvcg.png" width="650"></div>  <i>Figura 7. Interacción asincrónica con un servicio externo utilizando el enfoque de Reactive Streams</i> <br><br>  Por supuesto, en este caso no eliminaremos por completo el bloqueo de llamadas.  Esto se debe a una falta de coincidencia de paradigmas entre las secuencias reactivas, que suponen una interacción completamente asincrónica, y un iterador, que debe llamar a trueN o false al llamar al método hasNext.  Sin embargo, a diferencia de la interacción síncrona con un servicio externo, el tiempo de inactividad debido a bloqueos puede reducirse significativamente al aumentar la carga general de los núcleos del procesador. <br><br>  Sería conveniente que los desarrolladores de Apache Spark en futuras versiones implementaran un análogo del método mapPartitions, que funciona con Publisher y Subscriber.  Esto permitiría una interacción completamente asincrónica, eliminando así la posibilidad de bloquear hilos. <br><br><h3>  Akka-streams y akka-http como implementación de la especificación Reactive Streams </h3><br>  Actualmente, ya hay más de una docena de implementaciones de la especificación Reactive Streams.  Una de esas implementaciones es el módulo akka-streams de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">akka</a> .  En el mundo de JVM, Akka se ha establecido como uno de los medios más efectivos para escribir sistemas paralelos y distribuidos.  Esto se logra debido al hecho de que el principio básico establecido en su base es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el modelo de actor</a> , que le permite escribir aplicaciones altamente competitivas sin el control directo de los hilos y sus grupos. <br><br>  Se ha escrito mucha literatura sobre la implementación del concepto de actores en akka, por lo que no nos detendremos aquí (el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio oficial de akka</a> es una muy buena fuente de información, también recomiendo el libro de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acción de akka</a> ).  Aquí veremos más de cerca el lado tecnológico de la implementación bajo la JVM. <br><br>  En general, los actores no existen por sí mismos, sino que forman un sistema jerárquico.  Para crear un sistema de actor, debe asignar recursos para él, por lo que el primer paso al trabajar con akka es crear una instancia del objeto ActorSystem.  Cuando se inicia ActorSystem, se crea un grupo separado de subprocesos, denominado despachador, en el que se ejecuta todo el código definido en los actores.  Típicamente, un solo hilo ejecuta el código de múltiples actores, sin embargo, si es necesario, puede configurar un despachador separado para un grupo específico de actores (por ejemplo, para actores que interactúan directamente con una API de bloqueo). <br><br>  Una de las tareas más comunes resueltas usando actores es el procesamiento secuencial de flujos de datos.  Anteriormente, para esto, era necesario construir manualmente cadenas de actores y asegurarse de que no hubiera cuellos de botella entre ellos (por ejemplo, si un actor procesa los mensajes más rápido que el siguiente, entonces puede tener un desbordamiento de la cola de mensajes entrantes, lo que lleva a un error OutOfMemoryError). <br><br>  A partir de la versión 2.4, se agregó el módulo akka-streams a akka, que le permite definir declarativamente el proceso de procesamiento de datos y luego crear los actores necesarios para su ejecución.  Akka-streams también implementa el principio de contrapresión, que elimina la posibilidad de desbordar la cola de mensajes entrantes para todos los actores involucrados en el procesamiento. <br><br>  Los elementos principales para definir el esquema de procesamiento del flujo de datos en los flujos de akka son Source, Flow y Sink.  Al combinarlos entre sí, obtenemos un gráfico ejecutable.  Para comenzar el proceso de procesamiento, se utiliza un materializador, que crea actores que trabajan de acuerdo con el gráfico definido por nosotros (la interfaz del Materializador y su implementación ActorMaterializer). <br><br>  Consideremos las etapas Fuente, Flujo y Sumidero con más detalle.  Fuente define la fuente de datos.  Akka-streams admite más de una docena de formas diferentes de crear fuentes, incluso desde un iterador: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> featuresSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">Float</span></span>], <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator { () =&gt; featuresIterator }</code> </pre><br>  La fuente también se puede obtener convirtiendo una fuente existente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = source.map(item =&gt; transform(item))</code> </pre> <br>  Si la transformación es una operación no trivial, se puede representar como una entidad Flow.  Akka-streams admite muchas formas diferentes de crear Flow.  La forma más fácil es crear desde una función: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Flow</span></span>.fromFunction((x: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; x.length)</code> </pre> <br>  Al combinar Source y Flow, obtenemos una nueva Fuente. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = oldSource.via(someFlow)</code> </pre> <br>  El sumidero se utiliza como la etapa final del procesamiento de datos.  Como en el caso de Source, akka-streams proporciona más de una docena de opciones diferentes de Sink, por ejemplo, Sink.foreach realiza una determinada operación para cada elemento, Sink.seq recopila todos los elementos de una colección, etc. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> printSink: <span class="hljs-type"><span class="hljs-type">Sink</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>, <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = <span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println)</code> </pre> <br>  Fuente, flujo y sumidero se parametrizan por los tipos de elementos de entrada y / o salida, respectivamente.  Además, cada etapa de procesamiento puede tener algún resultado de su trabajo.  Para esto, Source, Flow y Sink también se parametrizan mediante un tipo adicional que determina el resultado de la operación.  Este tipo se llama el tipo de valor materializado.  Si la operación no implica la presencia de un resultado adicional de su trabajo, por ejemplo, cuando definimos Flujo a través de una función, entonces el tipo NotUsed se usa como el valor materializado. <br><br>  Combinando la fuente, el flujo y el sumidero necesarios, obtenemos RunnableGraph.  Está parametrizado por un tipo, que determina el tipo de valor obtenido como resultado de la ejecución de este gráfico.  Si es necesario, al combinar las etapas, puede especificar el resultado de cuál de las etapas será el resultado de toda la gráfica de operaciones.  Por defecto, se toma el resultado de la etapa Fuente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = someSource.to(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))</code> </pre> <br>  Sin embargo, si el resultado de la etapa Sink es más importante para nosotros, entonces debemos indicarlo explícitamente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = someSource.toMat(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))(<span class="hljs-type"><span class="hljs-type">Keep</span></span>.right)</code> </pre><br>  Después de haber definido el gráfico de operaciones, debemos ejecutarlo.  Para hacer esto, runnableGraph necesita llamar al método de ejecución.  Como parámetro, este método toma un objeto ActorMaterializer (que también puede estar en un alcance implícito), que es responsable de crear actores que realizarán operaciones.  Por lo general, un ActorMaterializer se crea inmediatamente después de la creación de un ActorSystem, adjunto a su ciclo de vida, y lo utiliza para crear actores.  Considere un ejemplo: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   ActorSystem,       implicit val system = ActorSystem(“system name”) // ,       ActorSystem implicit val materializer = ActorMaterializer() //    ,       Sink val graph: RunnableGraph[Future[immutable.Seq[Int]]] = Source.fromIterator(() =&gt; (1 to 10).iterator).toMat(Sink.seq)(Keep.right) //   ,    implicit scope. val result: Future[immutable.Seq[Int]] = graph.run()</span></span></code> </pre><br>  En el caso de combinaciones simples, puede hacerlo sin crear un RunnableGraph separado, sino simplemente conectar Source a Sink e iniciarlos llamando al método runWith en Source.  Este método también supone que un objeto ActorMaterializer está presente en el ámbito implícito.  Además, en este caso, se utilizará el valor materializado definido en Sink.  Por ejemplo, usando el siguiente código, podemos convertir Source a Publisher desde la especificación Reactive Streams: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator(() =&gt; sourceIterator).map(item =&gt; transform(item)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> publisher: <span class="hljs-type"><span class="hljs-type">Publisher</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>] = source.runWith(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.asPublisher(<span class="hljs-literal"><span class="hljs-literal">false</span></span>))</code> </pre><br>  Entonces, ahora hemos mostrado cómo puede obtener Reactive Streams Publisher creando una Fuente desde el iterador de fuente y realizando algunas transformaciones en sus elementos.  Ahora podemos asociarlo con un suscriptor que suministre datos al iterador resultante.  Queda por considerar la última pregunta: cómo organizar la interacción HTTP con un servicio externo. <br><br>  La estructura de akka incluye el módulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://doc.akka.io/docs/akka-">akka-http</a> , que le permite organizar la comunicación asincrónica sin bloqueo a través de HTTP.  Además, este módulo está construido sobre la base de flujos de akka, lo que le permite agregar interacción HTTP como un paso adicional en el gráfico de las operaciones de procesamiento de flujo de datos. <br><br>  Para conectarse a servicios externos, akka-http proporciona tres interfaces diferentes. <br><br><ol><li>  API de nivel de solicitud: es la opción más simple para el caso de solicitudes individuales a una máquina arbitraria.  En este nivel, las conexiones HTTP se gestionan de forma completamente automática, y en cada solicitud es necesario transferir la dirección completa de la máquina a la que se dirige la solicitud. </li><li>  API de nivel de host: adecuada cuando sabemos a qué puerto en qué máquina accederemos.  En este caso, akka-http toma el control del conjunto de conexiones HTTP, y en las solicitudes es suficiente para especificar la ruta relativa al recurso solicitado. </li><li>  API de nivel de conexión: le permite obtener un control total sobre la administración de las conexiones HTTP, es decir, abrir, cerrar y distribuir solicitudes entre conexiones. </li></ol><br>  En nuestro caso, la dirección del servicio de clasificación la conocemos de antemano, por lo tanto, es necesario organizar la interacción HTTP solo con esta máquina en particular.  Por lo tanto, la API de nivel de host es la mejor para nosotros.  Ahora, veamos cómo se crea el grupo de conexiones HTTP cuando se usa: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[(<span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>,<span class="hljs-type"><span class="hljs-type">Id</span></span>), (<span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">HttpResponse</span></span>],<span class="hljs-type"><span class="hljs-type">Id</span></span>), <span class="hljs-type"><span class="hljs-type">Http</span></span>.<span class="hljs-type"><span class="hljs-type">HostConnectionPool</span></span>] = <span class="hljs-type"><span class="hljs-type">Http</span></span>().cachedHostConnectionPool[<span class="hljs-type"><span class="hljs-type">Id</span></span>](hostAddress, portNumber)</code> </pre><br>  Al llamar a Http (). CachedHostConnectionPool [T] (hostAddress, portNumber) en el ActorSystem, que está en un ámbito implícito, los recursos se asignan para crear un grupo de conexiones, pero las conexiones en sí no están establecidas.  Como resultado de esta llamada, se devuelve Flow, que recibe un par de una solicitud HTTP y algún objeto de identificación Id como entrada.  El objeto de identificación es necesario para hacer coincidir la solicitud con la respuesta correspondiente debido al hecho de que la llamada HTTP en akka-http es una operación asincrónica, y el orden en que se reciben las respuestas no corresponde necesariamente al orden en que se envían las solicitudes.  Por lo tanto, en la salida, Flow da un par del resultado de la consulta y el objeto de identificación correspondiente. <br><br>  Directamente, las conexiones HTTP se establecen cuando se inicia (materializa) un gráfico (incluido este Flujo).  Akka-http se implementa de tal manera que no importa cuántas veces se hayan materializado los gráficos que contienen httpFlow, dentro de un ActorSystem siempre habrá un grupo común de conexiones HTTP que serán utilizadas por todas las materializaciones.  Esto le permite controlar mejor el uso de los recursos de la red y evitar sobrecargarlos. <br><br>  Por lo tanto, el ciclo de vida del grupo de conexiones HTTP está vinculado al ActorSystem.  Como ya se mencionó, también se adjunta el ciclo de vida del grupo de subprocesos, en el que se realizan las operaciones definidas en los actores (o en nuestro caso, definidas como las etapas akka-streams y akka-http).  Por lo tanto, para lograr la máxima eficiencia, debemos reutilizar una instancia de ActorSystem dentro del mismo proceso JVM. <br><br><h3>  Poniendo todo esto junto: un ejemplo de implementación de interacción con el servicio de clasificación </h3><br>  Entonces, ahora podemos pasar al proceso de clasificar grandes volúmenes de datos distribuidos en Apache Spark utilizando la interacción asincrónica con servicios externos.  El esquema general de esta interacción ya se ha mostrado en la Figura 7. <br><br>  Supongamos que tenemos un conjunto de datos inicial [Características] definido.  Al aplicarle la operación mapPartitions, deberíamos obtener un conjunto de datos, en el que cada identificación del conjunto fuente se estampa con un cierto valor obtenido como resultado de la clasificación (conjunto de datos [puntuación]).  Para organizar el procesamiento asincrónico en los ejecutores, debemos ajustar los iteradores de origen y resultantes en Publisher y Subscriber, respectivamente, de la especificación de flujos reactivos y vincularlos. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Features</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Score</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, score: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">batchesRequestCount</span></span></span><span class="hljs-class"> </span></span>= config.getInt(“scoreService. batchesRequestCount”)<span class="hljs-comment"><span class="hljs-comment">//(2) //... val scoreDs: Dataset[Score] = featuresDs.mapPartitions { fi: Iterator[Features] =&gt; val publisher: Publisher[Iterable[Score]] = createPublisher(fi) //(3) val iteratorSubscriber: Iterator[Score] = new IteratorSubscriber(batchesRequestCount) //(4) publisher.subscribe(batchesRequestCount) //(5) iteratorSubscriber //(6) }</span></span></code> </pre> <br>  En esta implementación, se tiene en cuenta que el servicio de clasificación para una llamada puede procesar un grupo de vectores de características a la vez, por lo tanto, el resultado de la clasificación después de una llamada también estará disponible de inmediato para todo el grupo.  Por lo tanto, como un tipo de parámetro para Publisher, no solo tenemos Score, como es de esperar, sino Iterable [Score].  Por lo tanto, enviamos los resultados de clasificación para este grupo al iterador resultante (que también es un Suscriptor) mediante una sola llamada al método onNext.  Esto es mucho más eficiente que llamar a Next para cada elemento.  Ahora analizaremos este código con más detalle. <br><br><ol><li>  Determinamos la estructura de los datos de entrada y salida.  Como entrada, tendremos un grupo de algunos identificadores con un vector de características, y como salida, tendremos un grupo de identificadores con un valor numérico obtenido como resultado de la clasificación. </li><li>  Determinamos el número de grupos que el suscriptor solicitará al editor a la vez.  Dado que se supone que estos valores permanecerán en el búfer y esperarán hasta que se lean desde el iterador resultante, este valor depende de la cantidad de memoria asignada al ejecutor. </li><li>  Crear editor desde el iterador de origen.  Será responsable de interactuar con el servicio de clasificación.  La función createPublisher se analiza a continuación. </li><li>  Cree un suscriptor, que será el iterador resultante.  El código de clase IteratorSubscriber también se proporciona a continuación. </li><li>  Registro de suscriptor con Publisher. </li><li>  Devuelve IteratorSubscriber como resultado de la operación mapPartitions. </li></ol><br>  Ahora considere la implementación de la función createPublisher. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ids</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-comment"><span class="hljs-comment">//(1) val batchSize = config.getInt("scoreService.batchSize") val parallelismLevel = config.getInt("scoreService.parallelismLevel") //(2) //... def createPublisher(fi: Iterator[Features]): Publisher[Iterable[Score]] = { import ActorSystemHolder._ //(3) Source .fromIterator(() =&gt; fi) //(4) .grouped(batchSize) //(5) .map { groupedFeatures: Seq[Features] =&gt; val request: (HttpRequest, Ids) = createHttpRequest(groupedFeatures) //(6) logger.debug(s"Sending request for the first id: ${request._2(0)}") request } .via(httpFlow) //(7) .flatMapMerge(parallelismLevel, { //(8) case (Success(response), ids) if response.status.isSuccess() =&gt; logger.debug(s"Processing successful result for the first id: ${ids(0)}") val resultSource: Source[Iterable[Score], _] = response.entity.dataBytes.reduce(_ ++ _).map { responseBytes =&gt; processSuccessfulResponse(responseBytes, ids) } //(9) resultScore case (Success(response), ids) =&gt; logger.warn( s"Failed result for the first id: ${ids(0)}, HTTP status: ${response.status}" ) response.discardEntityBytes() Source.failed( new IOException(s"Non-successful HTTP status: ${response.status}") ) //(10) case (Failure(ex), ids) =&gt; logger.warn(s"Failed result: an exception has occured", ex) Source.failed(ex) //(11) }) .runWith(Sink.asPublisher(false)) //(12) } def createHttpRequest(featuresSeq: Seq[Features]): (HttpRequest, ProfileIds) = { val requestBytes: Array[Byte] = featuresToMatrixBytes(featuresSeq) val ids: ProfileIds = extractIds(featuresSeq) val httpRequest = HttpRequest( method = HttpMethods.PUT, uri = "/score", entity = requestBytes ) httpRequest -&gt; ids }</span></span></code> </pre><br><ol><li>    -   ,   .         httpFlow,           . </li><li>     :     ,     (batchSize)        (parallelismLevel). </li><li>   implicit scope ActorSystem, ActorMaterializer  httpFlow.        Spark-.  ActorSystemHolder    . </li><li>     akka-streams   .     Source[Features]   . </li><li>            batchSize       . </li><li>     HttpRequest       .   HttpRequest      createHttpRequest.      createPublisher.      feature-,   ,      (            predict).       ,      HTTP-.      ,   HTTP-,    HTTP-, URI      . </li><li>        httpFlow. </li><li>     ,   .      flatMapMerge,        akka-http    Source[ByteString],      ,       .           .  parallelismLevel ,      (     ).      HTTP-:   ,  ,  ,   . </li><li>       :          .      akka    ByteString.    ,    ByteString    O(1),    ByteString        .       ,    ,         .                ,     . </li><li>       HTTP-     ,  Stream .         ,      discardEntityBytes    ,    ,  . </li><li>         .      akka-http    ,       . </li><li>       ,    Publisher,     .    ,    .  false   Sink.asPublisher ,   Publisher    Subscriber-. </li></ol><br>      ,    akka  ActorSystem,        .  ,        Spark ,          .   Spark    JVM , ,        ,     ActorSystem    ActorMatrializer  httpFlow. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActorSystemHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actorSystem: <span class="hljs-type"><span class="hljs-type">ActorSystem</span></span> = { <span class="hljs-comment"><span class="hljs-comment">//(1) val actorSystemName = s"score-service-client" logger.debug(s"Creating actor system $actorSystemName") val as = ActorSystem(actorSystemName) //(2) logger.debug("Adding shutdown hook for the actor system") scala.sys.addShutdownHook { //(3) logger.debug(s"Terminating actor system $actorSystemName") Await.result(as.terminate(), 30.seconds) //to Mars :) logger.debug(s"The actor system $actorSystemName has been terminated") } as } implicit lazy val materializer: ActorMaterializer = { //(4) logger.debug(s"Creating actor materializer for actor system ${actorSystem.name}") ActorMaterializer() } lazy val httpFlow: Flow[ (HttpRequest,ProfileIds), (Try[HttpResponse], ProfileIds), Http.HostConnectionPool] = { //(5) val httpFlowSettings = ConnectionPoolSettings(actorSystem) logger.debug(s"Creating http flow with settings $httpFlowSettings") Http().cachedHostConnectionPool[ProfileIds]( config.getString("scoreService.host"), config.getInt("scoreService.int"), settings = httpFlowSettings ) } }</span></span></code> </pre><br><ol><li>     ,   ,       ,     . </li><li>    ActorSystem   . </li><li>  ,     ,    ActorSystem,       terminate, ,   ,   ,     .      ,     JVM-. </li><li>    ActorMaterializer,      akka-streams,   ActorSystem. </li><li> ,   httpFlow     .      ,       HTTP-   ActorSystem. </li></ol><br>       Subscriber-    HTTP-. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">item: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Done</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamErrorCompletionException</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">2</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorSubscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">requestSize: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Iterable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//(3) private val buffer: BlockingQueue[QueueItem[Iterable[T]]] = new LinkedBlockingQueue[QueueItem[Iterable[T]]]() //(4) private var expecting: Int = 0 //(5) private val subscriptionPromise: Promise[Subscription] = Promise() private lazy val subscription: Subscription = Await.result(subscriptionPromise.future, 5.minutes) //(6) private var currentIterator: Iterator[T] = Iterator.empty //(7) private var isDone = false //(8) override def onSubscribe(s: Subscription): Unit = { subscriptionPromise.success(s) //(9) logger.trace("The iterator has been subscribed") } override def onNext(t: Iterable[T]): Unit = { logger.trace("Putting a next batch to the buffer") buffer.put(Item(t)) //(10) } override def onComplete(): Unit = { logger.debug("The stream has been succesfully completed") buffer.put(Done) //(11) } override def onError(t: Throwable): Unit = { logger.warn("The stream has been completed with error", t) buffer.put(Failure(t)) //(12) } override def hasNext: Boolean = { logger.trace("Asking hasNext") if (currentIterator.hasNext) { //(13) true } else if (isDone) { //(14) false } else { if (expecting &lt; requestSize) { requestNextBatches() //(15) } buffer.take() match { //(16) case Item(batch) =&gt; currentIterator = batch.iterator expecting -= 1 this.hasNext //(17) case Done =&gt; isDone = true false //(18) case Failure(exception) =&gt; throw new StreamErrorCompletionException(exception) //(19) } } } override def next(): T = { val out = currentIterator.next() logger.trace("The next element is {}", out) out //(20) } private def requestNextBatches(): Unit = { logger.debug(s"Requesting {} batches", requestSize) subscription.request(requestSize) expecting += requestSize //(21) } }</span></span></code> </pre><br>  IteratorSubscriber    Producer-Consumer.   ,    Subscriber,  Producer-,  ,   Iterator, – Consumer-.      ,     .    Iterator       Apache Spark,    Subscriber –  ,  ActorSystem. <br><br>      IteratorSubscriber  . <br><br><ol><li>          .          ,     Done,    ,  Throwable,    . </li><li>      ,        hasNext    . </li><li>  ,    ,        Publisher-. </li><li>    ,     .    LinkedBlockingQueue,      . ,         . </li><li>     ,    .     ,         ,       Publisher-.   ,    ,      Publisher-   .         hasNext  next ( requestNextBatches    hasNext),       ,       . </li><li>  subscriptionPromise  subscription     Subscription,    Publisher    onSubscribe. ,    Reactive Streams        Subscriber-  Publisher-     ,   ,   hasNext   ,  onSubscribe.      ,     subscription,          Publisher-.     lazy   subscription,    Promise. </li><li>       .          hasNext  next,     ,       . </li><li>     ,        ,  hasNext   false     .           hasNext,         . </li><li>    onSubscribe    Publisher-  Subscription    Promise,        subscription. </li><li> onNext  Publisher-,        .      . </li><li>       Publisher   onComplete,          Done. </li><li>    Publisher   onError.       . </li><li>    hasNext     ,      .      ,    true,       .     ,         . </li><li>        ,            false. </li><li>  ,   ,        requestSize,       Publisher.         ,    ,     ,   Publisher-    ,   HTTP-     . </li><li>        .  ,   ,      ,      .  ,       ,     (  ,    ,        subscription), ,     ,   ,      . </li><li>       ,           currentIterator.        ,          . ,       hasNext  ,         (    ,   ),        . </li><li>     ,    false        hasNext. ,     isDone,   ,     .   - ,   hasNext        ,         false.        ,       hasNext  ,    false      ,      .          ,      . </li><li>        ,    ,     ,     . </li><li>  next      .    ,        hasNext,    next        . </li><li>     Publisher-  ,       ,   subscription,       Publisher-.     requestSize.         . </li></ol><br>  ,       ,   ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div> <i> 8.       .</i> <br><br><h3>  :      </h3><br>      ,        ,      .     ,       HTTP ,      .         . <br><br>    –         .    ,     ,       Hadoop ,      .  ,    ,       -       .     ,  ,   hdfs, ,          , ,       . <br><br>  ,         . ,   akka-http              ,         .   ,      -,       -       Apache Spark ,       ,  ,    -. <br><br> ,   ,         .   ,   ,        http-,          ,     . <br><br>          ,         .  ,        ,    .     ,   .  ,         . <br><br>                ,    . ,  ,    Hadoop    ,           ,     . <br><br>  ,  ,  Hadoop-    ,     ,         . <br><br>  ,  ,          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CleverDATA</a> .                      .  ,  ,     ,  ,    ,            .  ,            . <br><br><div class="spoiler"> <b class="spoiler_title">,      .</b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desarrollador de Java</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingeniero de sistemas</font></font></a> </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413141/">https://habr.com/ru/post/es413141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413129/index.html">25 errores de un programador novato</a></li>
<li><a href="../es413133/index.html">Antipatrones populares: paginación</a></li>
<li><a href="../es413135/index.html">Asignación de prueba de revisión de código de desarrolladores junior react</a></li>
<li><a href="../es413137/index.html">Clasifique grandes cantidades de datos en Apache Spark utilizando modelos arbitrarios de aprendizaje automático</a></li>
<li><a href="../es413139/index.html">Coches eléctricos: se acerca la revolución</a></li>
<li><a href="../es413143/index.html">Bobby Urban Lite: la nueva mochila urbana de XD Design</a></li>
<li><a href="../es413145/index.html">Analista ayuda a las empresas a ganar dinero</a></li>
<li><a href="../es413147/index.html">¿Es posible usar Tibero en lugar de Oracle? Y es necesario</a></li>
<li><a href="../es413149/index.html">Almacén de datos distribuidos en el concepto de Data Lake: por dónde empezar</a></li>
<li><a href="../es413151/index.html">La NSA propuso el estándar de cifrado para dispositivos IoT, pero ISO lo rechazó</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>