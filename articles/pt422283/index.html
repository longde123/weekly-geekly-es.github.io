<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍✈️ 🧓 🖖🏽 Teste da caixa branca 🧔🏽 ⤵️ 👩🏿‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O desenvolvimento de programas de alta qualidade implica que o programa e suas partes sejam testados. O teste de unidade clássico envolve dividir um p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teste da caixa branca</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422283/"><p>  O desenvolvimento de programas de alta qualidade implica que o programa e suas partes sejam testados.  O teste de unidade clássico envolve dividir um programa grande em pequenos blocos convenientes para o teste.  Ou, se o desenvolvimento de testes ocorrer paralelamente ao desenvolvimento de código ou se os testes forem desenvolvidos antes do programa (TDD - test driven development), o programa será inicialmente desenvolvido em pequenos blocos adequados para os requisitos dos testes. </p><br><p>  Uma das variedades de teste de unidade pode ser considerada teste baseado em propriedade (essa abordagem é implementada, por exemplo, nas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bibliotecas QuickCheck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ScalaCheck</a> ).  Essa abordagem é baseada na localização de propriedades universais que devem ser válidas para qualquer dado de entrada.  Por exemplo, a <em>serialização seguida pela desserialização deve produzir o mesmo objeto</em> .  Ou <em>re-classificar não deve alterar a ordem dos itens na lista</em> .  Para verificar essas propriedades universais, as bibliotecas acima suportam um mecanismo para gerar dados de entrada aleatórios.  Essa abordagem funciona especialmente bem para programas baseados em leis matemáticas que servem como propriedades universais válidas para uma ampla classe de programas.  Existe até uma biblioteca de propriedades matemáticas prontas - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">disciplina</a> - que permite verificar o desempenho dessas propriedades em novos programas (um bom exemplo de reutilização de testes). </p><br><p>  Às vezes, é necessário testar um programa complexo sem poder analisá-lo em partes verificáveis ​​de forma independente.  Nesse caso, o programa de teste é <del>  preto </del>  caixa branca (branca - porque temos a oportunidade de estudar a estrutura interna do programa). </p><br><p>  Sob o corte, são descritas várias abordagens para testar programas complexos com uma entrada com graus variados de complexidade (envolvimento) e graus variados de cobertura. </p><a name="habracut"></a><br><p>  * <em>Neste artigo, assumimos que o programa em teste pode ser representado como uma função pura sem um estado interno.</em>  <em>(Algumas das considerações fornecidas abaixo podem ser aplicadas se o estado interno estiver presente, mas é possível redefinir esse estado para um valor fixo.)</em> </p><br><h3 id="testovyy-stend-test-bench">  Banco de ensaio </h3><br><p> Antes de tudo, como apenas uma função é testada, cujo código de chamada é sempre o mesmo, não precisamos criar testes de unidade separados.  Todos esses testes seriam os mesmos, precisos para as entradas e verificações.  É o suficiente para transmitir os dados de origem ( <code>input</code> ) em um loop e verificar os resultados (resultado <code>expectedOutput</code> ).  Para identificar um conjunto de problemas de dados de teste em caso de detecção de erros, todos os dados de teste devem ser rotulados.  Assim, um conjunto de dados de teste pode ser representado como um triplo: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expectedOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  O resultado de uma execução pode ser representado como <code>TestCaseResult</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseResult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">testCase: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TestCase</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">], actualOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Try</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  (Apresentamos o resultado do lançamento usando o <code>Try</code> para capturar possíveis exceções.) </p><br><p>  Para simplificar a execução de todos os dados de teste através do programa em teste, você pode usar uma função auxiliar que chamará o programa para cada valor de entrada: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCases</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](cases: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCase</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]] = cases .map{ testCase =&gt; <span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>(testCase, <span class="hljs-type"><span class="hljs-type">Try</span></span>{ f(testCase.input) } ) } .filter(r =&gt; r.actualOutput != <span class="hljs-type"><span class="hljs-type">Success</span></span>(r.testCase.expectedOutput))</code> </pre> <br><p>  Essa função auxiliar retornará os dados e resultados problemáticos diferentes do esperado. </p><br><p>  Por conveniência, você pode formatar os resultados do teste. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span></span>(results: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[_, _]]): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"Failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${results.length}</span></span></span><span class="hljs-string">:\n"</span></span> + results .map(r =&gt; r.testCase.label + <span class="hljs-string"><span class="hljs-string">": expected "</span></span> + r.testCase.expectedOutput + <span class="hljs-string"><span class="hljs-string">", but got "</span></span> + r.actualOutput) .mkString(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><p>  e exiba um relatório apenas em caso de erros: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) test(<span class="hljs-string"><span class="hljs-string">"all test cases"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testBench = runTestCases(testCases) _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> results = testBench(f) assert(results.isEmpty, report(results)) }</code> </pre> <br><h3 id="podgotovka-vhodnyh-dannyh">  Preparação de entrada </h3><br><p>  No caso mais simples, você pode criar dados de teste manualmente para testar o programa, gravá-los diretamente no código de teste e usá-los, como mostrado acima.  Muitas vezes acontece que casos interessantes de dados de teste têm muito em comum e podem ser apresentados como uma instância básica, com pequenas alterações. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = <span class="hljs-type"><span class="hljs-type">MyObject</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//        val testCases = Seq( TestCase("baseline", baseline, ???), TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???) )</span></span></code> </pre> <br><p>  Ao trabalhar com estruturas de dados imutáveis ​​aninhadas, as lentes são de grande ajuda, por exemplo, na biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monocle</a> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testObject1 = (field1 composeLens field2).set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline) <span class="hljs-comment"><span class="hljs-comment">//    : val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))</span></span></code> </pre> <br><p>  As lentes permitem que você "modifique" elegantemente partes profundamente aninhadas das estruturas de dados: cada lente é um método de obtenção e configuração de uma propriedade.  As lentes podem ser combinadas para produzir lentes que "focam" no próximo nível. </p><br><h3 id="ispolzovanie-dsl-dlya-predstavleniya-izmeneniy">  Usando DSL para apresentar alterações </h3><br><p>  A seguir, consideraremos a formação dos dados de teste fazendo alterações em algum objeto de entrada inicial.  Normalmente, para obter o objeto de teste de que precisamos, precisamos fazer algumas alterações.  Ao mesmo tempo, é muito útil incluir uma lista de alterações na descrição de texto do TestCase: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline"</span></span>, baseline, ???), <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline + "</span></span> + <span class="hljs-string"><span class="hljs-string">"(field1 = 123) + "</span></span> + <span class="hljs-comment"><span class="hljs-comment">//  1-  "(field2 = 456) + " + // 2- "(field3 = 789)", // 3- baseline .copy(field1 = "123") // 1-  .copy(field2 = "456") // 2-  .copy(field3 = "789"), // 3-  ???) )</span></span></code> </pre> <br><p>  Sempre saberemos para quais dados de teste o teste é realizado. </p><br><p>  Para que a lista textual de alterações não diverja das mudanças reais, você deve seguir o princípio de "uma única versão da verdade".  (Se as mesmas informações forem necessárias / usadas em vários pontos, deve haver uma única fonte primária de informações exclusivas, e as informações devem ser distribuídas automaticamente para todos os outros pontos de uso, com as transformações necessárias. Se esse princípio for violado, a cópia manual de informações será inevitável. . informações sobre a versão discrepância em pontos diferentes em outras palavras na descrição dos dados de teste, vemos um, e dados de ensaios -. outro exemplo, copiar uma mudança <code>field2 = "456"</code> e ajustando-o na <code>field3 = "789"</code> que Mauger  acidentalmente esquecer de corrigir a descrição. Como resultado, a descrição só irá refletir duas mudas de três.) </p><br><p>  No nosso caso, a principal fonte de informação são as próprias alterações, ou melhor, o código-fonte do programa que faz as alterações.  Gostaríamos de deduzir deles um texto descrevendo as alterações.  De antemão, como primeira opção, você pode sugerir o uso de uma macro que irá capturar o código fonte das alterações e usar o código fonte como documentação.  Aparentemente, essa é uma maneira boa e relativamente simples de documentar mudanças reais e pode muito bem ser aplicada em alguns casos.  Infelizmente, se apresentarmos as alterações no texto sem formatação, perderemos a capacidade de fazer transformações significativas na lista de alterações.  Por exemplo, detecte e elimine alterações duplicadas ou sobrepostas, elabore uma lista de alterações de maneira conveniente para o usuário final. </p><br><p>  Para poder lidar com as mudanças, você deve ter um modelo estruturado delas.  O modelo deve ser expressivo o suficiente para descrever todas as mudanças que nos interessam.  Parte deste modelo, por exemplo, será o endereçamento de campos de objetos, constantes e operações de atribuição. </p><br><p>  O modelo de mudança deve permitir resolver as seguintes tarefas: </p><br><ol><li>  Gerar instâncias de modelo de mudança.  (Ou seja, na verdade, criando uma lista específica de alterações.) </li><li>  Formação de uma descrição textual das alterações. </li><li>  Aplicando alterações nos objetos do domínio. </li><li>  Executando transformações de otimização no modelo. </li></ol><br><p>  Se uma linguagem de programação universal for usada para fazer alterações, pode ser difícil representar essas alterações no modelo.  O código fonte do programa pode usar construções complexas que não são suportadas pelo modelo.  Esse programa pode usar padrões secundários, como lentes ou o método de <code>copy</code> , para alterar os campos de um objeto, que são abstrações de nível inferior em relação ao nível do modelo de mudança.  Como resultado, análises adicionais de tais padrões podem ser necessárias para gerar instâncias de alterações.  Portanto, inicialmente uma boa opção usando uma macro não é muito conveniente. </p><br><p>  Outra maneira de criar instâncias do modelo de mudança pode ser uma linguagem especializada (DSL), que cria objetos do modelo de mudança usando um conjunto de métodos de extensão e operadores auxiliares.  Bem, nos casos mais simples, instâncias do modelo de mudança podem ser criadas diretamente através dos construtores. </p><br><div class="spoiler">  <b class="spoiler_title">Alterar detalhes do idioma</b> <div class="spoiler_text"><p>  A linguagem de mudança é uma construção bastante complexa que inclui vários componentes, que são, por sua vez, não triviais. </p><br><ol><li>  Modelo de estrutura de dados. </li><li>  Alterar modelo. </li><li>  DSL atualmente incorporado (?) - construções auxiliares, métodos de extensão, para a construção conveniente de alterações. </li><li>  Um intérprete de alterações que permite "modificar" um objeto (de fato, é claro, criar uma cópia modificada). </li></ol><br><p>  Aqui está um exemplo de um programa escrito usando DSL: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target: <span class="hljs-type"><span class="hljs-type">Entity</span></span>[<span class="hljs-type"><span class="hljs-type">Target</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ,     val updateField1 = target \ field1 := "123" val updateField2 = target \ subobject \ field2 := "456" // ,   DSL: val updateField1 = SetProperty(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123")) val updateField2 = SetProperty(PropertyAccess(PropertyAccess(target, Property(subobject, typeTag[SubObject])), Property(field2, typeTag[String])), LiftedString("456"))</span></span></code> </pre> <br><p>  Ou seja, usando os métodos de extensão <code>\</code> e <code>:=</code> , <code>PropertyAccess</code> , <code>SetProperty</code> , os objetos são formados a partir dos objetos de <code>target</code> , <code>field1</code> , <code>subobject</code> , <code>field2</code> criados anteriormente.  Além disso, devido a conversões implícitas (perigosas), a string "123" é compactada em um <code>LiftedString</code> (você pode fazer isso sem conversões implícitas e chamar o método correspondente explicitamente: <code>lift("123")</code> ). </p><br><p>  Uma ontologia digitada pode ser usada como modelo de dados (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://habr.com/post/229035/</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://habr.com/post/222553/</a> ).  (Em resumo: são declarados objetos de nome que representam as propriedades de qualquer tipo de domínio: campo <code>val field1: Property[Target, String]</code> .) Nesse caso, os dados reais podem ser armazenados, por exemplo, no formato JSON.  A conveniência de uma ontologia digitada, no nosso caso, reside no fato de que o modelo de mudança geralmente opera com propriedades individuais de objetos, e a ontologia apenas fornece uma ferramenta adequada para abordar propriedades. </p><br><p>  Para representar as alterações, você precisa de um conjunto de classes do mesmo plano que a classe <code>SetProperty</code> acima: </p><br><ul><li>  <code>Modify</code> - aplicação da função, </li><li>  <code>Changes</code> - aplicando várias alterações sequencialmente </li><li>  <code>ForEach</code> - aplique alterações a cada item da coleção, </li><li>  etc. </li></ul><br><p>  O intérprete de mudança de idioma é um avaliador de expressão recursiva regular baseado no PatternMatching.  Algo como: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">DslExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Any</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">LiftedString</span></span>(str) =&gt; str <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PropertyAccess</span></span>(obj, prop) =&gt; <span class="hljs-type"><span class="hljs-type">Getter</span></span>(prop)(gamma).get(obj) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (expression: <span class="hljs-type"><span class="hljs-type">DslChangeExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>], target: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SetProperty</span></span>(path, valueExpr) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = eval(valueExpr, gamma) <span class="hljs-type"><span class="hljs-type">Setter</span></span>(path)(gamma).set(value)(target) }</code> </pre> <br><p>  Para operar diretamente nas propriedades dos objetos, você deve especificar getter e setter para cada propriedade usada no modelo de mudança.  Isso pode ser alcançado preenchendo o mapa entre as propriedades ontológicas e as lentes correspondentes. </p></div></div><br><p>  Essa abordagem como um todo funciona e, de fato, permite que você descreva as mudanças uma vez, mas gradualmente há a necessidade de representar mudanças cada vez mais complexas e o modelo de mudanças está crescendo um pouco.  Por exemplo, se você precisar alterar uma propriedade usando o valor de outra propriedade do mesmo objeto (por exemplo, <code>field1 = field2 + 1</code> ), precisará suportar variáveis ​​no nível DSL.  E se a alteração de uma propriedade não for trivial, no nível DSL, será necessário suporte para expressões e funções aritméticas. </p><br><h3 id="testirovanie-vetvey">  Teste de ramificação </h3><br><p>  O código de teste pode ser linear e, em geral, um conjunto de dados de teste é suficiente para entender se funciona.  Se houver uma ramificação ( <code>if-then-else</code> ), você deverá executar a caixa branca pelo menos duas vezes com dados de entrada diferentes para que ambas as ramificações sejam executadas.  O número de conjuntos de dados de entrada suficientes para cobrir todas as ramificações é aparentemente numericamente igual à complexidade ciclomática do código com ramificações. </p><br><p>  Como formar todos os conjuntos de dados de entrada?  Como estamos lidando com uma caixa branca, podemos isolar as condições de ramificação e modificar o objeto de entrada duas vezes para que, em um caso, uma ramificação seja executada, no outro, outra.  Considere um exemplo: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Tendo essa condição, podemos formar dois casos de teste: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase1 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline), <span class="hljs-comment"><span class="hljs-comment">/* result of A */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase2 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, field1.set(<span class="hljs-comment"><span class="hljs-comment">/*  "123", , , */</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> + <span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;)(baseline), <span class="hljs-comment"><span class="hljs-comment">/*result of B*/</span></span>)</code> </pre> <br><p>  <em>(Caso um dos cenários de teste não possa ser criado, podemos assumir que o código morto foi detectado e a condição, juntamente com a ramificação correspondente, pode ser removida com segurança.)</em> </p><br><p>  Se propriedades independentes de um objeto são verificadas em várias ramificações, é bastante simples formar um conjunto exaustivo de objetos de teste modificados que cubram completamente todas as combinações possíveis. </p><br><div class="spoiler">  <b class="spoiler_title">DSL para formar todas as combinações de alterações</b> <div class="spoiler_text"><p>  Vamos considerar com mais detalhes o mecanismo que permite formar todas as listas possíveis de alterações que fornecem cobertura completa de todos os ramos.  Para usar a lista de alterações durante o teste, precisamos combinar todas as alterações em um único objeto, que enviaremos à entrada do código testado, ou seja, é necessário suporte para a composição.  Para fazer isso, você pode usar o DSL acima para modelar alterações e, em seguida, basta uma lista simples de alterações ou pode apresentar uma alteração como uma função de modificação <code>T =&gt; T</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> change1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(_) <span class="hljs-comment"><span class="hljs-comment">// val change1: T =&gt; T = _.copy(field1 = "123") val change2: T =&gt; T = field2.set("456")</span></span></code> </pre> <br><p>  então a cadeia de mudanças será simplesmente uma composição de funções: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> changes = change1 compose change2</code> </pre> <br><p>  ou, para uma lista de alterações: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawChangesList: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(change1, change2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allChanges: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = rawChangesList.foldLeft(identity)(_ compose _)</code> </pre> <br><p>  Para registrar compactamente todas as alterações correspondentes a todas as ramificações possíveis, você pode usar o DSL do seguinte nível de abstração, que simula a estrutura da caixa branca testada: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)] = <span class="hljs-type"><span class="hljs-type">IF</span></span>(<span class="hljs-string"><span class="hljs-string">"field1 == '123'"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,    THEN( field1.set("123"))( //  target \ field1 := "123" IF("field2 == '456') THEN(field2.set("456"))(TERMINATE) ELSE(field2.set("456" + "1"))(TERMINATE) ) ELSE( field1.set("123" + "1") )(TERMINATE)</span></span></code> </pre> <br><p>  Aqui, a coleção de <code>tests</code> contém alterações agregadas correspondentes a todas as combinações possíveis de ramificações.  Um parâmetro do tipo <code>String</code> conterá todos os nomes das condições e todas as descrições das mudanças das quais a função de mudança agregada é formada.  E o segundo elemento de um par do tipo <code>T =&gt; T</code> é apenas a função agregada das mudanças obtidas como resultado da composição das mudanças individuais. </p><br><p>  Para obter os objetos alterados, você precisa aplicar todas as funções de alteração agregadas ao objeto de linha de base: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests2: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>)] = tests.map(_.map_2(_(baseline)))</code> </pre> <br><p>  Como resultado, obtemos uma coleção de pares e a linha descreve as alterações aplicadas, e o segundo elemento do par será o objeto no qual todas essas alterações são combinadas. </p><br><p>  Com base na estrutura do modelo do código testado na forma de uma árvore, as listas de alterações representam o caminho da raiz para as planilhas dessa árvore.  Assim, uma parte significativa das alterações será duplicada.  Você pode se livrar dessa duplicação usando a opção DSL, na qual as alterações são aplicadas diretamente ao objeto de linha de base à medida que você se move pelas ramificações.  Nesse caso, menos cálculos desnecessários serão realizados. </p></div></div><br><h3 id="avtomaticheskoe-formirovanie-testovyh-dannyh">  Geração automática de dados de teste </h3><br><p>  Como estamos lidando com uma caixa branca, podemos ver todos os galhos.  Isso torna possível construir um modelo de lógica contido em uma caixa branca e usar o modelo para gerar dados de teste.  Se o código de teste estiver escrito em Scala, você poderá, por exemplo, usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">scalameta</a> para ler o código, com a conversão subsequente em um modelo lógico.  Novamente, como na questão discutida anteriormente sobre modelagem da lógica das mudanças, é difícil modelar todas as possibilidades de uma linguagem universal.  Além disso, assumiremos que o código testado é implementado usando um subconjunto limitado do idioma, ou em outro idioma ou DSL, inicialmente limitado.  Isso nos permite focar nos aspectos da linguagem que nos interessam. </p><br><p>  Considere um exemplo de código que contém uma única ramificação: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  A condição divide o conjunto de valores do <code>field1</code> em duas classes de equivalência: <code>== "123"</code> e <code>!= "123"</code> .  Portanto, todo o conjunto de dados de entrada também é dividido em duas classes de equivalência com relação a essa condição - <code>ClassCondition1IsTrue</code> e <code>ClassCondition1IsFalse</code> .  Do ponto de vista da abrangência, é suficiente que tomemos pelo menos um exemplo dessas duas classes para cobrir os ramos <code>A</code> e <code>B</code>  Para a primeira classe, podemos construir um exemplo, de certo modo, de uma maneira única: pegue um objeto aleatório, mas altere o <code>field1</code> para <code>"123"</code> .  Além disso, o objeto certamente <code>ClassCondition1IsTrue</code> na classe de equivalência <code>ClassCondition1IsTrue</code> e os cálculos seguirão a ramificação <code>A</code>  Existem mais exemplos para a segunda classe.  Uma maneira de gerar algum exemplo da segunda classe é gerar objetos de entrada arbitrários e descartar aqueles com o <code>field1 == "123"</code> .  Outra maneira: pegar um objeto aleatório, mas altere o <code>field1</code> para <code>"123" + "*"</code> (para modificação, você pode usar qualquer alteração na linha de controle para garantir que a nova linha não seja igual à linha de controle). </p><br><p>  <a href=""><code>  Arbitrary</code> e <code>Gen</code> da biblioteca ScalaCheck</a> são bastante adequados como <a href=""><code>  Arbitrary</code></a> dados aleatórios. </p><br><p>  Basicamente, <strong>chamamos a</strong> função booleana usada na <code>if</code> .  Ou seja, encontramos todos os valores do objeto de entrada para os quais essa função booleana avalia como <code>true</code> - <code>ClassCondition1IsTrue</code> , e todos os valores do objeto de entrada para os quais ele aceita <code>false</code> - <code>ClassCondition1IsFalse</code> . </p><br><p>  De maneira semelhante, é possível gerar dados adequados para as restrições geradas por operadores condicionais simples com constantes (mais / menos que uma constante, incluída em um conjunto, começa com uma constante).  Tais condições são fáceis de reverter.  Mesmo que funções simples sejam chamadas no código de teste, podemos substituir a chamada pela definição (inline) e ainda inverter expressões condicionais. </p><br><h4 id="trudno-obratimye-funkcii">  Funções reversíveis rígidas </h4><br><p>  A situação é diferente quando a condição usa uma função difícil de reverter.  Por exemplo, se uma função hash for usada, não seria possível gerar automaticamente um exemplo fornecendo o valor desejado do código hash. </p><br><p>  Nesse caso, você pode adicionar um parâmetro adicional ao objeto de entrada que representa o resultado do cálculo da função, substituir a chamada de função por uma chamada para esse parâmetro e atualizar esse parâmetro, apesar da violação da conexão funcional: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sha(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a9403</span></span></span><span class="hljs-class">...") ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">object.sha_field1 == "a9403..."</span></span></span><span class="hljs-class">) ...</span></span></code> </pre> <br><p>  Um parâmetro adicional permite a execução de código dentro da ramificação, mas, obviamente, pode levar a resultados realmente incorretos.  Ou seja, o programa de teste produzirá resultados que nunca podem ser observados na realidade.  No entanto, verificar parte do código que, de outra forma, é inacessível para nós ainda é útil e pode ser considerado como uma forma de teste de unidade.  Afinal, mesmo durante o teste de unidade, uma subfunção é chamada com argumentos que nunca podem ser usados ​​no programa. </p><br><p>  Com essas manipulações, substituímos (substituímos) o objeto de teste.  No entanto, de certa forma, o programa recém-criado inclui a lógica do programa antigo.  De fato, se como os valores dos novos parâmetros artificiais obtivermos os resultados do cálculo das funções que substituímos pelos parâmetros, o programa produzirá os mesmos resultados.  Aparentemente, o teste do programa modificado ainda pode ser interessante.  Você só precisa se lembrar sob quais condições o programa alterado se comportará da mesma forma que o original. </p><br><h4 id="zavisimye-usloviya">  Condições dependentes </h4><br><p>         ,      .        ,  ,   ,      .        ,     . (,  , <code>x &gt; 0</code> ,   — <code>x &lt;= 1</code> .         ,           — <code>(-∞, 0]</code> , <code>(0, 1]</code> , <code>(1, +∞)</code> , —      .) </p><br><p>       ,     ,   ,        <code>true</code>  <code>false</code>     .   ,    ,  " "         . </p><br><h4 id="svyazannye-parametry">   </h4><br><p>  ,        ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; x)</code> </pre> <br><p> (     <code>&gt; 0</code> ,       — <code>y &gt; x</code> .) <br>    "", ,   ,      ,    ,     .             ,             "  "     . <br>  ,   "",  ( <code>y == x + 1</code> ),    ,        . <br>   "" ( <code>y &gt; x + 1 &amp;&amp; y &lt; x + 2</code> ),     ,        . </p><br><h4 id="simvolnoe-vypolnenie">   </h4><br><p>  ,    ,    -  ,   "c " ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Symbolic Execution</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> ),     .        ( <code>field1 = field1_initial_value</code> ).       ,    .       : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = field1 + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//    a = field_initial_value + 10 val b = a * 3 //    b = 3 * field_initial_value + 30</span></span></code> </pre> <br><p>         — <code>true</code>  <code>false</code> .       .           .  Por exemplo </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-comment"><span class="hljs-comment">//   A ,  field_initial_value + 10 &gt; 0 //   B ,  field_initial_value + 10 &lt;= 0</span></span></code> </pre> <br><p>           ,  ,   ,     ,    .        ,       (, ,   ). </p><br><h4 id="testirovanie-ciklov-i-rekursivnyh-funkciy">      </h4><br><p>        .    ,     ,       .        ,       .         ,         . </p><br><p> ,      .       . , ,        .  ,       ,      ,        .        ,   ,   ,  ,   ,      ? </p><br><p>     Y- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"  "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">stackoverflow:What is a Y-combinator? (2- )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">habr:  Y-  7  </a> ).      ,       . (   ,      ,  .)    .            ,      .        ,    ""    . Y-   "  "     (     ). </p><br><p>        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ).   ,       .         ,     .       ,      . ,   ,       ,       <code>TestCase</code> '.  ,       ,     ( <code>throw</code>   <code>Nothing</code>  <code>bottom</code> ,    ).            . </p><br><p>        ,   .        .    ,  ,        .  ,       .        ,    ,     .          , ,    ,    ,      .      ,        .      ,    . </p><br><h3 id="smysl-testirovaniya-belogo-yaschika">     </h3><br><p>      ,  ,     ,      ,    100% .       ,     ,   .  Hum. .   , ,   ,   ?         ,    ,     -  . </p><br><p>           : </p><br><ol><li>                . </li><li>       (      ). </li><li>       ,          . </li><li>      ,    . </li></ol><br><p>       ,   ,       . -,       ,     ,   ,       . -,    ,   ,     ( ,  ),         ,  ,   ""  .   /    ,         . </p><br><h3 id="zaklyuchenie">  Conclusão </h3><br><p>        "   "  "   ".  ,      ,     ,      ,     .         ,           . </p><br><p>      ,      ,  ,  ,  . -,          ,        ( ),      . -, -,      .      DSL,  ,    . -,          ,   . -,       ,        (   ,     ,   ).            . </p><br><p>  ,          ,      . ,      ,         -   . </p><br><h3 id="blagodarnosti">  Agradecimentos </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@mneychev</a>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt422283/">https://habr.com/ru/post/pt422283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt422269/index.html">O livro "Dispositivo interno do Windows. 7th ed</a></li>
<li><a href="../pt422273/index.html">Não há estradas estúpidas em uma cidade inteligente. O que é o RWIS e como ele reduzirá o custo do trabalho na estrada</a></li>
<li><a href="../pt422275/index.html">Um funcionário do Google conseguiu controlar o sistema de abertura de portas no escritório da empresa devido a uma vulnerabilidade de software</a></li>
<li><a href="../pt422277/index.html">Arquitetura e programação RCA Studio II</a></li>
<li><a href="../pt422281/index.html">A7 Data Server: gerenciamento de dados online</a></li>
<li><a href="../pt422285/index.html">Por que as compras on-line têm lealdade suficiente de 1% dos clientes</a></li>
<li><a href="../pt422291/index.html">Pequena caixa preta (visualização de todo o dinheiro e mercados mundiais)</a></li>
<li><a href="../pt422293/index.html">Obtendo a lista de alarmes do OSS via interface AlarmIRP</a></li>
<li><a href="../pt422297/index.html">A primeira experiência ou como tentar se tornar uma lenda de código e magia</a></li>
<li><a href="../pt422299/index.html">TsNIImash: SpaceX supostamente implementa desenvolvimentos soviéticos. Por que Ilon Mask tem tantos inimigos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>