<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚úàÔ∏è üßì üññüèΩ Teste da caixa branca üßîüèΩ ‚§µÔ∏è üë©üèø‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O desenvolvimento de programas de alta qualidade implica que o programa e suas partes sejam testados. O teste de unidade cl√°ssico envolve dividir um p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teste da caixa branca</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422283/"><p>  O desenvolvimento de programas de alta qualidade implica que o programa e suas partes sejam testados.  O teste de unidade cl√°ssico envolve dividir um programa grande em pequenos blocos convenientes para o teste.  Ou, se o desenvolvimento de testes ocorrer paralelamente ao desenvolvimento de c√≥digo ou se os testes forem desenvolvidos antes do programa (TDD - test driven development), o programa ser√° inicialmente desenvolvido em pequenos blocos adequados para os requisitos dos testes. </p><br><p>  Uma das variedades de teste de unidade pode ser considerada teste baseado em propriedade (essa abordagem √© implementada, por exemplo, nas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bibliotecas QuickCheck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ScalaCheck</a> ).  Essa abordagem √© baseada na localiza√ß√£o de propriedades universais que devem ser v√°lidas para qualquer dado de entrada.  Por exemplo, a <em>serializa√ß√£o seguida pela desserializa√ß√£o deve produzir o mesmo objeto</em> .  Ou <em>re-classificar n√£o deve alterar a ordem dos itens na lista</em> .  Para verificar essas propriedades universais, as bibliotecas acima suportam um mecanismo para gerar dados de entrada aleat√≥rios.  Essa abordagem funciona especialmente bem para programas baseados em leis matem√°ticas que servem como propriedades universais v√°lidas para uma ampla classe de programas.  Existe at√© uma biblioteca de propriedades matem√°ticas prontas - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">disciplina</a> - que permite verificar o desempenho dessas propriedades em novos programas (um bom exemplo de reutiliza√ß√£o de testes). </p><br><p>  √Äs vezes, √© necess√°rio testar um programa complexo sem poder analis√°-lo em partes verific√°veis ‚Äã‚Äãde forma independente.  Nesse caso, o programa de teste √© <del>  preto </del>  caixa branca (branca - porque temos a oportunidade de estudar a estrutura interna do programa). </p><br><p>  Sob o corte, s√£o descritas v√°rias abordagens para testar programas complexos com uma entrada com graus variados de complexidade (envolvimento) e graus variados de cobertura. </p><a name="habracut"></a><br><p>  * <em>Neste artigo, assumimos que o programa em teste pode ser representado como uma fun√ß√£o pura sem um estado interno.</em>  <em>(Algumas das considera√ß√µes fornecidas abaixo podem ser aplicadas se o estado interno estiver presente, mas √© poss√≠vel redefinir esse estado para um valor fixo.)</em> </p><br><h3 id="testovyy-stend-test-bench">  Banco de ensaio </h3><br><p> Antes de tudo, como apenas uma fun√ß√£o √© testada, cujo c√≥digo de chamada √© sempre o mesmo, n√£o precisamos criar testes de unidade separados.  Todos esses testes seriam os mesmos, precisos para as entradas e verifica√ß√µes.  √â o suficiente para transmitir os dados de origem ( <code>input</code> ) em um loop e verificar os resultados (resultado <code>expectedOutput</code> ).  Para identificar um conjunto de problemas de dados de teste em caso de detec√ß√£o de erros, todos os dados de teste devem ser rotulados.  Assim, um conjunto de dados de teste pode ser representado como um triplo: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expectedOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  O resultado de uma execu√ß√£o pode ser representado como <code>TestCaseResult</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseResult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">testCase: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TestCase</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">], actualOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Try</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  (Apresentamos o resultado do lan√ßamento usando o <code>Try</code> para capturar poss√≠veis exce√ß√µes.) </p><br><p>  Para simplificar a execu√ß√£o de todos os dados de teste atrav√©s do programa em teste, voc√™ pode usar uma fun√ß√£o auxiliar que chamar√° o programa para cada valor de entrada: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCases</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](cases: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCase</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]] = cases .map{ testCase =&gt; <span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>(testCase, <span class="hljs-type"><span class="hljs-type">Try</span></span>{ f(testCase.input) } ) } .filter(r =&gt; r.actualOutput != <span class="hljs-type"><span class="hljs-type">Success</span></span>(r.testCase.expectedOutput))</code> </pre> <br><p>  Essa fun√ß√£o auxiliar retornar√° os dados e resultados problem√°ticos diferentes do esperado. </p><br><p>  Por conveni√™ncia, voc√™ pode formatar os resultados do teste. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span></span>(results: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[_, _]]): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"Failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${results.length}</span></span></span><span class="hljs-string">:\n"</span></span> + results .map(r =&gt; r.testCase.label + <span class="hljs-string"><span class="hljs-string">": expected "</span></span> + r.testCase.expectedOutput + <span class="hljs-string"><span class="hljs-string">", but got "</span></span> + r.actualOutput) .mkString(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><p>  e exiba um relat√≥rio apenas em caso de erros: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) test(<span class="hljs-string"><span class="hljs-string">"all test cases"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testBench = runTestCases(testCases) _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> results = testBench(f) assert(results.isEmpty, report(results)) }</code> </pre> <br><h3 id="podgotovka-vhodnyh-dannyh">  Prepara√ß√£o de entrada </h3><br><p>  No caso mais simples, voc√™ pode criar dados de teste manualmente para testar o programa, grav√°-los diretamente no c√≥digo de teste e us√°-los, como mostrado acima.  Muitas vezes acontece que casos interessantes de dados de teste t√™m muito em comum e podem ser apresentados como uma inst√¢ncia b√°sica, com pequenas altera√ß√µes. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = <span class="hljs-type"><span class="hljs-type">MyObject</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//        val testCases = Seq( TestCase("baseline", baseline, ???), TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???) )</span></span></code> </pre> <br><p>  Ao trabalhar com estruturas de dados imut√°veis ‚Äã‚Äãaninhadas, as lentes s√£o de grande ajuda, por exemplo, na biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monocle</a> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testObject1 = (field1 composeLens field2).set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline) <span class="hljs-comment"><span class="hljs-comment">//    : val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))</span></span></code> </pre> <br><p>  As lentes permitem que voc√™ "modifique" elegantemente partes profundamente aninhadas das estruturas de dados: cada lente √© um m√©todo de obten√ß√£o e configura√ß√£o de uma propriedade.  As lentes podem ser combinadas para produzir lentes que "focam" no pr√≥ximo n√≠vel. </p><br><h3 id="ispolzovanie-dsl-dlya-predstavleniya-izmeneniy">  Usando DSL para apresentar altera√ß√µes </h3><br><p>  A seguir, consideraremos a forma√ß√£o dos dados de teste fazendo altera√ß√µes em algum objeto de entrada inicial.  Normalmente, para obter o objeto de teste de que precisamos, precisamos fazer algumas altera√ß√µes.  Ao mesmo tempo, √© muito √∫til incluir uma lista de altera√ß√µes na descri√ß√£o de texto do TestCase: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline"</span></span>, baseline, ???), <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline + "</span></span> + <span class="hljs-string"><span class="hljs-string">"(field1 = 123) + "</span></span> + <span class="hljs-comment"><span class="hljs-comment">//  1-  "(field2 = 456) + " + // 2- "(field3 = 789)", // 3- baseline .copy(field1 = "123") // 1-  .copy(field2 = "456") // 2-  .copy(field3 = "789"), // 3-  ???) )</span></span></code> </pre> <br><p>  Sempre saberemos para quais dados de teste o teste √© realizado. </p><br><p>  Para que a lista textual de altera√ß√µes n√£o diverja das mudan√ßas reais, voc√™ deve seguir o princ√≠pio de "uma √∫nica vers√£o da verdade".  (Se as mesmas informa√ß√µes forem necess√°rias / usadas em v√°rios pontos, deve haver uma √∫nica fonte prim√°ria de informa√ß√µes exclusivas, e as informa√ß√µes devem ser distribu√≠das automaticamente para todos os outros pontos de uso, com as transforma√ß√µes necess√°rias. Se esse princ√≠pio for violado, a c√≥pia manual de informa√ß√µes ser√° inevit√°vel. . informa√ß√µes sobre a vers√£o discrep√¢ncia em pontos diferentes em outras palavras na descri√ß√£o dos dados de teste, vemos um, e dados de ensaios -. outro exemplo, copiar uma mudan√ßa <code>field2 = "456"</code> e ajustando-o na <code>field3 = "789"</code> que Mauger  acidentalmente esquecer de corrigir a descri√ß√£o. Como resultado, a descri√ß√£o s√≥ ir√° refletir duas mudas de tr√™s.) </p><br><p>  No nosso caso, a principal fonte de informa√ß√£o s√£o as pr√≥prias altera√ß√µes, ou melhor, o c√≥digo-fonte do programa que faz as altera√ß√µes.  Gostar√≠amos de deduzir deles um texto descrevendo as altera√ß√µes.  De antem√£o, como primeira op√ß√£o, voc√™ pode sugerir o uso de uma macro que ir√° capturar o c√≥digo fonte das altera√ß√µes e usar o c√≥digo fonte como documenta√ß√£o.  Aparentemente, essa √© uma maneira boa e relativamente simples de documentar mudan√ßas reais e pode muito bem ser aplicada em alguns casos.  Infelizmente, se apresentarmos as altera√ß√µes no texto sem formata√ß√£o, perderemos a capacidade de fazer transforma√ß√µes significativas na lista de altera√ß√µes.  Por exemplo, detecte e elimine altera√ß√µes duplicadas ou sobrepostas, elabore uma lista de altera√ß√µes de maneira conveniente para o usu√°rio final. </p><br><p>  Para poder lidar com as mudan√ßas, voc√™ deve ter um modelo estruturado delas.  O modelo deve ser expressivo o suficiente para descrever todas as mudan√ßas que nos interessam.  Parte deste modelo, por exemplo, ser√° o endere√ßamento de campos de objetos, constantes e opera√ß√µes de atribui√ß√£o. </p><br><p>  O modelo de mudan√ßa deve permitir resolver as seguintes tarefas: </p><br><ol><li>  Gerar inst√¢ncias de modelo de mudan√ßa.  (Ou seja, na verdade, criando uma lista espec√≠fica de altera√ß√µes.) </li><li>  Forma√ß√£o de uma descri√ß√£o textual das altera√ß√µes. </li><li>  Aplicando altera√ß√µes nos objetos do dom√≠nio. </li><li>  Executando transforma√ß√µes de otimiza√ß√£o no modelo. </li></ol><br><p>  Se uma linguagem de programa√ß√£o universal for usada para fazer altera√ß√µes, pode ser dif√≠cil representar essas altera√ß√µes no modelo.  O c√≥digo fonte do programa pode usar constru√ß√µes complexas que n√£o s√£o suportadas pelo modelo.  Esse programa pode usar padr√µes secund√°rios, como lentes ou o m√©todo de <code>copy</code> , para alterar os campos de um objeto, que s√£o abstra√ß√µes de n√≠vel inferior em rela√ß√£o ao n√≠vel do modelo de mudan√ßa.  Como resultado, an√°lises adicionais de tais padr√µes podem ser necess√°rias para gerar inst√¢ncias de altera√ß√µes.  Portanto, inicialmente uma boa op√ß√£o usando uma macro n√£o √© muito conveniente. </p><br><p>  Outra maneira de criar inst√¢ncias do modelo de mudan√ßa pode ser uma linguagem especializada (DSL), que cria objetos do modelo de mudan√ßa usando um conjunto de m√©todos de extens√£o e operadores auxiliares.  Bem, nos casos mais simples, inst√¢ncias do modelo de mudan√ßa podem ser criadas diretamente atrav√©s dos construtores. </p><br><div class="spoiler">  <b class="spoiler_title">Alterar detalhes do idioma</b> <div class="spoiler_text"><p>  A linguagem de mudan√ßa √© uma constru√ß√£o bastante complexa que inclui v√°rios componentes, que s√£o, por sua vez, n√£o triviais. </p><br><ol><li>  Modelo de estrutura de dados. </li><li>  Alterar modelo. </li><li>  DSL atualmente incorporado (?) - constru√ß√µes auxiliares, m√©todos de extens√£o, para a constru√ß√£o conveniente de altera√ß√µes. </li><li>  Um int√©rprete de altera√ß√µes que permite "modificar" um objeto (de fato, √© claro, criar uma c√≥pia modificada). </li></ol><br><p>  Aqui est√° um exemplo de um programa escrito usando DSL: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target: <span class="hljs-type"><span class="hljs-type">Entity</span></span>[<span class="hljs-type"><span class="hljs-type">Target</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ,     val updateField1 = target \ field1 := "123" val updateField2 = target \ subobject \ field2 := "456" // ,   DSL: val updateField1 = SetProperty(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123")) val updateField2 = SetProperty(PropertyAccess(PropertyAccess(target, Property(subobject, typeTag[SubObject])), Property(field2, typeTag[String])), LiftedString("456"))</span></span></code> </pre> <br><p>  Ou seja, usando os m√©todos de extens√£o <code>\</code> e <code>:=</code> , <code>PropertyAccess</code> , <code>SetProperty</code> , os objetos s√£o formados a partir dos objetos de <code>target</code> , <code>field1</code> , <code>subobject</code> , <code>field2</code> criados anteriormente.  Al√©m disso, devido a convers√µes impl√≠citas (perigosas), a string "123" √© compactada em um <code>LiftedString</code> (voc√™ pode fazer isso sem convers√µes impl√≠citas e chamar o m√©todo correspondente explicitamente: <code>lift("123")</code> ). </p><br><p>  Uma ontologia digitada pode ser usada como modelo de dados (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://habr.com/post/229035/</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://habr.com/post/222553/</a> ).  (Em resumo: s√£o declarados objetos de nome que representam as propriedades de qualquer tipo de dom√≠nio: campo <code>val field1: Property[Target, String]</code> .) Nesse caso, os dados reais podem ser armazenados, por exemplo, no formato JSON.  A conveni√™ncia de uma ontologia digitada, no nosso caso, reside no fato de que o modelo de mudan√ßa geralmente opera com propriedades individuais de objetos, e a ontologia apenas fornece uma ferramenta adequada para abordar propriedades. </p><br><p>  Para representar as altera√ß√µes, voc√™ precisa de um conjunto de classes do mesmo plano que a classe <code>SetProperty</code> acima: </p><br><ul><li>  <code>Modify</code> - aplica√ß√£o da fun√ß√£o, </li><li>  <code>Changes</code> - aplicando v√°rias altera√ß√µes sequencialmente </li><li>  <code>ForEach</code> - aplique altera√ß√µes a cada item da cole√ß√£o, </li><li>  etc. </li></ul><br><p>  O int√©rprete de mudan√ßa de idioma √© um avaliador de express√£o recursiva regular baseado no PatternMatching.  Algo como: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">DslExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Any</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">LiftedString</span></span>(str) =&gt; str <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PropertyAccess</span></span>(obj, prop) =&gt; <span class="hljs-type"><span class="hljs-type">Getter</span></span>(prop)(gamma).get(obj) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (expression: <span class="hljs-type"><span class="hljs-type">DslChangeExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>], target: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SetProperty</span></span>(path, valueExpr) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = eval(valueExpr, gamma) <span class="hljs-type"><span class="hljs-type">Setter</span></span>(path)(gamma).set(value)(target) }</code> </pre> <br><p>  Para operar diretamente nas propriedades dos objetos, voc√™ deve especificar getter e setter para cada propriedade usada no modelo de mudan√ßa.  Isso pode ser alcan√ßado preenchendo o mapa entre as propriedades ontol√≥gicas e as lentes correspondentes. </p></div></div><br><p>  Essa abordagem como um todo funciona e, de fato, permite que voc√™ descreva as mudan√ßas uma vez, mas gradualmente h√° a necessidade de representar mudan√ßas cada vez mais complexas e o modelo de mudan√ßas est√° crescendo um pouco.  Por exemplo, se voc√™ precisar alterar uma propriedade usando o valor de outra propriedade do mesmo objeto (por exemplo, <code>field1 = field2 + 1</code> ), precisar√° suportar vari√°veis ‚Äã‚Äãno n√≠vel DSL.  E se a altera√ß√£o de uma propriedade n√£o for trivial, no n√≠vel DSL, ser√° necess√°rio suporte para express√µes e fun√ß√µes aritm√©ticas. </p><br><h3 id="testirovanie-vetvey">  Teste de ramifica√ß√£o </h3><br><p>  O c√≥digo de teste pode ser linear e, em geral, um conjunto de dados de teste √© suficiente para entender se funciona.  Se houver uma ramifica√ß√£o ( <code>if-then-else</code> ), voc√™ dever√° executar a caixa branca pelo menos duas vezes com dados de entrada diferentes para que ambas as ramifica√ß√µes sejam executadas.  O n√∫mero de conjuntos de dados de entrada suficientes para cobrir todas as ramifica√ß√µes √© aparentemente numericamente igual √† complexidade ciclom√°tica do c√≥digo com ramifica√ß√µes. </p><br><p>  Como formar todos os conjuntos de dados de entrada?  Como estamos lidando com uma caixa branca, podemos isolar as condi√ß√µes de ramifica√ß√£o e modificar o objeto de entrada duas vezes para que, em um caso, uma ramifica√ß√£o seja executada, no outro, outra.  Considere um exemplo: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Tendo essa condi√ß√£o, podemos formar dois casos de teste: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase1 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline), <span class="hljs-comment"><span class="hljs-comment">/* result of A */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase2 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, field1.set(<span class="hljs-comment"><span class="hljs-comment">/*  "123", , , */</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> + <span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;)(baseline), <span class="hljs-comment"><span class="hljs-comment">/*result of B*/</span></span>)</code> </pre> <br><p>  <em>(Caso um dos cen√°rios de teste n√£o possa ser criado, podemos assumir que o c√≥digo morto foi detectado e a condi√ß√£o, juntamente com a ramifica√ß√£o correspondente, pode ser removida com seguran√ßa.)</em> </p><br><p>  Se propriedades independentes de um objeto s√£o verificadas em v√°rias ramifica√ß√µes, √© bastante simples formar um conjunto exaustivo de objetos de teste modificados que cubram completamente todas as combina√ß√µes poss√≠veis. </p><br><div class="spoiler">  <b class="spoiler_title">DSL para formar todas as combina√ß√µes de altera√ß√µes</b> <div class="spoiler_text"><p>  Vamos considerar com mais detalhes o mecanismo que permite formar todas as listas poss√≠veis de altera√ß√µes que fornecem cobertura completa de todos os ramos.  Para usar a lista de altera√ß√µes durante o teste, precisamos combinar todas as altera√ß√µes em um √∫nico objeto, que enviaremos √† entrada do c√≥digo testado, ou seja, √© necess√°rio suporte para a composi√ß√£o.  Para fazer isso, voc√™ pode usar o DSL acima para modelar altera√ß√µes e, em seguida, basta uma lista simples de altera√ß√µes ou pode apresentar uma altera√ß√£o como uma fun√ß√£o de modifica√ß√£o <code>T =&gt; T</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> change1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(_) <span class="hljs-comment"><span class="hljs-comment">// val change1: T =&gt; T = _.copy(field1 = "123") val change2: T =&gt; T = field2.set("456")</span></span></code> </pre> <br><p>  ent√£o a cadeia de mudan√ßas ser√° simplesmente uma composi√ß√£o de fun√ß√µes: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> changes = change1 compose change2</code> </pre> <br><p>  ou, para uma lista de altera√ß√µes: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawChangesList: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(change1, change2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allChanges: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = rawChangesList.foldLeft(identity)(_ compose _)</code> </pre> <br><p>  Para registrar compactamente todas as altera√ß√µes correspondentes a todas as ramifica√ß√µes poss√≠veis, voc√™ pode usar o DSL do seguinte n√≠vel de abstra√ß√£o, que simula a estrutura da caixa branca testada: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)] = <span class="hljs-type"><span class="hljs-type">IF</span></span>(<span class="hljs-string"><span class="hljs-string">"field1 == '123'"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,    THEN( field1.set("123"))( //  target \ field1 := "123" IF("field2 == '456') THEN(field2.set("456"))(TERMINATE) ELSE(field2.set("456" + "1"))(TERMINATE) ) ELSE( field1.set("123" + "1") )(TERMINATE)</span></span></code> </pre> <br><p>  Aqui, a cole√ß√£o de <code>tests</code> cont√©m altera√ß√µes agregadas correspondentes a todas as combina√ß√µes poss√≠veis de ramifica√ß√µes.  Um par√¢metro do tipo <code>String</code> conter√° todos os nomes das condi√ß√µes e todas as descri√ß√µes das mudan√ßas das quais a fun√ß√£o de mudan√ßa agregada √© formada.  E o segundo elemento de um par do tipo <code>T =&gt; T</code> √© apenas a fun√ß√£o agregada das mudan√ßas obtidas como resultado da composi√ß√£o das mudan√ßas individuais. </p><br><p>  Para obter os objetos alterados, voc√™ precisa aplicar todas as fun√ß√µes de altera√ß√£o agregadas ao objeto de linha de base: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests2: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>)] = tests.map(_.map_2(_(baseline)))</code> </pre> <br><p>  Como resultado, obtemos uma cole√ß√£o de pares e a linha descreve as altera√ß√µes aplicadas, e o segundo elemento do par ser√° o objeto no qual todas essas altera√ß√µes s√£o combinadas. </p><br><p>  Com base na estrutura do modelo do c√≥digo testado na forma de uma √°rvore, as listas de altera√ß√µes representam o caminho da raiz para as planilhas dessa √°rvore.  Assim, uma parte significativa das altera√ß√µes ser√° duplicada.  Voc√™ pode se livrar dessa duplica√ß√£o usando a op√ß√£o DSL, na qual as altera√ß√µes s√£o aplicadas diretamente ao objeto de linha de base √† medida que voc√™ se move pelas ramifica√ß√µes.  Nesse caso, menos c√°lculos desnecess√°rios ser√£o realizados. </p></div></div><br><h3 id="avtomaticheskoe-formirovanie-testovyh-dannyh">  Gera√ß√£o autom√°tica de dados de teste </h3><br><p>  Como estamos lidando com uma caixa branca, podemos ver todos os galhos.  Isso torna poss√≠vel construir um modelo de l√≥gica contido em uma caixa branca e usar o modelo para gerar dados de teste.  Se o c√≥digo de teste estiver escrito em Scala, voc√™ poder√°, por exemplo, usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">scalameta</a> para ler o c√≥digo, com a convers√£o subsequente em um modelo l√≥gico.  Novamente, como na quest√£o discutida anteriormente sobre modelagem da l√≥gica das mudan√ßas, √© dif√≠cil modelar todas as possibilidades de uma linguagem universal.  Al√©m disso, assumiremos que o c√≥digo testado √© implementado usando um subconjunto limitado do idioma, ou em outro idioma ou DSL, inicialmente limitado.  Isso nos permite focar nos aspectos da linguagem que nos interessam. </p><br><p>  Considere um exemplo de c√≥digo que cont√©m uma √∫nica ramifica√ß√£o: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  A condi√ß√£o divide o conjunto de valores do <code>field1</code> em duas classes de equival√™ncia: <code>== "123"</code> e <code>!= "123"</code> .  Portanto, todo o conjunto de dados de entrada tamb√©m √© dividido em duas classes de equival√™ncia com rela√ß√£o a essa condi√ß√£o - <code>ClassCondition1IsTrue</code> e <code>ClassCondition1IsFalse</code> .  Do ponto de vista da abrang√™ncia, √© suficiente que tomemos pelo menos um exemplo dessas duas classes para cobrir os ramos <code>A</code> e <code>B</code>  Para a primeira classe, podemos construir um exemplo, de certo modo, de uma maneira √∫nica: pegue um objeto aleat√≥rio, mas altere o <code>field1</code> para <code>"123"</code> .  Al√©m disso, o objeto certamente <code>ClassCondition1IsTrue</code> na classe de equival√™ncia <code>ClassCondition1IsTrue</code> e os c√°lculos seguir√£o a ramifica√ß√£o <code>A</code>  Existem mais exemplos para a segunda classe.  Uma maneira de gerar algum exemplo da segunda classe √© gerar objetos de entrada arbitr√°rios e descartar aqueles com o <code>field1 == "123"</code> .  Outra maneira: pegar um objeto aleat√≥rio, mas altere o <code>field1</code> para <code>"123" + "*"</code> (para modifica√ß√£o, voc√™ pode usar qualquer altera√ß√£o na linha de controle para garantir que a nova linha n√£o seja igual √† linha de controle). </p><br><p>  <a href=""><code>  Arbitrary</code> e <code>Gen</code> da biblioteca ScalaCheck</a> s√£o bastante adequados como <a href=""><code>  Arbitrary</code></a> dados aleat√≥rios. </p><br><p>  Basicamente, <strong>chamamos a</strong> fun√ß√£o booleana usada na <code>if</code> .  Ou seja, encontramos todos os valores do objeto de entrada para os quais essa fun√ß√£o booleana avalia como <code>true</code> - <code>ClassCondition1IsTrue</code> , e todos os valores do objeto de entrada para os quais ele aceita <code>false</code> - <code>ClassCondition1IsFalse</code> . </p><br><p>  De maneira semelhante, √© poss√≠vel gerar dados adequados para as restri√ß√µes geradas por operadores condicionais simples com constantes (mais / menos que uma constante, inclu√≠da em um conjunto, come√ßa com uma constante).  Tais condi√ß√µes s√£o f√°ceis de reverter.  Mesmo que fun√ß√µes simples sejam chamadas no c√≥digo de teste, podemos substituir a chamada pela defini√ß√£o (inline) e ainda inverter express√µes condicionais. </p><br><h4 id="trudno-obratimye-funkcii">  Fun√ß√µes revers√≠veis r√≠gidas </h4><br><p>  A situa√ß√£o √© diferente quando a condi√ß√£o usa uma fun√ß√£o dif√≠cil de reverter.  Por exemplo, se uma fun√ß√£o hash for usada, n√£o seria poss√≠vel gerar automaticamente um exemplo fornecendo o valor desejado do c√≥digo hash. </p><br><p>  Nesse caso, voc√™ pode adicionar um par√¢metro adicional ao objeto de entrada que representa o resultado do c√°lculo da fun√ß√£o, substituir a chamada de fun√ß√£o por uma chamada para esse par√¢metro e atualizar esse par√¢metro, apesar da viola√ß√£o da conex√£o funcional: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sha(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a9403</span></span></span><span class="hljs-class">...") ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">object.sha_field1 == "a9403..."</span></span></span><span class="hljs-class">) ...</span></span></code> </pre> <br><p>  Um par√¢metro adicional permite a execu√ß√£o de c√≥digo dentro da ramifica√ß√£o, mas, obviamente, pode levar a resultados realmente incorretos.  Ou seja, o programa de teste produzir√° resultados que nunca podem ser observados na realidade.  No entanto, verificar parte do c√≥digo que, de outra forma, √© inacess√≠vel para n√≥s ainda √© √∫til e pode ser considerado como uma forma de teste de unidade.  Afinal, mesmo durante o teste de unidade, uma subfun√ß√£o √© chamada com argumentos que nunca podem ser usados ‚Äã‚Äãno programa. </p><br><p>  Com essas manipula√ß√µes, substitu√≠mos (substitu√≠mos) o objeto de teste.  No entanto, de certa forma, o programa rec√©m-criado inclui a l√≥gica do programa antigo.  De fato, se como os valores dos novos par√¢metros artificiais obtivermos os resultados do c√°lculo das fun√ß√µes que substitu√≠mos pelos par√¢metros, o programa produzir√° os mesmos resultados.  Aparentemente, o teste do programa modificado ainda pode ser interessante.  Voc√™ s√≥ precisa se lembrar sob quais condi√ß√µes o programa alterado se comportar√° da mesma forma que o original. </p><br><h4 id="zavisimye-usloviya">  Condi√ß√µes dependentes </h4><br><p>         ,      .        ,  ,   ,      .        ,     . (,  , <code>x &gt; 0</code> ,   ‚Äî <code>x &lt;= 1</code> .         ,           ‚Äî <code>(-‚àû, 0]</code> , <code>(0, 1]</code> , <code>(1, +‚àû)</code> , ‚Äî      .) </p><br><p>       ,     ,   ,        <code>true</code>  <code>false</code>     .   ,    ,  " "         . </p><br><h4 id="svyazannye-parametry">   </h4><br><p>  ,        ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; x)</code> </pre> <br><p> (     <code>&gt; 0</code> ,       ‚Äî <code>y &gt; x</code> .) <br>    "", ,   ,      ,    ,     .             ,             "  "     . <br>  ,   "",  ( <code>y == x + 1</code> ),    ,        . <br>   "" ( <code>y &gt; x + 1 &amp;&amp; y &lt; x + 2</code> ),     ,        . </p><br><h4 id="simvolnoe-vypolnenie">   </h4><br><p>  ,    ,    -  ,   "c " ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Symbolic Execution</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> ),     .        ( <code>field1 = field1_initial_value</code> ).       ,    .       : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = field1 + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//    a = field_initial_value + 10 val b = a * 3 //    b = 3 * field_initial_value + 30</span></span></code> </pre> <br><p>         ‚Äî <code>true</code>  <code>false</code> .       .           .  Por exemplo </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-comment"><span class="hljs-comment">//   A ,  field_initial_value + 10 &gt; 0 //   B ,  field_initial_value + 10 &lt;= 0</span></span></code> </pre> <br><p>           ,  ,   ,     ,    .        ,       (, ,   ). </p><br><h4 id="testirovanie-ciklov-i-rekursivnyh-funkciy">      </h4><br><p>        .    ,     ,       .        ,       .         ,         . </p><br><p> ,      .       . , ,        .  ,       ,      ,        .        ,   ,   ,  ,   ,      ? </p><br><p>     Y- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"  "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">stackoverflow:What is a Y-combinator? (2- )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">habr:  Y-  7  </a> ).      ,       . (   ,      ,  .)    .            ,      .        ,    ""    . Y-   "  "     (     ). </p><br><p>        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ).   ,       .         ,     .       ,      . ,   ,       ,       <code>TestCase</code> '.  ,       ,     ( <code>throw</code>   <code>Nothing</code>  <code>bottom</code> ,    ).            . </p><br><p>        ,   .        .    ,  ,        .  ,       .        ,    ,     .          , ,    ,    ,      .      ,        .      ,    . </p><br><h3 id="smysl-testirovaniya-belogo-yaschika">     </h3><br><p>      ,  ,     ,      ,    100% .       ,     ,   .  Hum. .   , ,   ,   ?         ,    ,     -  . </p><br><p>           : </p><br><ol><li>                . </li><li>       (      ). </li><li>       ,          . </li><li>      ,    . </li></ol><br><p>       ,   ,       . -,       ,     ,   ,       . -,    ,   ,     ( ,  ),         ,  ,   ""  .   /    ,         . </p><br><h3 id="zaklyuchenie">  Conclus√£o </h3><br><p>        "   "  "   ".  ,      ,     ,      ,     .         ,           . </p><br><p>      ,      ,  ,  ,  . -,          ,        ( ),      . -, -,      .      DSL,  ,    . -,          ,   . -,       ,        (   ,     ,   ).            . </p><br><p>  ,          ,      . ,      ,         -   . </p><br><h3 id="blagodarnosti">  Agradecimentos </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@mneychev</a>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt422283/">https://habr.com/ru/post/pt422283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt422269/index.html">O livro "Dispositivo interno do Windows. 7th ed</a></li>
<li><a href="../pt422273/index.html">N√£o h√° estradas est√∫pidas em uma cidade inteligente. O que √© o RWIS e como ele reduzir√° o custo do trabalho na estrada</a></li>
<li><a href="../pt422275/index.html">Um funcion√°rio do Google conseguiu controlar o sistema de abertura de portas no escrit√≥rio da empresa devido a uma vulnerabilidade de software</a></li>
<li><a href="../pt422277/index.html">Arquitetura e programa√ß√£o RCA Studio II</a></li>
<li><a href="../pt422281/index.html">A7 Data Server: gerenciamento de dados online</a></li>
<li><a href="../pt422285/index.html">Por que as compras on-line t√™m lealdade suficiente de 1% dos clientes</a></li>
<li><a href="../pt422291/index.html">Pequena caixa preta (visualiza√ß√£o de todo o dinheiro e mercados mundiais)</a></li>
<li><a href="../pt422293/index.html">Obtendo a lista de alarmes do OSS via interface AlarmIRP</a></li>
<li><a href="../pt422297/index.html">A primeira experi√™ncia ou como tentar se tornar uma lenda de c√≥digo e magia</a></li>
<li><a href="../pt422299/index.html">TsNIImash: SpaceX supostamente implementa desenvolvimentos sovi√©ticos. Por que Ilon Mask tem tantos inimigos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>