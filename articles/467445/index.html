<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∏ ‚òùüèø üõÄüèø Lista evasiva de actualizaciones de Windows instaladas üôãüèæ üóª üö†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øAlguna vez te has preguntado por qu√© se genera una lista de actualizaciones de Windows instaladas? ¬øY a trav√©s de qu√© API conseguirlo? Intentar√© dar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lista evasiva de actualizaciones de Windows instaladas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467445/">  ¬øAlguna vez te has preguntado por qu√© se genera una lista de actualizaciones de Windows instaladas?  ¬øY a trav√©s de qu√© API conseguirlo?  Intentar√© dar respuestas a estas y otras preguntas emergentes en mi peque√±o estudio. <br><br><img src="https://habrastorage.org/webt/bb/rl/zc/bbrlzcws8p-tumczrzauuvx2l7w.jpeg"><br><a name="habracut"></a><br><h2>  Antecedentes o c√≥mo comenz√≥ todo. </h2><br>  Cada a√±o se celebra una conferencia de j√≥venes especialistas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en nuestra empresa</a> , donde cada participante puede resolver el problema de un departamento (se propone una lista de temas por adelantado).  Y el departamento de SPAS (soporte de software y hardware) ten√≠a la siguiente tarea, que me interes√≥, adem√°s de que me permiti√≥ volver a la programaci√≥n nuevamente (desafortunadamente, en este momento trabajo en esta empresa como un simple operador de NPPS). <br><br>  Anteriormente, por cada "TO" con la ayuda de WSUS, todas las actualizaciones lanzadas se extra√≠an y distribu√≠an a todas las m√°quinas.  TSB (boletines de servicio t√©cnico) tambi√©n aparec√≠an peri√≥dicamente, lo que indicaba que era necesario instalar las actualizaciones necesarias en forma de paquetes aislados.  Como resultado, acumulamos actualizaciones que no se pueden rastrear en WSUS, pero solo se pueden ver a trav√©s del panel de control en la secci√≥n "Actualizaciones instaladas". <br><br><br><br><img src="https://habrastorage.org/webt/v6/9f/kb/v69fkb557stfaokhfjpoccmnuma.png" alt="Esquema de actualizaci√≥n visual"><br><br>  Hay situaciones en las que la estaci√≥n de trabajo o el servidor se "cuelga" y debe restaurarlo a partir de una imagen creada hace alg√∫n tiempo.  Al recuperarse de una imagen, existe la posibilidad de que perdamos las actualizaciones que necesitamos (que vienen en forma de paquetes aislados) que se instalaron antes de que la m√°quina se bloqueara.  Explicado lo m√°s detallado posible, porque las aclaraciones ya ser√°n un secreto comercial. <br><br>  Es por eso que surgi√≥ la idea de crear un programa que pudiera extraer esta lista de actualizaciones (preferiblemente de <b>forma remota a</b> trav√©s de la red local), escribir en un archivo / base de datos, comparar la lista actual con una plantilla determinada y enviar un mensaje al sistema SCADA a trav√©s de uno de los protocolos: SNMP, OPC. <br><br>  Como habr√°s adivinado por el t√≠tulo del art√≠culo, ya ten√≠a una tarea dif√≠cil para elegir el m√©todo de recuperaci√≥n de la lista.  Como de costumbre, decid√≠ buscar el correcto en el motor de b√∫squeda, hice preguntas sobre recursos especializados ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos</a> , por alguna raz√≥n, a stackoverflow en ingl√©s no me gust√≥ mi pregunta y tuve que eliminarlo), pero todas las respuestas no dieron el resultado deseado.  Por lo tanto, tuve que resolverlo yo mismo, lo que se discutir√° m√°s adelante. <br><br><h2>  Comandos de la consola </h2><br>  Comencemos con uno simple y aprovechemos lo que Windows nos ofrece sin usar herramientas de terceros.  Esto se puede hacer usando los siguientes comandos: <br><br><ul><li>  wmic qfe list </li><li>  systeminfo </li><li>  dism / online / get-packages </li><li>  a trav√©s de PowerShell: <br><br><ul><li>  <b>Obtener revisi√≥n</b> </li><li>  <b>Get-SilWindowsUpdate</b> (solo disponible en ediciones de servidor) </li><li>  <b>Get-WmiObject -Class win32_quickfixengineering</b> - a trav√©s del acceso a la clase WMI win32_quickfixengineering (sobre WMI un poco m√°s tarde) </li></ul><br></li></ul><br><br>  Puede obtener la lista a trav√©s de la interfaz gr√°fica a trav√©s del elemento est√°ndar del Panel de control "Agregar o quitar programas", pero no podemos copiar nada desde all√≠.  Cada herramienta del panel de control est√° representada por un archivo .cpl en la carpeta Windows \ System.  Los archivos .pl en la carpeta del sistema de Windows se descargan autom√°ticamente cuando se inicia el panel de control.  El archivo Appwiz.cpl es responsable del elemento del programa.  Su an√°lisis no condujo a nada. <br><br>  La salida del comando de la consola se puede redirigir a un archivo y luego se puede analizar, pero esto es incorrecto, m√°s una llamada al programa (de acuerdo con las reglas de SB, no funcionar√°) y no se trata de recibir la lista de forma remota.  Por lo tanto, le sugiero que simplemente llame a los comandos, compare el n√∫mero de actualizaciones en cada lista, con la lista a trav√©s del Panel de control y contin√∫e nuestra investigaci√≥n. <br><br>  Formalmente, todos los m√©todos para obtener la lista de actualizaciones se pueden dividir en dos grupos: local y de red. <br><br><img src="https://habrastorage.org/webt/jw/jt/nf/jwjtnfe3m0dqr_cc9q9xybhf1ka.png" alt="Metodos locales y de red para obtener informaci√≥n."><br><br>  Todos los m√©todos se probaron en im√°genes limpias del sistema (Windows 7, 8, Server 2012 R2) con actualizaciones integradas, despu√©s de cada actualizaci√≥n a trav√©s del Centro de actualizaciones de los servidores oficiales de Microsoft se realiz√≥ una verificaci√≥n adicional.  Deteng√°monos en cada uno de ellos con m√°s detalle. <br><br><h2>  WUA </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WUApi</a> (API del Agente de Windows Update): uso de la API del Agente de Windows Update.  La opci√≥n m√°s obvia, cuyo nombre habla por s√≠ mismo.  Usaremos la biblioteca Wuapi.dll para esto. <br><blockquote>  Nota: en lo sucesivo, para mi comodidad, incrustar√© todos los resultados en la Lista.  Esto puede no ser racional, pero me pareci√≥ una buena idea. </blockquote><div class="spoiler">  <b class="spoiler_title">Ejemplo de implementaci√≥n</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WUApiLib; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listUpdateHistory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//WUApi List&lt;string&gt; result = new List&lt;string&gt;(200); try { UpdateSession uSession = new UpdateSession(); IUpdateSearcher uSearcher = uSession.CreateUpdateSearcher(); uSearcher.Online = false; ISearchResult sResult = uSearcher.Search("IsInstalled=1 And IsHidden=0"); string sw = "   WUApi: " + sResult.Updates.Count; result.Add(sw); foreach (WUApiLib.IUpdate update in sResult.Updates) { result.Add(update.Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre> <br></div></div><br>  Hay una segunda variaci√≥n de este m√©todo: <b>Sesi√≥n de actualizaci√≥n</b> : recibir informaci√≥n conect√°ndose a la sesi√≥n de actualizaci√≥n del Agente de Windows Update (en este caso, no trabajamos directamente con la biblioteca). <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de implementaci√≥n</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sessionlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pc</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    object sess = null; object search = null; object coll = null; try { sess = Activator.CreateInstance(Type.GetTypeFromProgID("Microsoft.Update.Session", pc)); search = (sess as dynamic).CreateUpdateSearcher(); int n = (search as dynamic).GetTotalHistoryCount(); int kol = 0; //coll = (search as dynamic).QueryHistory(1, n); coll = (search as dynamic).QueryHistory(0, n); result.Add("  Update.Session: " + n); foreach (dynamic item in coll as dynamic) { if (item.Operation == 1) result.Add(item.Title); kol++; //Console.WriteLine(": " + kol); } result.Add("  : " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } finally { if (sess != null) Marshal.ReleaseComObject(sess); if (search != null) Marshal.ReleaseComObject(search); if (coll != null) Marshal.ReleaseComObject(coll); } return result; }</span></span></code> </pre><br></div></div><br>  Microsoft sugiere el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uso</a> remoto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de la API</a> . <br><br>  Las principales desventajas de estos dos m√©todos son que no le permiten encontrar correcciones de KB que no se distribuyen a trav√©s de Windows Update.  Solo puede ver lo que pas√≥ por el agente de actualizaci√≥n en s√≠, es decir, esta opci√≥n no nos conviene. <br><br><h2>  DISM </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Deployment Image Servicing and Management</a> es una herramienta de l√≠nea de comandos que se puede utilizar para dar servicio a una imagen de Windows o para preparar una imagen de un entorno de preinstalaci√≥n de Windows (Windows PE).  Es un reemplazo para Package Manager (Pkgmgr.exe), PEimg e Intlcfg. <br><br>  Esta utilidad se utiliza para integrar actualizaciones, paquetes de servicio en la imagen del sistema.  Las actualizaciones de Windows son m√≥dulos separados que se pueden presentar de varias maneras: <br><br><ul><li>  Archivos .cab (gabinete) - archivos.  Dise√±ado para distribuci√≥n e instalaci√≥n utilizando m√≥dulos de Windows Update en modo automatizado; </li><li>  Archivos .msu (paquete independiente de Microsoft Update): archivos ejecutables.  Dise√±ado para su distribuci√≥n e instalaci√≥n por los propios usuarios en modo manual a trav√©s del cat√°logo de actualizaciones de Microsoft.  De hecho, son un conjunto empaquetado que consta de archivos .cab-, .xml, .txt. </li></ul><br>  El <b>comando</b> anteriormente mencionado <b>dism / online / get-packages</b> muestra informaci√≥n b√°sica sobre todos los paquetes en la imagen de wim / sistema actual.  Microsoft se ha ocupado de nosotros y proporciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquetes NuGet</a> para un uso conveniente de la API. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de implementaci√≥n</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.Dism; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DISMlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">220</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DismApi.Initialize(DismLogLevel.LogErrors); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dismsession = DismApi.OpenOnlineSession(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listupdate = DismApi.GetPackages(dismsession); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ab = listupdate.Count; <span class="hljs-comment"><span class="hljs-comment">//Console.WriteLine("   DISM: " + ab); string sw = "   DISM: " + ab; result.Add(sw); foreach (DismPackage feature in listupdate) { result.Add(feature.PackageName); //result.Add($"[ ] {feature.PackageName}"); //result.Add($"[ ] {feature.InstallTime}"); //result.Add($"[ ] {feature.ReleaseType}"); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  El n√∫mero de actualizaciones coincidi√≥ con el n√∫mero de la lista del Panel de control hasta la primera actualizaci√≥n a trav√©s del centro de control; despu√©s de eso, el n√∫mero de actualizaciones disminuy√≥ (fueron 214, se convirti√≥ en 209), aunque l√≥gicamente deber√≠an haber aumentado.  Ejemplos de salida <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Antes de actualizar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Despu√©s de actualizar</a> . <br><br>  Cu√°l es la raz√≥n de esto, solo puedo especular: quiz√°s algunas actualizaciones reemplazaron a las anteriores, por lo tanto, el n√∫mero se volvi√≥ menos. <br><br>  Un poco m√°s tarde, encontr√© una utilidad del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DISM ++</a> chino, que no se basa en la API DISM o la API DISM Core, pero las bibliotecas que tiene no tienen los m√©todos que necesito abrir, por lo que abandon√© esta idea y continu√© buscando m√°s. <br><br><h2>  WSUS </h2><br>  Windows Server Update Services ( <a href="">WSUS</a> ) es un servidor para actualizar sistemas operativos y productos de Microsoft.  El servidor de actualizaci√≥n se sincroniza con el sitio web de Microsoft, descargando actualizaciones que pueden distribuirse dentro de la LAN corporativa.  Una vez m√°s, una herramienta especial dise√±ada para trabajar con actualizaciones. <br><br>  Distribuido solo en las ediciones del servidor de Windows, por lo que se implement√≥ el siguiente soporte: <br><br><ul><li>  el sistema principal es Windows Server 2016; </li><li>  y a trav√©s del sistema de virtualizaci√≥n Hyper-V, se implementaron dos sistemas operativos cliente: <br><ul><li>  Windows 8.1 </li><li>  Windows 7 </li></ul><br></li></ul><br>  Todos los sistemas est√°n conectados a una √∫nica red de √°rea local virtual, pero <u>sin acceso a Internet</u> . <br><br><div class="spoiler">  <b class="spoiler_title">Algunos consejos</b> <div class="spoiler_text">  Para no asignar una partici√≥n de disco duro para el nuevo sistema, uso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WinNTSetup</a> e instalo el sistema en discos VHD: el cargador de arranque, que comienza con Windows 7 (ediciones Professional / Ultimate), se adapta perfectamente al arranque desde una imagen de disco.  Los discos as√≠ obtenidos se pueden usar de forma segura en Hyper-V: matas dos p√°jaros de un tiro a la vez.  Recuerde hacer una copia del repositorio BCD por adelantado a trav√©s del <b>comando bcdedit / export e: \ bcd_backup.bcd</b> . <br><br>  No quer√≠a configurar AD para la distribuci√≥n de actualizaciones, por lo tanto, simplemente registr√© la ruta al servidor WSUS en las pol√≠ticas de grupo: <br><br><img src="https://habrastorage.org/webt/j6/7f/v0/j67fv0mdw8mr8l0m73fowtmm238.png" alt="Configuraciones"><br><br>  Aseg√∫rese de prestar atenci√≥n al puerto, debido a un error tipogr√°fico (8350 en lugar de 8530) no pude recibir actualizaciones en las m√°quinas cliente, aunque todo se hizo correctamente.  Adem√°s, los nombres de los elementos en las pol√≠ticas de grupo en Windows 7 y Windows 8 son diferentes. <br><br>  Para recibir el informe utilizando WSUS, debe instalar adicionalmente el paquete; el sistema se lo notificar√°. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Y ahora un peque√±o c√≥digo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      using Microsoft.UpdateServices.Administration; public static List&lt;string&gt; GetWSUSlist(params string[] list) { List&lt;string&gt; result = new List&lt;string&gt;(200); //    string namehost = list[0]; // ,     string = "example1"; string servername = list[1]; //  string = "WIN-E1U41FA6E55"; string Username = list[2]; string Password = list[3]; try { ComputerTargetScope scope = new ComputerTargetScope(); IUpdateServer server = AdminProxy.GetUpdateServer(servername, false, 8530); ComputerTargetCollection targets = server.GetComputerTargets(scope); // Search targets = server.SearchComputerTargets(namehost); // To get only on server FindTarget method IComputerTarget target = FindTarget(targets, namehost); result.Add(" : " + target.FullDomainName); IUpdateSummary summary = target.GetUpdateInstallationSummary(); UpdateScope _updateScope = new UpdateScope(); // See in UpdateInstallationStates all other properties criteria //_updateScope.IncludedInstallationStates = UpdateInstallationStates.Downloaded; UpdateInstallationInfoCollection updatesInfo = target.GetUpdateInstallationInfoPerUpdate(_updateScope); int updateCount = updatesInfo.Count; result.Add(" -   - " + updateCount); foreach (IUpdateInstallationInfo updateInfo in updatesInfo) { result.Add(updateInfo.GetUpdate().Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; } public static IComputerTarget FindTarget(ComputerTargetCollection coll, string computername) { foreach (IComputerTarget target in coll) { if (target.FullDomainName.Contains(computername.ToLower())) return target; } return null; }</span></span></code> </pre><br></div></div><br>  Como no hay Internet, la situaci√≥n con las actualizaciones aparece como en la siguiente captura de pantalla: <br><br><img src="https://habrastorage.org/webt/az/gc/le/azgclepy6kznsibmilm1psoewa8.png"><br><br>  El comportamiento es similar a WUApi: si las actualizaciones no han pasado por ellos, entonces no lo saben.  Por lo tanto, este m√©todo no funciona nuevamente. <br><br><h2>  Wmi </h2><br>  El Instrumental de administraci√≥n de Windows ( <b>WMI</b> ) en traducci√≥n literal es un kit de herramientas de administraci√≥n de Windows. <br><br>  WMI es un est√°ndar implementado por Microsoft para administrar una empresa a <u>trav√©s de Internet</u> para la administraci√≥n centralizada y el monitoreo de varias partes de una infraestructura inform√°tica que ejecuta una plataforma Windows.  WMI es un sistema abierto unificado de interfaces de acceso a cualquier par√°metro del sistema operativo, dispositivos y aplicaciones que operan en √©l. <br><br>  Este m√©todo le permite recibir datos tanto de la m√°quina local como de forma remota dentro de la red local.  Para acceder a los objetos WMI, se utiliza un lenguaje de consulta WMI (WQL) espec√≠fico, que es una de las variedades de SQL.  <b>Recibiremos</b> la lista a trav√©s de la clase WMI <b>win32_quickfixengineering</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de implementaci√≥n</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Management; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWMIlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] list</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ManagementScope Scope; string ComputerName = list[0]; string Username = list[1]; string Password = list[2]; int kol = 0; if (!ComputerName.Equals("localhost", StringComparison.OrdinalIgnoreCase)) { //    ,      //  . ConnectionOptions Conn = new ConnectionOptions(); Conn.Username = Username; Conn.Password = Password; //      ¬´NTLMDOMAIN:¬ª  NTLM  ,       NTLM. Conn.Authority = "ntlmdomain:DOMAIN"; Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), Conn); } else Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), null); try { Scope.Connect(); ObjectQuery Query = new ObjectQuery("SELECT * FROM Win32_QuickFixEngineering"); ManagementObjectSearcher Searcher = new ManagementObjectSearcher(Scope, Query); foreach (ManagementObject WmiObject in Searcher.Get()) { result.Add(WmiObject["HotFixID"].ToString()); //Console.WriteLine("{0,-35} {1,-40}", "HotFixID", WmiObject["HotFixID"]);// String //result.Add(); /*result.Add("{0,-17} {1}", " : ", WmiObject["Description"]); result.Add("{0,-17} {1}", ": ", WmiObject["Caption"]); result.Add("{0,-17} {1}", " : ", WmiObject["InstalledOn"]);*/ kol++; } result.Add("  " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  Cuantitativamente, todo coincide (incluso despu√©s de las actualizaciones), por lo que se decidi√≥ utilizar este m√©todo.  Para la creaci√≥n program√°tica de solicitudes WMI, le aconsejo que use la siguiente utilidad: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WMI Delphi Code Creator</a> .  Gracias a ella, mir√© mi c√≥digo un poco diferente y decid√≠ usar un espacio en blanco de este programa. <br><br><h2>  XML </h2><br>  Los datos obtenidos por el m√©todo WMI no me detuvieron, y decid√≠ "ingenier√≠a inversa de superficie".  Utilizaremos la utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Process Monitor</a> de la colecci√≥n de software <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sysinternals Suite</a> para identificar los archivos y las ramas de registro que se usan al llamar a los comandos de la consola enumerados anteriormente y acceder al elemento "Actualizaciones instaladas" a trav√©s del Panel de control. <br><br>  Me llam√≥ la atenci√≥n el archivo wuindex.xml ubicado en la carpeta C: \ Windows \ servicing \ Packages \.  Para analizarlo, se escribi√≥ el siguiente programa: <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de aplicaci√≥n de consola</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Xml; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text.RegularExpressions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">XMLviewer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> writePath = AppDomain.CurrentDomain.BaseDirectory + <span class="hljs-string"><span class="hljs-string">"XML  "</span></span> + Environment.MachineName + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(writePath)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  txt "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" XML .txt ,   "</span></span>); File.Delete(writePath); } <span class="hljs-comment"><span class="hljs-comment">//      KB Regex regex = new Regex(@"KB[0-9]{6,7}"); //Regex(@"(\w{2}\d{6,7}) ?"); //SortedSet    ,     ""     SortedSet&lt;string&gt; spisok = new SortedSet&lt;string&gt;(); XmlDocument xDoc = new XmlDocument(); string path = "C:\\Windows\\servicing\\Packages\\wuindex.xml"; //   xml xDoc.Load(path); int kol = 0; //-  int total = 0; //-    xml int total2 = 0; //-   XmlNodeList name = xDoc.GetElementsByTagName("Mappings"); foreach (XmlNode xnode in name) { //Console.WriteLine(xnode.Name); kol++; XmlNode attr = xnode.Attributes.GetNamedItem("UpdateId"); //Console.WriteLine(attr.Value); foreach (XmlNode childnode in xnode.ChildNodes) { XmlNode childattr = childnode.Attributes.GetNamedItem("Package"); total++; //Console.WriteLine(childattr.Value); MatchCollection matches = regex.Matches(childattr.Value); if (matches.Count &gt; 0) { foreach (Match match in matches) //Console.WriteLine(match.Value); spisok.Add(match.Value); } else { //Console.WriteLine("  "); } } } try { StreamWriter sw = new StreamWriter(writePath); foreach (string element in spisok) { //Console.WriteLine(element); sw.WriteLine(element); total2++; } sw.Close(); } catch (Exception ex) { Console.WriteLine(": " + ex.Message); } //Console.WriteLine("\n"); Console.WriteLine(" : " +kol); Console.WriteLine("    xml: " + total); Console.WriteLine(" KB : " + total2); Console.WriteLine("    ."); Console.Read(); } } }</span></span></code> </pre><br></div></div><br>  Desafortunadamente, este archivo no se encuentra en todos los sistemas y el principio de su generaci√≥n y actualizaci√≥n ha sido un misterio para m√≠.  Por lo tanto, nuevamente este m√©todo no nos conviene. <br><br><h2>  Cbs </h2><br>  Aqu√≠ llegamos a lo que todos estos m√©todos est√°n asociados.  Continuando con el an√°lisis de los registros de Process Monitor, identifiqu√© las siguientes carpetas y archivos. <br><br>  El archivo DataStore.edb ubicado en la <b>carpeta C: \ Windows \ SoftwareDistribution \ DataStore</b> .  Esta es una base de datos que contiene el historial de todas las actualizaciones de la versi√≥n instalada de Windows, incluidas las que solo est√°n en cola. <br><br>  El programa ESEDatabaseView se utiliz√≥ para analizar el archivo DataStore.edb.  Hay una tabla tbUpdates en la base de datos, cuyo contenido es dif√≠cil de interpretar. <br><br><img src="https://habrastorage.org/webt/n4/1v/b0/n41vb0kmc5axymvp2gd3qax5bek.png" alt="Tabla TbUpdates en ESEDatabaseView"><br><br>  Despu√©s de llamar mi atenci√≥n sobre el proceso <b>TiWorker.exe</b> , que se llamaba cada vez que abr√≠a un elemento en el Panel de control.  √âl "camin√≥" a trav√©s de muchas carpetas, una de las cuales me llev√≥ por el camino correcto. <br><br>  <b>C: \ Windows \ SoftwareDistribution</b> es una carpeta utilizada por Windows Update para descargar actualizaciones a una computadora e instalarlas, y tambi√©n almacena informaci√≥n sobre todas las actualizaciones instaladas previamente. <br><br>  Carpeta WinSxS ubicada en <b>C: \ Windows \ winsxs</b> .  Esta es la carpeta de servicio del sistema operativo Windows utilizada para almacenar versiones instaladas previamente de componentes del sistema.  Debido a su presencia, es posible volver a una versi√≥n anterior de la actualizaci√≥n si es necesario. <br><br>  <b>C: \ Windows \ servicing</b> : el componente principal de todo el sistema, cuyo nombre es <b>Servicio basado en componentes (CBS)</b> . <br><br>  CBS es un servicio basado en componentes que forma parte de Windows y est√° integrado con el servicio de actualizaci√≥n de Windows.  A diferencia <b>del servicio de mantenimiento basado</b> en <b>archivos (FBS)</b> (para sistemas operativos anteriores a Windows Vista), en el que los archivos se actualizaban directamente en los directorios del sistema, CBS introdujo una jerarqu√≠a completa de directorios y una familia completa (pila) de m√≥dulos / bibliotecas de servicios. <br><br>  <b>CbsApi.dll</b> es la biblioteca principal de soporte de tecnolog√≠a CBS.  No tiene m√©todos abiertos, por lo que no podr√≠a usarlo directamente.  Microsoft usa TrustedInstaller.exe y TiWorker.exe para acceder a los m√©todos de esta biblioteca y ya a trav√©s de estos procesos muestra los datos que necesitamos.  Los registros se mantienen en <b>C: \ Windows \ Logs \ CBS \ CBS.log</b> . <br><br>  En el momento de la creaci√≥n del prototipo del programa (puede ver mayo de 2019 en las capturas de pantalla), no hab√≠a informaci√≥n en ruso sobre CBS, pero a fines de agosto hab√≠a un muy buen art√≠culo de blog: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://datadump.ru/component-based-servicing</a> .  Un art√≠culo muy interesante que confirm√≥ mi experiencia y recopil√≥ la informaci√≥n necesaria.  Y m√°s sobre el tema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://www.outsidethebox.ms/17988/</a> <br><br><h2>  Conclusi√≥n </h2><br>  Microsoft ha complicado demasiado la tarea trivial de obtener una lista de actualizaciones y ha hecho que este proceso no sea del todo obvio.  Todo esto se hace por seguridad, pero no por facilidad de uso.  Estoy de acuerdo con el autor del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> : la previsibilidad y la transparencia comenzaron a faltar al recibir actualizaciones. <br><br>  Como resultado del estudio, se escribi√≥ el siguiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programa</a> , cuya demostraci√≥n se puede ver en este video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SNxReaN4EKY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Los planes para agregar: <br><br><ol><li>  comparar la lista de actualizaciones necesarias con la recibida; </li><li>  env√≠e el resultado a trav√©s de SNMP / OPC (si alguien tiene experiencia, comparta los comentarios); </li><li>  organizar la instalaci√≥n de las actualizaciones "fuera de l√≠nea" que faltan de la carpeta especificada. </li></ol><br>  Si conoce m√°s m√©todos para obtener una lista no solo de actualizaciones, sino tambi√©n componentes adicionales (Adobe Flash, Acrobat Reader, etc.) o si tiene otras sugerencias interesantes, escr√≠balas en los comentarios o en mensajes privados. Estar√© encantado de recibir cualquier comentario .  Y participe en la encuesta para este art√≠culo, as√≠ sabr√© si mi experiencia con la audiencia de Habrahabr ser√° interesante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467445/">https://habr.com/ru/post/467445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467429/index.html">Habrastatistics: explorando las secciones m√°s y menos visitadas del sitio</a></li>
<li><a href="../467435/index.html">Enviamos informes del agente Veeam Linux a correo o en Telegram</a></li>
<li><a href="../467437/index.html">MVCC en PostgreSQL-1. Aislamiento</a></li>
<li><a href="../467439/index.html">¬øPor qu√© regres√≥ el vinilo y c√≥mo se relacionan los servicios de transmisi√≥n con esto?</a></li>
<li><a href="../467443/index.html">Centro Multimedia "Kodi" y Proyecto Yocto</a></li>
<li><a href="../467449/index.html">Detecci√≥n de vulnerabilidades y evaluaci√≥n de resistencia a ataques de piratas inform√°ticos de tarjetas inteligentes y procesadores criptogr√°ficos con protecci√≥n incorporada</a></li>
<li><a href="../467453/index.html">Resolviendo el problema del n√∫mero 42 usando una supercomputadora planetaria</a></li>
<li><a href="../467455/index.html">Plantilla QBS para programar microcontroladores en QtCreator usando el ejemplo de los controladores Milander</a></li>
<li><a href="../467457/index.html">El camino desde la cirug√≠a hasta el desarrollo de juegos o la primera experiencia de desarrollo m√≥vil en Unity</a></li>
<li><a href="../467459/index.html">C√≥mo un microcontrolador puede leer datos a 1.6 Gbps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>