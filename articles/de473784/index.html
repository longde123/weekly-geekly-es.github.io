<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò¥ ‚åöÔ∏è üåú Wie schreibe ich einen intelligenten Vertrag f√ºr WebAssembly in einem Ontology-Netzwerk? Teil 2: C ++ ü•î üèåÔ∏è üç´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden zwei Beispiele zum Schreiben eines intelligenten Vertrags in C ++ mit WASM basierend auf dem Ontology-Blockchain-Netzwerk vor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie schreibe ich einen intelligenten Vertrag f√ºr WebAssembly in einem Ontology-Netzwerk? Teil 2: C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473784/"><img src="https://habrastorage.org/getpro/habr/post_images/3e1/ec5/4dd/3e1ec54ddc0f1d35cad05f7f2b6e600e.png" alt="Bild"><br><br>  In diesem Artikel werden zwei Beispiele zum Schreiben eines intelligenten Vertrags in C ++ mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WASM</a> basierend auf dem Ontology-Blockchain-Netzwerk vorgestellt.  Heute, nach mehreren Monaten stabilen Betriebs im Testmodus, hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ontology WASM</a> im Hauptnetzwerk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gestartet</a> , mit dem dApp-Vertr√§ge mit komplexer Gesch√§ftslogik schmerzlos und zu geringeren Kosten in die Blockchain √ºbertragen werden k√∂nnen, wodurch das dApp-√ñkosystem erheblich bereichert wird. <br><br>  Ontology Wasm unterst√ºtzt auch die Erstellung intelligenter Vertr√§ge in der Sprache Rust. Sie k√∂nnen hier dar√ºber lesen. <br><br>  Im Folgenden finden Sie zwei Beispiele f√ºr einen intelligenten Vertrag: Schreiben Sie zun√§chst ‚ÄûHallo Welt!‚Äú.  und erstellen Sie dann einen virtuellen Geldumschlag, der als Geschenk an einen Freund gesendet werden kann. <br><br><h2>  Entwicklung eines WASM-Vertrags mit C ++ </h2><br><a name="habracut"></a><br><h3>  Beispiel 1. Hallo Welt </h3><br>  Beginnen wir mit Hello World: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ontiolib/ontio.hpp&gt; #include&lt;stdio.h&gt; using namespace ontio; class hello:public contract { public: using contract::contract: void sayHello(){ printf("hello world!"); } }; ONTIO_DISPATCH(hello, (sayHello));</span></span></span></span></code> </pre> <br><h3>  Vertragserstellung </h3><br>  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ontology Wasm CDT-</a> Compiler enth√§lt einen Einstiegspunkt und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analyseparameter</a> , sodass Entwickler keine Eingabemethoden neu definieren m√ºssen.  Um die Logik des Dienstes zu schreiben, k√∂nnen Sie au√üerdem API-Methoden eines intelligenten Vertrags aufrufen. <br><br><pre> <code class="cpp hljs">ONTIO_DISPATCH(hello, (sayHello));</code> </pre> <br>  Im obigen Beispiel unterst√ºtzen wir bisher nur sayHello: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"hello world!"</span></span>);</code> </pre> <br>  "Hallo Welt!"  wird im Debug-Knotenprotokoll angezeigt.  Wenn Sie einen Smart-Vertrag direkt schreiben, kann printf nur zum Debuggen verwendet werden, da der Smart-Vertrag selbst mehr Funktionsbefehle enth√§lt. <br><br><h3>  Intelligente Vertrags-API </h3><br>  Ontology Wasm bietet die folgenden APIs f√ºr die Interaktion mit der Server-Blockchain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d29/dad/66d/d29dad66d40c938e872179cc3487172e.png" alt="Bild"><br><br><h2>  Beispiel 2: Geldumschlag </h2><br>  Schauen wir uns nun ein komplexeres Beispiel mit der Wasm Smart Contract API an. <br><br>  In diesem Beispiel schreiben wir einen virtuellen Geldumschlag. Ein Analogon zum roten Umschlag (Hongbao) ist eine beliebte Funktion des chinesischen Boten Wechat, mit der Sie in einem Chat Geld an Freunde senden k√∂nnen.  Der Benutzer erh√§lt eine Nachricht in Form eines roten Umschlags, √∂ffnet sie und das Geld wird automatisch dem Kontostand gutgeschrieben. <br><br>  Im Rahmen eines intelligenten Vertrags k√∂nnen Benutzer diesen Vertrag verwenden, um ONT-, ONG- oder OEP-4-Token mithilfe virtueller Geldumschl√§ge an ihre Freunde zu senden, die dann Token in ihre Blockchain-Brieftaschen √ºbertragen k√∂nnen. <br><br><h3>  Vorbereitung zum Erstellen eines Vertrags </h3><br>  Erstellen Sie zun√§chst die Quellvertragsdatei und nennen Sie sie redEnvelope.cpp.  Als n√§chstes ben√∂tigen wir drei APIs f√ºr diesen Vertrag: <br><br><ul><li>  <i>createRedEnvelope</i> : Erstellen Sie einen <i>Geldumschlag</i> </li><li>  <i>queryEnvelope</i> : Umschlaginformationen anfordern </li><li>  <i>ClaimEnvelope</i> : √ñffnen Sie einen Umschlag und erhalten Sie Geld </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ontiolib/ontio.hpp&gt; using namespace ontio; class redEnvlope: public contract{ } ONTIO_DISPATCH(redEnvlope, (createRedEnvlope)(queryEnvlope)(claimEnvelope));</span></span></span></span></code> </pre> <br>  Jetzt m√ºssen wir den Schl√ºsselwert speichern.  In einem intelligenten Vertrag werden die Daten im Kontext des Vertrags als Schl√ºsselwert gespeichert, und wir m√ºssen den KEY-Daten f√ºr eine nachfolgende Anforderung ein Pr√§fix hinzuf√ºgen. <br><br>  Im Folgenden definieren wir drei Pr√§fixe, die wir verwenden werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> rePrefix = <span class="hljs-string"><span class="hljs-string">"RE_PREFIX_"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sentPrefix = <span class="hljs-string"><span class="hljs-string">"SENT_COUNT_"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> claimPrefix = <span class="hljs-string"><span class="hljs-string">"CLAIM_PREFIX_"</span></span>;</code> </pre><br>  Da der Vertrag beide Ontologie-Token - ONT und ONG - unterst√ºtzt, k√∂nnen wir deren Vertragsadresse im Voraus bestimmen.  Im Gegensatz zu einem Standard-Smart-Vertrag ist die eigene Vertragsadresse von Ontology festgelegt und wird nicht aus dem Hash des Vertrags abgeleitet. <br><br><pre> <code class="cpp hljs">address ONTAddress = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}; address ONGAddress = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>};</code> </pre> <br>  Als N√§chstes m√ºssen Sie Informationen zum verwendeten Token im Vertrag speichern: die Adresse des Vertragstokens, den Gesamtbetrag des Umschlags und die Anzahl der Umschl√§ge. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receiveRecord</span></span></span><span class="hljs-class">{</span></span> address account; <span class="hljs-comment"><span class="hljs-comment">//User address asset amount; //Received amount ONTLIB_SERIALIZE(receiveRecord,(account)(amount)) }; struct envlopeStruct{ address tokenAddress; //Token asset address asset totalAmount; //Total amount asset totalPackageCount; //Total number of red envelope asset remainAmount; //Remaining amount asset remainPackageCount; //Remaining number of red envelope std::vector&lt;struct receiveRecord&gt; records; //Received records ONTLIB_SERIALIZE( envlopeStruct, (tokenAddress)(totalAmount)(totalPackageCount)(remainAmount)(remainPackageCount)(records) ) };</span></span></code> </pre> <br>  Das Folgende ist die Makrooperation, die vom Ontology Wasm CDT definiert wird und f√ºr die Serialisierung vor der Datenstrukturierung verwendet wird. <br><br><pre> <code class="cpp hljs">ONTLIB_SERIALIZE(receiveRecord,(account)(amount))</code> </pre> <br><h3>  Umschlag erstellen </h3><br>  Nachdem wir die erforderlichen Vorbereitungen getroffen haben, werden wir mit der Entwicklung der API-Logik beginnen. <br><br>  1. Beim Erstellen eines Geldumschlags m√ºssen die Adresse des Eigent√ºmers, die Anzahl und Anzahl der Umschl√§ge sowie die Adresse des Tokens angegeben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRedEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address owner,asset packcount, asset amount,address tokenAddr )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  2. √úberpr√ºfen Sie die Unterschrift des Eigent√ºmers. Andernfalls wird ein Rollback (Rollback der Transaktion) durchgef√ºhrt und Folgendes beendet: <br><br><pre> <code class="cpp hljs">ontio_assert(check_witness(owner),<span class="hljs-string"><span class="hljs-string">"checkwitness failed"</span></span>);</code> </pre> <br>  <i>Hinweis</i> : ontio_assert (expr, errormsg): false expr gibt einen Fehler zur√ºck und beendet den Vertrag. <br><br>  3. Wenn ein ONT-Token in einem Umschlag verwendet wird, ist es wichtig zu beachten, dass ONT nicht fragmentiert ist (mindestens 1 ONT).  Dann muss der Gesamtbetrag des Geldumschlags gr√∂√üer oder gleich der Anzahl der Token sein, um sicherzustellen, dass jeder Umschlag mindestens 1 ONT enth√§lt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(tokenAddr)){ ontio_assert(amount &gt;= packcount,<span class="hljs-string"><span class="hljs-string">"ont amount should greater than packcount"</span></span>); }</code> </pre> <br>  4. Als n√§chstes bestimmen wir f√ºr den Inhaber des Umschlags die Gesamtzahl der Geldumschl√§ge, die er sendet: <br><br><pre> <code class="cpp hljs">key sentkey = make_key(sentPrefix,owner.tohexstring()); asset sentcount = <span class="hljs-number"><span class="hljs-number">0</span></span>; storage_get(sentkey,sentcount); sentcount += <span class="hljs-number"><span class="hljs-number">1</span></span>; storage_put(sentkey,sentcount);</code> </pre> <br>  5. Generieren Sie den Hash des Umschlags - die Kennung, die diesen Umschlag kennzeichnet: <br><br><pre> <code class="cpp hljs">H256 hash ; hash256(make_key(owner,sentcount),hash) ; key rekey = make_key(rePrefix,hash256ToHexstring(hash));</code> </pre> <br>  6. Wir werden die Token in den Vertrag √ºbersetzen.  Wir ermitteln die Adresse des Vertrags, der gerade ausgef√ºhrt wird, mit dem Befehl self_address (). Anschlie√üend √ºbertragen wir die zugewiesene Anzahl von Token basierend auf der Art der Token in den Vertrag: <br><br><pre> <code class="cpp hljs">address selfaddr = self_address(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(tokenAddr)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ont::transfer(owner,selfaddr ,amount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer native token failed!"</span></span>); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONGToken(tokenAddr)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ong::transfer(owner,selfaddr ,amount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer native token failed!"</span></span>); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; params = pack(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"transfer"</span></span>),owner,selfaddr,amount); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res; call_contract(tokenAddr,params, res ); ontio_assert(res,<span class="hljs-string"><span class="hljs-string">"transfer oep4 token failed!"</span></span>); }</code> </pre><br>  <u>Hinweis 1:</u> F√ºr ONT und ONG bietet Ontology Wasm CDT die ont :: transfer-API zum √úbertragen von Token.  OEP-4-Token m√ºssen mit der herk√∂mmlichen vertrags√ºbergreifenden Anrufmethode gesendet werden. <br><br>  <u>Hinweis 2:</u> Wie eine normale Brieftaschenadresse kann die Vertragsadresse jede Art von Token akzeptieren.  Die Vertragsadresse wird jedoch durch einen kompilierten bin√§ren Hash generiert und verf√ºgt daher nicht √ºber einen entsprechenden privaten Schl√ºssel und kann keine Vertragstoken verwenden.  Wenn Sie keinen privaten Schl√ºssel eingerichtet haben, k√∂nnen Sie diese Token nicht verwalten. <br><br>  7. Speichern Sie die Informationen zum Vertrag im Data Warehouse: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class"> ;</span></span> es.tokenAddress = tokenAddr; es.totalAmount = amount; es.totalPackageCount = packcount; es.remainAmount = amount; es.remainPackageCount = packcount; es.records = {}; storage_put(rekey, es);</code> </pre> <br>  8. Senden Sie eine Benachrichtigung √ºber die Erstellung des Umschlags.  Dies ist ein asynchroner Prozess zum Aufrufen eines intelligenten Vertrags. Der Vertrag sendet auch eine Benachrichtigung √ºber das Ergebnis der Ausf√ºhrung.  Das Ausf√ºhrungsformat kann vom Vertragsautor festgelegt werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer [<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"{\"states\":[\"%s\", \"%s\", \"%s\"]}"</span></span>,<span class="hljs-string"><span class="hljs-string">"createEnvlope"</span></span>,owner.tohexstring().c_str(),hash256ToHexstring(hash).c_str()); notify(buffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  Hurra, der Geldumschlag ist fast fertig.  Lassen Sie uns nun sehen, wie Sie Umschlaginformationen anfordern. <br><br><h3>  Abfrageumschlag (Abfrage </h3><br>  Die Logik der Anforderung ist recht einfach. Sie m√ºssen nur die Informationen und das Format aus dem Datenspeicher abrufen und dann Folgendes ausgeben: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queryEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash)</span></span></span></span>{ key rekey = make_key(rePrefix,hash); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class">;</span></span> storage_get(rekey,es); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> formatEnvlope(es); }</code> </pre> <br>  <u>Hinweis:</u> Bei schreibgesch√ºtzten intelligenten Vertragsvorg√§ngen (z. B. Abfragen) k√∂nnen Sie das Ergebnis vor der Ausf√ºhrung √ºberpr√ºfen.  Im Gegensatz zu einem regul√§ren Vertragsanruf erfordert Pre-Exec keine Brieftaschensignatur und daher keine Provision in ONG.  Anschlie√üend k√∂nnen andere Benutzer den Umschlag beantragen, wenn sie √ºber einen Umschlag-Hash (Umschlag-ID) verf√ºgen. <br><br><h3>  Umschlag empfangen </h3><br>  Zu diesem Zeitpunkt haben wir bereits erfolgreich Token an einen intelligenten Vertrag √ºbertragen. Damit Ihre Freunde erfolgreich einen Anteil am Umschlag beanspruchen k√∂nnen, m√ºssen Sie ihnen die Umschlagkennung (Hash) senden. <br><br>  1. Um einen Umschlag zu erhalten, m√ºssen Sie die Adresse Ihres Kontos und den Hash des Umschlags eingeben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">claimEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address account, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  2. Als N√§chstes √ºberpr√ºft der Vertrag die Unterschrift Ihres Kontos, um sicherzustellen, dass Sie dessen Eigent√ºmer sind.  Jedes Konto kann nur einmal einen Umschlag beantragen: <br><br><pre> <code class="cpp hljs">ontio_assert(check_witness(account),<span class="hljs-string"><span class="hljs-string">"checkwitness failed"</span></span>); key claimkey = make_key(claimPrefix,hash,account); asset claimed = <span class="hljs-number"><span class="hljs-number">0</span></span> ; storage_get(claimkey,claimed); ontio_assert(claimed == <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"you have claimed this envlope!"</span></span>);</code> </pre><br>  3. √úberpr√ºfen Sie, ob der Umschlag gem√§√ü den vom Gesch√§ft empfangenen Hash-Informationen empfangen wurde: <br><br><pre> <code class="cpp hljs">key rekey = make_key(rePrefix,hash); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class">;</span></span> storage_get(rekey,es); ontio_assert(es.remainAmount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"the envlope has been claimed over!"</span></span>); ontio_assert(es.remainPackageCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"the envlope has been claimed over!"</span></span>);</code> </pre> <br>  4. Erstellen eines Anspruchsdatensatzes: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receiveRecord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class"> ;</span></span> record.account = account; asset claimAmount = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  5. Berechnung des Betrags f√ºr jeden Umschlagantragsteller. <br>  F√ºr den letzten Teilnehmer wird der Betrag des Restbetrags bestimmt, f√ºr jeden anderen wird der deklarierte Betrag durch eine Zufallszahl bestimmt, die aus dem Hash des aktuellen Blocks und den aktuellen Informationen √ºber den Umschlag berechnet wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (es.remainPackageCount == <span class="hljs-number"><span class="hljs-number">1</span></span>){ claimAmount = es.remainAmount; record.amount = claimAmount; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ H256 random = current_blockhash() ; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> part[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(part,&amp;random,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> random_num = *(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>*)part; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> percent = random_num % <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; claimAmount = es.remainAmount * percent / <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-comment"><span class="hljs-comment">//ont case if (claimAmount == 0){ claimAmount = 1; }else if(isONTToken(es.tokenAddress)){ if ( (es.remainAmount - claimAmount) &lt; (es.remainPackageCount - 1)){ claimAmount = es.remainAmount - es.remainPackageCount + 1; } } record.amount = claimAmount; } es.remainAmount -= claimAmount; es.remainPackageCount -= 1; es.records.push_back(record);</span></span></code> </pre> <br><h3>  6. Gutschrift von Geldern </h3><br>  Der entsprechende Betrag an Token wird gem√§√ü dem Berechnungsergebnis auf das Konto der Umschlagantragsteller √ºberwiesen: <br><br><pre> <code class="cpp hljs">address selfaddr = self_address(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(es.tokenAddress)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ont::transfer(selfaddr,account ,claimAmount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer ont token failed!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONGToken(es.tokenAddress)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ong::transfer(selfaddr,account ,claimAmount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer ong token failed!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; params = pack(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"transfer"</span></span>),selfaddr,account,claimAmount); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; call_contract(es.tokenAddress,params, res ); ontio_assert(res,<span class="hljs-string"><span class="hljs-string">"transfer oep4 token failed!"</span></span>); }</code> </pre><br>  7. Wir werden Informationen √ºber den Erhalt von Geldern und aktualisierte Informationen √ºber den Umschlag im Tresor aufschreiben und eine Benachrichtigung √ºber die Vertragserf√ºllung senden: <br><br><pre> <code class="cpp hljs">storage_put(claimkey,claimAmount); storage_put(rekey,es); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer [<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"{\"states\":[\"%s\",\"%s\",\"%s\",\"%lld\"]}"</span></span>,<span class="hljs-string"><span class="hljs-string">"claimEnvlope"</span></span>,hash.c_str(),account.tohexstring().c_str(),claimAmount); notify(buffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Wie oben erw√§hnt, kann dieser Vertrag √ºber die ClaimEnvelope-API Token aus dem Vertrag senden.  Dies gew√§hrleistet die Sicherheit von Token, w√§hrend sie sich im Umschlag befinden, da niemand Verm√∂genswerte abheben kann, ohne die erforderlichen Anforderungen zu erf√ºllen. <br><br>  Fertig  Sie haben Ihren ersten intelligenten Vertrag geschrieben.  Den vollst√§ndigen Vertragscode finden Sie auf GitHub <a href="">hier</a> . <br><br><h3>  Vertragstests </h3><br>  Es gibt zwei M√∂glichkeiten, einen Vertrag zu √ºberpr√ºfen: <br><br><ol><li>  Verwenden Sie <a href="">CLI</a> </li><li>  Verwenden Sie das <a href="">Golang SDK</a> </li></ol><br><h2>  Fazit </h2><br>  In diesem Artikel haben wir dar√ºber gesprochen, wie ein intelligenter Vertrag f√ºr Ontolgy Wasm mithilfe der Blockchain-API erstellt wird.  Es bleibt das Datenschutzproblem zu l√∂sen, damit aus dem intelligenten Vertrag ein vollwertiges Produkt wird.  In dieser Phase des Codes kann jeder einen Hash des roten Umschlags erhalten, indem er die Aufzeichnungen des Vertrags verfolgt. Dies bedeutet, dass jeder einen Anteil am Umschlag beanspruchen kann.  Dieses Problem kann einfach gel√∂st werden - wir definieren eine Liste von Konten, die f√ºr einen Umschlag gelten k√∂nnen, wenn dieser erstellt wird.  Auf Wunsch kann diese Funktion auch getestet werden. <br><br><hr><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Holen Sie sich ein</a> Ontologie- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stipendium</a> f√ºr die dApp-Entwicklung ab 20.000 US-Dollar <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bewerben Sie sich f√ºr das</a> Ontology Student Talent Program <br><br><hr><br>  Bist du ein Entwickler?  Treten Sie unserer Tech-Community auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Discord bei</a> .  Besuchen Sie auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Developer Center</a> auf unserer Website, wo Sie Entwicklertools, Dokumentationen und vieles mehr finden. <br><br><h4>  Ontologie </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ontologie-Website</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwietracht</a> </li><li>  Telegramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Englisch</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Russisch</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reddit</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473784/">https://habr.com/ru/post/de473784/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473770/index.html">Statische Analyse gro√üer Mengen von Python-Code: Instagram-Erfahrung. Teil 2</a></li>
<li><a href="../de473774/index.html">Sichere Cloud in DF Cloud</a></li>
<li><a href="../de473776/index.html">Vereinheitlichung der Validierungsregeln am Beispiel von Asp Core + VueJS</a></li>
<li><a href="../de473778/index.html">Bildoptimierung: Verwendung der Vision AI von Google zum Verst√§ndnis der Bildranking-Prinzipien</a></li>
<li><a href="../de473780/index.html">Schnelle Konturerkennung in 4K-Video: Farbe und komplexe Formen</a></li>
<li><a href="../de473786/index.html">Die Registrierung f√ºr den Hackathon in Riga endet. Preis - Kurzzeittraining bei PhysTech</a></li>
<li><a href="../de473788/index.html">Mikroproteine ‚Äã‚Äãentdecken unbekannte Aspekte der modernen Biologie</a></li>
<li><a href="../de473790/index.html">Splines in 3D-Grafiken, die am meisten automatisierte Option</a></li>
<li><a href="../de473794/index.html">Mobile Phishing - Endlose Bedrohungen</a></li>
<li><a href="../de473796/index.html">Optischer HDMI Extender. 300 Meter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>