<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕖 🧜🏿 👩🏾‍🤝‍👨🏽 Fantoche + Hiera. Aperte o máximo 🍹 👉🏾 🕴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, gostaria de falar sobre como usamos o Puppet e o Hiera para configurar servidores virtuais e com ferro. Basicamente, será sobre a arquit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fantoche + Hiera. Aperte o máximo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/412587/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/vq/z-/bj/vqz-bjm4yx2wvhzcf-frffyuh04.png"></div><br><p>  Neste artigo, gostaria de falar sobre como usamos o <strong>Puppet</strong> e o <strong>Hiera</strong> para configurar servidores virtuais e com ferro.  Basicamente, será sobre a arquitetura e a hierarquia que inventamos, o que facilita e sistematiza a configuração dos servidores. </p><br><p>  Fui solicitado a escrever este artigo pelo fato de que, na Internet, não encontrei exemplos bons e realmente úteis de como você pode trabalhar com hiera e para que serve.  Basicamente, estes são tutoriais com exemplos para entrar no tópico.  Mas a aplicação prática real de hiera não está escrita lá.  Talvez eu não parecesse bem, mas aqui está um exemplo real que provavelmente o ajudará a colocar todos os pontos em cima de i, como fiz uma vez. </p><br><h3 id="dlya-kogo-byla-by-polezna-dannaya-statya">  Para quem este artigo seria útil </h3><br><p>  Se: </p><br><ul><li>  Você sabe o que são Puppet e Hiera, mas na verdade não as usa juntas, porque não está claro como fazê-lo e por que </li><li>  Você tem muitas equipes em sua empresa e precisa diferenciar de alguma forma a configuração do servidor no nível do comando </li><li>  Você usa um pappet e os arquivos de nós que você cresceu para tamanhos incríveis </li><li>  Você gosta de ler a configuração do servidor no formato divino yaml :) </li><li>  Você está basicamente interessado no tópico Gerenciamento de configuração e administração do sistema. </li></ul><br><p>  Este artigo é para você. </p><a name="habracut"></a><br><h3 id="prezhde-chem-nachat">  Antes de começar </h3><br><p>  Avisarei você imediatamente, o artigo acabou sendo longo, mas espero que seja útil.  Além disso, entende-se que você já conectou o hiera ao fantoche e pelo menos de alguma forma está familiarizado com o fantoche.  Se o hiera não estiver conectado, não será difícil. </p><br><ul><li>  Leia mais sobre o que é o Puppet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Puppet for beginners</a> . </li><li>  Como Hiera funciona - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apresentando em Hiera</a> . </li></ul><br><h3 id="vvodnye-dannye">  Dados de entrada </h3><br><ul><li>  Temos cerca de 30 equipes de desenvolvimento no SEMrush, cada uma com seus próprios servidores </li><li>  Cada equipe trabalha com seu próprio conjunto de tecnologias (PL, DBMS, etc.) </li><li>  As equipes podem e devem (idealmente) usar uma configuração comum para projetos específicos (reutilização de código) </li><li>  As próprias equipes gerenciam a implantação de aplicativos em seus servidores (isso não é feito pelo pappet) </li></ul><br><h3 id="nemnogo-istorii">  Um pouco de história </h3><br><p>  Inicialmente, tínhamos tudo no pappet da versão 3, depois decidimos implementar o 4º pappet, e todos os novos servidores começaram a ser colocados nele, e os antigos foram lentamente portados para o 4º. </p><br><p>  No terceiro pappet, costumávamos usar o sistema clássico de arquivos e módulos de nós.  Os módulos foram criados em um grupo especial de projetos no Gitlab, clonados em um servidor pappet (usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">r10k</a> ), os agentes do pappet foram ao assistente e receberam um diretório para aplicá-lo ao servidor. </p><br><p>  Então eles começaram a tentar não fazer isso e não usar módulos locais, mas colocaram links para os módulos necessários e seus repositórios no Puppetfile.  Porque  Como esses módulos são constantemente suportados e aprimorados (bem, idealmente) pela comunidade e pelos desenvolvedores, e os nossos locais não.  Mais tarde, eles introduziram o hiera e mudaram completamente para ele, e os arquivos dos nós (como o nodes.pp) caíram no esquecimento. </p><br><p> No quarto pappet, tentamos abandonar completamente os módulos locais e usar apenas módulos remotos.  Infelizmente, uma reserva deve ser inserida aqui novamente, pois "não funcionou completamente", às vezes você ainda precisa se inclinar e terminar alguma coisa.  Obviamente, existem apenas arquivos hiera e nenhum nó. </p><br><p>  <strong>Quando você tem 30 equipes com um zoológico de tecnologia, o problema de como manter esse zoológico com&gt; 1000 servidores se torna especialmente grave.</strong>  <strong>Além disso, direi como hiera nos ajuda nisso.</strong> </p><br><h3 id="ierarhiya">  Hierarquia </h3><br><p>  Hiera (de fato, da qual recebeu o nome) estabelece uma hierarquia.  Conosco, fica assim: </p><br><pre><code class="hljs axapta">--- :hierarchy: - <span class="hljs-string"><span class="hljs-string">"nodes/%{::fqdn}"</span></span> - <span class="hljs-string"><span class="hljs-string">"teams/%{::team}_team/nodes/%{::fqdn}"</span></span> - <span class="hljs-string"><span class="hljs-string">"teams/%{::team}_team/projects/%{::project}/tiers/%{::tier}"</span></span> - <span class="hljs-string"><span class="hljs-string">"teams/%{::team}_team/projects/%{::project}/%{::role}"</span></span> - <span class="hljs-string"><span class="hljs-string">"teams/%{::team}_team/projects/%{::project}"</span></span> - <span class="hljs-string"><span class="hljs-string">"teams/%{::team}_team/roles/%{::role}"</span></span> - <span class="hljs-string"><span class="hljs-string">"teams/%{::team}_team/%{::team}"</span></span> - <span class="hljs-string"><span class="hljs-string">"projects/%{::project}/tiers/%{::tier}/%{::role}"</span></span> - <span class="hljs-string"><span class="hljs-string">"projects/%{::project}/tiers/%{::tier}"</span></span> - <span class="hljs-string"><span class="hljs-string">"projects/%{::project}/%{::role}"</span></span> - <span class="hljs-string"><span class="hljs-string">"projects/%{::project}"</span></span> - <span class="hljs-string"><span class="hljs-string">"tiers/%{::tier}"</span></span> - <span class="hljs-string"><span class="hljs-string">"virtual/%{::virtual}"</span></span> - <span class="hljs-string"><span class="hljs-string">"os/%{::operatingsystem}/%{::operatingsystemmajrelease}"</span></span> - <span class="hljs-string"><span class="hljs-string">"os/%{::operatingsystem}"</span></span> - users - <span class="hljs-keyword"><span class="hljs-keyword">common</span></span></code> </pre> <br><p>  Primeiro, vamos lidar com variáveis ​​obscuras (fatos). </p><br><p>  Cada servidor no SEMrush deve idealmente ter 4 fatos especiais expostos que descrevam sua afiliação: </p><br><ul><li>  fato da <strong><code>team</code></strong> - a qual equipe pertence </li><li>  <strong><code>project</code></strong> fato - a qual projeto ele se relaciona </li><li>  fato do <strong><code>role</code></strong> - que papel esse projeto tem </li><li>  fato da <strong><code>tier</code></strong> - que tipo de preparação ela possui (prod, test, dev) </li></ul><br><p>  Como isso funciona?  O agente Pappet procura o mestre do Pappet e, com base nesses fatos, procura por arquivos para si mesmo, percorrendo as pastas de acordo com nossa hierarquia.  Não há necessidade de indicar que os arquivos de configuração pertencem aos servidores.  Em vez disso, os próprios servidores sabem quais arquivos pertencem a eles, observando apenas o caminho e os fatos. </p><br><p>  Durante a configuração do servidor, os administradores entram em contato com os desenvolvedores e especificam esses parâmetros (geralmente, pelo contrário, pessoas informadas entram em contato com os próprios administradores) para criar uma hierarquia no hiera no futuro, com base nos quais descrevem a configuração do servidor.  Esse sistema ajuda a reutilizar o código e a ser mais flexível em termos de configuração do servidor. </p><br><p>  Por exemplo, temos um projeto <em>especial</em> .  Neste projeto, pode haver algum servidor front-end com nginx, um servidor back-end com python, um cluster db com mysql, um servidor redis para armazenamento em cache.  Todos esses servidores devem ser colocados em um projeto chamado <strong>especial</strong> e depois atribuir <strong>funções</strong> aos servidores. </p><br><p>  No arquivo do projeto, descrevemos os parâmetros comuns a todo o projeto.  A primeira coisa que vem à mente é a criação em todos os servidores do usuário para implantação com a emissão dos direitos necessários a ele e a implementação de suas chaves ssh. </p><br><p>  Na função de cada servidor, o serviço geralmente é descrito e personalizado - para o que esse servidor se destina (nginx, python, mysql etc.). Camada nesse caso, definitivamente precisaremos se precisarmos implantar uma cópia do ambiente de produção na plataforma dev, mas mude algo (senhas, por exemplo).  Nesse caso, o servidor de desenvolvimento e o servidor de produtos diferem apenas no fato de a camada estar configurada na "posição" desejada (produto ou desenvolvimento).  E então um pouco de mágica e hiera farão o truque. </p><br><p>  Se precisarmos implantar dois servidores idênticos na mesma função, mas algo neles deve diferir, por exemplo, algumas linhas na configuração, outra parte da hierarquia será resgatada.  Colocamos os arquivos com o nome do formato <strong><code>{fqdn }.yaml</code></strong> no lugar certo (por exemplo, <strong><code>nodes/myserver.domain.net</code></strong> ), definimos os valores necessários das variáveis ​​no nível de um servidor específico, e o pappet aplicará a mesma configuração para os dois servidores para a função e exclusivo para cada dos servidores. </p><br><p>  Exemplo: dois backends com código php estão na mesma função e são completamente idênticos.  É claro que não queremos fazer backup dos dois servidores - não faz sentido.  Podemos criar uma função na qual descrever a mesma configuração para os dois servidores e, em seguida, criar outro arquivo <strong><code>nodes/backend1.semrush.net</code></strong> no qual colocar a configuração para backup. </p><br><p>  O arquivo em lote <strong><code>teams/team-name.yaml</code></strong> indica a configuração para todos os servidores que pertencem à equipe.  Na maioria das vezes, descreve os usuários que podem interagir com esses servidores, bem como seus direitos de acesso. </p><br><p>  Com base nessas variáveis, construímos essa <strong>hierarquia</strong> .  Quanto maior o arquivo encontrado na hierarquia, maior a prioridade da configuração especificada nele. </p><br><p>  Daqui resulta que as variáveis ​​podem <strong>substituir com</strong> base nessa hierarquia.  Ou seja, a variável no arquivo de função " <strong><code>projects/%{::project}/%{::role}</code></strong> " tem precedência sobre a variável no arquivo de projeto " <strong><code>projects/%{::project}</code></strong> ".  As variáveis ​​também podem ser mescladas em todos os níveis da hierarquia se você tiver um módulo e / ou perfil / função gravados de forma que possam ser executados.  Ao especificar a parte comum da configuração do mysql para todos os servidores de projeto, você pode adicionar partes especiais que têm peso para essa função à mesma variável em outros níveis da hierarquia (haverá uma seção adicional na configuração do escravo). </p><br><p>  Acontece que o arquivo do nó específico localizado ao longo do caminho “ <strong><code>hieradata/nodes/%{::fqdn}</code></strong> ” tem a maior prioridade.  A seguir, vem o arquivo do nó, mas já no nível do comando.  Abaixo está o bloco que descreve outros fatos mais gerais: </p><br><pre> <code class="hljs axapta"> - <span class="hljs-string"><span class="hljs-string">"virtual/%{::virtual}"</span></span> - <span class="hljs-string"><span class="hljs-string">"os/%{::operatingsystem}/%{::operatingsystemmajrelease}"</span></span> - <span class="hljs-string"><span class="hljs-string">"os/%{::operatingsystem}"</span></span> - users - <span class="hljs-keyword"><span class="hljs-keyword">common</span></span></code> </pre> <br><p>  Assim, no arquivo <strong><code>common.yaml</code></strong> , temos uma configuração que definitivamente deve chegar a <strong>todos os</strong> servidores, no arquivo <strong><code>users.yaml</code></strong> todos os usuários são descritos (mas nem todos são criados em servidores, é claro), em <strong><code>os/%{::operatingsystem}</code></strong> configuração geral típica para servidores com um sistema operacional específico (fact <code>::operatingsystem</code> ) e assim por diante. </p><br><p>  Eu acho que, olhando para essa hierarquia, tudo fica claro.  Abaixo, considerarei um exemplo do uso dessa hierarquia.  Mas primeiro você precisa falar sobre perfis. </p><br><h3 id="profili">  Perfis </h3><br><p>  Um ponto importante na configuração de servidores usando módulos é o uso de perfis.  Eles estão localizados no <strong><code>site/profiles</code></strong> do caminho e são os pontos de entrada para os módulos.  Graças a eles, você pode configurar com mais precisão os módulos suspensos no servidor e criar os recursos necessários. </p><br><p>  Considere um exemplo simples.  Há um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">módulo</a> que instala e configura redis.  E também queremos definir o parâmetro sysctl <code>vm.overcommit_memory</code> como 1 ao conectar este módulo, porque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Em seguida, escrevemos um pequeno perfil que fornece essa funcionalidade: </p><br><pre> <code class="hljs lua"># standalone redis server class profiles::db::redis ( Hash $<span class="hljs-built_in"><span class="hljs-built_in">config</span></span> = {}, String $output_buffer_limit_slave = <span class="hljs-string"><span class="hljs-string">'256mb 64mb 60'</span></span>, ) { # https://redis.<span class="hljs-built_in"><span class="hljs-built_in">io</span></span>/topics/faq#background-saving-fails-with-a-fork-<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>-under-linux-even-<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>-i-have-a-lot-of-free-ram sysctl { <span class="hljs-string"><span class="hljs-string">'vm.overcommit_memory'</span></span>: ensure =&gt; present, value =&gt; <span class="hljs-string"><span class="hljs-string">'1'</span></span>, } class { <span class="hljs-string"><span class="hljs-string">'::redis'</span></span>: * =&gt; $<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>, } }</code> </pre> <br><p>  Como mencionado acima, os perfis são uma ferramenta que permite alterar / melhorar o comportamento do módulo, além de reduzir o número de configurações no hiera.  Se você usar módulos remotos, poderá encontrar o problema de que os módulos “aprovados” geralmente não têm a funcionalidade necessária ou possuem alguns bugs / falhas.  Então, em princípio, você pode clonar este módulo e corrigir / adicionar funcionalidade.  Mas a decisão certa seria, se possível, escrever um bom perfil que possa "preparar" o módulo da maneira que você precisa.  Abaixo estão alguns exemplos de perfis e você pode entender melhor por que eles são necessários. </p><br><h3 id="sokrytie-sekretov-v-hiera">  Escondendo segredos em hiera </h3><br><p>  Uma das vantagens importantes do hiera, em comparação com o pappet simples, é a capacidade de armazenar dados confidenciais em arquivos de configuração em forma criptografada no repositório.  Suas senhas estarão seguras. </p><br><p>  Em resumo, você usa a chave pública para criptografar as informações necessárias e as coloca com essa linha no arquivo hiera.  A parte privada da chave é armazenada no pappet master, que permite descriptografar esses dados.  Mais detalhes podem ser encontrados na página do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto</a> . </p><br><p>  No cliente (computador de trabalho), a ferramenta é instalada simplesmente usando <strong><code>gem install hiera-eyaml</code></strong> .  Além disso, usando um comando no formato <strong><code>eyaml encrypt --pkcs7-public-key=/path/to/public_key.pkcs7.pem -s 'hello'</code></strong> você pode criptografar dados e colá-los em um arquivo com a extensão eyaml ou apenas yaml, dependendo de como configure e, em seguida, o pappet descobrirá isso.  Você obtém algo como: </p><br><pre> <code class="hljs ruby">roles::postrgresql::<span class="hljs-symbol"><span class="hljs-symbol">password:</span></span> <span class="hljs-string"><span class="hljs-string">'ENC[PKCS7,MIIBeQYJKoZIhvcNAQcDoIIBajCCAWYCAQAxggEhMIIBHQIBADAFMAACAQEwDQYJKoZIhvcNAQEBBQAEggEAbIz1ihQlThMWa9T+Lq194Y6QdElMD1XTev5y+VPSHtkPTu6Al6TJaSrXF+7phJIjue+NF4ZVtJCLkHxUR6nJJqks0fcGS1vF2+6mmM9cy69sIU1A3HqpOHZLuqHAc7jUqljYxpwWSIGOK6I2FygdAp5FfOTewqfcVVmXj97EJdcv3DKrbAlSrIMO2iZRYwQvyv+qnptnZ7pilR2veOCPW2UMm6zagDLutX9Ft5vERbdaiCiEfTOpVa9Qx0GqveNRVJLV/5lfcL5ajdNBJXkvKqDbx8d3ZBtEVAAqeKlw0LqzScgmCbWQx2kUzukX5LSxbTpT0Th984Vp1sl7iPk7UTA8BgkqhkiG9w0BBwEwHQYJYIZIAWUDBAEqBBCp5GcwidcEMA+0wjAMblkKgBCR/f9KGXUgLh3/Ok60OIT5]'</span></span></code> </pre> <br><p>  Ou uma sequência de várias linhas: </p><br><pre> <code class="hljs powershell">roles::postgresql::password: &gt; ENC[<span class="hljs-type"><span class="hljs-type">PKCS7</span></span>,<span class="hljs-type"><span class="hljs-type">MIIBeQYJKoZIhvcNAQcDoIIBajCCAWYCAQAxggEhMIIBHQIBADAFMAACAQEw</span></span> <span class="hljs-type"><span class="hljs-type">DQYJKoZIhvcNAQEBBQAEggEAbIz1ihQlThMWa9T</span></span>+<span class="hljs-type"><span class="hljs-type">Lq194Y6QdElMD1XTev5y</span></span> +<span class="hljs-type"><span class="hljs-type">VPSHtkPTu6Al6TJaSrXF</span></span>+<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-type"><span class="hljs-type">phJIjue</span></span>+<span class="hljs-type"><span class="hljs-type">NF4ZVtJCLkHxUR6nJJqks0fcGS1vF</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">6</span></span><span class="hljs-type"><span class="hljs-type">mmM9cy69sIU1A3HqpOHZLuqHAc7jUqljYxpwWSIGOK6I2FygdAp5FfOTe</span></span> <span class="hljs-type"><span class="hljs-type">wqfcVVmXj97EJdcv3DKrbAlSrIMO2iZRYwQvyv</span></span>+<span class="hljs-type"><span class="hljs-type">qnptnZ7pilR2veOCPW2UM</span></span> <span class="hljs-type"><span class="hljs-type">m6zagDLutX9Ft5vERbdaiCiEfTOpVa9Qx0GqveNRVJLV</span></span>/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-type"><span class="hljs-type">lfcL5ajdNBJXkv</span></span> <span class="hljs-type"><span class="hljs-type">KqDbx8d3ZBtEVAAqeKlw0LqzScgmCbWQx2kUzukX5LSxbTpT0Th984Vp1sl7</span></span> <span class="hljs-type"><span class="hljs-type">iPk7UTA8BgkqhkiG9w0BBwEwHQYJYIZIAWUDBAEqBBCp5GcwidcEMA</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">wjAM</span></span> <span class="hljs-type"><span class="hljs-type">blkKgBCR</span></span>/<span class="hljs-type"><span class="hljs-type">f9KGXUgLh3</span></span>/<span class="hljs-type"><span class="hljs-type">Ok60OIT5</span></span>]</code> </pre> <br><p>  Parece que terminamos a preparação, agora podemos considerar um exemplo. </p><br><h3 id="primer-na-palcah">  Exemplo de dedo </h3><br><p>  <strong>Spoiler</strong> : <em>haverá muito mais configurações, portanto quem estiver interessado neste artigo de interesse puramente teórico pode pular esta seção e ir até o final.</em> </p><br><p>  Vamos agora ver um exemplo de como configurar um servidor usando o hiera no puppet4.  Não publicarei o código para todos os perfis, porque, caso contrário, a postagem será muito grande.  Vou me concentrar na hierarquia e configuração da hiera. </p><br><p>  <strong>A tarefa é esta:</strong> precisamos implantar: </p><br><ul><li>  Dois servidores db idênticos nos quais o postgresql está implantado </li><li>  Mais dois servidores - front-end com nginx </li><li>  Quinto e sexto servidor - back-ends python no docker </li><li>  Tudo é o mesmo no ambiente de desenvolvimento, exceto por algumas configurações do servidor </li></ul><br><p>  Criaremos nossa hierarquia em ordem e começaremos com o arquivo do projeto. </p><br><h4 id="proekt">  Projeto </h4><br><p>  Crie o arquivo de projeto <strong><code>projects/kicker.yaml</code></strong> .  Colocamos nele o que é comum a todos os servidores: precisamos de alguns repositórios e pastas para a implantação, além do próprio usuário da implantação. </p><br><pre> <code class="hljs ruby">--- <span class="hljs-symbol"><span class="hljs-symbol">classes:</span></span> - apt::debian::semrush <span class="hljs-symbol"><span class="hljs-symbol">files:</span></span> <span class="hljs-string"><span class="hljs-string">"/srv/data"</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">ensure:</span></span> <span class="hljs-string"><span class="hljs-string">'directory'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">owner:</span></span> <span class="hljs-string"><span class="hljs-string">'deploy'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">group:</span></span> <span class="hljs-string"><span class="hljs-string">'www-data'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">mode:</span></span> <span class="hljs-string"><span class="hljs-string">'0755'</span></span> <span class="hljs-string"><span class="hljs-string">'/srv/data/shared_temp'</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">ensure:</span></span> <span class="hljs-string"><span class="hljs-string">'directory'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">owner:</span></span> <span class="hljs-string"><span class="hljs-string">'deploy'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">group:</span></span> <span class="hljs-string"><span class="hljs-string">'www-data'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">mode:</span></span> <span class="hljs-string"><span class="hljs-string">'0775'</span></span> user_management::<span class="hljs-symbol"><span class="hljs-symbol">present:</span></span> - deploy</code> </pre> <br><h4 id="rol-db">  Função db </h4><br><p>  Crie um arquivo de função para os servidores de banco de dados <strong><code>projects/kicker/db.yaml</code></strong> .  Até agora, faremos sem dividir os servidores em ambientes: </p><br><pre> <code class="hljs ruby">--- <span class="hljs-symbol"><span class="hljs-symbol">classes:</span></span> - profiles::db::postgresql profiles::db::postgresql::<span class="hljs-symbol"><span class="hljs-symbol">globals:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">manage_package_repo:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-symbol"><span class="hljs-symbol">version:</span></span> <span class="hljs-string"><span class="hljs-string">'10'</span></span> profiles::db::postgresql::<span class="hljs-symbol"><span class="hljs-symbol">db_configs:</span></span> <span class="hljs-string"><span class="hljs-string">'listen_addresses'</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">value:</span></span> <span class="hljs-string"><span class="hljs-string">'*'</span></span> profiles::db::postgresql::<span class="hljs-symbol"><span class="hljs-symbol">databases:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">kicker:</span></span> {} profiles::db::postgresql::<span class="hljs-symbol"><span class="hljs-symbol">hba_rules:</span></span> <span class="hljs-string"><span class="hljs-string">'local connect to kicker'</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">type:</span></span> <span class="hljs-string"><span class="hljs-string">'local'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">database:</span></span> <span class="hljs-string"><span class="hljs-string">'kicker'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">user:</span></span> <span class="hljs-string"><span class="hljs-string">'kicker'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">auth_method:</span></span> <span class="hljs-string"><span class="hljs-string">'md5'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">order:</span></span> <span class="hljs-string"><span class="hljs-string">'001'</span></span> <span class="hljs-string"><span class="hljs-string">'allow connect from 192.168.1.100'</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">type:</span></span> <span class="hljs-string"><span class="hljs-string">'host'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">database:</span></span> <span class="hljs-string"><span class="hljs-string">'kicker'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">user:</span></span> <span class="hljs-string"><span class="hljs-string">'kicker'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">auth_method:</span></span> <span class="hljs-string"><span class="hljs-string">'md5'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">address:</span></span> <span class="hljs-string"><span class="hljs-string">'192.168.1.100/32'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">order:</span></span> <span class="hljs-string"><span class="hljs-string">'002'</span></span></code> </pre> <br><p>  Aqui, conectamos um perfil escrito para uso geral por todos que desejam instalar o postgres em seu servidor.  O perfil é configurável e permite que você configure com flexibilidade o módulo antes de aplicá-lo. </p><br><p>  Para os mais curiosos, abaixo do código do gato para esse perfil: </p><br><div class="spoiler">  <b class="spoiler_title">Perfil :: db :: postgresql</b> <div class="spoiler_text"><pre> <code class="hljs mel">class profiles::db::postgresql ( Hash $globals = {}, Hash $params = {}, Hash $recovery = {}, Hash[String, Hash[String, Variant[String, Boolean, Integer]]] $roles = {}, Hash[String, Hash[String, Variant[String, Boolean]]] $db_configs = {}, Hash[String, Hash[String, Variant[String, Boolean]]] $databases = {}, Hash[String, String] $db_grants = {}, Hash[String, Hash[String, String]] $extensions = {}, Hash[String, String] $table_grants = {}, Hash[String, Hash[String, String]] $hba_rules = {}, Hash[String, String] $indent_rules = {}, Optional[String] $role = undef, # <span class="hljs-string"><span class="hljs-string">'master'</span></span>, <span class="hljs-string"><span class="hljs-string">'slave'</span></span> Optional[String] $master_host = undef, Optional[String] $replication_password = undef, Integer $master_port = <span class="hljs-number"><span class="hljs-number">5432</span></span>, String $replication_user = <span class="hljs-string"><span class="hljs-string">'repl'</span></span>, String $trigger_file = <span class="hljs-string"><span class="hljs-string">'/tmp/pg_trigger.file'</span></span>, ){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> $role { <span class="hljs-string"><span class="hljs-string">'slave'</span></span>: { $_params = { manage_recovery_conf =&gt; true, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $globals[<span class="hljs-string"><span class="hljs-string">'datadir'</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> { <span class="hljs-string"><span class="hljs-string">"${globals['datadir']}/recovery.done"</span></span>: ensure =&gt; absent, } } $_recovery = { <span class="hljs-string"><span class="hljs-string">'recovery config'</span></span> =&gt; { standby_mode =&gt; <span class="hljs-string"><span class="hljs-string">'on'</span></span>, primary_conninfo =&gt; <span class="hljs-string"><span class="hljs-string">"host=${master_host} port=${master_port} user=${replication_user} password=${replication_password}"</span></span>, trigger_file =&gt; $trigger_file, } } $_conf = { <span class="hljs-string"><span class="hljs-string">'hot_standby'</span></span> =&gt; { value =&gt; <span class="hljs-string"><span class="hljs-string">'on'</span></span>, }, } <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> { $trigger_file: ensure =&gt; absent, } } <span class="hljs-string"><span class="hljs-string">'master'</span></span>: { $_conf = { <span class="hljs-string"><span class="hljs-string">'wal_level'</span></span> =&gt; { value =&gt; <span class="hljs-string"><span class="hljs-string">'replica'</span></span>, }, <span class="hljs-string"><span class="hljs-string">'max_wal_senders'</span></span> =&gt; { value =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>, }, <span class="hljs-string"><span class="hljs-string">'wal_keep_segments'</span></span> =&gt; { value =&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>, }, } <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> { $trigger_file: ensure =&gt; present, } } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { $_params = {} $_recovery = {} $_conf = {} } } class { <span class="hljs-string"><span class="hljs-string">'::postgresql::globals'</span></span>: * =&gt; $globals, } class { <span class="hljs-string"><span class="hljs-string">'::postgresql::server'</span></span>: * =&gt; deep_merge($_params, $params), } create_resources(<span class="hljs-string"><span class="hljs-string">'::postgresql::server::config_entry'</span></span>, deep_merge($_conf, $db_configs)) create_resources(<span class="hljs-string"><span class="hljs-string">'::postgresql::server::role'</span></span>, $roles) create_resources(<span class="hljs-string"><span class="hljs-string">'::postgresql::server::database'</span></span>, $databases) create_resources(<span class="hljs-string"><span class="hljs-string">'::postgresql::server::database_grant'</span></span>, $db_grants) create_resources(<span class="hljs-string"><span class="hljs-string">'::postgresql::server::extension'</span></span>, $extensions) create_resources(<span class="hljs-string"><span class="hljs-string">'::postgresql::server::table_grant'</span></span>, $table_grants) create_resources(<span class="hljs-string"><span class="hljs-string">'::postgresql::server::pg_hba_rule'</span></span>, $hba_rules) create_resources(<span class="hljs-string"><span class="hljs-string">'::postgresql::server::pg_indent_rule'</span></span>, $indent_rules) create_resources(<span class="hljs-string"><span class="hljs-string">'::postgresql::server::recovery'</span></span>, deep_merge($_recovery, $recovery)) }</code> </pre> </div></div><br><p>  Assim, instalamos o <code>Postgresql 10</code> uma só vez, configuramos o config ( <code>listen</code> ), criamos o banco de dados <code>kicker</code> e também escrevemos duas regras para acessar esse banco de dados no <code>pg_hba.conf</code> .  Legal! </p><br><h4 id="rol-frontend">  Função de front-end </h4><br><p>  Nós assumimos o <code>frontend</code> .  Crie o arquivo <strong><code>projects/kicker/frontend.yaml</code></strong> com o seguinte conteúdo: </p><br><pre> <code class="hljs ruby">--- <span class="hljs-symbol"><span class="hljs-symbol">classes:</span></span> - profiles::webserver::nginx profiles::webserver::nginx::<span class="hljs-symbol"><span class="hljs-symbol">servers:</span></span> <span class="hljs-string"><span class="hljs-string">'kicker.semrush.com'</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">use_default_location:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-symbol"><span class="hljs-symbol">listen_port:</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-symbol"><span class="hljs-symbol">server_name:</span></span> - <span class="hljs-string"><span class="hljs-string">'kicker.semrush.com'</span></span> profiles::webserver::nginx::<span class="hljs-symbol"><span class="hljs-symbol">locations:</span></span> <span class="hljs-string"><span class="hljs-string">'kicker-root'</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">location:</span></span> <span class="hljs-string"><span class="hljs-string">'/'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">server:</span></span> <span class="hljs-string"><span class="hljs-string">'kicker.semrush.com'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">proxy:</span></span> <span class="hljs-string"><span class="hljs-string">'http://kicker-backend.semrush.com:8080'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">proxy_set_header:</span></span> - <span class="hljs-string"><span class="hljs-string">'X-Real-IP $remote_addr'</span></span> - <span class="hljs-string"><span class="hljs-string">'X-Forwarded-for $remote_addr'</span></span> - <span class="hljs-string"><span class="hljs-string">'Host kicker.semrush.com'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">location_cfg_append:</span></span> <span class="hljs-string"><span class="hljs-string">'proxy_next_upstream'</span></span>: <span class="hljs-string"><span class="hljs-string">'error timeout invalid_header http_500 http_502 http_503 http_504'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">proxy_connect_timeout:</span></span> <span class="hljs-string"><span class="hljs-string">'5'</span></span></code> </pre> <br><p>  Tudo é simples aqui.  Conectamos o <strong><code>profiles::webserver::nginx</code></strong> , que prepara a entrada no módulo nginx, e também definimos as variáveis, especificamente o <code>server</code> e a <code>location</code> deste site. </p><br><p>  Um leitor atento perceberá que seria mais apropriado colocar a descrição do site mais alta na hierarquia, porque ainda teremos um ambiente de desenvolvimento e outras variáveis ​​( <code>server_name</code> , <code>proxy</code> ) serão usadas lá, mas isso não é muito importante.  Descrevendo a função dessa maneira, podemos ver como essas variáveis ​​são redefinidas apenas pela hierarquia. </p><br><h4 id="rol-docker">  Função do Docker </h4><br><p>  A função dos <strong><code>projects/kicker/docker.yaml</code></strong> <code>docker</code> <strong><code>projects/kicker/docker.yaml</code></strong> : </p><br><pre> <code class="hljs ruby">--- <span class="hljs-symbol"><span class="hljs-symbol">classes:</span></span> - profiles::docker profiles::docker::<span class="hljs-symbol"><span class="hljs-symbol">params:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">version:</span></span> <span class="hljs-string"><span class="hljs-string">'17.05.0~ce-0~debian-stretch'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">packages:</span></span> <span class="hljs-string"><span class="hljs-string">'python3-pip'</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">provider:</span></span> apt <span class="hljs-string"><span class="hljs-string">'Fabric3'</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">provider:</span></span> pip3 <span class="hljs-symbol"><span class="hljs-symbol">ensure:</span></span> <span class="hljs-number"><span class="hljs-number">1.12</span></span>.post1 user_management::<span class="hljs-symbol"><span class="hljs-symbol">users:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">deploy:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">groups:</span></span> - docker</code> </pre> <br><p>  O <strong><code>profiles/docker.pp</code></strong> muito simples e elegante.  Vou dar o código dele: </p><br><div class="spoiler">  <b class="spoiler_title">Perfil :: docker</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">profiles</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">:docker </span></span></span></span>( Hash $params = {}, <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> $install_kernel = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, ){ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-string"><span class="hljs-string">'docker'</span></span>: * =&gt; $params, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($install_kernel) { include profiles::docker::kernel } }</code> </pre> </div></div><br><p>  Está tudo pronto.  Isso já é suficiente para implantar o produto que precisamos em muitos servidores, simplesmente atribuindo a eles um projeto e uma função específicos (por exemplo, colocando o arquivo no formato desejado no diretório fatos.d, cuja localização depende do método de instalação do fantoche). </p><br><p>  Agora, temos a seguinte estrutura de arquivos: </p><br><pre> <code class="bash hljs">. ├── kicker │ ├── db.yaml │ ├── docker.yaml │ └── frontend.yaml └── kicker.yaml 1 directory, 4 files</code> </pre> <br><p>  Agora, trataremos dos ambientes e da definição de uma configuração exclusiva para uma função em um site específico. </p><br><h4 id="okruzheniya-i-override">  Ambiente e substituição </h4><br><p>  Vamos criar a configuração geral para todas as vendas.  O arquivo <strong><code>projects/kicker/tiers/prod.yaml</code></strong> contém uma indicação de que precisamos conectar uma classe a um firewall nesse ambiente (bem, produzir tudo a mesma coisa), bem como uma determinada classe que fornece um nível de segurança maior: </p><br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">--- classes: - semrush_firewall - strict_security_level</span></span></code> </pre> <br><p>  Para um ambiente de desenvolvimento, se precisarmos descrever algo específico, o mesmo arquivo será criado e a configuração necessária será inserida nele. </p><br><p>  Em seguida, você ainda precisará redefinir as variáveis ​​para a configuração nginx da função de <code>frontend</code> - <code>frontend</code> no ambiente de desenvolvimento.  Para fazer isso, você precisa criar o arquivo <strong><code>projects/kicker/tiers/dev/frontend.yaml</code></strong> .  Preste atenção a um novo nível de hierarquia. </p><br><pre> <code class="hljs ruby">--- profiles::webserver::nginx::<span class="hljs-symbol"><span class="hljs-symbol">servers:</span></span> <span class="hljs-string"><span class="hljs-string">'kicker-dev.semrush.com'</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">use_default_location:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-symbol"><span class="hljs-symbol">listen_port:</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-symbol"><span class="hljs-symbol">server_name:</span></span> - <span class="hljs-string"><span class="hljs-string">'kicker-dev.semrush.com'</span></span> profiles::webserver::nginx::<span class="hljs-symbol"><span class="hljs-symbol">locations:</span></span> <span class="hljs-string"><span class="hljs-string">'kicker-root'</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">location:</span></span> <span class="hljs-string"><span class="hljs-string">'/'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">server:</span></span> <span class="hljs-string"><span class="hljs-string">'kicker-dev.semrush.com'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">proxy:</span></span> <span class="hljs-string"><span class="hljs-string">'http://kicker-backend-dev.semrush.com:8080'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">proxy_set_header:</span></span> - <span class="hljs-string"><span class="hljs-string">'X-Real-IP $remote_addr'</span></span> - <span class="hljs-string"><span class="hljs-string">'X-Forwarded-for $remote_addr'</span></span> - <span class="hljs-string"><span class="hljs-string">'Host kicker-dev.semrush.com'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">location_cfg_append:</span></span> <span class="hljs-string"><span class="hljs-string">'proxy_next_upstream'</span></span>: <span class="hljs-string"><span class="hljs-string">'error timeout invalid_header http_500 http_502 http_503 http_504'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">proxy_connect_timeout:</span></span> <span class="hljs-string"><span class="hljs-string">'5'</span></span></code> </pre> <br><p>  Você não precisa mais especificar uma classe, ela é herdada dos níveis anteriores da hierarquia.  Aqui nós mudamos <code>server_name</code> e <code>proxy_pass</code> .  Um servidor que possua os fatos role = frontend e tier = dev encontrará primeiro o arquivo <strong><code>projects/kicker/frontend.yaml</code></strong> , mas as variáveis ​​desse arquivo serão substituídas pelo arquivo com a prioridade mais alta <strong><code>projects/kicker/tiers/dev/frontend.yaml</code></strong> . </p><br><h4 id="sokrytie-parolya-dlya-postgresql">  Ocultar senha para PostgreSQL </h4><br><p>  E assim temos o último item da agenda - defina senhas para o PostgreSQL. </p><br><p>  As senhas devem variar em ambientes.  Usaremos o eyaml para armazenar senhas com segurança.  Crie senhas: </p><br><pre> <code class="bash hljs">eyaml encrypt -s <span class="hljs-string"><span class="hljs-string">'verysecretpassword'</span></span> eyaml encrypt -s <span class="hljs-string"><span class="hljs-string">'testpassword'</span></span></code> </pre> <br><p>  Colamos as linhas recebidas nos arquivos <code>**projects/kicker/tiers/prod/db.yaml**</code> e <code>**projects/kicker/tiers/dev/db.yaml**</code> (ou você pode usar a extensão eyaml, isso é personalizável), respectivamente.  Aqui está um exemplo: </p><br><pre> <code class="hljs ruby">--- profiles::db::postgresql::<span class="hljs-symbol"><span class="hljs-symbol">roles:</span></span> <span class="hljs-string"><span class="hljs-string">'kicker'</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">password_hash:</span></span> &gt; <span class="hljs-string"><span class="hljs-string">'ENC[PKCS7,MIIBeQYJKoZIhvcNAQcDoIIBajCCAWYCAQAxggEhMIIBHQIBADAFMAACAQEwDQYJKoZIhvcNAQEBBQAEggEAsdpb2P0axUJzyWr2duRKAjh0WooGYUmoQ5gw0nO9Ym5ftv6uZXv25DRMKh7vsbzrrOR5/lLesx/pAVmcs2qbhd/y0Vr1oc2ohHlZBBKtCSEYwem5VN+kTMhWPvlt93x/S9ERoBp8LrrsIvicSYZByNfpS2DXCFbogSXCfEPxTTmCOtlOnxdjidIc9Q1vfAXv7FRQanYIspr2UytScm56H/ueeAc/8RYK51/nXDMtdPOiAP5VARioUKyTDSk8FqNvdUZRqA3cl+hA+xD5PiBHn5T09pnH8HyE/39q09gE0pXRe5+mOnU/4qfqFPc/EvAgAq5mVawlCR6c/cCKln5wJTA8BgkqhkiG9w0BBwEwHQYJYIZIAWUDBAEqBBDNKijGHBLPCth0sfwAjfl/gBAaPsfvzZQ/Umgjy1n+im0s]'</span></span></code> </pre> <br><p>  A seguir, a senha da função <code>kicker</code> será decodificada e aplicada no servidor de banco de dados no PostgreSQL. </p><br><p>  Isso, de fato, é tudo.  Sim, o exemplo acabou sendo maciço, mas, espero, funcional, sem deixar perguntas, claro e útil.  A hierarquia resultante em hiera é a seguinte: </p><br><pre> <code class="bash hljs">. ├── db.yaml ├── docker.yaml ├── frontend.yaml └── tiers ├── dev │ ├── db.yaml │ └── frontend.yaml ├── prod │ └── db.yaml └── prod.yaml 3 directories, 7 files</code> </pre> <br><p>  Você pode assistir esses arquivos ao vivo clonando um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">repositório</a> especialmente criado </p><br><h3 id="zaklyuchenie">  Conclusão </h3><br><p>  O boneco é bom e fácil de usar com o hiera.  Eu não chamaria isso de uma ferramenta de configuração ideal no mundo moderno, de maneira alguma, mas merece atenção.  Ele lida muito bem com algumas tarefas, e sua “filosofia” de manter um estado constantemente idêntico de recursos e configuração pode desempenhar um papel importante para garantir a segurança e a uniformidade das configurações. </p><br><p>  O mundo moderno está gradualmente se sinergizando e se desenvolvendo.  Agora, poucas pessoas usam apenas um sistema de configuração, geralmente no arsenal de devops e administradores, existem vários sistemas ao mesmo tempo.  E isso é bom, pois há muito por onde escolher.  O principal é que tudo deve ser lógico e compreensível, como e onde pode ser configurado. </p><br><p>  Como resultado, nosso objetivo como administradores é não configurar nada.  Idealmente, tudo isso deve ser feito pelas próprias equipes.  E devemos fornecer a eles uma ferramenta ou produto que nos permita fazer isso com segurança, facilidade e, o mais importante, com um resultado preciso.  Bem, e ajude a resolver problemas arquitetônicos e mais sérios do que "Você precisa instalar o PostgreSQL no servidor e criar um usuário".  Camon, 2018 está no quintal! <del>  Então jogue fantoche e ansible e vá para o futuro sem servidor. </del></p><br><p>  Com o desenvolvimento de sistemas de nuvens, contêineres e orquestração de contêineres, os sistemas de gerenciamento de configuração estão lentamente se recuperando para usuários e clientes.  Você também pode criar um cluster de contêineres à prova de falhas na nuvem e manter seus aplicativos em contêineres com auto skelling, backup, replicação, descoberta automática, etc., sem escrever uma única linha para ansible, fantoche, chef etc.  Você não precisa cuidar de nada (bem, quase).  Por outro lado, há menos servidores de ferro devido às nuvens.  Só que você não precisa mais configurá-los, essa ação é de responsabilidade do provedor de nuvem.  Mas é improvável que eles usem os mesmos sistemas que os mortais comuns. </p><br><h4 id="credits">  Créditos </h4><br><p>  Obrigado: </p><br><ul><li>  Dmitry Tupitsin, Dmitry Loginov, Stepan Fedorov e toda a equipe de administradores de sistemas por sua ajuda na preparação deste artigo </li><li>  Vladimir Legkostupov para a foto </li><li>  Yana Tabakova por organizar tudo isso e ajudar a passar por todas as etapas de pré-publicação </li><li>  Nikita Zakharov pela assistência em questões de licenciamento </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt412587/">https://habr.com/ru/post/pt412587/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt412573/index.html">O que há de errado com o Geektimes retornar a Habr</a></li>
<li><a href="../pt412575/index.html">Todos os anos, a música pop se torna cada vez mais monótona, porque as mesmas pessoas a compõem</a></li>
<li><a href="../pt412579/index.html">Marvel: Infinity War ou Como coletar dados para o seu projeto em alguns minutos</a></li>
<li><a href="../pt412581/index.html">Da Idade da Pedra à Segunda Guerra Mundial: como os robôs são usados ​​para pesquisar artefatos históricos</a></li>
<li><a href="../pt412583/index.html">Desmontamos o protocolo de chaleira Redmond G200S e o conectamos ao HomeAssistant</a></li>
<li><a href="../pt412589/index.html">25 divertidas bibliotecas Android. Primavera 2018</a></li>
<li><a href="../pt412591/index.html">Construindo um jetpack: 29 de maio é o Memorial Day de Wendell Moore</a></li>
<li><a href="../pt412593/index.html">Novos produtos, plataformas e tudo como serviço: seminários on-line da HPE</a></li>
<li><a href="../pt412595/index.html">Relatório do Clube de Roma de 2018, capítulo 1.1.2: “Financiamento”</a></li>
<li><a href="../pt412597/index.html">Jeff Bezos vai construir uma colônia na superfície da lua</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>