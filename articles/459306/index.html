<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÄ üññ ü•Ä Representaci√≥n del servidor en un entorno sin servidor ‚ûñ üç™ üå¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El autor del material, cuya traducci√≥n estamos publicando, es uno de los fundadores del proyecto Webiny : un CMS sin servidor basado en React, GraphQL...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Representaci√≥n del servidor en un entorno sin servidor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459306/">  El autor del material, cuya traducci√≥n estamos publicando, es uno de los fundadores del proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Webiny</a> : un CMS sin servidor basado en React, GraphQL y Node.js.  √âl dice que admitir una plataforma en la nube sin servidor de m√∫ltiples inquilinos es un negocio que tiene tareas espec√≠ficas.  Ya se han escrito muchos art√≠culos en los que se discuten las tecnolog√≠as est√°ndar para optimizar proyectos web.  Entre ellos est√°n la representaci√≥n del servidor, el uso de tecnolog√≠as avanzadas de desarrollo de aplicaciones web, varias formas de mejorar las compilaciones de aplicaciones y mucho m√°s.  Este art√≠culo, por un lado, es similar a los dem√°s y, por otro, difiere de ellos.  El hecho es que est√° dedicado a optimizar proyectos que se ejecutan en un entorno sin servidor. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/45/ve/ub/45veubaub6xbivpsjj3_1r7zmx0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Preparaci√≥n</font> </h2><br>  Para realizar mediciones que ayuden a identificar los problemas del proyecto, utilizaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">webpagetest.org</a> .  Con la ayuda de este recurso, cumpliremos con las solicitudes y recopilaremos informaci√≥n sobre el tiempo de ejecuci√≥n de varias operaciones.  Esto nos permitir√° comprender mejor lo que los usuarios ven y sienten al trabajar con el proyecto. <br><br>  Estamos particularmente interesados ‚Äã‚Äãen el indicador "Primera vista", es decir, cu√°nto tiempo se tarda en cargar un sitio de un usuario que lo visita por primera vez.  Este es un indicador muy importante.  El hecho es que el cach√© del navegador puede ocultar muchos cuellos de botella de proyectos web. <br><br><h2>  <font color="#3AC1EF">Indicadores que reflejan las caracter√≠sticas de la carga del sitio: identificaci√≥n de problemas</font> </h2><br>  Echa un vistazo a la siguiente tabla. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc9/8a5/669/cc98a56691adf056e19086280e24cd11.png"></div><br>  <i><font color="#999999">An√°lisis de indicadores antiguos y nuevos de un proyecto web.</font></i> <br><br>  Aqu√≠, el indicador m√°s importante se puede reconocer como "Tiempo de inicio de renderizado", el tiempo antes del inicio del renderizado.  Si observa detenidamente este indicador, puede ver que solo para comenzar a renderizar la p√°gina, en la versi√≥n anterior del proyecto, tard√≥ casi 2 segundos.  La raz√≥n de esto radica en la esencia misma de la Aplicaci√≥n de P√°gina √önica (SPA).  Para mostrar la p√°gina de dicha aplicaci√≥n en la pantalla, primero debe cargar el voluminoso paquete JS (esta etapa de carga de la p√°gina est√° marcada en la siguiente figura como 1).  Entonces este paquete necesita ser procesado en el hilo principal (2).  Y solo despu√©s de eso, algo puede aparecer en la ventana del navegador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/025/675/6b2/0256756b2e402f3ffbc06a426e8e03c1.png"></div><br>  <i><font color="#999999">(1) Descargue el paquete JS.</font></i>  <i><font color="#999999">(2) Esperando el procesamiento del paquete en el hilo principal</font></i> <br><br>  Sin embargo, esto es solo una parte de la imagen.  Despu√©s de que el hilo principal procesa el paquete JS, realiza varias solicitudes a la API de Gateway.  En esta etapa del procesamiento de la p√°gina, el usuario ve un indicador de carga rotativo.  La vista no es la m√°s agradable.  Sin embargo, el usuario a√∫n no ha visto ning√∫n contenido de la p√°gina.  Aqu√≠ hay un gui√≥n gr√°fico del proceso de carga de la p√°gina. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f27/a62/b12/f27a62b12f800e4f3622583ca9f078a1.png"></div><br>  <i><font color="#999999">Carga de la p√°gina</font></i> <br><br>  Todo esto sugiere que el usuario que visit√≥ dicho sitio no experimenta sensaciones particularmente agradables al trabajar con √©l.  Es decir, se ve obligado a mirar una p√°gina en blanco durante 2 segundos, y luego otro segundo, en el indicador de descarga.  Este segundo se agrega al tiempo de preparaci√≥n de la p√°gina debido al hecho de que despu√©s de cargar y procesar las solicitudes de API del paquete JS se ejecutan.  Estas consultas son necesarias para cargar los datos y, como resultado, mostrar la p√°gina terminada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/c77/350/bf6c77350326268fbc01ff092a831549.png"></div><br>  <i><font color="#999999">Carga de la p√°gina</font></i> <br><br>  Si el proyecto fue alojado en un VPS regular, entonces el tiempo requerido para completar estas solicitudes de API ser√≠a mayormente predecible.  Sin embargo, los proyectos que se ejecutan en un entorno sin servidor se ven afectados por el notorio problema de "arranque en fr√≠o".  En el caso de la plataforma en la nube Webiny, la situaci√≥n es a√∫n peor.  Las caracter√≠sticas de AWS Lambda son parte de VPC (Virtual Private Cloud).  Esto significa que para cada nueva instancia de dicha funci√≥n, debe inicializar ENI (Elastic Network Interface, Elastic Network Interface).  Esto aumenta significativamente el tiempo de arranque en fr√≠o de las funciones. <br><br>  Aqu√≠ hay algunos plazos para cargar las caracter√≠sticas de AWS Lambda dentro de VPC y fuera de VPC. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/1e5/30b/6421e530b2330c5c4bf63d473fa93cfb.png"></div><br>  <i><font color="#999999">An√°lisis de carga de la funci√≥n AWS Lambda dentro de VPC y fuera de VPC (imagen tomada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de aqu√≠</a> )</font></i> <br><br>  De esto podemos concluir que en el caso de que la funci√≥n se inicie dentro de la VPC, esto aumenta 10 veces el tiempo de arranque en fr√≠o. <br><br>  Adem√°s, aqu√≠ debe tenerse en cuenta un factor m√°s: los retrasos en la transmisi√≥n de datos de la red.  Su duraci√≥n ya est√° incluida en el tiempo que lleva ejecutar las solicitudes de API.  Las solicitudes son iniciadas por el navegador.  Por lo tanto, resulta que cuando la API responde a estas solicitudes, se agrega el tiempo necesario para llevar la solicitud del navegador a la API y el tiempo que tarda la respuesta en llegar desde la API al navegador.  Estas demoras ocurren durante cada solicitud. <br><br><h2>  <font color="#3AC1EF">Tareas de optimizaci√≥n</font> </h2><br>  Seg√∫n el an√°lisis anterior, formulamos varias tareas que necesit√°bamos resolver para optimizar el proyecto.  Aqu√≠ est√°n: <br><br><ul><li>  Mejora la velocidad de ejecuci√≥n de solicitudes de API o reduce la cantidad de solicitudes de API que bloquean la representaci√≥n. </li><li>  Reducir el tama√±o del paquete JS o convertir este paquete en recursos que no son necesarios para la salida de la p√°gina. </li><li>  Desbloqueo del hilo principal. </li></ul><br><h2>  <font color="#3AC1EF">Enfoques de problemas</font> </h2><br>  Aqu√≠ hay algunos enfoques para resolver los problemas que consideramos: <br><br><ol><li>  Optimizaci√≥n de c√≥digo con vistas a acelerar su ejecuci√≥n.  Este enfoque requiere mucho esfuerzo, tiene un alto costo.  Los beneficios que se pueden obtener como resultado de dicha optimizaci√≥n son dudosos. </li><li>  Aumente la cantidad de RAM disponible para las funciones de AWS Lambda.  Es f√°cil de hacer, el costo de tal soluci√≥n est√° en alg√∫n lugar entre medio y alto.  Solo se pueden esperar peque√±os efectos positivos de la aplicaci√≥n de esta soluci√≥n. </li><li>  El uso de alguna otra forma de resolver el problema.  Es cierto que en ese momento a√∫n no sab√≠amos qu√© era este m√©todo. </li></ol><br>  Al final, elegimos el tercer elemento de esta lista.  Razonamos as√≠: ‚Äú¬øQu√© pasa si no necesitamos absolutamente ninguna llamada a la API?  ¬øQu√© pasa si podemos prescindir del paquete JS?  Esto nos permitir√≠a resolver todos los problemas del proyecto ". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/476/84a/f6947684a7a537bba4b9dfeb24f524e6.jpg"></div><br>  La primera idea que nos pareci√≥ interesante fue crear una instant√°nea HTML de la p√°gina renderizada y compartirla con los usuarios. <br><br><h2>  <font color="#3AC1EF">Intento fallido</font> </h2><br>  Webiny Cloud es una infraestructura sin servidor basada en AWS Lambda que admite sitios Webiny.  Nuestro sistema puede detectar bots.  Cuando resulta que el bot complet√≥ la solicitud, esta solicitud se redirige a la instancia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Puppeteer</a> , que muestra la p√°gina usando Chrome sin una interfaz de usuario.  El c√≥digo HTML listo de la p√°gina se env√≠a al bot.  Esto se hizo principalmente por razones de SEO, debido al hecho de que muchos bots no saben c√≥mo ejecutar JavaScript.  Decidimos utilizar el mismo enfoque para preparar p√°ginas destinadas a usuarios comunes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/698/219/8bd698219b68cccfa5db9f9f81611111.png"></div><br>  Este enfoque funciona bien en entornos que carecen de soporte JavaScript.  Sin embargo, si intenta dar p√°ginas preprocesadas a un cliente cuyo navegador admite JS, se muestra la p√°gina, pero luego, despu√©s de descargar los archivos JS, los componentes React simplemente no saben d√≥nde montarlos.  Esto da como resultado una gran cantidad de mensajes de error en la consola.  Como resultado, tal decisi√≥n no nos conven√≠a. <br><br><h2>  <font color="#3AC1EF">Introduciendo SSR</font> </h2><br>  El punto fuerte de la representaci√≥n del lado del servidor (SSR) es que todas las solicitudes de API se ejecutan dentro de la red local.  Dado que son procesados ‚Äã‚Äãpor un determinado sistema o funci√≥n que se ejecuta dentro de la VPC, los retrasos que se producen al ejecutar solicitudes desde el navegador al backend de recursos no son caracter√≠sticos.  Aunque en este escenario, el problema de un "arranque en fr√≠o" persiste. <br><br>  Una ventaja adicional de usar SSR es que le damos al cliente una versi√≥n HTML de la p√°gina, cuando trabaja con la cual, despu√©s de cargar los archivos JS, los componentes React no tienen problemas de montaje. <br><br>  Y finalmente, no necesitamos un paquete JS muy grande.  Adem√°s, podemos prescindir de las llamadas a la API para mostrar la p√°gina.  Un paquete se puede cargar de forma asincr√≥nica y esto no bloquear√° el hilo principal. <br><br>  En general, podemos decir que la representaci√≥n del servidor, al parecer, deber√≠a haber resuelto la mayor√≠a de nuestros problemas. <br><br>  As√≠ es como se ve el an√°lisis del sitio despu√©s de aplicar la representaci√≥n del lado del servidor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/5df/38e/3705df38e8b3a2c697f04bed1d0d577e.png"></div><br>  <i><font color="#999999">M√©tricas del sitio despu√©s de aplicar la representaci√≥n del servidor</font></i> <br><br>  Ahora las solicitudes de API no se ejecutan y la p√°gina se puede ver antes de que se cargue el paquete JS grande.  Pero si observa de cerca la primera solicitud, puede ver que toma casi 2 segundos obtener un documento del servidor.  Hablemos de eso. <br><br><h2>  <font color="#3AC1EF">Problema con TTFB</font> </h2><br>  Aqu√≠ discutimos la m√©trica TTFB (Tiempo hasta el primer byte, tiempo hasta el primer byte).  Aqu√≠ est√°n los detalles de la primera solicitud. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d3/19e/9ec/8d319e9eca081b8cba644d7829ccf56e.png"></div><br>  <i><font color="#999999">Detalles de la primera solicitud</font></i> <br><br>  Para procesar esta primera solicitud, debemos hacer lo siguiente: iniciar el servidor Node.js, realizar el procesamiento del servidor, realizar solicitudes de API y ejecutar c√≥digo JS, y luego devolver el resultado final al cliente.  El problema aqu√≠ es que todo esto, en promedio, toma 1-2 segundos. <br><br>  Nuestro servidor, que realiza la representaci√≥n del servidor, necesita hacer todo este trabajo, y solo despu√©s de eso podr√° transmitir el primer byte de la respuesta al cliente.  Esto lleva al hecho de que el navegador tiene mucho tiempo para esperar el inicio de la respuesta a la solicitud.  Como resultado, resulta que ahora para la salida de la p√°gina necesita producir casi la misma cantidad de trabajo que antes.  La √∫nica diferencia es que este trabajo se lleva a cabo no en el lado del cliente, sino en el servidor, en el proceso de representaci√≥n del servidor. <br><br>  Aqu√≠ puede tener una pregunta sobre la palabra "servidor".  Hemos estado hablando sobre el sistema sin servidor todo este tiempo.  ¬øDe d√≥nde vino este "servidor"?  Nosotros, por supuesto, intentamos renderizar la representaci√≥n del servidor en las funciones de AWS Lambda.  Pero result√≥ que este es un proceso que consume muchos recursos (en particular, era necesario aumentar mucho la cantidad de memoria para obtener m√°s recursos del procesador).  Adem√°s, el problema de "arranque en fr√≠o", que ya hemos mencionado, tambi√©n se agrega aqu√≠.  Como resultado, la soluci√≥n ideal era utilizar un servidor Node.js que cargara los materiales del sitio y los representara en el lado del servidor. <br><br>  Volvamos a las consecuencias de usar la representaci√≥n del lado del servidor.  Echa un vistazo al siguiente gui√≥n gr√°fico.  Es f√°cil ver que no es particularmente diferente de lo que se obtuvo en el estudio del proyecto, que se realiz√≥ en el cliente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc5/ed3/8c4/fc5ed38c4250cfe6592af448b7f0fd30.png"></div><br>  <i><font color="#999999">Carga de p√°gina cuando se usa la representaci√≥n del lado del servidor</font></i> <br><br>  El usuario se ve obligado a mirar una p√°gina en blanco durante 2,5 segundos.  Esto es triste <br><br>  Aunque mirando estos resultados, uno podr√≠a pensar que no hemos logrado absolutamente nada, en realidad esto no es as√≠.  Ten√≠amos una instant√°nea HTML de la p√°gina que conten√≠a todo lo que necesit√°bamos.  Esta foto estaba lista para funcionar con React.  Al mismo tiempo, durante el procesamiento de la p√°gina en el cliente, no era necesario realizar ninguna solicitud de API.  Todos los datos necesarios ya se han incrustado en HTML. <br><br>  El √∫nico problema fue que crear esta instant√°nea HTML tom√≥ demasiado tiempo.  En este punto, podr√≠amos invertir m√°s tiempo en la optimizaci√≥n del procesamiento del servidor, o simplemente almacenar en cach√© sus resultados y dar a los clientes una instant√°nea de la p√°gina desde algo as√≠ como un cach√© Redis.  Nosotros acabamos de hacer eso. <br><br><h2>  <font color="#3AC1EF">Cach√© de resultados de representaci√≥n del servidor</font> </h2><br>  Despu√©s de que un usuario visita el sitio web de Webiny, primero verificamos el cach√© centralizado de Redis para ver si hay una instant√°nea HTML de la p√°gina.  Si es as√≠, le damos al usuario una p√°gina del cach√©.  En promedio, esto redujo el TTFB a 200-400 ms.  Fue despu√©s de la introducci√≥n del cach√© que comenzamos a notar mejoras significativas en el rendimiento del proyecto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01e/28d/37e/01e28d37ec4b2586d8a9d8d5187716c9.png"></div><br>  <i><font color="#999999">Carga de p√°gina cuando se usa la representaci√≥n del lado del servidor y la memoria cach√©</font></i> <br><br>  Incluso el usuario que visita el sitio por primera vez ve el contenido de la p√°gina en menos de un segundo. <br><br>  Veamos c√≥mo se ve ahora el diagrama de cascada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/629/40f/f4c/62940ff4c6f1136c2534c3c299b343c9.png"></div><br>  <i><font color="#999999">M√©tricas del sitio despu√©s de aplicar el procesamiento y el almacenamiento en cach√© del lado del servidor</font></i> <br><br>  La l√≠nea roja indica una marca de tiempo de 800 ms.  Aqu√≠ es donde el contenido de la p√°gina est√° completamente cargado.  Adem√°s, aqu√≠ puede ver que los paquetes JS se cargan a aproximadamente 1.3 s.  Pero esto no afecta el tiempo que el usuario necesita para ver la p√°gina.  Al mismo tiempo, no necesita hacer llamadas a la API y cargar el hilo principal para mostrar la p√°gina. <br><br>  Preste atenci√≥n al hecho de que el tiempo relacionado con la carga del paquete JS, la ejecuci√≥n de solicitudes de API y la realizaci√≥n de operaciones en el hilo principal todav√≠a juegan un papel importante en la preparaci√≥n de la p√°gina para el trabajo.  Esta inversi√≥n de tiempo y recursos es necesaria para que la p√°gina se vuelva "interactiva".  Pero esto no juega ning√∫n papel, en primer lugar, para los robots de los motores de b√∫squeda, y en segundo lugar, para crear la sensaci√≥n de "carga r√°pida de p√°ginas" entre los usuarios. <br><br>  Supongamos que una p√°gina es "din√°mica".  Por ejemplo, muestra un enlace en el encabezado para acceder a la cuenta de usuario en caso de que el usuario que est√° viendo la p√°gina haya iniciado sesi√≥n.  Despu√©s de la representaci√≥n del lado del servidor, la p√°gina de uso general se enviar√° al navegador.  Es decir, uno que se muestra a los usuarios que no han iniciado sesi√≥n.  El t√≠tulo de esta p√°gina cambiar√°, reflejando el hecho de que el usuario inici√≥ sesi√≥n, solo despu√©s de cargar el paquete JS y realizar las llamadas a la API.  Aqu√≠ estamos tratando con el indicador <a href="">TTI</a> (Time To Interactive, tiempo hasta la primera interactividad). <br><br>  Despu√©s de algunas semanas, descubrimos que nuestro servidor proxy no cierra la conexi√≥n con el cliente donde es necesario, si la representaci√≥n del servidor se inici√≥ como un proceso en segundo plano.  La correcci√≥n de literalmente una l√≠nea de c√≥digo condujo al hecho de que el indicador TTFB se redujo al nivel de 50-90 ms.  Como resultado, el sitio ahora comenz√≥ a mostrarse en el navegador despu√©s de unos 600 ms. <br><br>  Sin embargo, enfrentamos otro problema ... <br><br><h2>  <font color="#3AC1EF">Problema de invalidaci√≥n de cach√©</font> </h2><br>  <i><font color="#999999">"En inform√°tica, solo hay dos cosas complejas: invalidaci√≥n de cach√© y denominaci√≥n de entidades".</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">Phil Carleton</font></i> <br><br>  La invalidaci√≥n de cach√© es, de hecho, una tarea muy dif√≠cil.  ¬øC√≥mo solucionarlo?  En primer lugar, a menudo puede actualizar la memoria cach√© configurando un tiempo de almacenamiento muy corto para los objetos en cach√© (TTL, Tiempo de vida, duraci√≥n).  Esto a veces har√° que las p√°ginas se carguen m√°s lentamente de lo habitual.  En segundo lugar, puede crear un mecanismo de invalidaci√≥n de cach√© basado en ciertos eventos. <br><br>  En nuestro caso, este problema se resolvi√≥ utilizando un TTL muy peque√±o de 30 segundos.  Pero tambi√©n nos dimos cuenta de la posibilidad de proporcionar a los clientes datos obsoletos del cach√©.  En un momento en que los clientes reciben dichos datos, la memoria cach√© se actualiza en segundo plano.  Gracias a esto, nos deshicimos de problemas, como retrasos y "arranque en fr√≠o", que son t√≠picos de las funciones de AWS Lambda. <br><br>  As√≠ es como funciona.  Un usuario visita el sitio web de Webiny.  Estamos revisando el cach√© HTML.  Si hay una captura de pantalla de la p√°gina, se la damos al usuario.  La edad de una imagen puede ser incluso unos pocos d√≠as.  Al pasar esta antigua instant√°nea al usuario en unos pocos cientos de milisegundos, simult√°neamente iniciamos la tarea de crear una nueva instant√°nea y actualizar el cach√©.  Por lo general, lleva unos segundos completar esta tarea, ya que creamos un mecanismo gracias al cual siempre tenemos un cierto n√∫mero de funciones de AWS Lambda que ya se est√°n ejecutando y listas para funcionar.  Por lo tanto, no tenemos que, durante la creaci√≥n de nuevas im√°genes, dedicar tiempo al arranque en fr√≠o de las funciones. <br><br>  Como resultado, siempre devolvemos las p√°ginas del cach√© a los clientes, y cuando la antig√ºedad de los datos almacenados en cach√© alcanza los 30 segundos, el contenido del cach√© se actualiza. <br><br>  El almacenamiento en cach√© es definitivamente un √°rea en la que a√∫n podemos mejorar algo.  Por ejemplo, estamos considerando la posibilidad de actualizar autom√°ticamente el cach√© cuando el usuario publica una p√°gina.  Sin embargo, dicho mecanismo de actualizaci√≥n de cach√© tampoco es ideal. <br><br>  Por ejemplo, suponga que la p√°gina de inicio de un recurso muestra las tres publicaciones de blog m√°s recientes.  Si el cach√© se actualiza cuando se publica una nueva p√°gina, desde un punto de vista t√©cnico, solo se generar√° el cach√© para esta nueva p√°gina despu√©s de la publicaci√≥n.  El cach√© para la p√°gina de inicio estar√° desactualizado. <br><br>  Todav√≠a estamos buscando formas de mejorar el sistema de almacenamiento en cach√© de nuestro proyecto.  Pero hasta ahora, la atenci√≥n se ha centrado en resolver los problemas de rendimiento existentes.  Creemos que hemos hecho un buen trabajo en t√©rminos de resoluci√≥n de estos problemas. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Al principio, utilizamos la representaci√≥n del lado del cliente.  Luego, en promedio, el usuario pod√≠a ver la p√°gina en 3,3 segundos.  Ahora, esta cifra se ha reducido a unos 600 ms.  Tambi√©n es importante que ahora prescindamos del indicador de descarga. <br><br>  Para lograr este resultado, se nos permiti√≥, principalmente, el uso de la representaci√≥n del servidor.  Pero sin un buen sistema de almacenamiento en cach√©, resulta que los c√°lculos simplemente se transfieren del cliente al servidor.  Y esto lleva al hecho de que el tiempo requerido para que el usuario vea la p√°gina no cambia mucho. <br><br>  El uso de la representaci√≥n del servidor tiene otra calidad positiva, no mencionada anteriormente.  Estamos hablando del hecho de que facilita la visualizaci√≥n de p√°ginas en dispositivos m√≥viles d√©biles.  La velocidad de preparaci√≥n de una p√°gina para ver en dichos dispositivos depende de las modestas capacidades de sus procesadores.  La representaci√≥n del servidor le permite eliminar parte de la carga de ellos.  Cabe se√±alar que no realizamos un estudio especial sobre este tema, pero el sistema que tenemos deber√≠a ayudar a mejorar la visualizaci√≥n del sitio en tel√©fonos y tabletas. <br><br>  En general, podemos decir que la implementaci√≥n de la representaci√≥n del servidor no es una tarea f√°cil.  Y el hecho de que usemos un entorno sin servidor solo complica esta tarea.  La soluci√≥n a nuestros problemas requer√≠a cambios de c√≥digo, infraestructura adicional.  Necesit√°bamos crear un mecanismo de almacenamiento en cach√© bien dise√±ado.  Pero a cambio, obtuvimos mucho bien.  Lo m√°s importante es que las p√°ginas de nuestro sitio ahora se est√°n cargando y preparando para trabajar mucho m√°s r√°pido que antes.  Creemos que a nuestros usuarios les gustar√°. <br><br>  <b>Estimados lectores!</b>  ¬øUtiliza tecnolog√≠as de almacenamiento en cach√© y representaci√≥n de servidores para optimizar sus proyectos? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459306/">https://habr.com/ru/post/459306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459296/index.html">Precio JavaScript 2019</a></li>
<li><a href="../459298/index.html">Angular: estado en 2019</a></li>
<li><a href="../459300/index.html">Quasar 1.0: una nueva herramienta √∫til para los desarrolladores de Vue y no solo para ellos</a></li>
<li><a href="../459302/index.html">Reintentando solicitudes HTTP fallidas en Angular</a></li>
<li><a href="../459304/index.html">Bypass de trampa angular y ahorro de tiempo</a></li>
<li><a href="../459308/index.html">¬øEl SEO no funciona en 2019?</a></li>
<li><a href="../459310/index.html">Pruebe las herramientas de automatizaci√≥n o el probador de esteroides m√≥vil</a></li>
<li><a href="../459312/index.html">Querida Agile, estoy harta de fingir</a></li>
<li><a href="../459314/index.html">Visualice y trate con Hash Match Join</a></li>
<li><a href="../459316/index.html">Hydra 2019: transmisi√≥n gratuita de la primera sala y un poco sobre lo que ser√° en la conferencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>