<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏼 💩 👔 Copia de seguridad, Parte 4: Descripción general y prueba de zbackup, restic, borgbackup 🤱🏼 👃 👃🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artículo analizará las herramientas de software de respaldo que, al dividir el flujo de datos en componentes separados (fragmentos), forman un re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Copia de seguridad, Parte 4: Descripción general y prueba de zbackup, restic, borgbackup</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/454734/"><p><img src="https://habrastorage.org/webt/pr/ob/cd/probcd0kvhmv8mspkq9espvxzsq.png"></p><br><p>  Este artículo analizará las herramientas de software de respaldo que, al dividir el flujo de datos en componentes separados (fragmentos), forman un repositorio. </p><br><p>  Los componentes del repositorio también se pueden comprimir y cifrar, y lo más importante, con procesos de copia de seguridad repetidos, reutilizar nuevamente. </p><br><p>  Una copia de seguridad en un repositorio similar es una cadena con nombre de componentes relacionados, por ejemplo, basada en varias funciones hash. </p><br><p>  Hay varias soluciones similares, me centraré en 3: zbackup, borgbackup y restic. </p><a name="habracut"></a><br><h3 id="ozhidaemye-rezultaty">  Resultados esperados </h3><br><p>  Dado que todos los solicitantes de una forma u otra requieren la creación de un repositorio, uno de los factores más importantes será la estimación del tamaño del repositorio.  En el caso ideal, su tamaño no debe ser superior a 13 GB de acuerdo con la metodología aceptada, o incluso menos, sujeto a una buena optimización. </p><br><p>  También es altamente deseable poder hacer una copia de seguridad de los archivos directamente, sin usar archivadores tar, así como trabajar con ssh / sftp sin herramientas adicionales como rsync y sshfs. </p><br><p>  <strong>Comportamiento de respaldo:</strong> </p><br><ol><li>  El tamaño del repositorio será igual al tamaño de los cambios, o menos. </li><li>  Se espera una gran carga del procesador cuando se usa compresión y / o cifrado, y una carga bastante grande en la red y el subsistema de disco es probable si el proceso de archivo y / o cifrado funcionará en el servidor de almacenamiento de respaldo. </li><li>  Si daña el repositorio, es probable que se produzca un error retrasado tanto al crear nuevas copias de seguridad como al intentar restaurar.  Es necesario planificar medidas adicionales para garantizar la integridad del repositorio o utilizar los medios integrados para verificar su integridad. </li></ol><br><p>  El trabajo con alquitrán se acepta como valor de referencia, como se mostró en uno de los artículos anteriores. </p><br><h3 id="testirovanie-zbackup">  Prueba de respaldo </h3><br><p>  El mecanismo general de la operación zbackup es que el programa encuentra áreas que contienen los mismos datos en el flujo de datos suministrado en la entrada, luego las comprime y las cifra opcionalmente, ahorrando cada área solo 1 vez. </p><br><p>  Para la deduplicación, se utiliza una función hash de anillo de 64 bits con una ventana deslizante para verificar byte en busca de coincidencias con los bloques de datos existentes (similar a cómo se implementa en rsync). </p><br><p>  Para la compresión, lzma y lzo se utilizan en la ejecución de subprocesos múltiples y para el cifrado: aes.  En las últimas versiones hay una oportunidad en el futuro para eliminar datos antiguos del repositorio. <br>  El programa está escrito en C ++ con dependencias mínimas.  Aparentemente, el autor se inspiró en el modo Unix, por lo que el programa recibe datos en stdin al crear copias de seguridad, dando un flujo de datos similar al stdout al restaurar.  Por lo tanto, zbackup se puede utilizar como un buen "ladrillo" al escribir sus propias soluciones de copia de seguridad.  Por ejemplo, el autor del artículo, este programa es la principal herramienta de respaldo para máquinas domésticas desde aproximadamente 2014. </p><br><p>  Se utilizará un alquitrán regular como flujo de datos, a menos que se indique lo contrario. </p><br><div class="spoiler">  <b class="spoiler_title">Veamos cuáles serán los resultados:</b> <div class="spoiler_text"><p>  La verificación del trabajo se realizó en 2 versiones: </p><br><ol><li>  se crea un repositorio y se inicia zbackup en el servidor con los datos de origen, luego los contenidos del repositorio se transfieren al servidor de almacenamiento de respaldo. </li><li>  se crea un repositorio en el servidor de almacenamiento de respaldo, zbackup se inicia a través de ssh en el servidor de almacenamiento de respaldo, los datos se le proporcionan a través de una tubería. </li></ol><br><p>  Los resultados de la primera opción fueron los siguientes: 43m11s - cuando se usa un repositorio sin cifrar y un compresor lzma, 19m13s - cuando se reemplaza el compresor con lzo. </p><br><p>  La carga en el servidor con los datos de origen fue la siguiente (se muestra el ejemplo con lzma, con lzo había aproximadamente la misma imagen, pero la proporción de rsync era aproximadamente un cuarto del tiempo): </p><br><p> <a href=""><img src="https://habrastorage.org/webt/pp/d3/hs/ppd3hsaxn_kffamwcrwstrb_sds.png"></a> </p><br><p>  Está claro que dicho proceso de copia de seguridad solo es adecuado para cambios relativamente raros y pequeños.  También es muy deseable limitar el funcionamiento de zbackup a 1 subproceso, de lo contrario habrá una carga muy alta en el procesador, porque  El programa es muy bueno para trabajar en múltiples hilos.  La carga del disco fue pequeña, lo que, en general, con un subsistema de disco moderno basado en SSD, no se notará.  También puede ver claramente el inicio del proceso de sincronización de los datos del repositorio con un servidor remoto, la velocidad es comparable a la de rsync normal y depende del rendimiento del subsistema de disco del servidor de almacenamiento de respaldo.  La desventaja del enfoque es el almacenamiento del repositorio local y, como consecuencia, la duplicación de datos. </p><br><p>  Más interesante y práctica en la práctica es la segunda opción con ejecutar zbackup inmediatamente en el servidor de almacenamiento de respaldo. </p><br><p>  Primero, verificaremos la operación sin usar cifrado con el compresor lzma: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/wf/m4/g0/wfm4g0zjf3cktbvihsmmtbg-hcu.png"></a> </p><br><p>  El tiempo de ejecución de cada prueba: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lanzamiento 1 </th><th>  Lanzamiento 2 </th><th>  Lanzamiento 3 </th></tr></thead><tbody><tr><td>  39m45s </td><td>  40m20s </td><td>  40m3s </td></tr><tr><td>  7m36s </td><td>  8m3s </td><td>  7m48s </td></tr><tr><td>  15m35s </td><td>  15 min 48 s </td><td>  15 min 38 s </td></tr></tbody></table></div><br><p>  Si activa el cifrado usando aes, los resultados son bastante cercanos: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mf/7p/yv/mf7pyvnly6bmjtxbno88mjtrtn4.png"></a> </p><br><p>  Tiempo de funcionamiento en los mismos datos, con cifrado: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lanzamiento 1 </th><th>  Lanzamiento 2 </th><th>  Lanzamiento 3 </th></tr></thead><tbody><tr><td>  43m40s </td><td>  44m12s </td><td>  44m3s </td></tr><tr><td>  8m3s </td><td>  8m15s </td><td>  8m12s </td></tr><tr><td>  15m0s </td><td>  15m40s </td><td>  15m25s </td></tr></tbody></table></div><br><p>  Si el cifrado se combina con la compresión en lzo, es así: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/38/cz/tb/38cztb4tuzxtgsorc6uysied59k.png"></a> </p><br><p>  Tiempo de trabajo: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lanzamiento 1 </th><th>  Lanzamiento 2 </th><th>  Lanzamiento 3 </th></tr></thead><tbody><tr><td>  18m2s </td><td>  18m15s </td><td>  18m12s </td></tr><tr><td>  5 min 13 s </td><td>  5 min 24 s </td><td>  5m20s </td></tr><tr><td>  8m48s </td><td>  9m3s </td><td>  8m51s </td></tr></tbody></table></div></div></div><br><p>  El tamaño del repositorio resultante era relativamente el mismo y ascendía a 13 GB.  Esto significa que la deduplicación funciona correctamente.  Además, en datos ya comprimidos, el uso de lzo produce un efecto notable; en el tiempo operativo total, zbackup se acerca mucho a duplicidad / duplicación, sin embargo, va entre 2 y 5 veces menos que los basados ​​en librsync. </p><br><p>  Los beneficios son obvios: ahorrar espacio en disco en el servidor de almacenamiento de respaldo.  En cuanto a las herramientas para verificar el repositorio, no son provistas por zbackup, se recomienda utilizar una matriz de discos a prueba de fallas o un proveedor de la nube. </p><br><p>  En general, una muy buena impresión, a pesar del hecho de que el proyecto tiene aproximadamente 3 años de ejecución (la última solicitud de función fue hace aproximadamente un año, pero sin respuesta). </p><br><h3 id="testirovanie-borgbackup">  Prueba de borgbackup </h3><br><p>  Borgbackup es una bifurcación de ático, otro sistema similar a zbackup.  Está escrito en python, tiene una lista de características similares a zbackup, pero además sabe cómo: </p><br><ul><li>  Montar copias de seguridad a través del fusible </li><li>  Verifique el contenido del repositorio </li><li>  Trabajar en modo cliente-servidor </li><li>  Utilice varios compresores para datos, así como también la definición heurística del tipo de archivo al comprimirlo. </li><li>  2 opciones de cifrado, aes y blake </li><li>  Herramienta incorporada para </li></ul><br><div class="spoiler">  <b class="spoiler_title">comprobaciones de rendimiento</b> <div class="spoiler_text"><p>  punto de referencia de borgbackup crud ssh: // backup_server / repo / path local_dir </p><br><p>  Los resultados son los siguientes: </p><br><p>  CZ-BIG 96.51 MB / s (10 <em>100.00 MB archivos todo-cero: 10.36s)</em> <em><br></em>  <em>RZ-BIG 57.22 MB / s (10</em> 100.00 MB archivos todo-cero: 17.48s) <br>  UZ-BIG 253.63 MB / s (10 <em>100.00 MB archivos todo-cero: 3.94s)</em> <em><br></em>  <em>DZ-BIG 351.06 MB / s (10</em> 100.00 MB archivos todo-cero: 2.85s) <br>  CR-BIG 34.30 MB / s (10 <em>archivos aleatorios</em> de <em>100.00 MB: 29.15s)</em> <em><br></em>  <em>RR-BIG 60.69 MB / s (10</em> 100.00 MB archivos aleatorios: 16.48s) <br>  UR-BIG 311.06 MB / s (10 <em>archivos aleatorios</em> de <em>100.00 MB: 3.21s)</em> <em><br></em>  <em>DR-BIG 72.63 MB / s (10</em> archivos aleatorios <em>de</em> 100.00 MB: 13.77s) <br>  CZ-MEDIUM 108.59 MB / s (1000 <em>archivos todo cero de 1.00 MB: 9.21s)</em> <em><br></em>  <em>RZ-MEDIUM 76.16 MB / s (1000</em> archivos todo cero de 1.00 MB: 13.13s) <br>  UZ-MEDIUM 331.27 MB / s (1000 <em>archivos todo cero de 1.00 MB: 3.02s)</em> <em><br></em>  <em>DZ-MEDIUM 387.36 MB / s (1000</em> archivos todo cero de 1.00 MB: 2.58s) <br>  CR-MEDIUM 37.80 MB / s (1000 <em>archivos aleatorios de 1.00 MB: 26.45s)</em> <em><br></em>  <em>RR-MEDIUM 68.90 MB / s (1000</em> archivos aleatorios de 1.00 MB: 14.51s) <br>  UR-MEDIUM 347.24 MB / s (1000 <em>archivos aleatorios de 1.00 MB: 2.88s)</em> <em><br></em>  <em>DR-MEDIUM 48.80 MB / s (1000</em> archivos aleatorios de 1.00 MB: 20.49s) <br>  CZ-SMALL 11.72 MB / s (10000 <em>10.00 kB archivos todo-cero: 8.53s)</em> <em><br></em>  <em>RZ-SMALL 32.57 MB / s (10000</em> 10.00 kB archivos todo-cero: 3.07s) <br>  UZ-SMALL 19.37 MB / s (10000 <em>10.00 kB archivos todo-cero: 5.16s)</em> <em><br></em>  <em>DZ-SMALL 33.71 MB / s (10000</em> 10.00 kB archivos todo-cero: 2.97s) <br>  CR-SMALL 6.85 MB / s (10000 <em>10.00 kB archivos aleatorios: 14.60s)</em> <em><br></em>  <em>RR-SMALL 31.27 MB / s (10000</em> 10.00 kB archivos aleatorios: 3.20s) <br>  UR-SMALL 12.28 MB / s (10000 <em>10.00 kB archivos aleatorios: 8.14s)</em> <em><br></em>  <em>DR-SMALL 18.78 MB / s (10000</em> 10.00 kB archivos aleatorios: 5.32s) </p></div></div><br><p>  Durante las pruebas, la heurística se usará en compresión con la definición del tipo de archivo (compresión automática), y los resultados serán los siguientes: </p><br><div class="spoiler">  <b class="spoiler_title">Primero, verifique la operación sin cifrado:</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/fe/ep/xm/feepxmsoyorprvvt5h00tuj2spg.png"></a> </p><br><p>  Tiempo de trabajo: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lanzamiento 1 </th><th>  Lanzamiento 2 </th><th>  Lanzamiento 3 </th></tr></thead><tbody><tr><td>  4m6s </td><td>  4m10s </td><td>  4m5s </td></tr><tr><td>  56s </td><td>  58s </td><td>  54s </td></tr><tr><td>  1m26s </td><td>  1m34s </td><td>  1m30s </td></tr></tbody></table></div><br><p>  Si habilita la autorización de repositorio (modo autenticado), los resultados estarán cercanos: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/3c/qe/kx/3cqekxviy9rzhafckbi0tidjxn4.png"></a> </p><br><p>  Tiempo de trabajo: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lanzamiento 1 </th><th>  Lanzamiento 2 </th><th>  Lanzamiento 3 </th></tr></thead><tbody><tr><td>  4 min 11 s </td><td>  4m20s </td><td>  4m12s </td></tr><tr><td>  1m0s </td><td>  1m3s </td><td>  1m2s </td></tr><tr><td>  1m30s </td><td>  1m34s </td><td>  1 min 31 s </td></tr></tbody></table></div><br><p>  Cuando se activó el cifrado aes, los resultados no se deterioraron mucho: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/oa/yz/zl/oayzzliqw8zixlppy_idv2l8gzm.png"></a> </p><br><div class="scrollable-table"><table><thead><tr><th>  Lanzamiento 1 </th><th>  Lanzamiento 2 </th><th>  Lanzamiento 3 </th></tr></thead><tbody><tr><td>  4 min 55 s </td><td>  5m2s </td><td>  4 min 58 s </td></tr><tr><td>  1m0s </td><td>  1m2s </td><td>  1m0s </td></tr><tr><td>  1m49s </td><td>  1m50s </td><td>  1m50s </td></tr></tbody></table></div><br><p>  Y si cambia aes a blake, la situación mejorará por completo: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/df/kh/ay/dfkhayqoecs9hw_c_aj2fmxjkbu.png"></a> </p><br><p>  Tiempo de trabajo: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lanzamiento 1 </th><th>  Lanzamiento 2 </th><th>  Lanzamiento 3 </th></tr></thead><tbody><tr><td>  4 min 33 s </td><td>  4m43s </td><td>  4m40s </td></tr><tr><td>  59s </td><td>  1m0s </td><td>  1m0s </td></tr><tr><td>  1 min 38 s </td><td>  1m43s </td><td>  1m40s </td></tr></tbody></table></div></div></div><br><p>  Como en el caso de zbackup, el tamaño del repositorio era de 13 GB e incluso un poco menos, lo que, en general, se espera.  El tiempo de trabajo fue muy satisfactorio, es comparable con soluciones basadas en librsync, brindando posibilidades mucho más amplias.  También me complació la capacidad de establecer varios parámetros a través de variables de entorno, lo que brinda una ventaja muy seria cuando se usa borgbackup en modo automático.  También satisfecho con la carga durante la copia de seguridad: a juzgar por la carga del procesador, borgbackup funciona en 1 subproceso. </p><br><p>  No hubo inconvenientes especiales al usar. </p><br><h3 id="testirovanie-restic">  Prueba restic </h3><br><p>  A pesar de que restic es una solución bastante nueva (los primeros 2 candidatos se conocen desde 2013 y anteriores), tiene características bastante buenas.  Escrito en Go. </p><br><p>  Cuando se compara con zbackup, también proporciona: </p><br><ul><li>  Comprobación de la integridad del repositorio (incluidas las piezas de comprobación). </li><li>  Una gran lista de protocolos y proveedores compatibles para almacenar copias de seguridad, así como el soporte de rclone - rsync para soluciones en la nube. </li><li>  Comparación de 2 copias de seguridad entre ellos. </li><li>  Montaje del repositorio mediante fusible. </li></ul><br><p>  En general, la lista de posibilidades está bastante cerca del borgbackup, en algunos lugares más, en algunos lugares menos.  De las características, la falta de la capacidad de deshabilitar el cifrado y, por lo tanto, las copias de seguridad siempre se cifrarán.  Veamos en la práctica lo que puede extraer de este software: </p><br><div class="spoiler">  <b class="spoiler_title">Los resultados son los siguientes:</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/tq/k5/xn/tqk5xn1xknn33dydmslqofrjfvs.png"></a> </p><br><p>  Tiempo de trabajo: </p><br><div class="scrollable-table"><table><thead><tr><th>  Lanzamiento 1 </th><th>  Lanzamiento 2 </th><th>  Lanzamiento 3 </th></tr></thead><tbody><tr><td>  5 min 25 s </td><td>  5m50s </td><td>  5 min 38 s </td></tr><tr><td>  35s </td><td>  38s </td><td>  36s </td></tr><tr><td>  1 min 54 s </td><td>  2m2s </td><td>  1 min 58 s </td></tr></tbody></table></div></div></div><br><p>  Los resultados también son comparables con las soluciones basadas en rsync y, en general, están muy cerca del borgbackup, pero la carga del procesador es mayor (varios hilos funcionan) y diente de sierra. </p><br><p>  Lo más probable es que el programa dependa del rendimiento del subsistema de disco en el servidor de almacenamiento, como ocurrió con rsync.  El tamaño del repositorio era de 13 GB, al igual que zbackup o borgbackup, no hubo inconvenientes obvios al usar esta solución. </p><br><h3 id="rezultaty">  Resultados </h3><br><p>  De hecho, todos los candidatos obtuvieron indicadores cercanos, pero a un precio diferente.  Borgbackup ha demostrado ser el mejor, un poco más lento: restic, zbackup, probablemente no deberías comenzar a aplicar, <br>  y si ya está en uso, intente cambiar a borgbackup o restic. </p><br><h3 id="vyvody">  Conclusiones </h3><br><p>  La solución más prometedora es la restic, ya que  es él quien tiene la mejor relación de capacidades a velocidad, pero por ahora no apuraremos las conclusiones generales. </p><br><p>  Borgbackup, en principio, no es peor, pero zbackup es probablemente mejor para reemplazar.  Sin embargo, para garantizar que la regla 3-2-1 funcione, zbackup todavía se puede usar.  Por ejemplo, además de las herramientas de respaldo basadas en (lib) rsync. </p><br><h3 id="anons">  Anuncio </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia de seguridad, parte 1: ¿Por qué necesita una copia de seguridad, una descripción general de los métodos y las tecnologías?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia de seguridad, Parte 2: Descripción general y prueba de herramientas de copia de seguridad basadas en rsync</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia de seguridad, Parte 3: Descripción general y prueba de duplicidad, duplicación</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia de seguridad, Parte 4: Descripción general y prueba de zbackup, restic, borgbackup</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Backup, Parte 5: Prueba de Bacula y Veeam Backup para Linux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia de seguridad: parte solicitada por los lectores: revisión de AMANDA, UrBackup, BackupPC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia de seguridad, Parte 6: Comparación de herramientas de copia de seguridad</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia de seguridad Parte 7: Conclusiones</a> </p><br><p>  <u>Publicado por</u> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Finnix</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454734/">https://habr.com/ru/post/454734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454716/index.html">Los empleados no quieren un nuevo software: ¿ir de vez en cuando o doblar su línea?</a></li>
<li><a href="../454720/index.html">¿Cómo revivir la documentación?</a></li>
<li><a href="../454728/index.html">Acceso a Internet abierto: la tecnología LUWRAIN ayuda a los usuarios ciegos</a></li>
<li><a href="../454730/index.html">Reunión de Allure Server: grabaciones de video de informes</a></li>
<li><a href="../454732/index.html">5 técnicas sólidas de priorización para equipos de TI</a></li>
<li><a href="../454736/index.html">Soporte de Visual Studio 2019 en PVS-Studio</a></li>
<li><a href="../454738/index.html">Soporte de Visual Studio 2019 en PVS-Studio</a></li>
<li><a href="../454740/index.html">Mayo de 2019 Joomla Digest</a></li>
<li><a href="../454742/index.html">Al menos un truco de Vim que no conocías</a></li>
<li><a href="../454744/index.html">Descripción general de los informes de seguimiento de Java de la conferencia RigaDevDays</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>