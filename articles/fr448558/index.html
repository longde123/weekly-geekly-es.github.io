<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥š ğŸˆ² ğŸ¦ Est-il possible de rendre des images rÃ©alistes sans nombres Ã  virgule flottante? ğŸ‡ğŸ» ğŸš‘ ğŸ”µ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PrÃ©sentation 

 "Que se passe-t-il si nous remplaÃ§ons les nombres Ã  virgule flottante par des nombres rationnels et essayons de rendre l'image?" 

 Je...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Est-il possible de rendre des images rÃ©alistes sans nombres Ã  virgule flottante?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448558/"><h2>  PrÃ©sentation </h2><br><hr><br>  "Que se passe-t-il si nous remplaÃ§ons les nombres Ã  virgule flottante par des nombres rationnels et essayons de rendre l'image?" <br><br>  Je me suis posÃ© cette question aprÃ¨s avoir pensÃ© au tweet d'un chercheur et professeur d'infographie Morgan McGwire.  Il a expliquÃ© Ã  quel point les Ã©tudiants en informatique sont surpris lorsqu'ils dÃ©couvrent pour la premiÃ¨re fois que pour stocker les nombres Ã  virgule flottante familiers dans les ordinateurs modernes, des compromis doivent Ãªtre faits.  Et ces compromis rendent les tÃ¢ches simples difficiles, par exemple, vÃ©rifier si un point appartient Ã  un triangle.  Le problÃ¨me, bien sÃ»r, est que la vÃ©rification de quatre points dans le mÃªme plan (coplanaritÃ©) en utilisant un dÃ©terminant ou une sorte de multiplication vectorielle (mais en fait c'est la mÃªme chose) ne donnera jamais une valeur exactement Ã©gale Ã  zÃ©ro, ce qui est requis ce sont des mÃ©thodes mathÃ©matiques.  MÃªme si les vrais calculs d'Ãªtre sur le mÃªme plan Ã©taient exacts, les mÃªmes compromis avec une prÃ©cision de prÃ¨s de 1,0 donneraient la rÃ©ponse que les quatre points eux-mÃªmes ne sont pas coplanaires. <br><br>  Cela a donnÃ© naissance Ã  l'idÃ©e en moi - si nous supposons que toutes les donnÃ©es de rendu entrantes (coordonnÃ©es des sommets, transformations 3D, etc.) Ã©taient dÃ©finies comme des nombres rationnels, alors elles crÃ©eraient toutes les opÃ©rations, de la crÃ©ation d'un rayon, en traversant la structure accÃ©lÃ©ratrice jusqu'Ã  l'intersection les rayons avec des triangles ne sont que des nombres rationnels?  Si tel Ã©tait le cas, nous pourrions alors effectuer un test de coplanaritÃ© exactement!  Vous vous demandez peut-Ãªtre pourquoi une scÃ¨ne 3D exprimÃ©e en nombres rationnels ne devrait donner des rÃ©sultats qu'en nombres rationnels ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/c79/14b/a99c7914bc94ae608f4215c34cbe4f66.jpg"></div><br>  <i>Une scÃ¨ne simple, le tracÃ© de chemin dans lequel est effectuÃ© par l'arithmÃ©tique rationnelle.</i>  <i>Il utilise un systÃ¨me de <b>nombres Ã </b> virgule flottante, pas un <b>nombre Ã </b> virgule flottante.</i> <br><a name="habracut"></a><br>  PremiÃ¨rement, un nombre rationnel est un nombre qui peut Ãªtre exprimÃ© comme le rapport de deux entiers, par exemple 1/2 ou 355/113.  DeuxiÃ¨mement, les Â«opÃ©rations de rendu normalesÂ», telles que les tests de boÃ®te englobante, la vÃ©rification de l'intersection d'un rayon avec un triangle, la rÃ©flexion d'un rayon, etc., sont basÃ©es sur des produits vectoriels et scalaires, ainsi que sur la division scalaire (cela inclut transformation de coordonnÃ©es et inversion matricielle, quaternions, etc.), qui Ã  leur tour reposent sur quatre opÃ©rations de base: addition, soustraction, multiplication et division.  Lors de l'addition, de la soustraction, de la multiplication et de la division des nombres rationnels, des nombres rationnels sont Ã©galement obtenus.  Le mathÃ©maticien dirait que de nombreux nombres rationnels forment un champ qui est fermÃ© sous quatre opÃ©rations arithmÃ©tiques de base.  Pour nous, cela signifie que si nous adhÃ©rons Ã  des nombres exclusivement rationnels, nous pouvons rÃ©ellement passer des donnÃ©es d'entrÃ©e de la scÃ¨ne 3D Ã  une image entiÃ¨rement rendue sans quitter le monde des nombres rationnels. <br><br>  Les exceptions Ã  la rÃ¨gle Â«les actions sur les nombres rationnels donnent des nombres rationnelsÂ» sont les racines carrÃ©es et les fonctions trigonomÃ©triques / transcendantales.  Quant Ã  ce dernier, je dis toujours que si vous deviez effectuer des calculs trigonomÃ©triques dans les intÃ©rieurs gÃ©omÃ©triques de votre moteur de rendu, alors vous faites probablement quelque chose de mal (et j'ai montrÃ© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment corriger les cas les plus standards</a> ).  En ce qui concerne les racines carrÃ©es, Ã  l'exception des sections coniques (sphÃ¨res, cylindres, etc.) et de l'ombrage / DFOS / coloration, il n'est pas nÃ©cessaire de normaliser les rayons et la normale aux surfaces aussi souvent que d'habitude.  Il n'est certainement pas nÃ©cessaire de le faire pour crÃ©er un rayon, son passage, son intersection, ses rÃ©flexions, etc.  Malheureusement, trÃ¨s souvent, je vois que les programmeurs normalisent les valeurs sans autre raison que "eh bien, je ne sais pas, je le fais pour pouvoir jouer en toute sÃ©curitÃ©."  En pratique, dans la partie du rendu oÃ¹ la gÃ©omÃ©trie est tracÃ©e, il est trÃ¨s rarement nÃ©cessaire de normaliser les valeurs, donc j'avais l'espoir qu'il serait possible de tracer toute la scÃ¨ne sans quitter le monde des nombres rationnels - c'est ce que j'appellerais le "rendu rationnel". <br><br>  Pour mettre cela en pratique, je dois crÃ©er un systÃ¨me numÃ©rique basÃ© sur des nombres rationnels qu'un ordinateur pourrait utiliser.  Ensuite, j'ai pu implÃ©menter les algorithmes de traÃ§age de chemin habituels, calculer des images sans perte de prÃ©cision, effectuer des vÃ©rifications de coplanaritÃ© qui ont des rÃ©ponses prÃ©cises et rendre tous les Ã©tudiants Ã©tudiant l'infographie heureux. <br><br>  Cet article est une histoire de deux nuits de recherche sur le rÃ©alisme d'une telle idÃ©e.  Je vais parler des nombreux aspects que j'ai appris, de ce que j'ai trouvÃ© et de quelques surprises que j'ai dÃ©couvertes au cours du processus.  L'article est Ã©crit dans un ordre plus ou moins chronologique de mon travail.  De plus, il a Ã©tÃ© Ã©crit dans mon style inhabituellement informel et trÃ¨s peu scientifique (dont je suis fier).  L'image ci-dessus est une sorte de spoiler, mais lisez l'article Ã  la fin, car je vais parler du bon et du mauvais. <br><br><h2>  La prÃ©paration </h2><br><hr><br>  La premiÃ¨re chose que j'ai faite a Ã©tÃ© d'implÃ©menter dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shadertoy un</a> traceur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">minimalement</a> limitÃ© pour une scÃ¨ne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extrÃªmement simple</a> composÃ©e d'un plan, d'une sphÃ¨re, d'un parallÃ©lÃ©pipÃ¨de rectangle et d'un triangle - les blocs de construction de vÃ©ritables moteurs de rendu.  Ensuite, j'ai copiÃ© le code dans un fichier C ++ et, aprÃ¨s avoir apportÃ© quelques modifications mineures, je l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ai</a> compilÃ© Ã  l'aide de mon framework <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">piLibs</a> .  Donc, Ã  titre de comparaison, j'ai obtenu une image tracÃ©e rendue au processeur en utilisant des nombres rÃ©guliers selon la norme IEEE754 avec une virgule flottante.  J'ai Ã©galement supprimÃ© toute normalisation des rayons du code de trace, car, comme mentionnÃ© ci-dessus, aucune d'entre elles n'est rÃ©ellement nÃ©cessaire.  Permettez-moi de vous rappeler qu'une racine carrÃ©e est requise pour la normalisation et que les nombres rationnels ne sont pas conservÃ©s lorsqu'elle est utilisÃ©e (la racine carrÃ©e d'un nombre rationnel n'est pas un nombre rationnel).  Un peu plus tard, nous verrons qu'appliquer des racines carrÃ©es, bien sÃ»r, est toujours possible, je voulais juste rendre le code aussi mathÃ©matiquement propre que possible pour voir jusqu'oÃ¹ je peux aller avec l'arithmÃ©tique exacte des nombres rationnels sans arrondir. <br><br>  La derniÃ¨re Ã©tape prÃ©paratoire - j'ai pris toutes les classes vec3, mat4x4 et autres classes d'algÃ¨bre / mathÃ©matiques de base, puis je les ai modifiÃ©es pour qu'elles utilisent rationnel au lieu de flottant.  Comme ma structure rationnelle surcharge tous les opÃ©rateurs standard (add, sub, mul, div, inversion de signe, comparaisons, etc.), le remplacement s'est produit sans problÃ¨me.  J'ai rapidement implÃ©mentÃ© les opÃ©rations habituelles restantes (abs, signe, mod, fract, floor, sqrt, etc.), ce qui Ã©tait thÃ©oriquement suffisant pour obtenir de beaux rendus rationnels. <br><br><h2>  Test 1 - La solution naÃ¯ve </h2><br><hr><br>  Mais voyons Ã  quoi ressemblait cette premiÃ¨re implÃ©mentation.  Au dÃ©but, j'essaie toujours le plus simple, puis je regarde les rÃ©sultats.  Et la maniÃ¨re la plus simple d'implÃ©menter des valeurs rationnelles Ã©tait d'utiliser deux entiers.  Comme le nom de la section l'indique, ce ne sera pas ma dÃ©cision finale, mais pour la premiÃ¨re tentative, c'Ã©tait une dÃ©cision raisonnable.  Ainsi, chaque nombre <b>x</b> doit Ãªtre reprÃ©sentÃ© comme le numÃ©rateur <b>N</b> et le dÃ©nominateur <b>D</b> , formant la valeur <b>N</b> / <b>D.</b>  La valeur <b>x</b> est approximÃ©e par la meilleure paire <b>N</b> / <b>D</b> possible (dans la profondeur de bits spÃ©cifiÃ©e), qui est la plus proche de la vraie valeur <b>x</b> .  J'ai dÃ©cidÃ© que les deux nombres doivent Ãªtre positifs, et le signe du nombre doit Ãªtre stockÃ© dans un bit sÃ©parÃ© afin de simplifier le travail et de se dÃ©barrasser des ambiguÃ¯tÃ©s, bien que ce ne soit pas trÃ¨s important.  Ã€ ce stade, les numÃ©rateurs et les dÃ©nominateurs Ã©taient de type non signÃ©.  Mais mÃªme en sÃ©parant le signe, <b>N</b> / <b>D</b> avait beaucoup de redondance: par exemple, 1/4 et 7/28 dÃ©signent le mÃªme nombre, mais ont des reprÃ©sentations binaires complÃ¨tement diffÃ©rentes.  Nous y reviendrons plus tard, mais pour l'instant, ne concentrons pas notre attention et voyons Ã  quoi ressemblent les quatre opÃ©rations arithmÃ©tiques de base sous cette forme rationnelle. <br><br>  Tout d'abord, notez que la soustraction de <b>a</b> - <b>b</b> est simplement l'addition de <b>a</b> et la valeur opposÃ©e Ã  <b>b</b> , c'est-Ã -dire <b>a</b> + ( <b>-b</b> ), oÃ¹ <b>-b</b> peut Ãªtre calculÃ© en changeant simplement le signe de <b>b</b> .  De mÃªme, diviser <b>a</b> / <b>b</b> Ã©quivaut Ã  multiplier <b>a</b> et l'inverse de <b>b</b> .  Ou, en d'autres termes, <b>a</b> / <b>b</b> = <b>a</b> Â· (1 / <b>b</b> ), oÃ¹ (1 / <b>b</b> ) peut Ãªtre calculÃ© en changeant simplement les places du numÃ©rateur <b>b <sub>n</sub></b> et du dÃ©nominateur <b>b <sub>d du</sub></b> nombre <b>b</b> .  Donc, voici la premiÃ¨re propriÃ©tÃ© intÃ©ressante de l'arithmÃ©tique rationnelle - la division et la multiplication ont les mÃªmes coÃ»ts, par consÃ©quent, contrairement au rendu en virgule flottante habituel, dans lequel les divisions sont gÃ©nÃ©ralement Ã©vitÃ©es, retardÃ©es ou cachÃ©es sous les retards des demandes de texture lentes, il n'est pas nÃ©cessaire d'avoir peur de ces opÃ©rations en arithmÃ©tique rationnelle . <br><br>  Nous passons Ã  l'addition avec multiplication: nous savons que les valeurs opposÃ©es et inverses sont trivialement simples Ã  calculer, nous obtenons donc: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20f/b96/9c6/20fb969c6d2d6ad899898575244a8d20.png"></div><br>  La prÃ©servation des signes pendant la multiplication est triviale, c'est juste xor, car deux valeurs positives donnent un rÃ©sultat positif, ainsi que deux nÃ©gatives.  L'enregistrement d'un signe pour l'ajout est un processus plus compliquÃ©, et pour une solution rapide, je l'ai implÃ©mentÃ© Ã  travers trois branches (l'ajout est trivial si les signes <b>a</b> et <b>b</b> coÃ¯ncident, mais lorsqu'ils ne correspondent pas, vous devez sÃ©lectionner un plus petit nombre et le soustraire du plus grand - dans l'article, je ne le fais pas Je vais dÃ©crire ces petits dÃ©tails plus en dÃ©tail, mais il suffit de disposer le code source quelque part). <br><br>  Je vais Ã©galement sauter l'implÃ©mentation de fract () et floor ();  si vous dÃ©cidez d'essayer de les mettre en Å“uvre vous-mÃªme, vous verrez leur simplicitÃ© et leur beautÃ©.  Il convient Ã©galement de prÃªter attention aux opÃ©rateurs de comparaison.  AprÃ¨s avoir pris soin des signes et en supposant que <b>a</b> et <b>b sont</b> positifs, nous obtenons <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/b9c/831/6e4b9c831e9b49215c939fedc88ee0cd.png"></div><br>  Il est important de noter ici que mÃªme pour la comparaison, nous avons besoin de quelques opÃ©rations de multiplication, ce qui peut conduire Ã  la transition vers la taille de mot suivante et sera un peu plus faible. <br><br>  Enfin, nous regardons les racines carrÃ©es dans une section distincte, sachant que pour la plupart nous n'en avons pas besoin (sauf pour la sphÃ¨re de ce premier test). <br><br>  Cela a suffi pour exÃ©cuter le premier rendu et tracer la scÃ¨ne de test (plan + sphÃ¨re + triangle + boÃ®te rectangulaire) pour voir ce qui en est sorti.  J'ai gÃ©nÃ©reusement utilisÃ© des nombres rationnels de 65 bits pour ce premier test, qui reprÃ©sente en fait une grande quantitÃ© de donnÃ©es (comparable au type de donnÃ©es "double"): 32 bits sont pris par le numÃ©rateur, 32 bits sont le dÃ©nominateur et un autre bit est le signe.  La premiÃ¨re est l'image obtenue avec cette approche naÃ¯ve, la seconde est l'image rÃ©alisÃ©e Ã  l'aide de nombres Ã  virgule flottante (rÃ©fÃ©rence): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/628/aca/f79628aca052bc725fa16953c8939a5c.png"></div><br>  <i>Nombres rationnels de 65 bits "naÃ¯fs"</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>RÃ©fÃ©rence en virgule flottante</i> <br><br>  Le rÃ©sultat Ã©tait plutÃ´t mauvais, la boÃ®te et le triangle n'apparaissaient mÃªme pas sur le rendu, et la sphÃ¨re et le plan du sol Ã©taient trop bruyants.  Le problÃ¨me, bien sÃ»r, Ã©tait que chaque fois que mes nombres rationnels effectuaient une opÃ©ration arithmÃ©tique de base Ã  l'une des Ã©tapes algorithmiques du rendu, le numÃ©rateur et le dÃ©nominateur devenaient de plus en plus incontrÃ´lables, car une multiplication entiÃ¨re Ã©tait utilisÃ©e.  Pensez Ã  ce qui suit: si les unitÃ©s de notre monde initial Ã©taient des mÃ¨tres et que nous lierions la gÃ©omÃ©trie source (sommets et camÃ©ra) Ã  une prÃ©cision millimÃ©trique, alors seules les donnÃ©es source occuperaient un volume de 16 bits pour une scÃ¨ne plutÃ´t petite.  Dans le mÃªme temps, avec une rÃ©solution d'Ã©cran HD standard et un lissage 4X, les nombres de direction de faisceau rationnels nÃ©cessiteraient facilement 12 bits.  C'est-Ã -dire que lors de la premiÃ¨re interaction du faisceau et de la gÃ©omÃ©trie, l'opÃ©ration arithmÃ©tique la plus simple, utilisant les deux ensembles de donnÃ©es d'entrÃ©e, transformerait le rÃ©sultat en longueurs de 28 bits - assez prÃ¨s de la limite de 32 bits que je me suis fixÃ©e dans cette premiÃ¨re implÃ©mentation.  Et c'est avant mÃªme d'avoir rÃ©alisÃ© le tout premier produit vectoriel ou scalaire.  Au moment oÃ¹ le produit scalaire est terminÃ©, le moteur de rendu aurait besoin de nombres rationnels de centaines de bits pour reprÃ©senter les nombres.  Bien sÃ»r, c'est le pire des cas, mais le cas moyen serait proche de cela.  Ã‰tant donnÃ© que je n'ai allouÃ© qu'une capacitÃ© de 32 bits pour le numÃ©rateur et le dÃ©nominateur, il est facile de comprendre Ã  quelle vitesse les valeurs dÃ©passent les limites de ce test - il n'est pas surprenant que presque rien ne soit visible, sauf pour le plan d'Ã©tage et une partie de la sphÃ¨re. <br><br><h2>  Test 2 - RÃ©duction par le plus grand facteur commun </h2><br><hr><br>  Ensuite, j'ai amÃ©liorÃ© le systÃ¨me en utilisant la propriÃ©tÃ© que j'ai briÃ¨vement mentionnÃ©e ci-dessus - des nombres rationnels diffÃ©rents peuvent signifier le mÃªme montant.  Et en fait, 6/12 est la mÃªme valeur que 1/2, mais il utilise beaucoup plus de bits que le dernier.  Par consÃ©quent, l'idÃ©e Ã©tait la suivante: si aprÃ¨s chaque opÃ©ration arithmÃ©tique de base (ou aprÃ¨s) j'extrayais tous les diviseurs communs du numÃ©rateur et des dÃ©nominateurs, et ramÃ¨nerais la fraction Ã  sa forme la plus simple, alors je serais peut-Ãªtre en mesure de tout garder sous contrÃ´le et de continuer les opÃ©rations plus longtemps avec une arithmÃ©tique exacte sans perte de prÃ©cision.  Peut-Ãªtre pouvez-vous le faire assez longtemps pour obtenir des images propres et rendues?  Je vais prendre une petite digression pour montrer un autre exemple: 588/910 peut Ãªtre simplifiÃ© en 42/65, car 14 est un diviseur de 588 et 910. Mais pour stocker 42/65, Ã©videmment, moins de bits sont nÃ©cessaires que 588/910.  Trouver le plus grand nombre possible qui divise simultanÃ©ment les deux autres nombres peut Ãªtre fait en utilisant l'algorithme Great Common Divisor (GCD), des implÃ©mentations efficaces que vous pouvez trouver n'importe oÃ¹ (je l'ai personnellement copiÃ© directement Ã  partir de Wikipedia et l'ai accÃ©lÃ©rÃ© un peu en effectuant l'Ã©tape de numÃ©risation bits utilisant des opÃ©rations internes x64).  Ainsi, armÃ©e de l'algorithme GCD, ma classe rationnelle devrait constamment simplifier les fractions gÃ©nÃ©rÃ©es au cours du processus de rendu.  Cela pourrait se faire de deux maniÃ¨res: <br><br>  La premiÃ¨re consiste Ã  convertir le rÃ©sultat intermÃ©diaire des opÃ©rateurs d'addition et de multiplication vers le type de donnÃ©es de bit suivant (dans ma solution naÃ¯ve actuelle, c'est uin64_t), recherchez GCD dans ce type de donnÃ©es plus volumineux, puis rÃ©duisez le rÃ©sultat Ã  la longueur de bit d'origine (32).  La deuxiÃ¨me faÃ§on consiste Ã  analyser comment <b>a <sub>n</sub></b> , <b>a <sub>d</sub></b> , <b>b <sub>n</sub></b> et <b>b <sub>d</sub></b> sont combinÃ©s les uns avec les autres dans les deux opÃ©rateurs arithmÃ©tiques et d'en extraire des diviseurs communs avant d'effectuer la multiplication.  La deuxiÃ¨me approche a essentiellement Ã©liminÃ© le besoin de grandes longueurs de bits.  Sachant qu'il pourrait Ãªtre nÃ©cessaire de les utiliser de toute faÃ§on, j'ai dÃ©cidÃ© de choisir la premiÃ¨re mÃ©thode, car elle Ã©tait plus facile Ã  mettre en Å“uvre et elle m'a permis d'accÃ©lÃ©rer mon travail (la soirÃ©e s'envole trÃ¨s vite).  AprÃ¨s avoir fait tout cela, voyons quel rendu je peux crÃ©er maintenant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb9/bc5/66f/eb9bc566f927cab52570332aff765d02.png"></div><br>  <i>Nombre rationnel de 65 bits rÃ©duit par GCD</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>RÃ©fÃ©rence en virgule flottante</i> <br><br>  Bien mieux!  Jusqu'Ã  prÃ©sent, loin d'Ãªtre idÃ©al, bien sÃ»r, mais cela semble prometteur.  J'ai fait apparaÃ®tre la boÃ®te et le triangle, et la sphÃ¨re semble maintenant beaucoup plus volumineuse.  Cependant, un artefact drÃ´le est apparu dans le coin supÃ©rieur droit, et les nombres rationnels pour de nombreux pixels dÃ©passent toujours les limites, ce qui conduit Ã  de nombreux points dans l'image.  Cependant, il convient de noter que pour certains (nombreux) pixels, j'ai commencÃ© Ã  obtenir <b>des</b> rÃ©sultats <b>prÃ©cis</b> et parfaits!  Autrement dit, le traceur a trouvÃ© des intersections mathÃ©matiquement prÃ©cises de points et de distances, ce qui Ã©tait la cause premiÃ¨re de l'utilisation de nombres rationnels. <br><br>  Avant de passer Ã  l'Ã©tape suivante du processus de preuve de l'applicabilitÃ© des nombres rationnels, je souhaite briÃ¨vement m'arrÃªter et partager mes conclusions concernant la GCD et la rÃ©duction des nombres rationnels. <br><br>  La premiÃ¨re dÃ©couverte est liÃ©e au volume de bits des nombres rationnels.  MÃªme si je ne peux toujours pas rendre de belles images et cela est plus important que de se soucier de l'optimisation des volumes de donnÃ©es, et bien que cette premiÃ¨re implÃ©mentation utilisait toujours un grand nombre de bits (1 + 32 + 32), je pensais dÃ©jÃ  aux dÃ©chets mentionnÃ©s plus tÃ´t bits sous forme de fractions en excÃ¨s.  En particulier, aprÃ¨s avoir ajoutÃ© une Ã©tape avec un GCD, les combinaisons de bits comme 2/4 ne sont plus applicables, car elles sont automatiquement rÃ©duites Ã  1/2 avant d'Ã©crire dans un registre ou une variable.  Autrement dit, sur les 2 <sup>64</sup> combinaisons de bits qui pourraient Ãªtre le numÃ©rateur et le dÃ©nominateur, beaucoup restent inutilisÃ©es.  Et vous ne pouvez pas gaspiller des morceaux comme Ã§a.  Ou est-ce possible?  Combien d'espace ai-je rÃ©ellement perdu?  J'ai fait une petite digression pour explorer cette question. <br><br><h2>  Digression - sur des nombres mutuellement premiers </h2><br><hr><br>  Les illustrations ci-dessous montrent l'utilisation de bits pour les nombres rationnels en 5/5 bits et 7/7 bits.  Les axes horizontal et vertical des graphiques reprÃ©sentent les valeurs du numÃ©rateur et du dÃ©nominateur de tous les nombres rationnels possibles ayant des numÃ©rateurs et des dÃ©nominateurs jusqu'Ã  5 bits (31) et 7 bits (127).  Les pixels noirs sont des combinaisons inutilisÃ©es et les pixels blancs sont des fractions utilisÃ©es.  Par exemple, toute la diagonale est noire, Ã  l'exception du pixel 1/1, car toutes les fractions de la forme n / n sont rÃ©duites Ã  1/1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6c/f08/b9d/c6cf08b9df8d1adecee7836e92a228be.png"><br><br>  <i>Utilisation de bits pour 5/5 rationnel</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16e/79b/24b/16e79b24b234907f082af70a013ae971.png"><br><br>  <i>Utilisation de bits pour 7/7 rationnel</i> <br><br>  Si vous comptez les pixels, comme je l'ai fait, vous pouvez rapidement comprendre que la proportion de pixels utiles avec une augmentation du nombre de bits tend Ã  60,8%.  Une petite recherche en ligne m'a montrÃ© que ce rapport se rÃ©vÃ¨le Ãªtre exactement 6 / Ï€ <sup>2</sup> , car c'est aussi la probabilitÃ© d'Ãªtre relativement premier (n'ayant pas de diviseurs communs) pour deux nombres alÃ©atoires.  Vous pouvez demander, d'oÃ¹ vient le pi?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'avÃ¨re que Â«six par pi au carrÃ©Â» est une valeur Ã©gale Ã  l'unitÃ© divisÃ©e par la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction zÃªta de Riemann</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calculÃ©e au point 2, 1 / Î¶ (2). Cela ne devrait pas nous surprendre beaucoup, car la fonction zÃªta de Riemann apparaÃ®t souvent dans des problÃ¨mes impliquant des nombres premiers et mutuellement premiers.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quoi qu'il en soit, Ã  mon avis rationnel, j'ai gaspillÃ© environ 40% des combinaisons de bits. Et mÃªme si cela semble Ãªtre un grand nombre, j'ai dÃ©cidÃ© de le regarder comme s'il Ã©tait en fait un peu moins ... grÃ¢ce auquel je n'ai pas pu Ãªtre trÃ¨s contrariÃ©. Dans cet esprit, j'ai dÃ©cidÃ© de passer Ã  autre chose, en utilisant d'autres approches complÃ¨tement diffÃ©rentes, au lieu d'essayer d'optimiser ce problÃ¨me localement. Cependant, nÃ©anmoins, j'ai briÃ¨vement appris sur les arbres Stern-Brokaw et Calkin-Wilf, ce qui pourrait me permettre d'utiliser pleinement tous les bits disponibles, mais l'intervalle de valeurs obtenues avec leur aide est trÃ¨s petit, j'ai donc rapidement abandonnÃ© cette idÃ©e et je suis passÃ© Ã  autre chose. Je pense qu'Ã  ce stade, je dois exprimer ma gratitude envers </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WikipÃ©dia en</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tant que source constante de mes connaissances.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenons Ã  l'analyse de ce que nous avons obtenu: je peux rendre des images avec des distorsions, mais cela dÃ©pend beaucoup de la distribution des nombres premiers dans les calculs. Cela dÃ©pend de ces nombres premiers si l'algorithme GCD peut simplifier l'expression - dÃ¨s qu'un nombre premier ou un multiple tombe dans l'un des nombres de rendu (vecteurs, scalaires, matrices), il "pollue" tous les nombres qui le suivent dans d'autres manipulations arithmÃ©tiques, et y demeure pour toujours. Par consÃ©quent, progressivement tout est garanti pour commencer Ã  croÃ®tre, ce n'est qu'une question de temps. En plus du fait que cela est inÃ©vitable, il est Ã©galement nÃ©cessaire, car ce sont des diviseurs mutuellement simples qui portent des informations sur la valeur d'un nombre. Mais en mÃªme temps, les grands nombres premiers cassent tout trÃ¨s rapidement. Il y a donc un conflit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derniÃ¨re chose Ã  noter est que j'utilisais toujours deux fois plus de bits que le nombre Ã  virgule flottante standard, donc il n'y a aucun avantage rÃ©el jusqu'ici. </font><font style="vertical-align: inherit;">Bien sÃ»r, j'ai essayÃ© d'utiliser des nombres rationnels 16/16 bits, ce qui serait une comparaison plus honnÃªte avec les vraies exigences de l'arithmÃ©tique Ã  virgule flottante, mais avec une prÃ©cision de 16/16, le systÃ¨me que j'ai Ã©crit avec le numÃ©rateur + dÃ©nominateur + GCD a crÃ©Ã© des images complÃ¨tement illisibles.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test 3 - Normalisation des nombres rationnels </font></font></h2><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, Ã  ce stade, j'avais besoin de quelque chose de vraiment significatif. Il semblait que pour empÃªcher les nombres de sortir des limites, il fallait commencer Ã  les couper et Ã  perdre en prÃ©cision. Toute mon expÃ©rience a commencÃ© avec l'idÃ©e de rechercher </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rendu </font><b><font style="vertical-align: inherit;">prÃ©cis</font></b><font style="vertical-align: inherit;"> , mais Ã  ce moment-lÃ , j'ai senti que j'Ã©tais prÃªt Ã  abandonner cette idÃ©e et continuer Ã  explorer d'autres domaines, ne serait-ce que pour le plaisir, et voir Ã  quoi cela me mÃ¨nerait (l'idÃ©e initiale stimulant le processus de recherche "C'est exactement l'idÃ©e de commencer le processus, et aprÃ¨s cela, vous vous retrouvez souvent dans un endroit complÃ¨tement inattendu. Ou, comme John Cleese l'a dit une fois, les mauvaises idÃ©es peuvent conduire Ã  de bonnes idÃ©es, le processus crÃ©atif n'est pas toujours toujours edovatelnostyu ou logiquement vraie progression des Ã©tapes).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quoi qu'il en soit, j'ai dÃ©cidÃ© de vÃ©rifier ce qui arriverait aux rendus si je protÃ©geais en quelque sorte le numÃ©rateur et le dÃ©nominateur des dÃ©bordements. La maniÃ¨re la plus simple serait de dÃ©caler le numÃ©rateur et le dÃ©nominateur, si nÃ©cessaire, d'un nombre suffisant de bits vers la droite, jusqu'Ã  ce qu'ils rÃ©apparaissent dans l'espace binaire qui leur est allouÃ©. En fait, cela signifie une division entiÃ¨re du numÃ©rateur et du dÃ©nominateur par une valeur, ce qui signifie que la valeur du nombre reste </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">approximativement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inchangÃ©e. Et ici, je me suis Ã©cartÃ© du but initial de l'expÃ©rience.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ma premiÃ¨re implÃ©mentation, j'ai regardÃ© le nombre de bits nÃ©cessaires pour le numÃ©rateur et le dÃ©nominateur, pris le maximum pour les deux et dÃ©calÃ© les deux par ce nombre de bits (arrondi Ã  l'entier le plus proche). </font><font style="vertical-align: inherit;">Lorsque cela a Ã©tÃ© implÃ©mentÃ© dans les opÃ©rateurs d'addition et de multiplication, tout a commencÃ© Ã  sembler tout Ã  fait acceptable:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/c9d/8db/912c9d8dbc165e2aa14843cb3b3ccd12.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombres rationnels 65 bits rÃ©duits par GCD et normalisation</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Norme Ã  virgule flottante</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puisque tout semblait plutÃ´t bien, Ã  ce stade, j'ai procÃ©dÃ© Ã  la rÃ©solution du problÃ¨me d'une grande quantitÃ© de bits utilisÃ©s dans l'implÃ©mentation actuelle. </font><font style="vertical-align: inherit;">J'ai essayÃ© d'utiliser 16/16 (33 bits) au lieu de 32/32 (65 bits), et les images se sont rÃ©vÃ©lÃ©es Ã©tonnamment bonnes! </font><font style="vertical-align: inherit;">J'ai encore vu que sur certains bords de la sphÃ¨re il y a de petits trous, et dans la figure de la texture du triangle il y a de petits trous. </font><font style="vertical-align: inherit;">Mais ce n'est pas mauvais pour des quantitÃ©s suffisamment proches des nombres Ã  virgule flottante. </font><font style="vertical-align: inherit;">Cela m'a donnÃ© de l'Ã©nergie pour apprendre de nouvelles idÃ©es.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test 4 - Slash flottant </font></font></h2><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ã€ ce stade, j'ai dÃ©cidÃ© de me distraire et d'arrÃªter de chercher des excuses - si je veux trouver quelque chose d'intÃ©ressant pour le rendu en nombres rationnels, alors ils devraient occuper 32 bits et pas plus. Il vaut mieux trouver une bonne idÃ©e ou s'arrÃªter, et s'arrÃªter lÃ  (c'Ã©tait au dÃ©but de la deuxiÃ¨me soirÃ©e d'expÃ©riences).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au dÃ©but, je pensais que cela valait la peine de s'en tenir aux idÃ©es de GCD et de normalisation, mais il Ã©tait plus sage d'aborder le stockage et l'utilisation des bits. La premiÃ¨re chose qui m'est venue Ã  l'esprit est que mÃªme si le numÃ©rateur et le dÃ©nominateur peuvent devenir volumineux, cela ne se produit souvent pas. Ou, du moins, cela ne se produit pas simultanÃ©ment. Par consÃ©quent, lorsque le numÃ©rateur est petit, vous pouvez laisser le dÃ©nominateur Ãªtre grand et vice versa. Les bits inutilisÃ©s de l'une des deux valeurs entiÃ¨res peuvent Ãªtre utilisÃ©s pour reprÃ©senter des valeurs plus grandes. Puis je me suis rendu compte que de la mÃªme maniÃ¨re, un nombre Ã  virgule flottante est essentiellement un format Ã  virgule fixe, oÃ¹ le point Â«fixeÂ» est rendu variable. Je peux prendre mes nombres rationnels et Ã©galement faire la disposition des bits de la variable de fraction de fraction. Autrement dit, il n'est pas difficile de dÃ©finir la fraction sur 16/16, mais de permettre Ã  la mÃªme variable 32 bits d'Ãªtre parfois 16/16,et parfois 5/27 ou 13/19, au besoin.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela valait la peine de vÃ©rifier. </font><font style="vertical-align: inherit;">Quoi qu'il en soit, quelques lignes de code d'emballage / dÃ©ballage dans les setters et les getters internes peuvent Ãªtre Ã©crites rapidement. </font><font style="vertical-align: inherit;">Le schÃ©ma le plus logique pour moi semblait 1 | 5 | 26, c'est-Ã -dire:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 bit: signe </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 bits: position de la ligne de fraction (B) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26 bits: donnÃ©es combinÃ©es numÃ©rateur et dÃ©nominateur; </font><font style="vertical-align: inherit;">le numÃ©rateur est le bit 26-B supÃ©rieur, le dÃ©nominateur est le bit B infÃ©rieur,</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oÃ¹ la barre de fraction (B) dÃ©termine la taille du dÃ©nominateur. </font><font style="vertical-align: inherit;">Par exemple, le nombre 7/3 sera Ã©crit comme</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/3 = 0 00010 000000000000000000000111 11, </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oÃ¹ le signe 0 signifie une valeur positive, la ligne de la fraction 2 dÃ©signe le dÃ©nominateur (numÃ©ro 3), qui nÃ©cessite 2 bits pour reprÃ©senter, et le reste des bits va au numÃ©rateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les lecteurs qui ont travaillÃ© avec la norme IEEE754 peuvent trouver cette observation familiÃ¨re: la reprÃ©sentation binaire du dÃ©nominateur commence toujours par Â«1Â», car le numÃ©ro de ligne de fraction le tronque toujours Ã  la reprÃ©sentation la plus courte. </font><font style="vertical-align: inherit;">Autrement dit, le premier bit du dÃ©nominateur est facultatif. </font><font style="vertical-align: inherit;">Dans ce cas, le nombre Â«3Â» ne peut Ãªtre reprÃ©sentÃ© que par la valeur binaire Â«1Â» et la valeur de la ligne de fraction Â«1Â»:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/3 = 0 00001 00000000000000000000001111 1 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette astuce m'a non seulement sauvÃ© un bit prÃ©cieux, mais a Ã©galement un excellent effet secondaire: lorsque la valeur du trait de fraction est nulle, cela signifie naturellement en mÃªme temps que le dÃ©nominateur est 1 et qu'aucun espace n'est nÃ©cessaire pour le stocker. Cela signifie que ma reprÃ©sentation rationnelle des nombres s'est avÃ©rÃ©e soudainement complÃ¨tement compatible avec la reprÃ©sentation entiÃ¨re et l'arithmÃ©tique habituelles, jusqu'Ã  ce que les valeurs des nombres dÃ©passent 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est-Ã -dire Ã  un seuil suffisamment grand. </font><font style="vertical-align: inherit;">Quelle merveilleuse surprise! </font><font style="vertical-align: inherit;">C'est-Ã -dire que thÃ©oriquement, je peux utiliser exactement le mÃªme type de donnÃ©es, Â«rationnelÂ», pour effectuer des opÃ©rations de rendu et d'ombrage standard, mais aussi effectuer toute la logique et les tÃ¢ches du flux de commandes dans le traceur de chemin - je n'ai plus besoin d'utiliser deux types de donnÃ©es, car cela se produit dans la plupart des moteurs de rendu ("int" et "float") et effectuez des conversions dans un sens et dans un autre! </font><font style="vertical-align: inherit;">Cependant, le temps Ã©tant comptÃ© pour moi, je n'ai pas changÃ© tous les indices de boucle de Â«intÂ» Ã  Â«rationnelÂ». </font><font style="vertical-align: inherit;">La soirÃ©e touchait Ã  sa fin, et je devais encore vÃ©rifier beaucoup de choses pour amÃ©liorer la qualitÃ© des rendus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AprÃ¨s avoir crÃ©Ã© l'implÃ©mentation, j'ai pu le vÃ©rifier:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcb/a9b/34d/fcba9b34d81aae413f1288e6dcfcdf9b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombres rationnels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fractionnaires</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 32 bits </font><font style="vertical-align: inherit;">(1 | 5 | 26)</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standard 32 bits flottant </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-point</font></font></b></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O-oh, eh bien! J'ai encore des artefacts dans la sphÃ¨re, que je vais pour l'instant blÃ¢mer pour ma mauvaise mise en Å“uvre de la racine carrÃ©e, mais la boÃ®te et le triangle sont devenus vraiment propres. Le nombre de pixels d'image rÃ©solus avec prÃ©cision a Ã©galement augmentÃ©. Je pense qu'en raison du fait qu'avant le dÃ©bordement du dÃ©nominateur ou du numÃ©rateur, plus de nombres ont le temps d'apparaÃ®tre, j'ai augmentÃ© la probabilitÃ© que le GCD trouve des diviseurs communs et effectue une rÃ©duction. C'est-Ã -dire que la ligne flottante de la fraction a non seulement augmentÃ© l'intervalle des nombres reprÃ©sentÃ©s et a reportÃ© le moment de normalisation (avec perte de prÃ©cision) causÃ©e par le dÃ©bordement, mais a Ã©galement franchi l'Ã©tape suivante dans l'amÃ©lioration de la qualitÃ© en augmentant la probabilitÃ© de rÃ©ductions.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ã€ ce stade, j'Ã©tais prÃªt Ã  effectuer un test plus sÃ©rieux (mais toujours expÃ©rimental - le systÃ¨me est encore loin d'Ãªtre prÃªt Ã  fonctionner). </font><font style="vertical-align: inherit;">J'ai implÃ©mentÃ© un traceur de chemin avec un ensemble minimal de fonctions (pas nÃ©cessairement physiquement prÃ©cises ou mÃªme en tenant compte de la physique) et crÃ©Ã© une scÃ¨ne avec plusieurs parallÃ©lÃ©pipÃ¨des rectangulaires et deux sources lumineuses, dont l'implÃ©mentation de rÃ©fÃ©rence sur le GPU est ici: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.shadertoy.com/view/Xd2fzR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai Ã  nouveau converti la scÃ¨ne en framework C ++, supprimÃ© Ã  nouveau certaines normalisations de rayons inutiles et exÃ©cutÃ© le rendu. </font><font style="vertical-align: inherit;">Voici ce que j'ai obtenu:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/e7d/951/5b9e7d951bbef194094a389017433a50.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombres rationnels </font><b><font style="vertical-align: inherit;">fractionnaires</font></b><font style="vertical-align: inherit;"> 32 bits</font></font><b><font style="vertical-align: inherit;"></font></b></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/58f/543/20d58f54338c93f88379f550faf52c51.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flottante de </font><font style="vertical-align: inherit;">32 bits standards </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Point</font></font></b></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wow, c'est vraiment bon! </font><font style="vertical-align: inherit;">Bien que les fuites de lumiÃ¨re soient clairement visibles dans les coins oÃ¹ les bords du sol et du plafond sont connectÃ©s. </font><font style="vertical-align: inherit;">Regardez-les dans l'approximation: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/36d/404/72d/36d40472de509e4fe6a7520c7e6df5a4.png"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/9da/0d6/ffd9da0d613a076c0c624e5a9b2c15e9.png"><img src="https://habrastorage.org/getpro/habr/post_images/273/84b/a41/27384ba41a08f4771f8cf6c6cddd129d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elles sont peut-Ãªtre causÃ©es par un problÃ¨me dans ma mise en Å“uvre de l'intersection d'un rayon et d'une boÃ®te rectangulaire, qui ne s'exprime qu'en nombres rationnels; </font><font style="vertical-align: inherit;">Je ne serais pas surpris. </font><font style="vertical-align: inherit;">Ou peut-Ãªtre que je suis tombÃ© sur les limites de ce dont les nombres rationnels sont capables. </font><font style="vertical-align: inherit;">Quoi qu'il en soit, je suis trÃ¨s content. </font><font style="vertical-align: inherit;">De plus, j'ai d'autres changements et expÃ©riences que je voulais tester pour le peu de temps restant:</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelques autres expÃ©riences </font></font></h2><br><hr><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArithmÃ©tique prÃ©cise en 64 bits </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'idÃ©e de l'arithmÃ©tique exacte ne peut Ãªtre rÃ©alisÃ©e ni en nombres rationnels naÃ¯fs 64 bits ni en nombres rationnels 32 bits (1 | 5 | 26) avec une fraction de ligne flottante. Et les nombres Ã  virgule flottante 64 bits d'une fraction fonctionneront-ils? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai rapidement implÃ©mentÃ© des nombres rationnels 1 | 6 | 57 (mÃªme si j'ai dÃ» apprendre de nouveaux mÃ©canismes internes x64 pour dÃ©caler les bits). Ces 57 bits de numÃ©rateur / dÃ©nominateur ont permis de tracer un intervalle de distance beaucoup plus grand. J'ai vraiment Ã©tÃ© en </font><font style="vertical-align: inherit;">mesure de retracer la scÃ¨ne avec plusieurs triangles avec tout </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prÃ©cis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arithmÃ©tique (pas la scÃ¨ne mentionnÃ©e ci-dessus avec des parallÃ©lÃ©pipÃ¨des rectangulaires et un Ã©clairage global, mais juste quelques triangles devant la camÃ©ra). Et le succÃ¨s m'attendait! Cependant, le test de coplanaritÃ©, que j'ai implÃ©mentÃ© pour vÃ©rifier l'exactitude, a nÃ©cessitÃ© plusieurs opÃ©rations de produits scalaires et vectoriels, ce qui a commencÃ© Ã  normaliser les nombres. Par consÃ©quent, mÃªme si je savais que le rendu Ã©tait prÃ©cis, je ne pouvais pas le Â«prouverÂ» expÃ©rimentalement. Quelle ironie. En gÃ©nÃ©ral, cela signifie que 64 bits Ã©taient suffisants pour plusieurs triangles, mais des scÃ¨nes plus complexes s'effondreront toujours. Cependant, cela m'a fait rÃ©flÃ©chir Ã  une autre question: existe-t-il un algorithme qui peut Ãªtre utilisÃ© pour tester la coplanaritÃ©, basÃ© non pas sur des valeurs absolues, mais sur une arithmÃ©tique modulaire? Je supposeen arithmÃ©tique modulaire, les nombres rationnels ne devraient pas Â«exploserÂ» en taille? Je n'ai pas eu le temps d'examiner tout cela et je ne suis pas un expert en thÃ©orie des nombres.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Racines carrÃ©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la derniÃ¨re (deuxiÃ¨me) soirÃ©e de recherche, j'ai dÃ©cidÃ© de m'arrÃªter briÃ¨vement sur ce sujet et d'Ã©tudier de nouvelles informations. </font><font style="vertical-align: inherit;">Je voulais implÃ©menter la meilleure fonction de racine carrÃ©e possible pour les nombres rationnels. </font><font style="vertical-align: inherit;">Ma dÃ©cision naÃ¯ve actuelle ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mauvaise</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) a pris la racine carrÃ©e entiÃ¨re du numÃ©rateur (avec l'arrondissement correspondant), puis a fait de mÃªme avec le dÃ©nominateur. </font><font style="vertical-align: inherit;">Puisque la racine carrÃ©e d'une fraction est une fraction des racines carrÃ©es du numÃ©rateur et du dÃ©nominateur, en gÃ©nÃ©ral, cette approche donne des rÃ©sultats dÃ©cents, pas trop diffÃ©rents de la meilleure rÃ©ponse. </font><font style="vertical-align: inherit;">Mais il ne renvoie certainement pas la meilleure approximation rationnelle de la racine carrÃ©e d'un nombre rationnel. </font><font style="vertical-align: inherit;">Il effectue deux approximations au lieu d'une seule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai essayÃ© ce qui suit: Ã  la fin, nous recherchons ici deux entiers </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></b>  <b>y</b> , ,  <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/769/1eb/d9b/7691ebd9ba782aacba6bc480f13199a8.png"></div><br>          ()    (Â«Â» ,      ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/9db/7db/aaf9db7db7d1ee8300d090ea1e97535b.png"></div><br>  AprÃ¨s avoir recherchÃ© WikipÃ©dia, j'ai trouvÃ© que cette Ã©quation particuliÃ¨re est la soi-disant Â«Ã©quation de Pell modifiÃ©eÂ».  Il existe des algorithmes qui trouvent les plus petites valeurs <b>x</b> et <b>y</b> pour rÃ©soudre cette Ã©quation.  Malheureusement, mon attention s'est rapidement dÃ©placÃ©e vers d'autres mathÃ©matiques diophantiennes curieuses, et je n'ai procÃ©dÃ© Ã  la mise en Å“uvre d'aucun de ces algorithmes. <br><br><h3>  RÃ©duction plus efficace </h3><br>  Dans les derniÃ¨res minutes de la soirÃ©e, j'ai pensÃ© Ã  explorer l'idÃ©e d'utiliser plusieurs membres qui se combinent dans des opÃ©rateurs gÃ©omÃ©triques complexes, par exemple, dans un produit vectoriel.  Disons que le premier composant d'un produit vectoriel Ã©tait <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/4b5/c33/c844b5c33c70116474bbaa0c63273ad7.png"></div><br>  en supposant que sy = a / b, tz = c / d, ty = e / f, sz = g / h <br><br>  Cela signifie que maintenant je peux essayer de trouver des diviseurs communs, par exemple, entre a et d, ou e et h, et les utiliser pour une rÃ©duction prÃ©liminaire. <br><br>  J'ai eu une autre idÃ©e: si Ã  un moment donnÃ© la vitesse de rendu devient un problÃ¨me, vous pouvez complÃ¨tement dÃ©sactiver les Ã©tapes de recherche de GCD et appliquer uniquement la normalisation.  Une vÃ©rification rapide a montrÃ© que dans ce cas, les rendus d'image restent toujours acceptables et fonctionnent bien Ã  une vitesse beaucoup plus Ã©levÃ©e.  Cependant, dans ce cas, bien sÃ»r, nous obtenons moins de rÃ©sultats arithmÃ©tiquement prÃ©cis. <br><br>  Comme compromis, vous pouvez refuser de mettre en Å“uvre une procÃ©dure ou un schÃ©ma GCD, et utiliser Ã  la place quelque chose de mathÃ©matiquement simple, codÃ© en dur dans le code et efficace, dÃ©terminant la divisibilitÃ© uniquement par 2, 3 et 5. Bien que de cette faÃ§on, nous ne trouvions pas un nombre exhaustif de diviseurs, par en pratique, cela conduirait Ã  trouver un grand nombre d'abrÃ©viations.  Pensez-y - la divisibilitÃ© par 2 se produit trois fois plus souvent que la divisibilitÃ© par 7, et 20 fois plus souvent que la divisibilitÃ© par 41! <br><br><h2>  Conclusion </h2><br><hr><br>  AprÃ¨s cette expÃ©rience, j'ai commencÃ© Ã  croire qu'il est tout Ã  fait possible qu'une reprÃ©sentation des nombres soit basÃ©e sur des nombres rationnels, semblable Ã  ce que j'appelle la Â«fraction de ligne flottanteÂ».  Une reprÃ©sentation compatible avec les entiers et capable d'effectuer de nombreuses opÃ©rations en arithmÃ©tique exacte pour de nombreuses tÃ¢ches (Ã  condition que les donnÃ©es d'entrÃ©e soient prÃ©sentÃ©es sous une forme rationnelle).  La version 64 bits (1 | 6 | 57) a un grand potentiel, bien que la version 32 bits (1 | 5 | 26) crÃ©e dÃ©jÃ  des rendus intÃ©ressants. <br><br>  Si ce n'Ã©tait pas une expÃ©rience pour deux soirÃ©es, mais quelque chose de professionnel crÃ©Ã© dans un studio ou une entreprise, alors Ã  l'avenir, les mesures suivantes pourraient Ãªtre prises: <br><br>  * Obtenez un histogramme du nombre de pixels tracÃ©s avec prÃ©cision et pas exactement (en d'autres termes, la frÃ©quence d'exÃ©cution de normalisation) <br>  * Essayez d'implÃ©menter une rÃ©duction codÃ©e en dur sur les sÃ©parateurs 2, 3 et 5 et mesurez le pourcentage de pixels exacts perdus <br>  * Afficher la diffÃ©rence en pixels entre le rendu en virgule flottante et le rendu en virgule flottante fraction <br>  * Trouvez des faÃ§ons ingÃ©nieuses d'utiliser les valeurs inutilisÃ©es du format binaire "fractions de ligne flottante", par exemple, pour dÃ©signer Inf et NaN <br>  * ImplÃ©menter la dÃ©tection de NaN, Inf, underflow, overflow. <br><br>  Dans l'ensemble, c'Ã©tait une Ã©tude fascinante.  Au cours du processus, j'ai dÃ©couvert quelques surprises, j'ai trouvÃ© une petite invention et j'ai beaucoup appris sur l'Ã©quation de Pell, les racines carrÃ©es, le GCD, les mÃ©canismes internes x86_64, la fonction zÃªta de Riemann et certains autres aspects.  J'en suis trÃ¨s content! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448558/">https://habr.com/ru/post/fr448558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448544/index.html">Faisceaux en acier. Comment sont-ils formÃ©s</a></li>
<li><a href="../fr448546/index.html">UITableView tailles d'en-tÃªte et de pied de page automatiques avec AutoLayout</a></li>
<li><a href="../fr448548/index.html">La construction dans l'art: de Brueghel Ã  Vasya Lozhkin</a></li>
<li><a href="../fr448550/index.html">Ouverture du concours de rapport Ã  #PAYMENTSECURITY 2019</a></li>
<li><a href="../fr448552/index.html">ProLiant Series 100 - Le jeune frÃ¨re perdu</a></li>
<li><a href="../fr448560/index.html">Plan de transformation de l'IA: comment gÃ©rer une entreprise Ã  l'Ã¨re de l'IA?</a></li>
<li><a href="../fr448562/index.html">Google aide la police Ã  localiser des appareils Ã  proximitÃ© de scÃ¨nes de crime Ã  l'aide de donnÃ©es de localisation</a></li>
<li><a href="../fr448564/index.html">Le premier du groupe - le premier Ã  tomber: Ã©valuation des risques de leadership dans des groupes d'animaux auto-organisÃ©s</a></li>
<li><a href="../fr448570/index.html">Nous estimons le dÃ©bit du canal MIMO (l'algorithme de versement d'eau est inclus)</a></li>
<li><a href="../fr448572/index.html">La communication humaine devient un objet de luxe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>