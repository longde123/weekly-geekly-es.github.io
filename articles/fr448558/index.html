<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ö üà≤ ü¶ê Est-il possible de rendre des images r√©alistes sans nombres √† virgule flottante? üèáüèª üöë üîµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 

 "Que se passe-t-il si nous rempla√ßons les nombres √† virgule flottante par des nombres rationnels et essayons de rendre l'image?" 

 Je...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Est-il possible de rendre des images r√©alistes sans nombres √† virgule flottante?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448558/"><h2>  Pr√©sentation </h2><br><hr><br>  "Que se passe-t-il si nous rempla√ßons les nombres √† virgule flottante par des nombres rationnels et essayons de rendre l'image?" <br><br>  Je me suis pos√© cette question apr√®s avoir pens√© au tweet d'un chercheur et professeur d'infographie Morgan McGwire.  Il a expliqu√© √† quel point les √©tudiants en informatique sont surpris lorsqu'ils d√©couvrent pour la premi√®re fois que pour stocker les nombres √† virgule flottante familiers dans les ordinateurs modernes, des compromis doivent √™tre faits.  Et ces compromis rendent les t√¢ches simples difficiles, par exemple, v√©rifier si un point appartient √† un triangle.  Le probl√®me, bien s√ªr, est que la v√©rification de quatre points dans le m√™me plan (coplanarit√©) en utilisant un d√©terminant ou une sorte de multiplication vectorielle (mais en fait c'est la m√™me chose) ne donnera jamais une valeur exactement √©gale √† z√©ro, ce qui est requis ce sont des m√©thodes math√©matiques.  M√™me si les vrais calculs d'√™tre sur le m√™me plan √©taient exacts, les m√™mes compromis avec une pr√©cision de pr√®s de 1,0 donneraient la r√©ponse que les quatre points eux-m√™mes ne sont pas coplanaires. <br><br>  Cela a donn√© naissance √† l'id√©e en moi - si nous supposons que toutes les donn√©es de rendu entrantes (coordonn√©es des sommets, transformations 3D, etc.) √©taient d√©finies comme des nombres rationnels, alors elles cr√©eraient toutes les op√©rations, de la cr√©ation d'un rayon, en traversant la structure acc√©l√©ratrice jusqu'√† l'intersection les rayons avec des triangles ne sont que des nombres rationnels?  Si tel √©tait le cas, nous pourrions alors effectuer un test de coplanarit√© exactement!  Vous vous demandez peut-√™tre pourquoi une sc√®ne 3D exprim√©e en nombres rationnels ne devrait donner des r√©sultats qu'en nombres rationnels ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/c79/14b/a99c7914bc94ae608f4215c34cbe4f66.jpg"></div><br>  <i>Une sc√®ne simple, le trac√© de chemin dans lequel est effectu√© par l'arithm√©tique rationnelle.</i>  <i>Il utilise un syst√®me de <b>nombres √†</b> virgule flottante, pas un <b>nombre √†</b> virgule flottante.</i> <br><a name="habracut"></a><br>  Premi√®rement, un nombre rationnel est un nombre qui peut √™tre exprim√© comme le rapport de deux entiers, par exemple 1/2 ou 355/113.  Deuxi√®mement, les ¬´op√©rations de rendu normales¬ª, telles que les tests de bo√Æte englobante, la v√©rification de l'intersection d'un rayon avec un triangle, la r√©flexion d'un rayon, etc., sont bas√©es sur des produits vectoriels et scalaires, ainsi que sur la division scalaire (cela inclut transformation de coordonn√©es et inversion matricielle, quaternions, etc.), qui √† leur tour reposent sur quatre op√©rations de base: addition, soustraction, multiplication et division.  Lors de l'addition, de la soustraction, de la multiplication et de la division des nombres rationnels, des nombres rationnels sont √©galement obtenus.  Le math√©maticien dirait que de nombreux nombres rationnels forment un champ qui est ferm√© sous quatre op√©rations arithm√©tiques de base.  Pour nous, cela signifie que si nous adh√©rons √† des nombres exclusivement rationnels, nous pouvons r√©ellement passer des donn√©es d'entr√©e de la sc√®ne 3D √† une image enti√®rement rendue sans quitter le monde des nombres rationnels. <br><br>  Les exceptions √† la r√®gle ¬´les actions sur les nombres rationnels donnent des nombres rationnels¬ª sont les racines carr√©es et les fonctions trigonom√©triques / transcendantales.  Quant √† ce dernier, je dis toujours que si vous deviez effectuer des calculs trigonom√©triques dans les int√©rieurs g√©om√©triques de votre moteur de rendu, alors vous faites probablement quelque chose de mal (et j'ai montr√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment corriger les cas les plus standards</a> ).  En ce qui concerne les racines carr√©es, √† l'exception des sections coniques (sph√®res, cylindres, etc.) et de l'ombrage / DFOS / coloration, il n'est pas n√©cessaire de normaliser les rayons et la normale aux surfaces aussi souvent que d'habitude.  Il n'est certainement pas n√©cessaire de le faire pour cr√©er un rayon, son passage, son intersection, ses r√©flexions, etc.  Malheureusement, tr√®s souvent, je vois que les programmeurs normalisent les valeurs sans autre raison que "eh bien, je ne sais pas, je le fais pour pouvoir jouer en toute s√©curit√©."  En pratique, dans la partie du rendu o√π la g√©om√©trie est trac√©e, il est tr√®s rarement n√©cessaire de normaliser les valeurs, donc j'avais l'espoir qu'il serait possible de tracer toute la sc√®ne sans quitter le monde des nombres rationnels - c'est ce que j'appellerais le "rendu rationnel". <br><br>  Pour mettre cela en pratique, je dois cr√©er un syst√®me num√©rique bas√© sur des nombres rationnels qu'un ordinateur pourrait utiliser.  Ensuite, j'ai pu impl√©menter les algorithmes de tra√ßage de chemin habituels, calculer des images sans perte de pr√©cision, effectuer des v√©rifications de coplanarit√© qui ont des r√©ponses pr√©cises et rendre tous les √©tudiants √©tudiant l'infographie heureux. <br><br>  Cet article est une histoire de deux nuits de recherche sur le r√©alisme d'une telle id√©e.  Je vais parler des nombreux aspects que j'ai appris, de ce que j'ai trouv√© et de quelques surprises que j'ai d√©couvertes au cours du processus.  L'article est √©crit dans un ordre plus ou moins chronologique de mon travail.  De plus, il a √©t√© √©crit dans mon style inhabituellement informel et tr√®s peu scientifique (dont je suis fier).  L'image ci-dessus est une sorte de spoiler, mais lisez l'article √† la fin, car je vais parler du bon et du mauvais. <br><br><h2>  La pr√©paration </h2><br><hr><br>  La premi√®re chose que j'ai faite a √©t√© d'impl√©menter dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shadertoy un</a> traceur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">minimalement</a> limit√© pour une sc√®ne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extr√™mement simple</a> compos√©e d'un plan, d'une sph√®re, d'un parall√©l√©pip√®de rectangle et d'un triangle - les blocs de construction de v√©ritables moteurs de rendu.  Ensuite, j'ai copi√© le code dans un fichier C ++ et, apr√®s avoir apport√© quelques modifications mineures, je l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ai</a> compil√© √† l'aide de mon framework <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">piLibs</a> .  Donc, √† titre de comparaison, j'ai obtenu une image trac√©e rendue au processeur en utilisant des nombres r√©guliers selon la norme IEEE754 avec une virgule flottante.  J'ai √©galement supprim√© toute normalisation des rayons du code de trace, car, comme mentionn√© ci-dessus, aucune d'entre elles n'est r√©ellement n√©cessaire.  Permettez-moi de vous rappeler qu'une racine carr√©e est requise pour la normalisation et que les nombres rationnels ne sont pas conserv√©s lorsqu'elle est utilis√©e (la racine carr√©e d'un nombre rationnel n'est pas un nombre rationnel).  Un peu plus tard, nous verrons qu'appliquer des racines carr√©es, bien s√ªr, est toujours possible, je voulais juste rendre le code aussi math√©matiquement propre que possible pour voir jusqu'o√π je peux aller avec l'arithm√©tique exacte des nombres rationnels sans arrondir. <br><br>  La derni√®re √©tape pr√©paratoire - j'ai pris toutes les classes vec3, mat4x4 et autres classes d'alg√®bre / math√©matiques de base, puis je les ai modifi√©es pour qu'elles utilisent rationnel au lieu de flottant.  Comme ma structure rationnelle surcharge tous les op√©rateurs standard (add, sub, mul, div, inversion de signe, comparaisons, etc.), le remplacement s'est produit sans probl√®me.  J'ai rapidement impl√©ment√© les op√©rations habituelles restantes (abs, signe, mod, fract, floor, sqrt, etc.), ce qui √©tait th√©oriquement suffisant pour obtenir de beaux rendus rationnels. <br><br><h2>  Test 1 - La solution na√Øve </h2><br><hr><br>  Mais voyons √† quoi ressemblait cette premi√®re impl√©mentation.  Au d√©but, j'essaie toujours le plus simple, puis je regarde les r√©sultats.  Et la mani√®re la plus simple d'impl√©menter des valeurs rationnelles √©tait d'utiliser deux entiers.  Comme le nom de la section l'indique, ce ne sera pas ma d√©cision finale, mais pour la premi√®re tentative, c'√©tait une d√©cision raisonnable.  Ainsi, chaque nombre <b>x</b> doit √™tre repr√©sent√© comme le num√©rateur <b>N</b> et le d√©nominateur <b>D</b> , formant la valeur <b>N</b> / <b>D.</b>  La valeur <b>x</b> est approxim√©e par la meilleure paire <b>N</b> / <b>D</b> possible (dans la profondeur de bits sp√©cifi√©e), qui est la plus proche de la vraie valeur <b>x</b> .  J'ai d√©cid√© que les deux nombres doivent √™tre positifs, et le signe du nombre doit √™tre stock√© dans un bit s√©par√© afin de simplifier le travail et de se d√©barrasser des ambigu√Øt√©s, bien que ce ne soit pas tr√®s important.  √Ä ce stade, les num√©rateurs et les d√©nominateurs √©taient de type non sign√©.  Mais m√™me en s√©parant le signe, <b>N</b> / <b>D</b> avait beaucoup de redondance: par exemple, 1/4 et 7/28 d√©signent le m√™me nombre, mais ont des repr√©sentations binaires compl√®tement diff√©rentes.  Nous y reviendrons plus tard, mais pour l'instant, ne concentrons pas notre attention et voyons √† quoi ressemblent les quatre op√©rations arithm√©tiques de base sous cette forme rationnelle. <br><br>  Tout d'abord, notez que la soustraction de <b>a</b> - <b>b</b> est simplement l'addition de <b>a</b> et la valeur oppos√©e √† <b>b</b> , c'est-√†-dire <b>a</b> + ( <b>-b</b> ), o√π <b>-b</b> peut √™tre calcul√© en changeant simplement le signe de <b>b</b> .  De m√™me, diviser <b>a</b> / <b>b</b> √©quivaut √† multiplier <b>a</b> et l'inverse de <b>b</b> .  Ou, en d'autres termes, <b>a</b> / <b>b</b> = <b>a</b> ¬∑ (1 / <b>b</b> ), o√π (1 / <b>b</b> ) peut √™tre calcul√© en changeant simplement les places du num√©rateur <b>b <sub>n</sub></b> et du d√©nominateur <b>b <sub>d du</sub></b> nombre <b>b</b> .  Donc, voici la premi√®re propri√©t√© int√©ressante de l'arithm√©tique rationnelle - la division et la multiplication ont les m√™mes co√ªts, par cons√©quent, contrairement au rendu en virgule flottante habituel, dans lequel les divisions sont g√©n√©ralement √©vit√©es, retard√©es ou cach√©es sous les retards des demandes de texture lentes, il n'est pas n√©cessaire d'avoir peur de ces op√©rations en arithm√©tique rationnelle . <br><br>  Nous passons √† l'addition avec multiplication: nous savons que les valeurs oppos√©es et inverses sont trivialement simples √† calculer, nous obtenons donc: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20f/b96/9c6/20fb969c6d2d6ad899898575244a8d20.png"></div><br>  La pr√©servation des signes pendant la multiplication est triviale, c'est juste xor, car deux valeurs positives donnent un r√©sultat positif, ainsi que deux n√©gatives.  L'enregistrement d'un signe pour l'ajout est un processus plus compliqu√©, et pour une solution rapide, je l'ai impl√©ment√© √† travers trois branches (l'ajout est trivial si les signes <b>a</b> et <b>b</b> co√Øncident, mais lorsqu'ils ne correspondent pas, vous devez s√©lectionner un plus petit nombre et le soustraire du plus grand - dans l'article, je ne le fais pas Je vais d√©crire ces petits d√©tails plus en d√©tail, mais il suffit de disposer le code source quelque part). <br><br>  Je vais √©galement sauter l'impl√©mentation de fract () et floor ();  si vous d√©cidez d'essayer de les mettre en ≈ìuvre vous-m√™me, vous verrez leur simplicit√© et leur beaut√©.  Il convient √©galement de pr√™ter attention aux op√©rateurs de comparaison.  Apr√®s avoir pris soin des signes et en supposant que <b>a</b> et <b>b sont</b> positifs, nous obtenons <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/b9c/831/6e4b9c831e9b49215c939fedc88ee0cd.png"></div><br>  Il est important de noter ici que m√™me pour la comparaison, nous avons besoin de quelques op√©rations de multiplication, ce qui peut conduire √† la transition vers la taille de mot suivante et sera un peu plus faible. <br><br>  Enfin, nous regardons les racines carr√©es dans une section distincte, sachant que pour la plupart nous n'en avons pas besoin (sauf pour la sph√®re de ce premier test). <br><br>  Cela a suffi pour ex√©cuter le premier rendu et tracer la sc√®ne de test (plan + sph√®re + triangle + bo√Æte rectangulaire) pour voir ce qui en est sorti.  J'ai g√©n√©reusement utilis√© des nombres rationnels de 65 bits pour ce premier test, qui repr√©sente en fait une grande quantit√© de donn√©es (comparable au type de donn√©es "double"): 32 bits sont pris par le num√©rateur, 32 bits sont le d√©nominateur et un autre bit est le signe.  La premi√®re est l'image obtenue avec cette approche na√Øve, la seconde est l'image r√©alis√©e √† l'aide de nombres √† virgule flottante (r√©f√©rence): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/628/aca/f79628aca052bc725fa16953c8939a5c.png"></div><br>  <i>Nombres rationnels de 65 bits "na√Øfs"</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>R√©f√©rence en virgule flottante</i> <br><br>  Le r√©sultat √©tait plut√¥t mauvais, la bo√Æte et le triangle n'apparaissaient m√™me pas sur le rendu, et la sph√®re et le plan du sol √©taient trop bruyants.  Le probl√®me, bien s√ªr, √©tait que chaque fois que mes nombres rationnels effectuaient une op√©ration arithm√©tique de base √† l'une des √©tapes algorithmiques du rendu, le num√©rateur et le d√©nominateur devenaient de plus en plus incontr√¥lables, car une multiplication enti√®re √©tait utilis√©e.  Pensez √† ce qui suit: si les unit√©s de notre monde initial √©taient des m√®tres et que nous lierions la g√©om√©trie source (sommets et cam√©ra) √† une pr√©cision millim√©trique, alors seules les donn√©es source occuperaient un volume de 16 bits pour une sc√®ne plut√¥t petite.  Dans le m√™me temps, avec une r√©solution d'√©cran HD standard et un lissage 4X, les nombres de direction de faisceau rationnels n√©cessiteraient facilement 12 bits.  C'est-√†-dire que lors de la premi√®re interaction du faisceau et de la g√©om√©trie, l'op√©ration arithm√©tique la plus simple, utilisant les deux ensembles de donn√©es d'entr√©e, transformerait le r√©sultat en longueurs de 28 bits - assez pr√®s de la limite de 32 bits que je me suis fix√©e dans cette premi√®re impl√©mentation.  Et c'est avant m√™me d'avoir r√©alis√© le tout premier produit vectoriel ou scalaire.  Au moment o√π le produit scalaire est termin√©, le moteur de rendu aurait besoin de nombres rationnels de centaines de bits pour repr√©senter les nombres.  Bien s√ªr, c'est le pire des cas, mais le cas moyen serait proche de cela.  √âtant donn√© que je n'ai allou√© qu'une capacit√© de 32 bits pour le num√©rateur et le d√©nominateur, il est facile de comprendre √† quelle vitesse les valeurs d√©passent les limites de ce test - il n'est pas surprenant que presque rien ne soit visible, sauf pour le plan d'√©tage et une partie de la sph√®re. <br><br><h2>  Test 2 - R√©duction par le plus grand facteur commun </h2><br><hr><br>  Ensuite, j'ai am√©lior√© le syst√®me en utilisant la propri√©t√© que j'ai bri√®vement mentionn√©e ci-dessus - des nombres rationnels diff√©rents peuvent signifier le m√™me montant.  Et en fait, 6/12 est la m√™me valeur que 1/2, mais il utilise beaucoup plus de bits que le dernier.  Par cons√©quent, l'id√©e √©tait la suivante: si apr√®s chaque op√©ration arithm√©tique de base (ou apr√®s) j'extrayais tous les diviseurs communs du num√©rateur et des d√©nominateurs, et ram√®nerais la fraction √† sa forme la plus simple, alors je serais peut-√™tre en mesure de tout garder sous contr√¥le et de continuer les op√©rations plus longtemps avec une arithm√©tique exacte sans perte de pr√©cision.  Peut-√™tre pouvez-vous le faire assez longtemps pour obtenir des images propres et rendues?  Je vais prendre une petite digression pour montrer un autre exemple: 588/910 peut √™tre simplifi√© en 42/65, car 14 est un diviseur de 588 et 910. Mais pour stocker 42/65, √©videmment, moins de bits sont n√©cessaires que 588/910.  Trouver le plus grand nombre possible qui divise simultan√©ment les deux autres nombres peut √™tre fait en utilisant l'algorithme Great Common Divisor (GCD), des impl√©mentations efficaces que vous pouvez trouver n'importe o√π (je l'ai personnellement copi√© directement √† partir de Wikipedia et l'ai acc√©l√©r√© un peu en effectuant l'√©tape de num√©risation bits utilisant des op√©rations internes x64).  Ainsi, arm√©e de l'algorithme GCD, ma classe rationnelle devrait constamment simplifier les fractions g√©n√©r√©es au cours du processus de rendu.  Cela pourrait se faire de deux mani√®res: <br><br>  La premi√®re consiste √† convertir le r√©sultat interm√©diaire des op√©rateurs d'addition et de multiplication vers le type de donn√©es de bit suivant (dans ma solution na√Øve actuelle, c'est uin64_t), recherchez GCD dans ce type de donn√©es plus volumineux, puis r√©duisez le r√©sultat √† la longueur de bit d'origine (32).  La deuxi√®me fa√ßon consiste √† analyser comment <b>a <sub>n</sub></b> , <b>a <sub>d</sub></b> , <b>b <sub>n</sub></b> et <b>b <sub>d</sub></b> sont combin√©s les uns avec les autres dans les deux op√©rateurs arithm√©tiques et d'en extraire des diviseurs communs avant d'effectuer la multiplication.  La deuxi√®me approche a essentiellement √©limin√© le besoin de grandes longueurs de bits.  Sachant qu'il pourrait √™tre n√©cessaire de les utiliser de toute fa√ßon, j'ai d√©cid√© de choisir la premi√®re m√©thode, car elle √©tait plus facile √† mettre en ≈ìuvre et elle m'a permis d'acc√©l√©rer mon travail (la soir√©e s'envole tr√®s vite).  Apr√®s avoir fait tout cela, voyons quel rendu je peux cr√©er maintenant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb9/bc5/66f/eb9bc566f927cab52570332aff765d02.png"></div><br>  <i>Nombre rationnel de 65 bits r√©duit par GCD</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>R√©f√©rence en virgule flottante</i> <br><br>  Bien mieux!  Jusqu'√† pr√©sent, loin d'√™tre id√©al, bien s√ªr, mais cela semble prometteur.  J'ai fait appara√Ætre la bo√Æte et le triangle, et la sph√®re semble maintenant beaucoup plus volumineuse.  Cependant, un artefact dr√¥le est apparu dans le coin sup√©rieur droit, et les nombres rationnels pour de nombreux pixels d√©passent toujours les limites, ce qui conduit √† de nombreux points dans l'image.  Cependant, il convient de noter que pour certains (nombreux) pixels, j'ai commenc√© √† obtenir <b>des</b> r√©sultats <b>pr√©cis</b> et parfaits!  Autrement dit, le traceur a trouv√© des intersections math√©matiquement pr√©cises de points et de distances, ce qui √©tait la cause premi√®re de l'utilisation de nombres rationnels. <br><br>  Avant de passer √† l'√©tape suivante du processus de preuve de l'applicabilit√© des nombres rationnels, je souhaite bri√®vement m'arr√™ter et partager mes conclusions concernant la GCD et la r√©duction des nombres rationnels. <br><br>  La premi√®re d√©couverte est li√©e au volume de bits des nombres rationnels.  M√™me si je ne peux toujours pas rendre de belles images et cela est plus important que de se soucier de l'optimisation des volumes de donn√©es, et bien que cette premi√®re impl√©mentation utilisait toujours un grand nombre de bits (1 + 32 + 32), je pensais d√©j√† aux d√©chets mentionn√©s plus t√¥t bits sous forme de fractions en exc√®s.  En particulier, apr√®s avoir ajout√© une √©tape avec un GCD, les combinaisons de bits comme 2/4 ne sont plus applicables, car elles sont automatiquement r√©duites √† 1/2 avant d'√©crire dans un registre ou une variable.  Autrement dit, sur les 2 <sup>64</sup> combinaisons de bits qui pourraient √™tre le num√©rateur et le d√©nominateur, beaucoup restent inutilis√©es.  Et vous ne pouvez pas gaspiller des morceaux comme √ßa.  Ou est-ce possible?  Combien d'espace ai-je r√©ellement perdu?  J'ai fait une petite digression pour explorer cette question. <br><br><h2>  Digression - sur des nombres mutuellement premiers </h2><br><hr><br>  Les illustrations ci-dessous montrent l'utilisation de bits pour les nombres rationnels en 5/5 bits et 7/7 bits.  Les axes horizontal et vertical des graphiques repr√©sentent les valeurs du num√©rateur et du d√©nominateur de tous les nombres rationnels possibles ayant des num√©rateurs et des d√©nominateurs jusqu'√† 5 bits (31) et 7 bits (127).  Les pixels noirs sont des combinaisons inutilis√©es et les pixels blancs sont des fractions utilis√©es.  Par exemple, toute la diagonale est noire, √† l'exception du pixel 1/1, car toutes les fractions de la forme n / n sont r√©duites √† 1/1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6c/f08/b9d/c6cf08b9df8d1adecee7836e92a228be.png"><br><br>  <i>Utilisation de bits pour 5/5 rationnel</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16e/79b/24b/16e79b24b234907f082af70a013ae971.png"><br><br>  <i>Utilisation de bits pour 7/7 rationnel</i> <br><br>  Si vous comptez les pixels, comme je l'ai fait, vous pouvez rapidement comprendre que la proportion de pixels utiles avec une augmentation du nombre de bits tend √† 60,8%.  Une petite recherche en ligne m'a montr√© que ce rapport se r√©v√®le √™tre exactement 6 / œÄ <sup>2</sup> , car c'est aussi la probabilit√© d'√™tre relativement premier (n'ayant pas de diviseurs communs) pour deux nombres al√©atoires.  Vous pouvez demander, d'o√π vient le pi?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'av√®re que ¬´six par pi au carr√©¬ª est une valeur √©gale √† l'unit√© divis√©e par la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction z√™ta de Riemann</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calcul√©e au point 2, 1 / Œ∂ (2). Cela ne devrait pas nous surprendre beaucoup, car la fonction z√™ta de Riemann appara√Æt souvent dans des probl√®mes impliquant des nombres premiers et mutuellement premiers.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quoi qu'il en soit, √† mon avis rationnel, j'ai gaspill√© environ 40% des combinaisons de bits. Et m√™me si cela semble √™tre un grand nombre, j'ai d√©cid√© de le regarder comme s'il √©tait en fait un peu moins ... gr√¢ce auquel je n'ai pas pu √™tre tr√®s contrari√©. Dans cet esprit, j'ai d√©cid√© de passer √† autre chose, en utilisant d'autres approches compl√®tement diff√©rentes, au lieu d'essayer d'optimiser ce probl√®me localement. Cependant, n√©anmoins, j'ai bri√®vement appris sur les arbres Stern-Brokaw et Calkin-Wilf, ce qui pourrait me permettre d'utiliser pleinement tous les bits disponibles, mais l'intervalle de valeurs obtenues avec leur aide est tr√®s petit, j'ai donc rapidement abandonn√© cette id√©e et je suis pass√© √† autre chose. Je pense qu'√† ce stade, je dois exprimer ma gratitude envers </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikip√©dia en</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tant que source constante de mes connaissances.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenons √† l'analyse de ce que nous avons obtenu: je peux rendre des images avec des distorsions, mais cela d√©pend beaucoup de la distribution des nombres premiers dans les calculs. Cela d√©pend de ces nombres premiers si l'algorithme GCD peut simplifier l'expression - d√®s qu'un nombre premier ou un multiple tombe dans l'un des nombres de rendu (vecteurs, scalaires, matrices), il "pollue" tous les nombres qui le suivent dans d'autres manipulations arithm√©tiques, et y demeure pour toujours. Par cons√©quent, progressivement tout est garanti pour commencer √† cro√Ætre, ce n'est qu'une question de temps. En plus du fait que cela est in√©vitable, il est √©galement n√©cessaire, car ce sont des diviseurs mutuellement simples qui portent des informations sur la valeur d'un nombre. Mais en m√™me temps, les grands nombres premiers cassent tout tr√®s rapidement. Il y a donc un conflit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re chose √† noter est que j'utilisais toujours deux fois plus de bits que le nombre √† virgule flottante standard, donc il n'y a aucun avantage r√©el jusqu'ici. </font><font style="vertical-align: inherit;">Bien s√ªr, j'ai essay√© d'utiliser des nombres rationnels 16/16 bits, ce qui serait une comparaison plus honn√™te avec les vraies exigences de l'arithm√©tique √† virgule flottante, mais avec une pr√©cision de 16/16, le syst√®me que j'ai √©crit avec le num√©rateur + d√©nominateur + GCD a cr√©√© des images compl√®tement illisibles.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test 3 - Normalisation des nombres rationnels </font></font></h2><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, √† ce stade, j'avais besoin de quelque chose de vraiment significatif. Il semblait que pour emp√™cher les nombres de sortir des limites, il fallait commencer √† les couper et √† perdre en pr√©cision. Toute mon exp√©rience a commenc√© avec l'id√©e de rechercher </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rendu </font><b><font style="vertical-align: inherit;">pr√©cis</font></b><font style="vertical-align: inherit;"> , mais √† ce moment-l√†, j'ai senti que j'√©tais pr√™t √† abandonner cette id√©e et continuer √† explorer d'autres domaines, ne serait-ce que pour le plaisir, et voir √† quoi cela me m√®nerait (l'id√©e initiale stimulant le processus de recherche "C'est exactement l'id√©e de commencer le processus, et apr√®s cela, vous vous retrouvez souvent dans un endroit compl√®tement inattendu. Ou, comme John Cleese l'a dit une fois, les mauvaises id√©es peuvent conduire √† de bonnes id√©es, le processus cr√©atif n'est pas toujours toujours edovatelnostyu ou logiquement vraie progression des √©tapes).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quoi qu'il en soit, j'ai d√©cid√© de v√©rifier ce qui arriverait aux rendus si je prot√©geais en quelque sorte le num√©rateur et le d√©nominateur des d√©bordements. La mani√®re la plus simple serait de d√©caler le num√©rateur et le d√©nominateur, si n√©cessaire, d'un nombre suffisant de bits vers la droite, jusqu'√† ce qu'ils r√©apparaissent dans l'espace binaire qui leur est allou√©. En fait, cela signifie une division enti√®re du num√©rateur et du d√©nominateur par une valeur, ce qui signifie que la valeur du nombre reste </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">approximativement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inchang√©e. Et ici, je me suis √©cart√© du but initial de l'exp√©rience.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ma premi√®re impl√©mentation, j'ai regard√© le nombre de bits n√©cessaires pour le num√©rateur et le d√©nominateur, pris le maximum pour les deux et d√©cal√© les deux par ce nombre de bits (arrondi √† l'entier le plus proche). </font><font style="vertical-align: inherit;">Lorsque cela a √©t√© impl√©ment√© dans les op√©rateurs d'addition et de multiplication, tout a commenc√© √† sembler tout √† fait acceptable:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/c9d/8db/912c9d8dbc165e2aa14843cb3b3ccd12.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombres rationnels 65 bits r√©duits par GCD et normalisation</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Norme √† virgule flottante</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puisque tout semblait plut√¥t bien, √† ce stade, j'ai proc√©d√© √† la r√©solution du probl√®me d'une grande quantit√© de bits utilis√©s dans l'impl√©mentation actuelle. </font><font style="vertical-align: inherit;">J'ai essay√© d'utiliser 16/16 (33 bits) au lieu de 32/32 (65 bits), et les images se sont r√©v√©l√©es √©tonnamment bonnes! </font><font style="vertical-align: inherit;">J'ai encore vu que sur certains bords de la sph√®re il y a de petits trous, et dans la figure de la texture du triangle il y a de petits trous. </font><font style="vertical-align: inherit;">Mais ce n'est pas mauvais pour des quantit√©s suffisamment proches des nombres √† virgule flottante. </font><font style="vertical-align: inherit;">Cela m'a donn√© de l'√©nergie pour apprendre de nouvelles id√©es.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test 4 - Slash flottant </font></font></h2><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, j'ai d√©cid√© de me distraire et d'arr√™ter de chercher des excuses - si je veux trouver quelque chose d'int√©ressant pour le rendu en nombres rationnels, alors ils devraient occuper 32 bits et pas plus. Il vaut mieux trouver une bonne id√©e ou s'arr√™ter, et s'arr√™ter l√† (c'√©tait au d√©but de la deuxi√®me soir√©e d'exp√©riences).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au d√©but, je pensais que cela valait la peine de s'en tenir aux id√©es de GCD et de normalisation, mais il √©tait plus sage d'aborder le stockage et l'utilisation des bits. La premi√®re chose qui m'est venue √† l'esprit est que m√™me si le num√©rateur et le d√©nominateur peuvent devenir volumineux, cela ne se produit souvent pas. Ou, du moins, cela ne se produit pas simultan√©ment. Par cons√©quent, lorsque le num√©rateur est petit, vous pouvez laisser le d√©nominateur √™tre grand et vice versa. Les bits inutilis√©s de l'une des deux valeurs enti√®res peuvent √™tre utilis√©s pour repr√©senter des valeurs plus grandes. Puis je me suis rendu compte que de la m√™me mani√®re, un nombre √† virgule flottante est essentiellement un format √† virgule fixe, o√π le point ¬´fixe¬ª est rendu variable. Je peux prendre mes nombres rationnels et √©galement faire la disposition des bits de la variable de fraction de fraction. Autrement dit, il n'est pas difficile de d√©finir la fraction sur 16/16, mais de permettre √† la m√™me variable 32 bits d'√™tre parfois 16/16,et parfois 5/27 ou 13/19, au besoin.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela valait la peine de v√©rifier. </font><font style="vertical-align: inherit;">Quoi qu'il en soit, quelques lignes de code d'emballage / d√©ballage dans les setters et les getters internes peuvent √™tre √©crites rapidement. </font><font style="vertical-align: inherit;">Le sch√©ma le plus logique pour moi semblait 1 | 5 | 26, c'est-√†-dire:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 bit: signe </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 bits: position de la ligne de fraction (B) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26 bits: donn√©es combin√©es num√©rateur et d√©nominateur; </font><font style="vertical-align: inherit;">le num√©rateur est le bit 26-B sup√©rieur, le d√©nominateur est le bit B inf√©rieur,</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o√π la barre de fraction (B) d√©termine la taille du d√©nominateur. </font><font style="vertical-align: inherit;">Par exemple, le nombre 7/3 sera √©crit comme</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/3 = 0 00010 000000000000000000000111 11, </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o√π le signe 0 signifie une valeur positive, la ligne de la fraction 2 d√©signe le d√©nominateur (num√©ro 3), qui n√©cessite 2 bits pour repr√©senter, et le reste des bits va au num√©rateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les lecteurs qui ont travaill√© avec la norme IEEE754 peuvent trouver cette observation famili√®re: la repr√©sentation binaire du d√©nominateur commence toujours par ¬´1¬ª, car le num√©ro de ligne de fraction le tronque toujours √† la repr√©sentation la plus courte. </font><font style="vertical-align: inherit;">Autrement dit, le premier bit du d√©nominateur est facultatif. </font><font style="vertical-align: inherit;">Dans ce cas, le nombre ¬´3¬ª ne peut √™tre repr√©sent√© que par la valeur binaire ¬´1¬ª et la valeur de la ligne de fraction ¬´1¬ª:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/3 = 0 00001 00000000000000000000001111 1 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette astuce m'a non seulement sauv√© un bit pr√©cieux, mais a √©galement un excellent effet secondaire: lorsque la valeur du trait de fraction est nulle, cela signifie naturellement en m√™me temps que le d√©nominateur est 1 et qu'aucun espace n'est n√©cessaire pour le stocker. Cela signifie que ma repr√©sentation rationnelle des nombres s'est av√©r√©e soudainement compl√®tement compatible avec la repr√©sentation enti√®re et l'arithm√©tique habituelles, jusqu'√† ce que les valeurs des nombres d√©passent 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est-√†-dire √† un seuil suffisamment grand. </font><font style="vertical-align: inherit;">Quelle merveilleuse surprise! </font><font style="vertical-align: inherit;">C'est-√†-dire que th√©oriquement, je peux utiliser exactement le m√™me type de donn√©es, ¬´rationnel¬ª, pour effectuer des op√©rations de rendu et d'ombrage standard, mais aussi effectuer toute la logique et les t√¢ches du flux de commandes dans le traceur de chemin - je n'ai plus besoin d'utiliser deux types de donn√©es, car cela se produit dans la plupart des moteurs de rendu ("int" et "float") et effectuez des conversions dans un sens et dans un autre! </font><font style="vertical-align: inherit;">Cependant, le temps √©tant compt√© pour moi, je n'ai pas chang√© tous les indices de boucle de ¬´int¬ª √† ¬´rationnel¬ª. </font><font style="vertical-align: inherit;">La soir√©e touchait √† sa fin, et je devais encore v√©rifier beaucoup de choses pour am√©liorer la qualit√© des rendus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir cr√©√© l'impl√©mentation, j'ai pu le v√©rifier:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcb/a9b/34d/fcba9b34d81aae413f1288e6dcfcdf9b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombres rationnels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fractionnaires</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 32 bits </font><font style="vertical-align: inherit;">(1 | 5 | 26)</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standard 32 bits flottant </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-point</font></font></b></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O-oh, eh bien! J'ai encore des artefacts dans la sph√®re, que je vais pour l'instant bl√¢mer pour ma mauvaise mise en ≈ìuvre de la racine carr√©e, mais la bo√Æte et le triangle sont devenus vraiment propres. Le nombre de pixels d'image r√©solus avec pr√©cision a √©galement augment√©. Je pense qu'en raison du fait qu'avant le d√©bordement du d√©nominateur ou du num√©rateur, plus de nombres ont le temps d'appara√Ætre, j'ai augment√© la probabilit√© que le GCD trouve des diviseurs communs et effectue une r√©duction. C'est-√†-dire que la ligne flottante de la fraction a non seulement augment√© l'intervalle des nombres repr√©sent√©s et a report√© le moment de normalisation (avec perte de pr√©cision) caus√©e par le d√©bordement, mais a √©galement franchi l'√©tape suivante dans l'am√©lioration de la qualit√© en augmentant la probabilit√© de r√©ductions.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, j'√©tais pr√™t √† effectuer un test plus s√©rieux (mais toujours exp√©rimental - le syst√®me est encore loin d'√™tre pr√™t √† fonctionner). </font><font style="vertical-align: inherit;">J'ai impl√©ment√© un traceur de chemin avec un ensemble minimal de fonctions (pas n√©cessairement physiquement pr√©cises ou m√™me en tenant compte de la physique) et cr√©√© une sc√®ne avec plusieurs parall√©l√©pip√®des rectangulaires et deux sources lumineuses, dont l'impl√©mentation de r√©f√©rence sur le GPU est ici: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.shadertoy.com/view/Xd2fzR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai √† nouveau converti la sc√®ne en framework C ++, supprim√© √† nouveau certaines normalisations de rayons inutiles et ex√©cut√© le rendu. </font><font style="vertical-align: inherit;">Voici ce que j'ai obtenu:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/e7d/951/5b9e7d951bbef194094a389017433a50.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombres rationnels </font><b><font style="vertical-align: inherit;">fractionnaires</font></b><font style="vertical-align: inherit;"> 32 bits</font></font><b><font style="vertical-align: inherit;"></font></b></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/58f/543/20d58f54338c93f88379f550faf52c51.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flottante de </font><font style="vertical-align: inherit;">32 bits standards </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Point</font></font></b></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wow, c'est vraiment bon! </font><font style="vertical-align: inherit;">Bien que les fuites de lumi√®re soient clairement visibles dans les coins o√π les bords du sol et du plafond sont connect√©s. </font><font style="vertical-align: inherit;">Regardez-les dans l'approximation: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/36d/404/72d/36d40472de509e4fe6a7520c7e6df5a4.png"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/9da/0d6/ffd9da0d613a076c0c624e5a9b2c15e9.png"><img src="https://habrastorage.org/getpro/habr/post_images/273/84b/a41/27384ba41a08f4771f8cf6c6cddd129d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elles sont peut-√™tre caus√©es par un probl√®me dans ma mise en ≈ìuvre de l'intersection d'un rayon et d'une bo√Æte rectangulaire, qui ne s'exprime qu'en nombres rationnels; </font><font style="vertical-align: inherit;">Je ne serais pas surpris. </font><font style="vertical-align: inherit;">Ou peut-√™tre que je suis tomb√© sur les limites de ce dont les nombres rationnels sont capables. </font><font style="vertical-align: inherit;">Quoi qu'il en soit, je suis tr√®s content. </font><font style="vertical-align: inherit;">De plus, j'ai d'autres changements et exp√©riences que je voulais tester pour le peu de temps restant:</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelques autres exp√©riences </font></font></h2><br><hr><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arithm√©tique pr√©cise en 64 bits </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'id√©e de l'arithm√©tique exacte ne peut √™tre r√©alis√©e ni en nombres rationnels na√Øfs 64 bits ni en nombres rationnels 32 bits (1 | 5 | 26) avec une fraction de ligne flottante. Et les nombres √† virgule flottante 64 bits d'une fraction fonctionneront-ils? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai rapidement impl√©ment√© des nombres rationnels 1 | 6 | 57 (m√™me si j'ai d√ª apprendre de nouveaux m√©canismes internes x64 pour d√©caler les bits). Ces 57 bits de num√©rateur / d√©nominateur ont permis de tracer un intervalle de distance beaucoup plus grand. J'ai vraiment √©t√© en </font><font style="vertical-align: inherit;">mesure de retracer la sc√®ne avec plusieurs triangles avec tout </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√©cis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arithm√©tique (pas la sc√®ne mentionn√©e ci-dessus avec des parall√©l√©pip√®des rectangulaires et un √©clairage global, mais juste quelques triangles devant la cam√©ra). Et le succ√®s m'attendait! Cependant, le test de coplanarit√©, que j'ai impl√©ment√© pour v√©rifier l'exactitude, a n√©cessit√© plusieurs op√©rations de produits scalaires et vectoriels, ce qui a commenc√© √† normaliser les nombres. Par cons√©quent, m√™me si je savais que le rendu √©tait pr√©cis, je ne pouvais pas le ¬´prouver¬ª exp√©rimentalement. Quelle ironie. En g√©n√©ral, cela signifie que 64 bits √©taient suffisants pour plusieurs triangles, mais des sc√®nes plus complexes s'effondreront toujours. Cependant, cela m'a fait r√©fl√©chir √† une autre question: existe-t-il un algorithme qui peut √™tre utilis√© pour tester la coplanarit√©, bas√© non pas sur des valeurs absolues, mais sur une arithm√©tique modulaire? Je supposeen arithm√©tique modulaire, les nombres rationnels ne devraient pas ¬´exploser¬ª en taille? Je n'ai pas eu le temps d'examiner tout cela et je ne suis pas un expert en th√©orie des nombres.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Racines carr√©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la derni√®re (deuxi√®me) soir√©e de recherche, j'ai d√©cid√© de m'arr√™ter bri√®vement sur ce sujet et d'√©tudier de nouvelles informations. </font><font style="vertical-align: inherit;">Je voulais impl√©menter la meilleure fonction de racine carr√©e possible pour les nombres rationnels. </font><font style="vertical-align: inherit;">Ma d√©cision na√Øve actuelle ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mauvaise</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) a pris la racine carr√©e enti√®re du num√©rateur (avec l'arrondissement correspondant), puis a fait de m√™me avec le d√©nominateur. </font><font style="vertical-align: inherit;">Puisque la racine carr√©e d'une fraction est une fraction des racines carr√©es du num√©rateur et du d√©nominateur, en g√©n√©ral, cette approche donne des r√©sultats d√©cents, pas trop diff√©rents de la meilleure r√©ponse. </font><font style="vertical-align: inherit;">Mais il ne renvoie certainement pas la meilleure approximation rationnelle de la racine carr√©e d'un nombre rationnel. </font><font style="vertical-align: inherit;">Il effectue deux approximations au lieu d'une seule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai essay√© ce qui suit: √† la fin, nous recherchons ici deux entiers </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></b>  <b>y</b> , ,  <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/769/1eb/d9b/7691ebd9ba782aacba6bc480f13199a8.png"></div><br>          ()    (¬´¬ª ,      ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/9db/7db/aaf9db7db7d1ee8300d090ea1e97535b.png"></div><br>  Apr√®s avoir recherch√© Wikip√©dia, j'ai trouv√© que cette √©quation particuli√®re est la soi-disant ¬´√©quation de Pell modifi√©e¬ª.  Il existe des algorithmes qui trouvent les plus petites valeurs <b>x</b> et <b>y</b> pour r√©soudre cette √©quation.  Malheureusement, mon attention s'est rapidement d√©plac√©e vers d'autres math√©matiques diophantiennes curieuses, et je n'ai proc√©d√© √† la mise en ≈ìuvre d'aucun de ces algorithmes. <br><br><h3>  R√©duction plus efficace </h3><br>  Dans les derni√®res minutes de la soir√©e, j'ai pens√© √† explorer l'id√©e d'utiliser plusieurs membres qui se combinent dans des op√©rateurs g√©om√©triques complexes, par exemple, dans un produit vectoriel.  Disons que le premier composant d'un produit vectoriel √©tait <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/4b5/c33/c844b5c33c70116474bbaa0c63273ad7.png"></div><br>  en supposant que sy = a / b, tz = c / d, ty = e / f, sz = g / h <br><br>  Cela signifie que maintenant je peux essayer de trouver des diviseurs communs, par exemple, entre a et d, ou e et h, et les utiliser pour une r√©duction pr√©liminaire. <br><br>  J'ai eu une autre id√©e: si √† un moment donn√© la vitesse de rendu devient un probl√®me, vous pouvez compl√®tement d√©sactiver les √©tapes de recherche de GCD et appliquer uniquement la normalisation.  Une v√©rification rapide a montr√© que dans ce cas, les rendus d'image restent toujours acceptables et fonctionnent bien √† une vitesse beaucoup plus √©lev√©e.  Cependant, dans ce cas, bien s√ªr, nous obtenons moins de r√©sultats arithm√©tiquement pr√©cis. <br><br>  Comme compromis, vous pouvez refuser de mettre en ≈ìuvre une proc√©dure ou un sch√©ma GCD, et utiliser √† la place quelque chose de math√©matiquement simple, cod√© en dur dans le code et efficace, d√©terminant la divisibilit√© uniquement par 2, 3 et 5. Bien que de cette fa√ßon, nous ne trouvions pas un nombre exhaustif de diviseurs, par en pratique, cela conduirait √† trouver un grand nombre d'abr√©viations.  Pensez-y - la divisibilit√© par 2 se produit trois fois plus souvent que la divisibilit√© par 7, et 20 fois plus souvent que la divisibilit√© par 41! <br><br><h2>  Conclusion </h2><br><hr><br>  Apr√®s cette exp√©rience, j'ai commenc√© √† croire qu'il est tout √† fait possible qu'une repr√©sentation des nombres soit bas√©e sur des nombres rationnels, semblable √† ce que j'appelle la ¬´fraction de ligne flottante¬ª.  Une repr√©sentation compatible avec les entiers et capable d'effectuer de nombreuses op√©rations en arithm√©tique exacte pour de nombreuses t√¢ches (√† condition que les donn√©es d'entr√©e soient pr√©sent√©es sous une forme rationnelle).  La version 64 bits (1 | 6 | 57) a un grand potentiel, bien que la version 32 bits (1 | 5 | 26) cr√©e d√©j√† des rendus int√©ressants. <br><br>  Si ce n'√©tait pas une exp√©rience pour deux soir√©es, mais quelque chose de professionnel cr√©√© dans un studio ou une entreprise, alors √† l'avenir, les mesures suivantes pourraient √™tre prises: <br><br>  * Obtenez un histogramme du nombre de pixels trac√©s avec pr√©cision et pas exactement (en d'autres termes, la fr√©quence d'ex√©cution de normalisation) <br>  * Essayez d'impl√©menter une r√©duction cod√©e en dur sur les s√©parateurs 2, 3 et 5 et mesurez le pourcentage de pixels exacts perdus <br>  * Afficher la diff√©rence en pixels entre le rendu en virgule flottante et le rendu en virgule flottante fraction <br>  * Trouvez des fa√ßons ing√©nieuses d'utiliser les valeurs inutilis√©es du format binaire "fractions de ligne flottante", par exemple, pour d√©signer Inf et NaN <br>  * Impl√©menter la d√©tection de NaN, Inf, underflow, overflow. <br><br>  Dans l'ensemble, c'√©tait une √©tude fascinante.  Au cours du processus, j'ai d√©couvert quelques surprises, j'ai trouv√© une petite invention et j'ai beaucoup appris sur l'√©quation de Pell, les racines carr√©es, le GCD, les m√©canismes internes x86_64, la fonction z√™ta de Riemann et certains autres aspects.  J'en suis tr√®s content! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448558/">https://habr.com/ru/post/fr448558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448544/index.html">Faisceaux en acier. Comment sont-ils form√©s</a></li>
<li><a href="../fr448546/index.html">UITableView tailles d'en-t√™te et de pied de page automatiques avec AutoLayout</a></li>
<li><a href="../fr448548/index.html">La construction dans l'art: de Brueghel √† Vasya Lozhkin</a></li>
<li><a href="../fr448550/index.html">Ouverture du concours de rapport √† #PAYMENTSECURITY 2019</a></li>
<li><a href="../fr448552/index.html">ProLiant Series 100 - Le jeune fr√®re perdu</a></li>
<li><a href="../fr448560/index.html">Plan de transformation de l'IA: comment g√©rer une entreprise √† l'√®re de l'IA?</a></li>
<li><a href="../fr448562/index.html">Google aide la police √† localiser des appareils √† proximit√© de sc√®nes de crime √† l'aide de donn√©es de localisation</a></li>
<li><a href="../fr448564/index.html">Le premier du groupe - le premier √† tomber: √©valuation des risques de leadership dans des groupes d'animaux auto-organis√©s</a></li>
<li><a href="../fr448570/index.html">Nous estimons le d√©bit du canal MIMO (l'algorithme de versement d'eau est inclus)</a></li>
<li><a href="../fr448572/index.html">La communication humaine devient un objet de luxe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>