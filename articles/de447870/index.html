<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüéì üì´ üê∂ Grundlagen der JavaScript-Engine: Prototypoptimierung. Teil 1 üéß üíõ üë®üèæ‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. Bis zum Start des Kurses "Sicherheit von Informationssystemen" bleibt immer weniger Zeit, daher teilen wir auch heute noch Ver√∂ffentlic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen der JavaScript-Engine: Prototypoptimierung. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/447870/">  Hallo an alle.  Bis zum Start des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Sicherheit von Informationssystemen"</a> bleibt immer weniger Zeit, daher teilen wir auch heute noch Ver√∂ffentlichungen, die dem Start dieses Kurses gewidmet sind.  Diese Ver√∂ffentlichung ist √ºbrigens eine Fortsetzung dieser beiden Artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûGrundlagen von JavaScript-Engines: Allgemeine Formulare und Inline-Caching.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1 "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">" Grundlagen von JavaScript-Engines: Allgemeine Formulare und Inline-Caching.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2 "</a> . <br><br>  Der Artikel beschreibt die wichtigsten Grundlagen.  Sie sind allen JavaScript-Engines gemeinsam und nicht nur dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V8</a> , an dem die Autoren arbeiten ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benedict</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matthias</a> ).  Als JavaScript-Entwickler kann ich sagen, dass ein tieferes Verst√§ndnis der Funktionsweise der JavaScript-Engine Ihnen dabei hilft, effizienten Code zu schreiben. <br><br><img src="https://habrastorage.org/webt/sn/lh/zx/snlhzxtpzzs0ynrlywt0hvbfafw.png"><a name="habracut"></a><br><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel haben</a> wir erl√§utert, wie JavaScript-Engines den Zugriff auf Objekte und Arrays mithilfe von Formularen und Inline-Caches optimieren.  In diesem Artikel werden wir uns mit der Optimierung von Pipeline-Kompromissen und der Beschleunigung des Zugriffs auf Prototyp-Eigenschaften befassen. <br><br><blockquote>  Hinweis: Wenn Sie lieber Pr√§sentationen als Artikel lesen m√∂chten, sehen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Video an</a> .  Wenn nicht, √ºberspringen Sie es und lesen Sie weiter. </blockquote><br><br>  <b>Optimierungs- und Kompromissstufen</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das letzte Mal haben</a> wir herausgefunden, dass alle modernen JavaScript-Engines tats√§chlich dieselbe Pipeline haben: <br><br><img src="https://habrastorage.org/webt/dv/ni/m_/dvnim_h74jp64e3w2hyxmm9h1tu.png"><br><br>  Wir haben auch festgestellt, dass es trotz der Tatsache, dass hochrangige Pipelines von Motor zu Motor √§hnlich aufgebaut sind, einen Unterschied in der Optimierungspipeline gibt.  Warum ist das so?  Warum haben einige Motoren mehr Optimierungsstufen als andere?  Es geht darum, einen Kompromiss zwischen einem schnellen √úbergang in die Phase der Codeausf√ºhrung oder einem etwas l√§ngeren Zeitaufwand f√ºr die Ausf√ºhrung des Codes mit optimaler Leistung einzugehen. <br><br><img src="https://habrastorage.org/webt/ry/m5/cv/rym5cvxm6b5pwiaibki4jrtjqdq.png"><br><br>  Der Interpreter kann schnell Bytecode generieren, aber Bytecode allein ist in Bezug auf die Geschwindigkeit nicht effizient genug.  Die Einbeziehung eines optimierenden Compilers in diesen Prozess nimmt eine gewisse Zeit in Anspruch, erm√∂glicht jedoch einen effizienteren Maschinencode. <br>  Werfen wir einen Blick darauf, wie der V8 damit umgeht.  Denken Sie daran, dass der Interpreter in V8 als Ignition bezeichnet wird und als der schnellste Interpreter unter den vorhandenen Engines gilt (in Bezug auf die Geschwindigkeit der Ausf√ºhrung von Rohbytecode).  Der Optimierungs-Compiler in V8 hei√üt TurboFan und generiert hochoptimierten Maschinencode. <br><br><img src="https://habrastorage.org/webt/tr/jx/d7/trjxd74glsh5mmj9swifxkqukfk.png"><br><br>  Der Kompromiss zwischen Startverz√∂gerung und Ausf√ºhrungsgeschwindigkeit ist der Grund, warum einige JavaScript-Engines es vorziehen, zwischen den Schritten zus√§tzliche Optimierungsstufen hinzuzuf√ºgen.  Zum Beispiel f√ºgt SpiderMonkey eine Baseline-Ebene zwischen seinem Interpreter und dem vollst√§ndig optimierenden IonMonkey-Compiler hinzu: <br><br><img src="https://habrastorage.org/webt/ey/ry/1w/eyry1w6rnodjaethbgmjhcfkjj4.png"><br><br>  Der Interpreter generiert schnell Bytecode, aber der Bytecode selbst ist relativ langsam.  Baseline generiert Code etwas l√§nger, bietet jedoch zur Laufzeit eine verbesserte Leistung.  Schlie√ülich verbringt der optimierende Compiler IonMonkey die meiste Zeit damit, Maschinencode zu generieren, aber dieser Code ist √§u√üerst effizient. <br>  Schauen wir uns ein konkretes Beispiel an und sehen, wie die Pipelines verschiedener Motoren mit diesem Problem umgehen.  Hier in der Hot-Loop wird der gleiche Code oft wiederholt. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++i) { result += i; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result);</code> </pre> <br><br>  V8 startet mit dem Starten des Bytecodes im Ignition-Interpreter.  Irgendwann stellt die Engine fest, dass der Code hei√ü ist, und startet die TurboFan-Schnittstelle, die Profildaten integriert und eine grundlegende Maschinendarstellung des Codes erstellt.  Anschlie√üend wird es zur weiteren Verbesserung in einem anderen Thread an den TurboFan-Optimierer gesendet. <br><br><img src="https://habrastorage.org/webt/gy/zs/fb/gyzsfbelxi0ffbra0x2t-r6tm90.png"><br><br>  W√§hrend der Optimierung f√ºhrt V8 weiterhin Code in Ignition aus.  Irgendwann, wenn das Optimierungsprogramm fertig ist und wir ausf√ºhrbaren Maschinencode erhalten haben, geht es sofort zur Ausf√ºhrungsphase √ºber. <br>  SpyderMonkey startet auch die Bytecode-Ausf√ºhrung im Interpreter.  Es gibt jedoch eine zus√§tzliche Baseline-Ebene, was bedeutet, dass der Hot-Code zuerst dorthin gesendet wird.  Der Baseline-Compiler generiert Baseline-Code im Hauptthread und setzt die Ausf√ºhrung am Ende seiner Generierung fort. <br><br><img src="https://habrastorage.org/webt/xe/4k/oy/xe4koybmve5b33fwgwef87b1a_u.png"><br><br>  Wenn der Baseline-Code seit einiger Zeit ausgef√ºhrt wird, startet SpiderMonkey schlie√ülich die IonMonkey-Schnittstelle (IonMonkey-Frontend) und f√ºhrt den Optimierer aus. Der Vorgang ist V8 sehr √§hnlich.  All dies funktioniert gleichzeitig in Baseline weiter, w√§hrend IonMonkey sich mit der Optimierung befasst.  Wenn der Optimierer seine Arbeit beendet hat, wird der optimierte Code anstelle des Baseline-Codes ausgef√ºhrt. <br><br>  Die Architektur von Chakra ist SpiderMonkey sehr √§hnlich, aber Chakra versucht, mehr Prozesse gleichzeitig auszuf√ºhren, um zu vermeiden, dass der Haupt-Thread blockiert wird.  Anstatt einen Teil des Compilers im Hauptthread auszuf√ºhren, kopiert Chakra den Bytecode und die Profildaten, die der Compiler ben√∂tigt, und sendet sie an den dedizierten Compilerprozess. <br><br><img src="https://habrastorage.org/webt/3n/8x/op/3n8xopdh2_b-iobjurabjd6vj7m.png"><br><br>  Wenn der generierte Code fertig ist, f√ºhrt die Engine diesen SimpleJIT-Code anstelle des Bytecodes aus.  Das gleiche passiert mit FullJIT.  Der Vorteil dieses Ansatzes besteht darin, dass die beim Kopieren auftretende Pause normalerweise viel k√ºrzer ist als beim Starten eines vollwertigen Compilers (Frontend).  Andererseits hat dieser Ansatz einen Nachteil.  Es liegt in der Tatsache, dass die Kopierheuristik einige Informationen √ºberspringen kann, die f√ºr die Optimierung erforderlich sind. Wir k√∂nnen also sagen, dass die Qualit√§t des Codes in gewissem Ma√üe beeintr√§chtigt wird, um die Arbeit zu beschleunigen. <br><br>  In JavaScriptCore arbeiten alle optimierenden Compiler vollst√§ndig parallel zur grundlegenden Ausf√ºhrung von JavaScript.  Es gibt keine Kopierphase.  Stattdessen beginnt der Hauptthread einfach mit dem Kompilieren in einem anderen Thread.  Compiler verwenden dann ein komplexes Sperrschema, um auf Profildaten vom Hauptthread zuzugreifen. <br><br><img src="https://habrastorage.org/webt/22/ih/lv/22ihlvsqxl_80pfo4qgivtksbqk.png"><br><br>  Der Vorteil dieses Ansatzes besteht darin, dass die Menge an M√ºll reduziert wird, die nach der Optimierung im Hauptthread auftritt.  Der Nachteil dieses Ansatzes besteht darin, dass komplexe Multithreading-Probleme und einige Blockierungskosten f√ºr verschiedene Vorg√§nge gel√∂st werden m√ºssen. <br>  Wir haben √ºber die Kompromisse zwischen der schnellen Codegenerierung bei laufendem Interpreter und der schnellen Codegenerierung mit dem optimierenden Compiler gesprochen.  Es gibt jedoch noch einen Kompromiss, der die Verwendung von Speicher betrifft.  Um dies zu veranschaulichen, habe ich ein einfaches JavaScript-Programm geschrieben, das zwei Zahlen hinzuf√ºgt. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><br>  Sehen Sie sich den Bytecode an, der vom Z√ºndinterpreter in V8 f√ºr die Add-Funktion generiert wird. <br><br><pre> <code class="javascript hljs">StackCheck Ldar a1 Add a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] Return</code> </pre> <br><br>  Machen Sie sich keine Sorgen um den Bytecode, Sie m√ºssen ihn nicht lesen k√∂nnen.  Hierbei ist darauf zu achten, dass es <b>nur 4 Anweisungen</b> enth√§lt. <br>  Wenn der Code hei√ü wird, generiert TurboFan hochoptimierten Maschinencode, der im Folgenden dargestellt wird: <br><br><pre> <code class="javascript hljs">leaq rcx,[rip+<span class="hljs-number"><span class="hljs-number">0x0</span></span>] movq rcx,[rcx<span class="hljs-number"><span class="hljs-number">-0x37</span></span>] testb [rcx+<span class="hljs-number"><span class="hljs-number">0xf</span></span>],<span class="hljs-number"><span class="hljs-number">0x1</span></span> jnz CompileLazyDeoptimizedCode push rbp movq rbp,rsp push rsi push rdi cmpq rsp,[r13+<span class="hljs-number"><span class="hljs-number">0xe88</span></span>] jna StackOverflow movq rax,[rbp+<span class="hljs-number"><span class="hljs-number">0x18</span></span>] test al,<span class="hljs-number"><span class="hljs-number">0x1</span></span> jnz Deoptimize movq rbx,[rbp+<span class="hljs-number"><span class="hljs-number">0x10</span></span>] testb rbx,<span class="hljs-number"><span class="hljs-number">0x1</span></span> jnz Deoptimize movq rdx,rbx shrq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rcx,rax shrq rcx, <span class="hljs-number"><span class="hljs-number">32</span></span> addl rdx,rcx jo Deoptimize shlq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rax,rdx movq rsp,rbp pop rbp ret <span class="hljs-number"><span class="hljs-number">0x18</span></span></code> </pre> <br><br>  Es gibt wirklich viele Teams hier, besonders im Vergleich zu den vier, die wir im Bytecode gesehen haben.  Im Allgemeinen ist der Bytecode viel umfangreicher als der Maschinencode und insbesondere der optimierte Maschinencode.  Der Bytecode hingegen wird vom Interpreter ausgef√ºhrt, w√§hrend der optimierte Code direkt vom Prozessor ausgef√ºhrt werden kann. <br>  Dies ist einer der Gr√ºnde, warum JavaScript-Engines nicht einfach ‚Äûalles optimieren‚Äú.  Wie wir bereits gesehen haben, nimmt das Generieren von optimiertem Maschinencode viel Zeit in Anspruch und erfordert daher mehr Speicher. <br><br><img src="https://habrastorage.org/webt/dn/h5/sm/dnh5smq1qva1g8udg583xeve85y.png"><br><br>  <b>Zusammenfassend:</b> Der Grund, warum JavaScript-Engines unterschiedliche Optimierungsstufen aufweisen, besteht darin, einen Kompromiss zwischen der schnellen Codegenerierung mit dem Interpreter und der schnellen Codegenerierung mit dem optimierenden Compiler zu finden.  Durch Hinzuf√ºgen weiterer Optimierungsstufen k√∂nnen Sie fundiertere Entscheidungen treffen, basierend auf den Kosten f√ºr zus√§tzliche Komplexit√§t und Overhead w√§hrend der Ausf√ºhrung.  Dar√ºber hinaus besteht ein Kompromiss zwischen Optimierungsgrad und Speichernutzung.  Aus diesem Grund versuchen JavaScript-Engines, nur Hot-Funktionen zu optimieren. <br><br>  <b>Optimieren Sie den Zugriff auf Prototypeneigenschaften</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das letzte Mal haben</a> wir dar√ºber gesprochen, wie JavaScript-Engines das Laden von Objekteigenschaften mithilfe von Formularen und Inline-Caches optimieren.  Denken Sie daran, dass die Engines die Formen von Objekten getrennt von den Werten des Objekts speichern. <br><br><img src="https://habrastorage.org/webt/mu/-x/t4/mu-xt4rt-iqzzutk8zaayg33acw.png"><br><br>  Mit Formularen k√∂nnen Sie die Optimierung mithilfe von Inline-Caches oder abgek√ºrzten ICs verwenden.  Bei der Zusammenarbeit k√∂nnen Formulare und ICs den wiederholten Zugriff auf Eigenschaften an derselben Stelle in Ihrem Code beschleunigen. <br><br><img src="https://habrastorage.org/webt/1i/sb/bh/1isbbh_xagsaucfsy5vjhmva1gs.png"><br><br>  So ging der erste Teil der Ver√∂ffentlichung zu Ende, und im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Teil</a> finden Sie Informationen zu Klassen und Prototypenprogrammierung.  Traditionell warten wir auf Ihre Kommentare und st√ºrmischen Diskussionen und laden Sie zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offenen T√ºr</a> in den Kurs "Sicherheit von Informationssystemen" ein. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447870/">https://habr.com/ru/post/de447870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447856/index.html">Wie man ein Fenster ohne Pairing verkauft oder wie wichtig es ist, sich vor der Entwicklung einer Site zu positionieren</a></li>
<li><a href="../de447860/index.html">Thermodynamik von Schwarzen L√∂chern</a></li>
<li><a href="../de447862/index.html">Cisco Live 2019 EMEA. Technische Sitzungen: Externe Vereinfachung mit interner Komplikation</a></li>
<li><a href="../de447864/index.html">Nachrichten der Woche: Hauptereignisse in IT und Wissenschaft</a></li>
<li><a href="../de447868/index.html">Unterwasser-Ultraschall-Entfernungsmesser-Modul. Teil zwei</a></li>
<li><a href="../de447872/index.html">Alienware M15: Kompakter Gaming-Laptop mit umfassenden Upgrade-Optionen</a></li>
<li><a href="../de447874/index.html">Informationsentropie des Chaos</a></li>
<li><a href="../de447876/index.html">Alles ist sehr schlecht oder eine neue Art der Verkehrs√ºberwachung</a></li>
<li><a href="../de447878/index.html">√úberpr√ºfen von rdesktop und xrdp mit PVS-Studio</a></li>
<li><a href="../de447880/index.html">Validierung von rdesktop und xrdp mit dem PVS-Studio Analyzer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>