<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🎓 📫 🐶 Grundlagen der JavaScript-Engine: Prototypoptimierung. Teil 1 🎧 💛 👨🏾‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. Bis zum Start des Kurses "Sicherheit von Informationssystemen" bleibt immer weniger Zeit, daher teilen wir auch heute noch Veröffentlic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen der JavaScript-Engine: Prototypoptimierung. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/447870/">  Hallo an alle.  Bis zum Start des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Sicherheit von Informationssystemen"</a> bleibt immer weniger Zeit, daher teilen wir auch heute noch Veröffentlichungen, die dem Start dieses Kurses gewidmet sind.  Diese Veröffentlichung ist übrigens eine Fortsetzung dieser beiden Artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Grundlagen von JavaScript-Engines: Allgemeine Formulare und Inline-Caching.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1 "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">" Grundlagen von JavaScript-Engines: Allgemeine Formulare und Inline-Caching.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2 "</a> . <br><br>  Der Artikel beschreibt die wichtigsten Grundlagen.  Sie sind allen JavaScript-Engines gemeinsam und nicht nur dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V8</a> , an dem die Autoren arbeiten ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benedict</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matthias</a> ).  Als JavaScript-Entwickler kann ich sagen, dass ein tieferes Verständnis der Funktionsweise der JavaScript-Engine Ihnen dabei hilft, effizienten Code zu schreiben. <br><br><img src="https://habrastorage.org/webt/sn/lh/zx/snlhzxtpzzs0ynrlywt0hvbfafw.png"><a name="habracut"></a><br><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel haben</a> wir erläutert, wie JavaScript-Engines den Zugriff auf Objekte und Arrays mithilfe von Formularen und Inline-Caches optimieren.  In diesem Artikel werden wir uns mit der Optimierung von Pipeline-Kompromissen und der Beschleunigung des Zugriffs auf Prototyp-Eigenschaften befassen. <br><br><blockquote>  Hinweis: Wenn Sie lieber Präsentationen als Artikel lesen möchten, sehen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Video an</a> .  Wenn nicht, überspringen Sie es und lesen Sie weiter. </blockquote><br><br>  <b>Optimierungs- und Kompromissstufen</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das letzte Mal haben</a> wir herausgefunden, dass alle modernen JavaScript-Engines tatsächlich dieselbe Pipeline haben: <br><br><img src="https://habrastorage.org/webt/dv/ni/m_/dvnim_h74jp64e3w2hyxmm9h1tu.png"><br><br>  Wir haben auch festgestellt, dass es trotz der Tatsache, dass hochrangige Pipelines von Motor zu Motor ähnlich aufgebaut sind, einen Unterschied in der Optimierungspipeline gibt.  Warum ist das so?  Warum haben einige Motoren mehr Optimierungsstufen als andere?  Es geht darum, einen Kompromiss zwischen einem schnellen Übergang in die Phase der Codeausführung oder einem etwas längeren Zeitaufwand für die Ausführung des Codes mit optimaler Leistung einzugehen. <br><br><img src="https://habrastorage.org/webt/ry/m5/cv/rym5cvxm6b5pwiaibki4jrtjqdq.png"><br><br>  Der Interpreter kann schnell Bytecode generieren, aber Bytecode allein ist in Bezug auf die Geschwindigkeit nicht effizient genug.  Die Einbeziehung eines optimierenden Compilers in diesen Prozess nimmt eine gewisse Zeit in Anspruch, ermöglicht jedoch einen effizienteren Maschinencode. <br>  Werfen wir einen Blick darauf, wie der V8 damit umgeht.  Denken Sie daran, dass der Interpreter in V8 als Ignition bezeichnet wird und als der schnellste Interpreter unter den vorhandenen Engines gilt (in Bezug auf die Geschwindigkeit der Ausführung von Rohbytecode).  Der Optimierungs-Compiler in V8 heißt TurboFan und generiert hochoptimierten Maschinencode. <br><br><img src="https://habrastorage.org/webt/tr/jx/d7/trjxd74glsh5mmj9swifxkqukfk.png"><br><br>  Der Kompromiss zwischen Startverzögerung und Ausführungsgeschwindigkeit ist der Grund, warum einige JavaScript-Engines es vorziehen, zwischen den Schritten zusätzliche Optimierungsstufen hinzuzufügen.  Zum Beispiel fügt SpiderMonkey eine Baseline-Ebene zwischen seinem Interpreter und dem vollständig optimierenden IonMonkey-Compiler hinzu: <br><br><img src="https://habrastorage.org/webt/ey/ry/1w/eyry1w6rnodjaethbgmjhcfkjj4.png"><br><br>  Der Interpreter generiert schnell Bytecode, aber der Bytecode selbst ist relativ langsam.  Baseline generiert Code etwas länger, bietet jedoch zur Laufzeit eine verbesserte Leistung.  Schließlich verbringt der optimierende Compiler IonMonkey die meiste Zeit damit, Maschinencode zu generieren, aber dieser Code ist äußerst effizient. <br>  Schauen wir uns ein konkretes Beispiel an und sehen, wie die Pipelines verschiedener Motoren mit diesem Problem umgehen.  Hier in der Hot-Loop wird der gleiche Code oft wiederholt. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++i) { result += i; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result);</code> </pre> <br><br>  V8 startet mit dem Starten des Bytecodes im Ignition-Interpreter.  Irgendwann stellt die Engine fest, dass der Code heiß ist, und startet die TurboFan-Schnittstelle, die Profildaten integriert und eine grundlegende Maschinendarstellung des Codes erstellt.  Anschließend wird es zur weiteren Verbesserung in einem anderen Thread an den TurboFan-Optimierer gesendet. <br><br><img src="https://habrastorage.org/webt/gy/zs/fb/gyzsfbelxi0ffbra0x2t-r6tm90.png"><br><br>  Während der Optimierung führt V8 weiterhin Code in Ignition aus.  Irgendwann, wenn das Optimierungsprogramm fertig ist und wir ausführbaren Maschinencode erhalten haben, geht es sofort zur Ausführungsphase über. <br>  SpyderMonkey startet auch die Bytecode-Ausführung im Interpreter.  Es gibt jedoch eine zusätzliche Baseline-Ebene, was bedeutet, dass der Hot-Code zuerst dorthin gesendet wird.  Der Baseline-Compiler generiert Baseline-Code im Hauptthread und setzt die Ausführung am Ende seiner Generierung fort. <br><br><img src="https://habrastorage.org/webt/xe/4k/oy/xe4koybmve5b33fwgwef87b1a_u.png"><br><br>  Wenn der Baseline-Code seit einiger Zeit ausgeführt wird, startet SpiderMonkey schließlich die IonMonkey-Schnittstelle (IonMonkey-Frontend) und führt den Optimierer aus. Der Vorgang ist V8 sehr ähnlich.  All dies funktioniert gleichzeitig in Baseline weiter, während IonMonkey sich mit der Optimierung befasst.  Wenn der Optimierer seine Arbeit beendet hat, wird der optimierte Code anstelle des Baseline-Codes ausgeführt. <br><br>  Die Architektur von Chakra ist SpiderMonkey sehr ähnlich, aber Chakra versucht, mehr Prozesse gleichzeitig auszuführen, um zu vermeiden, dass der Haupt-Thread blockiert wird.  Anstatt einen Teil des Compilers im Hauptthread auszuführen, kopiert Chakra den Bytecode und die Profildaten, die der Compiler benötigt, und sendet sie an den dedizierten Compilerprozess. <br><br><img src="https://habrastorage.org/webt/3n/8x/op/3n8xopdh2_b-iobjurabjd6vj7m.png"><br><br>  Wenn der generierte Code fertig ist, führt die Engine diesen SimpleJIT-Code anstelle des Bytecodes aus.  Das gleiche passiert mit FullJIT.  Der Vorteil dieses Ansatzes besteht darin, dass die beim Kopieren auftretende Pause normalerweise viel kürzer ist als beim Starten eines vollwertigen Compilers (Frontend).  Andererseits hat dieser Ansatz einen Nachteil.  Es liegt in der Tatsache, dass die Kopierheuristik einige Informationen überspringen kann, die für die Optimierung erforderlich sind. Wir können also sagen, dass die Qualität des Codes in gewissem Maße beeinträchtigt wird, um die Arbeit zu beschleunigen. <br><br>  In JavaScriptCore arbeiten alle optimierenden Compiler vollständig parallel zur grundlegenden Ausführung von JavaScript.  Es gibt keine Kopierphase.  Stattdessen beginnt der Hauptthread einfach mit dem Kompilieren in einem anderen Thread.  Compiler verwenden dann ein komplexes Sperrschema, um auf Profildaten vom Hauptthread zuzugreifen. <br><br><img src="https://habrastorage.org/webt/22/ih/lv/22ihlvsqxl_80pfo4qgivtksbqk.png"><br><br>  Der Vorteil dieses Ansatzes besteht darin, dass die Menge an Müll reduziert wird, die nach der Optimierung im Hauptthread auftritt.  Der Nachteil dieses Ansatzes besteht darin, dass komplexe Multithreading-Probleme und einige Blockierungskosten für verschiedene Vorgänge gelöst werden müssen. <br>  Wir haben über die Kompromisse zwischen der schnellen Codegenerierung bei laufendem Interpreter und der schnellen Codegenerierung mit dem optimierenden Compiler gesprochen.  Es gibt jedoch noch einen Kompromiss, der die Verwendung von Speicher betrifft.  Um dies zu veranschaulichen, habe ich ein einfaches JavaScript-Programm geschrieben, das zwei Zahlen hinzufügt. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><br>  Sehen Sie sich den Bytecode an, der vom Zündinterpreter in V8 für die Add-Funktion generiert wird. <br><br><pre> <code class="javascript hljs">StackCheck Ldar a1 Add a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] Return</code> </pre> <br><br>  Machen Sie sich keine Sorgen um den Bytecode, Sie müssen ihn nicht lesen können.  Hierbei ist darauf zu achten, dass es <b>nur 4 Anweisungen</b> enthält. <br>  Wenn der Code heiß wird, generiert TurboFan hochoptimierten Maschinencode, der im Folgenden dargestellt wird: <br><br><pre> <code class="javascript hljs">leaq rcx,[rip+<span class="hljs-number"><span class="hljs-number">0x0</span></span>] movq rcx,[rcx<span class="hljs-number"><span class="hljs-number">-0x37</span></span>] testb [rcx+<span class="hljs-number"><span class="hljs-number">0xf</span></span>],<span class="hljs-number"><span class="hljs-number">0x1</span></span> jnz CompileLazyDeoptimizedCode push rbp movq rbp,rsp push rsi push rdi cmpq rsp,[r13+<span class="hljs-number"><span class="hljs-number">0xe88</span></span>] jna StackOverflow movq rax,[rbp+<span class="hljs-number"><span class="hljs-number">0x18</span></span>] test al,<span class="hljs-number"><span class="hljs-number">0x1</span></span> jnz Deoptimize movq rbx,[rbp+<span class="hljs-number"><span class="hljs-number">0x10</span></span>] testb rbx,<span class="hljs-number"><span class="hljs-number">0x1</span></span> jnz Deoptimize movq rdx,rbx shrq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rcx,rax shrq rcx, <span class="hljs-number"><span class="hljs-number">32</span></span> addl rdx,rcx jo Deoptimize shlq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rax,rdx movq rsp,rbp pop rbp ret <span class="hljs-number"><span class="hljs-number">0x18</span></span></code> </pre> <br><br>  Es gibt wirklich viele Teams hier, besonders im Vergleich zu den vier, die wir im Bytecode gesehen haben.  Im Allgemeinen ist der Bytecode viel umfangreicher als der Maschinencode und insbesondere der optimierte Maschinencode.  Der Bytecode hingegen wird vom Interpreter ausgeführt, während der optimierte Code direkt vom Prozessor ausgeführt werden kann. <br>  Dies ist einer der Gründe, warum JavaScript-Engines nicht einfach „alles optimieren“.  Wie wir bereits gesehen haben, nimmt das Generieren von optimiertem Maschinencode viel Zeit in Anspruch und erfordert daher mehr Speicher. <br><br><img src="https://habrastorage.org/webt/dn/h5/sm/dnh5smq1qva1g8udg583xeve85y.png"><br><br>  <b>Zusammenfassend:</b> Der Grund, warum JavaScript-Engines unterschiedliche Optimierungsstufen aufweisen, besteht darin, einen Kompromiss zwischen der schnellen Codegenerierung mit dem Interpreter und der schnellen Codegenerierung mit dem optimierenden Compiler zu finden.  Durch Hinzufügen weiterer Optimierungsstufen können Sie fundiertere Entscheidungen treffen, basierend auf den Kosten für zusätzliche Komplexität und Overhead während der Ausführung.  Darüber hinaus besteht ein Kompromiss zwischen Optimierungsgrad und Speichernutzung.  Aus diesem Grund versuchen JavaScript-Engines, nur Hot-Funktionen zu optimieren. <br><br>  <b>Optimieren Sie den Zugriff auf Prototypeneigenschaften</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das letzte Mal haben</a> wir darüber gesprochen, wie JavaScript-Engines das Laden von Objekteigenschaften mithilfe von Formularen und Inline-Caches optimieren.  Denken Sie daran, dass die Engines die Formen von Objekten getrennt von den Werten des Objekts speichern. <br><br><img src="https://habrastorage.org/webt/mu/-x/t4/mu-xt4rt-iqzzutk8zaayg33acw.png"><br><br>  Mit Formularen können Sie die Optimierung mithilfe von Inline-Caches oder abgekürzten ICs verwenden.  Bei der Zusammenarbeit können Formulare und ICs den wiederholten Zugriff auf Eigenschaften an derselben Stelle in Ihrem Code beschleunigen. <br><br><img src="https://habrastorage.org/webt/1i/sb/bh/1isbbh_xagsaucfsy5vjhmva1gs.png"><br><br>  So ging der erste Teil der Veröffentlichung zu Ende, und im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Teil</a> finden Sie Informationen zu Klassen und Prototypenprogrammierung.  Traditionell warten wir auf Ihre Kommentare und stürmischen Diskussionen und laden Sie zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offenen Tür</a> in den Kurs "Sicherheit von Informationssystemen" ein. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447870/">https://habr.com/ru/post/de447870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447856/index.html">Wie man ein Fenster ohne Pairing verkauft oder wie wichtig es ist, sich vor der Entwicklung einer Site zu positionieren</a></li>
<li><a href="../de447860/index.html">Thermodynamik von Schwarzen Löchern</a></li>
<li><a href="../de447862/index.html">Cisco Live 2019 EMEA. Technische Sitzungen: Externe Vereinfachung mit interner Komplikation</a></li>
<li><a href="../de447864/index.html">Nachrichten der Woche: Hauptereignisse in IT und Wissenschaft</a></li>
<li><a href="../de447868/index.html">Unterwasser-Ultraschall-Entfernungsmesser-Modul. Teil zwei</a></li>
<li><a href="../de447872/index.html">Alienware M15: Kompakter Gaming-Laptop mit umfassenden Upgrade-Optionen</a></li>
<li><a href="../de447874/index.html">Informationsentropie des Chaos</a></li>
<li><a href="../de447876/index.html">Alles ist sehr schlecht oder eine neue Art der Verkehrsüberwachung</a></li>
<li><a href="../de447878/index.html">Überprüfen von rdesktop und xrdp mit PVS-Studio</a></li>
<li><a href="../de447880/index.html">Validierung von rdesktop und xrdp mit dem PVS-Studio Analyzer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>