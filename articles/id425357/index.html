<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🎓 🤸🏻 😦 Bagaimana kami mengumpulkan tumpukan teknologi 12 lantai dan tidak menjadi gila ❎ 🥈 👩‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Appodeal adalah perusahaan yang terdiri dari ~ 100 orang yang bekerja di Moskow, San Francisco, Barnaul, Lutsk, Kirov, Barcelona, ​​dan sejak Juni 201...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami mengumpulkan tumpukan teknologi 12 lantai dan tidak menjadi gila</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/appodeal/blog/425357/">  Appodeal adalah perusahaan yang terdiri dari ~ 100 orang yang bekerja di Moskow, San Francisco, Barnaul, Lutsk, Kirov, Barcelona, ​​dan sejak Juni 2018, juga di Minsk. <br><br>  Kami memonetisasi aplikasi seluler dengan menampilkan iklan kepada pengguna.  Kami mulai dengan mediasi periklanan, tetapi tumpukan teknologi terus berkembang, sehingga produk lain dari industri Teknologi Iklan juga telah ditambahkan ke mediasi. <br><br><img src="https://habrastorage.org/webt/9x/iw/99/9xiw995blvp1eqlv6tc-hnfona0.jpeg" alt="gambar"><br><br>  Bagi mereka yang tidak terbiasa dengan Ad Tech, ini adalah bidang pekerjaan perusahaan teknologi yang bekerja di bidang periklanan.  Ketika Anda memberi tahu seseorang bahwa Anda bekerja di bidang periklanan mobile, orang sering bereaksi dengan skeptis - tampaknya, iklan “Azino Three Axes” yang menjengkelkan muncul di benak Anda.  Sebenarnya, ini hanyalah puncak gunung es, dan semua iklan "liar" ini tidak ada hubungannya dengan bisnis periklanan yang sebenarnya. <a name="habracut"></a>  Dan segmen seluler yang kami tangani telah lama melampaui segmen iklan di web: <br><br><img src="https://habrastorage.org/webt/3-/h8/ep/3-h8epbkxfz3_k8zk_foglrsnym.png" alt="gambar"><br><br><h4>  Mengapa mengintegrasikan iklan dalam aplikasi? </h4><br>  Tentu saja, banyak sumber daya dihabiskan untuk membuat aplikasi - dan pencipta / pemilik ingin waktu dan upaya yang dihabiskan untuk melunasi.  Pemilik aplikasi seluler yang memposting aplikasi mereka di App store / Google Play disebut penerbit atau penerbit.  Penerbit menerapkan model monetisasi yang berbeda, dari pembelian dalam aplikasi hingga monetisasi iklan.  Namun dari semua metode ini, hanya yang terakhir yang memungkinkan pengguna untuk tidak membayar untuk menggunakan aplikasi - dan ini memberikan cakupan pemirsa terbesar. <br><br>  Ya, jika ada terlalu banyak iklan, itu akan mengganggu semua orang dan berdampak buruk pada retensi pengguna.  Yang tentu saja tidak ada yang membutuhkan.  Oleh karena itu, mereka selalu berusaha mengintegrasikan iklan dengan bijak untuk mendapatkan uang maksimum pada aplikasi mereka dan pada saat yang sama tidak mengambil sepeser pun dari pengguna. <br><br><h4>  Bagaimana cara kerjanya? </h4><br>  Segera setelah penerbit memutuskan untuk menghasilkan uang melalui iklan, ia datang ke perusahaan yang dapat membuat tugas ini semudah mungkin baginya.  Bagaimana ini terjadi dengan Appodeal?  Setelah mendaftar di situs, kami mengintegrasikan aplikasinya dengan layanan kami.  Ini dilakukan melalui SDK klien, yang menghubungkan aplikasi ke bagian server dan berkomunikasi dengan bagian server melalui API. <br><br>  Jika Anda meminimalkan detail, maka tujuan interaksi dikurangi menjadi dua tahap: <br><br>  a.  Tentukan iklan mana yang akan ditampilkan sekarang; <br>  b.  Kirim informasi tentang iklan mana yang ditampilkan dan mana yang tidak, dan tampilkan dalam statistik. <br><br>  Saat ini, Appodeal melayani beberapa ribu aplikasi aktif yang menyediakan sekitar 400-450 juta tayangan iklan per hari, yang diterima sebagai tanggapan terhadap sekitar 1 miliar permintaan ke jaringan iklan (yang merupakan penyedia iklan).  Untuk membuat ini berfungsi, server kami melayani sekitar 125 ribu permintaan per detik, mis.  sekitar 10,8 miliar permintaan per hari. <br><br><img src="https://habrastorage.org/webt/-j/ci/bq/-jcibqnsphakjli4w0tnq5h7mre.png" alt="gambar"><br><br><h4>  Apa yang dibangun di atas ini? </h4><br>  Kami menggunakan berbagai teknologi untuk memberikan kecepatan, keandalan, dan pada saat yang sama fleksibilitas pengembangan dan dukungan.  Saat ini, kami sedang menulis kode dalam bahasa berikut: <br><br><ul><li>  / Ruby / Ruby on Rails + React.JS (front-end) /: Masih ada sebagian besar API dan seluruh komponen web yang dilihat pengguna dan karyawan kami </li><li>  / GoLang /: Memproses data statistik dalam jumlah besar dan tidak hanya </li><li>  / Scala /: Permintaan pemrosesan waktu nyata untuk bekerja dengan pertukaran pertukaran lalu lintas menggunakan protokol RTB (baca lebih lanjut tentang hal itu di akhir artikel) </li><li>  / Elixir / Phoenix /: Sebaliknya, bagian eksperimental.  Membangun beberapa layanan mikro untuk menangani beberapa statistik dan API. </li></ul><br><img src="https://habrastorage.org/webt/js/dj/qg/jsdjqgdn5x6skyabw52jkl7rokg.png" alt="gambar"><br><br><h4>  Mengapa awalnya Ruby dan Ruby on Rails? </h4><br>  Appodeal bersaing di segmennya dengan pemain yang sangat besar, jadi Anda harus beradaptasi dengan cepat terhadap perubahan pasar.  Seringkali ini terasa seperti perubahan pada roda mobil pada kecepatan 100 km / jam.  Ruby on Rails memungkinkan kami untuk bertahan dalam perlombaan dan mendapatkan pijakan di pasar cukup untuk menjadi pemimpin di segmennya.  Keuntungan utama Rails menurut kami: <br><br><ul><li>  Sejumlah besar pengembang yang memenuhi syarat </li><li>  Komunitas besar  Sejumlah besar solusi dan perpustakaan siap pakai </li><li>  Kecepatan memperkenalkan fitur baru dan mengubah / menghapus yang lama </li></ul><br><img src="https://habrastorage.org/webt/31/me/zl/31mezlqllshlsqmm0ultc0z7a7i.png" alt="gambar"><br><br>  Dari minus yang jelas: <br><br><ul><li>  Performa secara keseluruhan buruk.  Ini juga mempengaruhi kurangnya JIT (saat ini), kurangnya kemampuan untuk memparalelkan kode (jika Anda tidak memperhitungkan JRuby).  Sampai batas tertentu, ini tetap bisa ditanggung karena bottleneck biasanya database dan cache.  Apa yang kita lihat dalam gambar dari NewRelic: </li></ul><br><img src="https://habrastorage.org/webt/vz/uk/gh/vzukgh2_2ehcbmbf3mhikl-xsdc.png" alt="gambar"><br><br><ul><li>  Rail monolith tidak terpotong dengan baik pada layanan microser - mereka dipengaruhi oleh konektivitas tingkat tinggi antara logika bisnis dan logika akses data (ActiveRecord). </li></ul><br><h4>  Bagaimana data disimpan? </h4><br>  Kami memiliki banyak data.  Sangat  Kita berbicara tentang miliaran / puluhan / ratusan miliar catatan.  Karena datanya sangat berbeda, kami menyimpannya dengan cara yang berbeda.  Seharusnya tidak dibatasi dalam arsitektur untuk satu solusi, yang seharusnya universal.  Praktek menunjukkan bahwa, pertama, di Highload praktis tidak ada solusi universal.  Universalitas berarti indikator rata-rata (atau jauh lebih rendah dari rata-rata) untuk akses / kecepatan baca / ukuran penyimpanan data sebagai biaya untuk keserbagunaan ini.  Kedua, Anda perlu mencoba sesuatu yang baru setiap saat, bereksperimen dan mencari solusi yang tidak sepele untuk tugas-tugas tersebut.  Total: <br><br><ul><li>  / PostgreSQL /: Kami menyukai Postgre.  Kami menganggapnya sebagai solusi penyimpanan OLTP terbaik saat ini.  Data tentang pengguna, aplikasi, kampanye iklan, dan sebagainya disimpan di sana.  Kami menggunakan replikasi Primer-Replika.  Kami melakukan backup hanya pada liburan Natal, karena ini untuk para pengecut (lelucon). </li><li>  / VerticaDB /: Database berorientasi kolom.  Kami menggunakan untuk menyimpan miliaran catatan statistik.  Singkatnya, Vertika selama beberapa waktu dianggap sebagai solusi OLAP terbaik untuk menyimpan analitik.  Kerugian utama adalah harga (individu) yang besar untuk lisensi. </li><li>  / ClickHouse /: Juga basis data berorientasi kolom.  Beralih secara bertahap dengan VerticaDB.  Kami menganggap solusi OLAP terbaik saat ini.  Tidak bernilai sepeser pun.  Ini bekerja sangat cepat dan andal.  Perkecil utama adalah bahwa data tidak dapat dihapus dan diperbarui (kami akan membicarakan ini di artikel terpisah, jika ada yang tertarik). </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/0af/ee0/14e0afee039b7303db9d70c2f2f3892a.gif" alt="gambar"></div><br><blockquote>  Tidak ada!  Bagaimana tidak mungkin menghapus dan memodifikasi data ?! </blockquote><br><ul><li>  / Aerospike /: Penyimpanan nilai kunci NoSQL tercepat menurut kami.  Ada beberapa kekurangan, tetapi secara umum kami puas.  Bahkan ada grafik perbandingan untuk Aerospike di situs kinerja mereka dengan solusi lain: [Kapan menggunakan basis data Aerospike NoSQL vs.  Redis] (https://www.aerospike.com/when-to-use-aerospike-vs-redis/) </li><li>  / Redis /: Tentang "Lobak", saya pikir, tidak masuk akal untuk mengatakannya secara terpisah.  Secara paradoks, keunggulan utamanya adalah kemudahan penggunaan dan threading tunggal, yang menghindari kondisi balapan, misalnya, ketika bekerja dengan penghitung biasa. </li><li>  / Druid /: Kami menggunakan set data besar yang bekerja dengan pertukaran RTB.  Faktanya, sebagian besar, ia bermain di bidang yang sama dengan ClickHouse, tetapi secara historis, kami belum dapat beralih ke satu instrumen apa pun. </li></ul><br><img src="https://habrastorage.org/webt/o0/6j/un/o06junbll0drckljvb8sten_hei.png" alt="gambar"><br><br>  Perangkat seperti itu mungkin tampak kelebihan beban, tetapi pertama-tama, Appodeal adalah konglomerat besar dari beberapa tim pengembangan dan beberapa proyek dalam satu.  Dan kedua, ini adalah realitas keras dari teknologi iklan - kami bukan satu-satunya yang menggunakan tumpukan bertingkat di dalam satu perusahaan. <br><br><h4>  Bagaimana Anda mengikuti ini? </h4><br><br>  Karena aliran data besar, mereka perlu antri untuk memprosesnya.  Sebagai antrian, kami menggunakan Kafka.  Ini adalah solusi andal yang bagus yang ditulis dalam Scala yang belum pernah mengecewakan kami. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-s/ph/sy/-sphsyrohftcyefndm9nuz5hluo.png" alt="gambar"></div><br><br>  Satu-satunya persyaratan bagi pengguna dalam hal ini adalah bahwa ia memiliki waktu untuk menyapu antrian yang semakin meningkat lebih cepat daripada pertumbuhannya.  Aturan yang sederhana dan jelas.  Karena itu, untuk tujuan ini, kami terutama menggunakan GoLang.  Namun, ini tidak meniadakan fakta bahwa RAM di server ini harus berlimpah. <br><br>  Untuk memantau semua ekonomi ini, Anda harus memantau dan mendelegasikan segala sesuatu secara berturut-turut.  Untuk ini kami menggunakan: <br><br><ul><li>  / NewRelic /: Solusi teruji waktu yang terintegrasi sempurna dengan layanan mikro Ruby on Rails dan GoLang.  Satu-satunya minus dari NewRelic adalah harganya.  Karena itu, NewRelic tidak ada di mana-mana bersama kami.  Sebagian besar, kami mencoba menggantinya dengan metrik yang kami kumpulkan sendiri - kami menempatkannya di Grafana. </li><li>  / Statsd + Grafana /: Suatu hal yang baik untuk mengumpulkan metrik Anda.  Dengan satu-satunya minus yang Anda harus mengkonfigurasi semuanya sendiri dan "ulangi" fungsi NewRelic di luar kotak. </li><li>  / ElasticSearch + Fluentd + Kibana /: Dalam log kita meletakkan semuanya dalam satu baris.  Dari pertanyaan PostgreSQL yang lambat hingga beberapa pesan sistem Rails.  Sebenarnya, solusi seperti Kibana berdasarkan ElasticSearch memungkinkan Anda dengan mudah mengumpulkan semua log di satu tempat dan kemudian mencari pesan yang diperlukan di dalamnya. </li><li>  / Airbrake /: Wajib dalam hal ini adalah proses mengumpulkan kesalahan bersama dengan pesan stacktrace'ami.  Kami saat ini pindah dengan Airbrake ke salah satu solusi gratis.  Karena suatu alasan, sekali lagi, harga. </li></ul><br><img src="https://habrastorage.org/webt/0f/tx/e7/0ftxe7kzizutxsovtqcack5-bzs.png" alt="gambar"><br><br>  Anda perlu memahami bahwa pemantauan yang dibangun dengan benar adalah mata dan telinga Anda.  Buta tidak mungkin bekerja.  Anda perlu melihat apa yang terjadi pada server Anda pada titik waktu tertentu, sehingga stabilitas dan keandalan produk Anda akan sangat tergantung pada seberapa kompeten Anda membangun sistem untuk mengumpulkan dan menampilkan metrik. <br><br>  Ngomong-ngomong, berbicara tentang keandalan, kami mengandung beberapa server staging untuk pra-peluncuran dan memeriksa rilis, yang kami pertahankan stabil di bawah beban, menduplikasi beberapa lalu lintas nyata di sana.  Setiap minggu kami menyinkronkan basis data antara produksi dan pementasan.  Ini memberi kita semacam "cermin" yang memungkinkan kita menguji hal-hal yang tidak dapat diverifikasi secara lokal, serta mengidentifikasi masalah di tingkat pengujian beban. <br><br><h4>  Apakah ini benar-benar rumit? </h4><br>  Ternyata seperti itu.  Seperti yang ditulis Elon Musk dalam bukunya: "Pikiran terbaik generasi saya sibuk membuat orang mengklik iklan," kata Jeff Hammerbacher, seorang insinyur Facebook, kepada saya.  "Horor ..."  Daftar pendek yang dilakukan Appodeal: <br><br><ul><li>  Kami terintegrasi dengan dua lusin jaringan dan agensi periklanan.  Dalam mode otomatis, kami mendaftarkan aplikasi di jaringan ini, serta mengkonfigurasi berbagai parameter sehingga jaringan ini bekerja pada kinerja maksimum.  Tidak setiap jaringan memiliki API yang sesuai, di suatu tempat Anda harus melakukannya dengan robot. </li><li>  Setiap jaringan membayar pendapatan pengguna untuk tayangan, yang harus diterima, dipecah oleh berbagai parameter dan diproses.  Ini dilakukan tanpa henti.  Di suatu tempat, sekali lagi, oleh robot. </li><li>  Untuk memberikan penghasilan maksimum kepada pengguna, kami "membuat" kisi-kisi saling bersaing, membangun apa yang disebut "air terjun" dari penawaran iklan.  Air terjun ini dibangun berdasarkan berbagai indikator, misalnya, BPSe (harga rata-rata per 1000 tayangan), yang kami prediksi dengan berbagai cara.  Semakin tinggi penawaran iklan di air terjun, semakin tinggi kami memperkirakan harganya.  Air terjun ini ditawarkan pada perangkat sesering yang diperlukan.  Seperti yang mungkin sudah Anda duga, iklan yang tidak diklik dan hanya akan mengganggu semua orang tidak menarik minat siapa pun.  Pengecualian hanya yang disebut.  Iklan spanduk "Bermerek" dari Coca-Cola, Pepsi, dan perusahaan raksasa lainnya yang terbiasa selalu membicarakan diri mereka sendiri dan di mana-mana. </li><li>  Bagian dari interaksi ini dibangun di atas apa yang disebut protokol RTB (Penawaran Real-Time): </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dq/ma/fj/dqmafjo0twbm85ocp0p4vnnfkse.png" alt="gambar"></div><br><br>  Dalam hal ini, yang disebut penawar diperdagangkan satu sama lain secara online di pelelangan untuk hak menampilkan iklan mereka di perangkat yang dipilih.  Poin yang sangat menarik layak untuk artikel terpisah.  Banyak pertukaran, seperti Google AdExchange, menetapkan kerangka kerja yang ketat untuk waktu respons server (misalnya, 50 ms), yang menimbulkan masalah peningkatan kinerja.  Dalam kasus ketidaktaatan - denda ribuan dolar.  Inilah yang dilakukan oleh kernel yang ditulis dalam Scala bersama dengan Druid. <br><br>  Setiap pemburu ingin tahu di mana burung itu duduk, dan pelanggan kami (seperti kami) ingin tahu kepada siapa iklan itu ditampilkan, kapan dan mengapa.  Karena itu, kita harus mengantri (Kafka) semua tumpukan data yang kita miliki, secara bertahap memproses dan menambahkan ke database OLAP (ClickHouse).  Banyak orang berpikir bahwa PostgreSQL akan mengatasi tugas ini tidak lebih buruk daripada solusi "hipster", tetapi tidak demikian.  PostgreSQL bagus, tetapi solusi klasik untuk menyusun indeks untuk kecepatan akses data berhenti berfungsi ketika jumlah bidang untuk pemfilteran dan penyortiran melebihi 10, dan jumlah data yang disimpan mendekati 1 miliar catatan.  Anda tidak memiliki cukup memori untuk menyimpan semua indeks ini atau Anda akan mengalami masalah memperbarui indeks ini.  Bagaimanapun, Anda tidak akan dapat mencapai kinerja yang sama dengan solusi berorientasi kolom untuk pertanyaan analitis. <br><br><h4>  Kesimpulan </h4><br>  Dalam artikel ini, saya mencoba untuk menjelaskan secara singkat apa yang kami lakukan, bagaimana kami menyimpan dan memproses data.  Ceritakan pada kami di tumpukan mana yang Anda gunakan, ajukan pertanyaan, dan minta artikel baru - dengan senang hati kami akan membagikan pengalaman kami. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425357/">https://habr.com/ru/post/id425357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425347/index.html">Topeng Dumping: mitos atau kenyataan</a></li>
<li><a href="../id425349/index.html">Forum Positive Hack Days 9 akan diadakan 21 dan 22 Mei di Crocus Expo</a></li>
<li><a href="../id425351/index.html">Pemrogram DIY kehilangan pekerjaan mereka</a></li>
<li><a href="../id425353/index.html">Seluruh kebenaran tentang RTOS. Artikel # 13. Struktur data tugas dan panggilan API yang tidak didukung</a></li>
<li><a href="../id425355/index.html">Peringkat Keamanan Proyek ICO</a></li>
<li><a href="../id425359/index.html">Orang Cina menggunakan microchip untuk mengendalikan komputer Amerika</a></li>
<li><a href="../id425361/index.html">Pemblokiran konten, ekstensi untuk peramban kromium</a></li>
<li><a href="../id425363/index.html">Kiat untuk programmer mahasiswa</a></li>
<li><a href="../id425367/index.html">Gim Arduino paling sederhana dengan layar 1602 - Bagian # 2</a></li>
<li><a href="../id425369/index.html">KTRU (Katalog barang, pekerjaan, layanan) atau kematian pengadaan publik TI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>