<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈺 🚴 🎂 Orang asing atau sekali lagi terbiasa menggunakan pola desain 🕺🏻 👩🏾‍⚖️ 🥄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada topik pola desain, banyak artikel telah ditulis dan banyak buku telah diterbitkan. Namun, topik ini tidak berhenti menjadi relevan, karena polany...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Orang asing atau sekali lagi terbiasa menggunakan pola desain</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448590/"><p> Pada topik pola desain, banyak artikel telah ditulis dan banyak buku telah diterbitkan.  Namun, topik ini tidak berhenti menjadi relevan, karena polanya memungkinkan kami untuk menggunakan solusi yang siap pakai dan teruji waktu, yang memungkinkan kami untuk mengurangi waktu pengembangan proyek dengan meningkatkan kualitas kode dan mengurangi hutang teknis. </p><br><p>  Sejak munculnya pola desain, selalu ada contoh baru penggunaannya yang efektif.  Dan ini luar biasa.  Namun, ada lalat di salep: setiap bahasa memiliki spesifiknya sendiri.  Dan golang - dan bahkan lebih (itu bahkan tidak memiliki model OOP klasik).  Oleh karena itu, ada variasi pola, dalam kaitannya dengan bahasa pemrograman individual.  Pada artikel ini, saya ingin menyentuh pada topik pola desain dalam kaitannya dengan golang. </p><a name="habracut"></a><br><h1>  Dekorator </h1><br><blockquote>  Template Dekorator memungkinkan Anda untuk menghubungkan perilaku tambahan ke objek (secara statis atau dinamis) tanpa mempengaruhi perilaku objek lain dari kelas yang sama.  Templat sering digunakan untuk mematuhi Prinsip Tanggung Jawab Tunggal, karena memungkinkan Anda untuk berbagi fungsionalitas antar kelas untuk memecahkan masalah tertentu. <br></blockquote><p>  Pola DECORATOR yang terkenal banyak digunakan dalam banyak bahasa pemrograman.  Jadi, di golang, semua middleware dibangun atas dasar itu.  Misalnya, profil permintaan mungkin terlihat seperti ini: </p><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfileMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { started := time.Now() next.ServeHTTP() elapsed := time.Now().Sub(started) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"HTTP: elapsed time %d"</span></span>, elapsed) }</code> </pre> <br><p>  Dalam hal ini, antarmuka dekorator adalah satu-satunya fungsi.  Sebagai aturan, ini harus dicari.  Namun, dekorator dengan antarmuka yang lebih luas terkadang dapat bermanfaat.  Sebagai contoh, pertimbangkan akses ke database (paket database / sql).  Misalkan kita perlu melakukan profil yang sama dari permintaan basis data.  Dalam hal ini, kita perlu: </p><br><ul><li>  Alih-alih berinteraksi secara langsung dengan database melalui pointer, kita perlu pergi ke interaksi melalui antarmuka (untuk memisahkan perilaku dari implementasi). </li><li>  Buat pembungkus untuk setiap metode yang mengeksekusi query database SQL. </li></ul><br><p>  Sebagai hasilnya, kami mendapatkan dekorator yang memungkinkan Anda untuk membuat profil semua pertanyaan ke database.  Keuntungan dari pendekatan ini tidak dapat dipungkiri: </p><br><ul><li>  Menjaga kebersihan kode komponen akses basis data inti. </li><li>  Setiap dekorator menerapkan satu persyaratan.  Karena itu, kemudahan implementasi tercapai. </li><li>  Karena komposisi dekorator, kami mendapatkan model yang dapat diperluas yang dengan mudah menyesuaikan dengan kebutuhan kami. </li><li>  Kami mendapatkan nol overhead kinerja dalam mode produksi karena shutdown sederhana dari profiler. </li></ul><br><p>  Jadi, misalnya, Anda dapat menerapkan jenis dekorator berikut: </p><br><ul><li>  Detak jantung  Mem-ping sebuah basis data agar koneksi tetap hidup. </li><li>  Profiler.  Output dari tubuh permintaan dan waktu pelaksanaannya. </li><li>  Sniffer.  Kumpulan metrik basis data. </li><li>  Klon  Mengkloning basis data asli untuk tujuan debugging. </li></ul><br><p>  Sebagai aturan, ketika menerapkan dekorator kaya, penerapan semua metode tidak diperlukan: cukup untuk mendelegasikan metode yang tidak diimplementasikan ke objek internal. </p><br><p>  Misalkan kita perlu mengimplementasikan logger tingkat lanjut untuk melacak kueri DML untuk basis data (untuk melacak kueri INSERT / UPDATE / DELETE).  Dalam hal ini, kita tidak perlu mengimplementasikan seluruh antarmuka basis data - cukup tumpang tindih hanya dengan metode Exec. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyDatabase <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{ Query(...) (sql.Rows, error) QueryRow(...) error Exec(query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>) error Ping() error } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyExecutor <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MyDatabase } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *MyExecutor)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, args ...</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ... }</code> </pre> <br><p>  Jadi, kita melihat bahwa membuat bahkan dekorator yang kaya dalam bahasa golang tidak terlalu sulit. </p><br><h1>  Metode templat </h1><br><blockquote>  Metode Templat (Metode Templat Templat) - pola desain perilaku yang mendefinisikan dasar algoritma dan memungkinkan ahli waris untuk mendefinisikan kembali beberapa langkah algoritma tanpa mengubah strukturnya secara keseluruhan. <br></blockquote><p>  Bahasa golang mendukung paradigma OOP, sehingga templat ini tidak dapat diimplementasikan dalam bentuknya yang murni.  Namun, tidak ada yang menghalangi kita untuk berimprovisasi dengan menggunakan fungsi yang sesuai. </p><br><p>  Misalkan kita perlu mendefinisikan metode templat dengan tanda tangan berikut: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><p>  Ketika mendeklarasikan itu cukup bagi kita untuk menggunakan bidang tipe fungsional.  Untuk kenyamanan bekerja dengannya, kita dapat menggunakan fungsi wrapper untuk melengkapi panggilan dengan parameter yang hilang, dan untuk membuat contoh spesifik, fungsi konstruktor yang sesuai. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MethodImpl <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(me *MyStruct, s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ms *MyStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ms.MethodImpl(ms, s) } <span class="hljs-comment"><span class="hljs-comment">// First constructor func NewStruct1() *MyStruct { return &amp;MyStruct{ MethodImpl: func(me *MyStruct, s string) error { // Implementation 1 ... }, } } // Second constructor func NewStruct2() *MyStruct { return &amp;MyStruct{ MethodImpl: func(me *MyStruct, s string) error { // Implementation 2 ... }, } } func main() { // Create object instance o := NewStruct2() // Call the template method err := o.Method("hello") ... }</span></span></code> </pre> <br><p>  Seperti yang dapat Anda lihat dari contoh, semantik menggunakan pola hampir tidak berbeda dari OOP klasik. </p><br><h1>  Adaptor </h1><br><blockquote>  Pola desain "Adaptor" memungkinkan Anda untuk menggunakan antarmuka kelas yang ada sebagai antarmuka lain.  Templat ini sering digunakan untuk memastikan bahwa beberapa kelas bekerja dengan yang lain tanpa mengubah kode sumbernya. <br></blockquote><p>  Secara umum, sebagai adaptor dapat berfungsi, sebagai fungsi terpisah, dan seluruh antarmuka.  Jika dengan antarmuka semuanya lebih atau kurang jelas dan dapat diprediksi, maka dari sudut pandang fungsi individu ada kehalusan. </p><br><p>  Misalkan kita menulis beberapa layanan yang memiliki beberapa API internal: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyService <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Create(ctx context.Context, order <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, err error) }</code> </pre> <br><p>  Jika kita perlu menyediakan API publik dengan antarmuka yang berbeda (katakanlah untuk bekerja dengan gRPC), maka kita cukup menggunakan fungsi adaptor yang berhubungan dengan konversi antarmuka.  Sangat nyaman untuk menggunakan penutupan untuk tujuan ini. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRequest</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">struct</span></span></span></span> { Order <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> CreateResponse <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s MyService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Decode request req := request.(CreateRequest) // Call service method id, err := s.Create(ctx, req.Order) // Encode response return CreateResponse{ID: id, Err: err}, nil } }</span></span></code> </pre> <br><p>  Fungsi makeCreateEndpoint memiliki tiga langkah standar: </p><br><ul><li>  nilai decoding </li><li>  memanggil metode dari API internal layanan yang sedang dilaksanakan </li><li>  pengkodean nilai </li></ul><br><p>  Semua titik akhir dalam paket gokit dibangun berdasarkan prinsip ini. </p><br><h1>  Pengunjung </h1><br><blockquote>  Template "Pengunjung" adalah cara untuk memisahkan algoritma dari struktur objek di mana ia beroperasi.  Hasil pemisahan adalah kemampuan untuk menambahkan operasi baru ke struktur objek yang ada tanpa mengubahnya.  Ini adalah salah satu cara untuk mematuhi prinsip terbuka / tertutup. <br></blockquote><p>  Perhatikan pola pengunjung yang terkenal pada contoh bentuk geometris. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Geometry <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Visit(GeometryVisitor) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GeometryVisitor <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { VisitPoint(p *Point) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) VisitLine(l *Line) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) VisitCircle(c *Circle) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Point <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X, Y <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitPoint(point) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Line <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X1, Y1 <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> X2, Y2 <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(line *Line)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitLine(line) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Circle <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X, Y, R <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(circle *Circle)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitCircle(circle) }</code> </pre> <br><p>  Misalkan kita ingin menulis strategi untuk menghitung jarak dari titik tertentu ke bentuk tertentu. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DistanceStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { X, Y <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *DistanceStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Evaluate distance from point(X, Y) to point p } func (s *DistanceStrategy) VisitLine(l *Line) (interface{}, error) { // Evaluate distance from point(X, Y) to line l } func (s *DistanceStrategy) VisitCircle(c *Circle) (interface{}, error) { // Evaluate distance from point(X, Y) to circle c } func main() { s := &amp;DistanceStrategy{X: 1, Y: 2} p := &amp;Point{X: 3, Y: 4} res, err := p.Visit(s) if err != nil { panic(err) } fmt.Printf("Distance is %g", res.(float32)) }</span></span></code> </pre> <br><p>  Demikian pula, kita dapat menerapkan strategi lain yang kita butuhkan: </p><br><ul><li>  Tingkat vertikal </li><li>  Tingkat horizontal objek </li><li>  Membangun square spanning minimum (MBR) </li><li>  Primitif lain yang kita butuhkan. </li></ul><br><p>  Selain itu, angka yang didefinisikan sebelumnya (Point, Line, Circle ...) tidak tahu apa-apa tentang strategi ini.  Pengetahuan mereka hanya terbatas pada antarmuka GeometryVisitor.  Ini memungkinkan Anda mengisolasinya dalam paket terpisah. </p><br><p>  Pada suatu waktu, saat mengerjakan proyek kartografi, saya mendapat tugas untuk menulis fungsi untuk menentukan jarak antara dua objek geografis yang arbitrer.  Solusinya sangat berbeda, tetapi semuanya tidak cukup efisien dan elegan.  Mengingat entah bagaimana pola Pengunjung, saya perhatikan bahwa itu berfungsi untuk memilih metode target dan agak menyerupai langkah rekursi yang terpisah, yang, seperti yang Anda tahu, menyederhanakan tugas.  Ini mendorong saya untuk menggunakan Pengunjung Ganda.  Bayangkan betapa terkejutnya saya ketika saya menemukan bahwa pendekatan semacam itu sama sekali tidak disebutkan di Internet. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> geometryStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ G Geometry } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;pointStrategy{Point: p}) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *Line)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;lineStrategy{Line: l}) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Circle)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;circleStrategy{Circle: c}) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> pointStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ *Point } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point *pointStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Evaluate distance between point and p } func (point *pointStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between point and l } func (point *pointStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between point and c } type lineStrategy struct { *Line } func (line *lineStrategy) Visit(p *Point) (interface{}, error) { // Evaluate distance between line and p } func (line *lineStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between line and l } func (line *lineStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between line and c } type circleStrategy struct { *Circle } func (circle *circleStrategy) Visit(p *Point) (interface{}, error) { // Evaluate distance between circle and p } func (circle *circleStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between circle and l } func (circle *circleStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between circle and c } func Distance(a, b Geometry) (float32, error) { return a.Visit(&amp;geometryStrategy{G: b}) }</span></span></code> </pre> <br><p>  Dengan demikian, kami telah membangun mekanisme selektif dua tingkat, yang, sebagai hasil dari kerjanya, akan memanggil metode yang tepat untuk menghitung jarak antara dua primitif.  Kami hanya dapat menulis metode ini dan tujuannya tercapai.  Ini adalah bagaimana masalah elegan non-deterministik dapat direduksi menjadi sejumlah fungsi dasar. </p><br><h1>  Kesimpulan </h1><br><p>  Terlepas dari kenyataan bahwa tidak ada OOP klasik di golang, bahasa menghasilkan dialek pola sendiri yang bermain pada kekuatan bahasa.  Pola-pola ini berubah dari penolakan ke penerimaan universal dan menjadi praktik terbaik dari waktu ke waktu. </p><br><p>  Jika habrozhiteli yang dihormati memiliki pemikiran tentang pola, harap jangan malu dan ungkapkan pikiran Anda tentang hal ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448590/">https://habr.com/ru/post/id448590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448572/index.html">Komunikasi manusia menjadi barang mewah</a></li>
<li><a href="../id448574/index.html">Satu tugas dari rutin SEO: solusi 3 langkah</a></li>
<li><a href="../id448576/index.html">Transistor Story Bagian 2: Dari Crucible of War</a></li>
<li><a href="../id448582/index.html">Membuat tip kalkulator di Kotlin: bagaimana cara kerjanya?</a></li>
<li><a href="../id448584/index.html">7 kesalahan umum saat menggunakan preposisi dalam bahasa Inggris dan cara menghindarinya</a></li>
<li><a href="../id448594/index.html">Antivirus dan Firewall Gratis (UTM, NGFW) dari Sophos</a></li>
<li><a href="../id448596/index.html">Dudukan tablet di treadmill atau cari langkah gratis</a></li>
<li><a href="../id448602/index.html">Apakah pemantauan mati? - Pemantauan hidup panjang</a></li>
<li><a href="../id448604/index.html">Game Boy di C #</a></li>
<li><a href="../id448606/index.html">Sidorin: KnowledgeConf adalah tentang bagaimana mempertahankan pengetahuan dengan durasi kerja rata-rata di satu tempat dalam 2-3 tahun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>