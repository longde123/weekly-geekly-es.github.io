<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏿 🚴🏽 🔂 5 coisas que eu gostaria de saber quando comecei a usar o Angular 👢 🧜🏼 👋🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Angular moderno é uma estrutura poderosa com muitos recursos, junto com a qual, à primeira vista, surgem conceitos e mecanismos complexos. Isso é es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 coisas que eu gostaria de saber quando comecei a usar o Angular</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/480782/"><p>  O Angular moderno é uma estrutura poderosa com muitos recursos, junto com a qual, à primeira vista, surgem conceitos e mecanismos complexos.  Isso é especialmente perceptível para aqueles que acabaram de começar a trabalhar tanto no front-end em princípio quanto no Angular em particular. </p><br><p>  Também enfrentei o mesmo problema quando cheguei a Tinkoff na posição de Junior Frontend Developer há cerca de dois anos e mergulhei no mundo da Angular.  Portanto, ofereço-lhe uma pequena história sobre cinco coisas, cuja compreensão facilitaria muito meu trabalho a princípio. </p><br><p><img src="https://habrastorage.org/webt/er/qq/op/erqqope6skve-m43vun9ivrjyda.png"></p><a name="habracut"></a><br><h2 id="dependency-injection-di">  Injeção de Dependência (DI) </h2><br><p>  No começo, entrei no componente e vi que havia alguns argumentos no construtor de classes.  Fiz uma pequena análise do trabalho dos métodos de classe e ficou claro que essas são algumas dependências externas.  Mas como eles entraram na aula?  Onde o construtor foi chamado? </p><br><p>  Sugiro imediatamente entender um exemplo, mas para isso precisamos de uma aula.  Se no JavaScript "normal" o OOP estiver presente com certos "hacks", juntamente com o ES6, haverá uma sintaxe "real".  Angular usa o TypeScript imediatamente, na qual a sintaxe é praticamente a mesma.  Portanto, proponho usá-lo ainda mais. </p><br><p> Imagine que existe uma classe <code>JokerService</code> em nosso aplicativo que gerencia piadas.  O método <code>getJokes()</code> retorna uma lista de piadas.  Suponha que a usemos em três lugares.  Como obter piadas em três lugares diferentes no código?  Existem várias maneiras: </p><br><ol><li>  Crie uma instância da classe em todos os lugares.  Mas por que precisamos entupir a memória e criar tantos serviços idênticos?  E se houver 100 lugares? </li><li>  Torne o método estático e recupere dados usando JokerService.getJokes (). </li><li>  Implemente um dos padrões de design.  Se precisarmos que o serviço seja um para todo o aplicativo, esse será o Singleton.  Mas, para isso, você precisa escrever uma nova lógica na classe. </li></ol><br><p>  Então, temos três opções bastante funcionais.  O primeiro não nos convém - neste caso, é ineficaz.  Não queremos criar cópias extras, pois elas serão completamente idênticas.  Restam duas opções. </p><br><p>  Vamos complicar a tarefa de entender qual método nos convém melhor.  Suponha que, em terceiro lugar, precisamos, por algum motivo, criar nosso próprio serviço com determinados parâmetros.  Esse pode ser um autor específico, a duração da piada, o idioma e muito mais.  O que faremos então? </p><br><p>  No caso do método estático, você terá que passar as configurações a cada chamada, pois a classe é comum a todos os lugares.  Ou seja, em cada chamada para <code>getJokes()</code> passaremos todos os parâmetros exclusivos para esse local.  Obviamente, é melhor passá-las ao criar a instância e depois chamar o método <code>getJokes()</code> . </p><br><p>  Acontece que a segunda opção também não nos serve: fará sempre duplicar muito código em todos os lugares.  Resta apenas o Singleton, que novamente precisará atualizar a lógica, mas com variações.  Mas como entender qual opção precisamos? </p><br><p>  Se você pensou que pode simplesmente criar um objeto e usar a chave para executar o serviço desejado, posso parabenizá-lo: você acabou de perceber como a <em>Injeção de Dependência</em> funciona em geral.  Mas vamos um pouco mais fundo. </p><br><p>  Para garantir que um mecanismo seja necessário para nos ajudar a obter as instâncias corretas, imagine que o JokerService precise de mais dois serviços, um dos quais é opcional e o segundo deve fornecer um resultado especial em um determinado local.  Não é difícil. </p><br><h3 id="dependency-injection-v-angular">  Injeção de Dependência em Angular </h3><br><p>  Como diz a <a href="https://angular.io/guide/dependency-injection">documentação</a> , o DI é um padrão de design importante para um aplicativo.  O Angular possui sua própria estrutura de dependência, usada no próprio Angular para aumentar a eficiência e a modularidade. </p><br><p>  De um modo geral, a <em>Injeção de Dependências</em> é um mecanismo poderoso no qual uma classe recebe as dependências necessárias de algum lugar externo, em vez de criar instâncias por conta própria. </p><br><p>  Deixe a sintaxe e os arquivos com a extensão <code>html</code> não confundirem você.  Cada componente no Angular é um objeto JavaScript comum, uma instância de uma classe.  Em termos gerais: quando você insere um componente em um modelo, uma instância da classe de componente é criada.  Portanto, neste momento, você pode passar as dependências necessárias para o construtor.  Agora considere um exemplo: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'jokes', template: './jokes.template.html', }) export class JokesComponent { private jokes: Observable&lt;IJoke[]&gt;; constructor(private jokerService: JokerService) { this.jokes = this.jokerService.getJokes(); } }</code> </pre> <br><p>  No construtor de componentes, simplesmente indicamos que precisamos de um <code>JokerService</code> .  Nós não criamos nós mesmos.  Se houver mais cinco componentes que o usem, todos eles se referirão à mesma instância.  Tudo isso nos permite economizar tempo, eliminar clichês e escrever aplicativos muito produtivos. </p><br><h3 id="providers">  Fornecedores </h3><br><p>  E agora proponho lidar com o caso quando você precisar obter instâncias diferentes do serviço.  Primeiro, dê uma olhada no próprio serviço: </p><br><pre> <code class="plaintext hljs">@Injectable({ providedIn: 'root', //   ,   «»  }) export class JokerService { getJokes(): Observable&lt;IJoke[]&gt; { //     } }</code> </pre> <br><p>  Quando o serviço for um para todo o aplicativo, essa opção será suficiente.  Mas e se tivermos, digamos, duas implementações do <code>JokerService</code> ?  Ou é apenas por algum motivo que um componente específico precisa de sua própria instância de serviço?  A resposta é simples: <a href="https://angular.io/guide/providers"><code>provider</code></a> . </p><br><p>  Por conveniência, chamarei <code>provider</code> <em>provedor de provedor</em> , e o processo de substituição de um valor em uma classe será <em>verificado</em> .  Assim, podemos fornecer serviços de diferentes maneiras e em diferentes lugares.  Vamos começar com o último.  Existem três opções disponíveis: </p><br><ul><li>  Em todo o aplicativo - especifique <code>provideIn: 'root'</code> no próprio decorador de serviços. </li><li>  No módulo - especifique o provedor no decorador de serviços como <code>provideIn: JokesModule</code> ou no decorador do módulo <code>@NgModule  providers: [JokerService]</code> . </li><li>  No componente - especifique o provedor no decorador do componente, como no módulo. </li></ul><br><p>  O local é escolhido dependendo de suas necessidades.  Nós descobrimos o lugar, vamos para o mecanismo em si.  Se simplesmente especificássemos o <code>provideIn: root</code> no serviço, isso seria equivalente à seguinte entrada no módulo: </p><br><pre> <code class="plaintext hljs">@NgModule({ // ...     providers: [{provide: JokerService, useClass: JokerService}], }) //  </code> </pre> <br><p>  Isso pode ser lido da seguinte maneira: "Se um <code>JokerService</code> solicitado, forneça uma instância da classe <code>JokerService»</code>  A partir daqui, você pode obter uma instância específica de várias maneiras: </p><br><ul><li><p>  Por token - você precisa especificar um <code>InjectionToken</code> e obter um serviço nele.  Observe que nos exemplos abaixo em <code>provide</code> você pode transmitir o mesmo token: </p><br><pre> <code class="plaintext hljs">const JOKER_SERVICE_TOKEN = new InjectionToken&lt;string&gt;('JokerService'); // ...     [{provide: JOKER_SERVICE_TOKEN, useClass: JokerService}];</code> </pre> <br></li><li><p>  Por classe - você pode substituir a classe.  Por exemplo, solicitaremos o <code>JokerService</code> e forneceremos - <code>JokerHappyService</code> : </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useClass: JokerHappyService}];</code> </pre> <br></li><li><p>  Por valor - você pode retornar imediatamente a instância desejada: </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useValue: jokerService}];</code> </pre> <br></li><li><p>  Por fábrica - você pode substituir a classe por uma fábrica que criará a instância desejada quando for acessada: </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useFactory: jokerServiceFactory}];</code> </pre> <br></li></ul><br><p>  Isso é tudo.  Ou seja, para resolver o exemplo com uma instância especial, você pode usar qualquer um dos métodos acima.  Escolha o mais adequado às suas necessidades. </p><br><p>  A propósito, o DI trabalha não apenas para serviços, mas em geral para qualquer entidade que você obtém no construtor de componentes.  Este é um mecanismo muito poderoso que deve ser usado em todo o seu potencial. </p><br><h3 id="nebolshoy-itog">  Um pequeno resumo </h3><br><p>  Para um entendimento completo, proponho considerar o mecanismo simplificado de injeção de dependência no Angular em etapas usando o exemplo de serviço: </p><br><ol><li>  Ao inicializar o aplicativo, o serviço possui um token.  Se não o especificamos especificamente no provedor, esse é o JokerService. </li><li>  Quando um serviço é solicitado em um componente, o mecanismo DI verifica se o token transferido existe. </li><li>  Se o token não existir, o DI emitirá um erro.  No nosso caso, o token existe e o JokerService está localizado nele. </li><li>  Quando o componente é criado, uma instância do JokerService é passada ao construtor como argumento. </li></ol><br><h2 id="change-detection">  Detecção de alterações </h2><br><p>  Frequentemente ouvimos, como argumento para o uso de estruturas, algo como “A estrutura fará tudo por você - de maneira mais rápida e eficiente.  Você não precisa pensar em nada.  Apenas gerencie os dados. ”  Talvez isso seja verdade com uma aplicação muito simples.  Mas se você precisar trabalhar com as informações do usuário e operar constantemente com os dados, precisará saber como funciona o processo de detecção de alterações e renderização. </p><br><p>  Em Angular, a <em>Detecção de alterações</em> é responsável por verificar as alterações.  Como resultado de várias operações - alterando o valor de uma propriedade de classe, concluindo uma operação assíncrona, respondendo a uma solicitação HTTP e assim por diante - o processo de verificação é iniciado na árvore de componentes. </p><br><p>  Como o principal objetivo do processo é entender como renderizar novamente um componente, a essência é verificar os dados usados ​​nos modelos.  Se forem diferentes, o modelo será marcado como "alterado" e será redesenhado. </p><br><h3 id="zonejs">  Zone.js </h3><br><p>  Compreender como o Angular controla as propriedades da classe e as operações síncronas é bastante simples.  Mas como ele rastreia assíncrono?  A biblioteca Zone.js, criada por um dos desenvolvedores Angular, é responsável por isso. </p><br><p>  Aqui está o que é.  Uma zona em si é um "contexto de execução", para ser franco, o local e o estado em que o código é executado.  Após a conclusão da operação assíncrona, a função de retorno de chamada é executada na mesma zona em que foi registrada.  Então a Angular descobre onde a alteração ocorreu e o que verificar. </p><br><p>  O Zone.js substitui por suas implementações quase todas as funções e métodos assíncronos nativos.  Portanto, ele pode rastrear quando o <code>callback</code> uma função assíncrona será chamado.  Ou seja, o Zone informa ao Angular quando e onde iniciar o processo de validação de alterações. </p><br><h3 id="strategii-obnaruzheniya-izmeneniy">  Estratégias de detecção de alterações </h3><br><p>  Nós descobrimos como o Angular monitora um componente e executa a verificação de alterações.  Agora imagine que você tenha um aplicativo enorme com dezenas de componentes.  E para cada clique, toda operação assíncrona, toda solicitação executada com sucesso, uma verificação é iniciada em toda a árvore de componentes.  Provavelmente, esse aplicativo terá sérios problemas de desempenho. </p><br><p>  Os desenvolvedores angulares pensaram sobre isso e nos deram a oportunidade de estabelecer uma estratégia de detecção de alterações, cuja escolha correta pode aumentar significativamente a produtividade. </p><br><p>  Há duas opções para escolher: </p><br><ul><li>  Padrão - como o nome sugere, esta é a estratégia padrão quando um CD é lançado para cada ação. </li><li>  OnPush é uma estratégia na qual um CD é lançado em apenas alguns casos: <br><ul><li>  se o valor de <code>@Input()</code> mudou; </li><li>  se um evento ocorreu dentro do componente ou de seus descendentes; </li><li>  se a verificação foi iniciada manualmente; </li><li>  se um novo evento chegar no Tubo assíncrono. </li></ul></li></ul><br><p>  Com base na minha própria experiência em desenvolvimento no Angular, bem como na experiência de meus colegas, posso afirmar com certeza que é melhor sempre indicar a estratégia <code>OnPush</code> , a menos que o <code>default</code> realmente necessário.  Isso lhe dará várias vantagens: </p><br><ul><li>  Uma compreensão clara de como o processo do CD funciona. </li><li>  Trabalho puro com propriedades <code>@Input()</code> . </li><li>  Ganho de desempenho. </li></ul><br><h2 id="rabota-s-input">  Trabalhar com <code>@Input()</code> </h2><br><p>  Como outras estruturas populares, o Angular usa um fluxo de dados downstream.  O componente aceita parâmetros de entrada marcados com o decorador <code>@Input()</code> .  Considere um exemplo: </p><br><pre> <code class="plaintext hljs">interface IJoke { author: string; text: string; } @Component({ selector: 'joke', template: './joke.template.html', }) export class JokeComponent { @Input() joke: IJoke; }</code> </pre> <br><p>  Suponha que exista um componente descrito acima que exiba o texto da piada e o autor.  O problema com esta redação é que você pode alterar acidental ou especificamente o objeto transferido.  Por exemplo, substitua o texto ou autor. </p><br><pre> <code class="plaintext hljs">setAuthorNameOnly() { const name = this.joke.author.split(' ')[0]; this.joke.author = name; }</code> </pre> <br><p>  Percebo imediatamente que este é um mau exemplo, mas mostra claramente o que pode acontecer.  Para se proteger contra esses erros, é necessário tornar os parâmetros de entrada somente leitura.  Graças a isso, você entenderá como trabalhar com os dados corretamente e criar um CD.  Com base nisso, a melhor maneira de escrever uma classe será algo como isto: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'joke', template: './joke.template.html', changeDetection: ChangeDetectionStrategy.OnPush, }) export class JokeComponent { @Input() readonly joke: IJoke; @Output() updateName = new EventEmitter&lt;string&gt;(); setAuthorNameOnly() { const name = this.joke.author.split(' ')[0]; this.updateName.emit(name); } }</code> </pre> <br><p>  A abordagem descrita não é uma regra, mas apenas uma recomendação.  Existem muitas situações em que essa abordagem será inconveniente e ineficaz.  Com o tempo, você aprenderá a entender em que caso poderá recusar o método proposto de trabalhar com entradas. </p><br><h2 id="rxjs">  Rxjs </h2><br><p>  É claro que posso estar errado, mas parece que o ReactiveX e a programação reativa em geral são uma nova tendência.  Angular sucumbiu a essa tendência (ou talvez a tenha criado) e usa o RxJS por padrão.  A lógica básica de toda a estrutura é executada nesta biblioteca, portanto, é muito importante entender os princípios da programação reativa. </p><br><p>  Mas o que é RxJS?  Ele combina três idéias que vou revelar em uma linguagem bastante simples, com algumas omissões: </p><br><ul><li>  <em>O padrão "Observador"</em> é uma entidade que produz eventos, e há um ouvinte que recebe informações sobre esses eventos. </li><li>  <em>O Padrão Iterador</em> - permite obter acesso seqüencial aos elementos de um objeto sem revelar sua estrutura interna. </li><li>  <em>A programação funcional com coleções</em> é um padrão no qual a lógica bate em componentes pequenos e muito simples, cada um dos quais resolve apenas um problema. </li></ul><br><p>  A combinação desses padrões nos permite descrever de maneira simples algoritmos complexos à primeira vista, por exemplo: </p><br><pre> <code class="plaintext hljs">private loadUnreadJokes() { this.showLoader(); //   fromEvent(document, 'load') .pipe( switchMap( () =&gt; this.http .get('/api/v1/jokes') //   .pipe(map((jokes: any[]) =&gt; jokes.filter(joke =&gt; joke.unread))), //   ), ) .subscribe( (jokes: any[]) =&gt; (this.jokes = jokes), //   error =&gt; { /*   */ }, () =&gt; this.hideLoader(), //       ); }</code> </pre> <br><p>  Apenas 18 linhas com todo o belo recuo.  Agora tente reescrever este exemplo no Vanilla ou pelo menos no jQuery.  Quase 100% disso ocupará pelo menos o dobro de espaço e não será tão expressivo.  Aqui você pode simplesmente seguir a linha com os olhos e ler o código como um livro. </p><br><h3 id="observable">  Observável </h3><br><p>  O entendimento de que qualquer dado pode ser representado como um fluxo não vem imediatamente.  Portanto, proponho passar para uma analogia simples.  Imagine um fluxo é uma matriz de dados classificados por tempo.  Por exemplo, nesta modalidade: </p><br><pre> <code class="plaintext hljs">const observable = []; let counter = 0; const intervalId = setInterval(() =&gt; { observable.push(counter++); }, 1000); setTimeout(() =&gt; { clearInterval(intervalId); }, 6000);</code> </pre> <br><p>  Vamos considerar o último valor na matriz como relevante.  A cada segundo, um número será adicionado à matriz.  Como podemos descobrir em outro lugar no aplicativo que um elemento foi adicionado à matriz?  Em uma situação normal, chamaríamos algum tipo de <code>callback</code> de <code>callback</code> e atualizaríamos o valor da matriz e, então, pegaríamos o último elemento. </p><br><p>  Graças à programação reativa, não é necessário escrever apenas muita lógica nova, mas também pensar em atualizar as informações.  Isso pode ser comparado a um ouvinte simples: </p><br><pre> <code class="plaintext hljs">document.addEventListener('click', event =&gt; {});</code> </pre> <br><p>  Você pode colocar muitos <code>EventListener</code> em todo o aplicativo, e eles funcionarão, a menos que, é claro, você cuide do oposto de propósito. </p><br><p>  A programação reativa também funciona.  Em um lugar, simplesmente criamos um fluxo de dados e periodicamente lançamos novos valores lá; em outro, assinamos esse fluxo e simplesmente ouvimos esses valores.  Ou seja, sempre aprendemos sobre a atualização e podemos lidar com isso. </p><br><p>  Agora vamos ver um exemplo real: </p><br><pre> <code class="plaintext hljs">export class JokesListComponent implements OnInit { jokes$: Observable&lt;IJoke&gt;; authors$ = new Subject&lt;string[]&gt;(); unread$ = new Subject&lt;number&gt;(); constructor(private jokerService: JokerService) {} ngOnInit() { //  ,    subscribe()    this.jokes$ = this.jokerService.getJokes(); this.jokes$.subscribe(jokes =&gt; { this.authors$.next(jokes.map(joke =&gt; joke.author)); this.unread$.next(jokes.filter(joke =&gt; joke.unread).length); }); } }</code> </pre> <br><p>  Graças a essa lógica, ao alterar dados em <code>jokes</code> , atualizamos automaticamente os dados sobre o número de piadas não lidas e a lista de autores.  Se você tiver mais alguns componentes, um dos quais coleta estatísticas sobre o número de piadas lidas por um autor e o segundo calcula a duração média das piadas, as vantagens se tornam óbvias. </p><br><h2 id="testbed">  Testbed </h2><br><p>  Mais cedo ou mais tarde, o desenvolvedor entende que, se o projeto não for MVP, será necessário escrever testes.  E quanto mais testes forem escritos, mais clara e detalhada será a descrição, mais fácil, mais rápido e mais confiável será fazer alterações e implementar novas funcionalidades. </p><br><p>  Angular provavelmente previu isso e nos deu uma poderosa ferramenta de teste.  Muitos desenvolvedores, no início, tentam dominar algum tipo de tecnologia "desde o início", sem entrar na documentação.  Fiz o mesmo, e foi por isso que percebi bastante tarde todos os recursos de teste disponíveis "prontos para uso". </p><br><p>  Você pode testar qualquer coisa no Angular, mas se precisar instanciar e começar a chamar métodos para testar uma classe ou serviço regular, a situação com o componente é completamente diferente. </p><br><p>  Como já descobrimos, graças às dependências de DI são retiradas do componente.  Por um lado, isso complica um pouco todo o sistema, por outro, oferece grandes oportunidades para configurar testes e verificar muitos casos.  Proponho entender o exemplo de um componente: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'app-joker', template: '&lt;some-dependency&gt;&lt;/some-dependency&gt;', styleUrls: ['./joker.component.less'], }) export class JokerComponent { constructor( private jokesService: JokesService, @Inject(PARTY_TOKEN) private partyService: PartyService, @Optional() private sleepService: SleepService, ) {} makeNewFriend(): IFriend { if (this.sleepService &amp;&amp; this.sleepService.isSleeping) { this.sleepService.wakeUp(); } const joke = this.jokesService.generateNewJoke(); this.partyService.goToParty('Pacha'); this.partyService.toSay(joke.text); const laughingPeople = this.partyService.getPeopleByReaction('laughing'); const girl = laughingPeople.find(human =&gt; human.sex === 'female'); const friend = this.partyService.makeFriend(girl); return friend; } }</code> </pre> <br><p>  Portanto, no exemplo atual, existem três serviços.  Um é importado da maneira usual, um por token e outro serviço é opcional.  Como configuramos o módulo de teste?  Mostrarei imediatamente a exibição concluída: </p><br><pre> <code class="plaintext hljs">beforeEach(async(() =&gt; { TestBed.configureTestingModule({ imports: [SomeDependencyModule], declarations: [JokerComponent], //  ,    providers: [{provide: PARTY_TOKEN, useClass: PartyService}], }).compileComponents(); fixture = TestBed.createComponent(JokerComponent); component = fixture.componentInstance; fixture.detectChanges(); //    ,     }));</code> </pre> <br><p>  <code>TestBed</code> nos permite fazer uma simulação completa do módulo necessário.  Você pode conectar a ele quaisquer serviços, substituir módulos, obter instâncias de classes de um componente e muito mais.  Agora que já temos o módulo configurado, vamos para as possibilidades. </p><br><h3 id="mozhno-izbegat-lishnih-zavisimostey">  Dependências desnecessárias podem ser evitadas </h3><br><p>  Um aplicativo Angular consiste em módulos, que podem incluir outros módulos, serviços, diretrizes e muito mais.  No teste, precisamos, de fato, recriar a operação do módulo.  Se, em nosso exemplo, usarmos <code>&lt;some-dependency&gt;&lt;/some-dependency&gt;</code> no modelo, isso significa que devemos importar o <code>SomeDependencyModule</code> para o teste também.  E se houver vícios lá?  Portanto, eles também precisam ser importados. <br>  Se o aplicativo for complexo, haverá muitas dessas dependências.  A importação de todas as dependências levará ao fato de que em cada teste o aplicativo inteiro estará localizado e todos os métodos serão chamados.  Talvez isso não nos convenha. </p><br><p>  Há pelo menos uma maneira de se livrar das dependências necessárias - basta reescrever o modelo.  Suponha que você tenha testes de captura de tela ou testes de integração e não há necessidade de testar a aparência do componente.  Então basta verificar os métodos.  Nesse caso, você pode escrever a configuração da seguinte maneira: </p><br><pre> <code class="plaintext hljs">TestBed.configureTestingModule({ declarations: [JokerComponent], providers: [{provide: PARTY_TOKEN, useClass: PartyService}], }) .overrideTemplate(JokerComponent, '') //   ,   .compileComponents();</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sim, isso não é para todos. </font><font style="vertical-align: inherit;">Dentro do Tinkoff, concordamos em usar essa abordagem apenas nos casos em que não há necessidade de verificar a exibição do componente. </font><font style="vertical-align: inherit;">Por exemplo, ao trabalhar apenas com dados ou se comunicar com a parte. </font><font style="vertical-align: inherit;">Se houver necessidade de verificar como os dados são transferidos para componentes filho ou, por exemplo, como a entrada do usuário é processada, essa opção não funcionará. </font><font style="vertical-align: inherit;">Se você tiver esse caso, vá para o próximo parágrafo.</font></font></p><br><h3 id="mozhno-mokirovat-vse-zavisimosti-iz-konstruktora"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Você pode molhar todas as dependências do construtor </font></font></h3><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Já nos familiarizamos com o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Token de injeção</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por isso proponho a começar imediatamente os negócios. </font><font style="vertical-align: inherit;">No exemplo acima, eu já verifiquei o serviço de token no teste. </font><font style="vertical-align: inherit;">Se você não está escrevendo um teste de integração, não faz sentido chamar métodos de um serviço real, apenas faça uma simulação.</font></font></p><br><p>        <code>ts-mockito</code> ,     ,    . Angular    « ». </p><br><pre> <code class="plaintext hljs">//    export class MockPartyService extends PartyService { meetFriend(): IFriend { return {} as IFriend; } goToParty() {} toSay(some: string) { console.log(some); } } // ... TestBed.configureTestingModule({ declarations: [JokerComponent, MockComponent], providers: [{provide: PARTY_TOKEN, useClass: MockPartyService}], //    }).compileComponents();</code> </pre> <br><p>  Isso é tudo.         . </p><br><h3 id="mnozhestvo-keysov">   </h3><br><p>       .    ,  —  ,   — . ,              : </p><br><ul><li>          . </li><li>      — ,      .    —    . </li></ul><br><p>  —       .          ,          .   —     . </p><br><h2 id="itog">  Sumário </h2><br><p>       Angular,           .     ,   ,        «». </p><br><p>      , Angular       - .    HTTP-, , lazy-loading  .            <a href="https://angular.io/docs"> Angular</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480782/">https://habr.com/ru/post/pt480782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480772/index.html">Razões simples para a inevitabilidade da dívida técnica</a></li>
<li><a href="../pt480774/index.html">Não nginx unificado: hospedagem Ayhor - dash-scratch live</a></li>
<li><a href="../pt480776/index.html">Implantamos o Active Directory por todos os métodos possíveis.</a></li>
<li><a href="../pt480778/index.html">Gerenciamento de gestos: manipulação de sobreposições visuais. Parte 2</a></li>
<li><a href="../pt480780/index.html">Como montar uma ilustração a partir de cubos e pictogramas</a></li>
<li><a href="../pt480786/index.html">Clonagem profunda independente de objetos em JavaScript</a></li>
<li><a href="../pt480788/index.html">Árvore de Natal na linha de comando</a></li>
<li><a href="../pt480790/index.html">"Eficiência de fábrica". Localizando um gargalo e implementando um sistema pull para aumentar a produtividade</a></li>
<li><a href="../pt480792/index.html">Engenharia de Presentes</a></li>
<li><a href="../pt480794/index.html">Um pouco sobre o caso especial da implementação de algoritmos de pesquisa de portas abertas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>