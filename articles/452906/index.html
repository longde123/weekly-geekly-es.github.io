<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏿 🏻 👩🏿‍🤝‍👨🏼 Motores JavaScript: ¿cómo funcionan? Desde la pila de llamadas hasta las promesas, (casi) todo lo que necesita saber 💅🏿 👨🏽‍💻 🔴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Alguna vez te has preguntado cómo los navegadores leen y ejecutan código JavaScript? Parece misterioso, pero en esta publicación puedes tener una ide...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Motores JavaScript: ¿cómo funcionan? Desde la pila de llamadas hasta las promesas, (casi) todo lo que necesita saber</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/452906/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/nm/n6/sdnmn6cuvwusvk4fysdkzvnw9rg.jpeg"></div><br>  ¿Alguna vez te has preguntado cómo los navegadores leen y ejecutan código JavaScript?  Parece misterioso, pero en esta publicación puedes tener una idea de lo que está sucediendo bajo el capó. <br><br>  Comenzamos nuestro viaje al idioma con una excursión al maravilloso mundo de los motores JavaScript. <br><a name="habracut"></a><br>  Abra la consola en Chrome y vaya a la pestaña Fuentes.  Verá varias secciones, y una de las más interesantes se llama <b>Pila de llamadas</b> (en Firefox verá Pila de llamadas cuando coloque un punto de interrupción en el código): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d34/46f/a81/d3446fa81bf753ff80d32e39bcf5778c.png"><br><br>  ¿Qué es una pila de llamadas?  Parece que están sucediendo muchas cosas aquí, incluso por el simple hecho de ejecutar un par de líneas de código.  De hecho, JavaScript no viene en una caja con cada navegador.  Hay un gran componente que compila e interpreta nuestro código JavaScript: es un motor de JavaScript.  Los más populares son V8, se usa en Google Chrome y Node.js, SpiderMonkey en Firefox, JavaScriptCore en Safari / WebKit. <br><br>  Los motores JavaScript de hoy son excelentes ejemplos de ingeniería de software, y será casi imposible hablar sobre todos los aspectos.  Sin embargo, el trabajo principal en la ejecución del código lo hacemos solo unos pocos componentes de los motores: Pila de llamadas (pila de llamadas), Memoria global (memoria global) y Contexto de ejecución (contexto de ejecución).  Listo para conocerlos? <br><br>  Contenido: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Motores JavaScript y memoria global</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Motores JavaScript: ¿cómo funcionan?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contexto de ejecución global y pila de llamadas</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JavaScript es de un solo hilo y otras historias divertidas</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JavaScript asíncrono, cola de devolución de llamada y bucle de eventos</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Callback infierno y promesas ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crear y trabajar con JavaScript Promises</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manejo de errores en promesas de ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ES6 Combinadores de promesa: Promise.all, Promise.allSettled, Promise.any y otros</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Promesas de ES6 y cola de microtask</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Motores JavaScript: ¿cómo funcionan?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Evolución asincrónica: de promesas a asíncrono / espera</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Motores JavaScript: ¿cómo funcionan?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Resumen</a> <br></li></ol><br><a name="1"></a><h2>  1. Motores JavaScript y memoria global </h2><br>  Dije que JavaScript es un lenguaje compilado e interpretado.  Lo creas o no, los motores de JavaScript compilan tus microsegundos de código antes de que se ejecute. <br><br>  Algún tipo de magia, ¿eh?  Esta magia se llama JIT (compilación Just in time).  Solo es un gran tema de discusión, incluso los libros no serán suficientes para describir el trabajo de JIT.  Pero por ahora, omitiremos la teoría y nos centraremos en la fase de ejecución, que no es menos interesante. <br><br>  Para comenzar, mira este código: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; }</code> </pre> <br>  ¿Y si te pregunto cómo se procesa este código en un navegador?  ¿Qué vas a responder?  Puede decir: "el navegador lee el código" o "el navegador ejecuta el código".  En realidad, no todo es tan simple.  Primero, el código no lo lee el navegador, sino el motor.  <b>El motor de JavaScript lee el código</b> y, tan pronto como define la primera línea, coloca un par de enlaces en <b>la memoria global</b> . <br><br>  La memoria global (también llamada montón) es el área en la que el motor de JavaScript almacena variables y declaraciones de funciones.  Y cuando lea el código anterior, aparecerán dos carpetas en la memoria global: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/0a8/a90/11b0a8a904acef9ee7bde8b84cb76873.png"><br><br>  Incluso si el ejemplo contiene solo una variable y una función, imagine que su código JavaScript se ejecuta en un entorno más grande: en un navegador o en Node.js.  En tales entornos, hay muchas funciones y variables predefinidas que se denominan globales.  Por lo tanto, la memoria global contendrá muchos más datos que solo <code>num</code> y <code>pow</code> , tenga en cuenta. <br><br>  Nada se está ejecutando en este momento.  Ahora intentemos ejecutar nuestra función: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Que va a pasar  Y algo interesante sucederá.  Al llamar a la función, el motor de JavaScript resaltará dos secciones: <br><br><ul><li>  Contexto de ejecución global <br></li><li>  Pila de llamadas <br></li></ul><br>  Que son <br><br><a name="2"></a><h2>  2. Motores JavaScript: ¿cómo funcionan?  Contexto de ejecución global y pila de llamadas </h2><br>  Aprendiste cómo el motor de JavaScript lee variables y declaraciones de funciones.  Caen en la memoria global (montón). <br><br>  Pero ahora estamos ejecutando una función de JavaScript, y el motor debería ocuparse de esto.  Como?  Cada motor de JavaScript tiene un <b>componente clave llamado pila de llamadas</b> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Esta es una estructura de datos apilados</a> : se pueden agregar elementos desde arriba, pero no se pueden excluir de la estructura mientras haya otros elementos sobre ellos.  Así es como funcionan las funciones de JavaScript.  En la ejecución, no pueden abandonar la pila de llamadas si hay otra función presente en ella.  Preste atención a esto, ya que este concepto ayuda a comprender la afirmación "JavaScript es de subproceso único". <br><br>  Pero volvamos a nuestro ejemplo.  <b>Cuando se llama a una función, el motor la envía a la pila de llamadas</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b79/118/a43/b79118a430d9daa8af3491138c0cfd2b.png"><br><br>  Me gusta presentar la pila de llamadas como una pila de chips Pringles.  No podemos comer chips del fondo de la pila hasta que comamos los que están arriba.  Afortunadamente, nuestra función es síncrona: es solo una multiplicación que se calcula rápidamente. <br><br>  Al mismo tiempo, el motor coloca el <b>contexto de ejecución global</b> en la memoria, este es el entorno global en el que se ejecuta el código JavaScript.  Así es como se ve: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea8/a33/9c1/ea8a339c120638632b57eb0fb3161254.png"><br><br>  Imagine un contexto de ejecución global en forma de un mar en el que las funciones globales de JavaScript flotan como peces.  Que dulce  Pero esto es solo la mitad de la historia.  ¿Qué pasa si nuestra función tiene variables anidadas o funciones internas? <br><br>  Incluso en el caso simple, como se muestra a continuación, el motor de JavaScript crea un <b>contexto de ejecución local</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fixed = <span class="hljs-number"><span class="hljs-number">89</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Tenga en cuenta que agregué la variable <code>fixed</code> a la función <code>pow</code> .  En este caso, el contexto de ejecución local contendrá una sección para <code>fixed</code> .  No soy muy bueno dibujando rectángulos pequeños dentro de otros rectángulos pequeños, así que usa tu imaginación. <br><br>  Aparecerá un contexto de ejecución local junto a <code>pow</code> , dentro de la sección del rectángulo verde ubicada dentro del contexto de ejecución global.  Imagine también cómo para cada función anidada dentro de la función anidada, el motor crea otros contextos de ejecución local.  ¡Todas estas secciones rectangulares aparecen muy rápidamente!  ¡Como una muñeca que anida! <br><br>  Volvamos a la historia de un solo hilo.  ¿Qué significa esto? <br><br><a name="3"></a><h2>  3. JavaScript es de un solo hilo y otras historias divertidas </h2><br>  Decimos que <b>JavaScript es de un solo subproceso porque solo una pila de llamadas maneja nuestras funciones</b> .  Permítame recordarle que las funciones no pueden abandonar la pila de llamadas si otras funciones esperan ejecución. <br><br>  Esto no es un problema si trabajamos con código síncrono.  Por ejemplo, la suma de dos números es sincrónica y se calcula en microsegundos.  ¿Qué pasa con las llamadas de red y otras interacciones con el mundo exterior? <br><br>  Afortunadamente, los <b>motores de JavaScript están diseñados para funcionar de forma asíncrona de manera predeterminada</b> .  Incluso si pueden ejecutar solo una función a la vez, una entidad externa puede realizar funciones más lentas; en nuestro caso, es un navegador.  Hablaremos de esto a continuación. <br><br>  Al mismo tiempo, sabe que cuando el navegador carga algún tipo de código JavaScript, el motor lee este código línea por línea y realiza los siguientes pasos: <br><br><ul><li>  Pone variables y declaraciones de funciones en la memoria global (montón). <br></li><li>  Envía una llamada a cada función en la pila de llamadas. <br></li><li>  Crea un contexto de ejecución global en el que se ejecutan funciones globales. <br></li><li>  Crea muchos pequeños contextos de ejecución local (si hay variables internas o funciones anidadas). <br></li></ul><br>  Ahora tiene una comprensión básica de la mecánica de sincronización que subyace a todos los motores de JavaScript.  En el próximo capítulo, hablaremos sobre cómo funciona el código asincrónico en JavaScript y por qué funciona de esa manera. <br><br><a name="4"></a><h2>  4. JavaScript asíncrono, cola de devolución de llamada y bucle de eventos </h2><br>  Gracias a la memoria global, el contexto de ejecución y la pila de llamadas, el código JavaScript síncrono se ejecuta en nuestros navegadores.  Pero olvidamos algo.  ¿Qué sucede si necesita ejecutar algún tipo de función asincrónica? <br><br>  Por función asincrónica, me refiero a cada interacción con el mundo exterior, lo que puede llevar algún tiempo completar.  Llamar a la API REST o al temporizador es asíncrono, porque puede llevar segundos ejecutarlos.  Gracias a los elementos disponibles en el motor, podemos procesar tales funciones sin bloquear la pila de llamadas y el navegador.  No olvide que la pila de llamadas puede ejecutar solo una función a la vez, e <b>incluso una función de bloqueo puede detener literalmente el navegador</b> .  Afortunadamente, los motores de JavaScript son inteligentes y, con un poco de ayuda del navegador, pueden resolver las cosas. <br><br>  Cuando ejecutamos una función asincrónica, el navegador la toma y la realiza por nosotros.  Toma un temporizador como este: <br><br><pre> <code class="javascript hljs">setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Estoy seguro de que, aunque ya haya visto <code>setTimeout</code> cientos de veces, es posible que no sepa que <b>esta función no está integrada en JavaScript</b> .  Entonces, cuando apareció JavaScript, no había ninguna función <code>setTimeout</code> en él.  De hecho, es parte de las llamadas API de navegador, una colección de herramientas convenientes que nos proporciona el navegador.  Maravilloso!  Pero, ¿qué significa esto en la práctica?  Dado que <code>setTimeout</code> refiere a la API del navegador, esta función la ejecuta el propio navegador (por un momento aparece en la pila de llamadas, pero se elimina inmediatamente de allí). <br><br>  Después de 10 segundos, el navegador toma la función de devolución de llamada que le pasamos y la coloca en la <b>cola de devolución de llamada</b> .  Por el momento, dos secciones rectangulares más han aparecido en el motor de JavaScript.  Echa un vistazo a este código: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num); setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Ahora nuestro esquema se ve así: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00f/8e2/b33/00f8e2b33a47490117a9e8f6abad23f5.png"><br><br>  <code>setTimeout</code> se ejecuta dentro del contexto del navegador.  Después de 10 segundos, se inicia el temporizador y la función de devolución de llamada está lista para su ejecución.  Pero primero, debe pasar por la cola de devolución de llamada.  Esta es una estructura de datos en forma de una cola y, como su nombre lo indica, es una cola ordenada de funciones. <br><br>  Cada función asincrónica debe pasar por una cola de devolución de llamada antes de llegar a la pila de llamadas.  ¿Pero quién envía las funciones a continuación?  Esto hace que un componente llamado <b>un bucle de eventos</b> . <br><br>  Hasta ahora, el bucle de eventos solo trata una cosa: comprueba si la pila de llamadas está vacía.  Si hay alguna función en la cola de devolución de llamada y si la pila de llamadas está libre, es hora de enviar una devolución de llamada a la pila de llamadas. <br><br>  Después de eso, la función se considera ejecutada.  Este es el esquema general para procesar código asíncrono y síncrono con el motor de JavaScript: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eba/ec9/fec/ebaec9fec5dc1931176371fd4a9f3cbd.png"><br><br>  Digamos que <code>callback()</code> está listo para ejecutarse.  Cuando <code>pow()</code> <b>la pila de llamadas se libera y el bucle de eventos le envía</b> <code>callback()</code> .  ¡Y eso es todo!  Aunque simplifiqué un poco las cosas, si comprende el diagrama anterior, puede comprender todo JavaScript. <br><br>  Recuerde: <b>las API basadas en navegador, las colas de devolución de llamada y los bucles de eventos son los pilares de JavaScript asíncrono</b> . <br><br>  Y si está interesado, puede ver el curioso video "Qué diablos es el ciclo de eventos de todos modos", de Philip Roberts.  Esta es una de las mejores explicaciones para el bucle de eventos. <br><br>  Pero todavía no hemos terminado con el tema asincrónico de JavaScript.  En los siguientes capítulos consideraremos las promesas de ES6. <br><br><a name="5"></a><h2>  5. Callback hell y promesas de ES6 </h2><br>  Las funciones de devolución de llamada se utilizan en JavaScript en todas partes, tanto en código síncrono como asíncrono.  Considere este método: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element * <span class="hljs-number"><span class="hljs-number">2</span></span>; } [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>].map(mapper);</code> </pre><br>  <code>mapper</code> es una función de devolución de llamada que se pasa dentro del <code>map</code> .  El código anterior es síncrono.  Ahora considere este intervalo: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runMeEvery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Ran!'</span></span>); } setInterval(runMeEvery, <span class="hljs-number"><span class="hljs-number">5000</span></span>);</code> </pre> <br>  Este código es asíncrono, porque dentro de <code>setInterval</code> pasamos la devolución de llamada runMeEvery.  Las devoluciones de llamada se utilizan en todo JavaScript, por lo que durante años hemos tenido un problema llamado "infierno de devolución de llamada" - "infierno de devolución de llamada". <br><br>  El término <b>infierno de devolución de llamada</b> en JavaScript se aplica al "estilo" de programación, en el que las devoluciones de llamada están incrustadas en otras devoluciones de llamada que están incrustadas en otras devoluciones de llamada ... Debido a la naturaleza asincrónica, los programadores de JavaScript han caído en esta trampa. <br><br>  Para ser honesto, nunca creé grandes pirámides de devoluciones de llamada.  Quizás porque valoro el código legible y siempre trato de mantener sus principios.  Si golpea el infierno de devolución de llamada, significa que su función hace demasiado. <br><br>  No voy a hablar en detalle sobre el infierno de devolución de llamada, si está interesado, vaya a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">callbackhell.com</a> , donde este problema ha sido investigado en detalle y se han propuesto varias soluciones.  Y hablaremos sobre las <b>promesas de ES6</b> .  Este es un complemento de JavaScript diseñado para resolver el infierno problema de devolución de llamada.  ¿Pero qué son las promesas? <br><br>  <b>Una promesa de JavaScript es una representación de un evento futuro</b> .  Una promesa puede terminar con éxito, o en una jerga de programadores, una promesa será "resuelta" (resuelta).  Pero si la promesa termina con un error, entonces decimos que está en el estado rechazado.  Las promesas también tienen un estado predeterminado: cada nueva promesa comienza en un estado pendiente.  ¿Puedo crear mi propia promesa?  Si  Hablaremos de esto en el próximo capítulo. <br><br><a name="6"></a><h2>  6. Crear y trabajar con promesas de JavaScript </h2><br>  Para crear una nueva promesa, debe llamar al constructor pasándole una función de devolución de llamada.  Solo puede tomar dos parámetros: <code>resolve</code> y <code>reject</code> .  Creemos una nueva promesa que se resolverá en 5 segundos (puede probar los ejemplos en la consola del navegador): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ resolve() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Como puede ver, <code>resolve</code> es una función que llamamos para que la promesa finalice con éxito.  Y <code>reject</code> creará una promesa rechazada: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ reject() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Tenga en cuenta que puede ignorar el <code>reject</code> porque este es el segundo parámetro.  Pero si tiene la intención de utilizar el <code>reject</code> , no <b>puede ignorar la <code>resolve</code></b> .  Es decir, el siguiente código no funcionará y terminará con una promesa permitida: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Can't omit resolve ! const myPromise = new Promise(function(reject){ setTimeout(function(){ reject() }, 5000) });</span></span></code> </pre> <br>  Las promesas no parecen tan útiles en este momento, ¿verdad?  Estos ejemplos no muestran nada al usuario.  Agreguemos algo.  Y las promesas permitidas y rechazadas pueden devolver datos.  Por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); });</code> </pre> <br>  Pero todavía no vemos nada.  <b>Para extraer datos de una promesa, debe asociar la promesa con el método <code>then</code></b> .  Él toma una devolución de llamada (¡qué ironía!), Que recibe los datos actuales: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  Como desarrollador de JavaScript y consumidor del código de otras personas, en su mayoría interactúa con promesas externas.  Los creadores de la biblioteca a menudo envuelven el código heredado en un constructor de Promise, como este: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shinyNewUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do stuff and resolve // or reject });</span></span></code> </pre> <br>  Y si es necesario, también podemos crear y resolver una promesa llamando a <code>Promise.resolve()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ <span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Resolve!'</span></span>}) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(msg));</code> </pre> <br>  Entonces, permíteme recordarte: las promesas de JavaScript son un marcador para un evento que sucederá en el futuro.  Un evento comienza en el estado "esperando una decisión" y puede ser exitoso (permitido, ejecutado) o no exitoso (rechazado).  Una promesa puede devolver datos que se pueden recuperar al adjuntarlos.  En el próximo capítulo, discutiremos cómo lidiar con los errores que provienen de las promesas. <br><br><a name="7"></a><h2>  7. Manejo de errores en promesas de ES6 </h2><br>  El manejo de errores en JavaScript siempre fue fácil, al menos en código síncrono.  Echa un vistazo a un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeAnError(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  El resultado será: <br><br><pre> <code class="javascript hljs">Catching the error! <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate!</code> </pre> <br>  Como se esperaba, el error cayó en el <code>catch</code> .  Ahora prueba la función asincrónica: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setTimeout(makeAnError, <span class="hljs-number"><span class="hljs-number">5000</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  Este código es asíncrono debido a <code>setTimeout</code> .  ¿Qué pasará si lo ejecutamos? <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); ^ <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate! at Timeout.makeAnError [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _onTimeout] (<span class="hljs-regexp"><span class="hljs-regexp">/home/</span></span>valentino/Code/piccolo-javascript/<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.js:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br>  Ahora el resultado es diferente.  El error no fue detectado por el <code>catch</code> , sino que se elevó libremente en la pila.  La razón es que <code>try/catch</code> solo funciona con código síncrono.  Si desea saber más, este problema se trata en detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Afortunadamente, con promesas, podemos manejar los errores asincrónicos como si fueran sincrónicos.  En el último capítulo, dije que llamar a <code>reject</code> conduce a un rechazo de la promesa: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); });</code> </pre> <br>  En este caso, podemos manejar los errores utilizando el controlador de <code>catch</code> tirando (nuevamente) una devolución de llamada: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Además, para crear y rechazar una promesa en el lugar correcto, puede llamar a <code>Promise.reject()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject({<span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Rejected!'</span></span>}).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Permítame recordarle: el <code>then</code> controlador se ejecuta cuando se ejecuta la promesa, y el controlador de <code>catch</code> se ejecuta para las promesas rechazadas.  Pero este no es el final de la historia.  A continuación veremos cómo <code>async/await</code> funciona muy bien con <code>try/catch</code> . <br><br><a name="8"></a><h2>  8. Combinadores de promesas de ES6: Promise.all, Promise.allSettled, Promise.any y otros </h2><br>  Las promesas no están diseñadas para funcionar solas.  Promise API ofrece varios métodos para <b>combinar promesas</b> .  Una de las más útiles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">es Promise.all</a> , toma una matriz de promesas y devuelve una promesa.  El único problema es que Promise.all se rechaza si se rechaza al menos una promesa de la matriz. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Promise.race</a> permite o rechaza tan pronto como una de las promesas de la matriz recibe el estado correspondiente. <br><br>  En versiones más recientes de V8, también se introducirán dos nuevos combinadores: <code>Promise.allSettled</code> y <code>Promise.any</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Promise.any</a> aún se encuentra en una etapa temprana de la funcionalidad propuesta, al momento de escribir este artículo no es compatible.  Sin embargo, en teoría, podrá indicar si se ha ejecutado alguna promesa.  La diferencia con <code>Promise.race</code> es que <b>Promise.any no se rechaza, incluso si se rechaza una de las promesas</b> . <br><br>  <code>Promise.allSettled</code> aún más interesante.  También toma una serie de promesas, pero no se "acorta" si una de las promesas es rechazada.  Es útil cuando necesita verificar si todas las promesas en una matriz han pasado a alguna etapa, independientemente de la presencia de promesas rechazadas.  Se puede considerar lo contrario de <code>Promise.all</code> . <br><br><a name="9"></a><h2>  9. Promesas de ES6 y la cola de microtask </h2><br>  Si recuerda del capítulo anterior, cada función de devolución de llamada asíncrona en JavaScript está en la cola de devolución de llamada antes de que llegue a la pila de llamadas.  Pero las funciones de devolución de llamada pasadas a Promise tienen un destino diferente: son procesadas por la cola de microtask, en lugar de la cola de tareas. <br><br>  Y aquí debe tener cuidado: la <b>cola de microtask precede a la cola de llamadas</b> .  Las devoluciones de llamada de la cola de microtask tienen prioridad cuando el bucle de eventos verifica si hay nuevas devoluciones de llamadas listas para la pila de llamadas. <br><br>  Jake Archibald describe esta mecánica con más detalle en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, microtasks, colas y horarios</a> , excelente lectura. <br><br><a name="10"></a><h2>  10. Motores JavaScript: ¿cómo funcionan?  Evolución asincrónica: de promesas a asíncrono / espera </h2><br>  JavaScript está evolucionando rápidamente y constantemente estamos recibiendo mejoras cada año.  Las promesas parecían un final, pero <b>con ECMAScript 2017 (ES8) apareció una nueva sintaxis: <code>async/await</code></b> . <br><br>  <code>async/await</code> es solo una mejora estilística que llamamos azúcar sintáctico.  <code>async/await</code> no cambia JavaScript de ninguna manera (no olvide que el idioma debe ser compatible con versiones anteriores de los navegadores antiguos y no debe romper el código existente).  Esta es solo una nueva forma de escribir código asincrónico basado en promesas.  Considera un ejemplo.  Arriba, ya guardamos la promesa en el correspondiente <code>then</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data))</code> </pre> <br>  Ahora <b>con <code>async/await</code> podemos procesar el código asincrónico para que para el lector de nuestra lista el código se vea sincrónico</b> .  En lugar de usar <code>then</code> podemos envolver la promesa en una función etiquetada como <code>async</code> , y luego <code>await</code> resultado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); } getData();</code> </pre> <br>  Se ve bien, ¿verdad?  Es curioso que una función asincrónica siempre devuelva una promesa, y nadie puede evitar que haga esto: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } getData().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br>  ¿Qué hay de los errores?  Una de las ventajas de <code>async/await</code> es que esta construcción puede permitirnos usar <code><b>try/catch</b></code> .  Lea la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">introducción al manejo de errores en las funciones asíncronas y sus pruebas</a> . <br><br>  Echemos un vistazo a la promesa nuevamente, en la que manejamos los errores con el controlador <code>catch</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Con funciones asincrónicas, podemos refactorizar así: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// or return the data with return data } catch (error) { console.log(error); } } getData();</span></span></code> </pre> <br>  Sin embargo, no todos han cambiado a este estilo.  <code>try/catch</code> puede complicar su código.  Hay una cosa más a tener en cuenta.  Vea cómo se produce un error dentro de este bloque de <code>try</code> en este código: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>));</code> </pre> <br>  ¿Qué pasa con las dos líneas que se muestran en la consola?  Recuerde que <b><code>try/catch</code> es una construcción sincrónica, y nuestra función asincrónica genera una promesa</b> .  Siguen dos caminos diferentes, como los trenes.     !  ,   <code>throw</code> ,     <code>catch</code>  <code>getData()</code> .      ,     «Catch me if you can»,    «I will run no matter what!». <br><br>      ,  <code>throw</code>   <code>then</code> .   , ,  <code>Promise.reject()</code>  : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } Now the error will be handled <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected: getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will NOT run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>)); <span class="hljs-string"><span class="hljs-string">"Catching err"</span></span> <span class="hljs-comment"><span class="hljs-comment">// output</span></span></code> </pre> <br>   <code>async/await</code>        JavaScript.         . <br><br>   ,       JS-  <code>async/await</code> .    .     ,       <code>async/await</code> —   . <br><br><a name="11"></a><h2> 11. JavaScript-:   ?  </h2><br> JavaScript —     ,   ,    .   JS-: V8,   Google Chrome  Node.js; SpiderMonkey,   Firefox; JavaScriptCore,   Safari. <br><br> JavaScript-   «» :  ,  ,  ,   .      ,      . <br><br> JavaScript-  ,         .        JavaScript:  ,     - ,     (, )    . <br><br>       ECMAScript 2015   .  —   ,         .      .  2017-  <code>async/await</code> :    ,    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452906/">https://habr.com/ru/post/452906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452892/index.html">¿Cómo puede un no programador mudarse a los Estados Unidos? Instrucciones paso a paso.</a></li>
<li><a href="../452894/index.html">Face Anti-Spoofing o tecnológicamente reconoce a un tramposo de mil por cara</a></li>
<li><a href="../452900/index.html">Índices en PostgreSQL - 9 (BRIN)</a></li>
<li><a href="../452902/index.html">Terminando 4 años de entrenamiento como programador, entiendo que estoy lejos de ser un programador</a></li>
<li><a href="../452904/index.html">Cómo se comunican las máquinas: protocolo MQTT</a></li>
<li><a href="../452908/index.html">Selenium WebDriver: métrica de prueba en tiempo real con Grafana e InfluxDB</a></li>
<li><a href="../452910/index.html">Hola Habr! Hola tercon</a></li>
<li><a href="../452914/index.html">ML en Scala con una sonrisa, para aquellos que no tienen miedo a la experimentación</a></li>
<li><a href="../452916/index.html">Levántate y vete. Cirugía de columna: cuándo hacer, qué es peligroso</a></li>
<li><a href="../452922/index.html">Tablas de rejilla CSS flexibles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>