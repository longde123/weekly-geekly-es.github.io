<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüç≥ ‚õ¥Ô∏è üòß .NET: Tools zum Arbeiten mit Multithreading und Asynchronit√§t. Teil 1 üë®üèª‚ÄçüöÄ üï• üíî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich ver√∂ffentliche den Originalartikel √ºber Habr, dessen √úbersetzung im Codingsight- Blog ver√∂ffentlicht ist. 
 Der zweite Teil ist hier verf√ºgbar . 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Tools zum Arbeiten mit Multithreading und Asynchronit√§t. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452094/">  <i>Ich ver√∂ffentliche den Originalartikel √ºber Habr, dessen √úbersetzung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codingsight-</a> Blog ver√∂ffentlicht ist.</i> <br>  <i>Der zweite Teil ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verf√ºgbar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a></i> <br><br>  Die Notwendigkeit, etwas asynchron zu tun, ohne hier und jetzt auf das Ergebnis zu warten, oder viel Arbeit zwischen mehreren Einheiten zu teilen, die es ausf√ºhren, war schon vor dem Aufkommen der Computer.  Mit ihrem Aussehen ist ein solches Bed√ºrfnis sehr greifbar geworden.  Jetzt, im Jahr 2019, tippen Sie diesen Artikel auf einem Laptop mit einem Intel Core-Prozessor mit 8 Kernen, auf dem nicht hundert Prozesse gleichzeitig funktionieren, sondern noch mehr Threads.  Daneben liegt ein leicht angeschlagenes Telefon, das vor ein paar Jahren gekauft wurde und einen 8-Kern-Prozessor an Bord hat.  Die thematischen Ressourcen sind voll von Artikeln und Videos, in denen ihre Autoren die diesj√§hrigen Flaggschiff-Smartphones bewundern, auf denen sie 16-Kern-Prozessoren einsetzen.  F√ºr weniger als 20 US-Dollar pro Stunde bietet MS Azure eine virtuelle Maschine mit 128 Kernprozessoren und 2 TB RAM.  Leider ist es unm√∂glich, diese Leistung zu maximieren und einzud√§mmen, ohne das Zusammenspiel der Str√∂mungen steuern zu k√∂nnen. <br><a name="habracut"></a><br><h3>  Terminologie </h3><br>  <b>Prozess</b> - Ein Betriebssystemobjekt, ein isolierter Adressraum, enth√§lt Threads. <br>  <b>Thread (Thread)</b> - Ein Betriebssystemobjekt, die kleinste Ausf√ºhrungseinheit, Teil eines Prozesses, Threads, die Speicher und andere Ressourcen innerhalb des Prozesses gemeinsam nutzen. <br>  <b>Multitasking</b> ist eine Betriebssystemfunktion, mit der mehrere Prozesse gleichzeitig ausgef√ºhrt werden k√∂nnen <br>  <b>Multicore</b> - eine Eigenschaft des Prozessors, die F√§higkeit, mehrere Kerne f√ºr die Datenverarbeitung zu verwenden <br>  <b>Multiprocessing</b> - eine Eigenschaft eines Computers, die F√§higkeit, gleichzeitig physisch mit mehreren Prozessoren zu arbeiten <br>  <b>Multithreading</b> ist eine Eigenschaft eines Prozesses, die F√§higkeit, die Datenverarbeitung auf mehrere Threads zu verteilen. <br>  <b>Parallelit√§t</b> - mehrere Aktionen gleichzeitig pro Zeiteinheit ausf√ºhren <br>  <b>Asynchronit√§t</b> - Ausf√ºhrung einer Operation, ohne auf das Ende dieser Verarbeitung zu warten. Das Ergebnis der Ausf√ºhrung kann sp√§ter verarbeitet werden. <br><br><h3>  Metapher </h3><br>  Nicht alle Definitionen sind gut und einige bed√ºrfen einer zus√§tzlichen Erkl√§rung. Daher werde ich der formal eingef√ºhrten Terminologie eine Metapher f√ºr das Kochen des Fr√ºhst√ºcks hinzuf√ºgen.  Das Fr√ºhst√ºck in dieser Metapher zu kochen ist ein Prozess. <br><br>  Morgens beim Kochen koche ich ( <b>CPU</b> ) in die K√ºche ( <b>Computer</b> ).  Ich habe 2 H√§nde ( <b>Kerne</b> ).  Die K√ºche verf√ºgt √ºber eine Reihe von Ger√§ten ( <b>IO</b> ): Backofen, Wasserkocher, Toaster, K√ºhlschrank.  Ich schalte das Gas ein, stelle eine Pfanne darauf und gie√üe √ñl hinein, ohne zu warten, bis es sich erw√§rmt ( <b>asynchron, Non-Blocking-IO-Wait</b> ). Ich nehme die Eier aus dem K√ºhlschrank, zerbreche sie in einen Teller und schlage sie dann mit einer Hand ( <b>Faden Nr. 1)</b> ) und der zweite ( <b>Thread # 2</b> ) Ich halte die Platte (Shared Resource).  Jetzt w√ºrde ich immer noch den Wasserkocher einschalten, aber es sind nicht gen√ºgend H√§nde vorhanden ( <b>Fadenhunger</b> ). W√§hrend dieser Zeit wird die Pfanne erhitzt (Verarbeitung des Ergebnisses), wo ich gie√üe, was ich geschlagen habe.  Ich greife nach dem Wasserkocher und schalte ihn ein und beobachte dumm, wie das Wasser darin kocht ( <b>Blocking-IO-Wait</b> ), obwohl ich den Teller w√§hrend dieser Zeit waschen konnte, wo ich das Omelett schlug. <br><br>  Ich habe ein Omelett mit nur 2 H√§nden gekocht, aber ich habe nicht mehr, aber gleichzeitig wurden 3 Operationen ausgef√ºhrt, als ein Omelett geschlagen wurde: ein Omelett schlagen, einen Teller halten, eine Pfanne erhitzen. Die CPU ist der schnellste Teil des Computers, E / A ist das h√§ufiger verlangsamt alles, so oft ist eine effektive L√∂sung, etwas CPU zu nehmen, w√§hrend Daten von E / A empfangen werden. <br><br>  Fortsetzung der Metapher: <br><br><ul><li>  Wenn ich bei der Zubereitung eines Omeletts auch versuchen w√ºrde, mich umzuziehen, w√§re dies ein Beispiel f√ºr Multitasking.  Eine wichtige Nuance: Computer sind damit viel besser als Menschen. </li><li>  Eine K√ºche mit mehreren K√∂chen, beispielsweise in einem Restaurant, ist ein Multi-Core-Computer. </li><li>  Viele Food Court Restaurants in einem Einkaufszentrum - Rechenzentrum </li></ul><br><h3>  .NET Tools </h3><br>  Bei der Arbeit mit Threads ist .NET wie bei vielen anderen Dingen gut.  Mit jeder neuen Version pr√§sentiert er immer mehr neue Werkzeuge f√ºr die Arbeit mit ihnen, neue Abstraktionsebenen √ºber Betriebssystem-Threads.  Bei der Arbeit mit der Konstruktion von Abstraktionen verwenden die Framework-Entwickler den Ansatz, der die M√∂glichkeit l√§sst, bei der Verwendung von Abstraktionen auf hoher Ebene eine oder mehrere Ebenen darunter zu bleiben.  In den meisten F√§llen ist dies nicht erforderlich. Dar√ºber hinaus besteht die M√∂glichkeit, dass eine Schrotflinte in den Fu√ü geschossen wird. In seltenen F√§llen ist dies jedoch die einzige M√∂glichkeit, ein Problem zu l√∂sen, das auf der aktuellen Abstraktionsebene nicht gel√∂st werden kann. <br><br>  Mit Tools meine ich sowohl die Programmschnittstellen (APIs), die vom Framework und von Paketen von Drittanbietern bereitgestellt werden, als auch eine vollst√§ndige Softwarel√∂sung, die die Suche nach Problemen im Zusammenhang mit Multithread-Code vereinfacht. <br><br><h4>  Stream starten </h4><br>  Die Thread-Klasse, die grundlegendste Klasse in .NET f√ºr die Arbeit mit Threads.  Der Konstruktor akzeptiert einen von zwei Delegaten: <br><br><ul><li>  ThreadStart - Keine Parameter </li><li>  ParametrizedThreadStart - mit einem Parameter vom Typ Objekt. </li></ul><br>  Der Delegat wird nach dem Aufruf der Start-Methode im neu erstellten Thread ausgef√ºhrt. Wenn ein Delegat vom Typ ParametrizedThreadStart an den Konstruktor √ºbergeben wurde, muss ein Objekt an die Start-Methode √ºbergeben werden.  Dieser Mechanismus wird ben√∂tigt, um lokale Informationen in den Stream zu √ºbertragen.  Es ist anzumerken, dass das Erstellen eines Threads eine teure Operation ist und der Thread selbst ein schweres Objekt ist, zumindest weil dem Stapel 1 MB Speicher zugewiesen ist und eine Interaktion mit der Betriebssystem-API erforderlich ist. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(...).Start(...);</code> </pre> <br>  Die ThreadPool-Klasse repr√§sentiert das Konzept eines Pools.  In .NET ist der Thread-Pool eine technische Arbeit, und Microsoft-Entwickler haben gro√üe Anstrengungen unternommen, damit er in einer Vielzahl von Szenarien optimal funktioniert. <br><br>  <b>Allgemeines Konzept:</b> <br><br>  <i>Von Anfang an erstellt die Anwendung im Hintergrund mehrere Threads in Reserve und bietet die M√∂glichkeit, sie zu verwenden.</i>  <i>Wenn Threads h√§ufig und in gro√üer Anzahl verwendet werden, wird der Pool erweitert, um die Anforderungen des aufrufenden Codes zu erf√ºllen.</i>  <i>Wenn zum richtigen Zeitpunkt keine freien Flows im Pool vorhanden sind, wird entweder auf die R√ºckkehr eines der Flows gewartet oder ein neuer erstellt.</i>  <i>Daraus folgt, dass der Thread-Pool f√ºr einige kurze Aktionen gro√üartig und f√ºr Vorg√§nge, die als Dienst in der gesamten Anwendung ausgef√ºhrt werden, schlecht geeignet ist.</i> <i><br><br></i>  <i>Um einen Thread aus dem Pool zu verwenden, gibt es eine QueueUserWorkItem-Methode, die einen WaitCallback-Delegaten akzeptiert, der dieselbe Signatur wie ParametrizedThreadStart hat, und der an ihn √ºbergebene Parameter f√ºhrt dieselbe Funktion aus.</i> <br><br><pre> <code class="cs hljs">ThreadPool.QueueUserWorkItem(...);</code> </pre><br>  Die weniger bekannte Thread-Pool-Methode RegisterWaitForSingleObject wird verwendet, um nicht blockierende E / A-Operationen zu organisieren.  Der an diese Methode √ºbergebene Delegat wird aufgerufen, wenn der an die Methode √ºbergebene WaitHandle "Freigegeben" ist. <br><br><pre> <code class="cs hljs">ThreadPool.RegisterWaitForSingleObject(...)</code> </pre><br>  .NET verf√ºgt √ºber einen Stream-Timer und unterscheidet sich von WinForms / WPF-Timern dadurch, dass sein Handler in einem Stream aus dem Pool aufgerufen wird. <br><br><pre> <code class="cs hljs">System.Threading.Timer</code> </pre><br>  Es gibt auch eine ziemlich exotische M√∂glichkeit, einen Delegaten aus dem Pool an den Thread zu senden - die BeginInvoke-Methode. <br><br><pre> <code class="cs hljs">DelegateInstance.BeginInvoke</code> </pre><br>  Ich m√∂chte auch auf die Weitergabe einer Funktion eingehen, die viele der oben genannten Methoden aufruft - CreateThread von der Kernel32.dll Win32-API.  Dank des Mechanismus externer Methoden gibt es eine M√∂glichkeit, diese Funktion aufzurufen.  Ich habe eine solche Herausforderung nur einmal in einem schrecklichen Beispiel f√ºr Legacy-Code gesehen, und die Motivation des Autors, genau das zu tun, ist mir immer noch ein R√§tsel. <br><br><pre> <code class="cs hljs">Kernel32.dll CreateThread</code> </pre><br><h4>  Anzeigen und Debuggen von Threads </h4><br>  Die Threads, die Sie pers√∂nlich von allen Komponenten von Drittanbietern und dem .NET-Pool erstellt haben, k√∂nnen im Threads Visual Studio-Fenster angezeigt werden.  In diesem Fenster werden Informationen zu Flows nur angezeigt, wenn sich die Anwendung im Debugging befindet und sich im Unterbrechungsmodus (Unterbrechungsmodus) befindet.  Hier k√∂nnen Sie bequem die Stapelnamen und Priorit√§ten jedes Threads anzeigen und das Debuggen auf einen bestimmten Thread umstellen.  Mit der Priority-Eigenschaft der Thread-Klasse k√∂nnen Sie die Priorit√§t des Threads festlegen, die OC und CLR als Empfehlung beim Aufteilen der CPU-Zeit zwischen Threads wahrnehmen. <br><br><img src="https://habrastorage.org/webt/ow/kq/i5/owkqi5zdx2m8oe7iava3q1mikri.png"><br><br><h4>  Task parallele Bibliothek </h4><br>  Die Task Parallel Library (TPL) wurde in .NET 4.0 angezeigt.  Jetzt ist es der Standard und das Hauptwerkzeug f√ºr die Arbeit mit Asynchronit√§t.  Jeder Code, der einen √§lteren Ansatz verwendet, wird als Legacy betrachtet.  Die Grundeinheit von TPL ist die Task-Klasse aus dem Namespace System.Threading.Tasks.  Aufgabe ist eine Abstraktion √ºber einen Thread.  Mit der neuen Version von C # haben wir eine elegante M√∂glichkeit, mit Task-async / await-Operatoren zu arbeiten.  Diese Konzepte erm√∂glichten es, asynchronen Code so zu schreiben, als ob er einfach und synchron w√§re. Dies erm√∂glichte es sogar Personen mit wenig Verst√§ndnis f√ºr die interne K√ºche von Threads, Anwendungen zu schreiben, die sie verwenden, Anwendungen, die bei langen Vorg√§ngen nicht einfrieren.  Die Verwendung von async / await ist ein Thema f√ºr einen oder sogar mehrere Artikel, aber ich werde versuchen, ein paar S√§tze auf den Punkt zu bringen: <br><br><ul><li>  async ist ein Modifikator der Methode, die Task oder void zur√ºckgibt </li><li>  und warten ist die nicht blockierende Warteanweisung der Aufgabe. </li></ul><br>  Noch einmal: Der Operator await gibt im allgemeinen Fall (es gibt Ausnahmen) den aktuellen Ausf√ºhrungsthread weiter frei, und wenn die Task ihre Ausf√ºhrung beendet hat, kann der Thread (tats√§chlich ist es korrekter, den Kontext zu sagen, aber dazu sp√§ter mehr) die Methode weiter fortsetzen.  In .NET wird dieser Mechanismus auf die gleiche Weise wie die Ertragsr√ºckgabe implementiert, wenn eine geschriebene Methode in eine ganze Klasse umgewandelt wird, die eine Zustandsmaschine ist und abh√§ngig von diesen Zust√§nden in separaten Teilen ausgef√ºhrt werden kann.  Jeder Interessierte kann jeden einfachen Code mit asyn / await schreiben, kompilieren und die Assembly mit JetBrains dotPeek mit aktiviertem Compiler Generated Code anzeigen. <br><br>  Ber√ºcksichtigen Sie die Optionen zum Starten und Verwenden von Task.  Anhand des folgenden Codebeispiels erstellen wir eine neue Aufgabe, die nichts N√ºtzliches tut ( <i>Thread.Sleep (10000)</i> ), aber im wirklichen Leben sollte es sich um eine komplexe CPU-Arbeit handeln. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCO = System.Threading.Tasks.TaskCreationOptions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VoidAsyncMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancellationSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.StartNew( <span class="hljs-comment"><span class="hljs-comment">// Code of action will be executed on other context () =&gt; Thread.Sleep(10000), cancellationSource.Token, TCO.LongRunning | TCO.AttachedToParent | TCO.PreferFairness, scheduler ); // Code after await will be executed on captured context }</span></span></code> </pre><br>  Die Aufgabe wird mit einer Reihe von Optionen erstellt: <br><br><ul><li>  LongRunning ist ein Hinweis darauf, dass die Aufgabe nicht schnell erledigt wird. Daher ist es m√∂glicherweise sinnvoll, nicht einen Thread aus dem Pool zu entfernen, sondern einen separaten Thread f√ºr diese Aufgabe zu erstellen, um die anderen nicht zu besch√§digen. </li><li>  AttachedToParent - Aufgaben k√∂nnen in einer Hierarchie angeordnet werden.  Wenn diese Option verwendet wurde, befindet sich die Aufgabe m√∂glicherweise in einem Zustand, in dem sie sich selbst abgeschlossen hat und darauf wartet, dass die untergeordneten Elemente abgeschlossen werden. </li><li>  PreferFairness - bedeutet, dass es sch√∂n w√§re, die zuvor zur Ausf√ºhrung gesendeten Aufgaben vor den sp√§ter gesendeten auszuf√ºhren.  Dies ist jedoch nur eine Empfehlung und das Ergebnis kann nicht garantiert werden. </li></ul><br>  Der zweite Parameter der Methode hat CancellationToken √ºbergeben.  Um die Stornierung einer Operation nach ihrem Start korrekt zu verarbeiten, muss der ausgef√ºhrte Code mit Statuspr√ºfungen von CancellationToken gef√ºllt werden.  Wenn keine √úberpr√ºfungen vorhanden sind, kann die f√ºr das CancellationTokenSource-Objekt aufgerufene Cancel-Methode die Ausf√ºhrung der Task erst vor dem Start stoppen. <br><br>  Der letzte Parameter hat das Scheduler-Objekt vom Typ TaskScheduler √ºbergeben.  Diese Klasse und ihre Nachkommen dienen dazu, die Strategien f√ºr die Verteilung von Task'ov nach Thread zu steuern. Standardm√§√üig wird Task in einem zuf√§lligen Thread aus dem Pool ausgef√ºhrt. <br><br>  Der Warteoperator wird auf die erstellte Aufgabe angewendet. Dies bedeutet, dass der danach geschriebene Code, falls vorhanden, im selben Kontext ausgef√ºhrt wird (h√§ufig bedeutet dies, dass er sich im selben Thread befindet) wie der Code vor dem Warten. <br><br>  Die Methode ist als async void markiert. Dies bedeutet, dass Sie den Operator await verwenden k√∂nnen, der aufrufende Code jedoch nicht auf die Ausf√ºhrung warten kann.  Wenn diese Funktion erforderlich ist, sollte die Methode Task zur√ºckgeben.  Als asynchron ung√ºltig gekennzeichnete Methoden sind weit verbreitet: In der Regel handelt es sich dabei um Ereignishandler oder andere Methoden, die nach dem Prinzip von Feuer und Vergessen arbeiten.  Wenn Sie nicht nur die M√∂glichkeit geben m√ºssen, bis zum Abschluss der Ausf√ºhrung zu warten, sondern auch das Ergebnis zur√ºckgeben m√ºssen, m√ºssen Sie Task verwenden. <br><br>  Bei der Aufgabe, die die StartNew-Methode zur√ºckgegeben hat, k√∂nnen Sie jedoch wie bei jeder anderen die ConfigureAwait-Methode mit dem Parameter false aufrufen. Die Ausf√ºhrung nach dem Warten wird dann nicht im erfassten, sondern in einem beliebigen Kontext fortgesetzt.  Dies sollte immer dann erfolgen, wenn der Ausf√ºhrungskontext nach dem Warten f√ºr den Code nicht wichtig ist.  Es ist auch eine Empfehlung von MS beim Schreiben von Code, dass dieser in einer Bibliotheksform verpackt wird. <br><br>  Lassen Sie uns etwas n√§her darauf eingehen, wie Sie bis zum Abschluss der Aufgabe warten k√∂nnen.  Unten finden Sie einen Beispielcode mit Kommentaren, wenn das Warten bedingt gut und bedingt schlecht durchgef√ºhrt wird. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnotherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AsyncMethod(); <span class="hljs-comment"><span class="hljs-comment">// good result = AsyncMethod().Result; // bad AsyncMethod().Wait(); // bad IEnumerable&lt;Task&gt; tasks = new Task[] { AsyncMethod(), OtherAsyncMethod() }; await Task.WhenAll(tasks); // good await Task.WhenAny(tasks); // good Task.WaitAll(tasks.ToArray()); // bad }</span></span></code> </pre><br>  Im ersten Beispiel warten wir, bis die Aufgabe abgeschlossen ist, und ohne den aufrufenden Thread zu blockieren, kehren wir erst dann zur Verarbeitung des Ergebnisses zur√ºck, wenn es bereits vorhanden ist, bis der aufrufende Thread sich selbst √ºberlassen bleibt. <br><br>  In der zweiten Option blockieren wir den aufrufenden Thread, bis das Ergebnis der Methode berechnet ist.  Dies ist nicht nur deshalb schlecht, weil wir den Thread, eine so wertvolle Ressource des Programms, mit einfachem Leerlauf genommen haben, sondern auch, weil wir einen Deadlock bekommen, wenn der von uns aufgerufene Methodencode wartet und der Synchronisationskontext die R√ºckkehr zum aufrufenden Thread nach dem Warten beinhaltet : Der aufrufende Thread wartet, bis das Ergebnis der asynchronen Methode berechnet ist. Die asynchrone Methode versucht vergeblich, ihre Ausf√ºhrung im aufrufenden Thread fortzusetzen. <br><br>  Ein weiterer Nachteil dieses Ansatzes ist die komplizierte Fehlerbehandlung.  Tatsache ist, dass Fehler im asynchronen Code bei Verwendung von async / await sehr einfach zu behandeln sind - sie verhalten sich so, als ob der Code synchron w√§re.  Wenn wir <s>Exorzismus und</s> synchrone Erwartung auf Task anwenden, wird die urspr√ºngliche Ausnahme zu einer AggregateException, d. H.  Um eine Ausnahme zu behandeln, m√ºssen Sie den InnerException-Typ untersuchen und die if-Kette in einen catch-Block schreiben oder den catch when-Konstrukt anstelle der bekannteren catch-Blockkette in C # verwenden. <br><br>  Das dritte und das letzte Beispiel sind aus demselben Grund ebenfalls als schlecht markiert und enthalten dieselben Probleme. <br><br>  Wenn die Methoden WhenAny und WhenAll √§u√üerst praktisch sind, um auf eine Gruppe von Task'ov zu warten, wickeln sie eine Gruppe von Task'ov in eine Gruppe ein, die entweder bei der ersten Operation von Task'a aus der Gruppe funktioniert oder wenn alle ihre Ausf√ºhrung beendet haben. <br><br><h4>  Durchflussstopp </h4><br>  Aus verschiedenen Gr√ºnden kann es erforderlich sein, den Stream nach dem Start anzuhalten.  Es gibt verschiedene M√∂glichkeiten, dies zu tun.  Die Thread-Klasse verf√ºgt √ºber zwei Methoden mit entsprechenden Namen - <b>Abort</b> und <b>Interrupt</b> .  Der erste wird nicht zur Verwendung empfohlen, da  Nachdem es zu einem beliebigen Zeitpunkt aufgerufen wurde, wird w√§hrend der Verarbeitung einer Anweisung eine <b>ThreadAbortedException</b> ausgel√∂st.  Sie erwarten nicht, dass eine solche Ausnahme beim Inkrementieren einer Ganzzahlvariablen abst√ºrzt, oder?  Bei dieser Methode ist dies eine sehr reale Situation.  Wenn Sie verhindern m√∂chten, dass die CLR eine solche Ausnahme in einem bestimmten Abschnitt des Codes <b>ausl√∂st</b> , k√∂nnen Sie sie in Aufrufe von <b>Thread.BeginCriticalRegion</b> , <b>Thread.EndCriticalRegion einschlie√üen</b> .  Jeder Code, der in einen finally-Block geschrieben wird, wird mit solchen Aufrufen umbrochen.  Aus diesem Grund finden Sie im Darm des Framework-Codes Bl√∂cke mit einem leeren Versuch, aber schlie√ülich nicht mit einem leeren.  Microsoft empfiehlt daher nicht, diese Methode zu verwenden, da sie nicht in den .net-Kern aufgenommen wurde. <br><br>  Die Interrupt-Methode funktioniert vorhersehbarer.  Es kann einen Thread mit Ausnahme von <b>ThreadInterruptedException</b> nur <b>unterbrechen</b> , wenn sich der Thread im Ruhezustand befindet.  In diesem Zustand wird es angehalten, w√§hrend auf WaitHandle gewartet, gesperrt oder Thread.Sleep aufgerufen wird. <br><br>  Beide oben beschriebenen Optionen sind schlecht f√ºr ihre Unvorhersehbarkeit.  Die L√∂sung besteht darin, die <b>CancellationToken-</b> Struktur und die <b>CancellationTokenSource-</b> Klasse zu verwenden.  Das Fazit lautet: Eine Instanz der Klasse CancellationTokenSource wird erstellt, und nur die Person, deren Eigent√ºmer sie ist, kann den Vorgang durch Aufrufen der <b>Cancel-</b> Methode stoppen.  Nur das CancellationToken wird an die Operation selbst √ºbergeben.  Besitzer des CancellationToken k√∂nnen den Vorgang nicht selbst abbrechen, sondern nur pr√ºfen, ob der Vorgang abgebrochen wurde.  Zu diesem <b>Zweck</b> gibt es eine boolesche Eigenschaft <b>IsCancellationRequested</b> und die <b>ThrowIfCancelRequested-</b> Methode.  Letzteres <b>l√∂st</b> eine <b>TaskCancelledException aus,</b> wenn die Cancel-Methode f√ºr die abgebrochene CancellationToken-Instanz der CancellationTokenSource aufgerufen wird.  Und diese Methode empfehle ich.  Dies ist besser als die vorherigen Optionen, da Sie die vollst√§ndige Kontrolle dar√ºber erlangen, an welchen Punkten der Ausnahmevorgang unterbrochen werden kann. <br><br>  Die grausamste Option, um den Thread zu stoppen, ist das Aufrufen der Win32-API-Funktion TerminateThread.  Das Verhalten der CLR nach dem Aufruf dieser Funktion kann unvorhersehbar sein.  In MSDN wird √ºber diese Funktion Folgendes geschrieben: <i>‚ÄûTerminateThread ist eine gef√§hrliche Funktion, die nur in den extremsten F√§llen verwendet werden sollte.</i>  <i>‚Äû</i> <br><br><h4>  Konvertieren Sie die Legacy-API mithilfe der FromAsync-Methode in eine aufgabenbasierte API </h4><br>  Wenn Sie das Gl√ºck haben, an einem Projekt zu arbeiten, das nach der Einf√ºhrung der Aufgaben gestartet wurde und f√ºr die meisten Entwickler keinen stillen Horror mehr verursacht, m√ºssen Sie sich nicht mit vielen alten APIs befassen, sowohl mit Drittanbietern als auch mit solchen, die Ihr Team in der Vergangenheit gefoltert hat.  Gl√ºcklicherweise hat sich das .NET Framework-Entwicklungsteam um uns gek√ºmmert, obwohl das Ziel vielleicht darin bestand, auf uns selbst aufzupassen.  Wie auch immer, .NET verf√ºgt √ºber eine Reihe von Tools, mit denen Sie Code, der in alten asynchronen Programmierans√§tzen geschrieben wurde, problemlos in einen neuen konvertieren k√∂nnen.  Eine davon ist die FromAsync-Methode von TaskFactory.  Anhand des folgenden Codebeispiels verpacke ich die alten asynchronen Methoden der WebRequest-Klasse mit dieser Methode in Task. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> state = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; WebRequest wr = WebRequest.CreateHttp(<span class="hljs-string"><span class="hljs-string">"http://github.com"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.FromAsync( wr.BeginGetResponse, we.EndGetResponse );</code> </pre><br>  <i>Dies ist nur ein Beispiel, und es ist unwahrscheinlich, dass Sie dies mit integrierten Typen tun, aber in jedem alten Projekt wimmelt es nur so von BeginDoSomething-Methoden, die IAsyncResult- und EndDoSomething-Methoden zur√ºckgeben, die dies akzeptieren.</i> <br><br><h4>  Konvertieren Sie die Legacy-API mithilfe der TaskCompletionSource-Klasse in Task Based </h4><br>  Ein weiteres wichtiges Werkzeug ist die <b>TaskCompletionSource-</b> Klasse.  In Bezug auf Funktionen, Zweck und Funktionsprinzip kann es die RegisterWaitForSingleObject-Methode irgendwie an die ThreadPool-Klasse erinnern, √ºber die ich oben geschrieben habe.  Mit dieser Klasse k√∂nnen Sie alte asynchrone APIs einfach und bequem in Task einbinden. <br><br>  <i>Sie werden sagen, dass ich bereits √ºber die FromAsync-Methode der TaskFactory-Klasse gesprochen habe, die f√ºr diese Zwecke vorgesehen ist.</i>  <i>Hier m√ºssen wir uns an die gesamte Geschichte der Entwicklung von asynchronen Modellen in .net erinnern, die Microsoft seit 15 Jahren anbietet: Vor dem Task-Based Asynchronous Pattern (TAP) gab es Asynchronous Programming Pattern (APP), bei dem es um <b>Begin</b> DoSomething-Methoden ging, die <b>IAsyncResult-</b> und <b>End</b> DoSomething-Methoden zur√ºckgeben, die dies akzeptieren Die FromAsync-Methode ist f√ºr das Erbe dieser Jahre in Ordnung, wurde jedoch im Laufe der Zeit durch ein ereignisbasiertes asynchrones Muster (Event Based Asynchronous Pattern, <b>EAP</b> ) ersetzt, bei dem davon ausgegangen wurde, dass ein Ereignis ausgel√∂st wird, wenn der asynchrone Vorgang abgeschlossen ist.</i> <br><br>  TaskCompletionSource eignet sich hervorragend zum Einschlie√üen von Task- und Legacy-APIs, die auf dem Ereignismodell basieren.  Das Wesentliche seiner Arbeit ist folgender: Ein Objekt dieser Klasse hat eine √∂ffentliche Eigenschaft vom Typ Task, deren Status √ºber die Methoden SetResult, SetException usw. der TaskCompletionSource-Klasse gesteuert werden kann.  An Stellen, an denen der Operator "Warten" auf diese Aufgabe angewendet wurde, wird er abh√§ngig von der auf die TaskCompletionSource angewendeten Methode mit einer Ausnahme ausgef√ºhrt oder st√ºrzt ab.  Wenn immer noch nicht alles klar ist, schauen wir uns dieses Codebeispiel an, in dem eine alte EAP-API mithilfe von TaskCompletionSource in Task eingeschlossen ist: Wenn das Ereignis ausgel√∂st wird, wird die Task in den Status "Abgeschlossen" versetzt, und die Methode, mit der der Operator "Warten" auf diese Task angewendet wurde, setzt die Ausf√ºhrung fort das <b>Ergebnisobjekt erhalten</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SomeApiInstance someApiObj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Result&gt;(); someApiObj.Done += result =&gt; completionSource.SetResult(result); someApiObj.Do(); result completionSource.Task; }</code> </pre><br><h4>  Tipps und Tricks zu TaskCompletionSource </h4><br>  Das Umschlie√üen √§lterer APIs ist nicht alles, was Sie mit TaskCompletionSource tun k√∂nnen.  Die Verwendung dieser Klasse er√∂ffnet eine interessante M√∂glichkeit, verschiedene APIs f√ºr Aufgaben zu entwerfen, die keine Threads belegen.  Und der Fluss ist, wie wir uns erinnern, eine teure Ressource und ihre Anzahl ist begrenzt (haupts√§chlich durch RAM).  Diese Einschr√§nkung l√§sst sich leicht erreichen, indem beispielsweise eine geladene Webanwendung mit komplexer Gesch√§ftslogik entwickelt wird.  Betrachten Sie die M√∂glichkeiten, √ºber die ich die Implementierung eines Tricks wie Long-Polling spreche. <br><br>  <i>Kurz gesagt, der Kern des Tricks ist folgender: Sie m√ºssen Informationen von der API √ºber einige Ereignisse abrufen, die auf ihrer Seite auftreten, w√§hrend die API aus irgendeinem Grund das Ereignis nicht melden kann, sondern nur den Status zur√ºckgeben kann.</i>  <i>Ein Beispiel hierf√ºr sind alle APIs, die vor WebSocket oder wenn es aus irgendeinem Grund nicht m√∂glich ist, diese Technologie zu verwenden, auf HTTP basieren.</i>  <i>Der Client kann den HTTP-Server fragen.</i>  <i>Ein HTTP-Server kann selbst keine Kommunikation mit einem Client provozieren.</i>  <i>Eine einfache L√∂sung besteht darin, den Server nach Timer abzufragen. Dies f√ºhrt jedoch zu einer zus√§tzlichen Belastung des Servers und einer zus√§tzlichen Verz√∂gerung eines durchschnittlichen TimerInterval / 2. Um dies zu umgehen, wurde ein Trick namens Long Polling erfunden, bei dem die Antwort vom Server bis zum Ablauf des Timeouts oder verz√∂gert wird ein Ereignis wird passieren.</i>  <i>Wenn ein Ereignis aufgetreten ist, wird es verarbeitet. Wenn nicht, wird die Anforderung erneut gesendet.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!eventOccures &amp;&amp; !timeoutExceeded) { CheckTimout(); CheckEvent(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Aber eine solche L√∂sung wird sich schrecklich zeigen, sobald die Anzahl der Kunden, die auf die Veranstaltung warten, steigt, weil  Jeder dieser Kunden nimmt im Vorgriff auf das Ereignis einen ganzen Strom auf.  Ja, und wir erhalten eine zus√§tzliche Verz√∂gerung von 1 ms beim Ausl√∂sen des Ereignisses. Meistens ist dies nicht signifikant, aber warum sollte die Software schlechter als m√∂glich sein?  Wenn Sie Thread.Sleep (1) entfernen, laden wir vergeblich einen Prozessorkern zu 100% im Leerlauf und drehen uns in einem nutzlosen Zyklus.  Mit TaskCompletionSource k√∂nnen Sie diesen Code einfach wiederholen und alle oben genannten Probleme l√∂sen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LongPollingApi</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TaskCompletionSource&lt;Msg&gt;&gt; tasks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Msg&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptMessageAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duration</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Msg&gt;(); tasks[userId] = cs; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(Task.Delay(duration), cs.Task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cs.Task.IsCompleted ? cs.Task.Result : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, Msg m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tasks.TryGetValue(userId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource)) completionSource.SetResult(m); } }</code> </pre><br>  <i>Dieser Code ist nicht produktionsbereit, sondern nur eine Demo.</i>  <i>Um es in realen F√§llen zu verwenden, m√ºssen Sie zumindest die Situation behandeln, in der eine Nachricht zu einem Zeitpunkt eintrifft, zu dem niemand sie erwartet: In diesem Fall sollte die AsseptMessageAsync-Methode eine bereits abgeschlossene Aufgabe zur√ºckgeben.</i>  <i>Wenn dieser Fall am h√§ufigsten auftritt, k√∂nnen Sie √ºber die Verwendung von ValueTask nachdenken.</i> <br><br>  Nach Erhalt einer Anforderung f√ºr eine Nachricht erstellen wir TaskCompletionSource und platzieren es im W√∂rterbuch. Anschlie√üend warten wir darauf, was zuerst passiert: Das angegebene Zeitintervall l√§uft ab oder eine Nachricht wird empfangen. <br><br><h4>  ValueTask: warum und wie </h4><br>  Async / await-Operatoren generieren wie der Yield Return-Operator eine Zustandsmaschine aus der Methode, die ein neues Objekt erstellt, was fast immer nicht wichtig ist, aber in seltenen F√§llen ein Problem verursachen kann.  Dieser Fall kann eine Methode sein, die sehr oft aufgerufen wird und √ºber Zehntausende von Anrufen pro Sekunde spricht.  Wenn eine solche Methode so geschrieben ist, dass sie in den meisten F√§llen ein Ergebnis zur√ºckgibt, das alle Wartemethoden umgeht, bietet .NET ein Tool zur Optimierung dieser Methode - die ValueTask-Struktur.  Betrachten Sie zur Verdeutlichung ein Beispiel f√ºr seine Verwendung: Es gibt einen Cache, in den wir sehr oft gehen.  Es sind einige Werte darin und dann geben wir sie einfach zur√ºck. Wenn nicht, gehen wir zu einem langsamen E / A hinter ihnen.  Letzteres m√∂chte ich asynchron machen, was bedeutet, dass die gesamte Methode asynchron ist.  Daher ist der offensichtliche Weg, eine Methode zu schreiben, wie folgt: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> RequestById(id); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgrund des Wunsches, ein wenig zu optimieren, und der leichten Angst, was Roslyn durch das Kompilieren dieses Codes erzeugen wird, k√∂nnen wir dieses Beispiel wie folgt umschreiben: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RequestById(id); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In der Tat besteht die optimale L√∂sung in diesem Fall darin, den Hot-Path zu optimieren, n√§mlich den Wert aus dem W√∂rterbuch ohne zus√§tzliche Zuordnungen und Belastung des GC abzurufen, w√§hrend in den seltenen F√§llen, in denen wir noch zum E / A gehen m√ºssen, alles plus bleibt / minus alt: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(RequestById(id)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns dieses Codefragment genauer an: Wenn sich ein Wert im Cache befindet, erstellen wir eine Struktur, andernfalls wird die eigentliche Aufgabe in eine signifikante Aufgabe eingeschlossen. </font><font style="vertical-align: inherit;">Dem aufrufenden Code ist es egal, wie dieser Code ausgef√ºhrt wurde: ValueTask verh√§lt sich aus Sicht der C # -Syntax genau wie die in diesem Fall √ºbliche Aufgabe.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TaskSchedulers: Verwalten von Task-Startstrategien </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die n√§chste API, die ich in Betracht ziehen m√∂chte, ist die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">und ihre Ableitungen. </font><font style="vertical-align: inherit;">Ich habe oben bereits erw√§hnt, dass es in TPL die M√∂glichkeit gibt, die Strategien f√ºr die Verteilung von Task'ov nach Thread zu steuern. </font><font style="vertical-align: inherit;">Solche Strategien sind in den Nachkommen der TaskScheduler-Klasse definiert. </font><font style="vertical-align: inherit;">Fast jede Strategie, die m√∂glicherweise ben√∂tigt wird, befindet sich in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ParallelExtensionsExtras-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">, die von Microsoft entwickelt wurde, jedoch nicht Teil von .NET ist, sondern als Nuget-Paket geliefert wird. </font><font style="vertical-align: inherit;">Betrachten wir einige davon kurz:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CurrentThreadTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - F√ºhrt eine Aufgabe f√ºr den aktuellen Thread aus</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LimitedConcurrencyLevelTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - begrenzt die Anzahl gleichzeitig ausgef√ºhrter Aufgaben auf den Parameter N, der im Konstruktor akzeptiert wird</font></font></li><li> <b>OrderedTaskScheduler</b> ‚Äî   LimitedConcurrencyLevelTaskScheduler(1),     . </li><li> <b>WorkStealingTaskScheduler</b> ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">work-stealing</a>    .     ThreadPool.   ,   .NET ThreadPool   ,    ,                  .        .  T.O.      WorkStealingTaskScheduler'    ,   ThreadPool     . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueuedTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Erm√∂glicht das Ausf√ºhren von Aufgaben gem√§√ü den Warteschlangenregeln mit Priorit√§ten</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadPerTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Erstellt einen separaten Thread f√ºr jede Aufgabe, die darauf ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Dies kann f√ºr Aufgaben n√ºtzlich sein, die unvorhersehbar lange dauern.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt einen guten detaillierten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ºber TaskSchedulers im Microsoft-Blog. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum bequemen Debuggen aller Aufgaben in Visual Studio gibt es ein Aufgabenfenster. </font><font style="vertical-align: inherit;">In diesem Fenster k√∂nnen Sie den aktuellen Status der Aufgabe anzeigen und zur aktuell ausgef√ºhrten Codezeile wechseln.</font></font><br><br><img src="https://habrastorage.org/webt/tb/fv/3l/tbfv3l-sdz-jw0mpcakbt_-lve8.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PLinq und die Parallel-Klasse </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neben Task und allem, was in .NET mit ihnen gesagt wurde, gibt es zwei weitere interessante Tools: PLinq (Linq2Parallel) und die Parallel-Klasse. Die erste verspricht die parallele Ausf√ºhrung aller Linq-Operationen auf mehreren Threads. Die Anzahl der Threads kann mit der WithDegreeOfParallelism-Erweiterungsmethode konfiguriert werden. Leider verf√ºgt PLinq im Ausf√ºhrungsmodus meistens nicht √ºber gen√ºgend Informationen zu den Innenseiten Ihrer Datenquelle, um einen signifikanten Geschwindigkeitsgewinn zu erzielen. Andererseits ist der Versuchspreis sehr niedrig: Sie m√ºssen nur die AsParallel-Methode vor der Linq-Methodenkette aufrufen und Leistungstests durchf√ºhren. Dar√ºber hinaus ist es m√∂glich, mithilfe des Partitionsmechanismus zus√§tzliche Informationen √ºber die Art Ihrer Datenquelle an PLinq zu √ºbertragen. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hier</font></a><font style="vertical-align: inherit;"> k√∂nnen Sie mehr lesen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die statische Parallel-Klasse bietet Methoden zum parallelen Durchlaufen einer Foreach-Auflistung, zum Ausf√ºhren einer For-Schleife und zum parallelen Ausf√ºhren mehrerer Delegaten zu Invoke. </font><font style="vertical-align: inherit;">Die Ausf√ºhrung des aktuellen Threads wird bis zum Ende der Berechnungen gestoppt. </font><font style="vertical-align: inherit;">Die Anzahl der Threads kann konfiguriert werden, indem ParallelOptions als letztes Argument √ºbergeben wird. </font><font style="vertical-align: inherit;">Mithilfe von Optionen k√∂nnen Sie auch TaskScheduler und CancellationToken angeben.</font></font><br><br><h4>  Schlussfolgerungen </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als ich anfing, diesen Artikel basierend auf den Materialien meines Berichts und den Informationen zu schreiben, die ich w√§hrend der Arbeit danach gesammelt hatte, hatte ich nicht erwartet, dass es so viel werden w√ºrde. </font><font style="vertical-align: inherit;">Wenn mir der Texteditor, in den ich diesen Artikel schreibe, vorwurfsvoll mitteilt, dass die 15. Seite verschwunden ist, fasse ich die Zwischenergebnisse zusammen. </font><font style="vertical-align: inherit;">Weitere Tricks, APIs, visuelle Tools und Fallstricke werden in einem zuk√ºnftigen Artikel behandelt.</font></font><br><br>  <b>Schlussfolgerungen:</b> <br><br><ul><li>      ,   ,     . </li><li>  .NET       </li><li>     ,     legacy,       API   . </li><li>     .NET   Thread  ThreadPool </li><li>  Thread.Abort, Thread.Interrupt,  Win32 API TerminateThread      .      CancellationToken' </li><li>  ‚Äî  ,   .   ,     .      TaskCompletionSource </li><li>      .NET        Task'. </li><li>  c# async/await     </li><li>   Task'       TaskScheduler'  </li><li>  ValueTask      hot-paths  memory-traffic </li><li>  Tasks  Threads Visual Studio           </li><li> PLinq  ,            ,        partitioning </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ... </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452094/">https://habr.com/ru/post/de452094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452082/index.html">Flexibler Ablauf von In-App-Updates: Beschleunigen Sie den App-Update-Prozess unter Android</a></li>
<li><a href="../de452086/index.html">Was ist in meinem Pixel f√ºr Sie: Erstellen von Nanopixeln mit Plasmon-Metaoberfl√§chen</a></li>
<li><a href="../de452088/index.html">Stra√üenerkennung durch semantische Segmentierung</a></li>
<li><a href="../de452090/index.html">Erstellen eines prozeduralen Puzzle-Generators</a></li>
<li><a href="../de452092/index.html">In-App-Updates: Beschleunigen von Android-Anwendungsupdates</a></li>
<li><a href="../de452098/index.html">Protokolle des Frontend-Entwicklers Habr: Refactor und Reflex</a></li>
<li><a href="../de452102/index.html">Fotospiel f√ºr Drohnenliebhaber: kurz √ºber AirSelfie 2</a></li>
<li><a href="../de452106/index.html">Wir laden Redner zum Sommer-DIY-Meeting am 16. Juni 2019 ein</a></li>
<li><a href="../de452108/index.html">Docker: harmloser Rat</a></li>
<li><a href="../de452110/index.html">Automatisieren Sie den Festplattenaustausch mit Ansible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>