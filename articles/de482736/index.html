<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äç‚úàÔ∏è ‚öôÔ∏è üõÑ Verwenden von TSDuck zum √úberwachen von IP-Streams (TS-Streams) üë®‚Äç‚öñÔ∏è üåõ üö∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heutzutage gibt es vorgefertigte (propriet√§re) L√∂sungen zur √úberwachung von IP (TS) -Streams, beispielsweise VB und iQ , die √ºber einen ziemlich umfan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von TSDuck zum √úberwachen von IP-Streams (TS-Streams)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482736/"><p>  Heutzutage gibt es vorgefertigte (propriet√§re) L√∂sungen zur √úberwachung von IP (TS) -Streams, beispielsweise <a href="https://bridgetech.tv/all-products/" rel="nofollow">VB</a> und <a href="https://www.telestream.net/pdfs/iq/productsheets/Surveyor_TS_New.pdf" rel="nofollow">iQ</a> , die √ºber einen ziemlich umfangreichen Funktionsumfang verf√ºgen und in der Regel f√ºr gro√üe Betreiber verf√ºgbar sind, die sich mit Fernsehdiensten befassen.  Dieser Artikel beschreibt eine L√∂sung, die auf dem Open-Source-Projekt <a href="https://tsduck.io/" rel="nofollow">TSDuck basiert</a> und f√ºr die minimale Steuerung von IP-Streams (TS-Streams) durch den Z√§hler CC (Continuity Counter) und die Bitrate ausgelegt ist.  Eine m√∂gliche Anwendung besteht darin, den Verlust von Paketen oder des gesamten Datenstroms √ºber einen gemieteten L2-Kanal zu steuern (der normalerweise nicht √ºberwacht werden kann, z. B. durch Lesen der Verlustz√§hler in Warteschlangen). </p><br><h2 id="ochen-kratko-o-tsduck">  Sehr kurz √ºber TSDuck </h2><br><p> TSDuck ist eine Open-Source-Software (2-Klausel-BSD-Lizenz) (eine Reihe von Konsolendienstprogrammen und eine Bibliothek zur Entwicklung ihrer Dienstprogramme oder Plug-Ins) zur Manipulation von TS-Streams.  Als Eingang kann es mit IP (Multicast / Unicast), http, hls, DVB-Tuner, DVB-ASI-Demodulator von Dektec arbeiten, es gibt einen internen TS-Stream-Generator und das Lesen von Dateien.  Die Ausgabe kann eine Datei, IP (Multicast / Unicast), hls, dektec dvb-asi und HiDes-Modulatoren, Player (mplayer, vlc, xine) und Drop sein.  Zwischen Ein- und Ausgabe k√∂nnen Sie verschiedene Verkehrsprozessoren einschalten, z. B. PID-Remapping, Scrambling / Descrambling, Analyse von CC-Z√§hlern, Bitratenberechnung und andere f√ºr TS-Streams typische Vorg√§nge. </p><a name="habracut"></a><br><p>  In diesem Artikel werden IP-Streams (Multicast) als Eingabe verwendet, Bitrate_Monitor-Prozessoren werden verwendet (aus dem Namen ist klar, was es ist) und Kontinuit√§t (Analyse von CC-Z√§hlern).  Sie k√∂nnen IP-Multicast problemlos durch einen anderen von TSDuck unterst√ºtzten Eingabetyp ersetzen. </p><br><p>  Es gibt <a href="https://tsduck.io/download/tsduck/" rel="nofollow">offizielle Builds / Pakete von</a> TSDuck f√ºr die meisten aktuellen Betriebssysteme.  F√ºr Debian ist dies nicht der Fall, aber es war m√∂glich, ohne Probleme unter Debian 8 und Debian 10 zusammenzustellen. </p><br><p>  Als n√§chstes wird die TSDuck-Version 3.19-1520 verwendet, als Betriebssystem wird Linux verwendet (Debian 10 wurde zur Vorbereitung der L√∂sung verwendet, CentOS 7 wurde f√ºr den realen Gebrauch verwendet). </p><br><h2 id="podgotovka-tsduck-i-os">  TSDuck und OS vorbereiten </h2><br><p>  Bevor Sie den tats√§chlichen Datenfluss √ºberwachen, m√ºssen Sie sicherstellen, dass TSDuck ordnungsgem√§√ü funktioniert und dass auf Netzwerkkarten- oder Betriebssystemebene (Socket-Ebene) keine Tropfen vorhanden sind.  Dies ist erforderlich, um sp√§ter nicht zu erraten, wo die Abbr√ºche aufgetreten sind - im Netzwerk oder "im Server".  Sie k√∂nnen die Drops auf Netzwerkkartenebene mit dem Befehl ethtool -S ethX √ºberpr√ºfen. Die Optimierung erfolgt mit demselben ethtool (normalerweise m√ºssen Sie den RX-Puffer (-G) erh√∂hen und manchmal einige Offloads (-K) deaktivieren).  Als allgemeine Empfehlung wird empfohlen, einen separaten Port f√ºr den Empfang des analysierten Datenverkehrs zu verwenden. Dies minimiert, wenn m√∂glich, die mit der Tatsache verbundenen Fehlalarme, die aufgrund des Vorhandenseins von anderem Datenverkehr auf dem Analysatorport koh√§rent auftraten.  Wenn dies nicht m√∂glich ist (ein Mini-Computer / NUC mit einem einzelnen Port wird verwendet), ist es √§u√üerst w√ºnschenswert, den analysierten Verkehr gegen√ºber dem Rest auf dem Ger√§t, an das der Analysator angeschlossen ist, zu priorisieren.  In Bezug auf virtuelle Umgebungen m√ºssen Sie vorsichtig sein und in der Lage sein, Paketablagen zu finden, die am physischen Port beginnen und mit der Anwendung in der virtuellen Maschine enden. </p><br><h3 id="generaciya-i-priyom-potoka-vnutri-hosta">  Erzeugung und Empfang eines Streams im Host </h3><br><p>  Als ersten Schritt bei der Vorbereitung von TSDuck werden wir mithilfe von Netzen Datenverkehr auf demselben Host generieren und empfangen. </p><br><p>  Kochumgebung: </p><br><pre><code class="bash hljs">ip netns add P <span class="hljs-comment"><span class="hljs-comment"># netns P,       ip link add type veth # veth- - veth0   netns   (     ) ip link set dev veth1 netns P #veth1 -   netns P (     ) ip netns exec P ifconfig veth1 192.0.2.1/30 up # IP  veth1,      ip netns exec P ip ro add default via 192.0.2.2 #     nents P sysctl net.ipv6.conf.veth0.disable_ipv6=1 # IPv6  veth0 -    ,    TX     ifconfig veth0 up #  veth0 ip route add 239.0.0.1 dev veth0 # ,      239.0.0.1   veth0</span></span></code> </pre> <br><p>  Die Umgebung ist bereit.  Wir starten den Traffic Analyzer: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> P tsp --realtime -t \ -I ip 239.0.0.1:1234 \ -P continuity \ -P bitrate_monitor -p 1 -t 1 \ -O drop</code> </pre> <br><p>  Dabei bedeutet "-p 1 -t 1", dass Sie die Bitrate jede Sekunde berechnen und Informationen zur Bitrate jede Sekunde anzeigen m√ºssen <br>  Wir starten den Traffic Generator mit einer Geschwindigkeit von 10 Mbit / s: </p><br><pre> <code class="bash hljs">tsp -I craft \ -P regulate -b 10000000 \ -O ip -p 7 -e --<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>-port 6000 239.0.0.1:1234</code> </pre> <br><p>  wobei "-p 7 -e" bedeutet, dass Sie 7 TS-Pakete in 1 IP-Paket packen und es schwer machen m√ºssen (-e), d. h.  Warten Sie immer auf 7 TS-Pakete vom letzten Prozessor, bevor Sie ein IP-Paket senden. </p><br><p>  Der Analysator beginnt mit der Anzeige der erwarteten Meldungen: </p><br><pre> <code class="plaintext hljs">* 2020/01/03 14:55:44 - bitrate_monitor: 2020/01/03 14:55:44, TS bitrate: 9,970,016 bits/s * 2020/01/03 14:55:45 - bitrate_monitor: 2020/01/03 14:55:45, TS bitrate: 10,022,656 bits/s * 2020/01/03 14:55:46 - bitrate_monitor: 2020/01/03 14:55:46, TS bitrate: 9,980,544 bits/s</code> </pre> <br><p>  F√ºgen Sie nun einige Tropfen hinzu: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> P iptables -I INPUT -d 239.0.0.1 -m statistic --mode random --probability 0.001 -j DROP</code> </pre> <br><p>  und Nachrichten wie diese erscheinen: </p><br><pre> <code class="plaintext hljs">* 2020/01/03 14:57:11 - continuity: packet index: 80,745, PID: 0x0000, missing 7 packets * 2020/01/03 14:57:11 - continuity: packet index: 83,342, PID: 0x0000, missing 7 packets</code> </pre> <br><p>  was erwartet wird.  Deaktivieren Sie den Paketverlust (ip netns exec P iptables -F) und versuchen Sie, die Bitrate des Generators auf 100 Mbit / s zu erh√∂hen.  Der Analysator meldet eine Reihe von CC-Fehlern und etwa 75 Mbit / s anstelle von 100. Wir versuchen herauszufinden, wer die Schuld tr√§gt - der Generator hat keine Zeit oder das Problem ist nicht darin enthalten. Daf√ºr generieren wir eine feste Anzahl von Paketen (700.000 TS-Pakete = 100.000 IP-Pakete): </p><br><pre> <code class="plaintext hljs"># ifconfig veth0 | grep TX TX packets 151825460 bytes 205725459268 (191.5 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 # tsp -I craft -c 700000 -P regulate -b 100000000 -P count -O ip -p 7 -e --local-port 6000 239.0.0.1:1234 * count: PID 0 (0x0000): 700,000 packets # ifconfig veth0 | grep TX TX packets 151925460 bytes 205861259268 (191.7 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</code> </pre> <br><p>  Wie Sie sehen, wurden genau 100.000 IP-Pakete generiert (151925460-151825460).  Damit wir verstehen, was mit dem Analysator passiert, √ºberpr√ºfen wir dies mit dem RX-Z√§hler auf veth1, er ist genau gleich dem TX-Z√§hler auf veth0, und schauen uns dann an, was auf Sockelebene passiert: </p><br><pre> <code class="plaintext hljs"># ip netns exec P cat /proc/net/udp sl local_address rem_address st tx_queue rx_queue tr tm-&gt;when retrnsmt uid timeout inode ref pointer drops 133: 010000EF:04D2 00000000:0000 07 00000000:00000000 00:00000000 00000000 0 0 72338 2 00000000e0a441df 24355</code> </pre> <br><p>  Hier sehen Sie die Anzahl der Drop = 24355. In TS-Paketen sind es 170485 oder 24,36% von 700000, so dass genau 25% der verlorenen Bitrate Drop in der UDP-Buchse sind.  In einem UDP-Socket treten normalerweise aufgrund eines fehlenden Puffers Abbr√ºche auf. Sehen Sie sich die Gr√∂√üe des Standard-Socket-Puffers und die maximale Gr√∂√üe des Socket-Puffers an: </p><br><pre> <code class="plaintext hljs"># sysctl net.core.rmem_default net.core.rmem_default = 212992 # sysctl net.core.rmem_max net.core.rmem_max = 212992</code> </pre> <br><p>  Wenn Anwendungen die Gr√∂√üe des Puffers nicht explizit anfordern, werden Sockets mit einem Puffer von 208 KB erstellt. Wenn sie jedoch mehr anfordern, erhalten sie immer noch nicht, was angefordert wird.  Da Sie in tsp die Puffergr√∂√üe (--buffer-size) f√ºr die IP-Eingabe festlegen k√∂nnen, ber√ºhren wir standardm√§√üig nicht die Socket-Gr√∂√üe. Wir legen lediglich die maximale Gr√∂√üe des Socket-Puffers fest und geben die Puffergr√∂√üe explizit √ºber tsp-Argumente an: </p><br><pre> <code class="plaintext hljs">sysctl net.core.rmem_max=8388608 ip netns exec P tsp --realtime -t -I ip 239.0.0.1:1234 -b 8388608 -P continuity -P bitrate_monitor -p 1 -t 1 -O drop</code> </pre> <br><p>  Bei dieser Einstellung des Socket-Puffers betr√§gt die nun gemeldete Bitrate ca. 100 Mbit / s, es treten keine CC-Fehler auf. </p><br><p>  Durch die CPU-Auslastung durch die TLP-Anwendung selbst.  Bezogen auf einen Kern der i5-4260U-CPU bei 1,40 GHz erfordert die Analyse eines 10-Mbit / s-Datenstroms 3-4% CPU, 100 Mbit / s - 25%, 200 Mbit / s - 46%.  Bei der Einstellung von% Packet Loss nimmt die CPU-Last praktisch nicht zu (kann aber abnehmen). </p><br><p>  Auf einer produktiveren Hardware konnten problemlos Fl√ºsse von mehr als 1 Gbit / s generiert und analysiert werden. </p><br><h3 id="testirovanie-na-realnyh-setevyh-kartah">  Testen auf echten Netzwerkkarten </h3><br><p>  Nach dem Testen eines Veth-Paares m√ºssen Sie zwei Hosts oder zwei Ports eines Hosts verwenden, die Ports miteinander verbinden, den Generator auf einem Host und den Analysator auf dem zweiten Host ausf√ºhren.  Es gab keine √úberraschungen, aber in Wirklichkeit h√§ngt alles von Eisen ab, je schw√§cher, desto interessanter wird es. </p><br><h2 id="ispolzovanie-poluchaemyh-dannyh-sistemoy-monitoringa-zabbix">  Verwendung der empfangenen Daten durch das √úberwachungssystem (Zabbix) </h2><br><p>  Tsp hat keine maschinenlesbare API wie SNMP oder √§hnliches.  CC-Nachrichten m√ºssen mindestens 1 Sekunde lang aggregiert werden (bei einem hohen Prozentsatz an Paketverlusten kann es je nach Bitrate zu Hunderten / Tausenden / Zehntausenden pro Sekunde kommen). </p><br><p>  Um Informationen zu speichern und Diagramme der CC-Fehler und der Bitrate zu zeichnen und eine Art Unfall zu verursachen, k√∂nnen die folgenden Optionen weiter ausgef√ºhrt werden: </p><br><ol><li>  Analysiere und aggregiere (gem√§√ü CC) die Ausgabe von tsp, d.h.  konvertieren Sie es in die gew√ºnschte Form. </li><li>  F√ºgen Sie die tsp- und / oder Prozessor-Plug-ins bitrate_monitor und continuity selbst hinzu, damit das Ergebnis in einer maschinenlesbaren Form angezeigt wird, die f√ºr ein √úberwachungssystem geeignet ist. </li><li>  Schreiben Sie Ihre Anwendung oben auf die tsduck-Bibliothek. </li></ol><br><p>  Unter dem Gesichtspunkt der Arbeitskosten ist Option 1 offensichtlich die einfachste, insbesondere wenn man bedenkt, dass tsduck selbst in einer (nach modernen Standards) einfachen Sprache (C ++) geschrieben ist. </p><br><p>  Ein einfacher Prototyp des Parser + Aggregators f√ºr Bash zeigte, dass bei einem Stream mit 10 Mbit / s und einem Paketverlust von 50% (der schlimmste Fall) der Bash-Prozess das 3-4-fache der CPU-Belastung des eigentlichen TLP-Prozesses aufwies.  Dieses Szenario ist nicht akzeptabel.  Eigentlich ein St√ºck dieses Prototyps unten </p><br><div class="spoiler">  <b class="spoiler_title">Nudeln auf der Bash</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash missingPackets=0 ccErrorSeconds=0 regexMissPackets='^\*\ (.+) - continuity:.*missing ([0-9]+) packets$' missingPacketsTime="" ip netns exec P tsp --realtime -t -I ip -b 8388608 "239.0.0.1:1234" -O drop -P bitrate_monitor -p 1 -t 1 -P continuity 2&gt;&amp;1 | \ while read i do #line example:* 2019/12/28 23:41:14 - continuity: packet index: 6,078, PID: 0x0100, missing 5 packets #line example 2: * 2019/12/28 23:55:11 - bitrate_monitor: 2019/12/28 23:55:11, TS bitrate: 4,272,864 bits/s if [[ "$i" == *continuity:* ]] then if [[ "$i" =~ $regexMissPackets ]] then missingPacketsTimeNew="${BASH_REMATCH[1]}" #timestamp (seconds) if [[ "$missingPacketsTime" != "$missingPacketsTimeNew" ]] #new second with CC error then ((ccErrorSeconds += 1)) fi missingPacketsTime=$missingPacketsTimeNew packets=${BASH_REMATCH[2]} #TS missing packets ((missingPackets += packets)) fi elif [[ "$i" == *bitrate_monitor:* ]] then : #... fi done</span></span></code> </pre> </div></div><br><p>  Abgesehen von der Tatsache, dass es inakzeptabel langsam arbeitet, gibt es keine normalen Threads in Bash, Bash-Jobs sind unabh√§ngige Prozesse, und ich musste den Wert von missingPackets einmal pro Sekunde f√ºr den Nebeneffekt aufzeichnen (wenn ich Bitraten-Nachrichten erhalte, die jede Sekunde kommen).  Infolgedessen wurde bash alleine gelassen und es wurde beschlossen, einen Wrapper (Parser + Aggregator) in Golang zu schreiben.  Der CPU-Verbrauch von √§hnlichem Golang-Code ist 4-5 mal geringer als der von TLP.  Es stellte sich heraus, dass die Beschleunigung des Wrappers durch Ersetzen von bash durch golang etwa 16-mal betrug und das Ergebnis insgesamt akzeptabel war (im schlimmsten Fall 25% Overhead auf der CPU).  Die Quelldatei auf Golang ist <a href="https://github.com/inheb/tsduck-stat/tree/master/tsduck-stat" rel="nofollow">hier</a> . </p><br><h3 id="zapusk-obyortki">  Wrapper-Start </h3><br><p>  Um den Wrapper auszuf√ºhren, wurde ( <a href="https://github.com/inheb/tsduck-stat/tree/master/systemd" rel="nofollow">hier</a> ) die einfachste Dienstvorlage f√ºr systemd erstellt.  Es wird davon ausgegangen, dass der Wrapper selbst in eine Bin√§rdatei kompiliert ist (go build tsduck-stat.go), die sich in / opt / tsduck-stat / befindet.  Es wird angenommen, dass Golang mit Unterst√ºtzung f√ºr die monotone Uhr (&gt; = 1,9) verwendet wird. </p><br><p>  Um eine Instanz des Dienstes zu erstellen, m√ºssen Sie den Befehl systemctl enable tsduck-stat@239.0.0.1: 1234 ausf√ºhren und anschlie√üend systemctl start tsduck-stat@239.0.0.1: 1234 verwenden. </p><br><h3 id="discovery-iz-zabbix">  Entdeckung von Zabbix </h3><br><p>  Damit zabbix die Suche nach laufenden Diensten durchf√ºhren kann, wird ein <a href="https://github.com/inheb/tsduck-stat/tree/master/tsduck-stat" rel="nofollow">Gruppenlistengenerator</a> (discovery.sh) in dem f√ºr die Zabbix-Suche erforderlichen Format erstellt. Es wird davon ausgegangen, dass er sich dort befindet - in / opt / tsduck-stat.  Um die Ermittlung √ºber zabbix-agent zu starten, m√ºssen Sie die <a href="" rel="nofollow">.conf-Datei</a> zum Verzeichnis mit den zabbix-agent-Konfigurationen hinzuf√ºgen, um den Benutzerparameter hinzuzuf√ºgen. </p><br><h3 id="shablon-zabbix">  Zabbix-Vorlage </h3><br><p>  <a href="https://github.com/inheb/tsduck-stat/tree/master/zabbix_templates" rel="nofollow">Die erstellte Vorlage</a> (tsduck_stat_template.xml) enth√§lt die AutoErmittlungsregel, Prototypen von Datenelementen, Diagrammen und Triggern. </p><br><h2 id="kratkiy-cheklist-nu-a-vdrug-kto-to-reshit-vospolzovatsya">  Eine kurze Checkliste (na ja, wenn sich jemand entscheidet, sie zu benutzen) </h2><br><ol><li>  Stellen Sie sicher, dass tsp unter "idealen" Bedingungen keine Pakete fallen l√§sst (der Generator und der Analysator sind direkt verbunden). Falls es zu Tropfen kommt, lesen Sie Abschnitt 2 oder den Text des Artikels zu diesem Thema. </li><li>  Stellen Sie den maximalen Socket-Puffer ein (net.core.rmem_max = 8388608). </li><li>  Kompilieren Sie tsduck-stat.go (erstellen Sie tsduck-stat.go). </li><li>  Legen Sie die Dienstvorlage in / lib / systemd / system ab. </li><li>  Starten Sie die Dienste mit systemctl und √ºberpr√ºfen Sie, ob die Leistungsindikatoren angezeigt werden (grep "" / dev / shm / tsduck-stat / *).  Anzahl der Dienste nach Anzahl der Multicast-Streams.  Hier m√ºssen Sie m√∂glicherweise eine Route zur Multicast-Gruppe erstellen, m√∂glicherweise rp_filter deaktivieren oder eine Route zur Quell-IP erstellen. </li><li>  F√ºhren Sie discovery.sh aus, und stellen Sie sicher, dass es JSON generiert. </li><li>  H√§ngen Sie die Konfiguration des zabbix-Agenten an und starten Sie den zabbix-Agenten neu. </li><li>  Laden Sie die Vorlage auf zabbix herunter, wenden Sie sie auf den Host an, auf dem zabbix-agent √ºberwacht und installiert wird. Warten Sie ca. 5 Minuten, bis neue Datenelemente, Grafiken und Trigger angezeigt werden. </li></ol><br><h2 id="rezultat">  Ergebnis </h2><br><p><img src="https://habrastorage.org/webt/ug/rc/5c/ugrc5c87ctd6rylequ7kdha5lze.png" alt="Diagramme mit Bitrate und CC-Fehlern"></p><br><p>  F√ºr die Aufgabe, Paketverluste zu erkennen, reicht es fast aus, zumindest ist es besser als die fehlende √úberwachung. </p><br><p>  Tats√§chlich k√∂nnen CC- ‚ÄûVerluste‚Äú auftreten, wenn Videoclips geklebt werden (soweit ich wei√ü, werden Einf√ºgungen in lokalen Telezentren in der Russischen F√∂deration vorgenommen, dh ohne den CC-Z√§hler zu z√§hlen). Dies muss beachtet werden.  In propriet√§ren L√∂sungen wird dieses Problem teilweise umgangen, indem SCTE-35-Tag-Labels erkannt werden (sofern sie vom Stream-Generator hinzugef√ºgt werden). <br>  <strong>UPD:</strong> Unterst√ºtzung f√ºr SCTE-35-Tags zur Wrapper- und Zabbix-Vorlage hinzugef√ºgt </p><br><p>  Unter dem Gesichtspunkt der √úberwachung der Transportqualit√§t gibt es nicht gen√ºgend √úberwachungsjitter (Monitoring Jitter, IAT), weil  TV-Ger√§te (egal ob Modulatoren oder Endger√§te) stellen Anforderungen an diesen Parameter und es ist nicht immer m√∂glich, den Jitbuffer auf unendlich zu erh√∂hen.  Und Jitter kann schwanken, wenn Ger√§te mit gro√üen Puffern w√§hrend der √úbertragung verwendet werden und die QoS nicht oder nur unzureichend f√ºr die √úbertragung eines solchen Echtzeitverkehrs konfiguriert ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482736/">https://habr.com/ru/post/de482736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482722/index.html">Fantastische Geschichte ‚ÄûProjekt C. Eitelkeit der Eitelkeiten‚Äú (10 Min.)</a></li>
<li><a href="../de482726/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 328 (23. - 29. Dezember)</a></li>
<li><a href="../de482728/index.html">JPEG. Kompressionsalgorithmus</a></li>
<li><a href="../de482730/index.html">Feiertagsumfrage</a></li>
<li><a href="../de482734/index.html">Kompilieren Sie die Zeitverschleierung mit NAND / NOR</a></li>
<li><a href="../de482740/index.html">Interview f√ºr die Position eines Dichters</a></li>
<li><a href="../de482742/index.html">Eintritt in den westlichen Markt: Umgang mit Kunden</a></li>
<li><a href="../de482744/index.html">Eine Silberkugel finden: Ungew√∂hnliche Munition</a></li>
<li><a href="../de482748/index.html">Aufbau eines Taxibuchungsgesch√§fts in Dubai: Wie starte ich eine kundenorientierte Taxi-App wie Careem & Hala?</a></li>
<li><a href="../de482752/index.html">"Neue Epen". Wir essen den Elefanten in Teilen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>