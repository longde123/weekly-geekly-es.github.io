<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèΩ üïµüèº üåù RESTinio √© um servidor HTTP ass√≠ncrono. Ass√≠ncrono üñ±Ô∏è üëàüèø üîÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alguns anos atr√°s, publicamos o RESTinio , nossa pequena estrutura OpenSource C ++ para incorporar um servidor HTTP em aplicativos C ++. O RESTinio n√£...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio √© um servidor HTTP ass√≠ncrono. Ass√≠ncrono</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451728/"><p>  Alguns anos atr√°s, publicamos o <a href="">RESTinio</a> , nossa pequena estrutura OpenSource C ++ para incorporar um servidor HTTP em aplicativos C ++.  O RESTinio n√£o se tornou mega-popular durante esse per√≠odo, mas n√£o foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">perdido</a> .  Algu√©m o escolhe para o suporte "nativo" ao Windows, algu√©m para alguns recursos individuais (como suporte ao sendfile), algu√©m para a propor√ß√£o de recursos, facilidade de uso e personaliza√ß√£o.  Mas, eu acho, inicialmente muitos RESTinio s√£o atra√≠dos por este lac√¥nico "Ol√°, Mundo": </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;restinio/all.hpp&gt; int main() { restinio::run( restinio::on_this_thread() .port(8080) .address("localhost") .request_handler([](auto req) { return req-&gt;create_response().set_body("Hello, World!").done(); })); return 0; }</span></span></span></span></code> </pre> <br><p>  Isso √© realmente tudo o que √© necess√°rio para executar o servidor HTTP dentro de um aplicativo C ++. </p><br><p>  E, embora sempre tentemos dizer que o principal recurso para o qual geralmente nos envolvemos no RESTinio era o processamento ass√≠ncrono de solicita√ß√µes recebidas, ainda ocasionalmente encontramos perguntas sobre o que fazer se dentro do request_handler voc√™ precisar executar opera√ß√µes demoradas. </p><br><p>  E como essa pergunta √© relevante, voc√™ pode falar sobre ela novamente e dar alguns pequenos exemplos. </p><a name="habracut"></a><br><h1 id="nebolshaya-otsylka-k-istokam">  Uma pequena refer√™ncia √†s origens </h1><br><p>  Decidimos tornar nosso servidor HTTP incorpor√°vel ap√≥s v√°rias vezes seguidas enfrentar tarefas muito semelhantes: era necess√°rio organizar uma entrada HTTP para um aplicativo C ++ existente ou era necess√°rio escrever um microsservi√ßo no qual era necess√°rio reutilizar o C ++ "pesado" j√° existente qualquer c√≥digo.  Um recurso comum dessas tarefas era que o processamento do aplicativo da solicita√ß√£o poderia se estender por dezenas de segundos. </p><br><p>  Grosso modo, por um milissegundo, o servidor HTTP estava classificando uma nova solicita√ß√£o HTTP, mas para emitir uma resposta HTTP, era necess√°rio recorrer a outros servi√ßos ou executar c√°lculos demorados.  Se voc√™ processar solicita√ß√µes HTTP no modo s√≠ncrono, o servidor HTTP precisar√° de um conjunto de milhares de threads de trabalho, o que dificilmente pode ser considerado uma boa id√©ia, mesmo em condi√ß√µes modernas. </p><br><p>  √â muito mais conveniente quando o servidor HTTP pode trabalhar em apenas um thread de trabalho, no qual a E / S √© executada e os manipuladores de solicita√ß√£o s√£o chamados.  O manipulador de solicita√ß√£o simplesmente delega o processamento real de algum outro thread de trabalho e retorna o controle ao servidor HTTP.  Quando, muito mais tarde, em algum lugar de outro encadeamento de trabalho, as informa√ß√µes est√£o prontas para responder √† solicita√ß√£o, simplesmente √© gerada uma resposta HTTP que automaticamente pega o servidor HTTP e envia essa resposta ao cliente apropriado. </p><br><p>  Como nunca encontramos uma vers√£o pronta que fosse simples e conveniente de usar, ela era multiplataforma e suportava o Windows como uma plataforma "nativa", proporcionaria desempenho mais ou menos decente e, mais importante, seria aprimorada especificamente para assincr√¥nicas. trabalho, ent√£o, no in√≠cio de 2017, come√ßamos a desenvolver o RESTinio. </p><br><p>  Quer√≠amos criar um servidor HTTP incorporado ass√≠ncrono, f√°cil de usar, liberando o usu√°rio de algumas preocupa√ß√µes rotineiras, al√©m de mais ou menos produtivo, multiplataforma e permitindo uma configura√ß√£o flex√≠vel para diferentes condi√ß√µes.  Parece estar dando certo, mas vamos deixar que os usu√°rios julguem ... </p><br><h1 id="itak-est-vhodyaschiy-zapros-trebuyuschiy-mnogo-vremeni-na-obrabotku-chto-delat">  Portanto, h√° uma solicita√ß√£o de entrada que requer muito tempo de processamento.  O que fazer </h1><br><h2 id="rabochie-niti-restinioasio">  Linhas de trabalho RESTinio / Asio </h2><br><p>  √Äs vezes, os usu√°rios do RESTinio n√£o pensam sobre quais threads de trabalho e como exatamente usam o RESTinio.  Por exemplo, algu√©m pode considerar que quando o RESTinio √© iniciado em um thread de trabalho (usando <code>run(on_this_thread(...))</code> , como no exemplo acima), nesse segmento de trabalho o RESTinio chama apenas manipuladores de solicita√ß√£o.  Enquanto que para E / S, o RESTinio cria um encadeamento separado sob o cap√¥.  E esse encadeamento separado continua a servir novas conex√µes quando o encadeamento principal √© ocupado pelo request_handler. </p><br><p>  De fato, todos os encadeamentos que o usu√°rio aloca para o RESTinio s√£o usados ‚Äã‚Äãpara executar opera√ß√µes de E / S e para chamar request_handlers.  Portanto, se voc√™ iniciou o servidor RESTinio atrav√©s da <code>run(on_this_thread(...))</code> , e dentro da <code>run()</code> no encadeamento atual, ser√£o executados os manipuladores de E / S e de solicita√ß√£o. </p><br><p>  Grosso modo, o RESTinio lan√ßa um loop de eventos do Asio, no qual processa novas conex√µes, l√™ e analisa dados de conex√µes existentes, grava dados prontos para envio, gerencia conex√µes de fechamento, etc.  Entre outras coisas, depois que a solicita√ß√£o recebida √© lida e analisada completamente a partir da pr√≥xima conex√£o, o request_handler especificado pelo usu√°rio √© chamado para processar essa solicita√ß√£o. </p><br><p>  Portanto, se request_handler bloquear a opera√ß√£o do encadeamento atual, o loop de eventos do Asio-action trabalhando no mesmo encadeamento tamb√©m ser√° bloqueado.  Tudo √© simples. </p><br><p>  Se o RESTinio for iniciado em um pool de threads de trabalho (por exemplo, por meio de <code>run(on_thread_pool(...))</code> , como <a href="">neste exemplo</a> ), quase o mesmo acontece: um loop de eventos do Asio √© iniciado em cada thread do pool.  Portanto, se algum request_handler come√ßar a multiplicar matrizes grandes, isso bloquear√° o encadeamento de trabalho no pool e as opera√ß√µes de E / S n√£o ser√£o mais atendidas nesse encadeamento. </p><br><p>  Portanto, ao usar o RESTinio, a tarefa do desenvolvedor √© concluir seus request_handlers em um prazo razo√°vel e, de prefer√™ncia, n√£o muito tempo. </p><br><h2 id="nuzhen-li-vam-pul-rabochih-potokov-dlya-restinioasio">  Voc√™ precisa de um pool de fluxos de trabalho para o RESTinio / Asio? </h2><br><p>  Portanto, quando o request_handler especificado pelo usu√°rio bloqueia o thread de trabalho no qual √© chamado por um longo tempo, esse thread perde a capacidade de processar opera√ß√µes de E / S.  Mas e se request_handler precisar de muito tempo para formar uma resposta?  Suponha que ele fa√ßa algum tipo de opera√ß√£o pesada de computa√ß√£o, cujo tempo, em princ√≠pio, n√£o pode ser reduzido para alguns milissegundos? </p><br><p>  Um dos usu√°rios pode pensar que, como o RESTinio pode trabalhar em um pool de threads de trabalho, basta especificar o tamanho do pool maior e √© isso. </p><br><p>  Infelizmente, isso s√≥ funcionar√° em casos simples quando voc√™ tiver poucas conex√µes paralelas.  E a intensidade da consulta √© baixa.  Se a contagem de consultas paralelas for de milhares (pelo menos apenas algumas centenas), ser√° f√°cil obter uma situa√ß√£o em que todos os threads de trabalho do pool estar√£o ocupados processando solicita√ß√µes j√° aceitas.  E n√£o haver√° mais threads restantes para executar opera√ß√µes de E / S.  Como resultado, o servidor perder√° sua capacidade de resposta.  A inclus√£o de RESTinio perder√° a capacidade de processar tempos limite que o RESTinio contabiliza automaticamente quando recebe novas conex√µes e ao processar solicita√ß√µes. </p><br><p>  Portanto, se voc√™ precisar executar opera√ß√µes de bloqueio demoradas para atender √†s solicita√ß√µes recebidas, √© melhor alocar apenas um encadeamento de trabalho para o RESTinio, mas atribua um grande conjunto de fluxos de trabalho para executar essas mesmas opera√ß√µes.  O manipulador de solicita√ß√µes colocar√° a pr√≥xima solicita√ß√£o em alguma fila, de onde a solicita√ß√£o ser√° recuperada e enviada para processamento. </p><br><p>  Vimos um exemplo desse esquema em detalhes quando falamos sobre nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto de demonstra√ß√£o de camar√£o</a> neste artigo: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camar√£o: dimensionar e compartilhar imagens HTTP em C ++ moderno usando ImageMagic ++, SObjectizer e RESTinio</a> ". </p><br><h2 id="primery-delegirovaniya-obrabotki-zaprosov-na-otdelnye-rabochie-niti">  Exemplos de delega√ß√£o de processamento de solicita√ß√µes em threads de trabalho individuais </h2><br><p>  Acima, tentei explicar por que n√£o √© necess√°rio executar um processamento demorado dentro do request_handler.  De onde vem o resultado √≥bvio: o processamento demorado da solicita√ß√£o deve ser delegado a algum outro segmento de trabalho.  Vamos ver como isso pode parecer. </p><br><p>  Nos dois exemplos abaixo, precisamos de um √∫nico segmento de trabalho para executar o RESTinio e outro de trabalho para simular o longo processamento de solicita√ß√µes.  E tamb√©m precisamos de algum tipo de fila de mensagens para transferir solicita√ß√µes do encadeamento RESTinio para um encadeamento de trabalho separado. </p><br><p>  N√£o foi f√°cil para mim fazer uma nova implementa√ß√£o da fila de mensagens com seguran√ßa de thread para esses dois exemplos; portanto, usei o SObjectizer nativo e seus mchains, que s√£o canais CSP.  Voc√™ pode ler mais sobre o mchain aqui: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Troca de informa√ß√µes entre threads de trabalho sem problemas? Canais CSP para nos ajudar</a> ." </p><br><h3 id="sohranenie-obekta-request_handle">  Salvando o objeto request_handle </h3><br><p>  A t√©cnica b√°sica na qual a delega√ß√£o do processamento de solicita√ß√µes √© criada √© a transfer√™ncia do objeto <code>request_handle_t</code> algum lugar. </p><br><p>  Quando o RESTinio chama o request_handler especificado pelo usu√°rio para processar uma solicita√ß√£o de entrada, um objeto do tipo <code>request_handle_t</code> √© passado para esse <code>request_handle_t</code> .  Esse tipo nada mais √© do que um ponteiro inteligente para os par√¢metros da solicita√ß√£o recebida.  Portanto, se for conveniente que algu√©m pense que <code>request_handle_t</code> √© <code>shared_ptr</code> , voc√™ pode pensar com seguran√ßa.  Este <code>shared_ptr</code> √©. </p><br><p>  E como <code>request_handle_t</code> √© <code>shared_ptr</code> , podemos passar com seguran√ßa esse ponteiro inteligente em algum lugar.  O que faremos nos exemplos abaixo. </p><br><p>  Portanto, precisamos de um thread e canal de trabalho separados para se comunicar com ele.  Vamos criar tudo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  SObjectizer. so_5::wrapped_env_t sobj; //  std::thread    . std::thread processing_thread; //    main      join. //    RAII. auto processing_thread_joiner = so_5::auto_join(processing_thread); //      . auto req_ch = so_5::create_mchain(sobj); //       main. //    RAII. auto ch_closer = so_5::auto_close_drop_content(req_ch); //     . //      main()  - , //     ,      join(). processing_thread = std::thread{ processing_thread_func, req_ch };</span></span></code> </pre> <br><p>  O corpo do pr√≥prio thread de trabalho est√° localizado dentro da fun√ß√£o <code>processing_thread_func()</code> , que discutiremos um pouco mais adiante. </p><br><p>  Agora j√° temos um segmento de trabalho separado e um canal para comunica√ß√£o com ele.  Voc√™ pode iniciar o servidor RESTinio: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;() .port(8080) .address("localhost") .request_handler([req_ch](auto req) { //   GET-   . if(restinio::http_method_t::http_get == req-&gt;header().method() &amp;&amp; "/" == req-&gt;header().path()) { //    . so_5::send&lt;handle_request&gt;(req_ch, req); return restinio::request_accepted(); } else return restinio::request_rejected(); }) .cleanup_func([&amp;] { //      . //    , ..  req_ch //          //     . so_5::close_drop_content(req_ch); }));</span></span></code> </pre> <br><p>  A l√≥gica para este servidor √© muito simples.  Se uma solicita√ß√£o GET chegou para '/', delegamos o processamento da solicita√ß√£o de um √∫nico encadeamento.  Para fazer isso, realizamos duas opera√ß√µes importantes: </p><br><ul><li>  envie o objeto <code>request_handle_t</code> para o canal CSP.  Enquanto esse objeto √© armazenado dentro do canal CSP ou em outro local, o RESTinio sabe que a solicita√ß√£o ainda est√° ativa; </li><li>  retornamos o valor <code>restinio::request_accepted()</code> do manipulador de solicita√ß√µes.  Isso faz com que o RESTinio entenda que a solicita√ß√£o foi aceita para processamento e que a conex√£o com o cliente n√£o pode ser fechada. </li></ul><br><p>  O fato de request_handler n√£o gerar imediatamente uma resposta RESTinio n√£o incomoda.  Depois que <code>restinio::request_accepted()</code> for retornado, o usu√°rio <code>restinio::request_accepted()</code> a responsabilidade de processar a solicita√ß√£o e um dia a resposta ser√° gerada. </p><br><p>  Se o manipulador de solicita√ß√£o retornou <code>restinio::request_rejected()</code> , o RESTinio entende que a solicita√ß√£o n√£o ser√° processada e retornar√° um erro 501 ao cliente. </p><br><p>  Portanto, corrigimos o resultado preliminar: a inst√¢ncia <code>request_handle_t</code> pode ser transmitida para algum lugar, pois √©, de fato, <code>std::shared_ptr</code> .  Enquanto essa inst√¢ncia estiver ativa, o RESTinio considera que a solicita√ß√£o est√° sendo processada.  Se o manipulador de solicita√ß√£o retornou <code>restinio::request_accepted()</code> , o RESTinio n√£o se preocupar√° com o fato de a resposta √† solicita√ß√£o n√£o ter sido gerada no momento. </p><br><p>  Agora podemos ver a implementa√ß√£o desse segmento muito separado: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       //    . std::random_device rd; std::mt19937 generator{rd()}; std::uniform_int_distribution&lt;&gt; pause_generator{350, 3500}; //      timeout_elapsed. auto delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); //     -  . bool stop = false; select( so_5::from_all() //      . .on_close([&amp;stop](const auto &amp;) { stop = true; }) //     select(). //  select()     . .stop_on([&amp;stop]{ return stop; }), //   handle_request     RESTinio. case_(req_ch, [&amp;](handle_request cmd) { //     . const std::chrono::milliseconds pause{pause_generator(generator)}; //     . so_5::send_delayed&lt;timeout_elapsed&gt;(delayed_ch, //    timeout_elapsed. pause, //      timeout_elapsed. cmd.m_req, pause); }), //   timeout_elapsed. case_(delayed_ch, [](timeout_elapsed cmd) { //     . cmd.m_req-&gt;create_response() .set_body("Hello, World! (pause:" + std::to_string(cmd.m_pause.count()) + "ms)") .done(); }) ); }</span></span></code> </pre> <br><p>  A l√≥gica aqui √© muito simples: obtemos a solicita√ß√£o inicial na forma de uma mensagem <code>handle_request</code> e a encaminhamos para n√≥s mesmos na forma de uma mensagem <code>timeout_elapsed</code> atrasada por algum tempo aleat√≥rio.  Realizamos o processamento real da solicita√ß√£o somente ap√≥s o recebimento de <code>timeout_elapsed</code> . </p><br><p>  <strong>Upd.</strong>  Quando o m√©todo <code>done()</code> √© chamado em um thread de trabalho separado, o RESTinio √© notificado de que apareceu uma resposta pronta que precisa ser gravada na conex√£o TCP.  O RESTinio inicia a opera√ß√£o de grava√ß√£o, mas a pr√≥pria opera√ß√£o de E / S n√£o ser√° executada quando o nome <code>done()</code> chamado, mas onde o RESTinio faz o E / S e chama request_handlers.  I.e.  neste exemplo, <code>done()</code> √© chamado em um thread de trabalho separado, e a opera√ß√£o de grava√ß√£o ser√° executada no thread principal, onde <code>restinio::run()</code> funciona. </p><br><p>  As pr√≥prias mensagens s√£o as seguintes: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout_elapsed</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds m_pause; };</code> </pre> <br><p>  I.e.  um thread de trabalho separado pega <code>request_handle_t</code> e o salva at√© que surja a oportunidade de formar uma resposta completa.  E quando essa oportunidade surgir, <code>create_response()</code> √© chamado no objeto de solicita√ß√£o salva e a resposta √© retornada ao RESTinio.  Em seguida, o RESTinio j√° em seu contexto de trabalho grava a resposta em conex√£o com o cliente correspondente. </p><br><p>  Aqui, a inst√¢ncia <code>request_handle_t</code> √© armazenada em uma mensagem atrasada <code>timeout_elapsed</code> , pois n√£o h√° processamento real neste exemplo primitivo.  Em um aplicativo real, <code>request_handle_t</code> pode ser armazenado em algum tipo de fila ou dentro de algum objeto criado para processar a solicita√ß√£o. </p><br><p>  O c√≥digo completo deste exemplo pode ser encontrado <a href="">entre os exemplos regulares do RESTinio</a> . </p><br><h4 id="neskolko-nebolshih-poyasneniy-po-kodu">  Algumas pequenas notas de c√≥digo </h4><br><p>  Essa constru√ß√£o define as propriedades RESTinio que um servidor RESTinio deve ter: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;()</span></span></code> </pre> <br><p>  Neste exemplo, preciso do RESTinio para registrar suas a√ß√µes de processamento de solicita√ß√µes.  Portanto, defino <code>logger_t</code> como diferente do padr√£o <code>null_logger_t</code> .  Mas desde  O RESTinio funcionar√°, de fato, em v√°rios encadeamentos (o RESTinio processa solicita√ß√µes de entrada no encadeamento principal, mas as respostas chegam de um encadeamento de trabalho separado), ent√£o voc√™ precisa de um registrador seguro de encadeamento, que √© <code>shared_ostream_logger_t</code> . </p><br><p>  Dentro de <code>processing_thread_func()</code> , a fun√ß√£o SObjectizer <code>select()</code> , que √© um pouco semelhante √† constru√ß√£o Go-shn selecionada: voc√™ pode ler e processar mensagens de v√°rios canais ao mesmo tempo.  A fun√ß√£o <code>select()</code> funciona at√© que todos os canais passados ‚Äã‚Äãpara ela sejam fechados.  Ou at√© que lhe seja dito √† for√ßa que √© hora de terminar. </p><br><p>  Ao mesmo tempo, se o canal de comunica√ß√£o com o servidor RESTinio estiver fechado, n√£o faz sentido continuar trabalhando.  Portanto, em <code>select()</code> , a resposta ao fechamento de qualquer um dos canais √© determinada: assim que um canal √© fechado, o sinalizador de parada √© levantado.  E isso levar√° √† conclus√£o de <code>select()</code> e sair√° de <code>processing_thread_func()</code> . </p><br><h3 id="sohranenie-obekta-response_builder">  Salvando o Objeto response_builder </h3><br><p>  No exemplo anterior, consideramos um caso simples quando √© poss√≠vel salvar <code>request_handle_t</code> at√© que possamos fornecer imediatamente toda a resposta √† solicita√ß√£o. </p><br><p>  Mas pode haver cen√°rios mais complexos quando, por exemplo, voc√™ precisar dar uma resposta em partes.  Ou seja, recebemos uma solicita√ß√£o, podemos formar imediatamente apenas a primeira parte da resposta.  N√≥s formamos isso.  Depois de algum tempo, temos a oportunidade de formar a segunda parte da resposta.  Depois de mais algum tempo, podemos formar a pr√≥xima parte, etc. </p><br><p>  Al√©m disso, pode ser desej√°vel para n√≥s que todas essas partes desapare√ßam √† medida que as formam.  I.e.  Primeiro, a primeira parte da resposta, para que o cliente possa subtra√≠-la, depois a segunda, depois a terceira, etc. </p><br><p>  O RESTinio permite fazer isso devido a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diferentes tipos de respondce_builders</a> .  Em particular, tipos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">user_controlled_output</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chunked_output</a> . </p><br><p>  Nesse caso, n√£o √© suficiente salvar <code>request_handle_t</code> , porque <code>request_handle_t</code> ser√° √∫til apenas at√© a primeira chamada para <code>create_reponse()</code> .  Em seguida, precisamos trabalhar com response_builder.  Bem ... </p><br><p>  Bem, tudo bem.  Response_builder √© um tipo m√≥vel, um pouco semelhante ao unique_ptr.  Assim, tamb√©m podemos mant√™-lo enquanto precisarmos.  E para mostrar como fica, refazemos um pouco o exemplo acima.  Deixe a fun√ß√£o <code>processing_thread_func()</code> formar a resposta em partes. </p><br><p>  Isso n√£o √© nada dif√≠cil. </p><br><p>  Primeiro, precisamos decidir sobre os tipos que o novo <code>processing_thread_func()</code> precisar√°: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-comment"><span class="hljs-comment">//     . using output_t = restinio::chunked_output_t; //   reponse_builder-   . using response_t = restinio::response_builder_t&lt;output_t&gt;; //     . struct timeout_elapsed { response_t m_resp; int m_counter; };</span></span></code> </pre> <br><p>  A mensagem <code>handle_request</code> permanece inalterada.  Mas na mensagem <code>timeout_elapsed</code> agora armazenamos n√£o <code>request_handle_t</code> , mas response_builder do tipo que precisamos.  Al√©m disso, um contador das pe√ßas restantes.  Assim que esse contador for redefinido, a solicita√ß√£o de servi√ßo termina. </p><br><p>  Agora podemos ver uma nova vers√£o da fun√ß√£o <code>processing_thread_func()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::random_device rd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mt19937 generator{rd()}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;&gt; pause_generator{<span class="hljs-number"><span class="hljs-number">350</span></span>, <span class="hljs-number"><span class="hljs-number">3500</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stop = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; select( so_5::from_all() .on_close([&amp;stop](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;) { stop = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }) .stop_on([&amp;stop]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stop; }), case_(req_ch, [&amp;](handle_request cmd) { <span class="hljs-comment"><span class="hljs-comment">//    ,    . auto resp = cmd.m_req-&gt;create_response&lt;output_t&gt;(); resp.append_header( restinio::http_field::server, "RESTinio" ) .append_header_date_field() .append_header( restinio::http_field::content_type, "text/plain; charset=utf-8" ); //    ,  RESTinio //   . resp.flush(); //       . so_5::send_delayed&lt;so_5::mutable_msg&lt;timeout_elapsed&gt;&gt;(delayed_ch, //     . std::chrono::milliseconds{pause_generator(generator)}, //    timeout_elapsed. //     response_builder-  . std::move(resp), 3); }), case_(delayed_ch, [&amp;](so_5::mutable_mhood_t&lt;timeout_elapsed&gt; cmd) { //      . cmd-&gt;m_resp.append_chunk( "this is the next part of the response\n" ); //  RESTinio   . cmd-&gt;m_resp.flush(); cmd-&gt;m_counter -= 1; if( 0 != cmd-&gt;m_counter ) { //        . so_5::send_delayed( delayed_ch, std::chrono::milliseconds{pause_generator(generator)}, std::move(cmd)); } else // ,   . cmd-&gt;m_resp.done(); }) ); }</span></span></code> </pre> <br><p>  I.e.     ,        .       .         . </p><br><p> <strong>Upd.</strong>   <code>flush()</code>   ,     <code>done()</code> : RESTinio   ,   I/O-    ,   <code>flush()</code> ,  ,  RESTinio  -   request_handler-.  I.e.    <code>flush()</code>     ,        , ,   <code>restinio::run()</code> . </p><br><p>       ,    RESTinio    : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:02:35.106] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:02:35.106] INFO: init accept #0 [2019-05-13 15:02:35.106] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:02:39.050] TRACE: accept connection from 127.0.0.1:49280 on socket #0 [2019-05-13 15:02:39.050] TRACE: [connection:1] start connection with 127.0.0.1:49280 [2019-05-13 15:02:39.050] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:39.050] TRACE: [connection:1] continue reading request [2019-05-13 15:02:39.050] TRACE: [connection:1] received 78 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:02:39.050] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start response (#0): HTTP/1.1 200 OK [2019-05-13 15:02:39.050] TRACE: [connection:1] sending resp data, buf count: 1, total size: 167 [2019-05-13 15:02:39.050] TRACE: [connection:1] outgoing data was sent: 167 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:39.050] TRACE: [connection:1] should keep alive [2019-05-13 15:02:40.190] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:40.190] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:40.190] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:40.190] TRACE: [connection:1] should keep alive [2019-05-13 15:02:43.542] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:43.542] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:43.542] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:43.542] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:46.297] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:46.298] TRACE: [connection:1] sending resp data, buf count: 1, total size: 5 [2019-05-13 15:02:46.298] TRACE: [connection:1] outgoing data was sent: 5 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:46.298] TRACE: [connection:1] continue reading request [2019-05-13 15:02:46.298] TRACE: [connection:1] EOF and no request, close connection [2019-05-13 15:02:46.298] TRACE: [connection:1] close [2019-05-13 15:02:46.298] TRACE: [connection:1] close: close socket [2019-05-13 15:02:46.298] TRACE: [connection:1] close: timer canceled [2019-05-13 15:02:46.298] TRACE: [connection:1] close: reset responses data [2019-05-13 15:02:46.298] TRACE: [connection:1] destructor called</code> </pre> <br><p>   ,  RESTinio           167 .          ,           , RESTinio          . </p><br><p>   ,    RESTinio   -     response_builder     ,        . </p><br><p>      .        , ,     .       response_builder   .     ,   responce_builder       ,          .. </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . </p><br><h2 id="chto-budet-esli-obrabotka-zaprosa-zaymet-slishkom-mnogo-vremeni">  ,       ? </h2><br><p> ,   request_handler-     -   .  ,      ,           ? </p><br><p>  RESTinio    ,   -  request_handler-.    - ,     , RESTinio       . ,         . , : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:32:23.618] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:32:23.618] INFO: init accept #0 [2019-05-13 15:32:23.618] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:32:26.768] TRACE: accept connection from 127.0.0.1:49502 on socket #0 [2019-05-13 15:32:26.768] TRACE: [connection:1] start connection with 127.0.0.1:49502 [2019-05-13 15:32:26.768] TRACE: [connection:1] start waiting for request [2019-05-13 15:32:26.768] TRACE: [connection:1] continue reading request [2019-05-13 15:32:26.768] TRACE: [connection:1] received 78 bytes [2019-05-13 15:32:26.768] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:32:30.768] TRACE: [connection:1] handle request timed out [2019-05-13 15:32:30.768] TRACE: [connection:1] close [2019-05-13 15:32:30.768] TRACE: [connection:1] close: close socket [2019-05-13 15:32:30.768] TRACE: [connection:1] close: timer canceled [2019-05-13 15:32:30.768] TRACE: [connection:1] close: reset responses data [2019-05-13 15:32:31.768] WARN: [connection:1] try to write response, while socket is closed [2019-05-13 15:32:31.768] TRACE: [connection:1] destructor called</code> </pre> <br><p>   -       . ,      ,  RESTinio   , ..     . </p><br><p>   -    <code>handle_request_timeout</code> ,     RESTinio- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ). </p><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p> ,   ,      RESTinio ‚Äî   ,   .  ,     RESTinio,    ,        RESTinio,     . </p><br><p>      RESTinio        ,  , ,  :  ? -  ? -  ? - -  ? </p><br><p>  PS.    RESTinio     ,   SObjectizer,    .  ,  -   RESTinio ,     : " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> C++      HTTP-   </a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> HTTP-  C++:   RESTinio,   libcurl.  1</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shrimp:     HTTP    C++  ImageMagic++, SObjectizer  RESTinio</a> " </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451728/">https://habr.com/ru/post/pt451728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451718/index.html">Criar Assistente de Voz</a></li>
<li><a href="../pt451720/index.html">FIAS carregando no banco de dados no MSSQLSERVER por meios improvisados ‚Äã‚Äã(SQLXMLBULKLOAD). Como (provavelmente) n√£o precisa ser feito</a></li>
<li><a href="../pt451722/index.html">Biblioteca de widgets ass√≠ncronos Qt-async</a></li>
<li><a href="../pt451724/index.html">Skyrmion to skyrmion discord: skyrmions polares tridimensionais em ferroel√°sticos</a></li>
<li><a href="../pt451726/index.html">Procurando trabalho no exterior: 7 dicas simples para profissionais de TI</a></li>
<li><a href="../pt451738/index.html">Breve revis√£o do artigo "DeViSE: Um Modelo de Incorpora√ß√£o Visual-Sem√¢ntica Profunda"</a></li>
<li><a href="../pt451742/index.html">Um dia antes do DotNext 2019 Piter. An√∫ncio de transmiss√£o gratuita</a></li>
<li><a href="../pt451746/index.html">MegaSlerm para engenheiros e arquitetos Kubernetes</a></li>
<li><a href="../pt451748/index.html">Monitorando o status do SSD em matrizes Qsan</a></li>
<li><a href="../pt451750/index.html">Livro "Elasticsearch, Kibana, Logstash e pr√≥xima gera√ß√£o de mecanismos de pesquisa"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>