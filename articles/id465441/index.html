<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™ƒ ğŸ¦‹ ğŸ•º LuaVela: implementasi Lua 5.1 berdasarkan LuaJIT 2.0 ğŸ‘¬ â—¼ï¸ ğŸ¡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa waktu lalu kami mengumumkan rilis publik dan dibuka di bawah lisensi MIT kode sumber LuaVela - implementasi Lua 5.1, berdasarkan LuaJIT 2.0. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>LuaVela: implementasi Lua 5.1 berdasarkan LuaJIT 2.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iponweb/blog/465441/">  Beberapa waktu lalu kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengumumkan</a> rilis publik dan dibuka di bawah lisensi MIT kode sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LuaVela</a> - implementasi Lua 5.1, berdasarkan LuaJIT 2.0.  Kami mulai mengerjakannya pada 2015, dan pada awal 2017 itu digunakan di lebih dari 95% proyek perusahaan.  Sekarang saya ingin melihat kembali jalan yang dilalui.  Keadaan apa yang mendorong kami untuk mengembangkan implementasi bahasa pemrograman kami sendiri?  Masalah apa yang kita hadapi dan bagaimana kita menyelesaikannya?  Bagaimana LuaVela berbeda dari garpu LuaJIT lainnya? <br><a name="habracut"></a><br><h1>  Latar belakang </h1><br>  Bagian ini didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> kami tentang HighLoad ++.  Kami mulai aktif menggunakan Lua untuk menulis logika bisnis produk kami di tahun 2008.  Awalnya vanua Lua, dan sejak 2009 - LuaJIT.  Protokol RTB meletakkan kerangka kerja yang ketat untuk memproses permintaan, sehingga transisi ke implementasi bahasa yang lebih cepat adalah logis dan, dari beberapa titik, solusi yang diperlukan. <br><br>  Seiring waktu, kami menyadari bahwa ada batasan tertentu pada arsitektur LuaJIT.  Yang paling penting bagi kami adalah bahwa LuaJIT 2.0 menggunakan pointer 32-bit.  Ini membawa kami ke situasi di mana berjalan di Linux 64-bit membatasi ukuran ruang alamat virtual memori proses menjadi satu gigabyte (dalam versi kernel Linux yang lebih baru, batas ini dinaikkan menjadi dua gigabyte): <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* MAP_32BIT    4  x86-64: */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr = mmap((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)MMAP_REGION_START, size, MMAP_PROT, MAP_32BIT | MMAP_FLAGS, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Keterbatasan ini menjadi masalah besar - pada tahun 2015, 1-2 gigabyte memori tidak lagi cukup untuk banyak proyek untuk memuat data yang bekerja dengan logika.  Perlu dicatat bahwa setiap instance dari mesin virtual Lua adalah single-threaded dan tidak tahu cara berbagi data dengan instance lain - ini berarti bahwa dalam praktiknya, setiap mesin virtual dapat mengklaim ukuran memori tidak melebihi 2GB / n, di mana n adalah jumlah alur kerja server kami aplikasi. <br><br>  Kami melewati beberapa solusi untuk masalah ini: kami mengurangi jumlah utas di server aplikasi kami, mencoba mengatur akses ke data melalui LuaJIT FFI, menguji transisi ke LuaJIT 2.1.  Sayangnya, semua opsi ini tidak menguntungkan secara ekonomi atau tidak memiliki skala yang baik dalam jangka panjang.  Satu-satunya yang tersisa bagi kami adalah mengambil kesempatan dan bercabang LuaJIT.  Pada saat ini, kami membuat keputusan yang sangat menentukan nasib proyek. <br><br>  Pertama, kami segera memutuskan untuk tidak membuat perubahan pada sintaks dan semantik bahasa tersebut, dengan fokus menghilangkan batasan arsitektur LuaJIT, yang ternyata menjadi masalah bagi perusahaan.  Tentu saja, ketika proyek dikembangkan, kami mulai menambahkan ekstensi (kami akan membahas ini di bawah) - tetapi kami mengisolasi semua API baru dari perpustakaan bahasa standar. <br><br>  Selain itu, kami meninggalkan lintas platform demi mendukung hanya Linux x86-64, satu-satunya platform produksi kami.  Sayangnya, kami tidak memiliki sumber daya yang cukup untuk menguji jumlah perubahan raksasa yang akan kami buat ke platform. <br><br><h1>  Sekilas di bawah kap platform </h1><br>  Mari kita lihat dari mana batasan ukuran pointer berasal.  Untuk mulai dengan, tipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">angka</a> dalam Lua 5.1 adalah (dengan beberapa peringatan kecil) tipe C ganda, yang pada gilirannya sesuai dengan tipe presisi ganda yang didefinisikan oleh standar IEEE 754. Dalam pengkodean tipe 64-bit ini, kisaran nilai disorot untuk presentasi NaN.  Secara khusus, berapa nilai dalam kisaran [0xFFF8000000000000;  0xFFFFFFFFFFFFFFFFFF]. <br><br>  Dengan demikian, kita dapat mengemas nilai 64-bit tunggal baik nomor presisi ganda "nyata", atau entitas tertentu, yang dari sudut pandang tipe ganda akan ditafsirkan sebagai NaN, dan dari sudut pandang platform kami itu akan menjadi sesuatu yang lebih bermakna - misalnya, menurut jenis objek (32 bit tinggi) dan penunjuk ke isinya (32 bit rendah): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> TValue { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> type; } o; };</code> </pre><br>  Teknik ini kadang-kadang disebut penandaan NaN (atau tinju NaN), dan TValue pada dasarnya menggambarkan bagaimana LuaJIT mewakili nilai variabel dalam Lua.  TValue juga memiliki hipostasis ketiga yang digunakan untuk menyimpan pointer ke fungsi dan informasi untuk memutar kembali tumpukan Lua, yaitu, dalam analisis akhir, struktur data terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> TValue { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> type; } o; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">frame</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *func; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> link; } f; };</code> </pre><br>  Bidang frame.link dalam definisi di atas adalah tipe uintptr_t, karena dalam beberapa kasus ini menyimpan pointer, dan dalam kasus lain itu adalah integer.  Hasilnya adalah representasi yang sangat kompak dari tumpukan mesin virtual - pada kenyataannya, itu adalah array nilai TV, dan setiap elemen array ditafsirkan secara situasional sebagai salah satu angka, kemudian sebagai pointer yang diketik ke objek, atau sebagai data tentang bingkai Lua-stack. <br><br>  Mari kita lihat sebuah contoh.  Bayangkan kita mulai dengan LuaJIT kode Lua ini dan mengatur break point di dalam fungsi cetak: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> .. x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> n = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span> foo(b) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> bar({}, <span class="hljs-string"><span class="hljs-string">"Lua"</span></span>)</code> </pre><br>  Lua stack pada titik ini akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/1n/av/hn/1navhnm8vbz-inawirkvewxppme.png" alt="Lua stack menggunakan LuaJIT 2.0"><br><br>  Dan semuanya akan baik-baik saja, tetapi teknik ini mulai gagal segera setelah kami mencoba memulai pada x86-64.  Jika kita menjalankan dalam mode kompatibilitas untuk aplikasi 32-bit, kita bersandar pada pembatasan mmap yang telah disebutkan di atas.  Dan pointer 64-bit tidak akan bekerja di luar kotak sama sekali.  Apa yang harus dilakukan  Untuk memperbaiki masalah saya harus: <br><br><ol><li>  Perpanjang nilai TV dari 64 hingga 128 bit: dengan cara ini kita mendapatkan kekosongan "jujur" pada platform 64-bit. </li><li>  Perbaiki kode mesin virtual sesuai. </li><li>  Buat perubahan pada kompiler JIT. </li></ol><br>  Total volume perubahan ternyata sangat signifikan dan cukup mengasingkan kami dari LuaJIT yang asli.  Perlu dicatat bahwa ekstensi TValue bukan satu-satunya cara untuk menyelesaikan masalah.  Di LuaJIT 2.1, kami pergi dengan cara lain dengan menerapkan mode LJ_GC64.  Peter Cawley, yang membuat kontribusi besar untuk pengembangan mode operasi ini, membacanya di sebuah pertemuan di London.  Nah, dalam kasus LuaVela, tumpukan untuk contoh yang sama terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/ar/rj/yv/arrjyvsnfyixhd8haufn95nhgu8.png" alt="Lua stack saat menggunakan LuaVela"><br><br><h1>  Keberhasilan pertama dan stabilisasi proyek </h1><br>  Setelah berbulan-bulan pengembangan aktif, saatnya untuk mencoba LuaVela dalam pertempuran.  Sebagai percobaan, kami memilih proyek yang paling bermasalah dalam hal konsumsi memori: jumlah data yang harus mereka gunakan, jelas melebihi 1 gigabyte, sehingga mereka terpaksa menggunakan berbagai solusi.  Hasil pertama menggembirakan: LuaVela stabil dan menunjukkan kinerja yang lebih baik dibandingkan dengan konfigurasi LuaJIT yang digunakan dalam proyek yang sama ini. <br><br>  Pada saat yang sama, pertanyaan tentang pengujian muncul.  Untungnya, kami tidak harus memulai dari awal, karena sejak hari pertama pengembangan, selain melakukan staging server, kami juga siap membantu: <br><br><ul><li>  Tes fungsional dan integrasi server aplikasi yang menjalankan logika bisnis semua proyek perusahaan. </li><li>  Tes proyek individu. </li></ul><br>  Seperti yang telah ditunjukkan oleh praktik, sumber daya ini cukup untuk debugging dan membawa proyek ke kondisi stabil minimum (mereka melakukan perakitan dev - diluncurkan ke pementasan - itu bekerja dan tidak macet).  Di sisi lain, pengujian seperti itu melalui proyek-proyek lain benar-benar tidak cocok dalam jangka panjang: proyek dengan tingkat kerumitan seperti implementasi bahasa pemrograman tidak dapat memiliki tes sendiri.  Selain itu, kurangnya tes langsung di proyek murni teknis rumit pencarian dan koreksi kesalahan. <br><br>  Dalam dunia yang ideal, kami ingin menguji tidak hanya implementasi kami, tetapi juga memiliki serangkaian tes yang memungkinkan kami untuk memvalidasinya terhadap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semantik bahasa</a> .  Sayangnya, beberapa kekecewaan menunggu kami dalam masalah ini.  Terlepas dari kenyataan bahwa komunitas Lua secara sukarela membuat percabangan implementasi yang ada, hingga saat ini, serangkaian uji validasi yang sama tidak ada.  Situasi berubah menjadi lebih baik ketika, pada akhir 2018, FranÃ§ois Perrad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengumumkan</a> proyek lua-Harness. <br><br>  Pada akhirnya, kami menutup masalah pengujian dengan mengintegrasikan suite pengujian paling lengkap dan representatif dalam ekosistem Lua ke dalam repositori kami: <br><br><ul><li>  <a href="">Tes yang</a> ditulis oleh pencipta bahasa untuk implementasi Lua 5.1. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes</a> disediakan oleh komunitas oleh penulis LuaJIT Mike Pall. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lua harness</a> </li><li>  Subset dari tes proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MAD</a> sedang dikembangkan oleh CERN. </li><li>  Dua set tes yang telah kami buat di IPONWEB dan terus diisi ulang sejauh ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> untuk pengujian fungsional platform, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lain</a> menggunakan kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cmocka</a> untuk menguji C API dan semua yang kurang pengujian pada level kode Lua. </li></ul><br>  Pengenalan setiap kumpulan tes memungkinkan kami untuk mendeteksi dan memperbaiki 2-3 kesalahan kritis - jadi jelas bahwa upaya kami membuahkan hasil.  Meskipun topik pengujian runtime dan kompiler bahasa (baik statis maupun dinamis) benar-benar tidak terbatas, kami percaya bahwa kami telah meletakkan dasar yang agak solid untuk pengembangan proyek yang stabil.  Kami berbicara tentang masalah pengujian implementasi Lua kami sendiri (termasuk topik seperti bekerja dengan bangku tes dan debugging postmortem) dua kali, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lua di Moskow 2017</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++ 2018</a> - setiap orang yang tertarik pada detail dipersilakan untuk menonton video dari laporan ini.  Nah, lihat direktori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes</a> di repositori kami, tentu saja. <br><br><h1>  Fitur baru </h1><br>  Dengan demikian, kami memiliki implementasi stabil Lua 5.1 untuk Linux x86-64, yang dikembangkan oleh kekuatan tim kecil yang secara bertahap â€œmenguasaiâ€ warisan LuaJIT dan mengumpulkan keahlian.  Dalam kondisi seperti itu, keinginan untuk memperluas platform dan menambahkan fitur yang tidak ada di vanilla Lua maupun di LuaJIT, tetapi yang akan membantu kami memecahkan masalah mendesak lainnya, menjadi sangat wajar. <br><br>  Deskripsi terperinci dari semua ekstensi disediakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> dalam format RST (gunakan cmake. &amp;&amp; buat dokumen untuk membuat salinan lokal dalam format HTML).  Deskripsi lengkap tentang ekstensi Lua API dapat ditemukan <a href="">di tautan ini</a> , dan C API <a href="">di sini</a> .  Sayangnya, dalam artikel ulasan tidak mungkin untuk membicarakan semuanya, jadi di sini adalah daftar fungsi yang paling signifikan: <br><br><ul><li>  DataState - kemampuan untuk mengatur akses bersama ke objek dari beberapa instance independen mesin virtual Lua. </li><li>  Kemampuan untuk mengatur <a href="">batas waktu untuk coroutine</a> dan mengganggu eksekusi mereka yang berjalan lebih lama dari itu. </li><li>  Serangkaian optimisasi kompiler JIT yang dirancang untuk memerangi peningkatan eksponensial dalam jumlah jejak saat menyalin data di antara objek - kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membicarakan</a> hal ini di HighLoad ++ 2017, tetapi hanya beberapa bulan yang lalu kami memiliki ide kerja baru yang belum didokumentasikan. </li><li>  Toolkit Baru: Sampling Profiler.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dumpanalyze</a> compiler debug output analyzer, dll. </li></ul><br>  Masing-masing fitur ini layak mendapat artikel terpisah - tulis di komentar mana yang ingin Anda baca lebih lanjut. <br><br>  Di sini saya ingin berbicara sedikit tentang bagaimana kami mengurangi beban pada pengumpul sampah.  <a href="">Sealing</a> memungkinkan Anda untuk membuat objek tidak dapat diakses oleh pengumpul sampah.  Dalam proyek khas kami, sebagian besar data (hingga 80%) di dalam mesin virtual Lua sudah merupakan aturan bisnis, yang merupakan tabel Lua yang kompleks.  Masa hidup tabel ini (menit) jauh lebih lama dari masa permintaan yang diproses (puluhan milidetik), dan data di dalamnya tidak berubah selama pemrosesan kueri.  Dalam situasi seperti itu, tidak masuk akal untuk memaksa pengumpul sampah untuk berulang di sekitar struktur data besar ini berulang kali.  Untuk melakukan ini, kami secara rekursif "menyegel" objek dan menyusun ulang data sedemikian rupa sehingga pengumpul sampah tidak pernah mencapai objek "yang disegel" atau isinya.  Dalam vanilla Lua 5.4, masalah ini akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diselesaikan dengan</a> mendukung generasi objek dalam pengumpulan sampah generasi. <br><br>  Penting untuk diingat bahwa objek "yang disegel" tidak boleh ditulis.  Ketidaktaatan terhadap invarian ini mengarah pada munculnya petunjuk yang menggantung: misalnya, objek "tertutup" mengacu pada objek biasa, dan pengumpul sampah, melewatkan objek "tersegel" saat berjalan di sekitar tumpukan, melompati objek biasa - dengan perbedaan bahwa objek "tersegel" tidak dapat dilepaskan, dan yang biasa bisa.  Setelah menerapkan dukungan untuk invarian ini, kami pada dasarnya mendapatkan dukungan <a href="">imunitas</a> gratis <a href="">untuk</a> objek, yang tidak ada yang sering disesalkan di Lua.  Saya menekankan bahwa benda-benda yang tidak dapat diubah dan â€œdisegelâ€ bukanlah hal yang sama.  Properti kedua menyiratkan yang pertama, tetapi tidak sebaliknya. <br><br>  Saya juga mencatat bahwa di Lua 5.1 kekebalan dapat diimplementasikan menggunakan metatables - solusinya cukup berhasil, tetapi bukan yang paling menguntungkan dalam hal kinerja.  Informasi lebih lanjut tentang kekebalan "pemeteraian", dan bagaimana kita menggunakannya dalam kehidupan sehari-hari dapat ditemukan dalam laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br><h1>  Kesimpulan </h1><br>  Saat ini, kami puas dengan stabilitas dan serangkaian peluang untuk implementasi kami.  Dan meskipun karena keterbatasan awal, implementasi kami jauh lebih rendah daripada vanilla Lua dan LuaJIT dalam hal portabilitas, itu memecahkan banyak masalah kami - kami berharap solusi ini bermanfaat bagi orang lain. <br><br>  Selain itu, bahkan jika LuaVela tidak cocok untuk produksi, kami mengundang Anda untuk menggunakannya sebagai titik masuk untuk memahami cara kerja LuaJIT atau fork-nya.  Selain menyelesaikan masalah dan memperluas fungsionalitas, selama bertahun-tahun kami telah refactored bagian penting dari basis kode dan menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pelatihan</a> tentang struktur internal proyek - banyak di antaranya berlaku tidak hanya untuk LuaVela, tetapi juga untuk LuaJIT. <br><br>  Terima kasih atas perhatian Anda, kami menunggu permintaan tarik! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465441/">https://habr.com/ru/post/id465441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465429/index.html">Namun C adalah bahasa tingkat rendah</a></li>
<li><a href="../id465431/index.html">Analisis kode sumber RPC kerangka kerja Dubbo Apache dengan penganalisa statis PVS-Studio</a></li>
<li><a href="../id465433/index.html">Robot kerja - pria bahagia</a></li>
<li><a href="../id465435/index.html">Distribusi mana yang lebih baik digunakan untuk sistem embedded Anda?</a></li>
<li><a href="../id465437/index.html">Mengapa saya menolak bekerja di AWS</a></li>
<li><a href="../id465445/index.html">Catatan dari penyedia IoT. Kutukan Keluar Impuls</a></li>
<li><a href="../id465449/index.html">Bagaimana masalah Mail.ru dan FSB ditempa oleh reputasi Pavel Durov dan kepercayaan pada Telegram</a></li>
<li><a href="../id465453/index.html">3 September - Hari CTO di St. Petersburg</a></li>
<li><a href="../id465455/index.html">Bekerja dengan insiden, meningkatkan respons insiden dan nilai utang teknis. Bahan mitap Backend United 4: Okroshka</a></li>
<li><a href="../id465457/index.html">Tentang PBR di jari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>