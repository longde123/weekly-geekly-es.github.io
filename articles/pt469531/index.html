<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎺 📴 ✏️ "Comparar linguagens de programação em uma base de pior a pior é uma ocupação completamente idiota." 👋🏻 👩🏻‍🤝‍👨🏽 ❔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Isenção de responsabilidade : sim, na segunda-feira publicamos um habrapost com exatamente essa comparação de idiomas. Não, nós não somos loucos. Tudo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Comparar linguagens de programação em uma base de pior a pior é uma ocupação completamente idiota."</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469531/"><img src="https://habrastorage.org/webt/yv/ge/fz/yvgefz8egxcjmh0dvu66dqynh5q.png"><br><br><blockquote>  <b>Isenção de responsabilidade</b> : sim, na segunda-feira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publicamos um habrapost</a> com exatamente essa comparação de idiomas.  Não, nós não somos loucos.  Tudo está indo conforme o planejado. </blockquote><br>  Vitaly Bragilevsky combina conhecimento de ciência da computação teórica e prática de programação atual.  Ele ensina disciplinas relacionadas à ciência da computação teórica, é membro do Comitê de Normalização Haskell e membro do comitê de supervisão para o desenvolvimento do compilador GHC Haskell. <br><br>  Esta habrastatya é uma ótima entrevista com Vitaly sobre os seguintes tópicos: <br><br><ul><li>  Ensinar e conhecer JavaScript; <br></li><li>  Por que escolher Haskell; <br></li><li>  O lugar das linguagens funcionais na vida de um programador; <br></li><li>  Qual a vantagem do JavaScript e como ele evolui; <br></li><li>  O que aparecerá nas linguagens de programação nos próximos 10 a 15 anos; <br></li><li>  Quais linguagens de programação são confiáveis ​​e por quê; <br></li><li>  Qual é a diferença entre conferências científicas e conferências de desenvolvedores.  Por que um professor iria até eles; <br></li><li>  É importante ler para o programador, os livros são obsoletos e quais deles devem ler. <br></li></ul><br>  As entrevistas são conduzidas por membros do Comitê de Programa da conferência do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HolyJS 2019 em Moscou</a> , Alexei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zolotikh</a> e Artyom Kobzar.  Se a entrevista não for suficiente para você, em breve, no próximo HolyJS, Vitaliy dirá e mostrará com exemplos como conectar o JavaScript à teoria dos algoritmos. <br><a name="habracut"></a><br><h2>  Sobre como ensinar e conhecer JavaScript </h2><br>  <b>Artyom</b> : Entre os nossos ouvintes, especialmente entre a comunidade JavaScript, você não é amplamente conhecido. Conte-nos sobre você, o que faz e quais são seus hobbies - trabalhadores, profissionais, talvez não trabalhando. <br><br>  <b>Vitaliy</b> : Ensino principalmente, ensino na Universidade Estadual de São Petersburgo e participo periodicamente de outros trabalhos.  Como sou professor, tive que estudar muitos tópicos diferentes.  Como geralmente acontece em uma universidade, é necessário ler um curso específico e, para isso, você precisa entender tudo isso. <br><br>  Aconteceu que eu ensinei muitas coisas.  Por exemplo, um dos meus primeiros cursos especiais, que me foram designados no primeiro ano de trabalho, quando eu era muito jovem, foi chamado de "tecnologias XML da Web".  Então esses eram tópicos quentes, o Ajax apareceu em JavaScript e realmente não havia literatura.  Expliquei como usar tudo isso. <br><br>  Desde então, ninguém realmente entendeu como usá-lo, tudo ficou limitado a exemplos como este: existem duas listas suspensas, um usuário seleciona um item em uma das listas, uma solicitação é enviada ao servidor e você recebe dados para preencher a segunda lista suspensa.  Era uma novidade: havia poucos sites nesses sites.  Então, apenas a pesquisa do Google apareceu no modo beta, quando, enquanto você começa a digitar algum tipo de consulta, ele pede para você continuar.  O material do Ajax era novo e eu os ensinei. <br><br>  O que eu não ensinei somente depois disso: coisas matemáticas e programador.  Uma vez me deparei com Haskell e, desde então, tornou-se a principal área de atração, o que fiz.  Além de ensinar, estudando tudo em ciência da computação em geral, para ensinar, comecei a colaborar com a editora "DMK-press", traduzi vários livros para eles (com outras pessoas, eu mesmo editei algo).  Também estava em torno de Haskell.  Talvez esses dois tipos de atividades - ensino e o que está associado à tradução de livros para o russo - tenham sido as principais coisas que fiz. <br><br>  <b>Artyom</b> : Ou seja, chamamos diretamente um veterano do JavaScript para nós.  Encontrei o Ajax e, provavelmente, até o PHP. <br><br>  <b>Vitaliy</b> : Sim, eu até programei em PHP nos primeiros anos, escrevi vários sites. <br><br><h2>  Sobre os motivos da escolha da Haskell </h2><br><br>  <b>Artyom</b> : Você é o mais famoso da comunidade Haskell.  Por que você parou em Haskell e neste ecossistema? <br><br>  <b>Vitaliy</b> : Como nunca considerei uma carreira como programador para mim, fui livre no que gosto.  Eu não precisava me interessar pelo que eles pagam mais.  Quando descobri sobre Haskell, gostei muito.  Isso não é muito bom para falar, e de alguma forma eu até me permiti dizer algo como "Haskell é um idioma para pessoas inteligentes na comunidade de língua inglesa, e a comunidade é mais inteligente, em média".  Os americanos me venceram por isso, e eles estão certos.  Mas era exatamente nisso que eu estava interessado. <br><br>  Isto é, ao mesmo tempo, enquanto eu ainda estudava em uma universidade, eu estava envolvido em matemática bastante rigorosa, portanto, mudar para um tópico de programação relativamente duro era muito natural para mim.  Em geral, está claro que agora, das linguagens de programação usadas na produção, Haskell é uma das mais intensivas em ciência ou em recursos.  Toda essa abstração que existe é a mais próxima da matemática.  Portanto, para mim, foi uma escolha natural. <br><br><h2>  Sobre linguagens funcionais e seu lugar no mundo dos programadores </h2><br>  <b>Alexei</b> : Como você se sente sobre linguagens dinâmicas e funcionais?  E as coisas do tipo Lisp? <br><br>  <b>Vitaliy</b> : Eu gosto de me posicionar não tanto como um Haskellist, mas como um amante de linguagens de programação em geral.  Em primeiro lugar, é claro que todas as línguas têm o direito de existir.  Acredito que comparar linguagens de programação em uma base “melhor ou pior” é uma ocupação completamente idiota.  Infelizmente, isso geralmente é feito nas redes sociais e não apenas, mas isso não faz sentido. <br><br>  Eu gosto de aprender os recursos das linguagens de programação e de alguma forma classificar as linguagens de programação por esses recursos.  Mas considerar que esse é um bom recurso e ruim é estúpido.  Portanto, é claro que os idiomas com digitação dinâmica certamente têm o direito de existir.  Por exemplo, agora no meu curso para calouros tomei a linguagem de programação Julia como base.  Esta é uma linguagem dinâmica, existe um sistema de tipos.  Foi interessante para mim ensiná-lo, ao mesmo tempo, a ver essa área de aplicabilidade. <br><br>  Em geral, a primeira linguagem funcional que me deparei foi o Lisp.  Quando li o livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“A Estrutura e a Interpretação de Programas de Computador”</a> há muitos anos, é claro, tudo isso impressiona.  Portanto, tenho grande interesse em tudo isso.  Por exemplo, também gosto muito de JavaScript, porque conheço bem sua história. <br><br>  Eu sei que quando ele apareceu pela primeira vez, deveria ter sido algo como Lisp, porque no início a sintaxe original era semelhante ao esquema.  E então, por algumas razões de marketing, ele foi substituído por um C-like, mas, é claro, as linguagens Lisp estão lá dentro, e isso me impressiona. <br><br>  Em geral, tenho a sensação de que muitos amantes de JavaScript não sabem disso, e eles estão bem, mas eu sei, então sou ainda melhor.  Portanto, todos os idiomas são bons, e é interessante para mim estudá-los, é interessante estudar o campo da aplicabilidade, é interessante ver o que é feito mais fácil e mais conveniente neles.  E, em geral, essa comparação de idiomas para tarefas individuais também é uma área interessante separada, com a qual gosto de lidar. <br><br><h2>  O que é bom em javascript </h2><br>  <b>Artyom</b> : Enquanto você preparava o relatório, estava em contato com a nova versão do JavaScript, com o que estava incorporado nele.  Como você pode destacar uma solução boa, ruim ou talvez interessante do ponto de vista da teoria das linguagens de programação? <br><br>  <b>Vitaliy</b> : Avaliando do ponto de vista da variedade de linguagens de programação, é claro, a coisa mais interessante no JavaScript é seu modelo de objeto.  Isto é o que era desde o começo.  O modelo de protótipo tem uma história muito rica, é super interessante porque praticamente nenhuma outra linguagem moderna o possui agora. <br><br>  Em linguagens como C #, usando métodos de extensão, eles resolvem o problema de adicionar métodos a objetos existentes.  Isso é o que o JavaScript era desde o início e parece muito mais natural.  Ou seja, temos um protótipo ao qual adicionamos métodos e criamos novos objetos com base nele.  Em idiomas como C #, isso é mais artificial, na minha opinião. <br><br>  Eu estava interessado em ver como os módulos são adicionados ao JS.  Em JavaScript, por muito tempo houve problemas associados aos módulos, por décadas, você pode dizer, e eu me pergunto como eles começaram a fazer tudo isso.  Como os módulos são um tópico teórico profundo, existem muitas abordagens diferentes para sua implementação.  É verdade que não posso dizer que estudei completamente isso, mas é isso que me parece um caso interessante no campo do desenvolvimento de linguagens de programação.  Ou seja, como adicionar recursos ao idioma existente que não existiam antes. <br><br>  Isso ainda é interessante porque, há alguns anos, em Haskell, houve uma tentativa de adicionar, digamos, módulos mais corretos.  Agora podemos dizer que essa tentativa falhou, ninguém começou a usá-la.  Esse é o chamado projeto mochila, ou seja, parece estar implementado, mas o uso é tão insignificante que ficou claro que eles criaram um bom novo sistema modular, mas não funcionou muito bem. <br><br>  Tenho a sensação de conversar com diferentes caras envolvidos em JavaScript que os módulos em JS tiveram um desempenho melhor.  É verdade que sei disso muito superficialmente.  Eu acho que a opinião sobre JavaScript é muito influenciada pelo fato de que você pode escrever um código muito ruim lá.  E se você pode escrever um código muito ruim, alguém deve escrevê-lo em grandes quantidades.  Isso afeta negativamente a avaliação do idioma.  Do ponto de vista da teoria das linguagens de programação, isso, obviamente, não é muito bom. <br><br>  <b>Alexey</b> : Você conseguiu ver as últimas versões do JavaScript?  O que surpreendeu além do sistema de módulos? <br><br>  <b>Vitaliy</b> : Não posso dizer que consegui.  Folheei algo, mas não muito profundo.  Eu não posso listar. <br><br><h2>  O que aparecerá em linguagens de programação em um futuro próximo </h2><br><br>  <b>Artyom</b> : A teoria das linguagens de programação é um ambiente bastante acadêmico e, em princípio, interessante.  Quais são os novos recursos nos idiomas que estão prestes a aparecer em 10 a 15 anos?  Que pesquisas estão em andamento nessa área? <br><br>  <b>Vitaliy</b> : Eu diria que o tópico mais quente no momento é a digitação gradual.  É quando, ao mesmo tempo, no programa, existem partes tipificadas e não partes digitadas.  É para Python, para JavaScript, é feito para linguagens de brinquedo.  Ou seja, podemos, em primeiro lugar, combinar partes digitadas e não tipadas e, em segundo lugar, temos uma maneira simples de expandir a digitação. <br><br>  Ou seja, estamos implementando um protótipo de algo, como sempre foi feito em linguagens dinâmicas sem nenhum tipo, e então começamos a travar tipos em componentes individuais, cada vez mais.  Idealmente, obtemos um programa digitado com todos os benefícios.  Existem menos erros no tempo de execução e assim por diante. <br><br>  Este é talvez um dos desenvolvimentos mais importantes.  Alguns elementos já estão na forma de bibliotecas, mas até agora essa ainda é uma área de pesquisa.  Se assistirmos às principais conferências sobre linguagens de programação, certamente haverá várias seções dedicadas à digitação gradual, digitação.  Isso é algo que quase certamente será incluído nas linguagens mais dinâmicas, porque é muito conveniente.  Acontece a combinação de dois mundos. <br><br>  Há dez anos, pesquisas são feitas sobre tipos dependentes, quando o tipo depende dos valores.  O maior problema é que ele apaga a linha entre o estágio de compilação e o estágio de execução, porque, no estágio de compilação, valores específicos ainda não são conhecidos, mas os tipos precisam ser verificados.  Ou seja, valores específicos aparecem em tempo de execução, mas os tipos já devem estar corretos. <br><br>  E aí você já precisa escrever uma função na qual, dependendo do valor passado, o tipo de resultado seja alterado.  Esse embaçamento da fronteira entre o tempo de execução e o tempo de compilação é uma coisa muito interessante, agora também está sendo estudado ativamente em teoria por 10 a 15 anos e quase certamente cairá em muitas línguas, principalmente de tipo estaticamente, porque o sistema de tipo expressivo aumenta significativamente devido a esse desenvolvimento. <br><br>  É verdade que há uma desvantagem.  Acontece que os programas de gravação podem ser muito complicados.  Parece que os tipos controlam tudo, mas a escrita é muito difícil, então às vezes você pensa que, com esses tipos dependentes, pegue algum tipo qualquer e programe-o. <br><br>  <b>Artyom</b> : Eles fazem isso aqui. <br><br>  <b>Vitaliy</b> : Isso também pode ser feito com um grande desejo, às vezes não há para onde ir.  Quando você sai do servidor, não entende o quê e, até iniciar o programa, não sabe, ainda precisa usar essas coisas, mesmo em Haskell, não há para onde ir. <br><br><h2>  Como Vitaly desenvolve Haskell </h2><br><br>  <b>Artyom</b> : É engraçado.  De volta a Haskell.  Você é membro do comitê Haskell 2020. Na Podlodka, você disse que não estava fazendo nada lá, mas em uma entrevista, mencionou que ainda estava trabalhando em famílias simples e limitadas.  Que outras coisas específicas você implementa, supervisiona ou participa da implementação, talvez, do novo padrão Haskell? <br><br>  <b>Vitaliy</b> : Estes são dois comitês diferentes.  Eu tenho dois comitês.  Um deles é o Haskell 2020, no qual nada realmente acontece, é um comitê morto.  Seu objetivo é escrever um padrão de linguagem e certamente não será escrito.  Parece melhor - “Comitê para o desenvolvimento de um padrão de linguagem”, mas não funciona. <br><br>  O segundo comitê é chamado de "Comitê de Supervisão do GHC Compiler" - o Glasgow Haskell Compiler.  Estou nele há pouco mais de um ano, a tarefa dele é muito menos ambiciosa.  Esse comitê considera recursos, sugestões para alterar o compilador e a versão do idioma implementado neste compilador.  Existe um Haskell padrão, mas existe um Haskell implementado por um compilador específico.  Aqui está um exemplo de uma extensão de idioma: "famílias de tipos simples".  Esta é uma tentativa de facilitar a programação em nível de tipo adicionando controles adicionais. <br><br>  É verdade que devo dizer que existe um ambiente razoavelmente livre, ou seja, eu provavelmente não segui nenhum adereço durante todo o verão e devo muito do meu tempo a esse comitê, pretendo voltar a isso. <br><br>  Minha tarefa é a seguinte: preparou-a: existe uma proposta descrita, preciso procurar, talvez aconselhar o autor a finalizar algo e, finalmente, ir ao comitê com uma proposta para recomendar a inclusão no compilador ou recusar.  Depois de enviar esta proposta, o comitê discute e toma uma decisão - tudo é decidido coletivamente por lá. <br><br>  Uma das frases que devo está relacionada ao sublinhado nas anotações padrão.  Quando você não pode especificar completamente o tipo, ou seja, existem buracos e existe uma proposta para reformar esse sistema, de modo a analisar tudo de maneira uniforme.  Os furos podem estar em anotações padrão, na implementação de funções.  Uma certa abordagem unificada é proposta. <br><br>  Esse comitê considera mudanças estreitas no compilador. <br><br>  <b>Artyom</b> : Também temos um comitê de padronização - TC39.  A princípio, um certo aparece e ele está procurando um campeão.  Um campeão é uma pessoa de um comitê que está pronto para supervisionar este site.  Então, até onde eu sei, temos uma graduação por estágio.  Existem 4 estágios nos quais o recurso se move.  Zero é quando existe apenas uma proposta, quando um campeão é encontrado e uma API de alto nível é descrita, e assim por diante.  O quarto já está inserido no idioma.  A pessoa que fez a proposição e o curador participam das reuniões deste comitê e promovem essa proposta.  Como isso está acontecendo com você?  É apenas um comitê que decide internamente? <br><br>  <b>Vitaliy</b> : Toda a nossa atividade é aberta, é conduzida no GitHub e parcialmente em listas de discussão abertas.  O autor da proposta entra - enquanto estamos considerando a proposta, a implementação não nos interessa muito.  Pode ser, pode não ser, não analisamos de forma alguma, nada depende disso.  Primeiro, há uma discussão por toda a comunidade, todos podem comentar sobre esta proposta. <br><br>  Então, quando ele se estabeleceu, o autor a submete ao comitê, ou seja, pede ao comitê para considerá-lo.  O secretário do comitê nomeia um pastor que o supervisionará.  Ele olha, analisa, talvez ofereça melhorias ou, pelo contrário, tenta justificar por que isso não tem o direito de existir, após o que ele apresenta uma proposta de rejeitar ou, talvez, enviar uma revisão ou aceitar.  O comitê discute, toma uma decisão. <br><br>  E quando o comitê decide que concordamos com este pré-site, e passa para o status de aceito, em princípio, qualquer um pode assumir sua implementação.  Até o momento, pode não haver implementação, apenas tomamos uma decisão - sim, seria bom ter esse recurso no idioma ou compilador e temos uma lista de subnós aceitos, mas não implementados. <br><br>  Além disso, isso não é mais uma tarefa do comitê; então, alguém faz uma solicitação pull ao código-fonte do compilador, existem engenheiros, a equipe se sobrepõe parcialmente ao comitê, aqueles que já decidem se essa solicitação pull é aceita ou não. <br><br>  Como o comitê concorda em aceitar isso, ou seja, em princípio, é necessário aceitar a solicitação de mesclagem, mas há questões de engenharia lá, não é codificada lá, alguns problemas de desempenho são resolvidos pela equipe que está desenvolvendo diretamente o compilador.  Este não é mais o nosso trabalho. <br><br>  <b>Alexei</b> : Acontece que agora Haskell tem padrões bastante antigos.  Eu vejo que há Haskell 2010. <br><br>  <b>Vitaly</b> : Sim, 2010, muito velho.  Houve várias tentativas de escrever uma nova.  Havia uma idéia de emitir padrões todos os anos, mas, infelizmente, tudo falhou.  Em 2016, um comitê de 2020 foi convocado, mas ele também não fez nada.  Existem várias razões de graus variados de dificuldade, porque este trabalho não está em andamento.  Sim, o último padrão de 2010, não existe um novo e não é visível que ele aparecerá. <br><br><h2>  Sobre cursos e novos projetos </h2><br>  <b>Artyom</b> : Vamos voltar à sua atividade principal, ao ensino.  Eu pessoalmente conheci você no curso da teoria das categorias, o que eu realmente gosto.  Você diz que não gosta dele.  De que outros cursos você se orgulha e dos que você acha que seria bom conhecer?  Por exemplo, o curso pode ter sido com batentes, mas, em princípio, o próprio programa narrativo é muito bom. <br><br>  <b>Vitaly</b> : Primeiramente, publiquei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no YouTube</a> todos os cursos que tenho.  Lá eu tenho um curso sobre Idris - essa é uma linguagem de programação com tipos dependentes e, mesmo em duas versões, eu o li duas vezes.  Também tenho alguns cursos sobre o compilador de idiomas Haskell lá.  Um é dedicado a questões teóricas do modelo.  Não lembro exatamente o nome, mas é sobre como a teoria dos tipos funciona diretamente no compilador Haskell. <br><br>  A idéia é simples: todo o código Haskell é compilado em algum cálculo λ bastante simples, o chamado sistema F com pequenas extensões.  Na verdade, isso está no código do compilador, e o curso se concentra em como esses elementos da teoria dos tipos são usados ​​diretamente no compilador. <br><br>  E há um curso em que geralmente falo sobre a história da inferência de tipo e como a inferência de tipo foi organizada no início, quando foi inventada nos anos 60, antes de a inferência de tipo ser organizada na linguagem Haskell, quais são as dificuldades? como tudo funciona. <br><br>  Há um curso breve que eu lecionei na escola de verão de matemática.  De vez em quando, como me disseram, eles fazem cursos de ciência da computação para que as crianças descansem.      ,  ,    ,   ,        :     .         —  —         .        ,      ,       ,      . <br><br> ,  ,    . -       ,     ,    ,    ,  ,     ,    -  .   ,    - ,         .  ,      ,    -   -   .     . <br><br>        . -,  ,     ,   ,  ,  .      , .     ,    -   ,  -,     - ,   ,       .    -  ,  , -    ,    .          .        , ,     . <br><br>       , ,    , .   ,  , ,      ,           ,    ,     . <br><br> <b></b> :     - ?  ,  ,    .   , ,  , ,    -  . <br><br> <b></b> :         Computer Science Club.    ,          ,  ,     .  ,     . <br><br>     10 .    « GHC Haskell:  ».         GHC,    ,   40 ,      10 .          :     . <br><br>          ,       Haskell,  ,   .            ,  , .     . <br><br>        ,       1-2 .        .      ,  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>    .    ,   : ,  —   ,  -   ,    .           ,       . <br><br> ,  ,   ,   .        ,         ,     .   ,    . <br><br>    ,       ,     ,      ,   ,   .      ,   . <br><br> <b></b> :   ,     JetBrains  - ,    .    ? , -   ? <br><br> <b></b> :  JetBrains      ,    Haskell   ,   JetBrains  Haskell-  ,     . <br><br> <b></b> :  Haskell  JetBrains? <br><br> <b></b> :      Haskell c   JetBrains,    .     ,   . <br><br> <b></b> :     Haskell  JetBrains? <br><br> <b></b> :     -  Haskell   JetBrains?  ,  . <br><br> <b></b> : ,    . () <br><br> <b></b> :     .   ,    Java,    Haskell. <br><br> <b></b> :   ,    JetBrains? <br><br> <b></b> :      JetBrains Education.   JetBrains Research — ,  Education — . <br><br><h2>  JavaScript- </h2><br><br> <b></b> :      ,    , ,   JavaScript? , ,  ,  Elm,       Haskell. <br><br> <b></b> : -,        .  GHCJS   ,  ,      ,    .  Elm    ,       Haskell,  .   ,      ,     -        . <br><br>   ,       ,       ,   .        JavaScript     . <br><br> ,   Idris   —    Idris   PHP,  JavaScript,    .   . , , JavaScript  Haskell . <br><br>     ,  - ,     —     ,         —  ,  . <br><br>    — , ,   ,    ,      .   ,     .  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  HolyJS</a>       ,         ,     ,   ,     ,         .       —   ,    . <br><br>         ,   λ-   ,    — λ-,  ,     ,      .     ,     λ-,     ,    . <br><br>    1936 ,               —         .   ,   . <br><br><h2>        </h2><br><br> <b></b> :        ,     ?      Swift, ,   enum  ,   Union,           ? <br><br> <b></b> :  , ,   .    : ,          ,    . ,      ,  Python        ,            ,    . <br><br>   ,     ,   Python,      .  ,       ,    ,    . <br><br>   ,  ,     ,  ,    ,    .          C#.  C# : -, Microsoft    Java,   , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,      Delphi,   #,   C#   ,      Haskell,     . <br><br>     ,       . ,  JetBrains,   Kotlin,    . Kotlin, C#, Swift  Apple,        .   ,       . <br><br> ++ -   , ,  ,   - ,         ,        ,  . ,  ,   ,  JavaScript ,     . , ,  . <br><br>        ,    ,       . <br><br> <b></b> : -,       ,    ,     Mozilla  Rust. <br><br> <b></b> : , Mozilla —    ,  ,  - open source-,   .      .    ,   Rust   ,     .   ,   Rust   ,  -  , . <br><br>   ,   Twitter   — -     Microsoft,   , ,     C++   Microsoft   Rust.  , .       ,       Rust. ,  , ,    ,      .   ,    . <br><br>   Rust   ,         - ,    . <br><br><h2>       </h2><br><br> <b></b> : ! , ,      , , ,    —   ,  .        , , , - ,       ? <br><br> <b></b> :         ,  ,     .      ,     . -,    , .         .    ,  ,     —   .         —   ,    ,    .     . <br><br>      —    ,  ,   -,    ,      .       ,        . <br><br>      ,  ,   ,  .  ,     ,    .      . ,   , ,       ,      .    -     .        .       . <br><br> <b></b> :      ?      , ,         ,   , ,    ? <br><br> <b></b> :  ,   .   , ,     ,      ,         .       ,    -     ,  , , ,  .  ,      .    ,    —  .    ,   ,    . <br><br>  ,       —   . <br><br><h2>    </h2><br><br> <b></b> :       HolyJS   ? , -    ? ,      . <br><br> <b></b> : ,   ,   ,    ,      ,      .    ,   ,   .    ,             . <br><br>       ,  ,         AppsConf.        .     .         ,    . <br><br>     , , ,  .      : «       ,      ?».      -   , ,        : ,  ,  Twitter ,  Google .    ,       . <br><br>       .  ,   ,   ,   , ,   ,   ,    . <br><br>  ,       ,      ,          .            —  ,    . <br><br><h2>     </h2><br><br>  <b>Artyom</b> : Mais uma pergunta, talvez caótica.  Você escreveu um livro sobre Haskell chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Haskell in Depth</a> ? <br><br>  <b>Vitaliy</b> : Infelizmente, o livro não foi escrito no processo.  Isso é chamado de "programa de acesso antecipado".  E ela, infelizmente, foi desacelerada, e estou lentamente retornando ao trabalho.  Cerca da metade está escrita lá, e a segunda metade está atrasada, pela qual tenho muita vergonha daqueles que adquiriram esse acesso antecipado. <br><br>  <b>Artyom</b> : Aqui está um fato interessante: existe uma opinião na comunidade de que os livros sobre programação, especialmente se não tratam de conhecimentos fundamentais, não são muito bons, porque as informações rapidamente se tornam obsoletas.  Como você, como autor do livro, tem essa experiência?  E você considerou um problema tão grande que as informações que você fornece em um livro podem rapidamente ficar desatualizadas? <br><br>  <b>Vitaliy</b> : Claro, eu não entendo como os livros são escritos em JavaScript - na minha opinião, essa é uma tarefa impossível.  Com Haskell, nesse sentido, é um pouco mais fácil.  Mas aqui está o que posso dizer. <br><br>  Quando estudamos matemática na escola, essa matemática também é geralmente muito desatualizada.  Essas são as coisas que surgiram alguns milhares de anos atrás, algum teorema de Pitágoras.  Talvez ainda esteja sendo implementado, mas dizer que alguém mede as alturas das pirâmides usando o teorema de Pitágoras é algo assim, geralmente são usadas roletas a laser ou algo assim. <br><br>  É sobre o mesmo aqui.  Se uma pessoa é um grande profissional em alguma coisa e usa alguma tecnologia há muito tempo, é claro, ela não precisa de um livro.  Bem, o livro não é para ele e está escrito, é necessário para entrar em algum tipo de tecnologia, a fim de começar a entender isso.  E quando você já entrou, você tem outras fontes de desenvolvimento. <br><br>  Portanto, parece-me que os livros não vão a lugar algum.  Quando você começa a aprender alguma coisa, é claro que pode aprender linguagens de programação por artigos, mas na maioria dos casos o resultado não vai funcionar bem.  Na maioria das vezes, essa é a transferência de suas idéias sobre outra linguagem de programação para uma nova.  Você não reconhece as construções idiomáticas desse idioma e não sabe como usá-lo corretamente. <br><br>  Então, no início, é melhor pegar o livro, resolvê-lo e obter a base.  Deixe que ela descreva as versões mais recentes das bibliotecas, que algo seja adicionado à linguagem, pois é possível acompanhar.  Para obter a base, na minha opinião, você ainda precisa de um livro.  Isso é para todas as linguagens de programação, mesmo para JavaScript.  De qualquer forma, precisamos de algum tipo de estabilidade, como um ponto de referência, ao qual você pode se referir. <br><br>  Aliás, esse é um dos objetivos ao escrever um padrão de idioma Haskell para criar um ponto tão estável na história do idioma pelo qual você pode escrever um livro.  Além disso, de uma maneira ou de outra, a linguagem pode se desenvolver, mas existe um padrão e qualquer aluno pode se concentrar nele. <br><br>  É interessante como os livros desempenham o papel de um padrão para muitas linguagens de programação.  Por exemplo, o Straustrup escreveu um livro sobre C ++, e esse é um ponto a que você sempre pode se referir.  O C ++ foi muito além, mas ao aprender a linguagem, é bem possível focar nesta versão, descrita por Straustrup. <br><br>  <b>Artyom</b> : Você levantou um tópico interessante sobre os recursos de que as pessoas precisam, que não aprendem o idioma, mas querem ir mais fundo e seguir em frente.  Você pode aconselhar alguns recursos que você usa para estudar e recursos que seria bom estudar para um engenheiro mergulhar em uma teoria.  ciência da computação, na teoria dos tipos, ou, como você disse, eliminar uma certa ignorância de um engenheiro? <br><br>  <b>Vitaliy</b> : É difícil para mim dar um exemplo, não posso dizer que tenho fontes regulares de informação.  Talvez a fonte mais importante para mim seja o Twitter.  Acontece que tudo vem a mim via Twitter.  Alguns links interessantes me aparecem, eu os guardo para mim e os leio periodicamente.  Sinto que, pelo menos em Haskell, não existe essa fonte, mas há muitas pessoas respeitadas que escrevem coisas sensatas. <br><br>  De alguma forma, tentei usar o Reddit regularmente para esse fim, mas de alguma forma não funcionou para mim, só não tenho tempo suficiente para segui-lo.  Mas no Twitter, de qualquer maneira, tudo o que aparece mais cedo ou mais tarde vem a mim.  Olhou rapidamente, curiosamente - salvou e depois leu. <br><br>  E assim, em geral, recomendar algo no campo da ciência da computação ou da TI, para ser honesto, não estou pronto, não conheço esse site ou recurso.  Para aqueles envolvidos em linguagens de programação, uma fonte importante é o site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://lambda-the-ultimate.org</a> .  Todas as coisas mais interessantes aparecem lá e uma discussão está em andamento.  Esta é uma leitura obrigatória para os interessados ​​na teoria das linguagens de programação. <br><br><h2>  O que ler para o programador </h2><br><br>  <b>Alexei</b> : Você diz que os livros não expiram.  Existe uma lista de itens obrigatórios para ler ou apenas seus livros favoritos para recomendar?  Estou falando de teoria da programação, de conhecimentos gerais de engenharia. <br><br>  <b>Vitaliy</b> : Sou solicitado periodicamente a fazer uma lista, não realizo esse trabalho, é uma tarefa muito difícil. <br><br>  De acordo com a teoria das linguagens de programação, para começar a migrar para ela, existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o</a> livro de Pierce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Tipos em linguagens de programação".</a>  Geralmente, isso é uma cartilha para começar os tipos.  Provavelmente, seu primeiro terço seria útil para todos os programadores. <br><br>  Meu colega e eu estávamos traduzindo um livro chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introdução à teoria das linguagens de programação</a> .  É muito pequeno, e explica a semântica formal, inferência de tipos, coisas teóricas da compilação.  Uma introdução tão útil para linguagens de programação. <br><br>  Há um livro de Charles Petzold <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Annotated Turing"</a> .  Esse é um gênero incrível: o autor pegou um artigo de Turing em 1936, onde Turing descreveu o que mais tarde ficou conhecido como uma máquina de Turing e escreveu um livro grosso que explica esse artigo.  E o próprio artigo é a página 15. Além disso, há uma história da vida do próprio Turing, o pano de fundo dessa tarefa, como tudo aconteceu.  Seção por seção, ele fornece um fragmento do artigo e uma explicação do que foi feito ali. <br><br>  Se lermos o artigo agora, será muito difícil para nós.  Mas este livro de Petzold é incrível, recria todo o contexto e descreve o próprio artigo.  Eu recomendo isso para todos, esta é uma leitura muito interessante, amplia a mente.  Também existe o cálculo λ, porque está tudo por perto, e questões filosóficas são levantadas relacionadas a cálculos. <br><br>  Além disso, é claro, do ponto de vista tecnológico, sou um grande fã <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do</a> livro de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">McConnell, “Perfect Code”</a> .  Parece-me que esta também é uma leitura importante.  Você não pode ler tudo em uma linha, mas simplesmente abra-o em páginas aleatórias, leia algumas páginas e feche-o.  Isso é sobre como escrever código. <br><br>  É verdade que recentemente conversei com vários trabalhadores móveis, eles dizem que é um livro estúpido no qual não há nada útil.  Mas é sobre como escrever esse código para que ele viva por um longo tempo, para que possa ser suportado, alterado.  Talvez eles realmente não tenham essas necessidades. <br><br>  Sim, e não há Swift, nem Kotlin, algum tipo de Java, exemplos diferentes em linguagens diferentes que os programadores modernos não falam mais sobre nada.  O livro começou dois milésimos.  Mas acho que para qualquer programador essa leitura é muito útil.  McConnell ainda é bom, pois confirma tudo com a pesquisa, diz: “Então, nós fizemos tal e tal estudo, ainda assim e tal, e aqui estão os resultados.  Vamos discutir juntos como escrever código para torná-lo bom. ” <br><br>  Aqui, talvez, o suficiente de tal leitura. <br><br>  <b>Artyom</b> : para um mais especializado, pergunto: você recomendou a "Implementação do compilador moderno", disponível em três versões - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ML</a> . <br><br>  <b>Vitaliy</b> : Sim, este é um livro sobre compiladores.  Não sei se todos precisam ler, é mais provável para aqueles que estão interessados ​​em compiladores.  Mas sim, eu gosto - é pequeno e, trabalhando com ele, você pode realmente escrever seu próprio compilador.  Não tenho certeza de que todos os programadores precisem escrever seu próprio compilador, mas se você ficar subitamente curioso, os livros de Appel são realmente interessantes, mas já são algo estreito. <br><br>  Agora não consigo me lembrar de tudo.  Periodicamente, algo aparece à superfície, porque ao mesmo tempo eu leio muito.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“A estrutura e interpretação dos programas de computador”</a> também é um clássico útil para ler e fazer exercícios.  Mesmo se eu não concordar, mas a leitura em si é muito útil. <br><br><blockquote>  Vitaly Bragilevsky comparecerá à conferência do HolyJS 2019 em Moscou nos dias 8 e 9 de novembro de 2019 com o relatório <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“JavaScript a serviço da informática teórica”.</a> Os ingressos podem ser adquiridos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site oficial</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469531/">https://habr.com/ru/post/pt469531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469521/index.html">Comprei uma moto para andar, para não cair</a></li>
<li><a href="../pt469523/index.html">Dependência do desempenho do código no contexto da declaração de variáveis ​​em JavaScript</a></li>
<li><a href="../pt469525/index.html">Sistema de controle automatizado para uma escavadeira de mineração</a></li>
<li><a href="../pt469527/index.html">O interfone é um ouvido espião?</a></li>
<li><a href="../pt469529/index.html">A renderização de texto odeia você</a></li>
<li><a href="../pt469533/index.html">Problemas e ameaças da identificação biométrica</a></li>
<li><a href="../pt469537/index.html">Conhecendo Swift com Snake</a></li>
<li><a href="../pt469541/index.html">Montagem e implantação dos mesmos microsserviços com o werf e o GitLab CI</a></li>
<li><a href="../pt469543/index.html">Redis Scaling e Failover para Serviços DirectumRX</a></li>
<li><a href="../pt469545/index.html">O que há de novo no kernel do Linux 5.3 - Drivers gráficos, virtualização e modificações no subsistema de rede</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>