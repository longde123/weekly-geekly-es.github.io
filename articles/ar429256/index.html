<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👓 🔲 👨‍🚒 كيفية زراعة غابة على Actionscript3 / Flash في بضعة أسطر من التعليمات البرمجية 🍇 🍉 🤽🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في هذا التعليق ، تفاخرت بأنني كتبت برنامجًا أنشأ غابة "ذات مظهر لائق" في مائتي سطر من التعليمات البرمجية. لسوء الحظ ، تبين أن الواقع أكبر قليلاً في ال...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كيفية زراعة غابة على Actionscript3 / Flash في بضعة أسطر من التعليمات البرمجية</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429256/" style=";text-align:right;direction:rtl">  في هذا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">التعليق ،</a> تفاخرت بأنني كتبت برنامجًا أنشأ غابة "ذات مظهر لائق" في مائتي سطر من التعليمات البرمجية.  لسوء الحظ ، تبين أن الواقع أكبر قليلاً في الحجم - تحتوي المصادر المحفورة على حوالي 2100 سطر من التعليمات البرمجية ، منها حوالي 700 تعليق وأفكار بصوت عالٍ ورمز قديم مهمل ومحاولات لتوثيق طرق.  حجم SWF القابل للتنفيذ ، ومع ذلك ، تبين أن 13112 بايت. <br><br>  بدأ كل شيء بحقيقة أنه في منتدى Kongregate.com ، حيث كنت أقضي وقتًا نشطًا في ذلك الوقت ، اقترح أحد المشاركين التنافس في الجيل الإجرائي لشيء ما ، كان الموضوع الأول هو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"الغابة"</a> . <br><br><img src="https://habrastorage.org/webt/hm/qt/av/hmqtavjkbvff-lrzqdg37j6oge8.png"><br><a name="habracut"></a><br>  وبطبيعة الحال ، كان لكل شخص فكرته الخاصة حول ما يجب أن تكون الغابة التي سينمونها.  في ذلك الوقت قرأت كتبًا عن جميع أنواع السحر ، ونتيجة لذلك ، كنت أرغب في زراعة غابة.  تتكون الغابة من الأشجار - نكتب فئة الشجرة {...}.  تتكون الشجرة من أغصان وأوراق - نكتب فرع الفصل {...} ونعتقد ، هل نحن حقا بحاجة إلى أن تأخذ بعين الاعتبار كل ورقة على الشجرة؟  ونتيجة لذلك ، حصل "الفرع" على معلمة "بأوراق" ، واكتسبت الشجرة زوجًا من القوام ، أحدهما للأغصان والجذع ، والآخر للأوراق.  كان النسيج "تحت الشجرة" بسيطًا نسبيًا - هناك ضجيج بيرلين ، يمكنك تمديده ، لفه ، طلائه ، اعتباره جاهزًا ، ولكن كان عليك أن تتلاعب بالأوراق. <br><br>  ومع ذلك ، لم أكن راضيًا عن ضجيج الهاوسر على نسيج الشجرة ، وبدلاً من ذلك خرجت بخريطة - أي  قام بإنشاء خريطة ارتفاع ، وقام بتعديلها تحت نصف دائرة الفرع المرئي من الجانب ، ثم ملأ النسيج الرئيسي باللون البني وفرض خريطة ارتفاع مع تعديل الإضاءة إلى الصرير الجانبي.  الرمز الناتج هو كما يلي: <br><br><pre style=";text-align:right;direction:rtl"><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateBranch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:void </span></span>{ branchBitmap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BitmapData(<span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-number"><span class="hljs-number">0xff8080ff</span></span>); <span class="hljs-comment"><span class="hljs-comment">//branchBitmap.perlinNoise(32, 256, 2, 100 + Math.round(Math.random() * 900), true, true, 7, true); var hm:BitmapData = new BitmapData(512, 512, false, 0); var seed:int = 1000 + Math.random() * 2000; hm.perlinNoise(24,192, 2, seed, true, true, BitmapDataChannel.BLUE, false); // blue only. Is a heightmap var i:int; var j:int; for (i = 0; i &lt; 512; i++) { if (Math.abs(i - 256) &gt; 100) r = 0; else r = 200 * Math.sqrt(1 - (i - 256) * (i - 256) / 10000);// square curve //r = 200 * Math.sin(Math.PI * (i - 128) / 256); // sine curve for (j = 0; j &lt; 512; j++) hm.setPixel(i, j, Math.round(r*(500.0 + (hm.getPixel(i, j)-128))*0.002)); // now, r means position on the "log", and initial perlin noise is log's texture. // perlinNoise median 128, highest offset taking as 100, the result offset needs to be ~0.2 in multiplier } var v:Vector.&lt;int&gt; = new Vector.&lt;int&gt;(); var vv:Vector.&lt;Number&gt; = new Vector.&lt;Number&gt;(3); for (i = 1; i &lt; 511; i++) { v.length = 0; v.push(hm.getPixel(0, i-1), hm.getPixel(1, i-1), hm.getPixel(2, i-1), hm.getPixel(0, i), hm.getPixel(1, i), hm.getPixel(2, i), hm.getPixel(0, i+i), hm.getPixel(1, i+1), hm.getPixel(2, i+1)); for (j = 1; j &lt; 510; j++) { var g:int = -1 * v[0] - 2 * v[1] - 1 * v[2] + 1 * v[8] + 2 * v[7] + 1 * v[6]; // gradient by Y var r:int = -1 * v[0] - 2 * v[3] - 1 * v[6] + 1 * v[2] + 2 * v[5] + 1 * v[8]; // gradient by X //if ((i &gt; 50) &amp;&amp; (i &lt; 55) &amp;&amp; (j &gt; 50) &amp;&amp; (j &lt; 55)) trace(g, r); var b:int = v[5]; r += 128; g += 128; var p:uint = r *0x10000 + g*0x100 + b; branchBitmap.setPixel(j, i, p); v.shift(); v.push(hm.getPixel(j + 2, i + 1)); v[2] = hm.getPixel(j + 2, i - 1); v[5] = hm.getPixel(j + 2, i); } } var bf:BlurFilter = new BlurFilter(2,8); // ___ // bevelFilter is not what I need, it bevels a rectangle and just that [___] // dropShadowFilter requires empty alpha I believe // convolution filter works best on self, while it can do what I need branchBitmap.applyFilter(branchBitmap, branchBitmap.rect, P0, bf); hm.copyPixels(branchBitmap, branchBitmap.rect, P0); //branchBitmap.perlinNoise(32, 256, 0, seed, true, true, 7, true); // naked grayscale // 0 octaves means 50% gray filling branchBitmap.fillRect(branchBitmap.rect, 0xff808080); // it looks like I'll have enough details just by perlin-noising the heightmap var inc:Number = Math.PI / 3; var azi:Number = -Math.PI * 1 / 4; var cx:Number = Math.cos(inc) * Math.cos(azi); var cy:Number = Math.cos(inc) * Math.sin(azi); var cz:Number = Math.sin(inc); azi = 1 - 2 * cz; inc = 1 / cz; // cos(lighting) to be normalized into (0..1) via cz for (i = 0; i &lt; 512; i++) for (j = 0; j &lt; 512; j++) { p = branchBitmap.getPixel(j, i); var h:uint = hm.getPixel(j, i); // give a vector here somewhere vv[0]= (h &gt;&gt; 16)-128; vv[1] = ((h &gt;&gt; 8) &amp; 255)-128; vv[2] = 26; // balance constant, a normal is always pointing upwards, Basis.Normalize(vv); var m:Number = inc*(cx * vv[0] + cy * vv[1] + cz * vv[2]); // cos(lightangle) r = (p &gt;&gt; 16) &amp; 255; g = (p &gt;&gt; 8) &amp; 255; b = p &amp; 255; r = Math.max(0,Math.min(255, r * m)); g = Math.max(0,Math.min(255, g * m)); b = Math.max(0,Math.min(255, b * m)); branchBitmap.setPixel(j, i, 0x10000 * r + 0x100 * g + b); } branchBitmap.applyFilter(branchBitmap, branchBitmap.rect, P0,bf); // should be here, without blurring it's liney hm = new BitmapData(192, 512, false); hm.copyPixels(branchBitmap, new Rectangle(160, 0, 192, 512), P0); branchBitmap = hm; }</span></span></code> </pre> <br>  "Basis" عبارة عن فئة مساعدة للمتجهات a la Vector3D ، ولكن نظرًا لكتابة الشفرة في ذلك الحين تحت Flash 10.1 ، لم يكن هناك مثل هذه المتجهات حتى الآن ، أو فضلت أن أصنع دراجتي الخاصة.  تم رسم النسيج تحت الفرع بأوراق على النحو التالي: في البداية تم عمل ورقة واحدة ، ثم تم تحديد ما إذا كان للفروع ورقة مركزية ، وهذا يحدد طول قطعة الفرع التي تم إرفاق الأوراق بها ، ثم تم إرفاقها (محسوبة على النسيج) بزاوية إلى الفرع من خلال العرض المحسوب للورقة .  تم تعيين شكل الورقة كدائرة مشوهة مع العديد من النقاط المرجعية التي تم تعويضها من الدائرة بنصف قطر نصف ورقة ، وتم تعيين طول القطع بشكل منفصل ، كل هذا تم رسمه على نسيج الورقة باللون الأسود والأبيض وحفظه للمستقبل.  (بتعبير أدق ، كان هناك نسيجان "فرع بأوراق" ، أحدهما للنهايات ، أي الفروع التي لا ينمو فيها شيء من "النهاية" ، ولكن بالأوراق ، تم رسم ورقة عليها في نهاية الفرع ، والثانية لـ "منتصف "بدون ورقة نهاية.) <br><br>  ثم الجزء الأصعب هو كيف ستبدو الشجرة؟  هنا فكرت وجربت لفترة طويلة.  قررت أن أجعل الشجرة تنمو حقًا - تمتد الفروع في الطول (تنمو فعليًا من النهاية) ، وأحيانًا تفرخ الفروع إلى الجانب ، وتمتد الفروع إلى الشمس (أعلى) وحالتين إضافيتين.  اتضح تجزئة رهيبة ، أفضل خيار تمكنا من مشاركته بدا كما يلي: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/427/f05/aa5/427f05aa580feb5a231dd5e23c63baa8.jpg" alt="الصورة"><br>  <i>(من الغريب أن diary.ru هي خدمة ممتازة لاستضافة الصور ، حتى الآن لم يحدث شيء سيئ!)</i> <br><br>  توصلت إلى استنتاج مفاده أننا بحاجة إلى تقليل كثافة الفروع بطريقة أو بأخرى.  في البداية ، كانت الفكرة هي الحد من جاذبيتها - أي  الفروع "الثقيلة" جدا تنقطع وتسقط.  بدأت في حساب لحظة القوة في الانحناء ، ومقارنتها بقوة الشجرة (قمت بسحب القيم من مكان ما ، وسجلتها كثوابت وبدأت في الاختبار) - اتضح بشكل سيئ ، وأحيانًا انكسر الجذع ، على الرغم من أنه لم يكن يجب أن يحدث ، وكانت الشجرة مثنية بأمان ، في بعض الأحيان انكسر فرع كبير في البداية ، أدت النتيجة إلى جذع غير متوازن وانكسر مرة أخرى ، هذه المرة بسبب فقدان التوازن الرأسي ، وأحيانًا كان فرعًا طبيعيًا تمامًا في الهيكل ، ينمو في السمك ، ينحني في البداية تحت وزنه ، ثم كسر ، المبيعات  إذا لم يعد نمت شيء في ذلك.  سجل لأن التحدي كان الموعد النهائي. <br><br>  كانت المحاولة الثانية للحد من نمو الفروع الجديدة وبقاء الفروع القديمة / السابقة باستخدام الإضاءة.  من المحاولة الثالثة للتنفيذ (بقيت الأولين في شكل وظائف تم التعليق عليها) اتضح الأمر على هذا النحو: لقد بنيت شبكة شعرية ثلاثية الأبعاد مع جانب 0.5 متر (نعم ، جميع القيم الموجودة بالأمتار والكيلوغرامات - كنت أرغب حقًا في الفيزياء الحقيقية لغابة حقيقية في ذلك الوقت) ، والتي تم ملؤها في الأصفار الأولى ، ثم عند الالتفاف حول الشجرة ، ساهم كل فرع في ملء الشبكة في شكل حجمه مقسومًا على واحد أو اثنين من voxels.  والحقيقة هي أن جميع الفروع (على أي حال تقريبًا) كقطع منفصلة من الإطار المحسوب كانت أقصر من 0.5 متر ، مما سمح لنا باستخدام تقريب تقريبي.  بالإضافة إلى الحشو ، فإن كل فرع "يلقي بظلاله" على voxels الأساسية في شكل حشو إضافي لل voxels تحت و voxel قليلاً مع voxel مع فرع (الشكل النهائي هو هرم مربع ، ولكن اللعب مع دائرة كان ينكسر ، وبالتالي لم يكن إضاءة على أي حال).  تم استخدام هذه الشبكة كمحدد ، إذا بدأ أحد الفروع في النمو في منتصف الشجرة - سيكون هناك ضوء أقل هناك ، سيكون أقصر وقد لا ينمو على الإطلاق أو يموت من نقص الإضاءة.  ثم سقطت الفروع الميتة. <br><br>  جعل هذا الخيار من الممكن الحصول على الأشجار التي كانت شفافة نسبيًا عند عرضها وضغطها نسبيًا من حيث النطاق ، بدت النسخة العاملة الأولى على النحو التالي: <br><br><img src="https://habrastorage.org/webt/of/9e/kl/of9eklhz1sf9try2zuwtkr_3kds.jpeg"><br><br>  في هذا الإصدار ، ما زلت أراجع آلية نمو الشجرة نفسها ، ويمكن عرض الشجرة من جميع الجهات.  تم رسم الشجرة فرعًا واحدًا في كل مرة ، وتم فرز مجموعة الفروع أولاً حسب المسافة من المراقب ، كما هو الحال في دورة VMX القديمة الجيدة على الرسومات ثلاثية الأبعاد من عام 1996 ، اخترت الألوان لأغراض التجميل من مجموعة HSB لكل مكالمة "ارسم لي شجرة" حتى لا تكون الغابة رتيبة ، يتم أيضًا تدوير الهيكل العظمي للشجرة بشكل عشوائي للرسم.  في المجموع ، كان هناك ستة إلى ثمانية نماذج شجرة للرسم ، ينمو كل منها تحت تأثير RNG الخاص بها ، وتضبط المناظر الطبيعية للأرض ضوضاء أخرى للهاوسر ، ويتم اختيار المكان الذي تنمو فيه الشجرة بشكل عشوائي باستخدام مجموعة من النقاط المسموح بها للنمو عند الانتقال إلى الجانب مراقب المسافة.  إذا كانت الشجرة مزروعة عند النقطة A ، وكان نصف قطر الشجرة R المحدد لـ "النمو" ، فإن القيم (AR ، A + R) ممنوعة للنمو عند المسافة الحالية ، عند الانتقال إلى المرحلة التالية (-0.05) ، انخفض هذا الفاصل بمقدار 0.1 ، وتمت إزالته عندما تم تخفيضه إلى الصفر. <br><br>  آخر (وفي الواقع الأول والأخذ في الاعتبار فورًا) الفروق الدقيقة في الخوارزمية بأكملها هي أنها طويلة جدًا.  للتجول في شجرة "البالغين" ، يستغرق الرسم بضع ثوانٍ ، وعدد أقل قليلًا لرسم مواد شجرة واحدة ، ويستغرق الأمر من نصف ثانية إلى اثنتين ، ولم يتم تصميم Adobe Flash لمثل هذه الفترات الزمنية الطويلة للحساب دون تحديث الشاشة (بشكل أكثر دقة ، دون إعادة التحكم في المحرك) .  لذلك ، كنا بحاجة إلى خوارزمية يمكنها حفظ الحالة بين المكالمات ، ومواصلة العمل من المكان الذي تمت مقاطعته فيه والتحكم في وقت تنفيذه ، وفي الوقت نفسه لا داعي للذعر ولا تنزعج من محرك الفلاش.  تم تنفيذ إنقاذ الولاية كزوج من خصائص الفئة الرئيسية ، مقسمة إلى مراحل - من خلال تحديد الوظائف "زراعة شجرة مرة واحدة" ، و "رسم شجرة منتهية" و "رسم قطعة أرض" وقياس الوقت المستغرق ، على التوالي ، بمجرد "المرة" التالية استغرقت الشجرة أكثر من بضع ثوان ، واعتبرت الشجرة "جاهزة" وتم وضعها جانباً.  اتضح أن هناك ثلاث مراحل كبيرة: إنشاء مواد ، "زراعة" الأشجار ، ووضع الأشجار النهائية على الشاشة. <br><br>  تبدو النتيجة كالتالي: <br><br><img src="https://habrastorage.org/webt/gq/ng/5l/gqng5lalvmyilnobmf1dvhhsbqw.png"><br><br>  يمكنك اللعب <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> .  يمكن أن يكون تحسين برنامج Flash 10.1 المحسن (بشكل أكثر دقة ، مكتوبًا) ، مع الأخذ في الاعتبار مجموعة من تحديثات الفلاش من حيث الأمان ، بطيئًا للغاية - في هذه الحالة ، أنصحك بتنزيل إصدار تصحيح برنامج Adobe Flash Player 11.5 وفتحه في وضع عدم الاتصال.  يستغرق الرسم بأكمله 5-6 دقائق ، بعد أول دورتين على الشاشة تبدأ بعض الحركة في الحدوث ، وهو ما قد يكون مثيرًا للاهتمام للملاحظة.  بعد الرسم ، يمكنك الضغط على Ctrl + النقر لحفظ النتيجة كملف PNG رباعي مقارنة بحجم النافذة. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar429256/">https://habr.com/ru/post/ar429256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar429246/index.html">التدريب الصيفي في Mars IS: نظرة من الداخل</a></li>
<li><a href="../ar429248/index.html">نصائح متعددة اللغات: كيف تتعلم أي لغة بدون دموع أو لعنات</a></li>
<li><a href="../ar429250/index.html">مائة وصفات مسك الدفاتر الرقمية</a></li>
<li><a href="../ar429252/index.html">التحليل الثابت لتطبيقات الهاتف المحمول</a></li>
<li><a href="../ar429254/index.html">على منحنيات بيزييه وسرعة اردوينو ، الجزء الثاني</a></li>
<li><a href="../ar429258/index.html">كيفية إنشاء ميكانيكا ألعاب موثوقة باستخدام Excel فقط: النمذجة وتحسين الحلول</a></li>
<li><a href="../ar429260/index.html">طريقنا لتخزين السجل المركزي</a></li>
<li><a href="../ar429262/index.html">مرحبًا بكم في لقاء الخريف DIYorDIE في 17 نوفمبر</a></li>
<li><a href="../ar429264/index.html">وقت UPS Li-ion UPS: خطر حريق أم خطوة آمنة في المستقبل؟</a></li>
<li><a href="../ar429266/index.html">ما هي رواتب المتخصصين في تكنولوجيا المعلومات التي يقدمها أصحاب العمل في My Circle ، بيانات مايو-أكتوبر 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>