<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò™ ü§§ üë©üèª‚Äç‚öñÔ∏è ThingJS v1.0-alpha üçö üßú üßúüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama dua tahun terakhir saya telah mengembangkan platform IoT saya sendiri dan hari ini saya siap untuk menunjukkan versi alpha-nya. 


 Bersama den...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ThingJS v1.0-alpha</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474356/"><p><img src="https://habrastorage.org/webt/hd/vu/kq/hdvukqu1cfju8ygby3otuzmptmu.png"></p><br><p> Selama dua tahun terakhir saya telah mengembangkan platform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IoT</a> saya sendiri dan hari ini saya siap untuk menunjukkan versi alpha-nya. </p><br><p>  Bersama dengan mitra, kami membuat dan mendukung perangkat IoT.  Kami membongkar lebih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari satu garu</a> dalam proses kegiatan ini.  ThingJS dilahirkan bukan karena keinginan melainkan karena kebutuhan untuk membuat hidup lebih mudah bagi kami, tetapi pada saat yang sama, saya harap, untuk Anda. </p><br><p>  Artikel ini akan menarik bagi orang-orang yang dekat dengan topik IoT dan mereka telah melakukan sesuatu di bidang ini.  Poin penting adalah bahwa platform harus menarik (tiba-tiba) pengembang JavaScript, sebagai  bahasa ini dipilih sebagai dasar dari platform.  Tentu saja, pengembang C / C ++ juga akan memiliki sesuatu untuk dibaca. </p><br><p>  Pertama, saya akan berbicara tentang masalah utama apa yang kami temui saat mengembangkan perangkat IoT, kemudian saya akan menjelaskan bagaimana platform menanganinya, dan pada akhirnya, semuanya membosankan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> , bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teknis,</a> dan Anda dapat menyentuh semuanya secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">langsung</a> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Daftar isi</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah IoT</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah tangan pendek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah menara Babel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah Sindrom Stockholm</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solusi untuk masalah</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komunitas, Kecanduan, Fashionable, Remaja.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lebih banyak janji dan abstraksi.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perangkat IoT virtual</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi teknis</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur Aplikasi ThingJS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tumpukan teknologi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fitur Lingkungan Pengembangan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perangkat yang Didukung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perbandingan dengan pesaing</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mulai cepat</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saya hanya harus menonton</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saya ingin mencoba</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi kedip</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perakitan dari sumber</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komposisi Aplikasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manifes. json</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blok komponen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blok skrip</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blok ‚Äúwajib‚Äù</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blink.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blink.vue</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip / blink.js</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi antarmuka</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lingkungan pengembangan</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan aplikasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan firmware</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa selanjutnya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Referensi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Faq</a> </li></ul></div></div><br><h1 id="problemy-iot--anchorproblemsanchor">  Masalah IoT: <a name="problems"></a></h1><br><h2 id="--problema-korotkih-ruk-anchorshort-handsanchor">  - Masalah lengan pendek <a name="short-hands"></a></h2><br><p>  IoT didasarkan pada ekosistem.  Pengembangan konsep dan arsitektur teknisnya benar-benar banyak pekerjaan.  Selain itu, Anda masih perlu mengembangkan banyak firmware untuk perangkat heterogen.  Untuk menciptakan dan mengimplementasikan transportasi untuk pertukaran data antar perangkat pada berbagai prinsip fisik dan logis.  Perluas sumber daya cloud.  Mengolah antarmuka pengguna.  Dll  dll. </p><br><p>  Bahkan jika seorang spesialis individu memiliki keterampilan yang diperlukan untuk melakukan ini, maka ia tidak punya cukup waktu (tangan) untuk mengimplementasikan ide tersebut.  Sementara dia akan memotongnya, dia akan menjadi usang. </p><br><h2 id="--problema-vavilonskoy-bashni-anchortoweranchor">  - Masalah menara Babel <a name="tower"></a></h2><br><p>  Mengembangkan ekosistem IoT lengkap membutuhkan tumpukan teknologi yang sangat luas.  Menjadi tumpukan penuh di IoT sangat mudah ... sulit.  Butuh pengalaman di mana-mana.  Tidak semua bisa membanggakan berbagai pengetahuan, dan bahkan pengalaman.  Dan di sini pertanyaannya bukan pada kemampuan mental.  Ini adalah kesimpulan yang jelas dari masalah tangan pendek. </p><br><p>  Untuk menciptakan ekosistem yang benar-benar kaya membutuhkan kerja dari banyak spesialis yang cukup sempit, tetapi dengan pengetahuan yang mendalam di bidangnya.  Spesialis ini berbicara bahasa yang berbeda, menggunakan pola yang berbeda, dan seringkali mereka memahami istilah dasar dengan cara yang berbeda.  Dan mengingat bahwa IoT didasarkan pada perangkat dengan sumber daya terbatas, komunikasi yang efektif sangat penting untuk merealisasikan apa yang dimaksud. </p><br><h2 id="--problema-stokgolmskogo-sindroma-anchorsindromanchor">  - Masalah sindrom Stockholm <a name="sindrom"></a></h2><br><p>  Saat ini ada vendor yang mengembangkan ekosistem mereka.  Ini adalah Google, Microsoft, Yandex, Megaphone, MTS, dll.  Beberapa dari mereka memungkinkan Anda untuk mengintegrasikan barang-barang Anda sendiri ke dalam ekosistem mereka dengan persyaratan mereka.  Ini sebagian besar mencakup masalah yang dijelaskan di atas.  Tapi itu menciptakan kecanduan yang baru.  Dan vendor suka mengubah kondisi untuk integrasi.  Dan lebih dari itu, tidak ada masalah realisasi diri dalam paradigma ini. </p><br><h1 id="resheniya-problem-anchorsolutionsanchor">  Solusi untuk masalah: <a name="solutions"></a></h1><br><h2 id="--soobschestvo-zavisimosti-modno-molodezhno-anchorcommunityanchor">  - Komunitas, kecanduan, modis, awet muda <a name="community"></a></h2><br><p>  Masalah yang dijelaskan di atas, pada kenyataannya, memblokir akses ke pengembangan IoT untuk individu.  Pengembangan platform diluncurkan dengan kesadaran akan masalah ini.  Yayasan diletakkan untuk pengembangan platform melalui komunitas. </p><br><p>  Untuk mengimplementasikan ide ini, platform, tentu saja, dilengkapi dengan basis kode terbuka, dan juga memiliki paradigma ketergantungan pada semua lapisan. </p><br><p>  Jika Anda tidak tahu apa itu kecanduan, inilah saatnya mengenal mereka.  Tetapi jika Anda mencoba menjelaskan dengan sangat sederhana, maka modul yang Anda kembangkan mungkin bergantung pada modul lain yang ditulis teman Anda.  Dan Anda akan mengakses modulnya melalui antarmuka yang telah ditentukan. </p><br><p>  Jadi, pada saat yang sama, secara mandiri, banyak orang dapat mengembangkan komponen platform mereka sendiri dan menggunakan kembali yang sudah ada yang dikembangkan oleh seseorang.  Ini secara mendasar memecahkan masalah tangan pendek. </p><br><p><img src="https://habrastorage.org/webt/zt/xk/ok/ztxkokx7yqcgzwymgrq3o-ueah4.png"></p><br><p>  Juga, masalah "Menara Babel" sedang diselesaikan.  Ketergantungan dibangun sehingga berbagai tingkatan platform, dikembangkan dalam berbagai bahasa, memiliki mekanisme yang telah ditentukan untuk membangun ketergantungan di antara mereka sendiri. </p><br><p>  Misalnya, pengembang C dapat memanfaatkan komponen front-end yang sudah jadi dengan menyediakan antarmuka yang diperlukan.  Atau, sebaliknya, pengembang front-end dapat menggunakan komponen yang sudah jadi yang ditulis dalam C. Yaitu  semua orang akan melakukan apa yang dia tahu terbaik. </p><br><h2 id="--bolshe-obeschaniy-i-abstrakciy-anchorpromisesanchor">  - Lebih banyak janji dan abstraksi <a name="promises"></a></h2><br><p>  Protokol komunikasi antar perangkat tidak ditentukan.  Sebaliknya, ada abstraksi - bus data.  Perangkat dapat mengirim acara ke bus atau mendengarkan bus.  Tidak jelas siapa yang menulis ke bus dan siapa yang menerima, di muka.  Dan kapan juga.  Pertukaran dan pengiriman data yang tidak sinkron tidak dijamin.  Secara umum - neraka.  Jangan panik.  Jadi dikandung. </p><br><p>  Masalahnya adalah bahwa ekosistem adalah sekelompok perangkat mandiri yang terpisah.  Kapan saja, beberapa perangkat mungkin tidak tersedia.  Karena berbagai alasan.  Untuk menghentikan aktivitas perangkat lain jika bagian tidak tersedia bukanlah skenario terbaik.  Perlu untuk melegalkan apa yang tidak dapat dicegah. </p><br><p>  Platform mengimplementasikan paradigma janji untuk menyediakan acara.  Perangkat pertama berlangganan janji yang kedua untuk memberinya informasi.  Tapi tidak ada jaminan.  Pelanggan harus memutuskan apa yang harus dilakukan jika ada penyediaan data yang tidak tepat waktu kepadanya. </p><br><p>  Masalah komunikasi sinkron diselesaikan dengan mentransmisikan peristiwa melalui bus dengan tautan ke saluran sinkron.  Protokol saluran sinkron ditentukan oleh jenis peristiwa itu sendiri.  Misalnya, Anda dapat mengirim acara dengan tipe "do-render-video-stream" dan cara mengirim kamera IP WEB sebagai muatan.  Dengan demikian, penerima akan tahu bahwa Anda perlu memutar aliran video dari alamat yang ditentukan. </p><br><p><img src="https://habrastorage.org/webt/3s/th/vn/3sthvnlojthoq_gh9uqirnbqedg.png"></p><br><p>  Tapi bagaimana cara kerja bus secara fisik?  Implementasi bus berada di tangan masyarakat.  Ban mengembang dengan transportasi yang dibutuhkan proyek Anda.  Misalnya, sebuah acara diterima melalui http dan disampaikan melalui UART.  Untuk semua elemen ekosistem, secara lahiriah tidak ada yang akan berubah. </p><br><h1 id="--virtualnye-iot-ustroystva-anchorvirtualanchor">  - Perangkat IoT virtual <a name="virtual"></a></h1><br><p>  Bagi ThingJS, sesuatu bukan hanya hal fisik, tetapi juga aplikasi khusus - hal virtual.  Selain itu, benda fisik dapat berisi beberapa benda virtual (aplikasi) yang menggunakan sumber daya benda fisik. </p><br><p>  Pendekatan ini memungkinkan Anda untuk menyatukan interaksi antara backend bersyarat (pengontrol / server / cloud, dll.) Dan frontend (browser, aplikasi, dll.), Serta b2b dan bahkan f2f.  Bangun matriks, bukan hierarki interaksi. </p><br><p><img src="https://habrastorage.org/webt/-l/vg/bd/-lvgbdkme-d81bzhaqpqjwhcnly.png"></p><br><p>  Contoh sederhana akan menjadi kamera WEB, yang dengan sendirinya memiliki hal virtual - antarmuka pengguna.  Ketika pengguna pergi ke alamat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://192.168.4.1</a> , halaman WEB terbuka, di mana hal virtual mulai "hidup".  Kamera (hal fisik) dan halaman (hal virtual) secara otomatis menjadi ekosistem di mana bus data terpadu tersedia.  Melalui itu, hal virtual berkomunikasi dengan fisik.  Dalam hal ini: hal fisik memberitahu hal virtual melalui bus alamat dari aliran video, statusnya, dll., Dan hal virtual menunjukkan kepada pengguna video dan memberikan perintah yang diperlukan untuk hal fisik. </p><br><p>  Kelanjutan logis adalah kemampuan untuk meng-host hal-hal virtual di awan dan memasukkannya ke dalam ekosistem bersama.  Dan ini, pada gilirannya, memungkinkan Anda untuk membuat perangkat virtual dengan sumber daya besar yang menyelesaikan masalah, misalnya, tersedia untuk AI. </p><br><p>  Anda dapat membuat sendiri perangkat tersebut, atau menggunakan yang sudah dibuat.  Sindrom Stockholm dikalahkan.  Anda sendiri yang menentukan tergantung pada proyek Anda dan bagaimana Anda akan mengembangkannya. </p><br><h1 id="tehnicheskaya-informaciya-anchortech-infoanchor">  Informasi teknis <a name="tech-info"></a></h1><br><h2 id="struktura-prilozheniya-thingjs-anchorapp-structanchor">  Struktur Aplikasi ThingJS <a name="app-struct"></a></h2><br><p><img src="https://habrastorage.org/webt/sz/-w/ul/sz-wuldlbfp7z2kcc1vgrqov_ta.png"></p><br><h2 id="stek-tehnologiy-anchortech-stackanchor">  Tumpukan teknologi <a name="tech-stack"></a></h2><br><p>  Platform perangkat keras yang dipilih adalah pengontrol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESP32</a> .  Platform ini dirancang sebagai perangkat keras independen.  Namun, sayangnya, tidak ada waktu untuk mempartisi perangkat lain. </p><br><p>  Untuk pengembangan firmware, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat Espressif yang</a> direkomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">digunakan</a> .  Firmware dikembangkan dalam C. Kolektor cmake.  Proyek ini menggunakan konsep komponen, juga dipromosikan oleh Espressif. </p><br><p>  Selain esp-idf, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mongoose WEB Server digunakan</a> , serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mJS</a> penerjemah JavaScript yang dimodifikasi. </p><br><p>  Untuk pengembangan aplikasi, JavaScript digunakan dengan kerangka kerja VUE 2. Buat aplikasi menggunakan webpack.  Pengelola paket adalah npm.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VUE CLI</a> digunakan sebagai dasar untuk lingkungan pengembangan. </p><br><p>  Untuk membakukan visualisasi aplikasi dan mengurangi kepedihan kreativitas UI, paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vuetifyjs</a> termasuk dalam platform. </p><br><h2 id="vozmozhnosti-sredy-razrabotki-anchordev-skilsanchor">  Fitur Lingkungan Pengembangan <a name="dev-skils"></a></h2><br><p>  Untuk pengembang JavaScript (hal-hal virtual): </p><br><ul><li>  IDE yang Disarankan - WEBStorm; </li><li>  Semua keuntungan yang diberikan VUE CLI dan IDE; </li><li>  Debugging aplikasi intra-sistem (mJS debugger pada controller); </li><li>  MJS mengimplementasikan perintah debugger, yang memungkinkan Anda untuk memanggil debugger di tempat yang sewenang-wenang; </li><li>  Unggah file terbaru ke controller selama pengembangan (pengembang JavaScript sudah tidak bisa hidup tanpa fitur ini); </li><li>  Pengembangan runtime dipasangkan dengan pengontrol nyata.  Anda memprogram dan, di sana, Anda melihat hasilnya pada perangkat keras; </li><li>  ESLint yang dikonfigurasi untuk memahami objek platform. </li></ul><br><p>  Untuk pengembang C (hal fisik): </p><br><ul><li>  IDE yang disarankan - CLion; </li><li>  Semua keuntungan esp-idf dan IDE; </li><li>  Platform ini dibagi menjadi beberapa komponen sebagai bagian dari konsep esp-idf; </li><li>  Integrasi yang mudah dengan platform komponen asli. </li></ul><br><h2 id="podderzhivaemye-ustroystva-anchorhw-supportedanchor">  Perangkat yang Didukung <a name="hw-supported"></a></h2><br><p>  Hanya ESP32 yang saat ini didukung.  Chip ini populer karena ketersediaannya dengan karakteristik teknis yang luar biasa.  Berdasarkan itu, banyak perangkat IOT siap pakai telah dibuat yang dapat digunakan di bawah ThingJS. </p><br><h2 id="sravnenie-s-konkurentami-anchorvs-otheranchor">  Perbandingan dengan pesaing <a name="vs-other"></a></h2><br><p>  Saya sarankan untuk tidak berlari sejauh ini.  Saya tidak berani menyebut pesaing platform komersial.  Dan open-source muncul dan menghilang tanpa meninggalkan jejak yang nyata.  Karena itu, saya tidak melakukan perbandingan.  Namun, jika seseorang memiliki keinginan, saya siap memposting hasil karyanya di sini. </p><br><h1 id="bystryy-start-anchorget-startedanchor">  Mulai cepat <a name="get-started"></a></h1><br><h2 id="mne-tolko-posmotret-anchorvideoanchor">  Saya hanya harus menonton <a name="video"></a></h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dhPIAL2N0MQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="hochu-poprobovat-anchortouch-itanchor">  Saya ingin mencoba <a name="touch-it"></a></h2><br><p>  Untuk mencoba platform pada perangkat keras nyata, Anda akan memerlukan perangkat berbasis ESP32 dengan flash 4mb dan kemampuan untuk mem-flashnya melalui USB.  Tapi papan inti ESP32 v2 paling cocok. </p><br><p><img src="https://habrastorage.org/webt/ik/qw/jy/ikqwjyhkejf5t5kwdmbn20lq1ko.png"></p><br><p>  Anda dapat membeli barang-barang seperti itu tanpa masalah di Aliexpress atau Ebay.  Selain itu, bahkan ada kantor perwakilan di Rusia.  Saya pribadi membeli di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">St. Petersburg</a> . </p><br><p>  Untuk menguji operasi aplikasi uji "Blink", Anda harus menghubungkan LED.  Beberapa versi papan memiliki LED pra-instal yang terhubung ke GPIO2.  Jika Anda memiliki papan seperti itu, maka Anda tidak dapat melakukan apa pun.  Blink seharusnya bekerja tanpa gerakan yang tidak perlu.  Jika Anda hanya memiliki satu dioda (catu daya), Anda harus menghubungkan sendiri dioda indikator.  Ini tidak rumit. </p><br><p>  Anda akan memerlukan LED indikator apa pun dan tahan dari 1 hingga 5K. </p><br><p><img src="https://habrastorage.org/webt/ey/vg/e7/eyvge7dfugct2jtk2u2rq8wkpqs.png"></p><br><p>  Satu-satunya yang tersisa adalah menggunakan paket pengguna di perangkat.  Anda bisa membawanya ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Instruksi penempatan terletak di sana. </p><br><h2 id="blink-prilozhenie-anchorblinkanchor">  Aplikasi kedip <a name="blink"></a></h2><br><h3 id="sborka-iz-ishodnikov-anchorblink-bouldanchor">  Perakitan dari sumber <a name="blink-bould"></a></h3><br><p>  Blink adalah ekosistem sederhana yang terdiri dari satu perangkat virtual yang mengimplementasikan antarmuka pengguna, dan satu fisik.  Perangkat virtual dimulai dari perangkat fisik saat mengaksesnya melalui browser. </p><br><p>  Skripnya sederhana.  Saat memasang aplikasi pada perangkat fisik, LED (yang sebelumnya terhubung dengannya) mulai berkedip pada frekuensi 1 Hz.  Pengguna dapat menghidupkan atau mematikan berkedip dioda dari antarmuka.  Anda dapat menonton video di bagian "Saya hanya bisa menonton". </p><br><p>  Sumber ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> src / application / blink.  Untuk mengumpulkan blink dan bermain dengannya, Anda hanya perlu repositori ini.  Pastikan Anda sudah menginstal git, npm, dan nodejs. </p><br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-front <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ThingJS-front npm install npm run build</code> </pre> <br><p>  Jika semuanya berjalan lancar, Anda akan berakhir dengan sesuatu seperti berikut: </p><br><p><img src="https://habrastorage.org/webt/7b/a-/n8/7ba-n8_6y8hng41irp6jttozxks.png"></p><br><p>  Selamat!  Anda telah membangun aplikasi ThingJS pertama Anda.  Anda dapat menemukannya di folder dist / apps / blink dan segera mencoba menginstalnya di perangkat, dipandu oleh video dari bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Saya hanya bisa menonton"</a> . </p><br><h3 id="sostav-prilozheniya-anchorblink-containsanchor">  Komposisi Aplikasi <a name="blink-contains"></a></h3><br><div class="scrollable-table"><table><tbody><tr><th>  File </th><th>  Deskripsi </th></tr><tr><td>  skrip / blink.js </td><td>  Script yang diinstal pada controller </td></tr><tr><td>  blink.js </td><td>  Titik pemasangan komponen aplikasi </td></tr><tr><td>  Blink.vue </td><td>  Komponen VUE yang mengimplementasikan antarmuka pengguna </td></tr><tr><td>  favicon.svg </td><td>  Ikon aplikasi </td></tr><tr><td>  langs.js </td><td>  Paket Bahasa Aplikasi </td></tr><tr><td>  manifes. json </td><td>  Manifes aplikasi </td></tr></tbody></table></div><br><p>  Anda bisa berkenalan dengan semua detail aplikasi sendiri.  Saya akan fokus pada beberapa file. </p><br><h3 id="manifestjson-anchorblink-manifestanchor">  manifes. json <a name="blink-manifest"></a></h3><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Blink"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"vendor"</span></span> : <span class="hljs-string"><span class="hljs-string">"rpiontik"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"subversion"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"patch"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"en"</span></span>: <span class="hljs-string"><span class="hljs-string">"Blink Example"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"components"</span></span>: {...}, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: {...}, <span class="hljs-attr"><span class="hljs-attr">"requires"</span></span> : {...} }</code> </pre> <br><p>  Seperti yang ditunjukkan oleh nama file, ini adalah manifes aplikasi.  Ini memiliki metadata umum tentang tujuan yang mudah ditebak.  Selain mereka, ada tiga blok penting.  Mari kita perhatikan dengan seksama: </p><br><h4 id="blok-components-anchorblink-manifest-componentsanchor">  Blok komponen <a name="blink-manifest-components"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"components"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"blink-app"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"blink.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"intent_filter"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"thingjs.intent.action.MAIN"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"category"</span></span>: <span class="hljs-string"><span class="hljs-string">"thingjs.intent.category.LAUNCH"</span></span> } ] } }</code> </pre> <br><p>  Blok tersebut menggambarkan seluruh basis komponen aplikasi.  Kolom "sumber" menunjuk ke titik pemasangan komponen (lihat blink.js) dan merupakan titik masuk perakitan untuk webpack ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">entri</a> ).  Dengan demikian, setiap komponen akan dikeluarkan dalam satu bundel terpisah.  Bundel ini akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dimuat</a> sesuai kebutuhan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lazy load</a> ). </p><br><p>  Struktur penting adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intent_filter</a> .  Jika Anda kebetulan memprogram untuk Android, Anda akan menemukan sesuatu yang familier bagi Anda.  Dan jangan membuat kesalahan.  Sistem ini menghasilkan antarmuka dan peristiwa layanan yang berlangganan komponen.  Jika suatu peristiwa terjadi yang memenuhi kondisi penyaringan, komponen akan dimuat dan kontrol akan ditransfer ke titik pemasangan. </p><br><p>  Dalam hal ini, komponen "blink-app" berlangganan ke acara peluncuran komponen antarmuka utama aplikasi.  Ketika peluncur memulai aplikasi, komponen ini akan diperkenalkan. </p><br><p>  Jika Anda memodifikasi manifes dengan mengubah baris </p><br><p> <code>thingjs.intent.category.LAUNCH &gt;&gt; thingjs.intent.category.PREFERENCE</code> </p> <br><p>  , kemudian setelah pemasangan dan pemasangannya ternyata aplikasi telah berhenti membuka di desktop.  Tetapi "ubin" baru muncul di bagian "Pengaturan".  Pada saat yang sama, tidak ada yang berubah secara fungsional. </p><br><p>  Dengan demikian, kami menunjukkan kepada peluncur bahwa komponen ini adalah elemen antarmuka untuk menyesuaikan aplikasi kami.  Dan komponen ini mulai muncul di pengaturan. </p><br><h4 id="blok-scripts-anchorblink-manifest-scriptsanchor">  Blok skrip <a name="blink-manifest-scripts"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"entry"</span></span>: <span class="hljs-string"><span class="hljs-string">"blink"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"subscriptions"</span></span> : [<span class="hljs-string"><span class="hljs-string">"$-script-restart"</span></span>, <span class="hljs-string"><span class="hljs-string">"blink"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"modules"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"blink"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"hot_reload"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"scripts/blink.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"optimize"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } }</code> </pre> <br><p>  Blok ini memiliki fungsi yang mirip dengan blok "komponen", tetapi menggambarkan basis komponen aplikasi pada sisi pengontrol. </p><br><p>  Ini dengan jelas menunjukkan titik masuk.  Di bidang "entri".  Secara terpisah, saya akan memperhatikan bahwa ketika menginstal aplikasi, skrip tidak segera dimulai.  Ini diluncurkan hanya ketika salah satu peristiwa dimana skrip berlangganan terjadi. </p><br><p>  Bidang "langganan" bertanggung jawab untuk langganan.  Sekarang ini mengindikasikan dua peristiwa: </p><br><ul><li>  <strong>$ -script-restart</strong> - terjadi ketika sistem memulai atau memulai kembali; </li><li>  <strong>blink</strong> adalah acara khusus yang relevan dengan ekosistem blink. </li></ul><br><p>  Di blok "modul", deskripsi komposisi skrip berikut.  Saya akan mencatat dua bidang: </p><br><ul><li>  <strong>hot_reload</strong> - jika bidang ini disetel ke true, maka ketika file diubah dalam mode pengembangan, itu akan secara otomatis diunduh ke controller (hot reload); </li><li>  <strong>optimalkan</strong> - jika benar, maka ketika membangun proyek, skrip akan dioptimalkan dan dikumpulkan. </li></ul><br><h4 id="blok-requires-anchorblink-manifest-requiresanchor">  Blok ‚Äúwajib‚Äù <a name="blink-manifest-requires"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"requires"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"interfaces"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"blink"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"bit_port"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span> : <span class="hljs-string"><span class="hljs-string">"LED "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"en"</span></span> : <span class="hljs-string"><span class="hljs-string">"LED indicator"</span></span> } } } }</code> </pre> <br><p>  Anda mungkin sudah memperhatikan bahwa ketika menginstal aplikasi Anda harus memilih pin yang akan berkedip LED.  Namun, secara default sudah dipilih sebagai GPIO2.  Blok ini bertanggung jawab untuk pengaturan ini. </p><br><p>  Dalam blok ini ketergantungan ditunjukkan.  Dalam hal ini, agar aplikasi berfungsi, perlu menyediakan antarmuka dengan tipe "bit_port".  Antarmuka ini adalah persyaratan yang diperlukan (diperlukan = benar) dan secara default, GPIO2 ditentukan (default = 2).  Ini akan diproyeksikan ke dalam skrip dengan nama "blink". </p><br><p>  Saat memasang aplikasi, profil peralatan tempat skrip akan digunakan diperhitungkan.  Profil ini mencantumkan antarmuka yang tersedia dan sumber daya perangkat keras yang tersedia untuk mereka (khususnya pin dan kombinasinya).  Periksa kompatibilitas persyaratan dan peralatan.  Jika peralatan dapat memenuhi persyaratan aplikasi, pengguna ditunjukkan skema alokasi sumber daya, di mana sumber daya primer dialokasikan secara otomatis, dengan mempertimbangkan rekomendasi akun dari manifes.  Yaitu  dari bidang ‚Äúdefault‚Äù yang sama. </p><br><p>  Dengan demikian, beberapa aplikasi dapat diinstal pada satu perangkat, yang dapat berbagi sumber daya perangkat keras di antara mereka sendiri. </p><br><h3 id="blinkjs-anchorblink-blink-jsanchor">  blink.js <a name="blink-blink-js"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Blink.vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Langs <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./langs'</span></span>; $includeLang(Langs); $exportComponent(<span class="hljs-string"><span class="hljs-string">'blink-app'</span></span>, App);</code> </pre> <br><p>  File tersebut adalah titik pemasangan komponen yang diumumkan dalam manifes (lihat manifest.js / komponen). Ia mencatat VUE komponen 'blink-app' melalui metode abstraksi $ exportComponent, dan juga mencatat paket bahasa. </p><br><p>  Anda mungkin bertanya - mengapa kesulitan seperti itu?  Mengapa tidak segera mendaftarkan komponen VUE yang Anda tentukan dalam sumber?  Faktanya adalah manifes menggambarkan komponen publik.  Komponen-komponen ini dapat diminta oleh aplikasi pihak ketiga (dependensi runtime).  Titik pemasangan, pada gilirannya, dapat mendaftarkan komponen terkait (untuk penggunaan internal), serta layanan.  Artinya, siapkan lingkungan komponen. </p><br><h3 id="blinkvue-anchorblink-blink-vueanchor">  Blink.vue <a name="blink-blink-vue"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Blink'</span></span>, <span class="hljs-attr"><span class="hljs-attr">watch</span></span>: { blink_state (state) { <span class="hljs-comment"><span class="hljs-comment">// Send event to script this.$bus.$emit($consts.EVENTS.UBUS_MESSAGE, 'blink', state); } }, data () { return { blink_state: true }; } };</span></span></code> </pre> <br><p>  Kode berbicara sendiri.  Ketika properti "blink_state" diubah, pesan dikirim ke bus ($ bus) dengan nilai saat ini.  Ini semua yang perlu Anda lakukan agar skrip di sisi controller menerima perintah yang diinginkan. </p><br><h3 id="scriptsblinkjs-anchorblink-script-blink-jsanchor">  skrip / blink.js <a name="blink-script-blink-js"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> active = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Set port direction $res.blink.direction($res.blink.DIR_MODE_DEF_OUTPUT); // Run background process setInterval(function () { if (active) { // $res - is container with required resources $res.blink.set(state); // Do invert state = !state; } }, 1000); // Event listener // $bus - system bus interface $bus.on(function (event, content, data) { if (event === 'blink') { active = !!JSON.parse(content); } }, null);</span></span></code> </pre> <br><p>  Secara umum, kode ini sangat mirip dengan penggunaan timer klasik dalam JavaScript.  Kecuali itu tidak dalam dialek JavaScript ini.  Itu diimplementasikan di platform.  Temui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mJS</a> ini.  Anda dapat mempelajari lebih lanjut tentang ini di halaman resmi proyek. </p><br><p>  Untuk kebutuhan platform, dialek sudah selesai.  Pengatur waktu telah diperkenalkan, dan juga perintah yang berguna seperti "debugger".  Nah, debugger itu sendiri.  Lebih lanjut tentang ini secara terpisah di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Lingkungan Pengembangan"</a> . </p><br><p>  Perhatikan objek global platform.  Mereka diberi nama dengan karakter "$". </p><br><ul><li>  <strong>$ res</strong> - berisi sumber daya yang dialokasikan untuk skrip; </li><li>  <strong>$ bus</strong> - antarmuka <strong>bus</strong> . </li></ul><br><p>  Karena  aplikasi meminta antarmuka dengan tipe "bit_port" (lihat profile.json / membutuhkan) dan nama "blink", itu diberikan kepadanya sebagai $ res.blink.  Antarmuka hanya mengimplementasikan tiga fungsi: </p><br><ul><li>  <strong>set (value)</strong> - atur level GPIO </li><li>  <strong>get ()</strong> - dapatkan level GPIO saat ini </li><li>  <strong>arah (nilai)</strong> - mengatur mode GPIO </li></ul><br><p>  Untuk fungsi arah, konstanta yang tersedia dijelaskan melalui antarmuka yang sama $ res.blink.: DIR_MODE_DISABLE;  DIR_MODE_DEF_INPUT;  DIR_MODE_DEF_OUTPUT;  DIR_MODE_INPUT_OUTPUT_OD;  DIR_MODE_INPUT_OUTPUT. </p><br><p>  Berlangganan acara bus dilakukan melalui metode $ bus.on.  Dalam hal ini, semua peristiwa dimana skrip berlangganan akan datang ke handler.  Pawang menerima tiga parameter: </p><br><ul><li>  <strong>acara</strong> - pengidentifikasi <strong>acara</strong> .  Dalam hal ini, hanya dua yang mungkin: "$ -script-restart" dan "blink".  Hanya satu yang diproses - blink.  Berlangganan yang kedua hanya diperlukan agar skrip segera diluncurkan saat startup sistem. </li><li>  <strong>konten</strong> - data dapat datang dengan acara tersebut.  Ukurannya dibatasi hingga 126 byte, dengan mempertimbangkan panjang pengidentifikasi acara. </li><li>  <strong>data</strong> - data yang ditransmisikan saat berlangganan acara sebagai parameter kedua.  Dan dalam hal ini, mereka adalah nol. </li></ul><br><p>  Antarmuka bisa diperluas.  Di bawah ini Anda akan menemukan deskripsi tentang cara membuat antarmuka Anda sendiri. </p><br><h2 id="realizaciya-interfeysa-anchorintefacesanchor">  Implementasi antarmuka <a name="intefaces"></a></h2><br><p>  ThingJS memungkinkan Anda untuk memperluas sumber daya perangkat keras dan layanan yang tersedia melalui antarmuka khusus.  Anda dapat secara mandiri membuat antarmuka yang akan mengimplementasikan kompleks, akurat, dimuat, dll.  fungsional. </p><br><p>  Misalnya, Anda dapat mengimplementasikan antarmuka integrasi dengan layanan cloud Anda.  Atau latar belakang, proses asinkron yang dengannya skrip dapat bertukar pesan.  Baik, atau terapkan dukungan tampilan.  Ini juga akan mudah dibuat dan digunakan.  Anda dan orang lain.  Benar, untuk ini Anda perlu tahu C. </p><br><p>  Pertimbangkan implementasi antarmuka bit_port, yang digunakan dalam contoh Blink.  Untuk memulai, Anda perlu menggunakan proyek rilis alpha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ThingJS-template</a> .  Dokumentasi penyebaran ada di dalam proyek itu sendiri. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-template</code> </pre> <br><p>  Proyek ini mencakup komponen: </p><br><ul><li>  <strong>ThingJS-board</strong> - berisi konfigurasi perangkat.  Sejauh ini, hanya ESP32_CORE_BOARD V2 dan kompatibel; </li><li>  <strong>ThingJS-extern</strong> - perpustakaan proyek pihak ketiga yang digunakan ThingJS; </li><li>  <strong>ThingJS-core</strong> - inti platform; </li><li>  <strong>ThingJS-front</strong> - lingkungan pengembangan aplikasi; </li><li>  <strong>ThingJS-stdi</strong> - antarmuka standar. </li></ul><br><p>  Kami tertarik pada proyek ThingJS-stdi.  Strukturnya adalah sebagai berikut: </p><br><div class="scrollable-table"><table><tbody><tr><th>  File </th><th>  Deskripsi </th></tr><tr><td>  implementasi / tgsi_bit_port.c </td><td>  Implementasi antarmuka Bit_port </td></tr><tr><td>  implementasi / tgsi_bit_port.h </td><td>  File header antarmuka Bit_pro </td></tr><tr><td>  CMakeLists.txt </td><td>  skrip membangun cmake </td></tr><tr><td>  README.md </td><td></td></tr><tr><td>  sdti_utils.h </td><td>  Pembantu </td></tr><tr><td>  thingjs_stdi.c </td><td>  Antarmuka Mount Point </td></tr><tr><td>  thingjs_stdi.h </td><td>  File Header Mount Point </td></tr></tbody></table></div><br><p>  Bahkan, kami hanya tertarik pada satu file - implementasi / tgsi_bit_port.c.  Ini berisi semua yang membutuhkan penjelasan terpisah. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thingjsBitPortRegister</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> thingjs_bit_port_cases[] = DEF_CASES( DEF_CASE(GPIO0), DEF_CASE(GPIO2), DEF_CASE(GPIO3), DEF_CASE(GPIO4), DEF_CASE(GPIO5), DEF_CASE(GPIO12), DEF_CASE(GPIO13), DEF_CASE(GPIO14), DEF_CASE(GPIO15), DEF_CASE(GPIO16), DEF_CASE(GPIO17), DEF_CASE(GPIO18), DEF_CASE(GPIO19), DEF_CASE(GPIO21), DEF_CASE(GPIO22), DEF_CASE(GPIO23), DEF_CASE(GPIO25), DEF_CASE(GPIO26), DEF_CASE(GPIO27), DEF_CASE(GPIO32), DEF_CASE(GPIO33) ); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">st_thingjs_interface_manifest</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> = {</span></span> .type = <span class="hljs-string"><span class="hljs-string">"bit_port"</span></span>, .constructor = thingjsBitPortConstructor, .cases = thingjs_bit_port_cases }; thingjsRegisterInterface(&amp;interface); }</code> </pre> <br><p>  Fungsi thingjsBitPortRegister mendaftarkan komponen di inti ThingJS.  Untuk melakukan ini, ia memanggil fungsi thingjsRegisterInterface, yang dilewatinya struktur dengan deskripsi antarmuka. </p><br><ul><li>  pengenal <strong>jenis</strong> - antarmuka.  Dialah yang ditentukan sebagai jenis dalam file manifest.json aplikasi; </li><li>  <strong>konstruktor</strong> - tautan ke konstruktor antarmuka.  Fungsi ini dipanggil setiap kali Anda perlu membuat instance antarmuka baru; </li><li>  <strong>case</strong> adalah array yang menggambarkan sumber daya perangkat keras yang mungkin digunakan antarmuka untuk pekerjaannya.  Dalam hal ini, ini adalah GPIO tunggal.  Tetapi kombinasi atau dependensinya dapat dijelaskan secara terpisah. </li></ul><br><p>  Konstruktor antarmuka memasang antarmuka ke mesin mJS. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mjs_val_t</span></span> thingjsBitPortConstructor(struct mjs *mjs, cJSON *params) { <span class="hljs-comment"><span class="hljs-comment">//Validate preset params //The params must have pin number if (!cJSON_IsNumber(params)) return MJS_UNDEFINED; //Get pin number gpio_num_t gpio = params-&gt;valueint; //Create mjs object mjs_val_t interface = mjs_mk_object(mjs); /* Configure the IOMUX register for pad BLINK_GPIO (some pads are muxed to GPIO on reset already, but some default to other functions and need to be switched to GPIO. Consult the Technical Reference for a list of pads and their default functions.) */ gpio_pad_select_gpio(gpio); //Add protected property to interface mjs_set(mjs, interface, "gpio", ~0, mjs_mk_number(mjs, gpio)); //Set protected flag mjs_set_protected(mjs, interface, "gpio", ~0, true); //Bind functions mjs_set(mjs, interface, "set", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortSet)); mjs_set(mjs, interface, "get", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortGet)); mjs_set(mjs, interface, "direction", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortDirection)); //Consts mjs_set(mjs, interface, "DIR_MODE_DISABLE", ~0, mjs_mk_number(mjs, GPIO_MODE_DISABLE)); mjs_set(mjs, interface, "DIR_MODE_DEF_INPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_DEF_INPUT)); mjs_set(mjs, interface, "DIR_MODE_DEF_OUTPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_DEF_OUTPUT)); mjs_set(mjs, interface, "DIR_MODE_INPUT_OUTPUT_OD", ~0, mjs_mk_number(mjs, GPIO_MODE_INPUT_OUTPUT_OD)); mjs_set(mjs, interface, "DIR_MODE_INPUT_OUTPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_INPUT_OUTPUT)); //Return mJS interface object return interface; }</span></span></code> </pre> <br><p>  Bagaimana parameter dilewatkan: </p><br><ul><li>  <strong>mjs</strong> - konteks eksekusi global; </li><li>  <strong>params</strong> - parameter inisialisasi antarmuka.  Dalam hal ini, ini adalah nomor GPIO. </li></ul><br><p>  Objek "antarmuka" mJS dibuat, tempat metode dan properti antarmuka dipasang: </p><br><ul><li>  properti <strong>gpio</strong> - readonly di mana jumlah GPIO yang digunakan disimpan; </li><li>  <strong>set</strong> - metode untuk mengatur level sinyal; </li><li>  <strong>dapatkan</strong> - metode untuk mendapatkan level sinyal saat ini; </li><li>  <strong>arah</strong> - pengaturan mode GPIO; </li></ul><br><p>  Juga, konstanta dipasang dengan skrip yang dapat beroperasi (DIR_MODE_DISABLE, DIR_MODE_DEF_INPUT, dll.). </p><br><p>  Setelah membuat antarmuka, itu dipasang di bawah pengidentifikasi khusus (dalam contoh Blink itu adalah "blink") di objek $ res global.  Contoh penggunaan dapat ditemukan di bagian Blink ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip / blink.js</a> ). </p><br><p>  Anda dapat memformat antarmuka menjadi komponen atau paket terpisah.  Ini memungkinkan Anda untuk memasang firmware sebagai lego. </p><br><h1 id="sreda-razrabotki-anchordevanchor">  Lingkungan pengembangan <a name="dev"></a></h1><br><h2 id="razrabotka-prilozheniy-anchordev-appanchor">  Pengembangan aplikasi <a name="dev-app"></a></h2><br><p>  Lingkungan pengembangan aplikasi didasarkan pada VUE CLI, yang telah disempurnakan untuk memenuhi kebutuhan platform ThingJS.  Ini adalah garpu yang sulit, termasuk.  fitur-fitur baru dari VUE CLI layak ditunggu jika mereka secara langsung memudahkan kehidupan. </p><br><p>  Untuk menyebarkan lingkungan, Anda harus mengkloning proyek rilis alpha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ThingJS-depan</a> .  Pastikan Anda sudah menginstal git, npm, dan nodejs. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-front <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ThingJS-front npm install</code> </pre> <br><p>  Saat berkembang, saya sarankan menggunakan IDE WEBStorm. </p><br><p>  Komposisi dan struktur proyek mewarisi dari VUE CLI.  Saya akan mencerminkan perbedaan yang signifikan: </p><br><ol><li>  Skrip build ulang di folder build. </li><li>  Variabel lingkungan "HW_DEVICE_URL" telah ditambahkan ke konfigurasi lingkungan dev (config / dev.env.js).  Anda perlu menentukan tautan ke perangkat fisik yang digunakan untuk bekerja. </li><li>  Folder sistem aplikasi src / aplikasi telah muncul.  Ini berisi aplikasi yang akan dibangun secara otomatis.  Secara khusus, ini berisi dua aplikasi: ante (launcher) dan blink (application). </li><li>  Segala sesuatu di atas folder src / aplikasi dianggap sebagai modul platform dan sumber daya.  Tentu saja, Anda dapat membuat perubahan pada mereka, tetapi dalam kasus ini, mereka akan muncul di controller hanya setelah menginstalnya.  T.ch.  Kecuali jika Anda secara khusus menetapkan tujuan untuk diri sendiri, lebih baik tidak menyentuhnya. </li></ol><br><p>  Untuk pengujian, Anda dapat segera memulai dev-server.  Meskipun Anda tidak dapat sepenuhnya berkembang tanpa perangkat keras fisik, ini tidak mengganggu pengembangan antarmuka.  Maka, server dev mulai: </p><br><pre> <code class="bash hljs">npm run dev</code> </pre> <br><p>  Hasilnya harus seperti ini: </p><br><p><img src="https://habrastorage.org/webt/c2/ku/if/c2kuifxxfz1ppogv-_50rp7wtuo.png"></p><br><p>  Membuka browser dan memasukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://0.0.0.0:8080</a> di bilah alamat, Anda akan melihat platform dalam mode pengembangan: </p><br><p><img src="https://habrastorage.org/webt/no/cv/ax/nocvaxx5-kdjtvy0x7i5_jfvcbg.png"></p><br><p>  Proses pengembangan antarmuka itu sendiri tidak jauh berbeda dari pengembangan front-end klasik di VUE.  Kecuali bahwa ada objek platform global yang perlu Anda perhatikan: </p><br><ul><li>  <strong>$ const</strong> - berisi konstanta platform, serta paket bahasa; </li><li>  <strong>$ bus</strong> - bus data; </li><li>  <strong>$ store</strong> - penyimpanan global (VUEX). <br>  Dari contoh, Anda dapat memahami cara menggunakannya. </li></ul><br><p>  Multilingualisme diimplementasikan dengan cara paling sederhana - melalui filter "lang".  Tentukan konstanta bahasa, ini diterjemahkan ke dalam teks tergantung pada bahasa antarmuka. </p><br><pre> <code class="xml hljs">v-bind:label="'BLINK_SATE' | lang"</code> </pre> <br><p>  Untuk mengevaluasi sepenuhnya kapabilitas lingkungan pengembangan, Anda akan memerlukan pengontrol yang siap (dijahit).  Anda dapat mengumpulkan sendiri firmware <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari proyek</a> atau menggunakan firmware dan utilitas yang sudah jadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> . </p><br><p>  Setelah mem-flash controller dan menghubungkan ke jaringan, Anda perlu memastikan bahwa controller dapat diakses melalui IP dari komputer Anda.  Untuk melakukan ini, ketik <a href="">http: // [</a> controller <a href="">IP</a> ] di browser.  Antarmuka WEB harus terbuka. </p><br><p>  Sekarang Anda perlu menentukan alamat controller di file config / dev.env.js </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> merge = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'webpack-merge'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prodEnv = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./prod.env'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = merge(prodEnv, { <span class="hljs-attr"><span class="hljs-attr">NODE_ENV</span></span>: <span class="hljs-string"><span class="hljs-string">'"development"'</span></span>, <span class="hljs-attr"><span class="hljs-attr">HW_DEVICE_URL</span></span>: <span class="hljs-string"><span class="hljs-string">'"http://[IP ]"'</span></span> <span class="hljs-comment"><span class="hljs-comment">//HW_DEVICE_URL: '"http://192.168.8.105"', //HW_DEVICE_URL: '"http://192.168.4.1"', })</span></span></code> </pre> <br><p>  Jika server dev dimulai, hentikan dan restart.  Di masa depan, setelah mengubah file build, konfigurasi, dan manifes aplikasi, selalu restart server dev. </p><br><p>  Meskipun ketika bekerja di lingkungan dev, semua aplikasi yang ada di folder src / application asinstalled ditampilkan, hanya mereka yang benar-benar diinstal pada controller akan bekerja sepenuhnya.  Ini bukan fitur, tetapi bug alpha.  Di masa depan, sinkronisasi perangkat keras dan lingkungan dev akan terjadi secara otomatis.  Tetapi untuk sekarang, Anda perlu menginstal aplikasi secara manual pada pengontrol sehingga lingkungan ‚Äúmengaitkannya‚Äù dan menyinkronkannya dengan apa yang ada di dev. </p><br><p>  Kami merakit aplikasi dalam mode prod: </p><br><pre> <code class="bash hljs">npm run prod</code> </pre> <br><p>  Instal aplikasi yang dikumpulkan pada controller secara langsung.  <u><strong>Tidak melalui server dev</strong></u> . </p><br><p>  Sekarang Anda dapat memulai pengembangan.  Setiap perubahan yang Anda buat pada file Anda akan secara otomatis mulai membangun kembali aplikasi dan gambar di layar akan berubah (hot reload).  Aturan yang sama berlaku untuk skrip pengontrol.  Misalnya, Anda dapat menambahkan perintah debugger ke skrip aplikasi blink dan lihat hasilnya. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Event listener // $bus - system bus interface $bus.on(function (event, content, data) { if (event === 'blink') { debugger; active = !!JSON.parse(content); } }, null);</span></span></code> </pre> <br><p>  Sekarang, ketika keadaan kotak centang aplikasi Blink berubah, lingkungan pengembangan akan melempar pesan berikut: </p><br><p><img src="https://habrastorage.org/webt/bj/lw/qg/bjlwqgwrzgutdhi0vr2oed_cuee.png"></p><br><p>  Mengklik tautan "Mulai debugger" akan membawa Anda ke debugger.  Garis di mana berhenti terjadi ditampilkan. </p><br><p><img src="https://habrastorage.org/webt/m7/8u/3e/m78u3etl9hleirs072xjgpye_rw.png"></p><br><p>  Proses debugging itu sendiri tidak jauh berbeda dari debugger lain. </p><br><p><img src="https://habrastorage.org/webt/0m/i_/nt/0mi_nt0gx_-e-7nnvrrtdhxb9kg.png"></p><br><p>  Debugger dibagi menjadi empat bagian.  Dalam kode pusat itu sendiri.  Meninggalkan aplikasi yang terinstal di controller.  Struktur dan komposisi mereka.  Benar, Inspektur.  Log ditampilkan di bawah ini.  Di kiri bawah adalah status komunikasi saat ini dengan controller. </p><br><p>  Lingkungan debugging sedang dalam proses pengembangan intensif.  Masih banyak lagi alat pemantauan dan debugging yang akan dibangun.  Saya minta maaf sebelumnya untuk kemungkinan bug. </p><br><h2 id="razrabotka-proshivki-anchordev-firmwareanchor">  Pengembangan firmware <a name="dev-firmware"></a></h2><br><p>  Pengembangan firmware didasarkan pada konsep yang diusulkan oleh Espressif.  Saya tidak bisa mengalahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi asli</a> dalam hal ini. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori telah</a> disiapkan untuk memulai dengan cepat.  Ini berisi informasi penyebaran.  Untuk contoh penggunaan, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">‚ÄúMenerapkan Antarmuka‚Äù</a> . </p><br><p>  Perakitan ini sangat sederhana dan dalam 1-2 jam Anda sudah dapat memasang firmware tanpa masalah. </p><br><h1 id="chto-dalshe-anchorwhat-afteranchor">  Apa selanjutnya <a name="what-after"></a></h1><br><p>  Selanjutnya, jika platform tersebut menarik bagi masyarakat, direncanakan: </p><br><ul><li>  Pengembangan lingkungan debugging; </li><li>  Standarisasi penamaan antarmuka, acara, komponen; </li><li>  Dokumentasi terperinci pada platform; </li><li>  Hosting awan untuk hal-hal virtual; </li><li>  Repositori Runtime </li><li>  Mempartisi ke berbagai perangkat jadi. </li></ul><br><p>  Juga, saya mencari orang-orang yang ingin mengembangkan platform dengan saya.  Itu sudah sangat besar dalam cakupan dan ambisi.  Saya berasumsi kerja sama yang setara, yang tujuannya adalah untuk mengembangkan platform ke prinsip OpenSource yang lengkap. </p><br><p>        pull-     . </p><br><h1 id="ssylki-anchorrefsanchor">  Referensi <a name="refs"></a></h1><br><p>   ThingJS: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Situs</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> </li></ul><br><p>   ThingJS: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a> </li></ul><br><p>  : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESP32</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">esp-idf</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mongoose WEB Server</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mJS</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vue 2</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vuetifyjs</a> </li></ul><br><h1 id="faq-anchorfaqanchor"> FAQ <a name="faq"></a></h1><br><p>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474356/">https://habr.com/ru/post/id474356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474342/index.html">Mempercepat adegan dalam video menggunakan tampilan tabel</a></li>
<li><a href="../id474344/index.html">Internet Benda di Industri: Bagaimana Cara Kerja Pabrik Cerdas?</a></li>
<li><a href="../id474346/index.html">Pengembangan Docker di Windows Subsystem for Linux (WSL)</a></li>
<li><a href="../id474352/index.html">Penghancuran musuh dengan melompat, seperti dalam "Mario" Unity 2D</a></li>
<li><a href="../id474354/index.html">Smart home in container (ioBroker + Zigbee in Docker)</a></li>
<li><a href="../id474358/index.html">Tidur cukup di akhir pekan: bagaimana white noise membantu orang dewasa untuk rileks dan memantau kualitas tidur anak-anak</a></li>
<li><a href="../id474360/index.html">Tingkatkan CSS Anda dengan 5 prinsip ini.</a></li>
<li><a href="../id474364/index.html">Pengembangan elektronik. Ulasan subjektif dari sensor terintegrasi yang paling berguna</a></li>
<li><a href="../id474366/index.html">Acara digital di Moskow dari 4 hingga 10 November</a></li>
<li><a href="../id474368/index.html">Sinopsis tentang Pembelajaran Mesin. Teori probabilitas. Formula bayes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>