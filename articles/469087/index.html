<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèª üëÜ üìΩÔ∏è MVCC en PostgreSQL-2. Tenedores, archivos, p√°ginas. üéä üìØ üë©üèº‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La √∫ltima vez que hablamos sobre la consistencia de los datos, observamos la diferencia entre los niveles de aislamiento de transacciones desde el pun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC en PostgreSQL-2. Tenedores, archivos, p√°ginas.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/469087/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La √∫ltima vez</a> que hablamos sobre la consistencia de los datos, observamos la diferencia entre los niveles de aislamiento de transacciones desde el punto de vista del usuario y descubrimos por qu√© es importante saberlo.  Ahora estamos comenzando a explorar c√≥mo PostgreSQL implementa el aislamiento de instant√°neas y la concurrencia multiversion. <br><br>  En este art√≠culo, veremos c√≥mo se disponen f√≠sicamente los datos en archivos y p√°ginas.  Esto nos aleja de discutir el aislamiento, pero tal digresi√≥n es necesaria para entender lo que sigue.  Tendremos que descubrir c√≥mo se organiza el almacenamiento de datos en un nivel bajo. <br><br><h1>  Relaciones </h1><br>  Si observa las tablas e √≠ndices, resulta que est√°n organizados de manera similar.  Ambos son objetos de base de datos que contienen algunos datos que consisten en filas. <br><br>  No hay duda de que una tabla consta de filas, pero esto es menos obvio para un √≠ndice.  Sin embargo, imagine un √°rbol B: consta de nodos que contienen valores indexados y referencias a otros nodos o filas de tabla.  Son estos nodos los que pueden considerarse filas de √≠ndice y, de hecho, lo son. <br><br>  En realidad, algunos objetos m√°s se organizan de manera similar: secuencias (esencialmente tablas de una sola fila) y vistas materializadas (esencialmente, tablas que recuerdan la consulta).  Y tambi√©n hay vistas regulares, que no almacenan datos por s√≠ mismas, pero en todos los dem√°s sentidos son similares a las tablas. <br><br>  Todos estos objetos en PostgreSQL se denominan la <em>relaci√≥n de</em> palabra com√∫n.  Esta palabra es extremadamente impropia porque es un t√©rmino de la teor√≠a relacional.  Puede dibujar un paralelo entre una relaci√≥n y una tabla (vista), pero ciertamente no entre una relaci√≥n y un √≠ndice.  Pero sucedi√≥: el origen acad√©mico de PostgreSQL se manifiesta.  Me parece que primero se llamaron las tablas y las vistas, y el resto aument√≥ con el tiempo. <br><a name="habracut"></a><br>  Para ser m√°s simple, discutiremos m√°s las tablas e √≠ndices, pero las otras <em>relaciones</em> se organizan exactamente de la misma manera. <br><br><h1>  Tenedores y limas </h1><br>  Por lo general, varias <em>horquillas</em> corresponden a cada relaci√≥n.  Las bifurcaciones pueden tener varios tipos, y cada uno de ellos contiene un cierto tipo de datos. <br><br>  Si hay una bifurcaci√≥n, primero se representa con el √∫nico <em>archivo</em> .  El nombre de archivo es un identificador num√©rico, que se puede agregar con un final que corresponde al nombre de la bifurcaci√≥n. <br><br>  El archivo crece gradualmente y cuando su tama√±o alcanza 1 GB, se crea un nuevo archivo de la misma bifurcaci√≥n (los archivos como estos a veces se denominan <em>segmentos</em> ).  El n√∫mero ordinal del segmento se agrega al final del nombre del archivo. <br><br>  La limitaci√≥n de 1 GB del tama√±o del archivo surgi√≥ hist√≥ricamente para admitir diferentes sistemas de archivos, algunos de los cuales no pueden manejar archivos de mayor tama√±o.  Puede cambiar esta limitaci√≥n al <code>./configure --with-segsize</code> PostgreSQL ( <code>./configure --with-segsize</code> ). <br><br>  Por lo tanto, varios archivos en el disco pueden corresponder a una relaci√≥n.  Por ejemplo, para una mesa peque√±a habr√° tres de ellos. <br><br>  Todos los archivos de objetos que pertenecen a un espacio de tabla y una base de datos se almacenar√°n en un directorio.  Debe tener esto en cuenta ya que los sistemas de archivos generalmente no funcionan bien con una gran cantidad de archivos en un directorio. <br><br>  Tenga en cuenta que los archivos, a su vez, se dividen en <em>p√°ginas</em> (o <em>bloques</em> ), generalmente por 8 KB.  Discutiremos la estructura interna de las p√°ginas un poco m√°s. <br><br><img src="https://habrastorage.org/webt/10/ze/w6/10zew6_pruaxe8amjtx7_6x70tk.png"><br><br>  Ahora veamos los tipos de horquillas. <br><br>  La <strong>bifurcaci√≥n principal</strong> son los datos en s√≠: las filas de la tabla y el √≠ndice.  La bifurcaci√≥n principal est√° disponible para cualquier relaci√≥n (excepto las vistas que no contienen datos). <br><br>  Los nombres de los archivos de la bifurcaci√≥n principal consisten en el √∫nico identificador num√©rico.  Por ejemplo, esta es la ruta a la tabla que creamos la √∫ltima vez: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  ¬øDe d√≥nde surgen estos identificadores?  El directorio "base" corresponde al espacio de tabla "pg_default".  El siguiente subdirectorio, correspondiente a la base de datos, es donde se encuentra el archivo de inter√©s: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  La ruta es relativa, se especifica a partir del directorio de datos (PGDATA).  Adem√°s, pr√°cticamente todas las rutas en PostgreSQL se especifican a partir de PGDATA.  Gracias a esto, puede mover PGDATA de forma segura a una ubicaci√≥n diferente; nada lo limita (excepto que puede ser necesario establecer la ruta a las bibliotecas en LD_LIBRARY_PATH). <br><br>  Adem√°s, buscando en el sistema de archivos: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  La <strong>bifurcaci√≥n de inicializaci√≥n</strong> solo est√° disponible para tablas no registradas (creadas con UNLOGGED especificado) y sus √≠ndices.  Los objetos como estos no son diferentes de los objetos normales, excepto que las operaciones con ellos no se registran en el registro de escritura anticipada (WAL).  Debido a esto, es m√°s r√°pido trabajar con ellos, pero es imposible recuperar los datos en el estado consistente en caso de falla.  Por lo tanto, durante una recuperaci√≥n, PostgreSQL simplemente elimina todas las bifurcaciones de dichos objetos y escribe la bifurcaci√≥n de inicializaci√≥n en lugar de la bifurcaci√≥n principal.  Esto da como resultado un objeto vac√≠o.  Discutiremos el registro en detalle, pero en otra serie. <br><br>  La tabla "cuentas" se registra y, por lo tanto, no tiene una bifurcaci√≥n de inicializaci√≥n.  Pero para experimentar, podemos desactivar el cierre de sesi√≥n: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  El ejemplo aclara que la posibilidad de activar y desactivar el inicio de sesi√≥n sobre la marcha est√° asociada con la reescritura de los datos en archivos con diferentes nombres. <br><br>  Una bifurcaci√≥n de inicializaci√≥n tiene el mismo nombre que la bifurcaci√≥n principal, pero con el sufijo "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  El <strong>mapa de espacio libre</strong> es una bifurcaci√≥n que realiza un seguimiento de la disponibilidad de espacio libre dentro de las p√°ginas.  Este espacio cambia constantemente: disminuye cuando se agregan nuevas versiones de filas y aumenta durante la aspiraci√≥n.  El mapa de espacio libre se usa durante la inserci√≥n de nuevas versiones de fila para encontrar r√°pidamente una p√°gina adecuada, donde se ajusten los datos que se agregar√°n. <br><br>  El nombre del mapa de espacio libre tiene el sufijo "_fsm".  Pero este archivo aparece no inmediatamente, sino solo cuando surge la necesidad.  La forma m√°s f√°cil de lograr esto es aspirar una mesa (explicaremos por qu√© cuando llegue el momento): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  El <strong>mapa de visibilidad</strong> es una bifurcaci√≥n donde las p√°ginas que solo contienen versiones actualizadas de filas est√°n marcadas por un bit.  Aproximadamente, significa que cuando una transacci√≥n intenta leer una fila de dicha p√°gina, la fila se puede mostrar sin verificar su visibilidad.  En los pr√≥ximos art√≠culos, discutiremos en detalle c√≥mo sucede esto. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  P√°ginas </h1><br>  Como ya se mencion√≥, los archivos se dividen l√≥gicamente en p√°ginas. <br><br>  Una p√°gina generalmente tiene el tama√±o de 8 KB.  El tama√±o se puede cambiar dentro de ciertos l√≠mites (16 KB o 32 KB), pero solo durante la compilaci√≥n ( <code>./configure --with-blocksize</code> ).  Una instancia construida y ejecutada solo puede funcionar con p√°ginas del mismo tama√±o. <br><br>  Independientemente de la bifurcaci√≥n a la que pertenecen los archivos, el servidor los usa de una manera bastante similar.  Las p√°ginas se leen primero en la memoria cach√© del b√∫fer, donde los procesos pueden leerlas y cambiarlas;  luego, cuando surge la necesidad, son expulsados ‚Äã‚Äãde nuevo al disco. <br><br>  Cada p√°gina tiene particiones internas y, en general, contiene las siguientes particiones: <br><br><pre>        0 + ----------------------------------- +
           El |  cabecera |
       24 + ----------------------------------- +
           El |  matriz de punteros a versiones de fila |
    inferior + ----------------------------------- +
           El |  espacio libre |
    superior + ----------------------------------- +
           El |  versiones de fila |
  especial + ----------------------------------- +
           El |  espacio especial |
 tama√±o de p√°gina + ----------------------------------- +
</pre><br>  Puede conocer f√°cilmente los tama√±os de estas particiones utilizando la p√°gina de extensi√≥n "investigaci√≥n" inspeccionar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Aqu√≠ estamos mirando el <strong>encabezado</strong> de la primera p√°gina (cero) de la tabla.  Adem√°s de los tama√±os de otras √°reas, el encabezado tiene informaci√≥n diferente sobre la p√°gina, que a√∫n no nos interesa. <br><br>  En la parte inferior de la p√°gina hay <strong>un espacio especial</strong> , que en este caso est√° vac√≠o.  Solo se usa para √≠ndices, e incluso no para todos.  "En la parte inferior" aqu√≠ refleja lo que est√° en la imagen;  puede ser m√°s exacto decir "en direcciones altas". <br><br>  Despu√©s del espacio especial, se ubican las <strong>versiones de fila</strong> , es decir, esos mismos datos que almacenamos en la tabla m√°s informaci√≥n interna. <br><br>  En la parte superior de una p√°gina, justo despu√©s del encabezado, est√° la tabla de contenido: la <strong>matriz de punteros</strong> a las versiones de fila disponibles en la p√°gina. <br><br>  Se puede dejar <strong>espacio libre</strong> entre las versiones de fila y los punteros (este espacio libre se registra en el mapa de espacio libre).  Tenga en cuenta que no hay fragmentaci√≥n de memoria dentro de una p√°gina: todo el espacio libre est√° representado por un √°rea contigua. <br><br><h2>  Punteros </h2><br>  ¬øPor qu√© se necesitan los punteros a las versiones de fila?  La cuesti√≥n es que las filas de √≠ndice deben de alguna manera hacer referencia a las versiones de fila en la tabla.  Est√° claro que la referencia debe contener el n√∫mero de archivo, el n√∫mero de la p√°gina en el archivo y alguna indicaci√≥n de la versi√≥n de la fila.  Podr√≠amos usar el desplazamiento desde el comienzo de la p√°gina como indicador, pero es inconveniente.  No podr√≠amos mover una versi√≥n de fila dentro de la p√°gina, ya que romper√≠a las referencias disponibles.  Y esto resultar√≠a en la fragmentaci√≥n del espacio dentro de las p√°ginas y otras consecuencias problem√°ticas.  Por lo tanto, el √≠ndice hace referencia al n√∫mero de puntero y el puntero hace referencia a la ubicaci√≥n actual de la versi√≥n de fila en la p√°gina.  Y este es un direccionamiento indirecto. <br><br>  Cada puntero ocupa exactamente cuatro bytes y contiene: <br><br><ul><li>  una referencia a la versi√≥n de fila </li><li>  el tama√±o de esta versi√≥n de fila </li><li>  varios bytes para determinar el estado de la versi√≥n de la fila </li></ul><br><h2>  Formato de datos </h2><br>  El formato de datos en el disco es exactamente el mismo que el de la representaci√≥n de datos en la RAM.  La p√°gina se lee en la memoria cach√© del b√∫fer "tal cual", sin ninguna conversi√≥n.  Por lo tanto, los archivos de datos de una plataforma resultan incompatibles con otras plataformas. <br><br>  Por ejemplo, en la arquitectura X86, el orden de bytes es de bytes menos significativos a bytes m√°s significativos (little-endian), z / Architecture utiliza el orden inverso (big-endian), y en ARM el orden puede intercambiarse. <br><br>  Muchas arquitecturas proporcionan la alineaci√≥n de datos en los l√≠mites de las palabras de m√°quina.  Por ejemplo, en un sistema x86 de 32 bits, los n√∫meros enteros (tipo "entero", que ocupa 4 bytes) se alinear√°n en un l√≠mite de palabras de 4 bytes, de la misma manera que los n√∫meros de precisi√≥n doble (tipo "precisi√≥n doble" , que ocupa 8 bytes).  Y en un sistema de 64 bits, los n√∫meros de doble precisi√≥n se alinear√°n en un l√≠mite de palabras de 8 bytes.  Esta es una raz√≥n m√°s de incompatibilidad. <br><br>  Debido a la alineaci√≥n, el tama√±o de la fila de la tabla depende del orden del campo.  Por lo general, este efecto no es muy notable, pero a veces, puede dar lugar a un crecimiento significativo del tama√±o.  Por ejemplo, si los campos de los tipos ‚Äúchar (1)‚Äù y ‚Äúinteger‚Äù est√°n intercalados, generalmente se desperdician 3 bytes entre ellos.  Para obtener m√°s detalles sobre esto, puede consultar la presentaci√≥n de Nikolay Shaplov " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tuple internos</a> ". <br><br><h1>  Versiones de fila y TOSTADA </h1><br>  Discutiremos los detalles de la estructura interna de las versiones de fila la pr√≥xima vez.  En este punto, solo es importante para nosotros saber que cada versi√≥n debe caber completamente en una p√°gina: PostgreSQL no tiene forma de "extender" la fila a la p√°gina siguiente.  En su lugar, se utiliza la t√©cnica de almacenamiento de atributos de gran tama√±o (TOAST).  El nombre en s√≠ sugiere que una fila se puede cortar en tostadas. <br><br>  Bromas aparte, TOAST implica varias estrategias.  Podemos transmitir valores de atributos largos a una tabla interna separada despu√©s de dividirlos en peque√±os trozos de pan tostado.  Otra opci√≥n es comprimir un valor para que la versi√≥n de la fila se ajuste a una p√°gina normal.  Y podemos hacer ambas cosas: primero comprimir y luego romper y transmitir. <br><br>  Para cada tabla primaria, se puede crear una tabla TOAST separada si es necesario, una para todos los atributos (junto con un √≠ndice).  La disponibilidad de atributos potencialmente largos determina esta necesidad.  Por ejemplo, si una tabla tiene una columna de tipo "num√©rico" o "texto", la tabla TOAST se crear√° inmediatamente incluso si no se utilizar√°n valores largos. <br><br>  Dado que una tabla TOAST es esencialmente una tabla normal, tiene el mismo conjunto de horquillas.  Y esto duplica el n√∫mero de archivos que corresponden a una tabla. <br><br>  Las estrategias iniciales est√°n definidas por los tipos de datos de columna.  Puede verlos usando el comando <code>\d+</code> en psql, pero dado que adem√°s genera mucha otra informaci√≥n, consultaremos el cat√°logo del sistema: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Los nombres de las estrategias significan: <br><br><ul><li>  plain: TOAST no se usa (se usa para tipos de datos que se sabe que son cortos, como "entero"). </li><li>  extendido: tanto la compresi√≥n como el almacenamiento en una tabla TOAST separada est√°n permitidos </li><li>  externo: los valores largos se almacenan en la tabla TOAST sin compresi√≥n. </li><li>  main: los valores largos se comprimen primero y solo entran en la tabla TOAST si la compresi√≥n no ayud√≥. </li></ul><br>  En general, el algoritmo es el siguiente.  PostgreSQL tiene como objetivo tener al menos cuatro filas en una p√°gina.  Por lo tanto, si el tama√±o de la fila excede un cuarto de la p√°gina, se debe tener en cuenta el encabezado (2040 bytes para una p√°gina 8K normal), TOAST debe aplicarse a una parte de los valores.  Seguimos el orden que se describe a continuaci√≥n y nos detenemos en cuanto la fila ya no supera el umbral: <br><br><ol><li>  Primero revisamos los atributos con las estrategias "externas" y "extendidas" desde el atributo m√°s largo hasta el m√°s corto.  Los atributos "extendidos" se comprimen (si es efectivo) y si el valor en s√≠ excede un cuarto de la p√°gina, inmediatamente entra en la tabla TOAST.  Los atributos "externos" se procesan de la misma manera, pero no se comprimen. </li><li>  Si despu√©s de la primera pasada, la versi√≥n de la fila a√∫n no se ajusta a la p√°gina, transmitimos los atributos restantes con las estrategias "externas" y "extendidas" a la tabla TOAST. </li><li>  Si esto tampoco ayud√≥, intentamos comprimir los atributos con la estrategia "principal", pero los dejamos en la p√°gina de la tabla. </li><li>  Y solo si despu√©s de eso, la fila no es lo suficientemente corta, los atributos "principales" entran en la tabla TOAST. </li></ol><br>  A veces puede ser √∫til cambiar la estrategia para ciertas columnas.  Por ejemplo, si se sabe de antemano que los datos en una columna no se pueden comprimir, podemos establecer la estrategia "externa" para ello, lo que nos permite ahorrar tiempo al evitar intentos de compresi√≥n in√∫tiles.  Esto se hace de la siguiente manera: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  Al volver a ejecutar la consulta, obtenemos: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  Las tablas e √≠ndices TOAST se encuentran en el esquema pg_toast separado y, por lo tanto, generalmente no son visibles.  Para las tablas temporales, el esquema "pg_toast_temp_ <em>N</em> " se usa de manera similar al "pg_temp_ <em>N</em> " habitual. <br><br>  Por supuesto, si lo desea, nadie le impedir√° espiar la mec√°nica interna del proceso.  Digamos que en la tabla "cuentas" hay tres atributos potencialmente largos y, por lo tanto, debe haber una tabla TOAST.  Aqu√≠ esta: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  Es razonable que la estrategia "simple" se aplique a las tostadas en las que se corta la fila: no hay una TOSTADA de segundo nivel. <br><br>  PostgreSQL oculta mejor el √≠ndice, pero tampoco es dif√≠cil de encontrar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  La columna "cliente" utiliza la estrategia "extendida": sus valores se comprimir√°n.  Vamos a ver: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  No hay nada en la tabla TOAST: los caracteres que se repiten se comprimen bien y, despu√©s de la compresi√≥n, el valor se ajusta a una p√°gina de tabla habitual. <br><br>  Y ahora deje que el nombre del cliente consista en caracteres aleatorios: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Dicha secuencia no se puede comprimir y entra en la tabla TOAST: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Podemos ver que los datos se dividen en fragmentos de 2000 bytes. <br><br>  Cuando se accede a un valor largo, PostgreSQL autom√°ticamente y de forma transparente para la aplicaci√≥n restaura el valor original y lo devuelve al cliente. <br><br>  Ciertamente, es bastante intensivo en recursos comprimir y romper y luego restaurar.  Por lo tanto, almacenar datos masivos en PostgreSQL no es la mejor idea, especialmente si se usan con frecuencia y el uso no requiere l√≥gica transaccional (por ejemplo: escaneos de documentos contables originales).  Una alternativa m√°s beneficiosa es almacenar dichos datos en un sistema de archivos con los nombres de archivo almacenados en el DBMS. <br><br>  La tabla TOAST solo se usa para acceder a un valor largo.  Adem√°s, su propia concurrencia de mutiversion es compatible con una tabla TOAST: a menos que una actualizaci√≥n de datos toque un valor largo, una nueva versi√≥n de fila har√° referencia al mismo valor en la tabla TOAST, y esto ahorra espacio. <br><br>  Tenga en cuenta que TOAST solo funciona para tablas, pero no para √≠ndices.  Esto impone una limitaci√≥n en el tama√±o de las claves a indexar. <br><blockquote>  Para obtener m√°s detalles sobre la estructura de datos interna, puede leer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> . <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469087/">https://habr.com/ru/post/469087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469073/index.html">Derivado discreto o resumen de c√≥mo sumar series</a></li>
<li><a href="../469075/index.html">Grokay DLR</a></li>
<li><a href="../469077/index.html">Nuevo curso de Python de Microsoft [en ingl√©s]</a></li>
<li><a href="../469079/index.html">Python en Visual Studio Code: actualizaci√≥n de extensi√≥n de septiembre</a></li>
<li><a href="../469085/index.html">Sacamos el software del microcontrolador protegido con contrase√±a Renesas M16C</a></li>
<li><a href="../469093/index.html">Comparaci√≥n de bibliotecas de CLI menos populares y no muy cliff: cliff, plac, plumbum y otras (parte 2)</a></li>
<li><a href="../469095/index.html">Lanzamiento de las actualizaciones de ML.NET y Model Builder: novedades</a></li>
<li><a href="../469097/index.html">Servidor web CentOS 8 con php7, node.js y redis</a></li>
<li><a href="../469099/index.html">Tareas de prueba en la entrevista del desarrollador: ¬øtiene sentido?</a></li>
<li><a href="../469101/index.html">Aprender ingl√©s: c√≥mo aprender a hablar como hablante nativo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>