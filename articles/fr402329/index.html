<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèª üóÑÔ∏è üë©üèø‚Äçü§ù‚Äçüë©üèª M√©mo. AVR Buzic üíáüèΩ üéø ü•ö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Essence 
 J'ai d√©j√† cr√©√© un certain nombre d'appareils √©lectroniques de loisirs diff√©rents, et j'ai une caract√©ristique √©trange: s'il y a un √©metteur ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©mo. AVR Buzic</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402329/"><img src="https://habrastorage.org/files/a62/a7b/0f9/a62a7b0f93e34b378c415b8d4b1873bb.jpg"><br><h3>  Essence </h3><br>  J'ai d√©j√† cr√©√© un certain nombre d'appareils √©lectroniques de loisirs diff√©rents, et j'ai une caract√©ristique √©trange: s'il y a un √©metteur pi√©zo√©lectrique sonore (buzzer) sur la carte, moi, apr√®s avoir termin√© le travail principal sur le projet, je commence √† souffrir de b√™tises et √† lui faire jouer diverses m√©lodies (autant que possible) )  Il est particuli√®rement utile d'inclure une m√©lodie √† la fin d'un long processus pour attirer l'attention.  Par exemple, je l'ai utilis√© lorsque j'ai construit une cam√©ra d'exposition de fortune pour √©clairer la r√©sine photosensible, etc. <br><br>  Mais lorsque j'ai commenc√© √† chercher des exemples de g√©n√©ration de fr√©quences pour les AVR sur le r√©seau, pour une raison quelconque, je suis tomb√© sur des projets monstrueux ou insuffisamment concis qui mettent en ≈ìuvre la g√©n√©ration de fr√©quences sonores de mani√®re purement programmatique.  Et puis j'ai d√©cid√© de le d√©couvrir moi-m√™me ... <br><a name="habracut"></a><br><h3>  Digression lyrique </h3><br>  Mon hobby comprend la cr√©ation de divers appareils sur des microcontr√¥leurs, car cela ne recoupe pas mon prof.  activit√© (d√©veloppement logiciel), je me consid√®re comme un autodidacte absolu, et en √©lectronique ce n'est pas trop fort.  En fait, je pr√©f√®re les microcontr√¥leurs PIC, mais il se trouve que j'ai accumul√© un certain nombre de microcontr√¥leurs Atmel AVR (maintenant Microchip).  Faites imm√©diatement une r√©servation que je n'ai jamais eu AVR entre les mains, c'est-√†-dire  Il s'agit de mon premier projet sur le MCU Atmel, √† savoir Atmega48pa.  Le projet lui-m√™me r√©alise une charge utile, mais je n'en d√©crirai ici qu'une partie li√©e √† la g√©n√©ration de fr√©quences sonores.  Le test de g√©n√©ration de fr√©quences que j'ai appel√© "buzic", comme abr√©viation pour la musique de buzzer.  Oui, j'ai presque oubli√©: sur Habr il y a un utilisateur avec le surnom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">buzic</a> , je voulais imm√©diatement avertir que ce m√©mo ne s'applique pas √† lui en aucune fa√ßon, et juste au cas o√π, je m'excuse imm√©diatement d'utiliser la combinaison de lettres "Buzic". <br><br><h3>  Alors allons-y </h3><br>  J'ai pris connaissance d'un grand nombre d'exemples provenant du r√©seau - tous sont construits soit sur le cycle le plus simple dans le corps principal du firmware, soit sur l'interruption de la minuterie.  Mais ils utilisent tous la m√™me approche pour g√©n√©rer de la fr√©quence: <br><br><ol><li>  alimenter un niveau √©lev√© au pied du microcontr√¥leur </li><li>  faire un retard </li><li>  alimentation basse jusqu'au pied du microcontr√¥leur </li></ol><br>  Modification des retards et des param√®tres de la minuterie - ajustez la fr√©quence. <br><br>  Cette approche ne me convenait pas beaucoup, car  Je n'avais aucune envie d'√©crire du code pour un contr√¥le manuel du pied du microcontr√¥leur.  Je voudrais que la "pierre" g√©n√®re pour moi la fr√©quence du son, et je r√®gle juste les valeurs de certains registres, la changeant ainsi (fr√©quence). <br><br>  Lors de l'√©tude de la fiche technique (ci-apr√®s d√©nomm√©e DS), j'ai toujours trouv√© le mode de minuterie dont j'avais besoin - et ce mode, comme vous l'avez peut-√™tre devin√©, est le mode CTC (Clear Timer on Compare Match).  √âtant donn√© que la fonction de jouer de la musique est, pour le moins, pas la fonctionnalit√© principale, j'ai pr√©f√©r√© s√©lectionner la minuterie 2 pour cela (paragraphe 22 de la SD). <br><br>  Tout le monde sait que pratiquement tous les microcontr√¥leurs ont un mode de g√©n√©ration de signal PWM qui est impl√©ment√© sur des minuteries et il est enti√®rement mat√©riel.  Mais dans cette t√¢che, PWM ne convient pas car  une seule fr√©quence sera g√©n√©r√©e dans le mat√©riel.  Par cons√©quent, nous avons besoin de PFM (modulation de fr√©quence d'impulsion).  Une certaine similitude de PFM est le mode de temporisation CTC (clause 22.7.2 LH). <br><br><h3>  Mode CTC </h3><br>  Le minuteur 2 du microcontr√¥leur Atmega48pa est de 8 bits, c'est-√†-dire qu'il ¬´passe¬ª de 0 √† 255, puis passe en cercle.  Soit dit en passant, la minuterie peut aller dans une direction diff√©rente, mais pas dans notre cas.  Le prochain composant requis est l'unit√© de comparaison.  Parlant tr√®s grossi√®rement, ce module est l'initiateur de tout √©v√©nement li√© √† la minuterie.  Les √©v√©nements peuvent √™tre diff√©rents - tels que les interruptions, les changements de niveau de certaines jambes du microcontr√¥leur, etc. (√âvidemment, nous nous int√©ressons au second).  Comme vous pouvez le deviner, le module de comparaison n'est pas seulement nomm√© - il compare une valeur sp√©cifique s√©lectionn√©e par le d√©veloppeur du firmware avec la valeur actuelle du minuteur.  Si la valeur de la minuterie atteint la valeur que nous avons d√©finie, un √©v√©nement se produit.  Des √©v√©nements peuvent √©galement se produire lorsque la minuterie d√©borde ou pendant une r√©initialisation.  <b>Ok, nous sommes arriv√©s √† la conclusion qu'il est pratique pour nous √† certains moments que la minuterie, avec le module de comparaison, change ind√©pendamment le niveau sur le pied du microcontr√¥leur √† l'oppos√© - g√©n√©rant ainsi des impulsions.</b> <br><br>  La deuxi√®me t√¢che consiste √† d√©finir les intervalles entre ces impulsions - c'est-√†-dire  contr√¥ler la fr√©quence de g√©n√©ration.  Le caract√®re unique du mode CTC r√©side dans le fait que dans ce mode, le temporisateur n'atteint pas la fin (255), mais est r√©initialis√© lorsque la valeur d√©finie est atteinte.  Par cons√©quent, en modifiant cette valeur, nous pouvons r√©ellement contr√¥ler la fr√©quence.  Par exemple, si nous d√©finissons la valeur du module de comparaison √† 10, le changement de niveau au pied du microcontr√¥leur se produira 20 fois plus souvent que si nous le d√©finissons (la valeur du module de comparaison) √† 200. <b>Maintenant, nous pouvons contr√¥ler la fr√©quence!</b> <br><br><img src="https://habrastorage.org/files/d45/90e/b7a/d4590eb7acd543a59fc71057cc6ae5b5.png"><br><br><h3>  Le fer </h3><br><img src="https://habrastorage.org/files/8f9/dbb/8f5/8f9dbb8f514f4819863dff1a4dff4690.png"><br>  Le brochage du microcontr√¥leur montre que nous devons connecter notre buzzer √† la jambe de PB3 (OC2A) ou √† la jambe de PD3 (OC2B), car  OC2A et OC2B signifient exactement que sur ces jambes, le temporisateur 2 peut g√©n√©rer des signaux. <br><br>  Le sch√©ma que j'utilise habituellement pour connecter le buzzer est: <br><img src="https://habrastorage.org/files/8c8/a1e/7c6/8c8a1e7c67cf433989b5b94b89fa3e55.png"><br><br>  <b>Et donc nous avons assembl√© l'appareil.</b> <br><br><h3>  Registres </h3><br>  Dans le paragraphe pr√©c√©dent, nous avons d√©cid√© du choix de la jambe - c'est PB3 (OC2A), nous allons travailler avec.  Si vous avez besoin de PD3, alors pour elle, tout sera le m√™me, ce qui sera clairement visible de l'histoire. <br><br>  Nous allons configurer notre timer 2 en changeant 3 registres: <br><ol><li>  TCCR2A - param√®tres de mode et s√©lection de comportement </li><li>  TCCR2B - param√®tres de mode et diviseur de fr√©quence de minuterie (√©galement bits FOC - nous ne les utilisons pas) </li><li>  OCR2A (OCR2B pour le bo√Ætier de jambe PD3) - valeur du module de comparaison </li></ol><br><br>  Consid√©rons d'abord les registres TCCR2A et TCCR2B <br><img src="https://habrastorage.org/files/37b/def/522/37bdef52208b48b381b06405d9eddcb5.png"><br>  Comme vous pouvez le voir, nous avons 3 groupes de bits qui sont importants pour nous - ce sont des bits des s√©ries COM2xx, WGM2x et CS2x <br>  La premi√®re chose que nous devons changer est WGM2x - c'est la principale chose √† choisir le mode de g√©n√©ration - ces bits sont utilis√©s pour s√©lectionner notre mode CTC. <br><br><img src="https://habrastorage.org/files/f34/28d/3e3/f3428d3e3ecc4e1aafcef3c82b061d23.png"><br>  <i>note: √©videmment en LH la faute de frappe dans "Mise √† jour d'OCR0x √†" devrait √™tre OCR2x</i> <br><br>  C'est-√†-dire  le code sera comme ceci: <br><pre><code class="cpp hljs">TCCR2A = _BV(WGM21) ;</code> </pre> <br>  Comme vous pouvez le voir, TCCR2B n'est pas encore utilis√©.  WGM22 devrait √™tre nul, mais il est d√©j√† nul. <br><br>  L'√©tape suivante consiste √† configurer les bits COM2xx, plus pr√©cis√©ment COM2Ax - car  nous travaillons avec la jambe PB3 (pour PD3 COM2Bx sont utilis√©s de la m√™me mani√®re).  Ce qui va arriver √† notre jambe PB3 d√©pend d'eux. <br><br>  Les bits COM2xx d√©pendent du mode que nous avons s√©lectionn√© avec les bits WGM2x, nous devrons donc trouver la section correspondante dans le LH.  Parce que  nous avons le mode CTC, c'est-√†-dire  pas PWM, alors nous recherchons une plaque "Compare Output Mode, non-PWM", la voici: <br><img src="https://habrastorage.org/files/771/054/3e2/7710543e25404353b1c1056cd3a58483.png"><br>  Ici, vous devez s√©lectionner ¬´Basculer¬ª - de sorte que le niveau sur la jambe change √† l'oppos√© lorsque la minuterie atteint la valeur d√©finie.  Changement de niveau constant et impl√©mente la g√©n√©ration de la fr√©quence dont nous avons besoin. <br><br>  Parce que  les bits COM2xx sont √©galement dans le registre TCCR2A - seulement cela change: <br><pre> <code class="cpp hljs">TCCR2A = _BV(COM2A0) | _BV(WGM21) ;</code> </pre><br>  Naturellement, vous devez √©galement s√©lectionner le diviseur de fr√©quence avec des bits CS2x, et bien s√ªr, r√©gler le pied PB3 sur la sortie ... mais nous ne le ferons pas encore pour que lorsque nous allumons le MK, nous n'obtenions pas un cri per√ßant √† une fr√©quence incompr√©hensible, mais lorsque nous faisons tous les autres r√©glages et tourner le pied pour sortir - sera d√©crit ci-dessous. <br><br>  Alors, apportons notre initialisation √† un look complet: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; //set bit - using bitwise OR operator #define sbi(x,y) x |= _BV(y) //clear bit - using bitwise AND operator #define cbi(x,y) x &amp;= ~(_BV(y)) #define BUZ_PIN PB3 void timer2_buzzer_init() { // PB3 cbi(PORTB, BUZ_PIN); // PB3  ,    cbi(DDRB, BUZ_PIN); //  TCCR2A = _BV(COM2A0) | _BV(WGM21) ; //   (      ) OCR2A = 0; }</span></span></span></span></code> </pre><br>  J'ai utilis√© les macros cbi et sbi (espionn√© quelque part sur le r√©seau) pour d√©finir des bits individuels, et je l'ai laiss√© de cette fa√ßon.  Ces macros, bien s√ªr, ont √©t√© plac√©es dans le fichier d'en-t√™te, mais pour plus de clart√©, je les mets ici. <br><br><h3>  Calcul de la fr√©quence et de la dur√©e des notes </h3><br>  Nous arrivons maintenant √† l'essence m√™me de la question.  Il y a quelque temps, des connaissances de musiciens ont essay√© de transmettre une certaine quantit√© d'informations sur une √©quipe musicale dans le cerveau de mon programmeur, mon cerveau a presque bouilli, mais j'ai quand m√™me apport√© un grain utile de ces conversations. <br>  Je vous pr√©viens tout de suite - d'√©normes inexactitudes sont possibles. <br><ol><li>  chaque mesure se compose de 4 trimestres </li><li>  Chaque m√©lodie a un tempo - c'est-√†-dire  le nombre de ces trimestres par minute </li><li>  Chaque note peut √™tre jou√©e comme une mesure enti√®re, ainsi que sa partie 1/2, 1/3, 1/4, etc. </li><li>  Chaque note, bien s√ªr, a une certaine fr√©quence </li></ol><br>  Nous avons examin√© le cas le plus courant, en fait, tout y est plus compliqu√©, du moins pour moi, donc je ne discuterai pas de ce sujet dans le cadre de cette histoire. <br><br>  Et bien, nous allons travailler avec ce que nous avons.  Le plus important pour nous est d'obtenir √† terme la fr√©quence de la note (en fait, la valeur du registre OCR2A) et sa dur√©e, par exemple, en millisecondes.  En cons√©quence, il est n√©cessaire de faire quelques calculs. <br><br>  Parce que  nous sommes dans le cadre d'un langage de programmation, les m√©lodies sont plus faciles √† stocker dans un tableau.  La fa√ßon la plus logique de d√©finir chaque √©l√©ment du tableau dans le format est note + dur√©e.  Il est n√©cessaire de calculer la taille de l'√©l√©ment en octets, car nous √©crivons sous le microcontr√¥leur et avec les ressources ici, c'est serr√© - cela signifie que la taille de l'√©l√©ment en octets doit √™tre ad√©quate. <br><br><h4>  La fr√©quence </h4><br>  Commen√ßons par la fr√©quence.  Parce que  nous avons le temporisateur 8 bits 2, le registre de comparaison OCR2A est √©galement 8 bits.  Autrement dit, notre √©l√©ment du tableau de m√©lodies sera d√©j√† d'au moins 2 octets, car vous devez encore enregistrer la dur√©e.  En fait, 2 octets est la limite pour ce type d'artisanat.  Nous n'obtenons toujours pas un bon son, c'est un euph√©misme, et d√©penser plus d'octets est d√©raisonnable.  <b>Donc, nous nous sommes arr√™t√©s √† 2 octets.</b> <br><br>  <b>En comptant la fr√©quence, en fait, un autre gros probl√®me appara√Æt.</b> <br>  Si vous regardez les fr√©quences des notes, nous verrons qu'elles sont divis√©es en octaves. <br><img src="https://habrastorage.org/files/240/294/17a/24029417a547408aa6806c9ddf66d593.jpg"><br>  Pour la plupart des m√©lodies simples, 3 octaves suffisent, mais j'ai d√©cid√© d'esquiver et de mettre en ≈ìuvre 6: grandes, petites et les 4 suivantes. <br><br>  Maintenant, nous allons nous √©loigner de la musique et replonger dans le monde de la programmation des microcontr√¥leurs. <br>  Tout temporisateur dans l'AVR (et la grande majorit√© des autres MK) est li√© √† la fr√©quence du MK lui-m√™me.  La fr√©quence du quartz dans mon circuit est de 16Mhz.  La m√™me fr√©quence est d√©termin√©e par le F_CPU "define" pour √™tre √©gale √† 16000000 dans mon cas. Dans le registre TCCR2B, nous pouvons s√©lectionner des diviseurs de fr√©quence afin que notre temporisateur 2 ne "coche" pas √† une vitesse effr√©n√©e de 16000000 fois par seconde, mais un peu plus lentement.  Le diviseur de fr√©quence est s√©lectionn√© par des bits CS2x, comme mentionn√© ci-dessus. <br><br><img src="https://habrastorage.org/files/9bd/ca6/247/9bdca624740e4dd787574c6604291dc3.png"><br>  <i>note: √©videmment dans LH une faute de frappe au lieu de "CA2x" devrait √™tre CS2x</i> <br><br>  La question se pose - comment configurer le diviseur? <br><br>  Pour ce faire, vous devez comprendre comment calculer les valeurs du registre OCR2A.  Et le calculer est assez simple: <br>  <b>OCR2A = F_CPU / (diviseur de fr√©quence √† quartz * 2) / fr√©quence de note</b> <br>  Par exemple, prenez la note AVANT la premi√®re octave et le diviseur 256 (CS22 = 1, CS21 = 1, CS20 = 0): <br>  OCR2A = 16000000 / (256 * 2) / 261 = 119 <br><br>  Je vais vous expliquer tout de suite d'o√π vient la multiplication par 2. Le fait est que nous avons s√©lectionn√© le mode "Toggle" avec les registres COM2Ax, ce qui signifie que le changement de niveau sur le pied de bas en haut (ou vice versa) et inversement se fera en 2 passes de la minuterie: d'abord la minuterie atteint la valeur de OCR2A et change le pied du microcontr√¥leur, par exemple, de 1 √† 0, est r√©initialis√©e et seulement au deuxi√®me tour passe de 0 √† 1. Par cons√©quent, 2 tours de la minuterie vont pour chaque onde pleine, respectivement, le diviseur doit √™tre multipli√© par 2, sinon nous obtenons seulement la moiti√© de la fr√©quence de notre note. <br><br>  D'o√π le malheur pr√©cit√© ... <br><br>  Si on prend la note AVANT la grosse octave et qu'on laisse le diviseur 256: <br>  OCR2A = 16000000 / (256 * 2) / 65 = 480 !!! <br>  <b>480 - ce nombre est clairement sup√©rieur √† 255 et ne rentre pas physiquement dans le registre OCR2A 8 bits.</b> <br><br>  Que faire?  √âvidemment, changer le diviseur, mais si nous mettons le diviseur 1024, alors avec une grande octave, tout ira bien.  Les probl√®mes vont commencer avec les octaves sup√©rieures: <br>  LA 4√®me octave - OCR2A = 16000000 / (1024 * 2) / 3520 = 4 <br>  Une quatri√®me octave nette - OCR2A = 16000000 / (1024 * 2) / 3729 = 4 <br>  <b>Les valeurs OCR2A ne sont plus diff√©rentes, ce qui signifie que le son cessera √©galement d'√™tre diff√©rent.</b> <br><br>  <b>Il n'y a qu'une seule issue: pour la fr√©quence des notes, vous devez stocker non seulement les valeurs du registre OCR2A, mais aussi les bits du diviseur de fr√©quence √† quartz.</b>  <b>Parce que</b>  <b>pour diff√©rentes octaves, il y aura une valeur diff√©rente du diviseur de fr√©quence √† quartz, que nous devrons r√©gler dans le registre TCCR2B!</b> <br><br>  Maintenant, tout se met en place - et j'ai finalement expliqu√© pourquoi nous ne pouvions pas imm√©diatement remplir la valeur du diviseur dans la fonction timer2_buzzer_init (). <br><br>  Malheureusement, le diviseur de fr√©quence est de 3 bits de plus.  Et ils devront √™tre pris dans le deuxi√®me octet de l'√©l√©ment de tableau de m√©lodie. <br><br><div class="spoiler">  <b class="spoiler_title">Vive les macros</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_MASK (_BV(CS20) | _BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_1024 (_BV(CS20) | _BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_256 (_BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_128 (_BV(CS20) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_64 _BV(CS22) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_32 (_BV(CS20) | _BV(CS21)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_1024( x ) ((F_CPU / (1024 * 2) / x) | (DIV_1024 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_256( x ) ((F_CPU / (256 * 2) / x) | (DIV_256 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_128( x ) ((F_CPU / (128 * 2) / x) | (DIV_128 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_64( x ) ((F_CPU / (64 * 2) / x) | (DIV_64 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_32( x ) ((F_CPU / (32 * 2) / x) | (DIV_32 &lt;&lt; 8)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  #define DOB NOTE_1024( 65 ) #define DO_B NOTE_1024( 69 ) #define REB NOTE_1024 ( 73 ) #define RE_B NOTE_1024 ( 78 ) #define MIB NOTE_1024 ( 82 ) #define FAB NOTE_1024 ( 87 ) #define FA_B NOTE_1024 ( 93 ) #define SOLB NOTE_1024 ( 98 ) #define SOL_B NOTE_1024 ( 104 ) #define LAB NOTE_1024 ( 110 ) #define LA_B NOTE_1024 ( 116 ) #define SIB NOTE_1024 ( 123 ) //  #define DOS NOTE_256( 131 ) #define DO_S NOTE_256( 138 ) #define RES NOTE_256 ( 146 ) #define RE_S NOTE_256 ( 155 ) #define MIS NOTE_256 ( 164 ) #define FAS NOTE_256 ( 174 ) #define FA_S NOTE_256 ( 185 ) #define SOLS NOTE_256 ( 196 ) #define SOL_S NOTE_256 ( 207 ) #define LAS NOTE_256 ( 219 ) #define LA_S NOTE_256 ( 233 ) #define SIS NOTE_256 ( 246 ) //  #define DO1 NOTE_256( 261 ) #define DO_1 NOTE_256( 277 ) #define RE1 NOTE_256 ( 293 ) #define RE_1 NOTE_256 ( 310 ) #define MI1 NOTE_256 ( 329 ) #define FA1 NOTE_256 ( 348 ) #define FA_1 NOTE_256 ( 369 ) #define SOL1 NOTE_256 ( 391 ) #define SOL_1 NOTE_256 ( 414 ) #define LA1 NOTE_256 ( 439 ) #define LA_1 NOTE_256 ( 465 ) #define SI1 NOTE_256 ( 493 ) //  #define DO2 NOTE_128( 522 ) #define DO_2 NOTE_128( 553 ) #define RE2 NOTE_128 ( 586 ) #define RE_2 NOTE_128 ( 621 ) #define MI2 NOTE_128 ( 658 ) #define FA2 NOTE_128 ( 697 ) #define FA_2 NOTE_128 ( 738 ) #define SOL2 NOTE_128 ( 782 ) #define SOL_2 NOTE_128 ( 829 ) #define LA2 NOTE_128 ( 878 ) #define LA_2 NOTE_128 ( 930 ) #define SI2 NOTE_128 ( 985 ) //  #define DO3 NOTE_64( 1047 ) #define DO_3 NOTE_64( 1109 ) #define RE3 NOTE_64 ( 1175 ) #define RE_3 NOTE_64 ( 1245 ) #define MI3 NOTE_64 ( 1319 ) #define FA3 NOTE_64 ( 1397 ) #define FA_3 NOTE_64 ( 1480 ) #define SOL3 NOTE_64 ( 1568 ) #define SOL_3 NOTE_64 ( 1661 ) #define LA3 NOTE_64 ( 1760 ) #define LA_3 NOTE_64 ( 1865 ) #define SI3 NOTE_64 ( 1976 ) //  #define DO4 NOTE_32( 2093 ) #define DO_4 NOTE_32( 2217 ) #define RE4 NOTE_32 ( 2349 ) #define RE_4 NOTE_32 ( 2489 ) #define MI4 NOTE_32 ( 2637 ) #define FA4 NOTE_32 ( 2794 ) #define FA_4 NOTE_32 ( 2960 ) #define SOL4 NOTE_32 ( 3136 ) #define SOL_4 NOTE_32 ( 3322 ) #define LA4 NOTE_32 ( 3520 ) #define LA_4 NOTE_32 ( 3729 ) #define SI4 NOTE_32 ( 3951 )</span></span></span></span></code> </pre><br></div></div><br><br>  Et pour la dur√©e de la note, il ne nous reste que 5 bits, calculons donc la dur√©e. <br><br><h4>  La dur√©e </h4><br>  Vous devez d'abord traduire la valeur du tempo en unit√©s temporaires (par exemple, en millisecondes) - je l'ai fait comme ceci: <br>  <b>Dur√©e d'une mesure musicale en ms = (60 000 ms * 4 trimestres) / valeur de tempo.</b> <br><br>  Par cons√©quent, si nous parlons de parties de battement, alors cette valeur doit √™tre divis√©e, et au d√©but, je pensais que le d√©calage gauche habituel pour les diviseurs serait suffisant.  C'est-√†-dire  le code √©tait le suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> calc_note_delay(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> precalced_tempo, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> note) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / _BV((note &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b00111</span></span>)); }</code> </pre> <br><br>  C'est-√†-dire  J'ai utilis√© 3 bits (parmi les 5 restants) et obtenu des parties du rythme musical de degr√©s 2 √† 1/128.  Mais quand j'ai donn√© un ami me demandant d'√©crire une sorte de sonnerie sur mon morceau de fer, il y avait des questions pour lesquelles il n'y a pas 1/3 ou 1/6 et j'ai commenc√© √† penser ... <br><br>  Au final, j'ai cr√©√© un syst√®me d√©licat pour obtenir de telles dur√©es.  Un peu du 2x restant - j'ai pass√© sur le signe de la multiplication par 3 pour le diviseur d'horloge obtenu apr√®s le d√©calage.  Et le dernier bit est d'indiquer s'il est n√©cessaire de soustraire 1. C'est difficile √† d√©crire, il est plus facile de voir le code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> calc_note_delay(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> precalced_tempo, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> note) { note &gt;&gt;= <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> divider = _BV(note &amp; <span class="hljs-number"><span class="hljs-number">0b00111</span></span>); note &gt;&gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; divider *= ((note &amp; <span class="hljs-number"><span class="hljs-number">0b01</span></span>) ? <span class="hljs-number"><span class="hljs-number">3</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); divider -= (note &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / divider); }</code> </pre> <br>  Ensuite, j'ai ¬´d√©fini¬ª toutes les notes possibles (sauf celles qui sont inf√©rieures √† 1/128). <br><div class="spoiler">  <b class="spoiler_title">Les voici</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_MINUS_1 0b10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_MUL_3 0b01000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N2 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N3 (2 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N4 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N5 (1 | DEL_MINUS_1 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N6 (1 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N7 (3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N8 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N11 (2 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N12 (2 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N15 (4 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N16 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N23 (3 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N24 (3 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N31 (5 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N32 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N47 (4 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N48 (4 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N63 (6 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N64 6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N95 (5 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N96 (5 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N127 (7 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N128 7</span></span></code> </pre><br></div></div><br><br><h4>  Tout mettre ensemble </h4><br>  Au total, nous avons le format suivant pour l'√©l√©ment de notre r√©seau de sonneries. <br><br><ul><li>  1bit: diviseur de retard - 1 </li><li>  1bit: diviseur de retard * 3 </li><li>  3 bits: d√©calage du diviseur de retard </li><li>  3bit: diviseur d'horloge cpu </li><li>  8 bits: valeur OCR2A </li></ul><br>  Seulement 16 bits. <br><br>  Cher lecteur, si vous le souhaitez, vous pouvez imaginer le format vous-m√™me, peut-√™tre que quelque chose de plus vaste que le mien na√Ætra. <br><br>  Nous avons oubli√© d'ajouter une note vide, c'est-√†-dire  silence.  Et enfin, j'ai expliqu√© pourquoi au tout d√©but, dans la fonction timer2_buzzer_init (), nous avons sp√©cialement d√©fini la jambe PB3 √† l'entr√©e et non √† la sortie.  En changeant le registre DDRB, nous activerons et d√©sactiverons la lecture du "silence" ou de la composition dans son ensemble.  Parce que  nous ne pouvons pas avoir de notes avec une valeur de 0 - ce sera une note ¬´vide¬ª. <br><br>  D√©finissez les macros manquantes et la fonction pour activer la g√©n√©ration du son: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EMPTY_NOTE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE(delay, note) (uint16_t)((delay </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 11) | note) ........ ........ ........ void play_music_note(uint16_t note) { if (note) { TCCR2B = (note &gt;&gt; 8) &amp; DIV_MASK; OCR2A = note &amp; 0xff; sbi(DDRB, BUZ_PIN); } else cbi(DDRB, BUZ_PIN); }</span></span></span></span></code> </pre><br>  Je vais maintenant vous montrer √† quoi ressemble une sonnerie √©crite selon ce principe: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> king[] PROGMEM = { NOTE(DEL_1N4, MI3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N2, SI3), NOTE(DEL_1N4, LA_3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, LA_3), NOTE(DEL_1N4, EMPTY_NOTE), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, FA3), NOTE(DEL_1N2, LA3), NOTE(DEL_1N4, MI3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, MI4), NOTE(DEL_1N4, RE4), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N2, RE4), NOTE(DEL_1N2, EMPTY_NOTE), };</code> </pre><br><br><h3>  Jouer la sonnerie </h3><br>  Nous avons encore une t√¢che - jouer la m√©lodie.  Pour ce faire, nous devons "parcourir" le r√©seau de sonneries, en tenant compte des pauses appropri√©es et en changeant les fr√©quences des notes.  De toute √©vidence, nous avons besoin d'un autre minuteur, qui, soit dit en passant, peut √™tre utilis√© pour d'autres t√¢ches g√©n√©rales, comme je le fais habituellement.  De plus, vous pouvez basculer entre les √©l√©ments du tableau soit lors de l'interruption de ce temporisateur, soit dans la boucle principale, et utiliser le temporisateur pour calculer l'heure.  Dans cet exemple, j'ai utilis√© la 2e option. <br><br>  Comme vous le savez, le corps de tout programme pour MK comprend une boucle infinie: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-comment"><span class="hljs-comment">//   } return 0; }</span></span></code> </pre><br>  Dans ce document, nous allons ¬´courir¬ª le long de notre r√©seau.  Mais nous avons besoin d'une fonction similaire √† GetTickCount de WinApi, qui renvoie le nombre de millisecondes sur les syst√®mes d'exploitation Windows.  Mais naturellement, dans le monde de MK, il n'y a pas de telles fonctions ¬´pr√™tes √† l'emploi¬ª, nous devons donc les √©crire nous-m√™mes. <br><br><h4>  Minuterie 1 </h4><br>  Pour calculer les intervalles de temps (je n'√©cris pas intentionnellement des millisecondes, vous comprendrez pourquoi plus tard), j'ai utilis√© le temporisateur 1 en conjonction avec le mode CTC d√©j√† connu.  Le temporisateur 1 est un temporisateur de 16 bits, ce qui signifie que la valeur du module de comparaison pour lui est d√©j√† indiqu√©e par 2 registres 8 bits OCR1AH ‚Äã‚Äãet OCR1AL - pour les octets haut et bas, respectivement.  Je ne veux pas d√©crire en d√©tail le travail avec la minuterie 1, car cela ne s'applique pas au sujet principal de ce m√©mo.  Par cons√©quent, je ne vous le dirai qu'en 2 mots. <br><br>  Nous avons en fait besoin de 3 fonctions: <br><ul><li>  Initialisation de la minuterie </li><li>  Gestionnaire d'interruption de minuterie </li><li>  fonction qui renvoie le nombre d'intervalles de temps. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Fichier de code C</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;util/atomic.h&gt; #include "timer1_ticks.h" volatile unsigned long timer1_ticks; //  ISR (TIMER1_COMPA_vect) { timer1_ticks++; } void timer1_ticks_init() { //   // CTC ,     8 TCCR1B |= (1 &lt;&lt; WGM12) | (1 &lt;&lt; CS11); //     OCR1AH = (uint8_t)(CTC_MATCH_OVERFLOW &gt;&gt; 8); OCR1AL = (uint8_t) CTC_MATCH_OVERFLOW; //    TIMSK1 |= (1 &lt;&lt; OCIE1A); } unsigned long ticks() { unsigned long ticks_return; //  ,   ticks_return   //     ATOMIC_BLOCK(ATOMIC_FORCEON) { ticks_return = timer1_ticks; } return ticks_return; }</span></span></span></span></code> </pre><br></div></div><br><br>  Avant d'afficher le fichier d'en-t√™te avec une certaine constante CTC_MATCH_OVERFLOW, nous devons remonter le temps dans la <b>section "Dur√©e"</b> et d√©terminer la macro la plus importante pour la m√©lodie, qui calcule le tempo de la m√©lodie.  J'ai attendu longtemps pour le d√©terminer, car il est directement connect√© au lecteur, et donc au timer 1. <br>  En premi√®re approximation, cela ressemblait √† cela (voir calculs dans la section "Dur√©e"): <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEMPO( x ) (60000 * 4 / x)</span></span></code> </pre><br>  La valeur que nous obtenons √† la sortie, nous devons par la suite substituer le premier argument dans la fonction <b>calc_note_delay</b> .  Examinez maintenant de pr√®s la fonction calc_note_delay, √† savoir la ligne: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / divider);</code> </pre><br>  On voit que la valeur obtenue en calculant la macro TEMPO est divis√©e par un certain diviseur.  Rappelons que le diviseur maximum que nous avons d√©fini est <b>DEL_1N128</b> , c'est-√†-dire  le diviseur sera 128. <br><br>  Prenons maintenant la valeur de tempo commune √©gale √† 240 et faisons quelques calculs simples: <br>  <b>60000 * 4/240 = 1000</b> <br>  Oh horreur!  Nous n'avons eu que 1000, puisque cette valeur sera toujours divis√©e par 128, nous courons le risque de glisser √† 0, √† des taux √©lev√©s.  <b>Il s'agit du deuxi√®me probl√®me de dur√©e.</b> <br><br>  Comment le r√©soudre?  De toute √©vidence, afin d'√©largir la plage de valeurs de tempo, nous devons en quelque sorte augmenter le nombre obtenu en calculant la macro TEMPO.  Cela ne peut se faire que d'une seule mani√®re: s'√©loigner des millisecondes et compter le temps √† certains intervalles de temps.  Vous comprenez maintenant pourquoi pendant tout ce temps, j'ai √©vit√© de mentionner ¬´millisecondes¬ª dans l'histoire.  D√©finissons une autre macro: <br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MS_DIVIDER 4</span></span></code> </pre> <br>  Que ce soit notre diviseur de la milliseconde - divisez la milliseconde, par exemple, par 4 (250 Œºs). <br>  Ensuite, vous devez modifier la macro TEMPO: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEMPO( x ) (60000 * MS_DIVIDER * 4 / x)</span></span></code> </pre> <br><br>  Maintenant, avec une conscience claire, je vais donner le fichier d'en-t√™te pour travailler avec le temporisateur 1: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> TIMER1_TICKS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER1_TICKS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MS_DIVIDER 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTC_MATCH_OVERFLOW ((F_CPU / 1000) / (8 * MS_DIVIDER)) void timer1_ticks_init(); unsigned long ticks(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// TIMER1_TICKS_H_INCLUDED</span></span></span></span></code> </pre> <br>  Maintenant, nous pouvons, en changeant MS_DIVIDER, ajuster la plage de nos t√¢ches - j'en ai 4 dans mon code - c'√©tait suffisant pour mes t√¢ches.  <b>Attention: si vous avez encore des t√¢ches ¬´li√©es¬ª au temporisateur 1, n'oubliez pas de multiplier / diviser les valeurs de contr√¥le de temps pour elles par MS_DIVIDER.</b> <br><br><h4>  Plateau tournant </h4><br>  √âcrivons maintenant notre lecteur.  Je pense que tout sera clair d'apr√®s le code et les commentaires. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ timer1_ticks_init(); <span class="hljs-comment"><span class="hljs-comment">//   sei(); timer2_buzzer_init(); //    MS_DIVIDER long time_since = ticks(); //       MS_DIVIDER uint16_t note_delay = 0; //     uint16_t note_pos = 0; //  uint16_t length = sizeof(king) / sizeof(king[0]); //     uint16_t tempo = TEMPO(240); for(;;) { unsigned long time_current = ticks(); if (time_current - time_since &gt; note_delay) { //   uint16_t note = pgm_read_word(&amp;king[note_pos]); //   play_music_note(note); //    note_delay = calc_note_delay(tempo, note); //  if (++note_pos &gt;= length) note_pos = 0; time_since = time_current; } } return 0; }</span></span></code> </pre><br><br><h3>  Conclusion </h3><br>  J'esp√®re que ce m√©mo sera utile √† un lecteur respect√© et √† moi-m√™me, afin de ne pas oublier toutes les nuances de jouer des morceaux, au cas o√π je reprendrais les microcontr√¥leurs AVR. <br><br>  Eh bien, traditionnellement, la vid√©o et le code source (je l'ai d√©velopp√© dans l'environnement Code Blocks, alors n'ayez pas peur des fichiers obscurs): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/j60UCr2q0Ak" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr402329/">https://habr.com/ru/post/fr402329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr402319/index.html">Jagiellonian University d√©veloppe une application de formation √† l'aide des capacit√©s d'IBM Watson</a></li>
<li><a href="../fr402321/index.html">Revue Livall: un casque intelligent avec un contr√¥leur, un microphone et une application native</a></li>
<li><a href="../fr402323/index.html">"Aussi travailler": l'art d'√©couter de la musique</a></li>
<li><a href="../fr402325/index.html">"Monde mince." Chapitre 7</a></li>
<li><a href="../fr402327/index.html">WayRay annonce un partenariat strat√©gique avec Banma Technologies avec le soutien aux investissements du groupe Alibaba</a></li>
<li><a href="../fr402345/index.html">Donn√©es sur la diversit√© des esp√®ces</a></li>
<li><a href="../fr402347/index.html">Une s√©lection d'√©couteurs de sport jusqu'√† 2500 roubles</a></li>
<li><a href="../fr402351/index.html">Internet dans le monde: Japon et Singapour</a></li>
<li><a href="../fr402355/index.html">√âchecs quantiques</a></li>
<li><a href="../fr402357/index.html">Puis-je remplacer Adobe Premiere et Sony Vegas par des √©diteurs vid√©o gratuits?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>