<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✴️ 👩🏼‍🔧 💝 Standards für das Datenbankdesign 🎆 🖨️ 🦋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auf dem Weg von Projekt zu Projekt sehen wir uns leider mit dem Mangel an einheitlichen Standards für das Datenbankdesign konfrontiert, obwohl es SQL ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Standards für das Datenbankdesign</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/484188/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pa/zj/ej/pazjejv8zvpor7tzaggxr54csd4.jpeg"></div><br>  Auf dem Weg von Projekt zu Projekt sehen wir uns leider mit dem Mangel an einheitlichen Standards für das Datenbankdesign konfrontiert, obwohl es SQL schon seit mehreren Jahrzehnten gibt.  Ich vermute, der Grund liegt zum Teil daran, dass die meisten Entwickler die Architektur der Datenbank nicht verstehen.  Während meiner jahrelangen Arbeit bei der Einstellung von Entwicklern habe ich nur einige Male getroffen, die die Datenbank korrekt normalisieren konnten.  Ehrlich gesagt kann dies eine schwierige Aufgabe sein, aber viele der von mir befragten Entwickler, die sogar SQL fließend beherrschen, verfügten nicht über Kenntnisse im Datenbankdesign. <br><br>  In diesem Artikel geht es nicht um die DB-Normalisierung.  Wenn du das lernen willst, <a href="https://youtu.be/y1tcbhWLiUM">habe</a> ich dir <a href="https://youtu.be/y1tcbhWLiUM">hier</a> kurz die Grundlagen erklärt. <br><br>  Wenn Sie über eine funktionierende Datenbank verfügen, müssen Sie die Frage beantworten: „Welche Standards können angewendet werden, um die <i>Verwendung</i> dieser Datenbank zu erleichtern?“.  Wenn diese Standards weit verbreitet sind, können Sie die Datenbank problemlos verwenden, da Sie nicht jedes Mal, wenn Sie mit einer neuen Datenbank arbeiten, neue Standardsätze studieren und sich diese merken müssen. <br><a name="habracut"></a><br><h1>  CamelCase-Benennung oder Unterstreichung? </h1><br>  Ich stoße ständig auf Datenbanken, in denen Tabellen im Stil von <code>CustomerOrders</code> oder <code>customer_orders</code> .  Was ist besser zu benutzen?  Vielleicht möchten Sie einen bereits etablierten Standard anwenden, aber wenn Sie eine neue Datenbank erstellen, empfehle ich die Verwendung von Unterstrichen, um die Barrierefreiheit zu erhöhen.  Der Ausdruck "unter Wert" hat eine andere Bedeutung als "unter Wert", aber mit einem Unterstrich ist der erste immer unter <code>under_value</code> und der zweite unter <code>undervalue</code> .  Bei Verwendung von CamelCase erhalten wir <code>UnderValue</code> und <code>UnderValue</code> , die in Bezug auf SQL, bei dem die <code>UnderValue</code> und <code>UnderValue</code> , identisch sind.  Wenn Sie außerdem Sehprobleme haben und ständig mit Kopfhörern und Stiften experimentieren, um Wörter hervorzuheben, ist das Unterstreichen <i>viel</i> einfacher zu lesen. <br><br>  Schließlich ist CamelCase schwer zu lesen für diejenigen, für die Englisch nicht muttersprachlich ist. <br>  Zusammenfassend ist dies keine strenge Empfehlung, sondern eine persönliche Präferenz. <br><br><h1>  Plural oder Singular in Tabellennamen? </h1><br>  Experten der Datenbanktheorie haben lange darüber gestritten, ob Tabellen Singular (Kunde) oder Plural (Kunde) sein sollten.  Lassen Sie mich diesen gordischen Knoten durchtrennen, ohne näher auf die Theorie einzugehen, und zwar einfach mit Hilfe des Pragmatismus: Pluralisierte Tabellennamen widersprechen weniger häufig reservierten Schlüsselwörtern. <br><br>  Haben Sie Benutzer - <code>users</code> ?  SQL hat das <code>user</code> .  Benötigen Sie eine Einschränkungstabelle?  <code>constraint</code> ist ein reserviertes Wort.  Das Wort <code>audit</code> <br>  reserviert, aber brauchen Sie eine <code>audit</code> Tabelle?  Verwenden Sie einfach die <i>Pluralform</i> von Nomen, und die meisten reservierten Wörter werden Sie in SQL nicht stören.  Sogar PostgreSQL, das einen ausgezeichneten SQL-Parser hat, ist auf dem <code>user</code> gestolpert. <br><br>  Verwenden Sie einfach den Plural, und die Wahrscheinlichkeit von Konflikten wird viel geringer sein. <br><br><h1>  Benennen Sie die Spalte mit der ID nicht als "id" </h1><br>  Ich selbst habe im Laufe der Jahre gesündigt.  Einmal habe ich mit einem Kunden in Paris gearbeitet, und der DBA hat sich über mich beschwert, als ich der Spalte <code>id</code> den Namen <code>id</code> .  Ich dachte, er sei nur ein Pedant.  Der Spaltenname <code>customers.id</code> ist eindeutig und <code>customers.customer_id</code> ist eine Wiederholung von Informationen. <br><br>  Und später musste ich das debuggen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thread.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> email <span class="hljs-keyword"><span class="hljs-keyword">thread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> email selected <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> selected.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> recipient <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> recipient.id = thread.recipient_id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station_area sa <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> sa.id = recipient.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station st <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> st.id = sa.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star origin <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> origin.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star destination <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> destination.id = st.id <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ( route.from_id = origin.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> route.to_id = destination.id ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> selected.id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( thread.sender_id = ? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( thread.recipient_id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( origin.id = destination.id <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( route.distance <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() &gt;= thread.datesent + ( route.distance * <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-string"><span class="hljs-string">'30 seconds'</span></span> ) )))) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> datesent <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, thread.parent_id <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span></code> </pre> <br>  Beachten Sie das Problem?  Wenn SQL vollständige ID-Namen wie <code>email_id</code> , <code>star_id</code> oder <code>station_id</code> , werden die Fehler sofort <code>station_id</code> , <i>wenn ich diesen Code</i> <code>station_id</code> , und nicht später, wenn ich zu verstehen versuchte, was ich falsch gemacht habe. <br><br>  Tun Sie sich selbst einen Gefallen und verwenden Sie die vollständigen Namen für die ID.  Danke später <br><br><h1>  Spaltennamen </h1><br>  Geben Sie den Spalten so aussagekräftige Namen wie möglich.  Nehmen wir an, die <code>temperature</code> hat nichts damit zu tun: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> temperature &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br>  Ich lebe in Frankreich und für uns wird eine Temperatur von 32 Grad „zu kalt“ sein.  Daher ist es besser, die Spalte <code>fahrenheit</code> zu benennen. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fahrenheit &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br>  Jetzt ist alles völlig klar. <br><br>  Wenn Sie Einschränkungen für Fremdschlüssel haben, geben Sie den Spalten auf beiden Seiten der Einschränkung nach Möglichkeit den gleichen Namen.  Hier ist ein perfekt durchdachtes, vernünftiges SQL: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.owner = s.person_id;</code> </pre> <br>  Dieser Code ist wirklich in Ordnung.  Wenn Sie sich jedoch die Tabellendefinition ansehen, werden Sie <code>some_other_table.owner</code> dass <code>some_other_table.owner</code> eine Fremdschlüsseleinschränkung für <code>companies.company_id</code> .  Im Grunde genommen ist diese SQL also falsch.  Es mussten identische Namen verwendet werden: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.company_id = s.person_id;</code> </pre> <br>  Jetzt ist sofort klar, dass wir einen Fehler haben. Sie müssen nur eine Codezeile überprüfen und müssen nicht auf die Tabellendefinition verweisen. <br><br>  Ich möchte jedoch darauf hinweisen, dass dies nicht immer möglich ist.  Wenn Sie eine Tabelle mit einem Quell-Warehouse und einem Ziel haben, möchten Sie möglicherweise <code>source_id</code> mit <code>destination_id</code> <code>source_id</code> mit <code>warehouse_id</code> <code>source_id</code> vergleichen.  In diesem Fall ist es besser, die Namen <code>source_warehouse_id</code> und <code>destination_warehouse_id</code> <code>source_warehouse_id</code> . <br><br>  Beachten Sie auch, dass der <code>owner</code> im obigen Beispiel den Zweck besser beschreibt als <code>company_id</code> .  Wenn Ihnen dies verwirrend erscheint, können Sie die Spalte <code>owning_company_id</code> .  Der Name gibt dann den Zweck der Spalte an. <br><br><h1>  Vermeiden Sie Nullwerte </h1><br>  Dieser Rat ist vielen erfahrenen Datenbankentwicklern bekannt, aber sie sprechen leider nicht oft genug darüber: Lassen Sie aus keinem guten Grund NULL-Werte in der Datenbank zu. <br>  Dies ist ein wichtiges, aber ziemlich kompliziertes Thema.  Wir diskutieren zuerst die Theorie und dann ihre Auswirkungen auf die Architektur der Datenbank und analysieren abschließend ein praktisches Beispiel für schwerwiegende Probleme, die durch das Vorhandensein von NULL-Werten verursacht werden. <br><br><h2>  Arten von Datenbanken </h2><br>  Die Datenbank kann Daten verschiedener <i>Typen enthalten</i> : INTEGER, JSON, DATETIME usw. Der Typ ist der Spalte zugeordnet, und jeder Wert, der hinzugefügt wird, muss diesem Typ entsprechen. <br><br>  Aber was ist ein Typ?  Dies ist ein Name, eine Reihe gültiger Werte und eine Reihe gültiger Operationen.  Sie helfen uns, unerwünschtes Verhalten zu vermeiden.  Was passiert beispielsweise in Java, wenn Sie versuchen, eine Zeichenfolge und eine Zahl zu vergleichen? <br><br><pre> <code class="sql hljs">CustomerAccount.java:5: error: bad operand types for binary operator '&gt;' if ( current &gt; threshold ) { ^ first type: String second type: int</code> </pre> <br>  Auch wenn Sie nicht bemerken, dass <code>current &gt; threshold</code> unvergleichbare Typen vergleicht, wird der Compiler dies für Sie abfangen. <br><br>  Ironischerweise funktionieren die Datenbanken, in denen Ihre Daten gespeichert sind - und die Ihre letzte Verteidigungslinie gegen Datenkorruption sind - fürchterlich mit Typen!  Einfach nur ekelhaft.  Wenn Ihre <code>customers</code> beispielsweise einen Ersatzschlüssel enthält, können Sie Folgendes tun: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, birthdate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> customer_id &gt; weight;</code> </pre> <br>  Das macht natürlich keinen Sinn und in Wirklichkeit werden Sie einen Kompilierungsfehler bekommen.  Viele Programmiersprachen erleichtern das Abfangen solcher Typfehler, bei Datenbanken ist das Gegenteil der Fall. <br><br>  Dies ist eine normale Situation in der Datenbankwelt, wahrscheinlich weil der <a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">erste SQL-Standard 1992 veröffentlicht wurde</a> .  Computer waren in jenen Jahren langsam, und alles, was die Implementierung komplizierte, verlangsamte zweifellos die Datenbanken. <br><br>  Und dann erscheinen NULL-Werte in der Szene.  Der SQL-Standard hat sie nur an einer Stelle korrekt implementiert, in den <code>IS NOT NULL</code> <code>IS NULL</code> und <code>IS NOT NULL</code> .  Da der NULL-Wert per Definition unbekannt ist, können keine Operatoren dafür entworfen werden.  Und so gibt es <code>IS NULL</code> und <code>IS NOT NULL</code> anstelle von <code>= NULL</code> und <code>!= NULL</code> .  Und jeder Vergleich von NULL-Werten führt dazu, dass ein neuer NULL-Wert angezeigt wird. <br><br>  Wenn dies für Sie seltsam klingt, ist es viel einfacher, wenn Sie "unknown" anstelle von NULL schreiben: <br><br><blockquote>  Der Vergleich von <s>NULL</s> unbekannten Werten führt zu <s>NULL</s> unbekannten Werten. </blockquote><br>  Ja, jetzt verstehe ich! <br><br><h2>  Was bedeutet ein Nullwert? </h2><br>  Ausgerüstet mit den Krümeln der Theorie betrachten wir ihre praktischen Konsequenzen. <br><br>  Sie müssen einen Bonus von 500 US-Dollar an alle Mitarbeiter zahlen, deren Jahresgehalt mehr als 50.000 US-Dollar betrug. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> employee_number, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> salary &gt; <span class="hljs-number"><span class="hljs-number">50000</span></span>;</code> </pre> <br>  Und Sie wurden gerade entlassen, weil Ihr Chef mehr als 50.000 US-Dollar verdient hat, sein Gehalt jedoch nicht in der Datenbank (in der Spalte <code>employees.salary</code> ist NULL) vorhanden ist und der Vergleichsoperator NULL nicht mit 50.000 vergleichen kann. <br><br>  Warum ist in dieser Spalte NULL?  Vielleicht ist das Gehalt vertraulich.  Vielleicht ist die Information noch nicht angekommen.  Vielleicht ist dies ein Berater und wird nicht bezahlt.  Vielleicht hat er einen Stundenlohn, kein Gehalt.  Es gibt <i>viele</i> Gründe, warum Daten fehlen können. <br><br>  Das Vorhandensein oder Fehlen von Informationen in der Spalte lässt darauf schließen, dass dies von etwas <i>anderem</i> abhängt und nicht von der Denormalisierung des Primärschlüssels und der Datenbank.  Daher sind Spalten, in denen möglicherweise NULL-Werte vorhanden sind, gute Kandidaten für die Erstellung neuer Tabellen.  In diesem Fall haben Sie möglicherweise <code></code> , <code>_</code> , <code>__</code> usw. Sie werden immer noch entlassen, weil Sie die Gehälter blind kombiniert haben und Ihr Chef keine hat.  Aber dann fängt Ihre Basis an, Sie mit genügend Informationen zu versorgen, um darauf hinzuweisen, dass das Problem mehr als eine Gehaltsfrage ist. <br><br>  Und ja, es war ein dummes Beispiel, aber es war der letzte Strohhalm. <br><br><h2>  NULL-Werte führen zu logisch unmöglichen Situationen </h2><br>  Es mag Ihnen so vorkommen, als ob ich in Bezug auf NULL-Werte pedantisch bin.  Schauen wir uns jedoch ein anderes Beispiel an, das der Realität viel näher kommt. <br><br>  Vor einigen Jahren arbeitete ich in London für einen Domain-Registrar und versuchte zu verstehen, warum eine 80-zeilige SQL-Abfrage falsche Daten zurückgibt.  In dieser Situation hätten Informationen definitiv zurückgegeben werden müssen, aber dies ist nicht geschehen.  Ich schäme mich zuzugeben, aber ich brauchte einen Tag, um zu verstehen, dass der Grund eine solche Kombination von Bedingungen war: <br><br><ul><li>  Ich habe OUTER JOIN verwendet. <br></li><li>  Sie könnten leicht NULL-Werte erzeugen. <br></li><li>  NULL-Werte können dazu führen, dass SQL eine falsche Antwort gibt. <br></li></ul><br>  Viele Entwickler kennen den letzteren Aspekt nicht. Schauen wir uns ein Beispiel aus dem Buch <a href="https://www.amazon.com/Database-Depth-Relational-Theory-Practitioners/dp/0596100124/">Database In Depth an</a> .  Ein einfaches Diagramm zweier Tabellen: <br><br> <code>suppliers</code> <br> <div class="scrollable-table"><table><tbody><tr><td>  supplier_id <br></td><td>  Stadt <br></td></tr><tr><td>  s1 <br></td><td>  London <br></td></tr></tbody></table></div><br> <code>parts</code> <br> <br><div class="scrollable-table"><table><tbody><tr><td>  part_id <br></td><td>  Stadt <br></td></tr><tr><td>  p1 <br></td><td>  Null <br></td></tr></tbody></table></div><br>  Es ist schwierig, ein einfacheres Beispiel zu finden. <br><br>  Dieser Code gibt <code>p1</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts;</code> </pre> <br>  Was wird dieser Code tun? <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> city = city;</code> </pre> <br>  Es wird nichts zurückgegeben, da Sie einen NULL-Wert auch nicht mit einem anderen NULL-Wert oder demselben NULL-Wert vergleichen können.  Es sieht komisch aus, weil die Stadt in jeder Zeile gleich sein sollte, auch wenn wir es nicht wissen, oder?  Was gibt dann den folgenden Code zurück?  Versuchen Sie dies zu verstehen, bevor Sie weiterlesen. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s.supplier_id, p.part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> suppliers s, parts p <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.city &lt;&gt; s.city <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> p.city &lt;&gt; <span class="hljs-string"><span class="hljs-string">'Paris'</span></span>;</code> </pre> <br>  Wir haben keine Zeichenfolge als Antwort erhalten, da wir die Stadt <code>NULL</code> ( <code>p.city</code> ) nicht vergleichen können und daher keiner der Zweige der <code>WHERE</code> zu <code>true</code> . <br><br>  Wir wissen jedoch, dass die unbekannte Stadt entweder Paris oder nicht Paris ist.  Wenn es Paris ist, ist die erste Bedingung erfüllt ( <code>&lt;&gt; 'London'</code> ).  Wenn es nicht Paris ist, ist die zweite Bedingung erfüllt ( <code>&lt;&gt; 'Paris'</code> ).  Daher muss die <code>WHERE</code> <code>true</code> , dies ist jedoch nicht der <code>true</code> Infolgedessen generiert SQL ein logisch unmögliches Ergebnis. <br><br>  Es war ein Fehler, auf den ich in London gestoßen bin.  Jedes Mal, wenn Sie SQL schreiben, das NULL-Werte generieren oder enthalten kann, besteht die Gefahr, dass Sie ein falsches Ergebnis erhalten.  Dies kommt selten vor, ist aber sehr schwer zu identifizieren. <br><br><h1>  Zusammenfassung </h1><br><ul><li>  Verwenden Sie <code>__</code> anstelle von <code>CamelCase</code> . <br></li><li>  Tabellennamen müssen im Plural sein. <br></li><li>  Geben Sie erweiterte Namen für Felder mit Bezeichnern an ( <code>item_id</code> anstelle von <code>id</code> ). <br></li><li>  Vermeiden Sie mehrdeutige Spaltennamen. <br></li><li>  Benennen Sie die Spalten mit Fremdschlüsseln nach Möglichkeit genauso wie die Spalten, auf die sie sich beziehen. <br></li><li>  Fügen Sie nach Möglichkeit allen Spaltendefinitionen NOT NULL hinzu. <br></li><li>  Vermeiden Sie nach Möglichkeit das Schreiben von SQL, das NULL-Werte generieren kann. <br></li></ul><br>  Obwohl nicht perfekt, wird dieser Datenbank-Designleitfaden Ihr Leben einfacher machen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484188/">https://habr.com/ru/post/de484188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484176/index.html">Implementieren der Statusvorlage in Unity</a></li>
<li><a href="../de484178/index.html">Intelligenter Ethernet-Switch für Planet Earth</a></li>
<li><a href="../de484180/index.html">Virtuelle Telefonanlage von Rostelecom: Was und wie kann über die API geschehen?</a></li>
<li><a href="../de484182/index.html">Xenobots: Lebende Nanoroboter aus Froschzellen</a></li>
<li><a href="../de484186/index.html">LDAP - "Authentifizierung" ist ein Antipattern</a></li>
<li><a href="../de484192/index.html">Einfache und leicht zu implementierende Anwendungen auf Tarantool Cartridge (Teil 2)</a></li>
<li><a href="../de484194/index.html">Kubernetes übersetzt in Kinder</a></li>
<li><a href="../de484196/index.html">Aufnahme von JS-Ton über ein Mikrofon oder Sprachkommentare</a></li>
<li><a href="../de484198/index.html">Rückseite der Medaille: Wer hat beim Wachstum der Tesla-Aktien gewonnen und verloren?</a></li>
<li><a href="../de484200/index.html">Wie man Ziele setzt, um sie zu erreichen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>