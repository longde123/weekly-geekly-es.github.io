<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾 👈 🌏 L'avenir de WebAssembly comme «arbre de compétences» 🐮 😘 💤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Certaines personnes ont mal compris WebAssembly. Il y a ceux qui croient que puisque les navigateurs prennent déjà en charge WebAssembly (depuis 2017)...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'avenir de WebAssembly comme «arbre de compétences»</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/428347/">  Certaines personnes ont mal compris WebAssembly.  Il y a ceux qui croient que puisque les navigateurs prennent déjà en charge WebAssembly (depuis 2017), alors tout est prêt.  Pas encore proche, seul le MVP (produit minimalement viable) est prêt.  Je peux deviner d'où vient la racine de cette erreur: après la sortie de MVP, ses développeurs ont promis de maintenir la compatibilité descendante au niveau de «tout code écrit maintenant fonctionnera à l'avenir».  Mais cela ne signifie pas que le développement de WebAssembly est terminé, pas du tout!  De nombreuses fonctionnalités sont en cours de développement et devraient être développées dans un avenir proche.  Et quand ils seront mis en œuvre, tout changera beaucoup. <br><br>  Vous pouvez essayer d'imaginer toutes ces fonctionnalités sous la forme d'un arbre de compétences dans certains jeux.  Nous avons quelques "basiques" (fonctionnalités déjà implémentées) et un arbre entier avec de nombreuses branches et feuilles qui s'ouvriront avec le temps, nous donnant de plus en plus de puissance. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c6f/7a8/30f/c6f7a830f86adac22fb26212840d79e6.png" alt="image"></a> <br>  Voyons ce que nous avons déjà et ce qu'il nous reste à découvrir. <br>  ( <b>Sous la coupe beaucoup d'images, le trafic</b> ) <br><a name="habracut"></a><br><h2>  Produit minimum viable (MVP) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e24/fc2/578/e24fc257831cdd6a1e1ff997eb6e31a4.png" alt="image"><br>  Au tout début de l'histoire de WebAssembly se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Emscripten</a> , qui a permis de compiler du code C ++ en code JavaScript.  Cela nous a permis de transférer un grand nombre de bibliothèques C ++ dans le monde du Web, sans lesquelles il serait impossible d'exécuter du code de niveau supérieur.  Le code JS généré était loin d'être idéal et fonctionnait lentement (par rapport à sa version native).  Mais tout de même, les ingénieurs de Mozilla ont trouvé deux façons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de l'</a> accélérer.  Le principal était l'allocation d'un sous-ensemble du langage qui pouvait être exécuté à des vitesses comparables aux vitesses d'exécution de code natif.  Ce sous-ensemble a été appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">asm.js.</a> <br><br>  Les développeurs d'autres navigateurs ont remarqué et apprécié la vitesse de asm.js, tous les principaux navigateurs ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">obtenu</a> son soutien.  Mais cela n'a pas mis fin à l'histoire.  Ce n'était que le début.  Il y avait encore de la place pour travailler plus vite.  Mais ils dépassaient déjà Javascript.  Il s'est avéré que le code natif (par exemple, en C ++) devait être compilé non pas en Javascript, mais dans autre chose.  En quelque chose de nouveau, créé spécifiquement comme une alternative rapide à JS.  Et c'est ainsi que WebAssembly a vu le jour. <br><br>  Qu'est-ce qui est inclus dans la première version de WebAssembly?  Qu'est-ce qui a suffi pour obtenir le fier titre de «produit minimum viable»? <br><br><h3>  Compétence: plateforme de compilation cible </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/363/557/8a43635574df19b6115ac43061f809ab.png" alt="image"><br><br>  Les programmeurs qui ont travaillé sur WebAssembly ont compris que leur tâche n'était pas de prendre en charge uniquement C ou C ++.  La tâche consistait à donner la possibilité de compiler du code dans n'importe quelle langue dans WebAssembly.  Il devait s'agir d'un tel «assembleur», qui devait être exécuté dans le navigateur, tout comme le code machine de l'application de bureau est exécuté, par exemple, sur la plate-forme x86.  Mais ce nouveau langage ne devrait s'appuyer sur aucune plateforme spécifique, son objectif devrait être une plateforme abstraite d'un niveau supérieur, dont la mise en œuvre spécifique dépendrait déjà de l'ensemble des instructions utilisées sur ce matériel. <br><br><h3>  Compétence: exécution rapide de code </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/1de/2ef/f15/1de2eff156f50e2791dee8b2fbf6c794.png" alt="image"><br><br>  Tout devait fonctionner rapidement.  Sinon, pourquoi s'embêter avec toute cette histoire?  En fin de compte, l'utilisateur devrait être en mesure d'exécuter des applications vraiment «lourdes», de pouvoir jouer aux meilleurs jeux dans le navigateur, etc. <br><br><h3>  Compétence: Compacité </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/38c/906/a9f38c9069761e4e6c5619641b159399.png" alt="image"><br><br>  Il est important non seulement la vitesse d'exécution du code, mais aussi la vitesse de son chargement.  Les utilisateurs sont habitués aux applications de bureau qui se lancent très rapidement (car elles sont installées localement et disposent de toutes les ressources nécessaires).  Les applications Web s'exécutent également relativement rapidement car elles ne chargent pas autant de ressources à la fois.  Et cela pose un nouveau défi pour nous: si nous voulons créer un nouveau type d'application Web avec une base de code aussi grande que celle de bureau classique, mais téléchargeable sur Internet, le code doit être aussi compact que possible. <br><br><h3>  Compétence: accès à la mémoire </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/350/e55/239/350e55239fe24dc00799045dce0bb36e.png" alt="image"><br><br>  Nos nouvelles applications devront également travailler avec la mémoire d'une manière légèrement différente de celle du code JavaScript.  Besoin d'un accès direct aux blocs de mémoire.  Cela est dû à la particularité des langages C et C ++, dans lesquels il existe des pointeurs.  Un pointeur est, en gros, une variable qui contient une adresse en mémoire.  Une application peut lire des données à cette adresse, les modifier et même utiliser l'arithmétique vers un pointeur pour «avancer» en mémoire à partir de l'adresse spécifiée.  Une énorme quantité de code C / C ++ utilise des pointeurs pour augmenter l'efficacité de son travail, la création d'une plate-forme cible pour un tel code est impossible sans le support des pointeurs. <br><br>  Mais nous ne pouvons permettre à aucun morceau de code téléchargé sur Internet d'avoir un accès direct à la mémoire de notre processus - c'est trop dangereux.  Nous devrons créer un environnement qui, d'une part, permet au code natif compilé dans WebAssembly de croire qu'il a un accès direct à la mémoire, mais d'autre part, cela limitera strictement la zone dans laquelle il est autorisé à manipuler des données. <br><br>  Pour cela, WebAssembly utilise le «modèle de mémoire linéaire».  Ceci est implémenté à l'aide de TypedArrays - quelque chose comme un tableau en JavaScript, mais ne contenant qu'un ensemble séquentiel d'octets en mémoire.  Lorsque vous voulez y mettre quelque chose, vous utilisez l'accès à l'élément par index (qui peut être une adresse en mémoire).  Ainsi, ce tableau «prétend» être un bloc de mémoire pour le code C ++. <br><br><h3>  Nouvelle réalisation! </h3><br>  Ainsi, avec tout ce qui précède, les gens pourront enfin exécuter l'application de bureau dans un navigateur avec environ les mêmes performances que si elle était native.  C'est à propos de cet ensemble de fonctionnalités et a été appelé le "produit minimum viable" (MVP). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a9/c6e/ac9/3a9c6eac96976ad0cd5c5893b47e9ccc.png" alt="image"><br><br>  À ce stade, certaines applications pourraient en effet déjà être créées sous WebAssembly et gagner de l'argent dans le navigateur.  Mais il y avait encore un long chemin à parcourir. <br><br><h2>  Applications de bureau lourdes </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/393/bfe/b91/393bfeb91e6a174d57e9a8896fd2f912.png" alt="image"><br><br>  La prochaine étape importante devrait être la possibilité de lancer de très grandes applications de bureau.  Pouvez-vous imaginer la version complète de Photoshop fonctionnant dans un navigateur?  Et vous ne l'avez pas installé, juste ouvert le lien - et maintenant vous avez toute la puissance de 100% de ce produit, à vitesse native, la dernière version avec toutes les mises à jour et correctifs, sur n'importe quel appareil. <br><br>  Et nous n'en sommes pas si loin - des exemples commencent déjà à apparaître.  Par exemple, AutoCAD.  Et aussi Adobe Lightroom.  Mais soyons honnêtes - tout n'est pas prêt dans l'implémentation actuelle de WebAssembly pour lancer des applications vraiment volumineuses.  Les goulots d'étranglement sont étudiés et corrigés ici même au moment où vous lisez cet article. <br><br><h3>  Compétence: multithreading </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7c2/779/cac/7c2779cac9e06ed2a7ea21469efcb54e.png" alt="image"><br><br>  De toute évidence, nous avons besoin du multithreading.  Les ordinateurs modernes ont de nombreux cœurs.  Nous devons pouvoir les utiliser. <br><br><h3>  Compétence: SIMD </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/c98/11c/2ecc9811c01888acb643fb14fe70c7b3.png" alt="image"><br><br>  En plus du multithreading, il existe une autre technologie qui permet une mise en œuvre plus efficace du traitement parallèle des données.  Il s'agit du SIMD: traitement par une seule instruction de plusieurs blocs de données à la fois.  Un aspect important nécessaire pour un assemblage Web vraiment rapide. <br><br><h3>  Compétence: adressage 64 bits </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0fd/e7e/26d/0fde7e26d23106765832788445d65f88.png" alt="image"><br><br>  Une autre caractéristique importante de l'architecture matérielle moderne, qui n'est pas encore disponible dans WebAssembly, est la prise en charge de l'adressage de mémoire 64 bits.  Tout est simple: avec les adresses 32 bits, vous ne pouvez utiliser que 4 Go de mémoire (ce qui est très petit pour les gros programmes), mais avec les adresses 64 bits, cela représente déjà jusqu'à 16 exaoctets (c'est beaucoup pour les logiciels modernes).  Bien sûr, non seulement le maximum théorique est important, mais aussi le maximum pratique (combien de mémoire l'OS vous donnera).  Mais sur la plupart des appareils modernes, il y a déjà 4 Go ou plus de RAM et ce nombre augmentera. <br><br><h3>  Compétence: Compilation de flux </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/477/392/ade/477392ade953503f39a7f98214190ef1.png" alt="image"><br><br>  Nous devons non seulement exécuter rapidement les applications.  Nous devons également réduire l'intervalle de temps entre le début de son téléchargement sur le réseau et son démarrage.  La compilation de flux vous permet de démarrer le traitement d'un fichier WebAssembly avant qu'il ne soit finalement téléchargé.  Nous examinons les instructions lors du téléchargement sur le réseau.  Ainsi, le chargement et la compilation vont en parallèle.  Dans le code Firefox, nous avons pu atteindre une vitesse de compilation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">supérieure à la vitesse de téléchargement</a> - c'est-à-dire que le temps de traitement de certains codes de N octets s'est avéré être inférieur au temps de téléchargement de ce code sur le réseau.  Les développeurs d'autres navigateurs travaillent également sur la compilation de flux. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7a/ad8/71f/c7aad871f04688b8f1d93480c48e6a74.png" alt="image"><br><br>  Une chose liée à la compilation en streaming est l'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux compilateurs</a> .  L'un d'eux (décrit ci-dessus) fonctionne rapidement et vous permet de lancer immédiatement le code téléchargé.  Cependant, il n'en effectue pas toutes les optimisations théoriquement possibles, car cela demande plus de temps.  Ces optimisations sont effectuées par un autre compilateur travaillant en arrière-plan.  Dès qu'il a terminé son travail, une version en mémoire en remplace une autre puis fonctionne à la place. <br><br>  Nous obtenons donc à la fois le démarrage rapide de l'application et son fonctionnement efficace. <br><br><h3>  Compétence: mise en cache </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/287/101/9b4/2871019b4d4d50c27713f67c9fe6ccd9.png" alt="image"><br><br>  Si nous avons téléchargé et compilé du code WebAssembly par le compilateur d'optimisation, cela n'a aucun sens de faire de même lors du chargement de ce code dans un autre onglet (ou la prochaine fois que le navigateur est ouvert, à condition que l'application reste inchangée).  Le code compilé peut (et doit) être mis en cache puis utilisé à partir du cache. <br><br><h3>  Compétence: autres améliorations </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/85f/14f/157/85f14f1575ad1327cb1d0afa9e3ed353.png" alt="image"><br><br>  Maintenant, il y a beaucoup de discussions sur les autres améliorations possibles et sur quoi les efforts des développeurs devraient être concentrés.  Quelque chose va certainement se réaliser, quelque chose pas immédiatement, quelque chose ne se produira pas du tout.  Avec votre permission, je définirai tous ces points dans la classe générale «autres améliorations», et ce qui y entrera, nous comprendrons avec le temps. <br><br><h3>  Où en sommes-nous maintenant? </h3><br>  Quelque part ici: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a04/e7b/b13/a04e7bb13ef5b52fd1f0a5a1af4c298d.png" alt="image"><br><br><h4>  Multithreading </h4><br>  Pour le multithreading, nous avons un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plan</a> presque prêt, mais l'un de ses éléments clés ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SharedArrayBuffers</a> ) a été forcé d'être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">désactivé</a> au début de cette année.  Il sera bientôt réactivé et nous pourrons continuer. <br><br><h4>  SIMD </h4><br>  <a href="">Développé</a> activement en ce moment. <br><br><h4>  Adressage 64 bits </h4><br>  Pour le <a href="">wasm-64</a> , nous avons une idée assez claire de la façon dont les choses devraient fonctionner.  Nous étions basés sur des approches d'architecture x86 et ARM. <br><br><h4>  Compilation de flux </h4><br>  Dans Firefox, il a été <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ajouté</a> en 2017, d'autres navigateurs y travaillent. <br><br><h4>  Utilisation de deux compilateurs </h4><br>  Dans Firefox, cela a été ajouté en 2017 et dans d'autres navigateurs en 2018. <br><br><h4>  Mise en cache HTTP implicite </h4><br>  Dans Firefox, le développement est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">presque terminé</a> , il y aura bientôt une sortie. <br><br><h4>  Autres améliorations </h4><br>  Il y a une discussion <br><br>  Comme vous pouvez le voir, la plupart des éléments sont toujours en cours de développement.  Et pourtant, nous pouvons déjà voir des applications s'exécuter sur WebAssembly aujourd'hui, car les capacités d'aujourd'hui sont déjà suffisantes pour quelqu'un.  Dès que toutes les fonctionnalités ci-dessus seront prêtes, nous ouvrirons une nouvelle "nouvelle réalisation" et encore plus de nouvelles applications recevront le support de WebAssembly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/994/53c/36b/99453c36b420ead1b724c7a7e415c689.png" alt="image"><br><br><h2>  Interaction Javascript </h2><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/42e/383/372/42e383372c2216891576c4cdda6ae193.png" alt="image"></a> <br><br>  WebAssembly a été créé non seulement comme plate-forme pour les jeux et les applications lourdes.  Il peut être utilisé pour le développement Web régulier.  Nous sommes conscients qu'aujourd'hui il existe de très grandes applications Web écrites en Javascript et peu décident de les prendre et de les réécrire complètement dans WebAssembly.  Le point important ici est que ce n'est pas nécessaire.  Très probablement, la plupart de ces applications fonctionnent assez bien et seulement dans certains goulots d'étranglement, peut-être, il y a un manque de performances dans les calculs, ou la bande passante de traitement des données, ou un manque de fonctionnalités en raison du manque d'une version JS d'une bibliothèque.  Nous voulons donner aux développeurs la possibilité de réécrire uniquement ces goulots d'étranglement sur WebAssembly, en laissant le reste du code dans JS familier.  Et c'est déjà possible.  Par exemple, en réécrivant l'analyseur Gutenberg dans Rust et en l'assemblant sous WebAssebly, nous avons réussi à augmenter la productivité de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">86 fois</a> . <br><br>  Mais pour rendre une telle pratique de masse et pratique, nous devons mettre en œuvre autre chose. <br><br><h3>  Compétence: appels rapides entre JS et WebAssembly </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/557/618/0ec/5576180eca50ce1736a684aa32575524.png" alt="image"><br><br>  L'appel de WebAssembly à partir de JS devrait fonctionner très rapidement.  En ajoutant un petit module WebAssembly, le programmeur ne devrait ressentir aucune perte de performances, même si ce module est appelé très souvent.  Ce n'est pas le cas dans MVP (puisque l'objectif de MVP n'était pas de maximiser les performances de tels appels).  Ce problème doit encore être résolu.  Dans Firefox, nous avons déjà vérifié que certains appels JS-&gt; WebAssembly sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déjà plus rapides que les appels JS-&gt; JS non en ligne</a> .  Les développeurs d'autres navigateurs travaillent également sur cette tâche. <br><br><h3>  Compétence: échange de données rapide </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/606/f9c/445/606f9c44570c6a3a4f64b008be4e5eda.png" alt="image"><br><br>  Cette tâche est liée à la précédente: il est important non seulement d'appeler rapidement le code WebAssembly depuis JS, mais également de transférer rapidement des données entre eux.  Il y a certains problèmes avec cela.  Par exemple, le fait que WebAssembly ne comprend que les nombres.  Il n'y a pas d'objets dedans, mais dans JS ils le sont.  Il s'avère que nous avons besoin d'une sorte de couche de traduction.  Il existe déjà, mais n'est pas encore suffisamment productif. <br><br><h3>  Compétence: intégration avec les modules ES </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/15f/db4/b4f15fdb4151fccd40d509e675e3363e.png" alt="image"><br><br>  Maintenant, l'utilisation du module WebAssembly ressemble à l'appel d'une API spéciale qui vous renverra le module pour utilisation.  Mais cela signifie que le module WebAssembly ne fait pas vraiment partie du graphique du module JS de l'application Web.  Afin d'avoir toutes les fonctions disponibles pour les modules ES (comme l'exportation et l'importation), le module WebAssembly doit pouvoir s'intégrer aux modules ES. <br><br><h3>  Compétence: intégration dans le développement </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/60a/a00/b26/60aa00b2662dcb635ff336ad09319e85.png" alt="image"><br><br>  Le simple fait d'importer et d'exporter ne signifie pas devenir un module entièrement fonctionnel.  Nous avons besoin d'un endroit où les modules WebAssembly pourraient être distribués.  Quel sera l'analogue de npm pour WebAssembly?  Hmm ... que diriez-vous de npm lui-même?  Et quel sera l'analogue de webpack ou Parcel for WebAssembly?  Hmm ... qu'en est-il du webpack et du colis? <br><br>  Les modules WebAssembly ne doivent pas différer des modules ordinaires, ce qui signifie qu'ils peuvent être distribués via la même infrastructure.  Mais nous avons besoin d'outils pour les intégrer dans cette infrastructure. <br><br><h3>  Compétence: rétrocompatibilité </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/86f/b36/e1e86fb36b5c6f28e1084613b8acd24f.png" alt="image"><br><br>  Il y a une autre chose importante que nous devons fournir.  Tout devrait bien fonctionner même dans les anciennes versions des navigateurs.  Même ceux qui n'ont aucune idée de WebAssembly.  Nous devons garantir qu'une fois que nous aurons écrit le code de WebAssembly, le développeur n'aura pas à écrire la deuxième version du même code en Javascript simplement parce que le site doit également s'ouvrir dans IE11. <br><br><h3>  Où en sommes-nous maintenant? </h3><br>  Quelque part ici: <br><img src="https://habrastorage.org/getpro/habr/post_images/49e/46e/ff9/49e46eff987d5d8de4984576f954847c.png" alt="image"><br><br><h4>  Raccourcis entre JS et WebAssembly </h4><br>  Déjà <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">implémenté</a> dans Firefox, des travaux sont en cours dans d'autres navigateurs. <br><br><h4>  Échange de données rapide </h4><br>  Il y a plusieurs suggestions.  Par exemple, développez le système de types dans WebAssembly avec des références aux objets JS.  C'est possible, mais cela nécessitera l'écriture de code supplémentaire (par exemple, pour appeler les méthodes JS), ce qui ne fonctionne pas trop vite.  Pour résoudre ce problème, à son tour, il existe plusieurs suggestions. <br><br>  Il y a un autre aspect lié à l'échange de données.  Il s'agit de suivre la durée de stockage des données en mémoire.  Si vous avez des données en mémoire auxquelles le code JS devrait avoir accès, vous devez les y laisser jusqu'à ce que le code JS les lise.  Mais si vous les laissez là pour toujours, nous obtiendrons une fuite de mémoire.  Comment savoir que les données peuvent déjà être supprimées (le code JS les a déjà lues)?  Aujourd'hui, cette responsabilité incombe au programmeur - tout est libéré manuellement.  Une fois que le code JS a fini de lire les données, il devrait appeler quelque chose comme la fonction «libre».  Mais cette approche est dépassée et conduit souvent à des erreurs.  Pour résoudre ce problème, nous avons introduit le concept de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WeakRef</a> en Javascript.  Cela permet de lire les données sur le côté du code JS, et lorsque le garbage collector fonctionne, il est nécessaire d'effacer correctement la mémoire dans le module WebAssembly. <br><br>  Tout cela est encore en développement.  Pendant ce temps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, des outils ont</a> été <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">créés</a> dans l'écosystème Rust qui automatisent l'écriture de ce code pour vous, remplaçant les parties qui n'ont pas encore été implémentées par leur propre implémentation.  Un de ces outils mérite une mention spéciale.  Il s'appelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wasm-bindgen</a> .  Lorsqu'il remarque que votre code Rust essaie d'obtenir ou de renvoyer des objets JS ou DOM, il crée automatiquement une couche JS qui pourra interagir avec votre code Rust.  Et cette couche est également capable d'interagir avec le module WebAssembly écrit dans n'importe quel autre langage, donc non seulement les programmeurs Rust peuvent utiliser cet outil. <br><br><h4>  Intégration avec les modules ES </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un plan de</a> travail dans ce domaine existe depuis un certain temps.  Nous y travaillons activement avec les développeurs d'autres navigateurs. <br><br><h4>  Intégration au développement </h4><br>  Déjà, il existe des outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wasm-pack</a> dans l'écosystème Rust qui vous permettent d'emballer automatiquement tout ce dont vous avez besoin pour une sortie en npm.  Et il y a des gens qui utilisent cet outil pour créer leurs modules. <br><br><h4>  Compatibilité descendante </h4><br>  Pour la compatibilité descendante, nous avons l'outil wasm2js.  Il vous permet de transformer un fichier wasm en un fichier JS équivalent.  Ce code Javascript ne sera pas rapide, mais il fonctionnera sur n'importe quel navigateur (y compris celui qui ne prend pas en charge WebAssembly). <br><br>  Comme vous pouvez le voir, nous sommes très près de recevoir cette «réalisation».  Et dès que nous ferons cela, le chemin vers deux autres s'ouvrira. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cd/f82/ac3/4cdf82ac3ee88090ba897f2ca4b339da.png" alt="image"></a> <br><br><h2>  Framework JS et langages compilés JS </h2><br>  Le premier est la possibilité de réécrire les frameworks JS lourds et populaires sur WebAssebly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/794/e65/121/794e6512119d46d55953dba013ed3273.png" alt="image"><br><br>  La seconde consiste à permettre aux langages de programmation de se compiler en Javascript pour le remplacer par WebAssembly.  Nous parlons de langues comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scala.js</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reason</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Elm</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31c/1ce/750/31c1ce750e3bfefe906d372292e8dfdb.png" alt="image"><br><br>  Pour ces deux tâches, WebAssembly doit prendre en charge un certain nombre de nouvelles fonctionnalités de haut niveau. <br><br><h3>  Compétence: Garbage Collector </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/c3e/8eb/160/c3e8eb1609af4cde10a08081ee63f046.png" alt="image"><br><br>  Nous avons besoin d'une intégration avec un garbage collector basé sur un navigateur pour plusieurs raisons.  Rappelons d'abord la tâche de réécrire les frameworks JS (ou des parties d'entre eux).  Cela peut être nécessaire. ,  React      DOM-,     Rust   .     -     .   DOM     ,         ,        . ,    ,     ,      .      ,   . <br><br>        JS-.       - ,   .           ,      ,       Javascript.  JS-          WebAssembly-,            JS-. <br><br>       (  ),       .    ,   ,    . WebAssembly        ,   . <br><br>       Scala.js, Reason, Kotlin  Elm —     Javascript,        .   WebAssembly      —          WebAssembly             (    ). <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/98a/88d/f2f98a88dd8f91735a5572950606811e.png" alt="image"><br><br>    . ,  ,  Rust,   .    — .            —    .       WebAssembly     . <br><br>  ,    Javascript.          — -           - .   WebAssembly-  JS-,     —      .   Rust, ,     .   ,       . <br><br><h3> :  </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0dc/5f2/b8a/0dc5f2b8a7da6d533192464f6258c314.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les développeurs JS sont également habitués à de bons outils de débogage. </font><font style="vertical-align: inherit;">Tous les navigateurs modernes disposent d'outils pour une analyse pratique du code Javascript. </font><font style="vertical-align: inherit;">Nous avons besoin du même niveau de support pour WebAssembly.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compétence: Tail Calls </font></font></h3><br><img src="https://habrastorage.org/getpro/habr/post_images/365/d07/1d8/365d071d8415b5510f45f70982edee2e.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour prendre en charge les langages fonctionnels, nous avons besoin d'une chose appelée les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appels de queue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Je ne m'attarderai pas sur ce sujet, ce qui rend un peu plus facile de dire qu'un appel de queue est un moyen dans certains cas d'appeler une fonction sans lui allouer de cadre sur la pile. </font><font style="vertical-align: inherit;">Étant donné que cette fonctionnalité est essentielle pour les langages fonctionnels, nous voulons qu'elle soit prise en charge dans WebAssembly.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Où en sommes-nous maintenant? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelque part ici: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f5/b0d/853/8f5b0d8534744ec21059f27231fa080b.png" alt="image"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collecte des ordures </font></font></h4><br>  Pour implémenter le garbage collection, le travail est actuellement en cours dans deux directions: ce sont les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objets typés</a> pour JS et, en fait, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le garbage collector pour WebAssembly</a> .  Les objets typés vous permettent de décrire la structure claire de l'objet.  Il existe déjà une vision de la façon dont cela devrait fonctionner, et elle sera discutée lors de la prochaine réunion du TC39.  Par conséquent, le GC pour WebAssembly pourra accéder à la structure ci-dessus à ses propres fins.  Des travaux sont déjà en cours pour sa mise en œuvre. <br><br>  Dès que les deux parties seront terminées, nous obtiendrons un système d'interaction entre JS et WebAssembly, capable de comprendre à tous les niveaux en quoi consiste l'objet et d'utiliser efficacement ses données internes.  Nous avons déjà un prototype fonctionnel.  Cependant, le prototype ne peut pas seulement être pris et publié - nous devons consacrer un certain temps à la normalisation et aux révisions.  Nous prévoyons qu'il atteindra la sortie quelque part au cours de la 2019e année. <br><br><h4>  Gestion des exceptions </h4><br>  Les travaux sur les <a href="">exceptions sont</a> actuellement en cours de recherche et développement.  Nous examinons diverses propositions, essayons de les mettre en œuvre et voyons leur efficacité. <br><br><h4>  Débogage </h4><br>  Pour le débogage, il existe déjà un certain support dans les outils de développement Firefox.  Mais l'idéal est encore loin.  Nous voulons montrer au développeur son code source et sa position actuelle, et pas seulement les instructions de l'assembleur.  Nous devons développer et implémenter la prise en charge des fichiers de symboles, ce qui nous permettra de corréler chaque instruction de code avec la ligne source.  Actuellement, des <a href="">travaux sont en cours</a> sur la spécification de ce mécanisme. <br><br><h4>  Appels de queue </h4><br>  <a href="">Il y a un travail en cours</a> . <br><br>  Lorsque tout ce qui précède est terminé, nous pouvons supposer que nous avons atteint la réalisation «Les cadres et langages JS compilés dans JS» <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/8cb/651/7b4/8cb6517b4483f2b4f566783157f9511d.png" alt="image"></a> <br><br>  Il s'agissait donc d'un plan pour obtenir des «réalisations» dans le navigateur.  Qu'en est-il de ce qui se passe en dehors du navigateur? <br><br><h2>  Hors navigateur </h2><br>  Peut-être avez-vous été gêné par la combinaison des mots «en dehors du navigateur».  Avons-nous vraiment autre chose que le navigateur lorsque nous parlons du Web?  Mais le "web" que nous avons droit dans le nom "WebAssembly".  Mais en fait, HTML, CSS et JavaScript ne sont que la pointe de l'iceberg. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c11/606/9c4c1160641ee4014f7317b71711f3d2.png" alt="image"><br><br>  Oui, ils sont mieux visibles, car ce sont eux qui forment l'interface utilisateur.  Mais il y a une autre partie très importante du Web - ce sont les connexions.  La connexion de tout avec tout. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f34/d7b/4f4/f34d7b4f4d2fdfe6487614b4d1530416.png" alt="image"><br><br>  Je peux créer un lien vers votre page dès maintenant.  Je n'ai pas besoin de la vôtre ou de la permission de quiconque.  Je viens de faire ce lien, de l'ajouter à mon site.  Tout le monde peut le suivre et votre contenu sera affiché, le code que vous avez écrit sera lancé.  Cette simplicité de création de connexions et de transition à travers elles a créé notre Internet tel qu'il est.  Nous avons maintenant des réseaux sociaux et d'autres sites qui, par essence, élargissent le concept de «lien» avec la possibilité d'ancrer n'importe quoi: personnes, appareils, entreprises, etc. <br><br>  Mais avec tous ces liens et liens, il y a deux problèmes. <br><br>  D'abord, à quoi le lien devrait-il mener?  Si vous allez quelque part et que le site vous propose du code qui doit être exécuté dans votre navigateur - ce code doit être multiplateforme.  Il devrait se compiler en quelque chose et fonctionner sur un coquelicot, sur Windows, sur un Android.  Partout.  La portabilité du code téléchargeable est une partie importante du concept de connectivité Web. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b38/d74/4c1/b38d744c118cebfdff5d8cd198f8a490.png" alt="image"><br><br>  Mais il ne suffit pas de télécharger et d'exécuter le code.  Vous devez comprendre que nous ne savons rien de ce code.  Nous ne lui faisons pas suffisamment confiance pour avoir un contrôle total sur l'ordinateur de l'utilisateur.  Et si c'est du code malveillant?  Il peut faire quelque chose de mal.  Et ici, nous avons besoin d'une sorte de modèle de sécurité.  Nous avons besoin d'un bac à sable où nous pouvons mettre un code inconnu, lui donner des outils contrôlés pour le travail, mais en retirer tout ce qui est essentiel et dangereux. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bf/1d6/0c6/0bf1d60c6df0e2a76b4afb83e3dffe42.png" alt="image"><br><br>  Il y a donc deux aspects du concept de «communication»: la portabilité et la sécurité.  Nous savons que nous pouvons certainement exécuter le code et que cela ne nous nuira certainement pas.  Pourquoi est-ce que j'insiste sur ces concepts et comment cette vision des choses diffère-t-elle de la vision du Web en tant que combinaison de HTML, CSS et Javascript?  Parce que cette approche change fondamentalement la vue de ce qu'est WebAssembly. <br><br>  D'une part, nous pouvons considérer WebAssembly comme «un autre outil disponible dans un navigateur moderne».  Et il en est ainsi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1df/51f/fe5/1df51ffe596ea6f2f45543f913ca7911.png" alt="image"><br><br>  Mais la portabilité et la sécurité de l'exécution du code nous ouvrent d'autres portes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5da/71e/e98/5da71ee982b4cb6a126d14aa962ed491.png" alt="image"><br><br><h2>  Node.js </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/b5c/643/c55/b5c643c55f8c180e50e1a24ee4122ef6.png" alt="image"><br><br>  Comment WebAssembly peut-il aider Node?  Apporter la portabilité. <br><br>  Le nœud offre un niveau de portabilité assez élevé en utilisant Javascript.  Mais il existe encore de nombreux cas où les performances du code JS ne sont pas suffisantes ou tout simplement le bon code JS n'a pas encore été écrit, mais il existe une version native de celui-ci.  Et puis Node utilise des modules natifs.  Ils sont écrits dans des langages comme C et doivent être compilés pour la plate-forme spécifique sur laquelle votre nœud fonctionne. <br><br>  Les modules natifs peuvent être compilés lors de l'installation, ou vous pouvez les prendre immédiatement prêts pour l'une des plates-formes populaires.  Les deux approches sont possibles, mais ce n'est qu'un choix de deux maux: soit un mal de tête supplémentaire pour l'utilisateur, soit l'auteur du module. <br><br>  Si vous imaginez que ces modules seront sur WebAssembly, alors ils n'auront pas du tout besoin d'être compilés.  La portabilité vous permet de les exécuter sur n'importe quelle plate-forme, immédiatement, comme le code Javascript.  Mais ils fonctionneront avec les performances des versions natives. <br><br>  Et ici, le bonheur vient au monde de Node sous la forme d'une portabilité totale de tout et partout.  Vous pouvez porter l'application Node de Linux vers Windows - et tout continuera à fonctionner sans aucune recompilation.  Mais en même temps, le module WebAssembly n'a pas accès aux ressources système (il fonctionne dans son sandbox).  Mais les modules Node natifs (et même non natifs) ne fonctionnent pas dans le bac à sable, ils ont accès à tout - c'est l'idéologie de Node.  Ainsi, pour que le module WebAssembly obtienne les mêmes fonctionnalités, une couche supplémentaire d'accès aux ressources du système d'exploitation est nécessaire.  Quelque chose comme les fonctions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">POSIX</a> (elles ne sont pas nécessaires, elles ne sont données qu'à titre d'exemple d'interface d'accès aux ressources relativement stable et suffisante). <br><br><h3>  Compétence: interface portable </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/e88/688/a08e88688da9312cf9b0821ea1ebd9de.png" alt="image"><br><br>  Alors, de quoi les développeurs Node ont-ils besoin pour utiliser les modules WebAssembly?  Une sorte d'interface pour accéder à ses fonctions.  Ce serait bien de le standardiser.  Eh bien, non seulement Node peut appeler ces fonctions, mais aussi n'importe qui en général.  Si vous souhaitez utiliser le module WebAssembly dans votre application, nous sommes connectés et nous l’utilisons.  Quelque chose comme "POSIX pour WebAssembly".  PWSIX (interface système portable WebAssembly)? <br><br><h3>  Où en sommes-nous maintenant? </h3><br>  Il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">document</a> qui décrit le mécanisme permettant de fournir un chemin d'accès à un module par son nom.  Ceci est susceptible d'être utilisé à la fois par les navigateurs et par Node (ils pourront fournir des chemins différents).  Bien qu'il n'y ait pas de développement actif, mais il y a beaucoup de discussions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69c/74f/63f/69c74f63fd64008d91dbf31a18dce24e.png" alt="image"><br><br>  Il sera très probablement mis en œuvre sous une forme ou une autre.  C'est bien car cela nous ouvre de nombreuses possibilités. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ae2/750/50f/ae275050f12b82aba399d26d50656c0f.png" alt="image"></a> <br><br><h2>  CDN, Serverless et Edge Computing </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c16/77d/224/c1677d22458933b7f3c07cdf47b9bf12.png" alt="image"><br><br>  Les exemples sont des choses comme CDN, Serverless, Edge Computing.  Cas où vous mettez votre code sur le serveur de quelqu'un d'autre, qui prend soin de sa disponibilité pour les clients.  Pourquoi pourriez-vous avoir besoin de WebAssembly ici?  Récemment, il y a eu un excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> sur ce sujet.  En bref, il peut être nécessaire d'exécuter du code à partir de différentes sources (sans se faire mutuellement confiance) au sein d'un même processus.  Ce code doit être isolé les uns des autres et du système d'exploitation.  Des solutions comme une machine virtuelle JS (SpiderMonkey ou V8) fonctionnent d'une manière ou d'une autre, mais n'offrent pas les performances et l'évolutivité souhaitées.  Et WebAssembly - donne. <br><br>  Que faut-il pour que cela fonctionne? <br><br><h3>  Compétence: runtime </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/965/16f/e4c/96516fe4ccb30f39a885d1f460033e0c.png" alt="image"><br><br>  Nous avons besoin d'un environnement d'exécution et certaines entreprises créent le leur.  Nous avons déjà des compilateurs WebAssembly (comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cranelift</a> ) - ils sont rapides et économes en mémoire.  Mais le code généré par lui ne peut pas vivre dans le vide - il doit s'appuyer sur quelque chose, interagir d'une manière ou d'une autre avec l'environnement.  Maintenant, certaines entreprises, telles que Fastly, écrivent elles-mêmes cet environnement d'exécution.  Mais ce n'est pas une très bonne approche - après tout, de nombreuses entreprises en auront besoin et feront le même travail, encore et encore.  Nous pourrions le faire une fois, ajouter à la norme - et économiser à tout le monde un tas de ressources. <br><br><h3>  Où en sommes-nous maintenant? </h3><br>  Quelque part ici: <br><img src="https://habrastorage.org/getpro/habr/post_images/bba/460/2be/bba4602be78c2f8132a7106d7463218f.png" alt="image"><br><br>  Il n'y a pas encore de standard d'exécution.  Ce qui n'empêche pas plusieurs runtimes indépendants déjà utilisés dans des projets réels d'exister et de fonctionner.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WAVM</a> et wasmjit. <br><br>  Nous prévoyons également de publier un runtime construit sur Cranelift, il sera appelé wasmtime.  Et dès que nous avons quelque chose de standardisé et de fonctionnel, c'est une opportunité ouverte de développer un certain nombre de choses, comme, par exemple ... <br><br><h2>  Utilitaires de ligne de commande portables </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/90a/f8f/a14/90af8fa14441a34a3652478d0bd9b948.png" alt="image"><br><br>  WebAssembly peut être utilisé non seulement dans le navigateur, mais également dans les systèmes d'exploitation traditionnels.  Nous ne parlerons pas du noyau (bien qu'il y ait aussi des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">casse</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cou</a> qui agitent cela), mais le code WebAssembly peut bien fonctionner en mode utilisateur.  Et cela permet de créer des utilitaires de ligne de commande qui, une fois construits, fonctionneront garantis d'être les mêmes pour n'importe quel système d'exploitation. <br><br><h2>  Internet des objets </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/18f/10a/dcd/18f10adcda7bfa676d90b6e92cb2bb30.png" alt="image"><br><br>  Par «Internet des objets», ils désignent généralement des appareils de faible puissance (comme des capteurs / contrôleurs portables ou divers dans les «maisons intelligentes»).  Les limitations des ressources processeur et de la RAM disponibles affectent négativement la possibilité d'exécuter du code JS, mais WebAssembly est une tout autre affaire.  L'optimisation de compilateurs comme Cranelift et d'un runtime comme wasmtime brillera dans de telles conditions, car ils ont été juste écrits pour des tâches d'économie de ressources.  Dans des cas absolument extrêmes, WebAssembly permet même de compiler votre module dans le binaire natif de la plateforme cible.  Eh bien, encore une fois, la portabilité - il y a beaucoup de tous ces appareils IoT aujourd'hui et ils sont construits sur différentes plates-formes.  Avec WebAssembly, vous n'avez pas à vous en préoccuper - le code développé s'exécutera partout. <br><br><h2>  Conclusions </h2><br>  Revenons un peu en arrière et jetons à nouveau un œil à notre «arbre de compétences». <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0c6/201/71f/0c620171f0b0c2b880e730e84ee9f1b4.png" alt="image"></a> <br><br>  J'ai commencé cet article avec le fait que certaines personnes ne comprennent pas pourquoi WebAssembly n'est pas encore terminé.  Comme vous pouvez maintenant le comprendre, son chemin a à peine commencé.  Oui, MVP ouvre déjà certaines possibilités.  Nous pouvons déjà compiler quelque chose dans WebAssembly et l'exécuter dans un navigateur.  Mais il reste encore beaucoup de travail à faire - prendre en charge tout ce dont vous avez besoin pour les applications lourdes et les langages de haut niveau, remplacer les frameworks JS et toutes ces choses «en dehors du navigateur» dont j'ai parlé.  Lorsque tout cela sera prêt, nous verrons un nouveau web.  Haute performance, plus grand, plus portable.  Il n'y aura plus ce type de logiciel qui ne peut pas être écrit pour être exécuté dans le navigateur: jeux, blockchain, Internet des objets, utilitaires de ligne de commande - tout commencera. <br><br>  WebAssembly n'est pas terminé.  Il vient de commencer. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428347/">https://habr.com/ru/post/fr428347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428337/index.html">JavaScript divertissant: sans accolades</a></li>
<li><a href="../fr428339/index.html">Ne l'automatisez pas: mauvais conseils commerciaux</a></li>
<li><a href="../fr428341/index.html">Technologie Qsan RAID EE</a></li>
<li><a href="../fr428343/index.html">Un puzzle intéressant en C</a></li>
<li><a href="../fr428345/index.html">Couvrir les exigences avec des cas. SuperJob Realities</a></li>
<li><a href="../fr428349/index.html">Concombre dans le cloud: utilisation de scripts BDD pour les tests de résistance des produits</a></li>
<li><a href="../fr428355/index.html">Mécanique de la gamification: évaluation</a></li>
<li><a href="../fr428357/index.html">L'absorption en pratique: une histoire de vie</a></li>
<li><a href="../fr428363/index.html">Construire un jetpack / hoverboard: systèmes de sauvetage</a></li>
<li><a href="../fr428365/index.html">L'histoire de la façon dont la facturation Google a changé, ou comment éviter les coûts inutiles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>