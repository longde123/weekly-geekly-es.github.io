<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐑 ⚾️ 🐾 Guide JavaScript Partie 5: Tableaux et boucles 🤤 👩🏿‍🔬 🤙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, dans la cinquième partie de la traduction du cours JavaScript, nous allons parler des tableaux et des boucles. Les tableaux sont utilisés...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide JavaScript Partie 5: Tableaux et boucles</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/430380/">  Aujourd'hui, dans la cinquième partie de la traduction du cours JavaScript, nous allons parler des tableaux et des boucles.  Les tableaux sont utilisés pour résoudre de nombreux problèmes.  Travaille souvent avec des tableaux à l'aide de boucles. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: premier programme, fonctionnalités linguistiques, normes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2: style de code et structure du programme</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: variables, types de données, expressions, objets</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4: caractéristiques</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 5: tableaux et boucles</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 6: exceptions, points-virgules, littéraux génériques</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 7: mode strict, ce mot-clé, événements, modules, calculs mathématiques</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 8: Présentation des fonctionnalités d'ES6</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 9: Présentation des normes ES7, ES8 et ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tableaux</font> </h2><br>  Les tableaux, objets de type <code>Array</code> , évoluent avec d'autres mécanismes du langage.  Ce sont des listes de valeurs numérotées. <br><br>  Le premier élément du tableau a un index (clé) de 0; cette approche est utilisée dans de nombreux langages de programmation. <br><br>  Dans cette section, nous considérerons les méthodes modernes de travail avec les tableaux. <br><br><h3>  <font color="#3AC1EF">▍Initialisation des tableaux</font> </h3><br>  Voici quelques façons d'initialiser des tableaux. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>).fill(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ,   6 ,  1</span></span></code> </pre> <br>  Afin d'accéder à un élément individuel du tableau, utilisez une construction composée de crochets qui contiennent l'index de l'élément du tableau.  Les éléments du tableau peuvent être lus ou écrits. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 2, 3 ] const first = a[0] console.log(first) //1 a[0] = 4 console.log(a) //[ 4, 2, 3 ]</span></span></code> </pre> <br>  Le constructeur de <code>Array</code> pour déclarer des tableaux n'est pas recommandé. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>() <span class="hljs-comment"><span class="hljs-comment">//  const a = new Array(1, 2, 3) // </span></span></code> </pre> <br>  Cette méthode ne doit être utilisée que lors de la déclaration de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableaux typés</a> . <br><br><h3>  <font color="#3AC1EF">▍Obtenir la longueur du tableau</font> </h3><br>  Pour connaître la longueur d'un tableau, vous devez vous référer à sa propriété <code>length</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> l = a.length</code> </pre> <br><h3>  <font color="#3AC1EF">▍Vérification d'un tableau à l'aide de la méthode every ()</font> </h3><br>  La méthode du tableau <code>every()</code> peut être utilisée pour organiser la vérification de tous leurs éléments en utilisant une certaine condition.  Si tous les éléments du tableau remplissent la condition, la fonction renverra <code>true</code> , sinon elle renverra <code>false</code> . <br><br>  Cette méthode reçoit une fonction qui prend les arguments <code>currentValue</code> (élément de tableau actuel), <code>index</code> (index de l'élément de tableau actuel) et <code>array</code> (le tableau lui-même).  Il peut également prendre une valeur facultative, utilisée comme <code>this</code> lors de l'exécution de la fonction qui lui est transmise. <br>  Par exemple, vérifiez si les valeurs de tous les éléments du tableau sont supérieures à 10. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el &gt; <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.every(test)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(b.every(test)) //false</span></span></code> </pre> <br>  Ici, dans la fonction <code>test()</code> , nous ne sommes intéressés que par le premier argument qui lui est passé, nous le déclarons donc, en spécifiant uniquement le paramètre <code>el</code> , dans lequel la valeur correspondante tombera. <br><br><h3>  <font color="#3AC1EF">▍ Vérification d'un tableau à l'aide de la méthode some ()</font> </h3><br>  Cette méthode est très similaire à la méthode <code>every()</code> , mais elle retourne <code>true</code> si au moins un des éléments du tableau satisfait la condition spécifiée par la fonction qui lui est passée. <br><br><h3>  <font color="#3AC1EF">▍Créez un tableau basé sur un tableau existant à l'aide de la méthode map ()</font> </h3><br>  La méthode <code>map()</code> des tableaux vous permet d'itérer sur les tableaux, en appliquant à chaque élément transmis à cette méthode une fonction qui convertit l'élément et crée de nouveaux tableaux à partir des valeurs reçues.  Voici, par exemple, comment obtenir un nouveau tableau, qui est le résultat de la multiplication de tous les éléments du tableau d'origine par 2. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> double = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doubleA = a.map(double) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 2, 3 ] console.log(doubleA) //[ 2, 4, 6 ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Filtrage d'un tableau à l'aide de la méthode filter ()</font> </h3><br>  La méthode <code>filter()</code> est similaire à la méthode <code>map()</code> , mais elle vous permet de créer de nouveaux tableaux contenant uniquement les éléments des tableaux d'origine qui remplissent la condition spécifiée par la méthode <code>filter()</code> passée à la fonction. <br><br><h3>  <font color="#3AC1EF">▍ méthode Reduce ()</font> </h3><br>  La méthode <code>reduce()</code> vous permet d'appliquer une fonction donnée à l'accumulateur et à chaque valeur du tableau, en réduisant le tableau à une seule valeur (cette valeur peut avoir un type primitif ou objet).  Cette méthode prend une fonction de conversion et une valeur de batterie initiale facultative.  Prenons un exemple. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">accumulator, currentValue, currentIndex, array</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulator * currentValue }, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//24 // 1: 1 * 1 = 1 // 2: 1 * 2 = 2 // 3: 2 * 3 = 6 // 4: 6 * 4 = 24</span></span></code> </pre> <br>  Ici, nous recherchons le produit de tous les éléments du tableau décrit à l'aide d'un littéral, définissant la valeur initiale de l'accumulateur 1. <br><br><h3>  <font color="#3AC1EF">▍ Énumération d'un tableau à l'aide de la méthode forEach ()</font> </h3><br>  La méthode <code>forEach()</code> des tableaux peut être utilisée pour itérer sur les valeurs des tableaux et pour effectuer certaines actions sur eux, spécifiées par la fonction passée à la méthode.  Par exemple, nous affichons, un à la fois, les éléments du tableau dans la console. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] a.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(el)) <span class="hljs-comment"><span class="hljs-comment">//1 //2 //3</span></span></code> </pre> <br>  Si vous devez arrêter ou interrompre la boucle lors de l'itération sur un tableau, alors lorsque vous utilisez <code>forEach()</code> devrez <code>forEach()</code> une exception.  Par conséquent, si au cours de la résolution d'un certain problème, il peut être nécessaire d'interrompre le cycle, il est préférable de choisir une autre manière d'itérer les éléments du tableau. <br><br><h3>  <font color="#3AC1EF">▍Sélection d'un tableau à l'aide de l'opérateur for ... of</font> </h3><br>  L'opérateur <code>for...of</code> est apparu dans la norme ES6.  Il vous permet d'itérer sur des objets itérables (y compris des tableaux).  Voici comment l'utiliser. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> a) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(v) } <span class="hljs-comment"><span class="hljs-comment">//1 //2 //3</span></span></code> </pre> <br>  À chaque itération de la boucle, l'élément suivant du tableau <code>a</code> entre dans la variable <code>v</code> . <br><br><h3>  <font color="#3AC1EF">▍ Énumération d'un tableau à l'aide de l'instruction for</font> </h3><br>  L'instruction <code>for</code> vous permet d'organiser des boucles, qui, en particulier, peuvent être utilisées pour parcourir (ou initialiser) des tableaux en accédant à leurs éléments par index.  En règle générale, l'indice de l'élément suivant est obtenu à l'aide d'un compteur de boucles. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a[i]) } <span class="hljs-comment"><span class="hljs-comment">//1 //2 //3</span></span></code> </pre> <br>  Si, pendant l'exécution de la boucle, vous devez ignorer son itération, vous pouvez utiliser la commande <code>continue</code> .  Pour terminer prématurément le cycle, vous pouvez utiliser la commande <code>break</code> .  Si vous utilisez la commande <code>return</code> dans une boucle, par exemple, située dans une certaine fonction, la boucle et la fonction se termineront et la valeur retournée avec <code>return</code> ira à l'endroit où la fonction a été appelée. <br><br><h3>  <font color="#3AC1EF">▍ Méthode @@ itérateur</font> </h3><br>  Cette méthode est apparue dans la norme ES6.  Il vous permet d'obtenir le soi-disant "itérateur d'un objet" - un objet qui dans ce cas vous permet d'organiser une itération des éléments du tableau.  Un itérateur de tableau peut être obtenu en utilisant le symbole (ces symboles sont appelés "symboles connus") <code>Symbol.iterator</code> .  Après avoir reçu l'itérateur, vous pouvez accéder à sa méthode <code>next()</code> , qui, à chaque appel, renvoie une structure de données contenant l'élément suivant du tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> it = a[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(it.next().value) //2 console.log(it.next().value) //3</span></span></code> </pre> <br>  Si vous appelez la méthode <code>next()</code> fois le dernier élément du tableau atteint, elle renverra, en tant que valeur de l'élément, <code>undefined</code> .  L'objet renvoyé par la méthode <code>next()</code> contient la <code>value</code> et les propriétés <code>done</code> .  La propriété <code>done</code> valeur <code>false</code> jusqu'à ce que le dernier élément du tableau soit atteint.  Dans notre cas, si nous l'appelons.next <code>it.next()</code> pour la quatrième fois, il renverra l'objet <code>{ value: undefined, done: true }</code> , tandis que dans les trois appels précédents, cet objet ressemblerait à <code>{ value: , done: false }</code> . <br><br>  La méthode du tableau <code>entries()</code> renvoie un itérateur qui vous permet d'itérer sur les paires clé-valeur du tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> it = a.entries() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value) <span class="hljs-comment"><span class="hljs-comment">//[0, 1] console.log(it.next().value) //[1, 2] console.log(it.next().value) //[2, 3]</span></span></code> </pre> <br>  La méthode <code>keys()</code> vous permet d'itérer sur les clés d'un tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> it = a.keys() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value) <span class="hljs-comment"><span class="hljs-comment">//0 console.log(it.next().value) //1 console.log(it.next().value) //2</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Ajout d'éléments à la fin d'un tableau</font> </h3><br>  Pour ajouter des éléments à la fin du tableau, utilisez la méthode <code>push()</code> . <br><br><pre> <code class="javascript hljs">a.push(<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">▍Ajout d'éléments au début du tableau</font> </h3><br>  Pour ajouter des éléments au début du tableau, utilisez la méthode <code>unshift()</code> . <br><br><pre> <code class="javascript hljs">a.unshift(<span class="hljs-number"><span class="hljs-number">0</span></span>) a.unshift(<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Suppression des éléments du tableau</font> </h3><br>  Vous pouvez supprimer un élément de la fin du tableau tout en renvoyant cet élément à l'aide de la méthode <code>pop()</code> . <br><br><pre> <code class="javascript hljs">a.pop()</code> </pre> <br>  De même, en utilisant la méthode <code>shift()</code> , vous pouvez supprimer un élément du début du tableau. <br><br><pre> <code class="javascript hljs">a.shift()</code> </pre> <br>  La même chose, mais indiquant déjà la position de la suppression des éléments et leur nombre, se fait en utilisant la méthode <code>splice()</code> . <br><br><pre> <code class="javascript hljs">a.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    2     a.splice(3, 2) //    2 ,    3</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Suppression des éléments du tableau et insertion d'autres éléments à la place</font> </h3><br>  Afin d'utiliser une opération pour supprimer certains éléments du tableau et insérer d'autres éléments à la place, la méthode familière <code>splice()</code> est utilisée. <br><br>  Par exemple, ici, nous supprimons 3 éléments du tableau à partir de l'index 2, après quoi nous ajoutons deux autres éléments au même endroit: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] a.splice(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 2, 'a', 'b', 6 ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Combiner plusieurs tableaux</font> </h3><br>  Pour combiner plusieurs tableaux, vous pouvez utiliser la méthode <code>concat()</code> , qui renvoie un nouveau tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a.concat(b) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(c) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 2, 3, 4 ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Trouver des éléments dans un tableau</font> </h3><br>  Dans la norme ES5, la méthode <code>indexOf()</code> est apparue, qui retourne l'index de la première occurrence de l'élément de tableau souhaité.  Si l'élément est introuvable dans le tableau, <code>-1</code> est renvoyé. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.indexOf(<span class="hljs-number"><span class="hljs-number">5</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//4 console.log(a.indexOf(23)) //-1</span></span></code> </pre> <br>  La méthode <code>lastIndexOf()</code> renvoie l'index de la dernière occurrence de l'élément dans le tableau, ou <code>-1</code> si l'élément n'est pas trouvé. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.lastIndexOf(<span class="hljs-number"><span class="hljs-number">5</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//7 console.log(a.lastIndexOf(23)) //-1</span></span></code> </pre> <br>  Dans ES6, la méthode <code>find()</code> des tableaux est apparue, qui effectue une recherche de tableau en utilisant la fonction qui lui est transmise.  Si la fonction renvoie <code>true</code> , la méthode renvoie la valeur du premier élément trouvé.  Si l'élément est introuvable, la fonction retournera <code>undefined</code> . <br><br>  Son utilisation peut se présenter comme suit. <br><br><pre> <code class="javascript hljs">a.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.id === my_id)</code> </pre> <br>  Ici, dans un tableau contenant des objets, un élément est recherché, dont la propriété <code>id</code> est égale à celle spécifiée. <br><br>  La méthode <code>findIndex()</code> est similaire à <code>find()</code> , mais elle retourne l'index de l'élément trouvé ou <code>undefined</code> . <br><br>  La méthode <code>includes()</code> est apparue dans ES7, ce qui vous permet de vérifier la présence d'un certain élément dans un tableau.  Il renvoie <code>true</code> ou <code>false</code> , trouvant ou ne trouvant pas un élément intéressant le programmeur. <br><br><pre> <code class="javascript hljs">a.includes(value)</code> </pre> <br>  En utilisant cette méthode, il est possible de vérifier la présence de certains éléments et non du tableau entier, mais seulement d'une partie de celui-ci, en commençant par l'index spécifié lors de l'appel de cette méthode.  L'index est spécifié à l'aide du deuxième paramètre facultatif de cette méthode. <br><br><pre> <code class="javascript hljs">a.includes(value, i)</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Obtention d'un fragment d'un tableau</font> </h3><br>  Afin d'obtenir une copie d'un fragment du tableau en tant que nouveau tableau, vous pouvez utiliser la méthode <code>slice()</code> .  Si cette méthode est appelée sans arguments, le tableau renvoyé sera une copie complète de l'original.  Il prend deux paramètres facultatifs.  Le premier définit l'indice de départ du fragment, le second définit la fin.  Si l'index de fin n'est pas spécifié, le tableau est copié de l'index de début spécifié vers la fin. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.slice(<span class="hljs-number"><span class="hljs-number">4</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//[ 5, 6, 7, 8, 9 ] console.log(a.slice(3,7)) //[ 4, 5, 6, 7 ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Sort array</font> </h3><br>  Pour organiser le tri des éléments du tableau par ordre alphabétique ( <code>0-9A-Za-z</code> ), la méthode <code>sort()</code> est utilisée sans lui passer d'arguments. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>] a.sort() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 10, 11, 2, 3 ] const b = [1, 'a', 'Z', 3, 2, 11] b.sort() console.log(b) //[ 1, 11, 2, 3, 'Z', 'a' ]</span></span></code> </pre> <br>  Vous pouvez transmettre une fonction à cette méthode qui définit l'ordre de tri.  La fonction accepte, pour la comparaison de deux éléments, les paramètres <code>a</code> et <code>b</code> .  Il renvoie un nombre négatif si <code>a</code> inférieur à <code>b</code> selon un critère, 0 s'ils sont égaux et un nombre positif si <code>a</code> supérieur à <code>b</code> .  Lors de l'écriture d'une fonction similaire pour trier des tableaux numériques, elle peut renvoyer le résultat de la soustraction de <code>a</code> et <code>b</code> .  Ainsi, renvoyer le résultat de l'évaluation de l'expression <code>a - b</code> signifie trier le tableau dans l'ordre croissant, renvoyer le résultat de l'évaluation de l'expression <code>b - a</code> triera le tableau dans l'ordre décroissant. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b)) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 2, 3, 10, 11 ] console.log(a.sort((a, b) =&gt; b - a)) //[ 11, 10, 3, 2, 1 ]</span></span></code> </pre> <br>  Pour inverser la séquence des éléments du tableau, vous pouvez utiliser la méthode <code>reverse()</code> .  Comme <code>sort()</code> , il modifie le tableau pour lequel il est appelé. <br><br><h3>  <font color="#3AC1EF">▍Obtenir une représentation sous forme de chaîne d'un tableau</font> </h3><br>  Pour obtenir une représentation sous forme de chaîne d'un tableau, vous pouvez utiliser sa <code>toString()</code> . <br><br><pre> <code class="javascript hljs">a.toString()</code> </pre> <br>  Un résultat similaire est donné par la méthode <code>join()</code> , appelée sans arguments. <br><br><pre> <code class="javascript hljs">a.join()</code> </pre> <br>  Pour cela, comme argument, vous pouvez passer les éléments séparateurs. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.toString()) <span class="hljs-comment"><span class="hljs-comment">//1,10,3,2,11 console.log(a.join()) //1,10,3,2,11 console.log(a.join(', ')) //1, 10, 3, 2, 11</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Création de copies de tableaux</font> </h3><br>  Pour créer une copie du tableau en copiant les valeurs du tableau d'origine dans le nouveau tableau, vous pouvez utiliser la méthode <code>Array.from()</code> .  Il convient également pour créer des tableaux à partir d'objets de type tableau (à partir de chaînes, par exemple). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-string"><span class="hljs-string">'a string'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(a) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(b) <span class="hljs-comment"><span class="hljs-comment">//[ 'a', ' ', 's', 't', 'r', 'i', 'n', 'g' ]</span></span></code> </pre> <br>  La méthode <code>Array.of()</code> peut également être utilisée pour copier des tableaux, ainsi que pour «assembler» des tableaux à partir de divers éléments.  Par exemple, pour copier les éléments d'un tableau dans un autre, vous pouvez utiliser la construction suivante. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.of(...a) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(b) <span class="hljs-comment"><span class="hljs-comment">// [ 1, 10, 3, 2, 11 ]</span></span></code> </pre> <br>  La méthode <code>copyWithin()</code> est utilisée pour copier les éléments du tableau à un certain endroit de ce tableau lui-même.  Son premier argument spécifie l'index initial de la position cible, le second l'index initial de la position de la source de l'élément et le troisième paramètre, facultatif, indique l'indice final de la position de la source de l'élément.  Si vous ne le spécifiez pas, tout sera copié à l'emplacement spécifié du tableau, à partir de l'index initial de la position source jusqu'à la fin du tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] a.copyWithin(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//[ 3, 4, 5, 4, 5 ]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Cycles</font> </h2><br>  En parlant des tableaux ci-dessus, nous avons déjà trouvé quelques façons d'organiser les boucles.  Cependant, les boucles en JavaScript ne sont pas seulement utilisées pour travailler avec des tableaux, et nous avons considéré loin de tous leurs types.  Par conséquent, nous allons maintenant consacrer un peu de temps à discuter des différentes manières d'organiser les boucles en JavaScript et parler de leurs fonctionnalités. <br><br><h3>  <font color="#3AC1EF">▍ pour boucle</font> </h3><br>  Prenons un exemple d'application de ce cycle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.length; i++) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(list[i]) <span class="hljs-comment"><span class="hljs-comment">//,     console.log(i) // }</span></span></code> </pre> <br>  Comme déjà mentionné, vous pouvez interrompre l'exécution d'une telle boucle à l'aide de la commande <code>break</code> , et vous pouvez ignorer l'itération en cours et passer directement à la suivante à l'aide de la commande <code>continue</code> . <br><br><h3>  <font color="#3AC1EF">▍ pour chaque cycle</font> </h3><br>  Nous avons également discuté de ce cycle.  Voici un exemple d'itération sur un tableau l'utilisant. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>] list.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item, index</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(item) <span class="hljs-comment"><span class="hljs-comment">// console.log(index) // }) //     ,      list.forEach(item =&gt; console.log(item))</span></span></code> </pre> <br>  Rappelez-vous que pour interrompre un tel cycle, il est nécessaire de lever une exception, c'est-à-dire que si vous devez l'interrompre lors de l'utilisation d'un cycle, il est préférable de choisir un autre cycle. <br><br><h3>  <font color="#3AC1EF">▍ Faire ... en boucle</font> </h3><br>  C'est ce qu'on appelle le «cycle de postcondition».  Une telle boucle sera exécutée au moins une fois avant de vérifier la condition de fin de la boucle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(list[i]) <span class="hljs-comment"><span class="hljs-comment">// console.log(i) // i = i + 1 } while (i &lt; list.length)</span></span></code> </pre> <br>  Il peut être interrompu à l'aide de la commande <code>break</code> , vous pouvez passer à sa prochaine itération avec la commande <code>continue</code> . <br><br><h3>  <font color="#3AC1EF">▍ en boucle</font> </h3><br>  C'est ce que l'on appelle le «cycle préconditionné».  Si, à l'entrée du cycle, la condition de poursuite du cycle est fausse, elle ne sera pas exécutée une seule fois. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; list.length) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(list[i]) <span class="hljs-comment"><span class="hljs-comment">// console.log(i) // i = i + 1 }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ pour ... en boucle</font> </h3><br>  Cette boucle vous permet d'itérer sur toutes les propriétés énumérées d'un objet par leurs noms. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-string"><span class="hljs-string">'three'</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> object) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(property) <span class="hljs-comment"><span class="hljs-comment">//  console.log(object[property]) //  }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Cycle pour ... de</font> </h3><br>  Le cycle <code>for...of</code> combine la commodité du cycle <code>forEach</code> et la possibilité d'interrompre son fonctionnement à l'aide d'outils ordinaires. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  for (const value of ['a', 'b', 'c']) { console.log(value) // } //       `entries()` for (const [index, value] of ['a', 'b', 'c'].entries()) { console.log(index) // console.log(value) // }</span></span></code> </pre> <br>  Notez qu'ici, dans l'en-tête de la boucle, le mot clé <code>const</code> est utilisé et non, comme vous vous en doutez, <code>let</code> .  Si les variables à l'intérieur du bloc de boucle n'ont pas besoin d'être réaffectées, alors <code>const</code> nous convient tout à fait. <br>  Si nous comparons les boucles <code>for...in</code> et <code>for...of</code> , il s'avère que <code>for...in</code> répète les noms des propriétés et <code>for...of</code> - les valeurs des propriétés. <br><br><h2>  <font color="#3AC1EF">Boucles et étendues</font> </h2><br>  Avec les boucles et les étendues variables, il existe une fonction JavaScript qui peut poser des problèmes au développeur.  Pour résoudre ces problèmes, <code>let</code> boucles, des étendues et des mots <code>let</code> clés <code>var</code> et <code>let</code> . <br><br>  Prenons un exemple. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operations = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { operations.push(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) }) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operation <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> operations) { operation() }</code> </pre> <br>  La boucle effectue 5 itérations, à chacune desquelles une nouvelle fonction est ajoutée au tableau d' <code>operations</code> .  Cette fonction affiche dans la console la valeur du compteur de boucle - <code>i</code> .  Une fois les fonctions ajoutées au tableau, nous parcourons ce tableau et appelons les fonctions qui en sont les éléments. <br><br>  En exécutant un tel code, vous pouvez vous attendre au résultat affiché ci-dessous. <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Mais en fait, il déduit ce qui suit. <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  Pourquoi en est-il ainsi?  Le fait est qu'en tant que compteur de boucles, nous utilisons une variable déclarée à l'aide du mot clé <code>var</code> . <br><br>  Étant donné que les déclarations de ces variables remontent en haut de la portée, le code ci-dessus est similaire au suivant. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operations = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { operations.push(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) }) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operation <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> operations) { operation() }</code> </pre> <br>  En conséquence, il s'avère que dans la boucle <code>for...of</code> , dans laquelle nous itérons sur le tableau, la variable <code>i</code> est toujours visible, elle est 5, par conséquent, en se référant à <code>i</code> dans toutes les fonctions, nous imprimons le nombre 5. <br><br>  Comment changer le comportement du programme pour qu'il fasse ce qu'on attend de lui? <br><br>  La solution la plus simple à ce problème consiste à utiliser le mot clé <code>let</code> .  Il, comme nous l'avons déjà dit, est apparu dans ES6, son utilisation vous permet de vous débarrasser de certaines bizarreries caractéristiques de <code>var</code> . <br><br>  En particulier, dans l'exemple ci-dessus, il suffit de changer <code>var</code> pour <code>let</code> et tout fonctionnera comme il se doit. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operations = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { operations.push(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) }) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operation <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> operations) { operation() }</code> </pre> <br>  Maintenant, à chaque itération de la boucle, chaque fonction ajoutée au tableau d' <code>operations</code> obtient sa propre copie de <code>i</code> .  N'oubliez pas que dans cette situation, vous ne pouvez pas utiliser le mot clé <code>const</code> , car la valeur de <code>i</code> dans la boucle change. <br><br>  Une autre façon de résoudre ce problème, qui était souvent utilisé avant la norme ES6, lorsque le mot clé <code>let</code> n'était pas là, était d'utiliser IIFE. <br><br>  Avec cette approche, la valeur de <code>i</code> stockée dans la fermeture, et la fonction renvoyée par IIFE et ayant accès à la fermeture entre dans le tableau.  Cette fonction peut être exécutée lorsqu'elle devient nécessaire.  Voici à quoi ça ressemble. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operations = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { operations.push(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(j</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(j) })(i)) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operation <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> operations) { operation() }</code> </pre> <br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Aujourd'hui, nous avons parlé des tableaux et des boucles en JavaScript.  Le sujet de notre prochain article est la gestion des exceptions, les modèles d'utilisation des points-virgules et les littéraux de modèle. <br><br>  <b>Chers lecteurs!</b>  Quelles méthodes de travail avec les tableaux en JavaScript utilisez-vous le plus souvent? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430380/">https://habr.com/ru/post/fr430380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430366/index.html">VR-cuisine: ce qui n'est pas visible dans le casque</a></li>
<li><a href="../fr430372/index.html">Voiture à hydrogène. Est-il temps de dire au revoir à l'essence?</a></li>
<li><a href="../fr430374/index.html">Ingénierie des données et plus encore: bandes vidéo Wrike et diapositives de la réunion</a></li>
<li><a href="../fr430376/index.html">Guide JavaScript, partie 6: exceptions, points-virgules, littéraux de modèle</a></li>
<li><a href="../fr430378/index.html">J2CL - Mieux vaut tard que jamais</a></li>
<li><a href="../fr430382/index.html">Guide JavaScript Partie 4: Fonctionnalités</a></li>
<li><a href="../fr430384/index.html">Création de cartes à partir d'entités de bruit</a></li>
<li><a href="../fr430386/index.html">Construction d'une centrale de stockage à semi-conducteurs en Inde</a></li>
<li><a href="../fr430388/index.html">Conférence Web Summit</a></li>
<li><a href="../fr430392/index.html">Comment développer et tester des API avec mon «vélo» PieceofScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>