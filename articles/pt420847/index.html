<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ú ü•ò üíÉüèº Introdu√ß√£o √† programa√ß√£o de sombreador para layouts üêà ‚ôªÔ∏è üë≥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O WebGL j√° existe h√° muito tempo, muitos artigos foram escritos sobre shaders, h√° uma s√©rie de li√ß√µes. Mas, na maioria das vezes, s√£o muito complicado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdu√ß√£o √† programa√ß√£o de sombreador para layouts</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420847/"><p><img src="https://habrastorage.org/webt/mx/-v/ry/mx-vryd99xgt73gzsgzhfvcqpe0.jpeg"></p><br><p> O WebGL j√° existe h√° muito tempo, muitos artigos foram escritos sobre shaders, h√° uma s√©rie de li√ß√µes.  Mas, na maioria das vezes, s√£o muito complicados para o designer de layout.  √â ainda melhor dizer que eles cobrem grandes quantidades de informa√ß√µes que o desenvolvedor do game engine precisa e n√£o o designer do layout.  Eles come√ßam imediatamente com a constru√ß√£o de uma cena complexa, uma c√¢mera, luz ... Em um site comum, para criar um par de efeitos com fotos, todo esse conhecimento √© redundante.  Como resultado, as pessoas fazem estruturas arquitet√¥nicas muito complexas e escrevem shaders longos e longos para a√ß√µes muito simples em ess√™ncia. </p><br><p>  Tudo isso levou a uma introdu√ß√£o aos aspectos do trabalho com shaders que provavelmente s√£o √∫teis ao designer de layout para criar v√°rios efeitos 2D com fotos no site.  Obviamente, ajustados pelo fato de que eles pr√≥prios s√£o relativamente raramente usados ‚Äã‚Äãno design de interface.  Criaremos um modelo inicial em JS puro, sem bibliotecas de terceiros, e consideraremos as id√©ias de criar alguns efeitos populares baseados na troca de pixels, dif√≠ceis de fazer no SVG, mas ao mesmo tempo eles s√£o facilmente implementados usando shaders. </p><a name="habracut"></a><br><blockquote> Sup√µe-se que o leitor j√° esteja familiarizado com a <code>canvas</code> , descreve o que √© o WebGL e possui um conhecimento m√≠nimo de matem√°tica.  Alguns pontos ser√£o descritos de maneira simplista, n√£o acad√™mica, a fim de fornecer uma compreens√£o pr√°tica das tecnologias para trabalhar com elas, e n√£o uma teoria completa de sua cozinha interna ou termos de aprendizado.  Existem livros inteligentes para isso. </blockquote><p>  <em>Deve-se notar imediatamente que os editores integrados ao artigo do CodePen t√™m a capacidade de influenciar o desempenho do que √© feito neles.</em>  <em>Portanto, antes de escrever um coment√°rio, informando que algo est√° diminuindo a velocidade do seu macbook, verifique se o problema n√£o vem deles.</em> </p><br><h2 id="osnovnye-idei">  Id√©ias principais </h2><br><p>  <strong>O que √© um shader?</strong> </p><br><p>  O que √© um shader de fragmento?  Este √© essencialmente um pequeno programa.  √â executado para cada pixel na <code>anvas</code> .  Se tivermos uma <code>canvas</code> tamanho 1000x500px, esse programa ser√° executado 500.000 vezes, sempre recebendo como par√¢metros de entrada as coordenadas do pixel para o qual est√° sendo executado no momento.  Isso tudo acontece na GPU em uma variedade de threads paralelos.  No processador central, esses c√°lculos levariam muito mais tempo. </p><br><p>  Um sombreador de v√©rtice tamb√©m √© um programa, mas n√£o √© executado para todos os pixels da <code>canvas</code> , mas para cada v√©rtice nas formas em que tudo √© constru√≠do no espa√ßo tridimensional.  Tamb√©m paralelo a todos os v√©rtices.  Assim, a entrada recebe as coordenadas do v√©rtice, n√£o o pixel. </p><br><p>  Al√©m disso, no contexto de nossa tarefa, ocorre o seguinte: </p><br><ul><li>  Tomamos um conjunto de coordenadas dos v√©rtices do ret√¢ngulo, nos quais a fotografia ser√° "desenhada". </li><li>  Um sombreador de v√©rtice para cada v√©rtice considera sua localiza√ß√£o no espa√ßo.  Para n√≥s, isso se resumir√° a um caso especial - um avi√£o paralelo √† tela.  Fotos em 3d n√£o precisamos.  A proje√ß√£o subsequente no plano da tela n√£o pode dizer nada. </li><li>  Al√©m disso, para cada fragmento vis√≠vel, e em nosso contexto para todos os fragmentos de pixel, √© executado um sombreador de fragmento, que tira uma foto e as coordenadas atuais, conta alguma coisa e fornece cor para esse pixel espec√≠fico. </li><li>  Se n√£o houvesse l√≥gica no shader de fragmento, o comportamento de tudo isso ser√° semelhante ao <code>drawImage()</code> da <code>canvas</code> .  Mas ent√£o adicionamos essa l√≥gica e obtemos muitas coisas interessantes. </li></ul><br><p>  Esta √© uma descri√ß√£o muito simplificada, mas deve ficar claro quem faz o qu√™. </p><br><p>  <strong>Um pouco sobre sintaxe</strong> </p><br><p>  Os shaders s√£o escritos em GLSL - OpenGL Shading Language.  Essa linguagem √© muito parecida com C.  N√£o faz sentido descrever toda a sintaxe e os m√©todos padr√£o aqui, mas voc√™ sempre pode usar a folha de dicas: </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler com fotos</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/id/vb/6e/idvb6ew9k7ackf94bjviuxavhxc.jpeg"><br><img src="https://habrastorage.org/webt/ye/ax/b4/yeaxb44uvcjkhir92ezxcsnc2oo.jpeg"><br><img src="https://habrastorage.org/webt/f7/2q/5q/f72q5qifi99xwv5nsqfnkb2x1au.jpeg"><br><img src="https://habrastorage.org/webt/8c/ty/in/8ctyinenggjs8gutaj484oreep4.jpeg"></p></div></div><br><p>  Cada sombreador tem uma fun√ß√£o principal, com a qual sua execu√ß√£o come√ßa.  Par√¢metros de entrada padr√£o para sombreadores e sa√≠da dos resultados de seu trabalho s√£o implementados atrav√©s de vari√°veis ‚Äã‚Äãespeciais com o prefixo <code>gl_</code> .  Eles s√£o reservados com anteced√™ncia e est√£o dispon√≠veis dentro desses mesmos shaders.  Portanto, as coordenadas do v√©rtice para o sombreador de v√©rtice est√£o na vari√°vel <code>gl_Position</code> , as coordenadas do fragmento (pixel) para o sombreador de fragmento est√£o em <code>gl_FragCoord</code> , etc.  Voc√™ sempre pode encontrar a lista completa de vari√°veis ‚Äã‚Äãespeciais dispon√≠veis na mesma folha de dicas. </p><br><p>  Os principais tipos de vari√°veis ‚Äã‚Äãno GLSL s√£o bastante despretensiosos - <code>void</code> , <code>bool</code> , <code>int</code> , <code>float</code> ... Se voc√™ trabalhou com qualquer linguagem semelhante a C, j√° os viu.  Existem outros tipos, em particular vetores de diferentes dimens√µes - <code>vec2</code> , <code>vec3</code> , <code>vec4</code> .  N√≥s os usaremos constantemente para coordenadas e cores.  As vari√°veis ‚Äã‚Äãque podemos criar s√£o de tr√™s modifica√ß√µes importantes: </p><br><ul><li>  <strong>Uniforme</strong> - dados globais em todos os sentidos.  Passado de fora, o mesmo para todas as chamadas de shaders de v√©rtice e fragmento. </li><li>  <strong>Atributo</strong> - Esses dados s√£o transferidos com mais precis√£o e para cada chamada de sombreador pode ser diferente. </li><li>  <strong>Varia√ß√£o</strong> - Necess√°rio para transferir dados de shaders de v√©rtice para shaders de fragmentos. </li></ul><br><blockquote>  √â √∫til prefixar u / a / v para todas as vari√°veis ‚Äã‚Äãnos shaders para facilitar a compreens√£o de quais dados vieram. </blockquote><p>  Acredito que vale a pena seguir para um exemplo pr√°tico para assistir imediatamente a tudo isso em a√ß√£o e n√£o carregar sua mem√≥ria. </p><br><h2 id="gotovim-startovyy-shablon">  Modelo de in√≠cio de cozinha </h2><br><p>  Vamos come√ßar com JS.  Como geralmente acontece quando se trabalha com <code>canvas</code> , precisamos dela e do contexto.  Para n√£o carregar o c√≥digo de amostra, criaremos vari√°veis ‚Äã‚Äãglobais: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CANVAS = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.canvas); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GL = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'webgl'</span></span>);</code> </pre> <br><p>  Pule o momento associado ao tamanho da <code>canvas</code> e seu rec√°lculo ao redimensionar a janela do navegador.  Esse c√≥digo est√° inclu√≠do nos exemplos e geralmente depende do restante do layout.  N√£o faz sentido se concentrar nele.  Vamos para as a√ß√µes com o WebGL. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shaders</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShaders</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PROGRAM</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM, shaders.vertex)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM, shaders.fragment)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linkProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  Primeiro, compilamos os shaders (ser√° um pouco menor), criamos um programa, adicionamos os dois shaders a ele e criamos um link.  Neste ponto, a compatibilidade dos shaders √© verificada.  Lembre-se de vari√°veis ‚Äã‚Äãvari√°veis ‚Äã‚Äãque s√£o passadas do v√©rtice para o fragmento?  - Em particular, seus conjuntos s√£o verificados aqui para que mais tarde no processo n√£o ocorra que algo n√£o tenha sido transmitido ou transmitido, mas que n√£o seja.  Obviamente, essa verifica√ß√£o n√£o revelar√° erros l√≥gicos, acho que isso √© compreens√≠vel. </p><br><p>  As coordenadas dos v√©rtices ser√£o armazenadas em uma matriz de buffer especial e ser√£o transmitidas em partes, um v√©rtice, para cada chamada de sombreador.  A seguir, descrevemos alguns detalhes para trabalhar com essas pe√ßas.  Primeiramente, usaremos as coordenadas do v√©rtice no sombreador atrav√©s da <code>a_position</code> atributo <code>a_position</code> .  Pode ser chamado de forma diferente, n√£o importa.  N√≥s obtemos sua localiza√ß√£o (isso √© algo como um ponteiro em C, mas n√£o um ponteiro, mas um n√∫mero de entidade que existe apenas dentro do programa). </p><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertexPositionAttribute = GL.getAttribLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'a_position'</span></span>);</code> </pre> <br><p>  A seguir, indicamos que uma matriz com coordenadas ser√° passada por essa vari√°vel (no pr√≥prio shader, j√° a perceberemos como um vetor).  O WebGL descobrir√° de forma independente quais coordenadas de quais pontos de nossas formas devem ser passadas para as quais o sombreador chama.  Definimos apenas os par√¢metros para a matriz vetorial que ser√° transmitida: dimens√£o - 2 (transmitiremos as coordenadas <code>(x,y)</code> ), consiste em n√∫meros e n√£o √© normalizado.  Os √∫ltimos par√¢metros n√£o s√£o interessantes para n√≥s, deixamos zeros por padr√£o. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.enableVertexAttribArray</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">vertexPositionAttribute</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.vertexAttribPointer</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">vertexPositionAttribute</span></span>, 2, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.FLOAT</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>, 0, 0);</code> </pre> <br><p>  Agora crie o buffer em si com as coordenadas dos v√©rtices do nosso plano, nos quais a foto ser√° exibida.  As coordenadas "2d" s√£o mais claras, mas, para nossas tarefas, isso √© a coisa mais importante. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPlane</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.ARRAY_BUFFER, GL.createBuffer()</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bufferData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GL.ARRAY_BUFFER, new Float32Array([ -1, -1, -1, 1, 1, -1, 1, 1 ])</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">STATIC_DRAW</span></span></span><span class="hljs-function"> ); }</span></span></code> </pre> <br><p>  Este quadrado ser√° suficiente para todos os nossos exemplos.  <code>STATIC_DRAW</code> significa que o buffer √© carregado uma vez e depois ser√° reutilizado.  N√£o enviaremos nada novamente. </p><br><p>  Antes de passar para os pr√≥prios shaders, vejamos a compila√ß√£o deles: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShaders</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">vertex</span></span>: compileShader( GL.VERTEX_SHADER, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.shaders.vertex).textContent ), <span class="hljs-attr"><span class="hljs-attr">fragment</span></span>: compileShader( GL.FRAGMENT_SHADER, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.shaders.fragment).textContent ) }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compileShader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type, source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shader = GL.createShader(type); GL.shaderSource(shader, source); GL.compileShader(shader); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shader; }</code> </pre> <br><p>  N√≥s obtemos o c√≥digo de sombreamento dos elementos da p√°gina, criamos um sombreador e o compilamos.  Em teoria, voc√™ pode armazenar o c√≥digo do sombreador em arquivos separados e carreg√°-lo durante a montagem como uma string no lugar certo, mas o CodePen n√£o fornece essa oportunidade para exemplos.  Muitas li√ß√µes sugerem escrever c√≥digo diretamente na linha em JS, mas o idioma n√£o o transforma em um idioma conveniente.  Embora, claro, tenha gosto e cor ... </p><br><p>  Se ocorrer um erro durante a compila√ß√£o, o script continuar√° sendo executado, mostrando alguns avisos no console que n√£o fazem muito sentido.  √â √∫til examinar os logs ap√≥s a compila√ß√£o para n√£o sobrecarregar o c√©rebro com o que n√£o foi compilado l√°: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">console</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.log</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getShaderInfoLog</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span>));</code> </pre> <br><blockquote>  O WebGL fornece v√°rias op√ß√µes diferentes para rastrear problemas ao compilar sombreadores e criar um programa, mas, na pr√°tica, acontece que em tempo real n√£o podemos consertar nada.  Muitas vezes, seremos guiados pelo pensamento "caiu - depois caiu" e n√£o carregaremos o c√≥digo com v√°rias verifica√ß√µes extras. </blockquote><p>  <strong>Vamos passar para os pr√≥prios shaders</strong> </p><br><p>  Como teremos apenas um plano com o qual n√£o faremos nada, basta um simples sombreador de v√©rtices, o que faremos desde o in√≠cio.  Os principais esfor√ßos ser√£o focados nos shaders de fragmentos e todos os exemplos subsequentes ser√£o relevantes para eles. </p><br><blockquote>  Tente escrever c√≥digo de sombreador com nomes de vari√°veis ‚Äã‚Äãmais ou menos significativos.  Na rede, voc√™ encontrar√° exemplos em que fun√ß√µes com matem√°tica vigorosa para 200 linhas de texto cont√≠nuo ser√£o reunidas a partir de vari√°veis ‚Äã‚Äãde uma letra, mas apenas porque algu√©m o faz n√£o significa que vale a pena repetir.  Essa abordagem n√£o √© uma ‚Äúespecificidade do trabalho com GL‚Äù, √© uma c√≥pia e pasta banal de c√≥digos-fonte do s√©culo passado, escritos por pessoas que, na juventude, tinham restri√ß√µes no tamanho dos nomes de vari√°veis. </blockquote><p>  Primeiro, o vertex shader.  Um vetor 2D com coordenadas <code>(x,y)</code> ser√° transferido para a vari√°vel de atributo <code>a_position</code> , como dissemos.  O sombreador deve retornar um vetor de quatro valores <code>(x,y,z,w)</code> .  Ele n√£o mover√° nada no espa√ßo; portanto, no eixo z, simplesmente zeramos tudo e configuramos o valor de w para a unidade padr√£o.  Se voc√™ est√° se perguntando por que existem quatro e n√£o tr√™s coordenadas, use a pesquisa de rede para "coordenadas uniformes". </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'vertex-shader'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'x-shader/x-vertex'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> precision mediump float; attribute vec2 a_position; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">void</span></span></span><span class="actionscript"> main() { gl_Position = vec4(position, </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">0</span></span></span><span class="actionscript">, </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1</span></span></span><span class="actionscript">); } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  O resultado do trabalho √© registrado em uma vari√°vel especial <code>gl_Position</code> .  Os sombreadores n√£o t√™m uma <code>return</code> no sentido pleno da palavra; eles anotam todos os resultados de seu trabalho em vari√°veis ‚Äã‚Äãespecialmente reservadas para esses fins. </p><br><blockquote>  Observe o trabalho de precis√£o para o tipo de dados flutuante.  Para evitar alguns dos problemas em dispositivos m√≥veis, a precis√£o deve ser pior que o highp e deve ser a mesma nos dois shaders.  Isso √© mostrado como um exemplo aqui, mas √© uma boa pr√°tica em telefones desativar completamente essa beleza com shaders. </blockquote><p>  O sombreador de fragmento sempre retornar√° a mesma cor para come√ßar.  Nosso quadrado ocupar√° toda a <code>canvas</code> ; portanto, aqui definimos a cor de cada pixel: </p><br><pre> <code class="hljs pgsql">&lt;script id=<span class="hljs-string"><span class="hljs-string">'fragment-shader'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=<span class="hljs-string"><span class="hljs-string">'x-shader/x-fragment'</span></span>&gt; <span class="hljs-type"><span class="hljs-type">precision</span></span> mediump <span class="hljs-type"><span class="hljs-type">float</span></span>; #define GOLD vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.86</span></span>, <span class="hljs-number"><span class="hljs-number">0.6</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) <span class="hljs-type"><span class="hljs-type">void</span></span> main() { gl_FragColor = GOLD; } &lt;/script&gt;</code> </pre> <br><p>  Voc√™ pode prestar aten√ß√£o aos n√∫meros que descrevem a cor.  Isso √© familiar a todos os tip√≥grafos RGBA, apenas normalizados.  Os valores n√£o s√£o n√∫meros inteiros de 0 a 255, mas fracion√°rios de 0 a 1. A ordem √© a mesma. </p><br><blockquote>  N√£o se esque√ßa de usar o pr√©-processador para todas as constantes m√°gicas em projetos reais - isso torna o c√≥digo mais compreens√≠vel sem afetar o desempenho (a substitui√ß√£o, como em C, ocorre durante a compila√ß√£o). </blockquote><p>  Vale ressaltar outro ponto sobre o pr√©-processador: </p><br><blockquote>  O uso de verifica√ß√µes constantes #ifdef GL_ES em v√°rias li√ß√µes √© desprovido de significado pr√°tico.  hoje em nosso navegador, simplesmente n√£o existem outras op√ß√µes cont√°beis. </blockquote><p>  Mas √© hora de j√° olhar para o resultado: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/JaoYMj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  O quadrado dourado indica que os shaders est√£o funcionando conforme o esperado.  Faz sentido brincar um pouco com eles antes de come√ßar a trabalhar com fotos. </p><br><p>  <strong>Vetores de gradiente e transforma√ß√£o</strong> </p><br><p>  Normalmente, os tutoriais WebGL come√ßam desenhando gradientes.  Isso faz pouco sentido pr√°tico, mas ser√° √∫til observar alguns pontos. </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gl_FragColor = vec4(gl_FragCoord.zxy / <span class="hljs-number"><span class="hljs-number">500.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Neste exemplo, usamos as coordenadas do pixel atual como cor.  Voc√™ ver√° isso frequentemente em exemplos na rede.  Ambos s√£o vetores.  Portanto, ningu√©m se incomoda em misturar tudo de uma vez.  Os evangelistas TypeScript devem ter um ataque aqui.  Um ponto importante √© como obtemos apenas parte das coordenadas do vetor.  Propriedades <code>.x</code> , <code>.y</code> , <code>.z</code> , <code>.xy</code> , <code>.zy</code> , <code>.xyz</code> , <code>.zyx</code> , <code>.xyzw</code> , etc.  em seq√º√™ncias diferentes, voc√™ pode extrair os elementos de um vetor em uma determinada ordem na forma de outro vetor.  Muito convenientemente implementado.  Al√©m disso, um vetor de dimens√£o superior pode ser criado a partir de um vetor de dimens√£o inferior, adicionando os valores ausentes, como fizemos. </p><br><blockquote>  Sempre indique explicitamente a parte fracion√°ria dos n√∫meros.  N√£o h√° convers√£o autom√°tica int -&gt; float aqui. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/vzENvx" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>Uniformes e passagem do tempo</strong> </p><br><p>  O pr√≥ximo exemplo √∫til √© o uso de uniformes.  Esses s√£o os dados mais comuns para todas as chamadas de sombreador.  N√≥s obtemos sua localiza√ß√£o da mesma maneira que para vari√°veis ‚Äã‚Äãde atributo, por exemplo: </p><br><pre> <code class="hljs delphi">GL.getUniformLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'u_time'</span></span>)</code> </pre> <br><p>  Em seguida, podemos definir os valores antes de cada quadro.  Assim como os vetores, existem muitos m√©todos semelhantes aqui, come√ßando com a palavra <code>uniform</code> , em seguida, vem a dimens√£o da vari√°vel (1 para n√∫meros, 2, 3 ou 4 para vetores) e o tipo (f - float, i - int, v - vector) . </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_time')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeStamp</span></span></span><span class="hljs-function"> / 1000.0); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawArrays</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TRIANGLE_STRIP, 0, 4)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">window</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestAnimationFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(draw)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><blockquote>  De fato, nem sempre precisamos de 60fps nas interfaces.  √â bem poss√≠vel adicionar uma lentid√£o ao requestAnimationFrame e reduzir a frequ√™ncia dos quadros de redesenho. </blockquote><p>  Por exemplo, mudaremos a cor do preenchimento.  Nos shaders, todas as fun√ß√µes matem√°ticas b√°sicas est√£o dispon√≠veis - <code>sin</code> , <code>cos</code> , <code>tan</code> , <code>asin</code> , <code>acos</code> , <code>atan</code> , <code>pow</code> , <code>exp</code> , <code>log</code> , <code>sqrt</code> , <code>abs</code> e outras.  Vamos usar dois deles. </p><br><pre> <code class="hljs cpp">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u_time; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_FragColor = vec4( <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time)), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time * <span class="hljs-number"><span class="hljs-number">3.0</span></span>)), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)), <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  O tempo em tais anima√ß√µes √© um conceito relativo.  Aqui, usamos os valores fornecidos pelo <code>requestAnimationFrame</code> , mas podemos criar nosso pr√≥prio "tempo".  A id√©ia √© que, se alguns par√¢metros s√£o descritos em fun√ß√£o do tempo, podemos mudar o tempo na dire√ß√£o oposta, desacelerar, acelerar ou retornar ao seu estado original.  Isso pode ser muito √∫til. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/VGYvNP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Mas h√° exemplos abstratos suficientes, vamos continuar usando imagens. </p><br><p>  <strong>Carregando uma imagem em uma textura</strong> </p><br><p>  Para usar a imagem, precisamos criar uma textura, que ser√° renderizada em nosso avi√£o.  Para come√ßar, carregue a pr√≥pria imagem: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Image(); image.crossOrigin = <span class="hljs-string"><span class="hljs-string">'anonymous'</span></span>; image.onload = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// .... }; image.src = 'example.jpg'; }</span></span></code> </pre> <br><p>  Ap√≥s o carregamento, crie uma textura e indique que ele ficar√° abaixo do n√∫mero 0. No WebGL, pode haver muitas texturas ao mesmo tempo e devemos indicar explicitamente a quais comandos subsequentes se relacionar√£o.  Nos nossos exemplos, haver√° apenas uma textura, mas ainda indicamos explicitamente que ser√° zero. </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> texture = GL.createTexture(); GL.activeTexture(GL.TEXTURE0); GL.bindTexture(GL.TEXTURE_2D, texture);</code> </pre> <br><p>  Resta adicionar uma imagem.  Tamb√©m dizemos imediatamente que ele precisa ser girado ao longo do eixo Y, porque  no WebGL, o eixo est√° de cabe√ßa para baixo: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pixelStorei</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UNPACK_FLIP_Y_WEBGL</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texImage2D</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, 0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RGB</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RGB</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UNSIGNED_BYTE</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">image</span></span>);</code> </pre> <br><p>  Em teoria, a textura deve ser quadrada.  Mais precisamente, eles devem ter um tamanho igual √† pot√™ncia de dois - 32px, 64px, 128px etc.  Mas todos entendemos que ningu√©m processar√° fotos e elas ter√£o propor√ß√µes diferentes a cada vez.  Isso causar√° erros mesmo se o tamanho da <code>canvas</code> se encaixar perfeitamente na textura.  Portanto, preenchemos todo o espa√ßo at√© as bordas do plano com os pixels extremos da imagem.  Esta √© uma pr√°tica padr√£o, embora pare√ßa um pouco de muleta. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_WRAP_S</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CLAMP_TO_EDGE</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_WRAP_T</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CLAMP_TO_EDGE</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_MIN_FILTER</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LINEAR</span></span>);</code> </pre> <br><p>  Resta transferir a textura para os shaders.  Como esses dados s√£o comuns a todos, usamos o modificador <code>uniform</code> . </p><br><pre> <code class="hljs delphi">GL.uniform1i(GL.getUniformLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'u_texture'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Agora podemos usar as cores da textura no shader de fragmento.  Mas tamb√©m queremos que a imagem ocupe toda a <code>canvas</code> .  Se a imagem e a <code>canvas</code> tiverem as mesmas propor√ß√µes, essa tarefa se tornar√° trivial.  Primeiro, transferimos o tamanho da <code>canvas</code> para os shaders (isso deve ser feito toda vez que voc√™ altera o tamanho): </p><br><pre> <code class="hljs pgsql">GL.uniform1f(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_canvas_size'</span></span>), Math.max(CANVAS.height, CANVAS.width));</code> </pre> <br><p>  E divida as coordenadas nele: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D u_texture; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> float u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, gl_FragCoord.xy / u_canvas_size); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/QVwjeJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Neste ponto, voc√™ pode pausar e preparar o ch√°.</em>  <em>Fizemos todo o trabalho preparat√≥rio e passamos a criar v√°rios efeitos.</em> </p><br><h2 id="effekty">  Efeitos </h2><br><p>  Ao criar v√°rios efeitos, a intui√ß√£o e a experimenta√ß√£o desempenham um papel importante.  Geralmente, voc√™ pode substituir um algoritmo complexo por algo completamente simples e obter um resultado semelhante.  O usu√°rio final n√£o notar√° a diferen√ßa, mas agilizamos o trabalho e simplificamos o suporte.  O WebGL n√£o fornece ferramentas adequadas para depura√ß√£o de shaders, por isso √© ben√©fico termos pequenos peda√ßos de c√≥digo que podem caber na cabe√ßa como um todo. </p><br><blockquote>  Menos c√≥digo significa menos problemas.  E √© mais f√°cil de ler.  Sempre verifique os shaders encontrados na rede para a√ß√µes desnecess√°rias.  Acontece que voc√™ pode remover metade do c√≥digo e nada muda. </blockquote><p>  Vamos brincar um pouco com o shader.  A maioria dos nossos efeitos ser√° baseada no fato de retornarmos a cor n√£o do pixel na textura que deveria estar neste local, mas em alguns dos vizinhos.  √â √∫til tentar adicionar √†s coordenadas o resultado de uma fun√ß√£o padr√£o das coordenadas.  O tempo tamb√©m ser√° √∫til - portanto, o resultado da execu√ß√£o ser√° mais f√°cil de rastrear e, no final, ainda produziremos efeitos animados.  Vamos tentar usar o seno: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  O resultado √© estranho.  Obviamente, tudo se move com muita amplitude.  Divida tudo por algum n√∫mero: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  J√° est√° melhor.  Agora est√° claro que tivemos um pouco de emo√ß√£o.  Em teoria, para aumentar cada onda, precisamos dividir o argumento seno - a coordenada.  Vamos fazer isso: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y / <span class="hljs-number"><span class="hljs-number">30.0</span></span>) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/jvEWbJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Efeitos semelhantes s√£o frequentemente acompanhados pela sele√ß√£o de coeficientes.  Isso √© feito a olho nu.  Como na culin√°ria, no come√ßo ser√° dif√≠cil adivinhar, mas depois acontecer√° por si s√≥.  O principal √© entender pelo menos aproximadamente o que esse ou aquele coeficiente na f√≥rmula resultante afeta.  Depois que os coeficientes s√£o selecionados, faz sentido coloc√°-los em macros (como foi o primeiro exemplo) e fornecer nomes significativos. </p><br><p>  <strong>Espelho torto, bicicletas e experi√™ncias</strong> </p><br><p>  Pensar √© bom.  Sim, existem algoritmos prontos para resolver alguns problemas que podemos apenas pegar e usar.       ,      . </p><br><p>         ,   " ",       .  O que fazer? </p><br><p> ,       ,   ?      .   ,       rand()  - .    ,    ,   ,  ,   .    .                  .   ,      .         .      .    -,    .      .    ,     ,       ,   .     ,           "": </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(vec2 <span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); }</code> </pre><br><p>    ,          , ,      NVIDIA  ATI     .     ,        . </p><br><p>       ,    ,          : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + rand(<span class="hljs-name"><span class="hljs-name">gl_FragCoord</span></span>.xy) / <span class="hljs-number"><span class="hljs-number">100.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + rand(<span class="hljs-name"><span class="hljs-name">gl_FragCoord</span></span>.xy + vec2(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">u_time</span></span>))) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>    ,   ,   : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/pOvgbX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> ,        .     ,   ,     .   ‚Äî           .  Como fazer isso? .      . </p><br><p>       0  1,     - .    5 ‚Äî          .       ,      . </p><br><pre> <code class="hljs matlab">vec2 texture_coord = gl_FragCoord.xy / u_canvas_size; gl_FragColor = texture2D(u_texture, texture_coord + <span class="hljs-built_in"><span class="hljs-built_in">rand</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">5.0</span></span>) + vec2(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time))) / <span class="hljs-number"><span class="hljs-number">100.0</span></span>);</code> </pre> <br><p>   ,   -    .   -   . ,    ,   .     ? </p><br><p>        ,  ,   ,  - .     , .    , ..      -.      ,      .      . ,         ,   .        . </p><br><p>    <code>sin</code>  <code>cos</code>   ,    .   .         . </p><br><pre> <code class="hljs mel">gl_FragColor = texture2D(u_texture, texture_coord + vec2( <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(u_time + texture_coord.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(u_time + texture_coord.y * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>));</code> </pre> <br><p>      .   <code>fract</code>  .    1  1 ‚Äî     : </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(vec2 position) { vec2 block_position = <span class="hljs-keyword"><span class="hljs-keyword">floor</span></span>(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top_left_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top_right_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom_left_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom_right_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec2 computed_value = fract(position); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>        . WebGL      <code>smoothstep</code> ,     : </p><br><pre> <code class="hljs lisp">vec2 computed_value = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, fract(<span class="hljs-name"><span class="hljs-name">position</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>    ,      .   ,          X   : </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> computed_value.x;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/mGyVBK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> ‚Ä¶    ,  ,    ... </p><br><blockquote>    - ,     ,     ...        . </blockquote><p>     y ‚Äî    ,   .      ? </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(computed_value);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/OoPMza" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>     . </p><br><p>     .     0.5 ‚Äî      . </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mix</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">top_left_value</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_right_value</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>) + (<span class="hljs-selector-tag"><span class="hljs-selector-tag">bottom_left_value</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_left_value</span></span>) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> * (1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>) + (<span class="hljs-selector-tag"><span class="hljs-selector-tag">bottom_right_value</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_right_value</span></span>) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span>;</code> </pre> <br><p>      : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/eLmJMZ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <em>     ,   , ,  .</em> </p><br><p> <strong> </strong> </p><br><p>        ,     ,          .         - . </p><br><p>    uniform-,       .   0  1,  0 ‚Äî   ,  1 ‚Äî  . </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u_intensity;</code> </pre> <br><p>       : </p><br><pre> <code class="hljs mel">gl_FragColor = texture2D(u_texture, texture_coord + vec2(<span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(u_time + texture_coord.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(u_time + texture_coord.y * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>) * u_intensity);</code> </pre> <br><p>         ,      . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/PdwZdX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>         (  0  1),             . </p><br><blockquote>  ,    ,         ,       .          ‚Äî         requestAnimationFrame.       ,     FPS. </blockquote><p> <strong>   </strong> </p><br><p>      ,        .   uniform-. </p><br><pre> <code class="hljs powershell">document.addEventListener(<span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>, (e) =&gt; { let rect = CANVAS.getBoundingClientRect(); MOUSE_POSITION = [ <span class="hljs-type"><span class="hljs-type">e.clientX</span></span> - <span class="hljs-type"><span class="hljs-type">rect.left</span></span>, <span class="hljs-type"><span class="hljs-type">rect.height</span></span> - (<span class="hljs-type"><span class="hljs-type">e.clientY</span></span> - <span class="hljs-type"><span class="hljs-type">rect.top</span></span>) ]; GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_mouse_position'</span></span>), MOUSE_POSITION); });</code> </pre> <br><p>    ,            .      ‚Äî  ,       . </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> texture_coord = gl_FragCoord.xy / u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> direction = u_mouse_position / u_canvas_size - texture_coord; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> dist = distance(gl_FragCoord.xy, u_mouse_position) / u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord + u_intensity * direction * dist * <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> ); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord); } }</code> </pre> <br><p>         -    .         . </p><br><blockquote>             .    ,        . </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/bxNEOP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <strong></strong> </p><br><p>      . Glitch-     ,      SVG.      .    ‚Äî .      ?       ‚Äî  ,   ,   ,      . </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> random_value = rand(vec2(texture_coord.y, u_time)); <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (random_value &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">05</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, vec2(texture_coord.x + random_value / <span class="hljs-number"><span class="hljs-number">5</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, texture_coord.y)); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord); }</code> </pre> <br><blockquote> "     ?" ‚Äî   ,      .          . </blockquote><p>     .      ‚Äî  ,           . </p><br><pre> <code class="hljs lisp">float random_value = rand(<span class="hljs-name"><span class="hljs-name">vec2</span></span>(<span class="hljs-name"><span class="hljs-name">floor</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.y * 20.0), u_time));</code> </pre> <br><p>     .   ,       : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, vec2(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.x + random_value / <span class="hljs-number"><span class="hljs-number">4.0</span></span>, texture_coord.y)) + vec4(<span class="hljs-name"><span class="hljs-name">vec3</span></span>(<span class="hljs-name"><span class="hljs-name">random_value</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>          .          ‚Äî    . ,           ‚Äî   <code>.r</code> , <code>.g</code> , <code>.b</code> , <code>.rg</code> , <code>.rb</code> , <code>.rgb</code> , <code>.bgr</code> , ...               . </p><br><p>       : </p><br><pre> <code class="hljs lisp">float random_value = u_intensity * rand(<span class="hljs-name"><span class="hljs-name">vec2</span></span>(<span class="hljs-name"><span class="hljs-name">floor</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.y * 20.0), u_time));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/OoPMeY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="chto-v-itoge">  Qual √© o resultado? </h2><br><p>         ,                   ,     .          ,  ,      ‚Äî         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420847/">https://habr.com/ru/post/pt420847/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420833/index.html">Principais erros de monetiza√ß√£o de aplicativos [e como corrigi-los]</a></li>
<li><a href="../pt420837/index.html">Teste de matrizes RAID de software para dispositivos NVMe usando a metodologia SNIA</a></li>
<li><a href="../pt420841/index.html">Hotfix pr√©-hospitalar ou ‚ÄúHey Swagger! Onde est√£o meus erros?</a></li>
<li><a href="../pt420843/index.html">7 de setembro de Ecaterimburgo - uma reuni√£o para desenvolvedores .NET</a></li>
<li><a href="../pt420845/index.html">Domar os obstinados com o uso de uma muleta: o orif√≠cio do adaptador Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../pt420853/index.html">Conhe√ßa o Pseudo Console do Windows (ConPTY)</a></li>
<li><a href="../pt420857/index.html">Roaming sem fio de Wi-Fi: teoria na pr√°tica</a></li>
<li><a href="../pt420859/index.html">√Ä quest√£o de Wirth e correntes</a></li>
<li><a href="../pt420861/index.html">Preparando-se para C ++ 20. Estudo de caso real da Coroutines TS</a></li>
<li><a href="../pt420863/index.html">Como fizemos o primeiro smartphone russo, continuamos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>