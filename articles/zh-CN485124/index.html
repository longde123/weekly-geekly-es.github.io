<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😮 🤙🏽 🌎 PHP和PHPUnit中的纯测试 👋🏽 🙍🏼 📸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP生态系统中有许多工具可提供便利的PHP测试。 最著名的之一是PHPUnit ，它几乎是使用这种语言进行测试的同义词。 但是，关于好的测试方法的文章很少。 关于为什么和何时编写测试，什么样的测试等等有很多选择。 但是老实说，如果以后再看不到测试 ，那就写没有意义 。 

 测试是一种特殊的文档。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP和PHPUnit中的纯测试</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/485124/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/3y/zg/jx3yzg2jnznn0kwnk6oe6ikvlzw.jpeg" width="400"></div><br>  PHP生态系统中有许多工具可提供便利的PHP测试。 最著名的之一是<a href="https://github.com/sebastianbergmann/phpunit">PHPUnit</a> ，它几乎是使用这种语言进行测试的同义词。 但是，关于好的测试方法的文章很少。 关于为什么和何时编写测试，什么样的测试等等有很多选择。 但是老实说，如果以后<b>再看不到测试</b> ，那就<b>写没有意义</b> 。 <br><br> 测试是一种特殊的文档。 正如<a href="https://thephp.website/en/issue/real-life-tdd-php/">我之前在PHP中关于TDD所写的那样</a> ，该测试将始终（或至少应该）清楚地讨论特定代码段的任务。 <br><br> 如果一个测试不能表达这个想法，那么这个测试是不好的。 <br><br> 我准备了一套技术，可以帮助PHP开发人员编写良好，可读和有用的测试。 <br><a name="habracut"></a><br><h2> 让我们从基础开始 </h2><br> 有许多人可以毫无疑问地遵循的一组标准技术。 我将提及其中的许多内容，并尝试解释为什么需要它们。 <br><br><h3>  1.测试中不应包含输入输出操作 </h3><br>  <b>主要原因</b> ：I / O操作缓慢且不可靠。 <br><br>  <b>慢</b> ：即使您拥有世界上最好的硬件，I / O仍然比内存访问慢。 测试应始终快速进行，否则人们将很少进行测试。 <br><br>  <b>不可靠</b> ：某些文件，二进制文件，套接字，文件夹和DNS记录在您正在测试的某些计算机上可能不可用。 您越依赖I / O测试，您的测试与基础架构的联系就越多。 <br><br> 与I / O有关的操作： <br><br><ul><li> 读写文件。 <br></li><li> 网络通话。 <br></li><li>调用外部进程（使用<code>exec</code> ， <code>proc_open</code>等）。 <br></li></ul><br> 在某些情况下，输入输出操作的存在使您可以更快地编写测试。 但请注意：请确保在您的机器上进行开发，组装和部署时，这些操作是否相同，否则可能会遇到严重的问题。 <br><br> 隔离测试，使它们不需要I / O操作：下面提供了一种体系结构解决方案，该解决方案通过在接口之间共享责任来防止测试执行I / O。 <br><br> 一个例子： <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPeople</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ $rawPeople = file_get_contents( <span class="hljs-string"><span class="hljs-string">'people.json'</span></span> ) ?? <span class="hljs-string"><span class="hljs-string">'[]'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json_decode( $rawPeople, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ); }</code> </pre><br> 使用这种方法开始测试时，将创建一个本地文件，并会不时创建快照： <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGetPeopleReturnsPeopleList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $people = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;peopleService -&gt;getPeople(); <span class="hljs-comment"><span class="hljs-comment">// assert it contains people }</span></span></code> </pre> <br> 为此，我们需要配置运行测试的先决条件。 乍一看，一切看起来都合理，但实际上却很糟糕。 <br><br> 由于没有满足先决条件而跳过测试并不能保证我们软件的质量。 这只会隐藏错误！ <br><br>  <b>我们解决了这种情况</b> ：我们通过将职责转移到接口来隔离I / O操作。 <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// extract the fetching // logic to a specialized // interface interface PeopleProvider { public function getPeople(): array; } // create a concrete implementation class JsonFilePeopleProvider implements PeopleProvider { private const PEOPLE_JSON = 'people.json'; public function getPeople(): array { $rawPeople = file_get_contents( self::PEOPLE_JSON ) ?? '[]'; return json_decode( $rawPeople, true ); } } class PeopleService { // inject via __construct() private PeopleProvider $peopleProvider; public function getPeople(): array { return $this-&gt;peopleProvider -&gt;getPeople(); } }</span></span></code> </pre> <br> 现在我知道<code>JsonFilePeopleProvider</code>在任何情况下都将使用I / O。 <br><br> 可以使用<a href="https://flysystem.thephpleague.com/docs/adapter/local/">Flysystem文件系统之</a>类<a href="https://flysystem.thephpleague.com/docs/adapter/local/">的</a>抽象层来代替<code>file_get_contents()</code>可以很容易地创建存根。 <br><br> 然后为什么我们需要<code>PeopleService</code> ？ 好问题。 为此，需要进行测试：挑战架构并删除无用的代码。 <br><br><h3>  2.测试应该有意识且有意义。 </h3><br>  <b>主要原因</b> ：测试是一种文档形式。 保持它们的清晰，简洁和可读性。 <br><br>  <b>简洁明了</b> ：没有混乱，没有数千行存根，没有陈述序列。 <br><br>  <b>可读性</b> ：测试应说明一个故事。 为此，“给定，何时，然后”结构非常好。 <br><br> 良好且易读的测试的特征： <br><br><ul><li> 仅包含对<code>assert</code>方法的必要调用（最好是一个）。 <br></li><li> 他非常清楚地说明了在给定条件下应该发生的情况。 <br></li><li> 它仅测试方法执行的一个分支。 <br></li><li> 出于任何陈述，他不会在整个宇宙中存根。 <br></li></ul><br> 重要的是要注意，如果您的实现包含条件表达式，过渡运算符或循环，则测试都应明确覆盖它们。 例如，使早期答案始终包含测试。 <br><br> 我再说一遍：这不是覆盖范围的问题，而是文档的问题。 <br><br> 这是一个令人困惑的测试示例： <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $noWings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals( <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, $noWings-&gt;canFly() ); $singleWing = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( !$singleWing-&gt;canFly() ); $twoWings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( $twoWings-&gt;canFly() ); }</code> </pre> <br> 让我们调整“给定时间，然后给定”的格式，看看会发生什么： <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Given $person = $this-&gt;givenAPersonHasNoWings(); // Then $this-&gt;assertEquals( false, $person-&gt;canFly() ); // Further cases... } private function givenAPersonHasNoWings(): Person { return new Person(0); }</span></span></code> </pre> <br> 就像“给定”部分一样，“何时”和“然后”可以转移到私有方法中。 这将使您的测试更具可读性。 <br><br>  <code>assertEquals</code>毫无意义。 阅读此内容的人必须跟踪该声明，以了解其含义。 <br><br> 使用特定的语句将使您的测试更具可读性。  <code>assertTrue()</code>应该接收一个布尔变量，而不是类似<code>canFly() !== true</code>的表达式。 <br><br> 在前面的示例中，我们用一个简单的<code>$person-&gt;canFly()</code>替换了<code>false</code>和<code>$person-&gt;canFly()</code>之间的<code>assertEquals</code> ： <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// ... $person = $this-&gt;givenAPersonHasNoWings(); $this-&gt;assertFalse( $person-&gt;canFly() ); // Further cases...</span></span></code> </pre> <br> 现在一切都非常清楚了！ 如果一个人没有翅膀，他一定不能飞！ 像诗一样读 <br><br> 现在，“更多案例”部分（在我们的文字中出现两次）清楚地表明该测试做出了太多陈述。  <code>testCanFly()</code>方法是完全无用的。 <br><br> 让我们再次改进测试： <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFlyIsFalsyWhenPersonHasNoWings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $person = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;givenAPersonHasNoWings(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertFalse( $person-&gt;canFly() ); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFlyIsTruthyWhenPersonHasTwoWings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $person = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;givenAPersonHasTwoWings(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( $person-&gt;canFly() ); } <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br> 我们甚至可以重命名测试方法，以使其与实际场景相匹配，例如在<code>testPersonCantFlyWithoutWings</code> ，但<code>testPersonCantFlyWithoutWings</code>一切都适合我。 <br><br><h3>  3.该测试不应依赖于其他测试 </h3><br>  <b>主要原因</b> ：测试应该以任何顺序运行并成功运行。 <br><br> 我看不出有足够的理由在测试之间建立互连。 最近，我被要求做一个登录功能测试，我将在这里给出一个很好的例子。 <br><br> 该测试应： <br><br><ul><li> 生成用于登录的JWT令牌。 <br></li><li> 执行登录功能。 <br></li><li> 批准状态更改。 <br></li></ul><br> 就像这样： <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGenerateJWTToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... $token $this-&gt;token = $token; } // @depends testGenerateJWTToken public function testExecuteAnAmazingFeature(): void { // Execute using $this-&gt;token } // @depends testExecuteAnAmazingFeature public function testStateIsBlah(): void { // Poll for state changes on // Logged-in interface }</span></span></code> </pre> <br> 这很糟糕，原因如下： <br><br><ul><li>  PHPUnit无法保证此执行顺序。 <br></li><li> 测试必须能够独立运行。 <br></li><li> 并行测试可能会随机失败。 <br></li></ul><br> 解决此问题的最简单方法是使用给定的，何时，然后方案。 因此，测试将更加周到，它们将讲述一个故事，清楚地表明其依赖性，并说明要测试的功能。 <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testAmazingFeatureChangesState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Given $token = $this-&gt;givenImAuthenticated(); // When $this-&gt;whenIExecuteMyAmazingFeature( $token ); $newState = $this-&gt;pollStateFromInterface( $token ); // Then $this-&gt;assertEquals( 'my-state', $newState ); }</span></span></code> </pre> <br> 我们还需要添加用于身份验证等的测试。此结构是如此好，以至于<a href="https://behat.org/en/latest/quick_start.html">默认情况下使用Behat</a> 。 <br><br><h3>  4.始终实现依赖性 </h3><br>  <b>主要原因</b> ：语气很差-为全局状态创建存根。 无法创建依赖项的存根不允许测试该功能。 <br><br> 有用的提示： <b>忘记静态有状态类和单例实例</b> 。 如果您的班级依赖于某种东西，那么就使它得以实现。 <br><br> 这是一个悲伤的例子： <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureToggle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Id $feature )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ $cookieName = $feature-&gt;getCookieName(); <span class="hljs-comment"><span class="hljs-comment">// Early return if cookie // override is present if (Cookies::exists( $cookieName )) { return Cookies::get( $cookieName ); } // Evaluate feature toggle... } }</span></span></code> </pre> <br> 我如何测试这个早期答案？ <br><br> 没错 没办法 <br><br> 为了测试它，我们需要了解<code>Cookies</code>类的行为，并确保我们可以重现与其关联的所有环境，从而得出某些答案。 <br><br> 不要这样做。 <br><br> 如果您将<code>Cookies</code>实例实现为依赖项，则可以纠正这种情况。 测试将如下所示： <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Test class... private Cookies $cookieMock; private FeatureToggle $service; // Preparing our service and dependencies public function setUp(): void { $this-&gt;cookieMock = $this-&gt;prophesize( Cookies::class ); $this-&gt;service = new FeatureToggle( $this-&gt;cookieMock-&gt;reveal() ); } public function testIsActiveIsOverriddenByCookies(): void { // Given $feature = $this-&gt;givenFeatureXExists(); // When $this-&gt;whenCookieOverridesFeatureWithTrue( $feature ); // Then $this-&gt;assertTrue( $this-&gt;service-&gt;isActive($feature) ); // additionally we can assert // no other methods were called } private function givenFeatureXExists(): Id { // ... return $feature; } private function whenCookieOverridesFeatureWithTrue( Id $feature ): void { $cookieName = $feature-&gt;getCookieName(); $this-&gt;cookieMock-&gt;exists($cookieName) -&gt;shouldBeCalledOnce() -&gt;willReturn(true); $this-&gt;cookieMock-&gt;get($cookieName) -&gt;shouldBeCalledOnce() -&gt;willReturn(true); }</span></span></code> </pre> <br> 单调也是如此。 因此，如果您要使对象唯一，那么请正确配置依赖项注入器，而不要使用（反）单例模式。 否则，您将编写仅对<code>reset()</code>或<code>setInstance()</code>这样的情况有用的方法。 我认为这太疯狂了。 <br><br> 更改架构以简化测试是完全正常的！ 创建有助于测试的方法是不正常的。 <br><br><h3>  5.永远不要测试受保护/私有方法 </h3><br>  <b>主要原因是</b> ：它们通过确定行为的签名来影响我们测试功能的方式：在这种情况下，当我输入A时，我期望得到B。 <b>私有/受保护的方法不是功能签名的一部分</b> 。 <br><br> 我什至不想展示一种“测试”私有方法的方法，但我会提示：您只能使用<a href="https://www.php.net/manual/en/book.reflection.php">反射</a> API来做到这一点。 <br><br> 当您考虑使用反射来测试私有方法时，请始终以某种方式惩罚自己！ 不好，不好的开发者！ <br><br> 根据定义，私有方法只能在内部调用。 也就是说，它们不是公开可用的。 这意味着只有来自同一类的公共方法才能调用此类方法。 <br><br>  <b>如果您测试了所有公共方法，那么您还将测试所有私有/受保护方法</b> 。 如果不是这种情况，则可以自由删除私有/受保护的方法；无论如何都不会使用它们。 <br><br><h2> 进阶技巧 </h2><br> 希望您还不会觉得无聊。 不过，我不得不谈论基础知识。 现在，我将分享我的观点，以编写影响我的开发过程的干净的测试和决策。 <br><br> 在编写测试时，我不会忘记的最重要的事情是： <br><br><ul><li> 研究。 <br></li><li> 快速反馈。 <br></li><li> 文献资料 <br></li><li> 重构 <br></li><li> 在测试期间进行设计。 <br></li></ul><br><h3>  1.在开始而不是结束时进行测试 </h3><br>  <b>价值</b> ：研究，快速反馈，文档编制，重构，测试过程中的设计。 <br><br> 这是一切的基础。 最重要的方面，包括所有列出的值。 提前编写测试时，这可以帮助您首先了解应如何构造“给定，何时，然后”方案。 为此，您首先要记录文档，更重要的是，请记住需求并将其设置为最重要的方面。 <br><br> 听说在实现之前编写测试会很奇怪吗？ 并想象实现某件事有多么奇怪，并且当进行测试以找出答案时，“那么，那么”给出的所有表达式都是没有意义的。 <br><br> 同样，这种方法将每两秒钟检查一次您的期望。 您将尽快获得反馈。 无论外观大小，该功能如何。 <br><br> 绿色测试是重构的理想领域。 主要思想：无测试-无重构。 未经测试进行重构是很危险的。 <br><br> 最后，将结构设置为“何时，然后给定”，这对您来说将变得显而易见，方法应该具有什么接口以及行为方式。 保持测试整洁还会迫使您不断做出不同的架构决策。 这将迫使您创建工厂，接口，破坏继承等。是的，测试将变得更加容易！ <br><br> 如果您的测试是实时文档，可以解释应用程序的工作原理，则必须使它们清晰明了。 <br><br><h3>  2.没有测试比有坏测试要好 </h3><br>  <b>值</b> ：研究，文档，重构。 <br><br> 许多开发人员以这种方式考虑测试：我将编写一个功能，将驱动测试框架，直到测试覆盖一定数量的新行并将其投入运行。 <br><br> 在我看来，当新的开发人员开始使用此功能时，您需要更加注意这种情况。  <b>测试会告诉这个人什么？</b> <br><br> 如果名称不够详细，测试通常会令人困惑。 更清楚的是： <code>testCanFly</code>或<code>testCanFlyReturnsFalseWhenPersonHasNoWings</code>吗？ <br><br> 如果您的测试只是凌乱的代码，使该框架涵盖了更多行，并且使用了没有意义的示例，那么该是停下来思考一下是否要编写这些测试的时候了。 <br><br> 甚至<code>$b</code>变量分配<code>$a</code>和<code>$b</code>或分配与特定用途无关的名称也很无聊。 <br><br>  <b>请记住</b> ：您的测试是实时文档，试图解释您的应用程序应如何运行。  <code>assertFalse($a-&gt;canFly())</code>文档不多。  <code>assertFalse($personWithNoWings-&gt;canFly())</code>已经很多了。 <br><br><h3>  3.侵入性地运行测试 </h3><br>  <b>价值观</b> ：学习，快速反馈，重构。 <br><br> 在开始使用功能之前，请运行测试。 如果它们在您开始工作之前失败了，您将<i>在</i>编写代码<i>之前</i>就知道了，并且不必花费宝贵的时间调试甚至根本不在乎的坏测试。 <br><br> 保存文件后，运行测试。 您越早发现某物已损坏，则修复它并继续进行的速度就越快。 如果中断工作流程来解决问题对您而言无济于事，那么可以想象一下，如果以后您不知道该问题，那么您将不得不返回许多步骤。 <br><br> 与同事聊天五分钟或检查来自Github的通知后，运行测试。 如果它们脸红了，那么您就知道您离开的地方。 如果测试为绿色，则可以继续工作。 <br> 进行任何重构（甚至是变量名）之后，请运行测试。 <br><br> 认真地，运行该死的测试。 按下保存按钮的频率。 <br>  <a href="https://github.com/spatie/phpunit-watcher">PHPUnit Watcher</a>可以为您做到这一点，甚至可以发送通知！ <br><br><h3>  4.大考验-大责任 </h3><br>  <b>价值观</b> ：研究，重构，测试过程中的设计。 <br><br> 理想情况下，每个班级应该有一个测试。 该测试应涵盖此类中的所有公共方法以及每个条件表达式或转换运算符。 <br><br> 您可以采取这样的做法： <br><br><ul><li> 一类=一个测试用例。 <br></li><li> 一种方法=一个或多个测试。 <br></li><li> 一个替代分支（如果/ switch / try-catch / exception）=一项测试。 <br></li></ul><br> 因此，对于这个简单的代码，您将需要四个测试： <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// class Person public function eatSlice(Pizza $pizza): void { // test exception if ([] === $pizza-&gt;slices()) { throw new LogicException('...'); } // test exception if (true === $this-&gt;isFull()) { throw new LogicException('...'); } // test default path (slices = 1) $slices = 1; // test alternative path (slices = 2) if (true === $this-&gt;isVeryHungry()) { $slices = 2; } $pizza-&gt;removeSlices($slices); }</span></span></code> </pre> <br> 您拥有的公共方法越多，将需要进行更多的测试。 <br><br> 没有人喜欢阅读冗长的文档。 由于您的测试也是文档，因此小巧而有意义的做法只会提高其质量和实用性。 <br><br> 这也是一个重要信号，表明您的班级正在累积责任，现在该通过将许多功能转移到其他班级或重新设计系统来重构它了。 <br><br><h3>  5.支持一组测试以解决回归问题 </h3><br>  <b>价值观</b> ：研究，文件记录，快速反馈。 <br><br> 考虑以下功能： <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromDb((int) $id); }</code> </pre> <br> 您认为有人正在传播“ 10”，但实际上正在传播“ 10香蕉”。 也就是说，有两个值，但一个是多余的。 你有个错误。 <br><br> 您首先要做什么？ 编写一个测试，将这种行为标记为错误！ <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFindByIdAcceptsOnlyNumericIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(InvalidArgumentException::class); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectExceptionMessage( <span class="hljs-string"><span class="hljs-string">'Only numeric IDs are allowed.'</span></span> ); findById(<span class="hljs-string"><span class="hljs-string">"10 bananas"</span></span>); }</code> </pre> <br> 当然，测试不会传输任何内容。 但是现在您知道需要做什么才能使它们传播。 更正错误，使测试变为绿色，部署应用程序并感到满意。 <br><br> 随身携带该测试。 只要有可能，就使用一组旨在解决回归问题的测试。 <br><br> 仅此而已！ 快速反馈，错误修复，文档，抗回归代码和幸福。 <br><br><h2> 最后的话 </h2><br> 以上大部分只是我个人观点，是我在职业生涯中发展起来的。 这并不意味着建议是对还是错，仅是一种意见。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN485124/">https://habr.com/ru/post/zh-CN485124/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN485108/index.html">2020年1月10日俄罗斯注册PMI专家的统计数据</a></li>
<li><a href="../zh-CN485110/index.html">我对有效远程工作的经验</a></li>
<li><a href="../zh-CN485118/index.html">Robert Martin的“清洁代码”。 摘要 如何编写清晰漂亮的代码？</a></li>
<li><a href="../zh-CN485120/index.html">向我们的应用程序添加一个非常快速的JSON API。</a></li>
<li><a href="../zh-CN485122/index.html">标题“为您阅读文章”。 十月-十二月2019</a></li>
<li><a href="../zh-CN485126/index.html">Mu-mu，woof-woof，quack-quack：声学通信的发展</a></li>
<li><a href="../zh-CN485128/index.html">节省Mikrotik CHR许可证</a></li>
<li><a href="../zh-CN485132/index.html">参加Google Play独立游戏节</a></li>
<li><a href="../zh-CN485136/index.html">Istio跟踪和监视：微服务和不确定性原则</a></li>
<li><a href="../zh-CN485138/index.html">应用程序本地化：我们如何交友翻译和开发</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>