<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€ğŸ³ ğŸ‘©â€ğŸ”¬ â˜¹ï¸ Mengikuti pertemuan "PostgreSQL 11 Fitur Baru" (Bagian 2) ğŸšŸ ğŸ“‚ ğŸï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian pertama, kita berbicara tentang inovasi utama dan perubahan dalam PostgreSQL 11. Kali ini, kita akan membahas secara lebih rinci beberapa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengikuti pertemuan "PostgreSQL 11 Fitur Baru" (Bagian 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/416187/">  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama,</a> kita berbicara tentang inovasi utama dan perubahan dalam PostgreSQL 11. Kali ini, kita akan membahas secara lebih rinci beberapa poin dalam format pertanyaan / jawaban yang diangkat oleh meetup. <br><a name="habracut"></a><br><h4>  Apa cara terbaik untuk mentransfer array data besar sebagai satu set parameter input untuk prosedur tersimpan di PL / pgSQL? </h4><br>  Cara yang paling mudah adalah membuat tabel sementara, membuat salinan data di sana, dan kemudian menggunakannya dalam prosedur. <br><br><h4>  Mesin eksternal (zheap) dan pengembangan di memori PostgreSQL </h4><br>  Tidak untuk semua beban kerja, model dengan menyimpan catatan versi lama di tabel itu sendiri cocok.  Di semua subd (versiionniki) lainnya, mereka disimpan dalam undo-log.  Anda bisa berdebat tentang kelayakannya, tetapi intinya adalah Anda perlu menyimpan catatan lama di suatu tempat.  Jika mereka memiliki umur yang pendek dan seseorang jarang mengatasinya, maka menyimpannya di meja itu sendiri berbahaya.  Mesin zheap eksternal PostgreSQL adalah upaya EnterpriseDB untuk membuat mesin tabel untuk PostgreSQL dengan batalkan log.  Berhasil, meskipun masih ada sesuatu untuk diperbaiki. <br><br>  Siapa yang bekerja dengan Ms.  SQL dalam mode Level Isolasi SNAPSHOT, tahu bahwa ia memiliki tempdb, di mana ia menempatkan versi lama, dan dilengkapi dengan vakum yang cukup dewasa untuk membersihkan tempdb.  Di sisi lain, komunitas meminta untuk membuat tabel dalam memori di PostgreSQL.  Ini dapat dilakukan dengan cukup mudah: tmpfs, dan hanya itu.  Di PostgreSQL Pro bahkan merilis versi pilot pertama, Anda dapat mencoba. <br><br>  Apa yang PostgreSQL tidak pernah miliki adalah mesin plug-in.  Ada indeks pluggable yang menggunakan WAL umum.  PostgreSQL memiliki banyak plug-in dan sedikit untuk diganti dengan cepat.  Misalnya, pelaksana tidak dinonaktifkan, tetapi Anda sudah dapat menggunakan simpul khusus di dalamnya yang Anda program sendiri.  Pengoptimal dalam PostgreSQL sepenuhnya dapat dicolokkan.  Anda dapat menulis sendiri dan menggunakan PostgreSQL sebagai juru bahasa dari pertanyaan Anda.  SQL parser tidak dapat dihubungkan. <br><br>  Mesin ingin terhubung dalam tiga arah: <br><br><ul>
<li>  mesin dengan batalkan log </li><li>  dalam memori </li><li>  penyimpanan kolom untuk kueri OLAP </li></ul><br>  Postgres Pro sedang dalam pembicaraan dengan EnterpriseDB tentang cara membuat API untuk menghubungkan semua ini. <br><br><h4>  Tentang kunci asing </h4><br>  Kunci asing di dalam PostgreSQL diimplementasikan oleh pemicu.  Anda dapat menulis pemicu Anda yang akan menerapkan segala jenis fungsi.  Semua pembatasan yang mungkin harus dilakukan dalam pelatuk.  Logika dalam pemicu tidak terlalu diperlukan untuk disimpan, tetapi periksa semuanya - itu perlu. <br><br><h4>  Apakah Postgres Pro berencana untuk melakukan SaaS atau PaaS? </h4><br>  Postgres Pro berencana untuk membuat PostgreSQL lebih dioptimalkan untuk cloud, khususnya, untuk menerapkan perubahan dinamis untuk membagikan buffer, untuk mengurangi jumlah parameter yang memerlukan restart PostgreSQL.  Mereka tidak akan membangun awan sendiri. <br><br><h4>  Bagaimana cara mengatur drive agar pengindeksan paralel berfungsi lebih cepat?  Mana yang lebih baik, banyak HDD atau satu SSD? </h4><br>  Lebih baik beberapa SSD.  Semakin banyak opsi paralelisasi yang disediakan perangkat keras, semakin baik.  Jika Anda memiliki satu disk, tidak cukup memori dan satu prosesor, maka paralelisasi tidak akan membantu Anda.  Tetapi SSD memiliki kekhasan: mereka mulai melambat jika lebih dari 80% volume ditempati.  Karena itu, jangan lupa untuk menyesuaikan trim, jika tidak, batas 80% akan datang di suatu tempat sekitar 50%. <br><br><h4>  Manajemen kamus dan menambahkan kata-kata dalam pencarian teks lengkap </h4><br>  Jika Anda menggunakan mantra atau bola salju, maka cukup ganti kamus kata-berhenti.  Masalahnya adalah jika Anda menambahkan kata berhenti, maka tidak ada gunanya mengindeks.  Ini bisa dilakukan secara perlahan.  Kata berhenti akan dikeluarkan dari permintaan dan tidak pernah dicari.  Dan jika Anda menghapus kata berhenti, maka tidak ada dalam koleksi itu tidak ada dan Anda perlu mengindeksnya kembali.  Masalahnya bukan di kamus, tetapi pada kenyataan bahwa Anda telah menggunakannya dan menyimpan pengetahuan Anda. <br><br>  Selain itu, dalam banyak kasus, Anda dapat menggunakan fungsi ts_rewrite yang tidak banyak diketahui, yang memungkinkan Anda mengganti sebagian permintaan dengan permintaan lain.  Misalnya, ketika kapal selam Kursk tenggelam, semua orang bergegas mencari informasi tentang itu.  Fedor Sigaev pada waktu itu bekerja di rambler, dan atas permintaan "Kursk" informasi tentang kota diberikan.  Mereka segera melakukan substitusi: dengan kata ini, berikan informasi tentang kapal selam.  Tetapi kemudian pengguna mulai mengutuk, yang tertarik pada desa itu sendiri.  Saya tidak tahu apakah mereka sadar atau tidak, tetapi itu perlu untuk memperkenalkan "kota Kursk".  Pergantian demikian memungkinkan ts_rewrite dibuat.  Selain itu, fungsi ini dapat digunakan untuk transisi yang lancar selama periode perubahan kamus. <br><br>  Tentu saja, mengubah pengurai dan kamus adalah tugas yang rumit.  Bahasa dengan huruf yang berbeda, seperti Rusia dan Inggris, rukun.  Jauh lebih buruk sekarang adalah, katakanlah, teks Prancis-Inggris.  Tidak jelas bahasa apa yang dirujuk oleh kata, yang ditulis dengan cara yang sama, tetapi dalam satu bahasa itu adalah kata berhenti, dan dalam bahasa lain tidak.  Postgres Pro saat ini sedang mengerjakan kamus fine-tuning untuk menggambarkan konfigurasi yang lebih kompleks. <br><br><h4>  Meliputi indeks dan pembaruan terbaru </h4><br>  Ini benar-benar teman.  Benar, jika setidaknya satu bidang diperbarui dalam indeks penutup, maka indeks akan berperilaku seperti biasa, semuanya akan diganti. <br><br><h4>  Ketidakmampuan untuk membuat tabel sementara saat mengeksekusi permintaan siaga </h4><br>  PostgreSQL tidak menyimpan pengetahuan tabel dalam direktori sistem, tetapi ada tambalan yang mentransfer pengetahuan ke direktori sistem.  Oleh karena itu, dengan tambalan ini Anda dapat menggunakan tabel sementara.  Tetapi kemudian muncul masalah lain: tidak ada transaksi yang ditunda.  Untuk bekerja dengan tabel sementara, Anda harus menggunakan dua kali id â€‹â€‹transaksi virtual, yang hanya berlaku untuk tabel sementara, dan bukan untuk yang utama yang berasal dari panduan.  Dan ketika Anda melihat angka 32-bit, mereka akan menjadi dua angka yang berbeda. <br><br>  Postgres Pro juga memiliki modul pg_variables, yang juga berfungsi stand by.  Ini bukan tabel sementara, tetapi fungsionalitas yang diperlukan dapat digambarkan. <br><br><h4>  Menerapkan Indeks Cluster </h4><br>  Postgres Pro memiliki beberapa upaya untuk mengimplementasikannya.  Sekarang Anda bisa memasukkan indeks tabel cluster dan tabel akan berada dalam urutan yang sama.  Menderita cara mempertahankan tabel dalam keadaan cluster.  Kami mencoba pendekatan yang berbeda, tetapi selalu memasukkan ke dalam tabel seperti itu sangat mahal.  Dan ini tidak menarik bagi siapa pun.  Oleh karena itu, sejauh ini telah disimpulkan bahwa perlu untuk pindah ke Tabel Tabel Terorganisir. <br><br><h4>  Faktor skala autovacuum yang direkomendasikan </h4><br>  Biasanya merekomendasikan pengaturan 1 - 5%.  Tapi ini sepenuhnya opsional.  Untuk tabel kecil, di mana, meskipun ada perubahan, rata-rata, distribusi yang sama tetap, nilai yang besar dapat ditetapkan.  Jika meja besar dan jarang diisi ulang, tetapi tepat, dengan perubahan distribusi yang kuat, Anda harus menciptakan sesuatu yang lain.  Itu semua tergantung pada distribusi data Anda. <br><br><h4>  Petunjuk dalam pertanyaan kompleks </h4><br>  Di Oracle, dengan pertanyaan kompleks, Anda harus secara berkala membantu dengan petunjuk, karena pemindaian penuh tiba-tiba terjadi.  Ada petunjuk di Postgres Pro, cukup moody, tetapi Anda bisa mendapatkannya.  Namun, tidak ada petunjuk dalam PostgreSQL biasa, dan mereka tidak akan muncul.  Jika Anda memiliki petunjuk bawaan, maka pengguna, dihadapkan dengan masalah pengoptimal, sisipkan petunjuk, tenang dan jangan melaporkan masalah.  Pengembangan pengoptimal berhenti. <br><br>  Omong-omong, pengoptimal PostgreSQL memiliki masalah.  Ketika dia memperkirakan sampel dari tabel, bahkan untuk jumlah yang lebih atau kurang masuk akal, dia menebak dengan beberapa kesalahan.  Kemudian mulai terhubung, hasilnya terhubung ke sesuatu yang lain, kesalahan terakumulasi, dan pada tingkat ketiga atau keempat PostgreSQL banyak kehilangan. <br><br>  Ada pengaturan seperti itu - bergabung dengan batas keruntuhan.  PostgreSQL mengurutkan BERGABUNG untuk penggunaan yang lebih efisien, tetapi batas pengurutan default adalah 8. Jika ada lebih dari 8 GABUNGAN berturut-turut, sistem tidak akan mengurutkannya dan akan ada ketergantungan pada urutan GABUNGAN dalam kueri. <br><br>  Ada juga pengoptimal genetik dengan berbagai parameter.  Anda dapat mengaktifkan berbagai pengaturan dalam satu sesi dan lebih atau kurang menggambarkan bagaimana permintaan harus dieksekusi.  Menggunakan urutan ini, dengan bantuan tanda kurung Anda dapat mengatur penghentian beberapa operasi, pemindaian detik yang sama.  Pilihan lain adalah memasukkan parameter tertentu ke dalam fungsi.  Dalam beberapa hal, ini juga merupakan petunjuk.  Tidak terlalu nyaman, tetapi setidaknya sesuatu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416187/">https://habr.com/ru/post/id416187/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416175/index.html">Hasil kompetisi pengembang muda aplikasi AR Epson Moverio BT-300</a></li>
<li><a href="../id416177/index.html">Rumus Tupper dan implementasi algoritma dalam Python</a></li>
<li><a href="../id416179/index.html">Sebuah pintu yang menyapa kita dengan nama dan hanya terbuka untuk karyawan departemen</a></li>
<li><a href="../id416181/index.html">Modulasi Amplitudo pada Jari</a></li>
<li><a href="../id416183/index.html">Pengujian Data: Persyaratan dan Level</a></li>
<li><a href="../id416189/index.html">Perawatan Scrum "mekanis". Bagian 3. Pekerjaan SM</a></li>
<li><a href="../id416191/index.html">Implementasi tingkat rendah dari trif prefix tree di PHP</a></li>
<li><a href="../id416193/index.html">Bagaimana robot dapat bekerja dengan manusia bersama (dan bukan sebaliknya)</a></li>
<li><a href="../id416195/index.html">Dijkstra untuk waktu linier</a></li>
<li><a href="../id416197/index.html">Mesin untuk program DARPA baru berhasil lulus tes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>