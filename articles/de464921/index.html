<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèª ü§õüèæ ü•î System.IO.Pipelines - ein wenig bekanntes Tool f√ºr Liebhaber hoher Leistung ü§≤üèª üà∫ üëèüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Leser. Seit der Ver√∂ffentlichung von .NET Core 2.1 ist ziemlich viel Zeit vergangen. Und solche coolen Innovationen wie Span und Memory wurden b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines - ein wenig bekanntes Tool f√ºr Liebhaber hoher Leistung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464921/">  Hallo Leser.  Seit der Ver√∂ffentlichung von .NET Core 2.1 ist ziemlich viel Zeit vergangen.  Und solche coolen Innovationen wie Span und Memory wurden bereits weit verbreitet, man kann viel dar√ºber lesen, sehen und h√∂ren.  Leider erhielt eine Bibliothek namens System.IO.Pipelines nicht die gleiche Aufmerksamkeit.  Fast alles, was zu diesem Thema geh√∂rt, ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einzige Beitrag</a> , den viele zu Hause √ºbersetzt und gepostet haben.  Es sollte auf jeden Fall mehr Informationen geben, damit Interessenten die Technologie aus verschiedenen Blickwinkeln betrachten k√∂nnen. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Ziel dieser Bibliothek ist es daher, die Arbeit mit der Streaming-Datenverarbeitung zu beschleunigen.  Es wurde urspr√ºnglich vom Entwicklungsteam von Kestrel (einem plattform√ºbergreifenden Webserver f√ºr ASP.NET Core) erstellt und verwendet, wird jedoch derzeit √ºber ein separates <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nuget-Paket bereitgestellt</a> . <br>  Bevor wir uns mit dem Thema befassen, k√∂nnen wir uns den Bibliotheksmechanismus als ein verbessertes Analogon von MemoryStream vorstellen.  Das Problem mit dem urspr√ºnglichen MemoryStream ist eine √ºberm√§√üige Anzahl von Kopien. Dies ist offensichtlich, wenn Sie sich daran erinnern, dass ein privates Byte-Array im Inneren als Puffer verwendet wird.  Beispielsweise ist bei den <a href="">Lese-</a> und <a href="">Schreibmethoden das</a> Kopieren deutlich sichtbar.  Daher wird f√ºr das Objekt, das in den Stream geschrieben werden soll, eine Kopie im internen Puffer erstellt, und w√§hrend des Lesens wird eine Kopie der internen Kopie an den Verbraucher geliefert.  Es klingt nicht nach der rationalsten Raumnutzung. <br>  System.IO.Pipelines zielt nicht darauf ab, alle Streams zu ersetzen, sondern ist ein zus√§tzliches Tool im Arsenal eines Entwicklers, der Hochleistungscode schreibt.  Ich schlage vor, dass Sie sich mit den grundlegenden Methoden und Klassen vertraut machen, sehen, wie sie im Inneren angeordnet sind, und grundlegende Beispiele analysieren. <br><br>  Beginnen wir mit dem internen Ger√§t und untersuchen gleichzeitig einfache Codefragmente.  Danach wird klar, was und wie es funktioniert und wie es verwendet werden soll.  Bei der Arbeit mit System.IO.Pipelines ist zu beachten, dass das Grundkonzept darin besteht, dass alle Lese- / Schreibvorg√§nge ohne zus√§tzliche Zuordnungen erfolgen sollten.  Einige auf den ersten Blick attraktive Methoden widersprechen dieser Regel.  Dementsprechend beginnt der Code, den Sie so schnell zu beschleunigen versuchen, Speicher f√ºr neue und neue Daten zuzuweisen, wodurch der Garbage Collector geladen wird. <br><br>  Die interne Bibliothek der Bibliothek nutzt die umfangreichsten M√∂glichkeiten der neuesten Versionen von Sprache und Zeitspanne, Spanne, Speicher, Objektpools, ValueTask usw.  Zumindest ein gutes Beispiel f√ºr die Verwendung dieser Funktionen in der Produktion ist einen Blick wert. <br>  Zu einer Zeit waren einige mit der Implementierung von Streams in C # unzufrieden, da eine Klasse sowohl zum Lesen als auch zum Schreiben verwendet wurde.  Aber wie sie sagen, k√∂nnen Sie keine Methoden aus einer Klasse werfen.  Selbst wenn der Stream das Lesen / Schreiben / Verschieben des Zeigers nicht unterst√ºtzte, wurden die Eigenschaften CanRead, CanWrite und CanSeek wirksam, die wie eine kleine Kr√ºcke aussahen.  Hier ist das anders. <br>  F√ºr die Arbeit mit Pipes werden zwei Klassen verwendet: <a href="">PipeWriter</a> und <a href="">PipeReader</a> .  Diese Klassen enthalten jeweils etwa 50 Zeilen und sind Pseudofassaden (nicht die klassischsten Inkarnationen, da eine einzige Klasse dahinter verborgen ist und nicht viele) f√ºr die <a href="">Pipe-</a> Klasse, die die gesamte grundlegende Logik f√ºr die Arbeit mit Daten enth√§lt.  Von den √∂ffentlichen Mitgliedern - 2 Konstruktoren, 2 Nur-Get-Eigenschaften - Reader und Writer, die Reset () -Methode, die interne Felder auf ihren Ausgangszustand zur√ºcksetzt, damit die Klasse wiederverwendet werden kann.  Andere Arbeitsmethoden werden als Pseudofassaden bezeichnet. <br><br><h2>  Erste Schritte mit der Pipe-Klasse </h2><br>  Die Klasseninstanz belegt 320 Bytes, was ziemlich viel ist (fast ein Drittel eines Kilobytes, 2 solcher Objekte konnten nicht in den Speicher von Manchester Mark I passen).  Es ist also eine schlechte Idee, es in gro√üen Mengen zuzuweisen.  Dar√ºber hinaus ist die Bedeutung des Objekts f√ºr den langfristigen Gebrauch bestimmt.  Die Verwendung von Pools liefert auch ein Argument f√ºr diese Aussage.  Immerhin werden die im Pool verwendeten Objekte f√ºr immer leben (auf jeden Fall im Standard). <br>  Beachten Sie, dass die Klasse als versiegelt markiert und threadsicher ist - viele Abschnitte des Codes sind ein kritischer Abschnitt und in Sperren eingeschlossen. <br>  Erstellen Sie zun√§chst eine Instanz der Pipe-Klasse und rufen Sie die Objekte PipeReader und PipeWriter mit den genannten Eigenschaften ab. <br><br><div class="spoiler">  <b class="spoiler_title">Einfache Initialisierung</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Betrachten Sie die Methoden zum Arbeiten mit Rohren: <br>  F√ºr die Aufnahme √ºber PipeWriter - WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Complete, CancelPendingFlush, OnReaderCompleted. <br>  Zum Lesen von PipeReader - AdvanceTo, ReadAsync, TryRead, Complete, CancelPendingRead, OnWriterCompleted. <br><br>  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag angegeben</a> , verwendet die Klasse eine einfach verkn√ºpfte Liste von Puffern.  Offensichtlich werden sie jedoch nicht zwischen PipeReader und PipeWriter √ºbertragen - die gesamte Logik befindet sich in einer Klasse.  Diese Liste wird sowohl zum Lesen als auch zum Schreiben verwendet.  Dar√ºber hinaus werden die zur√ºckgegebenen Daten in dieser Liste gespeichert. <br>  Es gibt auch Objekte, die den Beginn der zu lesenden Daten (ReadHead und Index), das Ende der zu lesenden Daten (ReadTail und Index) und den Beginn der zu schreibenden Stelle (WriteHead und die Anzahl der geschriebenen gepufferten Bytes) angeben.  Hier sind ReadHead, ReadTail und WriteHead ein bestimmtes Segment aus der Liste, und der Index gibt eine bestimmte Position innerhalb des Segments an.  Somit kann die Aufzeichnung in der Mitte eines Segments beginnen, das gesamte n√§chste Segment erfassen und in der Mitte des dritten Segments enden.  Diese Zeiger bewegen sich auf verschiedene Arten. <br><br><h2>  Erste Schritte mit PipeWriter-Methoden </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (ReadOnlyMemory &lt;Byte&gt; -Quelle, CancellationToken CancellationToken)</a> </h3><br>  Genau diese verlockende Methode.  Hat eine sehr geeignete und trendige Signatur - akzeptiert ReadOnlyMemory, asynchron.  Und viele m√∂gen versucht sein, sich besonders daran zu erinnern, dass Span und Memory so schnell und cool sind.  Aber schmeichel dir nicht.  Diese Methode kopiert lediglich das an sie √ºbergebene ReadOnlyMemory in die interne Liste.  Und "Kopieren" bedeutet einen Aufruf der CopyTo-Methode und nicht das Kopieren des Objekts selbst.  Das hei√üt, alle Daten, die wir aufzeichnen m√∂chten, werden kopiert, wodurch der Speicher geladen wird.  Diese Methode sollte nur untersucht werden, um sicherzustellen, dass es besser ist, sie nicht zu verwenden.  Nun, und vielleicht f√ºr einige seltene Situationen ist dieses Verhalten angemessen. <br>  Der Hauptteil der Methode ist ein kritischer Abschnitt. Der Zugriff darauf wird √ºber einen Monitor synchronisiert. <br><br>  Dann kann sich die Frage stellen, wie man etwas schreibt, wenn nicht mit der naheliegendsten und einzig geeigneten Methode. <br><br><h3>  # 2 <a href="">Speicher &lt;Byte&gt; GetMemory (int sizeHint)</a> </h3><br>  Die Methode verwendet einen Parameter eines Integer-Typs.  Darin m√ºssen wir angeben, wie viele Bytes wir schreiben m√∂chten (oder mehr, aber auf keinen Fall weniger).  Diese Methode pr√ºft, ob in dem in _writingHeadMemory gespeicherten aktuellen Speicherfragment gen√ºgend Speicherplatz zum Schreiben vorhanden ist.  Wenn dies ausreicht, wird _writingHeadMemory als Speicher zur√ºckgegeben.  Wenn nicht, wird f√ºr die Daten, die in den Puffer geschrieben wurden, f√ºr die jedoch die FlushAsync-Methode nicht aufgerufen wurde, ein anderes BufferSegment aufgerufen, das mit dem vorherigen verbunden ist (hier die Liste).  In Abwesenheit von _writingHeadMemory wird es mit einem neuen BufferSegment initialisiert.  Die Zuweisung des n√§chsten Puffers ist ein kritischer Abschnitt und erfolgt unter der Sperre. <br>  Ich schlage einen Blick auf ein solches Beispiel vor.  Auf den ersten Blick scheint es, dass der Compiler (oder die Laufzeit) den D√§mon verf√ºhrt hat. <br><br><div class="spoiler">  <b class="spoiler_title">Teufelei</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048  4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Aber alles in diesem Beispiel ist verst√§ndlich und einfach. <br>  Beim Erstellen einer Pipe-Instanz k√∂nnen wir ein <a href="">PipeOptions-</a> Objekt mit Optionen zum Erstellen an den Konstruktor √ºbergeben. <br><br>  PipeOptions verf√ºgt √ºber ein Standardfeld f√ºr die minimale Segmentgr√∂√üe.  Vor nicht allzu langer Zeit war es 2048, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Commit</a> √§nderte alles, jetzt 4096. Zum Zeitpunkt des Schreibens war die Version mit 4096 ein Vorabversionspaket, in der neuesten Release-Version war es 2048. Dies erkl√§rt das Verhalten des ersten Beispiels.  Wenn Sie eine kleinere Gr√∂√üe f√ºr den Standardpuffer verwenden m√∂chten, k√∂nnen Sie diese in einer Instanz des Typs PipeOptions angeben. <br><br>  Im zweiten Beispiel, in dem die Mindestgr√∂√üe angegeben ist, stimmt die L√§nge ohnehin nicht √ºberein.  Und dies geschieht bereits, weil die Erstellung eines neuen BufferSegments mithilfe von Pools erfolgt.  Eine der Optionen in PipeOptions ist der Speicherpool.  Danach wird der angegebene Pool verwendet, um ein neues Segment zu erstellen.  Wenn Sie Ihren Speicherpool nicht angegeben haben, wird der Standard-ArrayPool verwendet, der, wie Sie wissen, mehrere Buckets f√ºr unterschiedliche Arraysgr√∂√üen enth√§lt (jeder n√§chste ist zweimal gr√∂√üer als der vorherige). Wenn Sie nach einer bestimmten Gr√∂√üe gefragt werden, wird nach einem Bucket mit Arrays geeigneter Gr√∂√üe gesucht (dann) es ist das n√§chste gr√∂√üer oder gleich).  Dementsprechend ist der neue Puffer mit ziemlicher Sicherheit gr√∂√üer als von Ihnen angefordert.  Die minimale Arraygr√∂√üe im Standard-ArrayPool (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) betr√§gt 16. Machen Sie sich jedoch keine Sorgen, da dies ein Pool von Arrays ist.  Dementsprechend belastet das Array in den allermeisten F√§llen den Garbage Collector nicht und wird wiederverwendet. <br><br><h3>  # 2.5 <a href="">Span &lt;Byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Es funktioniert √§hnlich und gibt Span from Memory. <br><br>  Daher sind GetMemory () oder GetSpan () die Hauptmethoden zum Schreiben.  Sie geben uns ein Objekt, an das wir schreiben k√∂nnen.  Dazu m√ºssen wir keinen Speicher f√ºr neue Wertearrays zuweisen, sondern k√∂nnen direkt in die interne Struktur schreiben.  Welche verwendet werden soll, h√§ngt haupts√§chlich von der verwendeten API und der asynchronen Methode ab.  In Anbetracht des Vorstehenden stellt sich jedoch eine Frage.  Woher wei√ü der Leser, wie viel wir geschrieben haben?  Wenn wir immer eine bestimmte Implementierung des Pools verwenden w√ºrden, die ein Array mit genau der gew√ºnschten Gr√∂√üe ergibt, k√∂nnte der Leser den gesamten Puffer auf einmal lesen.  Wie wir bereits gesagt haben, wird uns jedoch ein Puffer mit einer hohen Wahrscheinlichkeit einer gr√∂√üeren Gr√∂√üe zugewiesen.  Dies f√ºhrt zu der folgenden f√ºr den Betrieb erforderlichen Methode. <br><br><h3>  # 3 <a href="">void Advance (int Bytes)</a> </h3><br>  Eine schrecklich einfache Methode.  Es wird die Anzahl der als Argument geschriebenen Bytes verwendet.  Sie erh√∂hen die internen Z√§hler - _unflushedBytes und _writingHeadBytesBuffered, deren Namen f√ºr sich selbst sprechen.  Au√üerdem wird _writingHeadMemory genau auf die Anzahl der geschriebenen Bytes gek√ºrzt (mithilfe der Slice-Methode).  Daher m√ºssen Sie nach dem Aufrufen dieser Methode einen neuen Speicherblock in Form von Memory oder Span anfordern. Sie k√∂nnen nicht in den vorherigen schreiben.  Und der gesamte K√∂rper der Methode ist ein kritischer Abschnitt und l√§uft unter einem Schloss. <br><br>  Es scheint, dass der Leser danach Daten empfangen kann.  Es ist jedoch noch ein Schritt erforderlich. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (CancellationToken CancellationToken)</a> </h3><br>  Die Methode wird aufgerufen, nachdem wir die erforderlichen Daten in den empfangenen Speicher geschrieben und angegeben haben, wie viel wir dort geschrieben haben.  Die Methode gibt eine ValueTask zur√ºck, ist jedoch nicht asynchron (im Gegensatz zu ihrem Nachkommen StreamPipeWriter).  ValueTask ist ein spezieller Typ (schreibgesch√ºtzte Struktur), der verwendet wird, wenn die meisten Aufrufe keine Asynchronit√§t verwenden, dh alle erforderlichen Daten zum Zeitpunkt des Aufrufs verf√ºgbar sind und die Methode synchron endet.  Im Inneren enth√§lt es entweder Daten oder Task (falls es nicht synchron funktioniert hat).  Dies h√§ngt vom Status der Eigenschaft _writerAwaitable.IsCompleted ab.  Wenn wir nach √Ñnderungen des Status dieses wartenden Objekts suchen, werden wir feststellen, dass dies unter der Bedingung geschieht, dass die Menge der nicht verarbeiteten (nicht verbrauchten) Daten (dies ist nicht genau die gleiche wie die Menge der ungelesenen (nicht untersuchten) Daten, die sp√§ter erl√§utert wird) einen bestimmten Schwellenwert √ºberschreitet (_pauseWriterThreshold).  Der Standardwert betr√§gt 16 Segmentgr√∂√üen.  Falls gew√ºnscht, kann der Wert in PipeOptions ge√§ndert werden.  Diese Methode startet auch die Fortsetzung der ReadAsync-Methode, falls eine blockiert wurde. <br><br>  Gibt ein FlushResult zur√ºck, das zwei Eigenschaften enth√§lt - IsCanceled und IsCompleted.  IsCanceled gibt an, ob Flush abgebrochen wurde (CancelPendingFlush-Aufruf).  IsCompleted gibt an, ob der PipeReader abgeschlossen wurde (durch Aufrufen der Methoden Complete () oder CompleteAsync ()). <br>  Der Hauptteil der Methode wird unter Locke Skywalker durchgef√ºhrt. <br><br>  Andere Methoden von PipeWriter sind aus Sicht der Implementierung nicht von Interesse und werden viel seltener verwendet, daher wird nur eine kurze Beschreibung gegeben. <br><br><h3>  # 5 void Complete (Ausnahme Ausnahme = null) oder ValueTask CompleteAsync (Ausnahme Ausnahme = null) </h3><br>  Markiert das zum Schreiben geschlossene Rohr.  Nach Abschluss wird eine Ausnahme ausgel√∂st, wenn versucht wird, die Methoden zum Schreiben zu verwenden.  Wenn PipeReader bereits abgeschlossen wurde, wird auch die gesamte Pipe-Instanz abgeschlossen.  Die meiste Arbeit wird unter dem Schloss erledigt. <br><br><h3>  # 6 void CancelPendingFlush () </h3><br>  Wie der Name schon sagt, wird die aktuelle FlushAsync () -Operation abgeschlossen.  Es gibt ein lok. <br><br><h3>  # 7 void OnReaderCompleted (Aktion &lt;Ausnahme, Objekt&gt; R√ºckruf, Objektstatus) </h3><br>  F√ºhrt den delegierten Delegaten aus, wenn der Reader abgeschlossen ist.  Es gibt auch ein Schloss. <br>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> hei√üt es derzeit, dass diese Methode bei einigen PipeWriter-Nachkommen m√∂glicherweise nicht aufgerufen wird und in Zukunft entfernt wird.  Daher sollten Sie keine Logik an diese Methoden binden. <br><br><h2>  Gehen Sie zu PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (CancellationToken-Token)</a> </h3><br>  Hier wird wie bei FlushAsync eine ValueTask zur√ºckgegeben, die darauf hinweist, dass die Methode gr√∂√ütenteils synchron ist, jedoch nicht immer.  H√§ngt vom Status von _readerAwaitable ab.  Wie bei FlushAsync m√ºssen Sie feststellen, wann _readerAwaitable auf unvollst√§ndig gesetzt ist.  Dies geschieht, wenn PipeReader alles aus der Liste liest (oder Daten enth√§lt, die als gepr√ºft markiert wurden und weitere Daten ben√∂tigen, um fortzufahren).  Was in der Tat logisch ist.  Dementsprechend k√∂nnen wir den Schluss ziehen, dass es w√ºnschenswert ist, Pipe genau auf Ihre Arbeit abzustimmen und alle Optionen sorgf√§ltig auf der Grundlage empirisch identifizierter Statistiken festzulegen.  Durch eine ordnungsgem√§√üe Konfiguration wird die Wahrscheinlichkeit eines asynchronen Ausf√ºhrungszweigs verringert und eine effizientere Datenverarbeitung erm√∂glicht.  Fast die gesamte Methode ist von einem Schloss umgeben. <br><br>  Gibt ein mysteri√∂ses <a href="">ReadResult zur√ºck</a> .  Tats√§chlich ist es nur ein Puffer + Flags, der den Status des Vorgangs anzeigt (IsCanceled - ob ReadAsync abgebrochen wurde und IsCompleted angibt, ob der PipeWriter geschlossen wurde).  In diesem Fall ist IsCompleted ein Wert, der angibt, ob die Methoden PipeWriter Complete () oder CompleteAsync () aufgerufen wurden.  Wenn diese Methoden mit einer Ausnahme aufgerufen wurden, wird sie beim Lesen ausgel√∂st. <br><br>  Der Puffer hat wieder einen mysteri√∂sen Typ - <a href="">ReadOnlySequence</a> .  Dies ist wiederum ein Objekt zum Enthalten von <a href="">Segmenten (ReadOnlySequenceSegment) der</a> Anfangs- und End- + Start- und Endindizes innerhalb der entsprechenden Segmente.  Was eigentlich der Struktur der Pipe-Klasse selbst √§hnelt.  BufferSegment ist √ºbrigens der Nachfolger von ReadOnlySequenceSegment, was darauf hindeutet, dass es dort verwendet wird.  Dank dieser Funktion k√∂nnen Sie unn√∂tige Speicherzuweisungen f√ºr die Daten√ºbertragung vom Schreiber zum Leser vermeiden. <br>  ReadOnlySpan kann zur weiteren Verarbeitung aus dem Puffer abgerufen werden.  Um das Bild zu vervollst√§ndigen, k√∂nnen Sie √ºberpr√ºfen, ob der Puffer einen einzelnen ReadOnlySpan enth√§lt.  Wenn es enth√§lt, m√ºssen wir die Auflistung nicht von einem Element aus durchlaufen, und wir k√∂nnen sie mit der First-Eigenschaft abrufen.  Andernfalls m√ºssen Sie alle Segmente im Puffer durchgehen und jedes ReadOnlySpan verarbeiten. <br><br>  Diskussionsthema - in der ReadOnlySequence-Klasse werden nullf√§hige Referenztypen aktiv verwendet und es gibt goto (nicht zum Verlassen der Verschachtelung und nicht im generierten Code) - insbesondere <a href="">hier</a> <br><br>  Nach der Verarbeitung m√ºssen Sie der Pipe-Instanz klar machen, dass wir die Daten gelesen haben. <br><br><h3>  # 2 <a href="">bool TryRead (Ergebnis von ReadResult)</a> </h3><br>  Synchrone Version.  Erm√∂glicht es Ihnen, das Ergebnis zu erhalten, wenn dies der Fall ist.  Wenn es nicht bereits vorhanden ist, wird es im Gegensatz zu ReadAsync nicht blockiert, sondern gibt false zur√ºck.  Auch im Schloss. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition verbraucht, SequencePosition untersucht)</a> </h3><br>  Bei dieser Methode k√∂nnen Sie angeben, wie viele Bytes wir lesen und wie viele verarbeitet werden.  Daten, die gelesen, aber nicht verarbeitet wurden, werden beim n√§chsten Lesen zur√ºckgegeben.  Diese Funktion mag auf den ersten Blick seltsam erscheinen, aber bei der Verarbeitung eines Bytestroms ist es selten erforderlich, jedes Byte einzeln zu verarbeiten.  In der Regel werden Daten mithilfe von Nachrichten ausgetauscht.  Es kann vorkommen, dass der Leser beim Lesen eine ganze Nachricht und einen Teil der zweiten Nachricht erhalten hat.  Das Ganze muss verarbeitet werden, und ein Teil des zweiten sollte beim n√§chsten Mal √ºbrig bleiben, damit er mit dem verbleibenden Teil einhergeht.  Die AdvanceTo-Methode akzeptiert eine SequencePosition, bei der es sich tats√§chlich um ein Segment + einen Index handelt.  Wenn Sie alles verarbeiten, was ReadAsync gelesen hat, k√∂nnen Sie buffer.End angeben.  Andernfalls m√ºssen Sie explizit eine Position erstellen, die das Segment und den Index angibt, an dem die Verarbeitung gestoppt wurde.  Unter der Haube lok. <br>  Wenn die Menge der Rohdaten geringer ist als der installierte Fehler (_resumeWriterThreshold), wird die Fortsetzung von PipeWriter gestartet, wenn es blockiert wurde.  Standardm√§√üig betr√§gt dieser Schwellenwert 8 Segmentvolumes (die H√§lfte des Blockierungsschwellenwerts). <br><br><h3>  # 4 void Complete (Ausnahme Ausnahme = null) </h3><br>  Vervollst√§ndigt PipeReader.  Wenn PipeWriter zu diesem Zeitpunkt abgeschlossen ist, wird die gesamte Pipe-Instanz beendet.  Innen verschlie√üen. <br><br><h3>  # 5 void CancelPendingRead () </h3><br>  Erm√∂glicht das Abbrechen des aktuell erwarteten Messwerts.  Locke. <br><br><h3>  # 6 void OnWriterCompleted (Aktion &lt;Ausnahme, Objekt&gt; R√ºckruf, Objektstatus) </h3><br>  Hier k√∂nnen Sie den Delegaten angeben, der nach Abschluss des PipeWriter ausgef√ºhrt werden soll. <br>  Wie bei der √§hnlichen Methode f√ºr PipeWriter enth√§lt die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> denselben Hinweis, der entfernt wird.  Unter der Haube verriegeln. <br><br><h2>  Beispiel </h2><br><br>  Die folgende Auflistung zeigt ein Beispiel f√ºr die Arbeit mit Rohren. <br>  Seit der Einf√ºhrung von .NET Core Span und Memory wurden viele Klassen f√ºr die Arbeit mit Daten durch √úberladungen mit diesen Typen erg√§nzt.  Das allgemeine Interaktionsschema ist also ungef√§hr das gleiche.  In meinem Beispiel habe ich Pipelines verwendet, um mit Pipes zu arbeiten (ich mag Wurzelw√∂rter), d. H.  Kan√§le - Betriebssystemobjekte f√ºr die Interprozesskommunikation.  Die Kanal-API wurde gerade entsprechend erweitert, um Daten in Span und Memory zu lesen.  Die asynchrone Version verwendet Speicher, da die asynchrone Methode mithilfe einer automatisch generierten endlichen Zustandsmaschine, in der alle lokalen Variablen und Methodenparameter gespeichert sind, in eine Vorlagenmethode konvertiert wird. Da Span ref readonly struct ist, kann sie mit Span nicht auf dem Heap sein bei einer asynchronen Methode ist dies nicht m√∂glich.  Es gibt aber auch eine synchrone Version der Methode, mit der Sie Span verwenden k√∂nnen.  In meinem Beispiel habe ich beide ausprobiert und es stellte sich heraus, dass sich die synchrone Version in dieser Situation besser zeigt.  Bei Verwendung wird weniger Speicherbereinigung durchgef√ºhrt und die Datenverarbeitung ist schneller.  Dies lag jedoch nur daran, dass viele Daten vorhanden waren.  F√ºr den Fall, dass zum Zeitpunkt der Beantragung des n√§chsten Stapels wahrscheinlich keine Daten vorliegen, sollten Sie die asynchrone Version verwenden, um den Prozessorleerlauf nicht zu belasten. <br>  Das Beispiel enth√§lt Kommentare, die einige Punkte erl√§utern.  Ich mache Sie darauf aufmerksam, dass trotz der Tatsache, dass die Fragmente des Programms, die f√ºr das Lesen aus der Pipe und die Verarbeitung verantwortlich sind, beim Schreiben in eine Datei getrennt werden, die Daten genau an der Stelle gelesen werden, an der sie beim Lesen aus der Pipe geschrieben wurden. <br><br><div class="spoiler">  <b class="spoiler_title">Jahre der Evolution f√ºr ein m√§chtiges Feature - asynchrone Maine</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pipepatawriter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/         -       . //int readBytes = await _namedPipe.ReadAsync(buffer, token); //         PipeWriter Span //         -       . int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); //      ,        //         if (readBytes == 0) { await Task.Delay(500, token); continue; } // ,       _pipeWriter.Advance(readBytes); //  ,      PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); //  PipeReader  ,       //        ,      if (result.IsCompleted) { break; } } //  _pipeWriter     Pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Datenprozessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">//     Pipe ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; //      await _bytesProcessor.ProcessBytesAsync(buffer, token); // ,      .       ,   //  ,               //    IBytesProcessor.ProcessBytesAsync   ,    _pipeReader.AdvanceTo(buffer.End); //  PipeWriter  ,      //      ,      if (result.IsCompleted) { break; } } //  _pipeReader     Pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bytesprozessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//,         IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464921/">https://habr.com/ru/post/de464921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464909/index.html">"Sie beobachten uns": Was kann in einem unauff√§lligen Minivan direkt unter Ihrem Fenster passieren?</a></li>
<li><a href="../de464913/index.html">"Know kaizen": Was ist diese Philosophie zur Verbesserung der Produktionsprozesse?</a></li>
<li><a href="../de464915/index.html">Optimierung der JavaScript-Schwanzrekursion</a></li>
<li><a href="../de464917/index.html">Nach dem Cyberpunk: Was Sie √ºber aktuelle Genres der modernen Science-Fiction wissen m√ºssen</a></li>
<li><a href="../de464919/index.html">Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung</a></li>
<li><a href="../de464925/index.html">UX Voice Guide: Situationen, Muster, Werkzeuge (und ein bisschen moralische Unterst√ºtzung)</a></li>
<li><a href="../de464927/index.html">ASIC Miner aus zweiter Hand: Risiken, √úberpr√ºfung und neu verkabelte Hashrate</a></li>
<li><a href="../de464929/index.html">Faules Laden von Browserbildern (Ladeattribut)</a></li>
<li><a href="../de464931/index.html">Assembler-Einf√ºgungen ... in C #?</a></li>
<li><a href="../de464933/index.html">Anwendungen f√ºr E-Books auf dem Android-Betriebssystem. Teil 4. Spiele</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>