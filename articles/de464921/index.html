<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏻 🤛🏾 🥔 System.IO.Pipelines - ein wenig bekanntes Tool für Liebhaber hoher Leistung 🤲🏻 🈺 👏🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Leser. Seit der Veröffentlichung von .NET Core 2.1 ist ziemlich viel Zeit vergangen. Und solche coolen Innovationen wie Span und Memory wurden b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines - ein wenig bekanntes Tool für Liebhaber hoher Leistung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464921/">  Hallo Leser.  Seit der Veröffentlichung von .NET Core 2.1 ist ziemlich viel Zeit vergangen.  Und solche coolen Innovationen wie Span und Memory wurden bereits weit verbreitet, man kann viel darüber lesen, sehen und hören.  Leider erhielt eine Bibliothek namens System.IO.Pipelines nicht die gleiche Aufmerksamkeit.  Fast alles, was zu diesem Thema gehört, ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einzige Beitrag</a> , den viele zu Hause übersetzt und gepostet haben.  Es sollte auf jeden Fall mehr Informationen geben, damit Interessenten die Technologie aus verschiedenen Blickwinkeln betrachten können. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  Einführung </h2><br>  Ziel dieser Bibliothek ist es daher, die Arbeit mit der Streaming-Datenverarbeitung zu beschleunigen.  Es wurde ursprünglich vom Entwicklungsteam von Kestrel (einem plattformübergreifenden Webserver für ASP.NET Core) erstellt und verwendet, wird jedoch derzeit über ein separates <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nuget-Paket bereitgestellt</a> . <br>  Bevor wir uns mit dem Thema befassen, können wir uns den Bibliotheksmechanismus als ein verbessertes Analogon von MemoryStream vorstellen.  Das Problem mit dem ursprünglichen MemoryStream ist eine übermäßige Anzahl von Kopien. Dies ist offensichtlich, wenn Sie sich daran erinnern, dass ein privates Byte-Array im Inneren als Puffer verwendet wird.  Beispielsweise ist bei den <a href="">Lese-</a> und <a href="">Schreibmethoden das</a> Kopieren deutlich sichtbar.  Daher wird für das Objekt, das in den Stream geschrieben werden soll, eine Kopie im internen Puffer erstellt, und während des Lesens wird eine Kopie der internen Kopie an den Verbraucher geliefert.  Es klingt nicht nach der rationalsten Raumnutzung. <br>  System.IO.Pipelines zielt nicht darauf ab, alle Streams zu ersetzen, sondern ist ein zusätzliches Tool im Arsenal eines Entwicklers, der Hochleistungscode schreibt.  Ich schlage vor, dass Sie sich mit den grundlegenden Methoden und Klassen vertraut machen, sehen, wie sie im Inneren angeordnet sind, und grundlegende Beispiele analysieren. <br><br>  Beginnen wir mit dem internen Gerät und untersuchen gleichzeitig einfache Codefragmente.  Danach wird klar, was und wie es funktioniert und wie es verwendet werden soll.  Bei der Arbeit mit System.IO.Pipelines ist zu beachten, dass das Grundkonzept darin besteht, dass alle Lese- / Schreibvorgänge ohne zusätzliche Zuordnungen erfolgen sollten.  Einige auf den ersten Blick attraktive Methoden widersprechen dieser Regel.  Dementsprechend beginnt der Code, den Sie so schnell zu beschleunigen versuchen, Speicher für neue und neue Daten zuzuweisen, wodurch der Garbage Collector geladen wird. <br><br>  Die interne Bibliothek der Bibliothek nutzt die umfangreichsten Möglichkeiten der neuesten Versionen von Sprache und Zeitspanne, Spanne, Speicher, Objektpools, ValueTask usw.  Zumindest ein gutes Beispiel für die Verwendung dieser Funktionen in der Produktion ist einen Blick wert. <br>  Zu einer Zeit waren einige mit der Implementierung von Streams in C # unzufrieden, da eine Klasse sowohl zum Lesen als auch zum Schreiben verwendet wurde.  Aber wie sie sagen, können Sie keine Methoden aus einer Klasse werfen.  Selbst wenn der Stream das Lesen / Schreiben / Verschieben des Zeigers nicht unterstützte, wurden die Eigenschaften CanRead, CanWrite und CanSeek wirksam, die wie eine kleine Krücke aussahen.  Hier ist das anders. <br>  Für die Arbeit mit Pipes werden zwei Klassen verwendet: <a href="">PipeWriter</a> und <a href="">PipeReader</a> .  Diese Klassen enthalten jeweils etwa 50 Zeilen und sind Pseudofassaden (nicht die klassischsten Inkarnationen, da eine einzige Klasse dahinter verborgen ist und nicht viele) für die <a href="">Pipe-</a> Klasse, die die gesamte grundlegende Logik für die Arbeit mit Daten enthält.  Von den öffentlichen Mitgliedern - 2 Konstruktoren, 2 Nur-Get-Eigenschaften - Reader und Writer, die Reset () -Methode, die interne Felder auf ihren Ausgangszustand zurücksetzt, damit die Klasse wiederverwendet werden kann.  Andere Arbeitsmethoden werden als Pseudofassaden bezeichnet. <br><br><h2>  Erste Schritte mit der Pipe-Klasse </h2><br>  Die Klasseninstanz belegt 320 Bytes, was ziemlich viel ist (fast ein Drittel eines Kilobytes, 2 solcher Objekte konnten nicht in den Speicher von Manchester Mark I passen).  Es ist also eine schlechte Idee, es in großen Mengen zuzuweisen.  Darüber hinaus ist die Bedeutung des Objekts für den langfristigen Gebrauch bestimmt.  Die Verwendung von Pools liefert auch ein Argument für diese Aussage.  Immerhin werden die im Pool verwendeten Objekte für immer leben (auf jeden Fall im Standard). <br>  Beachten Sie, dass die Klasse als versiegelt markiert und threadsicher ist - viele Abschnitte des Codes sind ein kritischer Abschnitt und in Sperren eingeschlossen. <br>  Erstellen Sie zunächst eine Instanz der Pipe-Klasse und rufen Sie die Objekte PipeReader und PipeWriter mit den genannten Eigenschaften ab. <br><br><div class="spoiler">  <b class="spoiler_title">Einfache Initialisierung</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Betrachten Sie die Methoden zum Arbeiten mit Rohren: <br>  Für die Aufnahme über PipeWriter - WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Complete, CancelPendingFlush, OnReaderCompleted. <br>  Zum Lesen von PipeReader - AdvanceTo, ReadAsync, TryRead, Complete, CancelPendingRead, OnWriterCompleted. <br><br>  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag angegeben</a> , verwendet die Klasse eine einfach verknüpfte Liste von Puffern.  Offensichtlich werden sie jedoch nicht zwischen PipeReader und PipeWriter übertragen - die gesamte Logik befindet sich in einer Klasse.  Diese Liste wird sowohl zum Lesen als auch zum Schreiben verwendet.  Darüber hinaus werden die zurückgegebenen Daten in dieser Liste gespeichert. <br>  Es gibt auch Objekte, die den Beginn der zu lesenden Daten (ReadHead und Index), das Ende der zu lesenden Daten (ReadTail und Index) und den Beginn der zu schreibenden Stelle (WriteHead und die Anzahl der geschriebenen gepufferten Bytes) angeben.  Hier sind ReadHead, ReadTail und WriteHead ein bestimmtes Segment aus der Liste, und der Index gibt eine bestimmte Position innerhalb des Segments an.  Somit kann die Aufzeichnung in der Mitte eines Segments beginnen, das gesamte nächste Segment erfassen und in der Mitte des dritten Segments enden.  Diese Zeiger bewegen sich auf verschiedene Arten. <br><br><h2>  Erste Schritte mit PipeWriter-Methoden </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (ReadOnlyMemory &lt;Byte&gt; -Quelle, CancellationToken CancellationToken)</a> </h3><br>  Genau diese verlockende Methode.  Hat eine sehr geeignete und trendige Signatur - akzeptiert ReadOnlyMemory, asynchron.  Und viele mögen versucht sein, sich besonders daran zu erinnern, dass Span und Memory so schnell und cool sind.  Aber schmeichel dir nicht.  Diese Methode kopiert lediglich das an sie übergebene ReadOnlyMemory in die interne Liste.  Und "Kopieren" bedeutet einen Aufruf der CopyTo-Methode und nicht das Kopieren des Objekts selbst.  Das heißt, alle Daten, die wir aufzeichnen möchten, werden kopiert, wodurch der Speicher geladen wird.  Diese Methode sollte nur untersucht werden, um sicherzustellen, dass es besser ist, sie nicht zu verwenden.  Nun, und vielleicht für einige seltene Situationen ist dieses Verhalten angemessen. <br>  Der Hauptteil der Methode ist ein kritischer Abschnitt. Der Zugriff darauf wird über einen Monitor synchronisiert. <br><br>  Dann kann sich die Frage stellen, wie man etwas schreibt, wenn nicht mit der naheliegendsten und einzig geeigneten Methode. <br><br><h3>  # 2 <a href="">Speicher &lt;Byte&gt; GetMemory (int sizeHint)</a> </h3><br>  Die Methode verwendet einen Parameter eines Integer-Typs.  Darin müssen wir angeben, wie viele Bytes wir schreiben möchten (oder mehr, aber auf keinen Fall weniger).  Diese Methode prüft, ob in dem in _writingHeadMemory gespeicherten aktuellen Speicherfragment genügend Speicherplatz zum Schreiben vorhanden ist.  Wenn dies ausreicht, wird _writingHeadMemory als Speicher zurückgegeben.  Wenn nicht, wird für die Daten, die in den Puffer geschrieben wurden, für die jedoch die FlushAsync-Methode nicht aufgerufen wurde, ein anderes BufferSegment aufgerufen, das mit dem vorherigen verbunden ist (hier die Liste).  In Abwesenheit von _writingHeadMemory wird es mit einem neuen BufferSegment initialisiert.  Die Zuweisung des nächsten Puffers ist ein kritischer Abschnitt und erfolgt unter der Sperre. <br>  Ich schlage einen Blick auf ein solches Beispiel vor.  Auf den ersten Blick scheint es, dass der Compiler (oder die Laufzeit) den Dämon verführt hat. <br><br><div class="spoiler">  <b class="spoiler_title">Teufelei</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048  4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Aber alles in diesem Beispiel ist verständlich und einfach. <br>  Beim Erstellen einer Pipe-Instanz können wir ein <a href="">PipeOptions-</a> Objekt mit Optionen zum Erstellen an den Konstruktor übergeben. <br><br>  PipeOptions verfügt über ein Standardfeld für die minimale Segmentgröße.  Vor nicht allzu langer Zeit war es 2048, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Commit</a> änderte alles, jetzt 4096. Zum Zeitpunkt des Schreibens war die Version mit 4096 ein Vorabversionspaket, in der neuesten Release-Version war es 2048. Dies erklärt das Verhalten des ersten Beispiels.  Wenn Sie eine kleinere Größe für den Standardpuffer verwenden möchten, können Sie diese in einer Instanz des Typs PipeOptions angeben. <br><br>  Im zweiten Beispiel, in dem die Mindestgröße angegeben ist, stimmt die Länge ohnehin nicht überein.  Und dies geschieht bereits, weil die Erstellung eines neuen BufferSegments mithilfe von Pools erfolgt.  Eine der Optionen in PipeOptions ist der Speicherpool.  Danach wird der angegebene Pool verwendet, um ein neues Segment zu erstellen.  Wenn Sie Ihren Speicherpool nicht angegeben haben, wird der Standard-ArrayPool verwendet, der, wie Sie wissen, mehrere Buckets für unterschiedliche Arraysgrößen enthält (jeder nächste ist zweimal größer als der vorherige). Wenn Sie nach einer bestimmten Größe gefragt werden, wird nach einem Bucket mit Arrays geeigneter Größe gesucht (dann) es ist das nächste größer oder gleich).  Dementsprechend ist der neue Puffer mit ziemlicher Sicherheit größer als von Ihnen angefordert.  Die minimale Arraygröße im Standard-ArrayPool (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) beträgt 16. Machen Sie sich jedoch keine Sorgen, da dies ein Pool von Arrays ist.  Dementsprechend belastet das Array in den allermeisten Fällen den Garbage Collector nicht und wird wiederverwendet. <br><br><h3>  # 2.5 <a href="">Span &lt;Byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Es funktioniert ähnlich und gibt Span from Memory. <br><br>  Daher sind GetMemory () oder GetSpan () die Hauptmethoden zum Schreiben.  Sie geben uns ein Objekt, an das wir schreiben können.  Dazu müssen wir keinen Speicher für neue Wertearrays zuweisen, sondern können direkt in die interne Struktur schreiben.  Welche verwendet werden soll, hängt hauptsächlich von der verwendeten API und der asynchronen Methode ab.  In Anbetracht des Vorstehenden stellt sich jedoch eine Frage.  Woher weiß der Leser, wie viel wir geschrieben haben?  Wenn wir immer eine bestimmte Implementierung des Pools verwenden würden, die ein Array mit genau der gewünschten Größe ergibt, könnte der Leser den gesamten Puffer auf einmal lesen.  Wie wir bereits gesagt haben, wird uns jedoch ein Puffer mit einer hohen Wahrscheinlichkeit einer größeren Größe zugewiesen.  Dies führt zu der folgenden für den Betrieb erforderlichen Methode. <br><br><h3>  # 3 <a href="">void Advance (int Bytes)</a> </h3><br>  Eine schrecklich einfache Methode.  Es wird die Anzahl der als Argument geschriebenen Bytes verwendet.  Sie erhöhen die internen Zähler - _unflushedBytes und _writingHeadBytesBuffered, deren Namen für sich selbst sprechen.  Außerdem wird _writingHeadMemory genau auf die Anzahl der geschriebenen Bytes gekürzt (mithilfe der Slice-Methode).  Daher müssen Sie nach dem Aufrufen dieser Methode einen neuen Speicherblock in Form von Memory oder Span anfordern. Sie können nicht in den vorherigen schreiben.  Und der gesamte Körper der Methode ist ein kritischer Abschnitt und läuft unter einem Schloss. <br><br>  Es scheint, dass der Leser danach Daten empfangen kann.  Es ist jedoch noch ein Schritt erforderlich. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (CancellationToken CancellationToken)</a> </h3><br>  Die Methode wird aufgerufen, nachdem wir die erforderlichen Daten in den empfangenen Speicher geschrieben und angegeben haben, wie viel wir dort geschrieben haben.  Die Methode gibt eine ValueTask zurück, ist jedoch nicht asynchron (im Gegensatz zu ihrem Nachkommen StreamPipeWriter).  ValueTask ist ein spezieller Typ (schreibgeschützte Struktur), der verwendet wird, wenn die meisten Aufrufe keine Asynchronität verwenden, dh alle erforderlichen Daten zum Zeitpunkt des Aufrufs verfügbar sind und die Methode synchron endet.  Im Inneren enthält es entweder Daten oder Task (falls es nicht synchron funktioniert hat).  Dies hängt vom Status der Eigenschaft _writerAwaitable.IsCompleted ab.  Wenn wir nach Änderungen des Status dieses wartenden Objekts suchen, werden wir feststellen, dass dies unter der Bedingung geschieht, dass die Menge der nicht verarbeiteten (nicht verbrauchten) Daten (dies ist nicht genau die gleiche wie die Menge der ungelesenen (nicht untersuchten) Daten, die später erläutert wird) einen bestimmten Schwellenwert überschreitet (_pauseWriterThreshold).  Der Standardwert beträgt 16 Segmentgrößen.  Falls gewünscht, kann der Wert in PipeOptions geändert werden.  Diese Methode startet auch die Fortsetzung der ReadAsync-Methode, falls eine blockiert wurde. <br><br>  Gibt ein FlushResult zurück, das zwei Eigenschaften enthält - IsCanceled und IsCompleted.  IsCanceled gibt an, ob Flush abgebrochen wurde (CancelPendingFlush-Aufruf).  IsCompleted gibt an, ob der PipeReader abgeschlossen wurde (durch Aufrufen der Methoden Complete () oder CompleteAsync ()). <br>  Der Hauptteil der Methode wird unter Locke Skywalker durchgeführt. <br><br>  Andere Methoden von PipeWriter sind aus Sicht der Implementierung nicht von Interesse und werden viel seltener verwendet, daher wird nur eine kurze Beschreibung gegeben. <br><br><h3>  # 5 void Complete (Ausnahme Ausnahme = null) oder ValueTask CompleteAsync (Ausnahme Ausnahme = null) </h3><br>  Markiert das zum Schreiben geschlossene Rohr.  Nach Abschluss wird eine Ausnahme ausgelöst, wenn versucht wird, die Methoden zum Schreiben zu verwenden.  Wenn PipeReader bereits abgeschlossen wurde, wird auch die gesamte Pipe-Instanz abgeschlossen.  Die meiste Arbeit wird unter dem Schloss erledigt. <br><br><h3>  # 6 void CancelPendingFlush () </h3><br>  Wie der Name schon sagt, wird die aktuelle FlushAsync () -Operation abgeschlossen.  Es gibt ein lok. <br><br><h3>  # 7 void OnReaderCompleted (Aktion &lt;Ausnahme, Objekt&gt; Rückruf, Objektstatus) </h3><br>  Führt den delegierten Delegaten aus, wenn der Reader abgeschlossen ist.  Es gibt auch ein Schloss. <br>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> heißt es derzeit, dass diese Methode bei einigen PipeWriter-Nachkommen möglicherweise nicht aufgerufen wird und in Zukunft entfernt wird.  Daher sollten Sie keine Logik an diese Methoden binden. <br><br><h2>  Gehen Sie zu PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (CancellationToken-Token)</a> </h3><br>  Hier wird wie bei FlushAsync eine ValueTask zurückgegeben, die darauf hinweist, dass die Methode größtenteils synchron ist, jedoch nicht immer.  Hängt vom Status von _readerAwaitable ab.  Wie bei FlushAsync müssen Sie feststellen, wann _readerAwaitable auf unvollständig gesetzt ist.  Dies geschieht, wenn PipeReader alles aus der Liste liest (oder Daten enthält, die als geprüft markiert wurden und weitere Daten benötigen, um fortzufahren).  Was in der Tat logisch ist.  Dementsprechend können wir den Schluss ziehen, dass es wünschenswert ist, Pipe genau auf Ihre Arbeit abzustimmen und alle Optionen sorgfältig auf der Grundlage empirisch identifizierter Statistiken festzulegen.  Durch eine ordnungsgemäße Konfiguration wird die Wahrscheinlichkeit eines asynchronen Ausführungszweigs verringert und eine effizientere Datenverarbeitung ermöglicht.  Fast die gesamte Methode ist von einem Schloss umgeben. <br><br>  Gibt ein mysteriöses <a href="">ReadResult zurück</a> .  Tatsächlich ist es nur ein Puffer + Flags, der den Status des Vorgangs anzeigt (IsCanceled - ob ReadAsync abgebrochen wurde und IsCompleted angibt, ob der PipeWriter geschlossen wurde).  In diesem Fall ist IsCompleted ein Wert, der angibt, ob die Methoden PipeWriter Complete () oder CompleteAsync () aufgerufen wurden.  Wenn diese Methoden mit einer Ausnahme aufgerufen wurden, wird sie beim Lesen ausgelöst. <br><br>  Der Puffer hat wieder einen mysteriösen Typ - <a href="">ReadOnlySequence</a> .  Dies ist wiederum ein Objekt zum Enthalten von <a href="">Segmenten (ReadOnlySequenceSegment) der</a> Anfangs- und End- + Start- und Endindizes innerhalb der entsprechenden Segmente.  Was eigentlich der Struktur der Pipe-Klasse selbst ähnelt.  BufferSegment ist übrigens der Nachfolger von ReadOnlySequenceSegment, was darauf hindeutet, dass es dort verwendet wird.  Dank dieser Funktion können Sie unnötige Speicherzuweisungen für die Datenübertragung vom Schreiber zum Leser vermeiden. <br>  ReadOnlySpan kann zur weiteren Verarbeitung aus dem Puffer abgerufen werden.  Um das Bild zu vervollständigen, können Sie überprüfen, ob der Puffer einen einzelnen ReadOnlySpan enthält.  Wenn es enthält, müssen wir die Auflistung nicht von einem Element aus durchlaufen, und wir können sie mit der First-Eigenschaft abrufen.  Andernfalls müssen Sie alle Segmente im Puffer durchgehen und jedes ReadOnlySpan verarbeiten. <br><br>  Diskussionsthema - in der ReadOnlySequence-Klasse werden nullfähige Referenztypen aktiv verwendet und es gibt goto (nicht zum Verlassen der Verschachtelung und nicht im generierten Code) - insbesondere <a href="">hier</a> <br><br>  Nach der Verarbeitung müssen Sie der Pipe-Instanz klar machen, dass wir die Daten gelesen haben. <br><br><h3>  # 2 <a href="">bool TryRead (Ergebnis von ReadResult)</a> </h3><br>  Synchrone Version.  Ermöglicht es Ihnen, das Ergebnis zu erhalten, wenn dies der Fall ist.  Wenn es nicht bereits vorhanden ist, wird es im Gegensatz zu ReadAsync nicht blockiert, sondern gibt false zurück.  Auch im Schloss. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition verbraucht, SequencePosition untersucht)</a> </h3><br>  Bei dieser Methode können Sie angeben, wie viele Bytes wir lesen und wie viele verarbeitet werden.  Daten, die gelesen, aber nicht verarbeitet wurden, werden beim nächsten Lesen zurückgegeben.  Diese Funktion mag auf den ersten Blick seltsam erscheinen, aber bei der Verarbeitung eines Bytestroms ist es selten erforderlich, jedes Byte einzeln zu verarbeiten.  In der Regel werden Daten mithilfe von Nachrichten ausgetauscht.  Es kann vorkommen, dass der Leser beim Lesen eine ganze Nachricht und einen Teil der zweiten Nachricht erhalten hat.  Das Ganze muss verarbeitet werden, und ein Teil des zweiten sollte beim nächsten Mal übrig bleiben, damit er mit dem verbleibenden Teil einhergeht.  Die AdvanceTo-Methode akzeptiert eine SequencePosition, bei der es sich tatsächlich um ein Segment + einen Index handelt.  Wenn Sie alles verarbeiten, was ReadAsync gelesen hat, können Sie buffer.End angeben.  Andernfalls müssen Sie explizit eine Position erstellen, die das Segment und den Index angibt, an dem die Verarbeitung gestoppt wurde.  Unter der Haube lok. <br>  Wenn die Menge der Rohdaten geringer ist als der installierte Fehler (_resumeWriterThreshold), wird die Fortsetzung von PipeWriter gestartet, wenn es blockiert wurde.  Standardmäßig beträgt dieser Schwellenwert 8 Segmentvolumes (die Hälfte des Blockierungsschwellenwerts). <br><br><h3>  # 4 void Complete (Ausnahme Ausnahme = null) </h3><br>  Vervollständigt PipeReader.  Wenn PipeWriter zu diesem Zeitpunkt abgeschlossen ist, wird die gesamte Pipe-Instanz beendet.  Innen verschließen. <br><br><h3>  # 5 void CancelPendingRead () </h3><br>  Ermöglicht das Abbrechen des aktuell erwarteten Messwerts.  Locke. <br><br><h3>  # 6 void OnWriterCompleted (Aktion &lt;Ausnahme, Objekt&gt; Rückruf, Objektstatus) </h3><br>  Hier können Sie den Delegaten angeben, der nach Abschluss des PipeWriter ausgeführt werden soll. <br>  Wie bei der ähnlichen Methode für PipeWriter enthält die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> denselben Hinweis, der entfernt wird.  Unter der Haube verriegeln. <br><br><h2>  Beispiel </h2><br><br>  Die folgende Auflistung zeigt ein Beispiel für die Arbeit mit Rohren. <br>  Seit der Einführung von .NET Core Span und Memory wurden viele Klassen für die Arbeit mit Daten durch Überladungen mit diesen Typen ergänzt.  Das allgemeine Interaktionsschema ist also ungefähr das gleiche.  In meinem Beispiel habe ich Pipelines verwendet, um mit Pipes zu arbeiten (ich mag Wurzelwörter), d. H.  Kanäle - Betriebssystemobjekte für die Interprozesskommunikation.  Die Kanal-API wurde gerade entsprechend erweitert, um Daten in Span und Memory zu lesen.  Die asynchrone Version verwendet Speicher, da die asynchrone Methode mithilfe einer automatisch generierten endlichen Zustandsmaschine, in der alle lokalen Variablen und Methodenparameter gespeichert sind, in eine Vorlagenmethode konvertiert wird. Da Span ref readonly struct ist, kann sie mit Span nicht auf dem Heap sein bei einer asynchronen Methode ist dies nicht möglich.  Es gibt aber auch eine synchrone Version der Methode, mit der Sie Span verwenden können.  In meinem Beispiel habe ich beide ausprobiert und es stellte sich heraus, dass sich die synchrone Version in dieser Situation besser zeigt.  Bei Verwendung wird weniger Speicherbereinigung durchgeführt und die Datenverarbeitung ist schneller.  Dies lag jedoch nur daran, dass viele Daten vorhanden waren.  Für den Fall, dass zum Zeitpunkt der Beantragung des nächsten Stapels wahrscheinlich keine Daten vorliegen, sollten Sie die asynchrone Version verwenden, um den Prozessorleerlauf nicht zu belasten. <br>  Das Beispiel enthält Kommentare, die einige Punkte erläutern.  Ich mache Sie darauf aufmerksam, dass trotz der Tatsache, dass die Fragmente des Programms, die für das Lesen aus der Pipe und die Verarbeitung verantwortlich sind, beim Schreiben in eine Datei getrennt werden, die Daten genau an der Stelle gelesen werden, an der sie beim Lesen aus der Pipe geschrieben wurden. <br><br><div class="spoiler">  <b class="spoiler_title">Jahre der Evolution für ein mächtiges Feature - asynchrone Maine</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pipepatawriter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/         -       . //int readBytes = await _namedPipe.ReadAsync(buffer, token); //         PipeWriter Span //         -       . int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); //      ,        //         if (readBytes == 0) { await Task.Delay(500, token); continue; } // ,       _pipeWriter.Advance(readBytes); //  ,      PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); //  PipeReader  ,       //        ,      if (result.IsCompleted) { break; } } //  _pipeWriter     Pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Datenprozessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">//     Pipe ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; //      await _bytesProcessor.ProcessBytesAsync(buffer, token); // ,      .       ,   //  ,               //    IBytesProcessor.ProcessBytesAsync   ,    _pipeReader.AdvanceTo(buffer.End); //  PipeWriter  ,      //      ,      if (result.IsCompleted) { break; } } //  _pipeReader     Pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bytesprozessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//,         IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464921/">https://habr.com/ru/post/de464921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464909/index.html">"Sie beobachten uns": Was kann in einem unauffälligen Minivan direkt unter Ihrem Fenster passieren?</a></li>
<li><a href="../de464913/index.html">"Know kaizen": Was ist diese Philosophie zur Verbesserung der Produktionsprozesse?</a></li>
<li><a href="../de464915/index.html">Optimierung der JavaScript-Schwanzrekursion</a></li>
<li><a href="../de464917/index.html">Nach dem Cyberpunk: Was Sie über aktuelle Genres der modernen Science-Fiction wissen müssen</a></li>
<li><a href="../de464919/index.html">Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung</a></li>
<li><a href="../de464925/index.html">UX Voice Guide: Situationen, Muster, Werkzeuge (und ein bisschen moralische Unterstützung)</a></li>
<li><a href="../de464927/index.html">ASIC Miner aus zweiter Hand: Risiken, Überprüfung und neu verkabelte Hashrate</a></li>
<li><a href="../de464929/index.html">Faules Laden von Browserbildern (Ladeattribut)</a></li>
<li><a href="../de464931/index.html">Assembler-Einfügungen ... in C #?</a></li>
<li><a href="../de464933/index.html">Anwendungen für E-Books auf dem Android-Betriebssystem. Teil 4. Spiele</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>