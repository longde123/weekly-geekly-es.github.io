<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋ 🙋🏻 🤮 Analisis mutasi, atau cara menguji tes ⬇️ 🧝 👈🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tidak pernah ada terlalu banyak tes - semua orang tahu itu. Meme tentang unit dan pengujian integrasi tidak lagi menyenangkan. Tetapi kami masih tidak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis mutasi, atau cara menguji tes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/421141/">  Tidak pernah ada terlalu banyak tes - semua orang tahu itu.  Meme tentang unit dan pengujian integrasi tidak lagi menyenangkan.  Tetapi kami masih tidak tahu apakah mungkin untuk mengandalkan hasil lulus tes, dan berapa persen cakupan yang memungkinkan kami untuk mencegah bug dalam produksi.  Jika perubahan fatal pada kode melewati tes, tanpa mempengaruhi hasilnya, maka solusinya menunjukkan sendiri - Anda perlu menguji tes! <br><br><img src="https://habrastorage.org/webt/6w/kv/4n/6wkv4nyll_4lnom-dlicndmsuhu.png"><br><br>  Pendekatan untuk mengotomatisasi tugas ini adalah laporan Mark Langovoy di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf</a> .  Video dan artikelnya singkat, dan idenya sangat bagus - Anda perlu mencatat. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-1820HwCJUA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Mark <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Langovoi</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">marklangovoi</a> ) bekerja di Yandex dalam proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yandex.Tolok</a> .  Ini adalah platform crowdsourcing untuk secara cepat menandai sejumlah besar data.  Pelanggan mengunduh data yang, misalnya, perlu dipersiapkan untuk digunakan dalam algoritma pembelajaran mesin, dan menetapkan harga, dan di sisi lain, pelaksana dapat menyelesaikan tugas dan mendapatkan uang. <br><br>  Di waktu luangnya, Mark mengembangkan Hari Pengembang Krasnodar Devodar, salah satu dari 19 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas TI</a> yang aktivisnya kami undang ke Frontend Conf di Moskow. <br><br><h2>  Pengujian <br></h2><br>  Ada berbagai jenis pengujian otomatis. <br><img src="https://habrastorage.org/webt/xv/dl/of/xvdlofex2xlqouaertrnrkq804c.png"><br><br>  Selama <strong>pengujian unit yang</strong> populer <strong>,</strong> kami menulis tes untuk bagian kecil (modul) aplikasi.  Mereka mudah ditulis, tetapi kadang-kadang selama integrasi dengan modul lain, mereka mungkin tidak berperilaku tepat seperti yang kita harapkan. <br><br>  Untuk menghindari hal ini, kita dapat menulis <strong>tes integrasi</strong> yang akan menguji operasi modul kita bersama. <br><img src="https://habrastorage.org/webt/ri/6k/gy/ri6kgykpne6mwcobow5wqwhphmq.png"><br><br>  Mereka sedikit lebih rumit, jadi hari ini kita akan fokus pada pengujian unit. <br><br><h2>  Pengujian unit <br></h2><br>  Setiap proyek yang menginginkan setidaknya stabilitas minimal adalah penulisan unit test. <br><br>  Pertimbangkan sebuah contoh. <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Signal</span></span></span><span class="hljs-class"> </span></span>{ on(callback) { ... } off(callback) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callbackIndex = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.indexOf(callback); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callbackIndex === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners = [ ...this.listeners.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, callbackIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>), ...this.listeners.slice(callbackIndex) ]; } trigger() { ... } }</code> </pre> <br>  Ada kelas Signal - ini adalah Event Emitter, yang memiliki metode on untuk berlangganan dan metode off untuk menghapus langganan - kami memeriksa apakah callback terdapat dalam array pelanggan, lalu hapus.  Dan, tentu saja, ada metode pemicu yang akan memanggil panggilan balik yang ditandatangani. <br><br>  Kami memiliki tes sederhana untuk contoh ini yang memanggil metode on dan off, dan kemudian pemicu, untuk memverifikasi bahwa panggilan balik tidak dipanggil setelah berhenti berlangganan. <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'off method should remove listener'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Signal(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wasCalled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callback = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { wasCalled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; signal.on(callback); signal.off(callback); signal.trigger(); expect(wasCalled).toBeFalsy(); });</code> </pre><br><h3>  Kriteria Penilaian Kualitas <br></h3><br>  Apa kriteria untuk menilai kualitas tes semacam itu? <br><br>  <strong>Cakupan kode</strong> adalah kriteria paling populer dan terkenal yang menunjukkan berapa persen dari baris kode dieksekusi ketika tes dijalankan. <br><img src="https://habrastorage.org/webt/8q/i8/om/8qi8om5vmjpwbthvc31xspmwtcu.png"><br><br>  Anda mungkin memiliki 70%, 80%, atau semua cakupan Kode 90%, tetapi apakah ini berarti bahwa ketika Anda mengumpulkan build berikutnya untuk produksi, semuanya akan baik-baik saja, atau ada yang salah? <br><br>  Mari kita kembali ke contoh kita. <br><br>  Jumat malam, Anda lelah, Anda sedang menyelesaikan fitur berikutnya.  Dan kemudian Anda menemukan kode ini yang ditulis rekan Anda.  Sesuatu tentang dirimu tampak rumit dan menakutkan bagimu. <br><br><pre> <code class="javascript hljs"> ...this.listeners.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, callbackIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>), ...this.listeners.slice(callbackIndex)</code> </pre><br>  Anda memutuskan bahwa Anda mungkin dapat menghapus array: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Signal</span></span></span><span class="hljs-class"> </span></span>{ ... off(callback) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callbackIndex = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.indexOf(callback); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callbackIndex === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners = []; } ... }</code> </pre><br>  Saya berkomitmen, menyusun proyek dan mengirimkannya ke produksi.  Tes lulus - mengapa tidak?  Dan dia pergi beristirahat di bar. <br><br><img src="https://habrastorage.org/webt/zv/ds/pb/zvdspbqun8lcjabukmbkna-eivo.png"><br><br>  Tetapi tiba-tiba, larut malam, sebuah telepon berdering ke penerima, bahwa semuanya jatuh, orang tidak dapat menggunakan produk, dan secara umum, bisnis membuang-buang uang!  Anda terbakar, Anda diancam akan dipecat. <br><br><img src="https://habrastorage.org/webt/5q/ac/4x/5qac4xp9819iwt9dwwue9rfvan8.png"><br><br>  Bagaimana cara menghadapinya?  Apa yang harus dilakukan dengan tes?  Bagaimana cara menangkap kesalahan bodoh primitif seperti itu?  Siapa yang akan menguji tes? <br><br>  Tentu saja, Anda dapat menyewa pasukan insinyur QA - biarkan mereka duduk dan bertepuk tangan aplikasi kami. <br><br><img src="https://habrastorage.org/webt/5n/7s/rd/5n7srdm7g3tk0iiakgj3oft8zum.png"><br><br>  Atau menyewa otomasi QA.  Mereka dapat disalahkan pada tes menulis - mengapa menulis sendiri jika ada orang khusus untuk ini? <br><br>  Tetapi sebenarnya itu mahal, jadi hari ini kita akan berbicara tentang analisis mutasional atau pengujian mutasional. <br><br><h2>  Pengujian Mutasi <br></h2><br>  Ini adalah cara untuk mengotomatiskan proses pengujian pengujian kami.  Tujuannya adalah untuk mengidentifikasi tes yang tidak efektif dan tidak lengkap, yaitu, pada kenyataannya, ini adalah <strong>tes pengujian</strong> . <br><br>  Idenya adalah mengubah potongan kode, menjalankan tes pada mereka, dan jika tes tidak jatuh, maka mereka tidak lengkap. <br><br>  Perubahan dibuat menggunakan operasi tertentu - <strong>mutator</strong> .  Mereka mengganti, misalnya, ditambah dengan minus, kalikan dengan membagi, dan operasi serupa lainnya.  Mutator dapat mengubah potongan kode, mengganti kondisi sementara, nol array bukannya menambahkan beberapa elemen ke array. <br><img src="https://habrastorage.org/webt/mu/xh/nb/muxhnbcmixwyzkp3xwoa5t0zywi.png"><br><br>  Sebagai hasil dari penerapan mutasi ke kode sumber, ia bermutasi dan menjadi <strong>mutan</strong> . <br><br>  Mutan dibagi menjadi dua kategori: <br><br><ol><li>  <strong>Membunuh</strong> - orang-orang di mana kami dapat mengidentifikasi penyimpangan, yaitu, di mana setidaknya satu tes jatuh. </li><li>  <strong>Yang selamat</strong> adalah orang-orang yang melarikan diri dari kami dan membawa bug untuk diproduksi. </li></ol><br>  Untuk menilai kualitas, ada metrik <strong>MSI (Indikator Skor Mutasi)</strong> - persentase mutan yang terbunuh dan selamat.  Semakin besar perbedaan antara tes cakupan kode dan MSI, semakin buruk persentase cakupan kode mencerminkan relevansi pengujian kami. <br><br>  Ini adalah sedikit teori, dan sekarang pertimbangkan bagaimana ini dapat digunakan dalam JavaScript. <br><br><h3>  Solusi javascript <br></h3><br>  Hanya ada satu alat pengujian mutasi yang aktif dalam pengembangan JavaScript - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stryker</a> .  Nama ini diberikan kepada instrumen untuk menghormati karakter X-man William Stryker - pencipta "Weapon X" dan seorang pejuang dengan semua mutan. <br><br><img src="https://habrastorage.org/webt/6w/kv/4n/6wkv4nyll_4lnom-dlicndmsuhu.png"><br><br>  Stryker bukan pelari ujian seperti Karma atau Jest;  juga bukan kerangka uji seperti Mocha atau Jasmine.  Ini adalah kerangka pengujian mutasi yang melengkapi infrastruktur Anda saat ini. <br><br><h3>  Sistem plugin <br></h3><br>  Stryker sangat fleksibel, sepenuhnya dibangun di atas sistem plug-in, yang sebagian besar ditulis oleh pengembang Stryker. <br><img src="https://habrastorage.org/webt/j3/2r/-n/j32r-ns1i8trfuitelgg3y_dpqu.png"><br><br>  Ada plugin untuk menjalankan tes pada Jest, Karma dan Mocha.  Ada integrasi dengan kerangka kerja Mocha (stryker-mocha-framework) Jasmine (stryker-jasmine) dan set mutator siap pakai untuk JavaScript, TypeScript dan bahkan untuk Vue: <br><br><ul><li>  stryker-javascript-mutator; </li><li>  stryker-typescript; </li><li>  stryker-vue-mutator. </li></ul><br>  Mutators for React termasuk dalam stryker-javascript-mutator.  Selain itu, Anda selalu dapat menulis mutator Anda sendiri. <br><br>  Jika Anda perlu mengubah kode sebelum menjalankan, Anda bisa menggunakan plugin untuk Webpack, Babel, atau TypeScript. <br><img src="https://habrastorage.org/webt/6f/qi/b3/6fqib3tsj-cjmqcnmpiyc45rmc4.png"><br><br>  Ini semua diatur relatif sederhana. <br><br><h3>  Konfigurasi <br></h3><br>  Konfigurasi tidak sulit: Anda hanya perlu menentukan di JSON config yang menjalankan test runner (dan / atau kerangka uji dan / atau transpiler) yang Anda gunakan, serta menginstal plugin yang sesuai dari npm. <br><br>  <strong>Stryker-cli</strong> utilitas konsol sederhana dapat melakukan semua ini untuk Anda dalam mode tanya jawab.  Dia akan bertanya apa yang Anda gunakan, dan akan mengkonfigurasi dirinya sendiri. <br><br><h3>  Bagaimana cara kerjanya <br></h3><br>  Siklus hidup sederhana dan terdiri dari langkah-langkah berikut: <br><br><ul><li>  Membaca dan menganalisis konfigurasi.  Stryker mengunduh konfigurasi dan menganalisisnya untuk berbagai plugin, pengaturan, pengecualian file, dll. </li><li>  Unduh plugin sesuai dengan konfigurasi. </li><li>  Menjalankan tes pada kode sumber untuk memeriksa apakah tes relevan sekarang (tiba-tiba mereka sudah rusak). </li><li>  Jika semuanya baik-baik, satu set mutan dihasilkan dari file yang kami ijinkan untuk dimutasi. </li><li>  Menjalankan tes pada mutan. </li></ul><br><img src="https://habrastorage.org/webt/6v/ww/yn/6vwwynfb_hq570upwyur0zrp5fq.png"><br><br>  Di atas adalah contoh memulai Stryker: <br><br><ul><li>  Stryker memulai; </li><li>  membaca konfigurasi; </li><li>  memuat dependensi yang diperlukan; </li><li>  menemukan file yang akan bermutasi; </li><li>  menjalankan tes pada kode sumber; </li><li>  menciptakan 152 mutan; </li><li>  menjalankan tes dalam 8 utas (dalam hal ini, berdasarkan jumlah inti CPU). </li></ul><br>  Ini bukan proses cepat, jadi lebih baik melakukannya di beberapa server CI / CD. <br><br>  Setelah melewati semua tes, Stryker memberikan laporan singkat tentang file-file dengan jumlah mutan yang dibuat, dibunuh dan selamat, serta persentase rasio mutan yang terbunuh terhadap survivor (MSI) dan mutator yang digunakan. <br><br>  Ini adalah masalah potensial yang tidak diperkirakan dalam pengujian kami. <br><br><h3>  Untuk meringkas <br></h3><br>  <strong>Pengujian mutasi bermanfaat dan menarik</strong> .  Ini dapat menemukan masalah pada tahap awal pengujian, dan tanpa partisipasi orang.  Ini akan mengurangi waktu untuk validasi permintaan tarik, misalnya, karena fakta bahwa pengembang yang memenuhi syarat tidak perlu menghabiskan waktu untuk validasi permintaan tarik, yang sudah memiliki masalah potensial.  Atau simpan produksi jika Anda memutuskan untuk mempersiapkan rilis baru pada Jumat malam. <br><br>  Stryker adalah alat pengujian mutasi multithreaded fleksibel.  Ini aktif berkembang, tetapi sejauh ini lembab, belum mencapai versi utama.  Misalnya, selama persiapan laporan ini, para pengembangnya akhirnya memungkinkan dalam plugin untuk Babel untuk menentukan file konfigurasi dan memperbaiki integrasi Jest.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> OpenSource yang dapat dibantu untuk dikembangkan. <br><br><div class="spoiler">  <b class="spoiler_title">Faq</b> <div class="spoiler_text">  <em>- Bagaimana cara menguji tes mutasi?</em>  <em>Tentunya ada kesalahan juga.</em>  <em>Dalam contoh pengujian unit pertama, cakupan adalah 90%.</em>  <em>Tampaknya semuanya baik-baik saja, tetapi masih kasus-kasus menyelinap ketika semuanya jatuh dan terbakar.</em>  <em>Karena itu, mengapa harus ada perasaan bahwa semuanya baik-baik saja setelah meliput tes mutasi ini?</em> <br><br>  - Saya tidak mengatakan bahwa pengujian mutasi adalah peluru perak dan itu akan menyembuhkan segalanya.  Tentu, mungkin ada beberapa kasus gila batas atau tidak adanya semacam mutator.  Pertama-tama, kesalahan tipikal mudah ditangkap.  Misalnya, Anda memberi tanda centang pada usia, atur ke &lt;18 (itu perlu &lt;=), dan dalam tes lupa melakukan pemeriksaan kasus batas.  Anda membuat perbandingan lain dengan mutator, dan sebagai hasilnya, tes jatuh (atau tidak jatuh), dan Anda mengerti bahwa semuanya baik atau semuanya buruk.  Hal-hal seperti itu cepat ditangkap.  Ini adalah cara untuk hanya menambahkan tes dengan benar, menemukan poin yang hilang. <br><br>  <em>- Seringkali Anda memiliki situasi "tertegun dan pergi"?</em>  <em>Saya pikir ini tidak benar.</em> <br><br>  - Tidak, tapi saya pikir dalam banyak proyek hal seperti itu memang ada.  Secara alami, ini tidak benar.  Banyak orang berpikir bahwa cakupan Kode membantu memeriksa semuanya, Anda dapat pergi dengan aman dan tidak khawatir - tetapi tidak demikian. <br><br>  <em>- Saya akan langsung mengatakan apa masalahnya.</em>  <em>Kami memiliki banyak semua jenis reduksi dan hal-hal lain yang kami uji bersama, dan ada banyak dari mereka.</em>  <em>Ini semua tumbuh, dan ternyata untuk setiap permintaan tarik, pengujian mutasi diluncurkan, yang membutuhkan banyak waktu.</em>  <em>Apakah mungkin menjalankan hanya pada apa yang telah berubah?</em> <br><br>  "Aku pikir kamu bisa mengkonfigurasinya sendiri."  Misalnya, di sisi pengembang, ketika dia mendorong, melakukan, Anda dapat membuat plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bertahap</a> yang hanya akan menjalankan file yang telah berubah.  Pada CI / CD, ini juga mungkin.  Dalam kasus kami, proyek ini sangat besar dan tua, dan kami berlatih pengujian spot.  Kami tidak memeriksa semuanya, karena itu akan memakan waktu seminggu, akan ada ratusan ribu mutasi.  Saya akan merekomendasikan melakukan pemeriksaan langsung, atau mengatur sendiri proses startup selektif.  Saya belum melihat alat yang siap pakai untuk integrasi seperti itu. <br><br>  <em>- Apakah kelengkapan semua kemungkinan mutasi untuk bagian kode tertentu dipastikan?</em>  <em>Jika tidak, bagaimana sebenarnya mutasi dipilih?</em> <br><br>  - Saya pribadi tidak memeriksa, tetapi saya juga tidak menemui masalah dengan ini.  Stryker harus menghasilkan semua mutasi yang mungkin pada potongan kode yang sama. <br><br>  <em>- Saya ingin bertanya tentang snapshot.</em>  <em>Tes unit saya menguji logika, dan, termasuk tata letak komponen reaksi snapshot.</em>  <em>Secara alami, jika saya mengubah desain logis apa pun, tata letak saya akan berubah di sana.</em>  <em>Ini perilaku yang diharapkan, bukan?</em> <br><br>  - Ya, itulah artinya, bahwa Anda memperbarui foto secara manual. <br><br>  <em>- Jadi, Anda entah bagaimana mengabaikan foto dalam laporan ini?</em> <br><br>  - Kemungkinan besar, snapshot perlu diperbarui terlebih dahulu, dan kemudian jalankan pengujian mutasi, jika tidak akan ada banyak sampah dari Stryker. <br><br>  <em>- Pertanyaan tentang server CI.</em>  <em>Untuk pengujian unit sederhana, ada reporter, di bawah GitLab, untuk apa pun yang Anda inginkan, yang menampilkan persentase tes yang berhasil, dan Anda dapat mengonfigurasi apakah gagal atau tidak gagal.</em>  <em>Bagaimana dengan Stryker?</em>  <em>Ini hanya menampilkan tablet di konsol, tetapi apa yang bisa saya lakukan selanjutnya?</em> <br><br>  - Mereka memiliki HTML-reporter, Anda dapat membuat reporter Anda sendiri - semuanya dapat disesuaikan secara fleksibel.  Mungkin ada beberapa alat khusus, tetapi karena kami masih melakukan pengujian mutasi titik, saya tidak menemukan integrasi spesifik dengan TeamCity dan alat CI / CD serupa. <br><br>  <em>- Seberapa banyak tes mutasi meningkatkan dukungan untuk tes yang Anda miliki secara umum?</em>  <em>Artinya, tes itu menyusahkan, dan tes harus ditulis ulang ketika kode ditulis ulang, dll. Terkadang lebih mudah untuk menulis ulang kode daripada tes.</em>  <em>Dan di sini saya juga memiliki tes mutasi.</em>  <em>Seberapa mahal untuk sebuah bisnis?</em> <br><br>  - Pertama, saya mungkin akan memperbaiki bahwa menulis ulang kode demi tes itu salah.  Kode harus mudah diuji.  Mengenai apa yang perlu diselesaikan, penting sekali bagi bisnis ini agar pengujiannya selengkap dan seefektif mungkin.  Jika tidak lengkap, ini berarti bug dapat terjadi yang akan menyebabkan kerugian.  Secara alami, Anda hanya dapat menguji bagian terpenting untuk bisnis. <br><br>  <em>"Tetap saja, betapa jauh lebih mahal jadinya ketika tes mutasi muncul, daripada jika mereka tidak ada di sana."</em> <br><br>  - Sebanyak tes buruk sekarang.  Jika tes ditulis dengan buruk sekarang, Anda harus menambahkan banyak.  Pengujian mutasi akan menemukan kasus yang tidak tercakup oleh tes. <br><br>  <em>“Ada banyak penilaian di slide hasil tes Stryker, mereka kritis atau tidak kritis.</em>  <em>Bagaimana cara menangani kesalahan positif?</em> <br><br>  - Pertanyaan halus adalah apa yang dianggap salah.  Saya bertanya kepada orang-orang di tim kami hal-hal menarik apa yang terjadi pada mereka.  Ada contoh tentang teks kesalahan.  Stryker melaporkan bahwa tes tidak menanggapi perubahan teks kesalahan.  Tampaknya menjadi tiang, tetapi kecil. <br><br>  <em>- Jadi Anda melihat kesalahan seperti itu dan melewatkan kesalahan yang tidak penting dalam mode manual?</em> <br><br>  "Kami memiliki pemeriksaan spot, jadi ya." <br><br>  <em>- Saya punya pertanyaan praktis.</em>  <em>Ketika Anda menerapkan ini, berapa persen dari tes yang Anda gagal?</em> <br><br>  - Kami tidak mengimplementasikannya pada keseluruhan proyek, tetapi ada masalah kecil pada proyek baru.  Oleh karena itu, saya tidak bisa mengatakan angka pastinya, tetapi secara umum, pendekatannya sudah pasti memperbaiki situasi. <br></div></div><br><blockquote>  Lihat pertunjukan front-end lainnya yang sama bermanfaatnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran youtube</a> kami, semua laporan tematik dari semua konferensi kami secara bertahap sampai di sana.  Atau berlangganan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buletin</a> , dan kami akan memberi Anda informasi tentang semua materi baru dan berita konferensi mendatang. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421141/">https://habr.com/ru/post/id421141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421131/index.html">Kerentanan Penting Server 1Cloud</a></li>
<li><a href="../id421133/index.html">LINKa. Keyboard kertas. Tombol ekstra besar</a></li>
<li><a href="../id421135/index.html">Au / Ni / MgO: transfer panas berskala nano</a></li>
<li><a href="../id421137/index.html">Cara Kerja Chrome Tanpa Kepala</a></li>
<li><a href="../id421139/index.html">Frontend Conf - menjaga pengguna</a></li>
<li><a href="../id421143/index.html">Aurora Labs S-Titanium Pro Mini Logam 3D Printer</a></li>
<li><a href="../id421147/index.html">Monster setelah liburan: AMD Threadripper 2990WX 32-Core dan 2950X 16-Core</a></li>
<li><a href="../id421149/index.html">Beberapa kata tentang gradien</a></li>
<li><a href="../id421153/index.html">CPU 24-core, tapi saya tidak bisa mengetikkan email (bagian 2)</a></li>
<li><a href="../id421155/index.html">Pencetakan 3D pada tahun 2018: hal yang paling menarik di industri ini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>