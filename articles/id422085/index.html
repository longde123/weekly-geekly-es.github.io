<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿ ğŸ˜¥ ğŸ’…ğŸ¼ Sortir berdasarkan pilihan ğŸ”© ğŸ‘ğŸ¾ ğŸ‘©ğŸ¿â€ğŸ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa ide menyortir berdasarkan pilihan? 



1. Dalam subarray yang tidak disortir, maksimum lokal (minimum) dicari. 
2. Maksimum (minimum) yang ditemuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sortir berdasarkan pilihan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422085/"><div style="text-align:center;"><img width="671" height="473" src="https://habrastorage.org/webt/ws/yv/vq/wsyvvqw8tdgk7xdvebnbiwv8pgk.png"></div><br><br>  Apa ide menyortir berdasarkan pilihan? <br><br><ol><li>  Dalam subarray yang tidak disortir, maksimum lokal (minimum) dicari. </li><li>  Maksimum (minimum) yang ditemukan mengubah tempat-tempat dengan elemen (pertama) terakhir dalam subarray. </li><li>  Jika subarrays yang tidak disortir tetap ada dalam array, lihat poin 1. </li></ol><br><a name="habracut"></a>  Penyimpangan liris sedikit.  Awalnya, dalam seri artikel saya, saya berencana untuk secara konsisten menyajikan materi tentang penyortiran kelas dalam urutan yang ketat.  Setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemilahan perpustakaan</a> , artikel tentang algoritma penyisipan lainnya direncanakan: pengurutan solitaire, pengurutan berdasarkan tabel Young, pengurutan menurut inversi, dll. <br><br>  Namun, sekarang trennya adalah nonlinier, oleh karena itu, tanpa menulis semua publikasi tentang penyortiran menurut sisipan, hari ini saya akan memulai cabang paralel tentang penyortiran berdasarkan pilihan.  Kemudian saya akan melakukan hal yang sama untuk kelas algoritmik lainnya: menggabungkan jenis, jenis distribusi, dll.  Ini umumnya akan memungkinkan publikasi untuk ditulis pada satu topik, kemudian pada yang lain.  Dengan rotasi tematik seperti itu akan lebih menyenangkan. <br><br><h1>  Sortir seleksi </h1><br><img width="570" height="95" src="https://habrastorage.org/webt/yt/cs/fz/ytcsfzyhzn9xy8opfyodmgz-a4u.gif"><br><br>  Sederhana dan bersahaja - kita menelusuri array untuk mencari elemen maksimum.  Maksimum yang ditemukan dipertukarkan dengan elemen terakhir.  Bagian array yang tidak disortir berkurang satu elemen (tidak termasuk elemen terakhir tempat kami menyusun ulang maksimum yang ditemukan).  Kami menerapkan tindakan yang sama untuk bagian yang tidak disortir ini - kami menemukan maksimum dan meletakkannya di tempat terakhir di bagian yang tidak disortir dari array.  Jadi kami melanjutkan hingga bagian array yang tidak disortir dikurangi menjadi satu elemen. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">selection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, e <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(data): mn = min(range(i, len(data)), key=data.__getitem__) data[i], data[mn] = data[mn], e <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br>  Menyortir dengan pilihan sederhana adalah pencarian ganda kasar.  Bisakah ini diperbaiki?  Mari kita lihat beberapa modifikasi. <br><br><h1>  Sortir pilihan ganda :: Sortir pilihan ganda </h1><br><img width="570" height="95" src="https://habrastorage.org/webt/jj/xn/kq/jjxnkqnbcbgwtqhxq9_p99kwmdi.gif"><br><br>  Gagasan serupa digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyortiran shaker</a> , yang merupakan varian dari penyortiran gelembung.  Melewati bagian array yang tidak disortir, selain maksimum, kami juga secara bersamaan menemukan minimum.  Kami menempatkan minimum di tempat pertama, maksimum di yang terakhir.  Dengan demikian, bagian yang tidak disortir pada setiap iterasi dikurangi oleh dua elemen sekaligus. <br><br>  Sepintas, tampaknya ini mempercepat algoritme sebanyak 2 kali - setelah setiap lintasan, subarray yang tidak disortir dikurangi bukan dari satu, tetapi dari dua sisi sekaligus.  Tetapi pada saat yang sama, jumlah perbandingan meningkat 2 kali, dan jumlah swap tetap tidak berubah.  Pilihan ganda hanya sedikit meningkatkan kecepatan algoritme, dan dalam beberapa bahasa bahkan bekerja lebih lambat karena alasan tertentu. <br><br><h1>  Perbedaan antara penyortiran berdasarkan pilihan dari penyortiran penyisipan </h1><br>  Tampaknya menyortir berdasarkan pilihan dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyortir berdasarkan sisipan</a> adalah satu dan hal yang sama, kelas umum dari algoritma.  Nah, atau menyortir berdasarkan sisipan adalah semacam penyortiran berdasarkan pilihan.  Atau mengurutkan berdasarkan pilihan adalah kasus khusus pengurutan berdasarkan sisipan.  Dan di sana-sini, kita bergiliran dari bagian array yang tidak disortir untuk mengekstrak elemen dan mengarahkannya ke area yang diurutkan. <br><br>  Perbedaan utama: dalam mengurutkan berdasarkan sisipan, kami mengekstrak elemen <u>apa pun</u> dari bagian array yang tidak disortir dan memasukkannya ke tempatnya di bagian yang diurutkan.  Dalam pemilihan sortir, kami sengaja mencari elemen <u>maksimum</u> (atau minimum) yang dengannya kami melengkapi bagian yang diurutkan dari array.  Di insets kita mencari di mana untuk memasukkan elemen berikutnya, dan dalam pilihan - kita sudah tahu sebelumnya tempat apa yang akan kita taruh, tetapi pada saat yang sama kita perlu menemukan elemen yang sesuai dengan tempat ini. <br><br>  Ini membuat kedua kelas algoritma sangat berbeda satu sama lain dalam esensinya dan metode yang digunakan. <br><br><h1>  Bingo sort :: Bingo sort </h1><br>  Fitur yang menarik dari pilihan pengurutan adalah kecepatan kemandirian dari sifat data yang disortir. <br><br>  Misalnya, jika array hampir diurutkan, maka, seperti yang Anda tahu, menyortir menurut sisipan akan memprosesnya lebih cepat (bahkan lebih cepat daripada penyortiran cepat).  Array dengan urutan terbalik untuk menyortir menurut sisipan adalah kasus yang merosot, ia akan mengurutkannya selama mungkin. <br><br>  Dan untuk mengurutkan berdasarkan pilihan, pemesanan sebagian atau terbalik dari array tidak memainkan peran - itu akan memprosesnya dengan kecepatan yang sama dengan yang acak acak.  Selain itu, untuk penyortiran klasik, tidak masalah jika array terdiri dari elemen unik atau berulang - ini praktis tidak mempengaruhi kecepatan. <br><br>  Namun pada prinsipnya, Anda bisa membuat dan memodifikasi algoritma sehingga itu bekerja lebih cepat dengan beberapa set data.  Misalnya, penyortiran bingo memperhitungkan jika array terdiri dari elemen berulang. <br><br><img width="608" height="225" src="https://habrastorage.org/webt/v3/me/ia/v3meiaqkqbdxg0yyxlar0oekvy8.gif"><br><br>  Kuncinya di sini adalah bahwa tidak hanya elemen maksimum yang diingat di bagian yang berantakan, tetapi juga maksimum untuk iterasi berikutnya ditentukan.  Hal ini memungkinkan untuk berulang maksimum tidak untuk mencari mereka lagi setiap kali, tetapi menempatkan mereka di tempat mereka segera setelah maksimum ini sekali lagi ditemui dalam array. <br><br>  Kompleksitas algoritmik tetap sama.  Tetapi jika array terdiri dari angka berulang, maka pengurutan bingo akan mengatasi sepuluh kali lebih cepat daripada pengurutan menurut pilihan biasa. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># - def bingo(data): #  . max = len(data) - 1 nextValue = data[max] for i in range(max - 1, -1, -1): if data[i] &gt; nextValue: nextValue = data[i] while max and data[max] == nextValue: max -= 1 #  . while max: value = nextValue nextValue = data[max] for i in range(max - 1, -1, -1): if data[i] == value: data[i], data[max] = data[max], data[i] max -= 1 elif data[i] &gt; nextValue: nextValue = data[i] while max and data[max] == nextValue: max -= 1 return data</span></span></code> </pre> <br><br><h1>  Sortir siklus :: Sortir siklus </h1><br>  Penyortiran loop menarik (dan berharga dari sudut pandang praktis) karena perubahan di antara elemen array terjadi jika dan hanya jika elemen diletakkan di tempat terakhirnya.  Ini bisa berguna jika menulis ulang dalam array terlalu mahal dan merawat memori fisik membutuhkan meminimalkan jumlah perubahan pada elemen array. <br><br><img width="608" height="147" src="https://habrastorage.org/webt/f0/ur/l9/f0url9pdtqepxtjjqbnl9aanuyo.gif"><br><br>  Ini berfungsi seperti ini.  Kami menyortir array, memanggil X sel berikutnya di lingkaran luar ini.  Dan kita melihat tempat apa dalam array yang kita butuhkan untuk memasukkan elemen selanjutnya dari sel ini.  Di tempat Anda ingin menempelkan beberapa elemen lain, kami mengirimkannya ke clipboard.  Untuk elemen ini di buffer, kami juga mencari tempatnya di array (dan menempelkannya ke tempat ini, dan mengirim ke buffer elemen yang muncul di tempat ini).  Dan untuk nomor baru di buffer, kami melakukan tindakan yang sama.  Berapa lama proses ini harus dilanjutkan?  Hingga elemen berikutnya di clipboard ternyata menjadi elemen yang perlu dimasukkan secara tepat di sel X (tempat saat ini dalam array di loop utama algoritma).  Cepat atau lambat momen ini akan terjadi dan kemudian di lingkaran luar Anda dapat pergi ke sel berikutnya dan ulangi prosedur yang sama untuk itu. <br><br>  Dalam jenis lain, berdasarkan pilihan, kami mencari maksimum / minimum untuk menempatkan mereka di tempat terakhir / pertama.  Dalam sortir siklus, ternyata setidaknya tempat pertama dalam subarray berada, seolah-olah, dalam proses bagaimana beberapa elemen lain diletakkan di tempat yang selayaknya di suatu tempat di tengah array. <br><br>  Dan di sini, kompleksitas algoritmik juga tetap dalam O ( <strong>n <sup>2</sup></strong> ).  Dalam praktiknya, pengurutan siklik bekerja bahkan beberapa kali lebih lambat daripada pilihan pengurutan biasa, karena Anda harus menjalankan array lebih banyak dan membandingkan lebih sering.  Ini adalah harga untuk jumlah penulisan ulang sekecil mungkin. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   def cycle(data): #        for cycleStart in range(0, len(data) - 1): value = data[cycleStart] # ,    pos = cycleStart for i in range(cycleStart + 1, len(data)): if data[i] &lt; value: pos += 1 #      ,   #      if pos == cycleStart: continue #   ,     #        while value == data[pos]: pos += 1 data[pos], value = value, data[pos] #      , #         while pos != cycleStart: # ,    pos = cycleStart for i in range(cycleStart + 1, len(data)): if data[i] &lt; value: pos += 1 #      #      while value == data[pos]: pos += 1 data[pos], value = value, data[pos] return data</span></span></code> </pre> <br><br><h1>  Semacam pancake </h1><br>  Algoritma yang telah menguasai semua tingkat kehidupan - dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bakteri</a> hingga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bill Gates</a> . <br><br><img width="585" height="240" src="https://habrastorage.org/webt/yy/y4/hd/yyy4hdfpntel75ckrnc9b31mum8.gif"><br><br>  Dalam kasus paling sederhana, kami mencari elemen maksimum di bagian array yang tidak diurutkan.  Ketika maksimum ditemukan, kami membuat dua belokan tajam.  Pertama, kita memutar rantai elemen sehingga maksimum berada di ujung yang berlawanan.  Kemudian kita membalikkan seluruh subarray yang tidak disortir, sebagai hasilnya maksimum jatuh ke tempatnya. <br><br>  Cordillets seperti itu, secara umum, menyebabkan kompleksitas algoritmik dalam O ( <strong>n <sup>3</sup></strong> ).  Ciliate yang terlatih ini berjatuhan dalam satu gerakan (oleh karena itu, dalam pelaksanaannya kompleksitasnya adalah O ( <strong>n <sup>2</sup></strong> )), dan ketika memprogram, pembalikan bagian array adalah siklus tambahan. <br><br>  Penyortiran pancake sangat menarik dari sudut pandang matematis (pikiran terbaik berpikir tentang menilai jumlah minimum flips yang cukup untuk menyortir), ada rumusan masalah yang lebih kompleks (dengan apa yang disebut sebagai satu sisi terbakar).  Topik pancake sangat menarik, mungkin saya akan menulis monograf yang lebih komprehensif tentang masalah ini. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   def pancake(data): if len(data) &gt; 1: for size in range(len(data), 1, -1): #      maxindex = max(range(size), key = data.__getitem__) if maxindex + 1 != size: #    ,    if maxindex != 0: #  , #     data[:maxindex+1] = reversed(data[:maxindex+1]) #    , #      data[:size] = reversed(data[:size]) return data</span></span></code> </pre> <br><br><hr><br>  Penyortiran pemilihan sama efektifnya dengan pencarian elemen minimum / maksimum di bagian array yang tidak disortir.  Dalam semua algoritma yang dianalisis hari ini, pencarian dilakukan dalam bentuk pencarian ganda.  Dan dalam pencarian ganda, apa pun yang dikatakan, kompleksitas algoritmik akan selalu tidak lebih baik daripada O ( <strong>n <sup>2</sup></strong> ).  Apakah ini berarti bahwa semua penyortiran berdasarkan pilihan ditakdirkan untuk berarti kompleksitas kuadrat?  Tidak sama sekali, jika proses pencarian diatur dengan cara yang secara fundamental berbeda.  Misalnya, pertimbangkan dataset sebagai heap dan cari di heap.  Namun, topik tumpukan bahkan bukan artikel, tetapi seluruh kisah, kita pasti akan berbicara tentang tumpukan, tetapi lain kali. <br><br><h2>  Referensi </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Seleksi</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Siklus</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Panekuk</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Panekuk</a> <br><br><h3>  Artikel Seri: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi Excel AlgoLab.xlsm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertukaran macam</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Urutan Penyisipan</a> </li><li>  <b>Sortir berdasarkan pilihan</b> <ul><li>  Penyortiran tumpukan biner dan modifikasi </li><li>  Pemilahan tumpukan binomial dan lemah </li><li>  Urutan Turnamen </li><li>  Penyortiran pohon Cartesian </li><li>  Semacam hutan </li><li>  Membandingkan Macam dengan Seleksi </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gabungkan Urusan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Urutkan berdasarkan distribusi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sortasi Hibrid</a> </li></ul><br>  Bingo, siklus, dan panekuk hari ini telah ditambahkan ke aplikasi AlgoLab.  Dalam yang terakhir, sehubungan dengan menggambar pancake, pembatasan telah ditempatkan - nilai-nilai elemen dalam array harus dari 1 hingga 5. Anda tentu saja dapat menambahkan lebih banyak, tetapi makro akan secara acak mengambil angka dari kisaran ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422085/">https://habr.com/ru/post/id422085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422073/index.html">Cara termudah untuk mendukung pengintegrasian klien java dengan server java</a></li>
<li><a href="../id422077/index.html">Apakah injeksi JavaScript relevan?</a></li>
<li><a href="../id422079/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 329 (27 Agustus - 2 September 2018)</a></li>
<li><a href="../id422081/index.html">Aplikasi untuk kerangka kerja untuk bot multi-platform</a></li>
<li><a href="../id422083/index.html">Situs satu halaman di Kotlin dan SpringBoot tanpa menggunakan JSP</a></li>
<li><a href="../id422087/index.html">Visi komputer dalam industri. Kuliah di Yandex</a></li>
<li><a href="../id422089/index.html">Konteks eksekusi JavaScript dan tumpukan panggilan</a></li>
<li><a href="../id422091/index.html">Penggunaan metode array yang efektif dalam JavaScript</a></li>
<li><a href="../id422093/index.html">"Mendongeng dengan Data," oleh Cole Nussbaumer Knaflic: ringkasan buku informal</a></li>
<li><a href="../id422095/index.html">Gadget audio khusus: suara "sunyi" dari "Medusa", "Bisikan" perisai dan 162 dB dari LRAD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>