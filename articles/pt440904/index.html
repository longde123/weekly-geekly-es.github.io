<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèæ üíç üï¥Ô∏è Compara√ß√£o das arquiteturas Viper e MVVM: como aplicar os dois üë• üìΩÔ∏è üéüÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Atualmente, o VIPER e o MVVM s√£o as solu√ß√µes arquiteturais mais populares usadas no desenvolvimento de grandes aplicativos que requerem participa√ß√£o n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compara√ß√£o das arquiteturas Viper e MVVM: como aplicar os dois</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440904/"><img src="https://habrastorage.org/webt/db/bn/4z/dbbn4zxc39qxt6vtlimqyjql5ko.jpeg"><br><br>  Atualmente, o VIPER e o MVVM s√£o as solu√ß√µes arquiteturais mais populares usadas no desenvolvimento de grandes aplicativos que requerem participa√ß√£o no desenvolvimento de grandes equipes bem testadas, com suporte a longo prazo e em constante evolu√ß√£o.  Neste artigo, tentaremos aplic√°-los em um pequeno projeto de teste, que √© uma lista de contatos do usu√°rio com a capacidade de adicionar um novo contato.  Este artigo tem mais pr√°tica do que anal√≠tica e destina-se principalmente √†queles que j√° est√£o em teoria familiarizados com essas arquiteturas e agora gostariam de entender como isso funciona com exemplos espec√≠ficos.  No entanto, uma descri√ß√£o b√°sica das arquiteturas e sua compara√ß√£o tamb√©m est√° presente. <br><a name="habracut"></a><br><br>  Este artigo √© uma tradu√ß√£o do artigo de Rafael Sacchi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúComparando as arquiteturas MVVM e Viper: quando usar uma ou outra‚Äù</a> .  Infelizmente, em algum momento da cria√ß√£o do artigo, a "publica√ß√£o" foi criada em vez de a "tradu√ß√£o", ent√£o voc√™ deve escrever aqui. <br><br>  Uma arquitetura bem projetada √© essencial para garantir suporte cont√≠nuo ao seu projeto.  Neste artigo, veremos as arquiteturas MVVM e VIPER como uma alternativa ao MVC tradicional. <br><br>  MVC √© um conceito bem conhecido para todos aqueles que est√£o envolvidos no desenvolvimento de software h√° algum tempo.  Esse padr√£o divide o projeto em tr√™s partes: Modelo representando entidades;  View, que √© uma interface para intera√ß√£o do usu√°rio;  e Controller, respons√°vel por garantir a intera√ß√£o entre o View e o Model.  Essa √© a arquitetura que a Apple nos oferece para usar em nossos aplicativos. <br><br>  No entanto, voc√™ provavelmente sabe que os projetos possuem muitas funcionalidades complexas: suporte para solicita√ß√µes de rede, an√°lise, acesso a modelos de dados, convers√£o de dados para sa√≠da, rea√ß√£o a eventos de interface etc.  Como resultado, voc√™ obt√©m grandes controladores que resolvem as tarefas acima e um monte de c√≥digo que n√£o pode ser reutilizado.  Em outras palavras, o MVC pode ser um pesadelo para um desenvolvedor com suporte a projetos de longo prazo.  Mas como garantir alta modularidade e reutiliza√ß√£o em projetos iOS? <br><br>  Veremos duas alternativas muito famosas √† arquitetura MVC: MVVM e VIPER.  Ambos s√£o bastante famosos na comunidade iOS e provaram que podem ser uma √≥tima alternativa ao MVC.  Falaremos sobre sua estrutura, escreveremos um exemplo de aplicativo e consideraremos casos em que √© melhor usar uma ou outra arquitetura. <br><br>  <b>Exemplo</b> <br><br>  Escreveremos um aplicativo com uma tabela de contatos do usu√°rio.  Voc√™ pode usar o c√≥digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deste reposit√≥rio</a> .  Nas pastas Starter, o esqueleto b√°sico do projeto est√° contido e, nas pastas Final, um aplicativo totalmente conclu√≠do. <br><br>  O aplicativo ter√° duas telas: na primeira, haver√° uma lista de contatos exibidos em uma tabela; na c√©lula, haver√° o nome e o sobrenome do contato, al√©m da imagem de base em vez da imagem do usu√°rio. <br><br><img src="https://habrastorage.org/webt/gn/kc/ww/gnkcwwblrc7b036fyvuz874zfpu.png"><br><br>  A segunda tela √© a tela para adicionar um novo contato, com os campos de entrada de nome e sobrenome e os bot√µes Conclu√≠do e Cancelar. <br><br><img src="https://habrastorage.org/webt/rx/b1/mv/rxb1mvegb0piorji2dovggxdj8q.png"><br><br>  <b>MVVM</b> <br><br>  Como funciona: <br><br>  MVVM significa <b>Model-View-ViewModel</b> .  Essa abordagem difere do MVC na l√≥gica da distribui√ß√£o de responsabilidades entre os m√≥dulos. <br><br><ul><li>  <b>Modelo</b> : Este m√≥dulo n√£o √© diferente daquele no MVC.  Ele √© respons√°vel pela cria√ß√£o de modelos de dados e pode conter l√≥gica de neg√≥cios.  Voc√™ tamb√©m pode criar classes auxiliares, por exemplo, como uma classe gerenciadora para gerenciar objetos no Modelo e gerenciador de rede para processar solicita√ß√µes e an√°lise de rede. </li><li>  <b>Ver</b> : E aqui tudo come√ßa a mudar.  O m√≥dulo View no MVVM abrange a interface (subclasses de arquivos UIView, .xib e .storyboard), l√≥gica de exibi√ß√£o (anima√ß√£o, renderiza√ß√£o) e manipula√ß√£o de eventos do usu√°rio (cliques no bot√£o etc.) No MVC, View e Controller s√£o respons√°veis ‚Äã‚Äãpor isso.  Isso significa que as visualiza√ß√µes que voc√™ possui permanecer√£o inalteradas, enquanto o ViewController conter√° uma pequena parte do que havia no MVC e, consequentemente, diminuir√° bastante. </li><li>  <b>ViewModel</b> : agora √© o local onde a maior parte do c√≥digo que voc√™ tinha anteriormente no ViewController estar√° localizada.  A camada ViewModel solicita dados do Modelo (pode ser uma solicita√ß√£o para um banco de dados local ou uma solicita√ß√£o de rede) e os transfere de volta para a View, no formato em que ser√£o usados ‚Äã‚Äãe exibidos l√°.  Mas este √© um mecanismo bidirecional, a√ß√µes ou dados inseridos pelo usu√°rio passam pelo ViewModel e atualizam o modelo.  Como o ViewModel controla tudo o que √© exibido, √© √∫til usar o mecanismo de vincula√ß√£o entre as duas camadas. </li></ul><br><br>  Comparado ao MVC, voc√™ est√° migrando de uma arquitetura parecida com esta: <br><br><img src="https://habrastorage.org/webt/op/i7/gq/opi7gqlutejiwvehje5zoeey96k.jpeg"><br><br>  Para a pr√≥xima vari√°vel de arquitetura: <br><br><img src="https://habrastorage.org/webt/zu/me/cj/zumecj56yf5vgzckbhjdarwx58i.png"><br><br>  Na qual as classes e subclasses de UIView e UIViewController s√£o usadas para implementar a View. <br><br>  Bem, agora ao ponto.  Vamos escrever um exemplo de nosso aplicativo usando a arquitetura MVVM. <br><br>  <b>Aplicativo MVVM Contacts</b> <br><br>  <b>MODELO</b> <br><br>  A classe a seguir √© um modelo de contato de contato: <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { @NSManaged var firstName: String? @NSManaged var lastName: String? var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " \(lastName)" } return name } } }</code> </pre> <br><br>  A classe de contato possui os campos <i>firstName</i> , <i>lastName</i> e a propriedade <i>fullName</i> calculada. <br><br>  <b>VER</b> <br><br>  VIEW inclui: Storyboard principal, com vistas j√° colocadas;  ContactsViewController, que exibe uma lista de contatos em uma tabela;  e AddContactViewController com um par de r√≥tulos e campos de entrada para adicionar o nome e o sobrenome do novo contato.  Vamos come√ßar com o <b>ContactsViewController</b> .  Seu c√≥digo ficar√° assim: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsViewController: UIViewController { @IBOutlet var tableView: UITableView! let contactViewModelController = ContactViewModelController() override func viewDidLoad() { super.viewDidLoad() tableView.tableFooterView = UIView() contactViewModelController.retrieveContacts({ [unowned self] in self.tableView.reloadData() }, failure: nil) } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { let addContactNavigationController = segue.destination as? UINavigationController let addContactVC = addContactNavigationController?.viewControllers[0] as? AddContactViewController addContactVC?.contactsViewModelController = contactViewModelController addContactVC?.didAddContact = { [unowned self] (contactViewModel, index) in let indexPath = IndexPath(row: index, section: 0) self.tableView.beginUpdates() self.tableView.insertRows(at: [indexPath], with: .left) self.tableView.endUpdates() } } } extension ContactsViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") as? ContactsTableViewCell guard let contactsCell = cell else { return UITableViewCell() } contactsCell.cellModel = contactViewModelController.viewModel(at: (indexPath as NSIndexPath).row) return contactsCell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactViewModelController.contactsCount } }</code> </pre> <br><br>  Mesmo com um olhar superficial, fica claro que essa classe √© implementada na maioria das tarefas da interface.  Ele tamb√©m possui navega√ß√£o no m√©todo <i>prepareForSegue (: :)</i> - e este √© exatamente o momento que ser√° alterado no VIPER ao adicionar uma camada de roteador. <br><br>  Vamos dar uma olhada na extens√£o da classe que implementa o protocolo UITableViewDataSource.  As fun√ß√µes n√£o funcionam diretamente com o modelo de contato do usu√°rio Contato na camada Modelo. Em vez disso, eles recebem dados (representados pela estrutura ContactViewModel) no formato em que ser√£o exibidos, j√° formatados usando o ViewModelController. <br><br>  O mesmo acontece em um circuito, que inicia imediatamente ap√≥s a cria√ß√£o de um contato.  Sua √∫nica tarefa √© adicionar uma linha √† tabela e atualizar a interface. <br><br>  Agora voc√™ precisa estabelecer um relacionamento entre a subclasse de UITableViewCell e ViewModel.  Isso seria semelhante √† classe de c√©lula da tabela <b>ContactsTableViewCell</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsTableViewCell: UITableViewCell { var cellModel: ContactViewModel? { didSet { bindViewModel() } } func bindViewModel() { textLabel?.text = cellModel?.fullName } }</code> </pre> <br><br>  E a classe <b>AddContactViewController</b> tamb√©m √©: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class AddContactViewController: UIViewController { @IBOutlet var firstNameTextField: UITextField! @IBOutlet var lastNameTextField: UITextField! var contactsViewModelController: ContactViewModelController? var didAddContact: ((ContactViewModel, Int) -&gt; Void)? override func viewDidLoad() { super.viewDidLoad() firstNameTextField.becomeFirstResponder() } @IBAction func didClickOnDoneButton(_ sender: UIBarButtonItem) { guard let firstName = firstNameTextField.text, let lastName = lastNameTextField.text else { return } if firstName.isEmpty || lastName.isEmpty { showEmptyNameAlert() return } dismiss(animated: true) { [unowned self] in self.contactsViewModelController?.createContact(firstName: firstName, lastName: lastName, success: self.didAddContact, failure: nil) } } @IBAction func didClickOnCancelButton(_ sender: UIBarButtonItem) { dismiss(animated: true, completion: nil) } fileprivate func showEmptyNameAlert() { showMessage(title: "Error", message: "A contact must have first and last names") } fileprivate func showMessage(title: String, message: String) { let alertView = UIAlertController(title: title, message: message, preferredStyle: .alert) alertView.addAction(UIAlertAction(title: "Ok", style: .destructive, handler: nil)) present(alertView, animated: true, completion: nil) } }</code> </pre> <br><br>  E, novamente, o trabalho principalmente com a interface do usu√°rio est√° acontecendo aqui.  Observe que AddContactViewController delega a funcionalidade de cria√ß√£o de contato para o ViewModelController na fun√ß√£o <i>didClickOnDoneButton (:)</i> . <br><br>  <b>VER MODELO</b> <br><br>  √â hora de falar sobre a nova camada ViewModel para n√≥s.  Primeiro, crie uma <b>classe de</b> contato <b>ContactViewModel</b> que fornecer√° a exibi√ß√£o que precisamos exibir e as fun√ß√µes &lt;and&gt; com par√¢metros ser√£o definidas para a classifica√ß√£o de contatos: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fullName: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bool</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: ContactViewModel, rhs: ContactViewModel)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  <b>O</b> c√≥digo <b>ContactViewModelController</b> ter√° a seguinte apar√™ncia: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModelController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactViewModelList: [<span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataManager = <span class="hljs-type"><span class="hljs-type">ContactLocalDataManager</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactsCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contacts = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.retrieveContactList() contactViewModelList = contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) } success?() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList[index] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(firstName: String, lastName: String, success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">(ContactViewModel, Int)</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contact = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.createContact(firstName: firstName, lastName: lastName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> insertionIndex = contactViewModelList.insertionIndex(of: contactViewModel) { $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; $<span class="hljs-number"><span class="hljs-number">1</span></span> } contactViewModelList.insert(contactViewModel, at: insertionIndex) success?(contactViewModel, insertionIndex) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } }</code> </pre><br><br>  <i><u>Nota: O</u></i> MVVM n√£o fornece uma defini√ß√£o exata de como criar um ViewModel.  Quando quero criar uma arquitetura mais em camadas, prefiro criar um ViewModelController que ir√° interagir com a camada Model e ser√° respons√°vel por criar os objetos ViewModel. <br><br>  O principal √© muito f√°cil de lembrar: a camada ViewModel n√£o deve estar envolvida no trabalho com a interface do usu√°rio.  Para evitar isso, √© melhor <b>nunca</b> importar o UIKit para um arquivo com o ViewModel. <br><br>  A classe ContactViewModelController solicita contatos do armazenamento local e tenta n√£o afetar a camada Modelo.  Ele retorna os dados no formato que a visualiza√ß√£o requer para ser exibida e notifica a visualiza√ß√£o quando um novo contato √© adicionado e os dados s√£o alterados. <br><br>  Na vida real, isso seria uma solicita√ß√£o de rede, e n√£o uma solicita√ß√£o ao banco de dados local, mas em nenhum dos casos nenhum deveria fazer parte do ViewModel - o trabalho em rede e o trabalho com o banco de dados local devem ser fornecidos usando seus pr√≥prios gerentes ( gerentes). <br><br>  Isso √© tudo sobre o MVVM.  Talvez essa abordagem pare√ßa mais test√°vel, suportada e distribu√≠da que o MVC.  Agora vamos falar sobre o VIPER e ver como ele difere do MVVM. <br><br>  <b>VIPER</b> <br><br>  Como funciona: <br><br>  VIPER √© uma implementa√ß√£o de Arquitetura Limpa para projetos iOS.  Sua estrutura consiste em: Exibir, Interagir, Apresentador, Entidade e Roteador.  Essa √© realmente uma arquitetura modular e muito distribu√≠da, que permite compartilhar responsabilidades, √© muito bem coberta por testes de unidade e torna seu c√≥digo reutiliz√°vel. <br><br><ul><li>  <b>Exibi√ß√£o</b> : uma camada de interface que geralmente implica arquivos UIKit (incluindo o UIViewController).  √â compreens√≠vel que em sistemas mais distribu√≠dos, as subclasses do UIViewController estejam relacionadas ao View.  No VIPER, as coisas s√£o quase as mesmas que no MVVM: o View √© respons√°vel por exibir o que o Presenter fornece e por transmitir informa√ß√µes ou a√ß√µes inseridas pelo usu√°rio ao Presenter. </li><li>  <b>Interator</b> : Cont√©m a l√≥gica de neg√≥cios necess√°ria para o aplicativo funcionar.  O Interactor √© respons√°vel por recuperar dados do Model (solicita√ß√µes de rede ou locais) e sua implementa√ß√£o n√£o est√° relacionada √† interface do usu√°rio.  √â importante lembrar que os gerentes locais e de rede n√£o fazem parte do VIPER, mas s√£o tratados como depend√™ncias separadas. </li><li>  <b>Apresentador</b> : Respons√°vel pela formata√ß√£o dos dados a serem exibidos na Visualiza√ß√£o.  No MVVM em nosso exemplo, o ViewModelController foi respons√°vel por isso.  O Presenter recebe dados do Interactor, cria uma inst√¢ncia do ViewModel (uma classe formatada para exibi√ß√£o correta) e os passa para o View.  Ele tamb√©m responde √† entrada de dados do usu√°rio, solicita dados adicionais do banco de dados ou vice-versa, passa-os para ela. </li><li>  <b>Entidade</b> : faz parte da responsabilidade da camada Modelo, que √© usada em outras arquiteturas.  Entidade √© um objeto de dados simples, sem l√≥gica de neg√≥cios, gerenciado por um trator online e v√°rios gerenciadores de dados. </li><li>  <b>Roteador</b> : Toda a l√≥gica de navega√ß√£o do aplicativo.  Pode parecer que essa n√£o √© a camada mais importante, mas se voc√™ precisar, por exemplo, reutilizar a mesma exibi√ß√£o no iPhone e no aplicativo para iPad, a √∫nica coisa que pode mudar √© como as exibi√ß√µes s√£o exibidas na tela.  Isso permite que voc√™ n√£o toque em mais camadas, exceto o roteador, que ser√° respons√°vel por isso em cada caso. </li></ul><br><br>  Comparado ao MVVM, o VIPER possui v√°rias diferen√ßas importantes na distribui√ß√£o de responsabilidades: <br><br>  - ele tem um roteador, uma camada separada respons√°vel pela navega√ß√£o <br><br>  - Entidades s√£o objetos de dados simples, redistribuindo a responsabilidade de acessar dados do Model para o Interactor <br><br>  - As responsabilidades do ViewModelController s√£o compartilhadas entre o Interactor e o Presenter <br><br>  E agora vamos repetir o mesmo aplicativo, mas j√° no VIPER.  Mas, para facilitar a compreens√£o, faremos apenas um controlador com contatos.  Voc√™ pode encontrar o c√≥digo do controlador para adicionar um novo contato no projeto usando o link (pasta VIPER Contacts Starter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste reposit√≥rio</a> ). <br><br>  <i><u>Nota</u></i> : Se voc√™ decidir criar seu projeto no VIPER, n√£o tente criar todos os arquivos manualmente - voc√™ pode usar um dos geradores de c√≥digo, por exemplo, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VIPER Gen</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Generamba (projeto Rambler)</a> . <br><br>  <b>VIPER Contacts App</b> <br><br>  <b>VER</b> <br><br>  VIEW √© representado por elementos do Main.storyboard e da classe ContactListView.  VIEW √© muito passivo;  suas √∫nicas tarefas s√£o transferir eventos da interface para o Presenter e atualizar seu estado, mediante notifica√ß√£o do Presenter.  √â assim que o c√≥digo <b>ContactListView se</b> parece: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListView: UIViewController { @IBOutlet var tableView: UITableView! var presenter: ContactListPresenterProtocol? var contactList: [ContactViewModel] = [] override func viewDidLoad() { super.viewDidLoad() presenter?.viewDidLoad() tableView.tableFooterView = UIView() } @IBAction func didClickOnAddButton(_ sender: UIBarButtonItem) { presenter?.addNewContact(from: self) } } extension ContactListView: ContactListViewProtocol { func reloadInterface(with contacts: [ContactViewModel]) { contactList = contacts tableView.reloadData() } func didInsertContact(_ contact: ContactViewModel) { let insertionIndex = contactList.insertionIndex(of: contact) { $0 &lt; $1 } contactList.insert(contact, at: insertionIndex) let indexPath = IndexPath(row: insertionIndex, section: 0) tableView.beginUpdates() tableView.insertRows(at: [indexPath], with: .right) tableView.endUpdates() } } extension ContactListView: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { guard let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") else { return UITableViewCell() } cell.textLabel?.text = contactList[(indexPath as NSIndexPath).row].fullName return cell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactList.count } }</code> </pre> <br><br>  O View envia os eventos <i>viewDidLoad</i> e <i>didClickOnAddButton</i> ao Presenter.  No primeiro evento, o Presenter solicitar√° dados do Interactor e, no segundo, o Presenter solicitar√° que o Roteador mude para o controlador para adicionar um novo contato. <br><br>  Os m√©todos do protocolo ContactListViewProtocol s√£o chamados no Presenter quando uma lista de contatos √© solicitada ou quando um novo contato √© adicionado.  Nos dois casos, os dados na Visualiza√ß√£o cont√™m apenas as informa√ß√µes necess√°rias para exibi√ß√£o. <br><br>  Tamb√©m na exibi√ß√£o est√£o os m√©todos que implementam o protocolo UITableViewDataSource que preenchem a tabela com os dados recebidos. <br><br>  <b>INTERACTOR</b> <br><br>  Interator em nosso exemplo √© bastante simples.  Tudo o que ele faz √© solicitar dados atrav√©s do gerenciador de banco de dados local, e n√£o importa para ele o que esse gerenciador, CoreData, Realm ou qualquer outra solu√ß√£o usa.  O c√≥digo em ContactListInteractor ser√° o seguinte: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorInputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter: <span class="hljs-type"><span class="hljs-type">ContactListInteractorOutputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localDatamanager: <span class="hljs-type"><span class="hljs-type">ContactListLocalDataManagerInputProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactList = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> localDatamanager?.retrieveContactList() { presenter?.didRetrieveContacts(contactList) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { presenter?.didRetrieveContacts([]) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { presenter?.didRetrieveContacts([]) } } }</code> </pre> <br><br>  Ap√≥s o Interactor receber os dados solicitados, ele notifica o Presenter.  Al√©m disso, como op√ß√£o, o Interactor pode transmitir um erro ao Presenter, que precisar√° formatar o erro em uma exibi√ß√£o adequada para exibi√ß√£o em View. <br><br>  <i>Nota</i> : Como voc√™ deve ter notado, cada camada no VIPER implementa um protocolo.  Como resultado, as classes dependem de abstra√ß√µes e n√£o de uma implementa√ß√£o espec√≠fica, atendendo ao princ√≠pio da invers√£o de depend√™ncia (um dos princ√≠pios do SOLID). <br><br>  <b>APRESENTADOR</b> <br><br>  O elemento mais importante da arquitetura.  Toda a comunica√ß√£o entre o View e o restante das camadas (Interactor e Roteador) passa pelo Presenter.  C√≥digo da <b>Empresa</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> view: <span class="hljs-type"><span class="hljs-type">ContactListViewProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interactor: <span class="hljs-type"><span class="hljs-type">ContactListInteractorInputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wireFrame: <span class="hljs-type"><span class="hljs-type">ContactListWireFrameProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { interactor?.retrieveContacts() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from view: ContactListViewProtocol)</span></span></span></span> { wireFrame?.presentAddContactScreen(from: view) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorOutputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didRetrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contacts: [Contact])</span></span></span></span> { view?.reloadInterface(with: contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) }) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddModuleDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contact: Contact)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) view?.didInsertContact(contactViewModel) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didCancelAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre> <br><br>  Depois que o View √© carregado, ele notifica o Presenter, que, por sua vez, solicita dados atrav√©s do Interactor.  Quando o usu√°rio clica no bot√£o Adicionar novo contato, o View notifica o Presenter, que envia uma solicita√ß√£o para abrir a tela Adicionar novo contato no roteador. <br><br>  O Presenter tamb√©m formata os dados e os retorna para a tela depois de consultar a lista de contatos.  Ele tamb√©m √© respons√°vel pela implementa√ß√£o do protocolo AddModuleDelegate.  Isso significa que o Presenter receber√° uma notifica√ß√£o quando um novo contato for adicionado, prepare os dados do contato para exibi√ß√£o e transfira para Exibir. <br><br>  Como voc√™ deve ter notado, o Presenter tem todas as chances de se tornar bastante complicado.  Se houver essa possibilidade, o Presenter pode ser dividido em duas partes: O Presenter, que recebe apenas dados, formata-os para exibi√ß√£o e os passa para View;  e um manipulador de eventos que responder√° √†s a√ß√µes do usu√°rio. <br><br>  <b>ENTITY</b> <br><br>  Essa camada √© semelhante √† camada Model no MVVM.  Em nossa aplica√ß√£o, ele √© representado pela classe Contact e pelas fun√ß√µes de defini√ß√£o do operador &lt;e&gt;.  <b>O</b> conte√∫do do <b>contato</b> ficar√° assim: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " " + lastName } return name } } } public struct ContactViewModel { var fullName = "" } public func &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } public func &gt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  ContactViewModel cont√©m os campos que o Presenter preenche (formata) que a Exibi√ß√£o exibe.  A classe Contact √© uma subclasse de NSManagedObject que cont√©m os mesmos campos que no modelo CoreData. <br><br>  <b>ROUTER</b> <br><br>  E, finalmente, a √∫ltima camada, mas certamente n√£o em import√¢ncia.  Toda responsabilidade pela navega√ß√£o √© do Presenter e do WireFrame.  O Presenter recebe um evento do usu√°rio e sabe quando fazer a transi√ß√£o, e o WireFrame sabe como e onde fazer essa transi√ß√£o.  Para que voc√™ n√£o fique confuso, neste exemplo, a camada Roteador √© representada pela classe ContactListWireFrame e √© referida como WireFrame no texto.  C√≥digo do quadro: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListWireFrame: ContactListWireFrameProtocol { class func createContactListModule() -&gt; UIViewController { let navController = mainStoryboard.instantiateViewController(withIdentifier: "ContactsNavigationController") if let view = navController.childViewControllers.first as? ContactListView { let presenter: ContactListPresenterProtocol &amp; ContactListInteractorOutputProtocol = ContactListPresenter() let interactor: ContactListInteractorInputProtocol = ContactListInteractor() let localDataManager: ContactListLocalDataManagerInputProtocol = ContactListLocalDataManager() let wireFrame: ContactListWireFrameProtocol = ContactListWireFrame() view.presenter = presenter presenter.view = view presenter.wireFrame = wireFrame presenter.interactor = interactor interactor.presenter = presenter interactor.localDatamanager = localDataManager return navController } return UIViewController() } static var mainStoryboard: UIStoryboard { return UIStoryboard(name: "Main", bundle: Bundle.main) } func presentAddContactScreen(from view: ContactListViewProtocol) { guard let delegate = view.presenter as? AddModuleDelegate else { return } let addContactsView = AddContactWireFrame.createAddContactModule(with: delegate) if let sourceView = view as? UIViewController { sourceView.present(addContactsView, animated: true, completion: nil) } } }</code> </pre> <br><br>  Como o WireFrame √© respons√°vel pela cria√ß√£o do m√≥dulo, ser√° conveniente configurar todas as depend√™ncias aqui.  Quando voc√™ deseja abrir outro controlador, a fun√ß√£o que abre o novo controlador recebe como argumento o objeto que o abrir√° e cria um novo controlador usando seu WireFrame.  Al√©m disso, ao criar um novo controlador, os dados necess√°rios s√£o transferidos para ele; nesse caso, apenas o delegado (Apresentador do controlador com contatos) para receber o contato criado. <br><br>  A camada Roteador oferece uma boa oportunidade para evitar o uso de segues (transi√ß√µes) nos storyboards e organizar toda a navega√ß√£o de c√≥digo.  Como os storyboards n√£o fornecem uma solu√ß√£o compacta para a transfer√™ncia de dados entre controladores, nossa implementa√ß√£o de navega√ß√£o n√£o adicionar√° c√≥digo extra.  Tudo o que temos √© apenas a melhor reutiliza√ß√£o. <br><br><br>  <b>Resumo</b> : <br><br>  Voc√™ pode encontrar os dois projetos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste reposit√≥rio</a> . <br><br>  Como voc√™ pode ver, o MVVM e o VIPER, embora diferentes, n√£o s√£o exclusivos.  O MVVM nos diz que al√©m de View e Model, tamb√©m deve haver uma camada ViewModel.  Mas nada √© dito sobre como essa camada deve ser criada, nem sobre como os dados s√£o solicitados - a responsabilidade por essa camada n√£o est√° claramente definida.  Existem v√°rias maneiras de implement√°-lo e voc√™ pode us√°-las. <br><br>  VIPER, por outro lado, √© uma arquitetura bastante √∫nica.  Ele consiste em v√°rias camadas, cada uma com uma √°rea de responsabilidade bem definida e menor que o MVVM √© influenciada pelo desenvolvedor. <br><br>  Quando se trata de escolher uma arquitetura, geralmente n√£o existe a √∫nica solu√ß√£o certa, mas ainda tentarei dar algumas dicas.  Se voc√™ tem um projeto grande e demorado, com requisitos claros e deseja ter ampla oportunidade de reutilizar componentes, o VIPER ser√° a melhor solu√ß√£o.  Uma defini√ß√£o mais clara da responsabilidade torna poss√≠vel organizar melhor os testes e melhorar a reutiliza√ß√£o. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440904/">https://habr.com/ru/post/pt440904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440894/index.html">Criando som para o Pathfinder: Kingmaker</a></li>
<li><a href="../pt440896/index.html">Tecnologias aditivas e digitaliza√ß√£o 3D em engenharia mec√¢nica: 7 hist√≥rias de sucesso</a></li>
<li><a href="../pt440898/index.html">Marketing de conte√∫do, publicidade contextual, melhoria na convers√£o: 6 guias √∫teis sobre promo√ß√£o de inicializa√ß√£o</a></li>
<li><a href="../pt440900/index.html">REST paix√£o por 200</a></li>
<li><a href="../pt440902/index.html">Metade do reino da IA: quanto os bancos economizam em aprendizado de m√°quina, redes neurais e bots de bate-papo</a></li>
<li><a href="../pt440906/index.html">Semin√°rio on-line "167-–§–ó. Como os bancos podem atender aos requisitos do Banco Central para sistemas antifraude ‚Äù- 26 de fevereiro de 2019 √†s 11:00 Hora de Moscou</a></li>
<li><a href="../pt440908/index.html">Servir tudo</a></li>
<li><a href="../pt440910/index.html">Por que os bancos monopolizam a blockchain?</a></li>
<li><a href="../pt440912/index.html">Tal dor, tanta dor, infra-estrutura como um servi√ßo 1: 0</a></li>
<li><a href="../pt440914/index.html">Perdi a f√© na ind√∫stria, queimei, mas o culto da ferramenta me salvou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>