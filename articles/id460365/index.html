<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍💻 👍🏻 🙆🏽 Jejak terdistribusi: kami melakukan semua yang salah 👨🏻‍🔬 📖 ⚱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan perev. : Penulis materi ini adalah Cindy Sridharan, seorang insinyur dari imgix yang terlibat dalam pengembangan API dan, khususnya, menguji l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jejak terdistribusi: kami melakukan semua yang salah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/460365/">  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Penulis materi ini adalah Cindy Sridharan, seorang insinyur dari imgix yang terlibat dalam pengembangan API dan, khususnya, menguji layanan-layanan mikro.</i>  <i>Dalam artikel ini, ia berbagi visi terperinci tentang masalah aktual di bidang penelusuran terdistribusi, di mana, menurut pendapatnya, ada kekurangan alat yang benar-benar efektif untuk menyelesaikan masalah mendesak.</i> <br><br><img src="https://habrastorage.org/webt/zu/va/og/zuvaogffo6d3gqi1mmzq5ts3zoc.png"><br>  <i>[Ilustrasi dipinjam dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahan lain</a> tentang penelusuran yang didistribusikan.]</i> <br><br>  Dipercayai bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penelusuran terdistribusi</a> sulit untuk diterapkan, dan pengembaliannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meragukan</a> .  "Masalah" jejak dijelaskan oleh banyak alasan, sering merujuk pada kompleksitas pengaturan setiap komponen sistem untuk mengirimkan header yang sesuai bersama dengan setiap permintaan.  Meskipun masalah ini memang terjadi, itu tidak bisa disebut tidak dapat diatasi sama sekali.  By the way, itu tidak menjelaskan mengapa pengembang tidak terlalu suka melacak (bahkan sudah berfungsi). <a name="habracut"></a><br><br>  Kesulitan utama dengan penelusuran terdistribusi adalah tidak mengumpulkan data, tidak membakukan format untuk mendistribusikan dan menyajikan hasil, dan tidak menentukan kapan, di mana dan bagaimana sampel.  Saya sama sekali tidak berusaha menyajikan "masalah-masalah kecernaan" ini sebagai <i>hal sepele</i> - pada kenyataannya, ada cukup banyak masalah teknis dan (jika kita benar-benar melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">standar dan protokol</a> Open Source) tantangan-tantangan politik yang harus diatasi sehingga masalah-masalah ini dapat dipertimbangkan terselesaikan. <br><br>  Namun, jika Anda membayangkan bahwa semua masalah ini telah diatasi, kemungkinan tidak ada yang akan berubah secara signifikan dalam hal <i>pengalaman pengguna akhir</i> .  Melacak mungkin masih tidak praktis dalam skenario debugging paling umum - bahkan setelah itu telah dikerahkan. <br><br><h2>  Jejak yang sangat berbeda </h2><br>  Pelacakan terdistribusi mencakup beberapa komponen yang berbeda: <br><br><ul><li>  melengkapi aplikasi dan middleware dengan kontrol; </li><li>  Transmisi konteks terdistribusi </li><li>  koleksi jejak; </li><li>  penyimpanan jejak; </li><li>  ekstraksi dan visualisasi mereka. </li></ul><br>  Banyak pembicaraan tentang penelusuran terdistribusi datang untuk mempertimbangkannya sebagai semacam operasi yang tidak disadari, satu-satunya tujuan adalah untuk membantu dalam diagnosis lengkap sistem.  Ini sebagian besar disebabkan oleh cara di mana konsep pelacakan terdistribusi terbentuk.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting blog yang</a> dibuat ketika sumber Zipkin dibuka, disebutkan bahwa <i>ia [Zipkin] membuat Twitter lebih cepat</i> .  Penawaran komersial pertama untuk penelusuran juga dipromosikan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat APM</a> . <br><br>  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Agar teks lebih lanjut dapat dipahami dengan lebih baik, kami mendefinisikan dua istilah dasar sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi proyek OpenTracing</a> :</i> <br><br><ul><li>  <i><b>Rentang</b> - elemen dasar dari penelusuran terdistribusi.</i>  <i>Ini adalah deskripsi alur kerja tertentu (misalnya, kueri basis data) dengan nama, waktu mulai dan akhir, tag, log, dan konteks.</i> </li><li>  <i>Rentang biasanya berisi tautan ke rentang lain, yang memungkinkan Anda untuk menggabungkan banyak rentang di <b>Trace</b> - visualisasi kehidupan permintaan saat bergerak melalui sistem terdistribusi.</i> </li></ul><br>  Trace'y berisi data yang sangat berharga yang dapat membantu dalam tugas-tugas seperti: pengujian dalam produksi, melakukan tes pemulihan bencana, pengujian dengan pengenalan kesalahan, dll.  Bahkan, beberapa perusahaan sudah menggunakan pelacakan untuk tujuan seperti itu.  Untuk mulai dengan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transfer konteks universal</a> memiliki kegunaan lain selain hanya mentransfer rentang ke sistem penyimpanan: <br><br><ul><li>  Misalnya, Uber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan</a> hasil penelusuran untuk membedakan antara lalu lintas uji dan lalu lintas produksi. </li><li>  Facebook <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan</a> jejak data untuk menganalisis jalur kritis dan untuk mengubah lalu lintas selama tes pemulihan bencana reguler. </li><li>  Jejaring sosial ini juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan</a> notebook Jupyter, yang memungkinkan pengembang untuk mengeksekusi permintaan arbitrer atas hasil penelusuran. </li><li>  Penganut Kegagalan Injeksi Lineage Driven ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LDFI)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan</a> jejak terdistribusi untuk pengujian kesalahan. </li></ul><br>  Tak satu pun dari opsi di atas yang sepenuhnya berhubungan dengan skenario <i>debugging</i> , di mana insinyur mencoba untuk memecahkan masalah dengan melihat jejak. <br><br>  Ketika datang ke skenario debugging, diagram <i>jejak</i> tetap antarmuka utama (meskipun beberapa juga menyebutnya <i>"Gantt chart"</i> atau <i>"diagram berjenjang"</i> ).  Dengan <i>traceview,</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">maksud</a> saya semua bentang dan metadata terkait yang bersama-sama membentuk jejak.  Setiap sistem penelusuran open source, serta setiap solusi penelusuran komersial, menawarkan antarmuka pengguna berbasis- <i>pelacakan</i> - <i>jejak</i> untuk memvisualisasikan, merinci, dan memfilter data jejak. <br><br>  Masalah dengan semua sistem jejak yang saya kenal saat ini adalah bahwa <i>visualisasi</i> terakhir <i>(traceview)</i> hampir sepenuhnya mencerminkan fitur dari proses pembuatan jejak.  Bahkan ketika visualisasi alternatif ditawarkan: peta intensitas (peta panas), topologi layanan, histogram latensi - pada akhirnya mereka masih turun ke <i>penelusuran jejak</i> . <br><br>  Di masa lalu, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengeluh</a> bahwa sebagian besar "inovasi" dalam keterlacakan sehubungan dengan UI / UX tampaknya terbatas untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memasukkan</a> metadata tambahan dalam jejak, menanamkan informasi dengan <i>kardinalitas tinggi</i> di dalamnya, atau menyediakan kemampuan untuk menelusuri ke rentang tertentu atau menjalankan kueri <i>antar dan intra-jejak</i> .  Dalam hal ini, <i>traceview</i> tetap menjadi alat utama visualisasi.  Selama kondisi ini tetap ada, penelusuran terdistribusi akan (paling baik) menempati posisi ke-4 sebagai alat debugging, diikuti oleh metrik, log, dan tumpukan jejak, dan paling buruk itu akan menjadi pemborosan uang dan waktu. <br><br><h2>  Masalah dengan traceview </h2><br>  Tujuan <i>penelusuran jejak</i> adalah untuk memberikan gambaran lengkap tentang pergerakan permintaan individu di semua komponen sistem terdistribusi yang terkait.  Beberapa sistem penelusuran yang lebih maju memungkinkan Anda menelusuri bentang individual dan melihat rincian waktu <i>dalam</i> satu proses tunggal (saat bentang memiliki batas fungsional). <br><br>  Premis dasar arsitektur layanan microsoft adalah gagasan bahwa struktur organisasi tumbuh dengan kebutuhan perusahaan.  Para pendukung layanan mikro berpendapat bahwa distribusi berbagai tugas bisnis di berbagai layanan terpisah memungkinkan tim pengembangan kecil dan otonom untuk mengendalikan seluruh siklus hidup layanan tersebut, memungkinkan mereka untuk secara mandiri membuat, menguji, dan menggunakan layanan ini.  Namun, kelemahan dari distribusi ini adalah hilangnya informasi tentang bagaimana setiap layanan berinteraksi dengan yang lain.  Dalam keadaan seperti itu, klaim penelusuran terdistribusi menjadi alat yang sangat diperlukan untuk <i>men</i> - <i>debug</i> interaksi kompleks antara layanan. <br><br>  Jika Anda memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem distribusi yang</a> benar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-</a> benar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menakjubkan</a> , maka tidak ada yang dapat mengingat gambaran <i>lengkapnya</i> .  Bahkan, mengembangkan alat berdasarkan asumsi bahwa secara umum mungkin adalah sedikit antipattern (pendekatan yang tidak efisien dan tidak produktif).  Idealnya, debugging memerlukan alat untuk membantu <i>mempersempit pencarian Anda</i> sehingga para insinyur dapat fokus pada subset dimensi (layanan / pengguna / host, dll.) Yang relevan dengan skenario yang dimaksud.  Ketika menentukan penyebab kegagalan, para insinyur tidak diharuskan untuk memahami apa yang terjadi di <i>semua layanan sekaligus</i> , karena persyaratan seperti itu akan bertentangan dengan gagasan arsitektur layanan mikro. <br><br>  Namun, traceview <i>hanya</i> itu.  Ya, beberapa sistem jejak menawarkan tampilan jejak terkompresi ketika jumlah bentang dalam penelusuran sangat besar sehingga tidak dapat ditampilkan dalam satu visualisasi.  Namun, karena banyaknya informasi yang terkandung bahkan dalam visualisasi terpotong seperti itu, para insinyur masih <i>dipaksa untuk</i> "menyaringnya", secara manual mempersempit pilihan menjadi serangkaian sumber masalah layanan.  Sayangnya, dalam bidang ini mesin jauh lebih cepat daripada manusia, lebih tidak rentan terhadap kesalahan, dan hasilnya lebih berulang. <br><br>  Alasan lain saya pikir metode traceview salah adalah karena tidak cocok untuk debugging hipotesis.  Pada intinya, debugging adalah proses <i>berulang</i> dimulai dengan hipotesis, diikuti dengan memeriksa berbagai pengamatan dan fakta yang diterima dari sistem menggunakan vektor yang berbeda, kesimpulan / generalisasi, dan penilaian lebih lanjut tentang kebenaran hipotesis. <br><br>  Kemampuan <i>untuk</i> menguji hipotesis <i>dengan cepat dan murah</i> dan meningkatkan model mental yang sesuai adalah <i>landasan</i> debugging.  Alat debugging apa pun harus <i>interaktif</i> dan mempersempit ruang pencarian atau, dalam kasus jejak palsu, memungkinkan pengguna untuk kembali dan fokus pada area lain dari sistem.  Alat yang ideal akan melakukan ini secara <i>proaktif</i> , segera menarik perhatian pengguna ke area yang berpotensi bermasalah. <br><br>  Sayangnya, <i>traceview</i> tidak dapat disebut alat antarmuka interaktif.  Yang terbaik yang dapat Anda harapkan ketika menggunakannya adalah mendeteksi sumber penundaan tertentu yang meningkat dan melihat semua jenis tag dan log yang terkait dengannya.  Ini tidak membantu insinyur untuk mengidentifikasi <i>pola</i> dalam lalu lintas, seperti spesifikasi distribusi keterlambatan, atau untuk mendeteksi korelasi antara pengukuran yang berbeda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analisis jejak umum</a> dapat mengatasi beberapa masalah ini.  Memang, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada contoh</a> analisis yang berhasil menggunakan pembelajaran mesin untuk mengidentifikasi rentang abnormal dan mengidentifikasi subset tag yang mungkin terkait dengan perilaku abnormal.  Namun demikian, saya belum menemukan visualisasi yang meyakinkan dari temuan yang dibuat menggunakan pembelajaran mesin atau analisis data yang diterapkan pada bentang yang akan sangat berbeda dari traceview atau DAG (directional acyclic graph). <br><br><h3>  Rentang levelnya terlalu rendah </h3><br>  Masalah mendasar dengan traceview adalah <i>rentang</i> yang terlalu primitif untuk analisis latensi dan analisis akar penyebab.  Ini seperti menganalisis setiap perintah prosesor dalam upaya untuk menghilangkan pengecualian, mengetahui bahwa ada alat yang jauh lebih tinggi seperti backtrace, yang jauh lebih nyaman untuk digunakan. <br><br>  Selain itu, saya akan mengambil kebebasan menyatakan hal berikut: idealnya, kita tidak perlu <i>gambaran lengkap tentang</i> apa yang terjadi selama siklus hidup permintaan, yang diwakili oleh alat modern untuk melacak.  Alih-alih, beberapa bentuk abstraksi tingkat yang lebih tinggi diperlukan, berisi informasi tentang apa yang <i>salah</i> (mirip dengan backtrace), bersama dengan beberapa konteks.  Alih-alih mengamati seluruh jejak, saya lebih suka melihat <i>bagiannya di</i> mana sesuatu yang menarik atau tidak biasa terjadi.  Saat ini, pencarian dilakukan secara manual: insinyur menerima jejak dan secara independen menganalisis rentang untuk mencari sesuatu yang menarik.  Pendekatan ketika orang menatap bentang di jejak terpisah dengan harapan mendeteksi aktivitas yang mencurigakan tidak berskala sama sekali (terutama ketika mereka harus memahami semua metadata yang disandikan dalam bentang yang berbeda, seperti span ID, nama metode RPC, durasi span 'a, log, tag, dll.) <br><br><h2>  Traceview alternatif </h2><br>  Melacak hasil sangat berguna ketika mereka dapat divisualisasikan sedemikian rupa untuk mendapatkan ide non-sepele tentang apa yang terjadi di bagian-bagian sistem yang saling berhubungan.  Sampai saat ini terjadi, proses debugging sebagian besar tetap <i>lembam</i> dan tergantung pada kemampuan pengguna untuk melihat korelasi yang benar, memeriksa bagian-bagian yang benar dari sistem atau mengumpulkan potongan-potongan mosaik bersama-sama - tidak seperti <i>alat</i> yang membantu pengguna merumuskan hipotesis ini. <br><br>  Saya bukan perancang visual atau spesialis UX, tetapi di bagian selanjutnya saya ingin berbagi beberapa ide tentang bagaimana visualisasi tersebut akan terlihat. <br><br><h3>  Fokus pada layanan tertentu </h3><br>  Dalam lingkungan di mana industri ini berkonsolidasi di sekitar ide-ide <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SLO (tujuan tingkat layanan) dan SLI (indikator tingkat layanan)</a> , tampaknya masuk akal bahwa tim individu harus terlebih dahulu memantau kesesuaian layanan mereka dengan tujuan-tujuan ini.  Oleh karena itu visualisasi yang <i>berorientasi layanan</i> paling cocok untuk tim tersebut. <br><br>  Jejak, terutama tanpa pengambilan sampel, adalah gudang informasi tentang setiap komponen sistem terdistribusi.  Informasi ini dapat diumpankan ke penangan rumit yang akan memberikan temuan berorientasi <i>layanan</i> kepada pengguna, yang dapat dideteksi sebelumnya - bahkan sebelum pengguna melihat jejak: <br><br><ol><li>  Tunda diagram distribusi hanya untuk permintaan yang sangat berbeda <i>(permintaan outlier)</i> ; </li><li>  Tunda diagram distribusi untuk kasus-kasus ketika sasaran layanan SLO tidak tercapai; </li><li>  Tag yang paling "umum", "menarik" dan "aneh" dalam kueri, yang paling sering <i>diulang</i> ; </li><li>  Rincian penundaan untuk kasus-kasus ketika <i>dependensi</i> layanan tidak mencapai sasaran SLO yang ditetapkan; </li><li>  Rincian penundaan untuk berbagai layanan hilir. </li></ol><br>  Metrik bawaan tidak bisa menjawab beberapa pertanyaan ini, memaksa pengguna mempelajari bentang dengan cermat.  Akibatnya, kami memiliki mekanisme yang sangat bermusuhan dengan pengguna. <br><br>  Dalam hal ini, muncul pertanyaan: bagaimana dengan interaksi kompleks antara berbagai layanan yang dikendalikan oleh tim yang berbeda?  Bukankah <i>traceview</i> dianggap sebagai alat yang paling tepat untuk mengatasi situasi seperti itu? <br><br>  Pengembang seluler, pemilik layanan tanpa kewarganegaraan, pemilik layanan stateful yang dikelola (seperti basis data) dan pemilik platform mungkin tertarik pada <i>pandangan</i> lain <i>tentang</i> sistem terdistribusi;  <i>traceview</i> adalah solusi yang terlalu universal untuk kebutuhan yang berbeda secara mendasar ini.  Bahkan dalam arsitektur layanan mikro yang sangat kompleks, pemilik layanan tidak perlu pengetahuan mendalam tentang lebih dari dua atau tiga layanan hulu dan hilir.  Intinya, dalam sebagian besar skenario, pengguna hanya perlu menjawab pertanyaan terkait <i>serangkaian layanan terbatas</i> . <br><br>  Ini seperti melihat sekelompok kecil layanan melalui kaca pembesar demi penelitian yang cermat.  Ini akan memungkinkan pengguna untuk mengajukan pertanyaan yang lebih mendesak mengenai interaksi kompleks antara layanan ini dan ketergantungan langsung mereka.  Ini mirip dengan backtrace di dunia layanan, di mana insinyur tahu <i>apa</i> yang salah, dan juga memiliki beberapa gagasan tentang apa yang terjadi di layanan sekitarnya untuk memahami <i>mengapa</i> . <br><br>  Pendekatan yang saya promosikan adalah kebalikan dari pendekatan top-down yang didasarkan pada traceview, ketika analisis dimulai dengan seluruh jejak, dan kemudian secara bertahap turun ke rentang individu.  Sebaliknya, pendekatan bottom-up dimulai dengan analisis area kecil yang dekat dengan potensi penyebab insiden, dan kemudian ruang pencarian diperluas jika perlu (dengan kemungkinan keterlibatan tim lain untuk menganalisis berbagai layanan yang lebih luas).  Pendekatan kedua lebih cocok untuk dengan cepat menguji hipotesis awal.  Setelah mendapatkan hasil tertentu, akan mungkin untuk beralih ke analisis yang lebih fokus dan terperinci. <br><br><h3>  Bangunan topologi </h3><br>  Pandangan yang terkait dengan layanan tertentu dapat sangat berguna jika pengguna tahu layanan atau kelompok layanan mana yang bertanggung jawab untuk meningkatkan keterlambatan atau merupakan sumber kesalahan.  Namun, dalam sistem yang kompleks, mengidentifikasi penyusup mungkin bukan tugas sepele selama kegagalan, terutama jika tidak ada pesan kesalahan yang diterima dari layanan. <br><br>  Membangun topologi layanan dapat sangat membantu dalam mencari tahu layanan mana yang menunjukkan lonjakan tingkat kesalahan atau peningkatan latensi, yang menyebabkan penurunan nyata dalam kinerja layanan.  Berbicara tentang membangun topologi, maksud saya bukan <i>peta layanan</i> yang menampilkan setiap layanan yang tersedia dalam sistem dan dikenal dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peta arsitekturnya dalam bentuk bintang kematian</a> .  Representasi seperti itu tidak lebih baik daripada penelusuran jejak berdasarkan grafik asiklik terarah.  Sebaliknya, saya ingin melihat <i>topologi layanan yang dihasilkan secara dinamis</i> berdasarkan atribut tertentu, seperti tingkat kesalahan, waktu respons, atau parameter yang ditentukan pengguna yang membantu memperjelas situasi dengan layanan mencurigakan tertentu. <br><br>  Mari kita lihat sebuah contoh.  Bayangkan sebuah situs berita hipotetis.  Layanan <i>halaman depan</i> berkomunikasi dengan Redis, dengan layanan rekomendasi, dengan layanan iklan dan layanan video.  Layanan video mengambil video dari S3, dan metadata dari DynamoDB.  Layanan rekomendasi menerima metadata dari DynamoDB, mengunduh data dari Redis dan MySQL, menulis pesan ke Kafka.  Layanan iklan menerima data dari MySQL dan menulis pesan ke Kafka. <br><br>  Berikut ini adalah representasi skematis dari topologi ini (banyak program perutean komersial membangun topologi).  Ini bisa berguna jika Anda perlu memahami dependensi layanan.  Namun, selama <i>debugging</i> , ketika layanan tertentu (katakanlah, layanan video) menunjukkan peningkatan waktu respons, topologi seperti itu tidak terlalu berguna. <br><br><img src="https://habrastorage.org/webt/qr/85/y9/qr85y98gth6ybvwt5yuditlnack.png"><br>  <i>Skema Layanan Situs Berita Hipotesis</i> <br><br>  Diagram di bawah ini akan lebih baik.  Di atasnya layanan bermasalah <i>(video)</i> digambarkan tepat di tengah.  Pengguna segera memperhatikannya.  Dari visualisasi ini, menjadi jelas bahwa layanan video bekerja secara tidak normal karena meningkatnya waktu respons S3, yang mempengaruhi kecepatan pengunduhan bagian halaman utama. <br><br><img src="https://habrastorage.org/webt/v2/w5/za/v2w5zaf_s1_r8mzo0j6r2dopyyk.png"><br>  <i>Topologi dinamis yang hanya menampilkan layanan "menarik"</i> <br><br>  Skema topologi yang dihasilkan secara dinamis bisa lebih efisien daripada peta layanan statis, terutama dalam infrastruktur fleksibel dan dapat diskalakan.  Kemampuan untuk membandingkan dan membedakan topologi layanan memungkinkan pengguna untuk mengajukan pertanyaan yang lebih relevan.  Pertanyaan yang lebih tepat tentang sistem lebih cenderung mengarah pada pemahaman yang lebih baik tentang cara kerja sistem. <br><br><h3>  Tampilan komparatif </h3><br>  Visualisasi lain yang bermanfaat adalah tampilan komparatif.  Jejak saat ini tidak cocok untuk perbandingan berdampingan, sehingga <i>rentang</i> biasanya dibandingkan.  Dan ide utama dari artikel ini adalah bentang yang terlalu rendah untuk mengekstrak informasi yang paling berharga dari hasil penelusuran. <br><br>  Perbandingan dua trace'ov tidak menuntut visualisasi baru yang fundamental.  Bahkan, sesuatu seperti histogram yang mewakili informasi yang sama dengan traceview sudah cukup.  Anehnya, bahkan metode sederhana ini dapat menghasilkan lebih banyak buah daripada studi sederhana tentang dua jejak secara terpisah.  Yang lebih kuat lagi adalah kemampuan untuk <i>memvisualisasikan</i> perbandingan jejak <i>dalam agregat</i> .  Akan sangat berguna untuk melihat bagaimana perubahan konfigurasi database yang baru-baru ini digunakan dengan dimasukkannya GC (pengumpulan sampah) memengaruhi waktu respons layanan hilir dalam beberapa jam.  Jika apa yang saya jelaskan di sini seperti analisis A / B tentang dampak perubahan infrastruktur <i>di berbagai layanan</i> menggunakan hasil penelusuran, maka Anda tidak terlalu jauh dari kebenaran. <br><br><h2>  Kesimpulan </h2><br>  Saya tidak mempertanyakan kegunaan dari jejak itu sendiri.  Saya dengan tulus percaya bahwa tidak ada cara lain untuk mengumpulkan data yang kaya, santai, dan kontekstual seperti yang terkandung dalam jejak.    ,          .   ,        traceview-,          ,     ,   trace'.  ,          ,         . <br><br>   ,     ,  .        , <b> </b>  ,        .  ,           production   ,   ,      ,       ,     . <br><br>    ,   ,     ,    , ,      .  ,         ,      ,     trace'  span'. <br><br>           (  UI). ,         ,        .        ,           .           .      . <br><br><h2>  PS dari penerjemah </h2><br>  Baca juga di blog kami: <br><br><ul><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> kubectl-debug    pod' Kubernetes</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">:   ,     Kubernetes</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  Kubernetes (   )</a> ». </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460365/">https://habr.com/ru/post/id460365/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460353/index.html">Jaringan saraf di gelas. Tidak membutuhkan daya, mengenali angka</a></li>
<li><a href="../id460355/index.html">Menyelamatkan tenggelam adalah urusan kami: bagaimana menghadapi penurunan motivasi tim</a></li>
<li><a href="../id460359/index.html">Kursus 2 Desainer Game Muda: Menyeimbangkan Perkembangan dan Dinamika tanpa Matematika</a></li>
<li><a href="../id460361/index.html">FAQ Hebat tentang keamanan siber sistem informasi medis</a></li>
<li><a href="../id460363/index.html">7 faktor yang hilang dalam pendekatan 12 Factor App</a></li>
<li><a href="../id460367/index.html">Chaos Engineering: seni kehancuran yang disengaja. Bagian 1</a></li>
<li><a href="../id460373/index.html">Di Balik Terpal Halaman Turbo: Arsitektur Teknologi Unduhan Cepat Halaman Web</a></li>
<li><a href="../id460375/index.html">Buku "Pembelajaran Mesin untuk Bisnis dan Pemasaran"</a></li>
<li><a href="../id460377/index.html">Menggunakan Liquibase untuk mengelola struktur database dalam aplikasi Spring Boot. Bagian 1</a></li>
<li><a href="../id460381/index.html">Apa itu ketegasan dan mengapa itu dibutuhkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>