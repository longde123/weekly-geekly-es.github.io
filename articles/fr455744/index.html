<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèæ üé¥ ‚≠ïÔ∏è Syst√®me de g√©n√©ration de paysage de labyrinthe avec un r√©alisme visuel am√©lior√© [traduction de l'article par Jinmo Kim] üë• üîÄ üõÄüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 


 Dans cet article, je vais parler d'un article de Jinmo Kim: "Syst√®me de cr√©ation de terrains de labyrinthe en r√©alit√© virtuelle imm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Syst√®me de g√©n√©ration de paysage de labyrinthe avec un r√©alisme visuel am√©lior√© [traduction de l'article par Jinmo Kim]</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455744/"><p>  Bonjour, Habr! </p><br><p>  Dans cet article, je vais parler d'un article de Jinmo Kim: "Syst√®me de cr√©ation de terrains de labyrinthe en r√©alit√© virtuelle immersive pour un nouveau r√©alisme visuel".  Il a √©t√© publi√© le 04/04/2019.  Le texte int√©gral de l'article est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><h3>  Br√®ve description du syst√®me </h3><br><p> L'article propose le syst√®me de l'auteur pour cr√©er des paysages de labyrinthe, avec lequel l'utilisateur peut g√©n√©rer automatiquement divers motifs complexes dans un syst√®me simple et intuitif.  En utilisant les informations de labyrinthe calcul√©es dans le programme, un paysage de labyrinthe en trois dimensions est g√©n√©r√© rapidement et efficacement. </p><br><p>  Le syst√®me de g√©n√©ration de paysage de labyrinthe propos√© comprend trois fonctions principales: </p><br><ul><li>  la fonction de g√©n√©ration automatique d'une grille de labyrinthe de diff√©rentes tailles et motifs, mise en ≈ìuvre en utilisant l'algorithme de g√©n√©ration de labyrinthe classique; </li><li>  fonction de g√©n√©ration de labyrinthe circulaire; </li><li>  la fonction de conversion d'un labyrinthe d'une esquisse manuelle en un objet 3D √† l'aide d'un algorithme de traitement d'image. </li></ul><br><p>  En utilisant le syst√®me propos√©, compos√© de ces trois fonctions, il est possible de cr√©er efficacement diff√©rents labyrinthes, d'homog√®ne √† irr√©gulier.  Ce d√©veloppement vous permettra de g√©n√©rer des paysages de labyrinthe de diff√©rents concepts directement √† partir des calculs effectu√©s √† travers le m√™me syst√®me.  De plus, ce travail analyse l'am√©lioration de l'effet de pr√©sence et d'immersion dans la r√©alit√© virtuelle, c'est-√†-dire  r√©alisme visuel.  De plus, dans ce travail, une analyse de l'ad√©quation du syst√®me de cr√©ation propos√© a √©t√© r√©alis√©e √† l'aide d'une enqu√™te. </p><a name="habracut"></a><br><h3>  Pourquoi la r√©alit√© virtuelle? </h3><br><p>  Pour obtenir une sorte d'exp√©rience r√©aliste, vous devez interagir avec les sens humains.  La r√©alit√© virtuelle permet √† une personne d'acqu√©rir une telle exp√©rience en interagissant avec des sensations visuelles, auditives et tactiles.  Dans la r√©alit√© virtuelle, l'effet de pr√©sence est important, gr√¢ce auquel l'utilisateur peut obtenir une exp√©rience r√©aliste bas√©e sur des sentiments sur o√π il est, avec qui et quelles actions il effectue. </p><br><p>  Pour augmenter l'effet de la pr√©sence dans la r√©alit√© virtuelle, il est important de savoir comment l'utilisateur interagit avec l'environnement virtuel, mais non moins important est de savoir comment des sc√®nes virtuelles vari√©es sont fournies pour satisfaire visuellement l'utilisateur. </p><br><p>  Dans les √©tudes des syst√®mes de r√©alit√© virtuelle orient√©s mat√©riel (syst√®mes tactiles, plateformes de mouvement, etc.), pour un affichage r√©aliste des actions et des mouvements des utilisateurs en r√©alit√© virtuelle, seules des sc√®nes exp√©rimentales ont √©t√© utilis√©es, o√π l'espace en elles √©tait limit√© et la structure des sc√®nes √©tait simple dans la plupart des cas.  √âtant donn√© que la technologie VR est utilis√©e dans divers domaines, tels que les arts visuels et la conception architecturale, ainsi que dans les jeux, des √©tudes sp√©ciales sont n√©cessaires pour cr√©er un espace virtuel complexe conform√©ment √† la VR.  √Ä cette fin, dans ce travail, des √©tudes ont √©t√© men√©es sur les m√©thodes de cr√©ation automatique de sc√®nes virtuelles, telles que les espaces urbains et les paysages virtuels, qui ont des structures complexes et des caract√©ristiques diverses. </p><br><h3>  Immersion en r√©alit√© virtuelle </h3><br><p>  La r√©alit√© virtuelle immersive (ou r√©alit√© virtuelle immersive) est une telle r√©alit√© qui na√Æt dans l'esprit d'une personne au cours de son interaction avec des syst√®mes techniques complexes, tels que les syst√®mes de r√©alit√© virtuelle.  Il a son propre chronotope unique, la logique, n'existe que pertinente, alors que l'utilisateur est ¬´pr√©sent¬ª dans cette r√©alit√©, a l'interactivit√©, comme la capacit√© de r√©pondre aux actions de l'utilisateur. </p><br><p>  Des √©tudes de plong√©es en r√©alit√© virtuelle ont √©t√© r√©alis√©es selon diff√©rentes approches: </p><br><ul><li>  un √©cran qui transmet des informations visuelles en trois dimensions pour offrir une exp√©rience r√©aliste √† l'utilisateur dans un environnement virtuel bas√© sur cinq sens </li><li>  traitement du son pour une perception spatiale am√©lior√©e gr√¢ce au son surround </li><li>  une m√©thode d'interaction avec un environnement virtuel, ainsi qu'un syst√®me tactile et une plateforme de mouvement qui redirigent les r√©ponses physiques vers le corps humain (bras, jambes, etc.). </li></ul><br><p>  Pour obtenir l'effet de pr√©sence dans la r√©alit√© virtuelle, il doit y avoir une satisfaction visuelle de l'utilisateur.  Pour cette raison, il y a un int√©r√™t croissant pour la recherche multimodale, qui examine √† la fois les sensations visuelles et auditives ou les sensations visuelles et tactiles, ainsi que les √©tudes de syst√®mes pseudo-tactiles qui combinent l'exp√©rience visuelle et les syst√®mes tactiles. </p><br><h3>  Am√©lioration du r√©alisme visuel </h3><br><p>  Une m√©thode pour g√©n√©rer une sc√®ne virtuelle, qui peut fournir un effet de pr√©sence am√©lior√©, ainsi que de nouvelles exp√©riences visuelles pour l'utilisateur dans un environnement virtuel, est n√©cessaire pour une vari√©t√© d'applications VR.  √Ä l'avenir, les sc√®nes de r√©alit√© virtuelle se lib√©reront de petits espaces limit√©s tels que les espaces int√©rieurs et cr√©eront de vastes paysages ouverts tels que les villes et les mondes virtuels pour offrir aux utilisateurs plus de choix. </p><br><p>  Pour cr√©er des sc√®nes de labyrinthe virtuel pouvant offrir de nouvelles exp√©riences et am√©liorer l'effet de la pr√©sence des utilisateurs dans la r√©alit√© virtuelle, un syst√®me de cr√©ation optimis√© est propos√© dans ce travail.  Il est bas√© sur la recherche traditionnelle et peut g√©n√©rer des sc√®nes de labyrinthe virtuel plus diverses dans une structure simple, intuitive et conviviale. </p><br><h3>  Syst√®me de paysage de labyrinthe </h3><br><p>  Le syst√®me propos√© cr√©e un paysage virtuel du labyrinthe, avec pour effet d'am√©liorer le r√©alisme visuel des utilisateurs dans la r√©alit√© virtuelle, en utilisant divers effets visuels.  Il comprend trois fonctions de base qui g√©n√®rent automatiquement divers mod√®les de labyrinthe et les convertissent en informations n√©cessaires pour cr√©er une surface tridimensionnelle du labyrinthe. </p><br><h4>  G√©n√©rer un motif de labyrinthe rectiligne </h4><br><p>  La premi√®re fonction du syst√®me de cr√©ation de paysage de labyrinthe est de g√©n√©rer automatiquement des motifs de labyrinthe en utilisant l'algorithme de g√©n√©ration de labyrinthe classique.  Un facteur important est la n√©cessit√© de cr√©er le labyrinthe final.  Il doit y avoir diff√©rents chemins ou un chemin absolu pour que l'utilisateur ne soit pas pi√©g√© √† l'int√©rieur du labyrinthe.  Cela aide √† emp√™cher les utilisateurs de souffrir de la maladie VR, qui est un grave probl√®me de r√©alit√© virtuelle.  Cette fonction est bas√©e sur l'algorithme de Lee et al., Qui cr√©e un motif de labyrinthe en utilisant l'algorithme Prim. </p><br><p>  L'algorithme pour la g√©n√©ration finale du labyrinthe de Lee, etc., est une m√©thode qui commence par les processus: (1) d√©finir la position de d√©part et (2) d√©finir al√©atoirement la cellule de route √† partir des cellules environnantes.  Ensuite (3), l'algorithme examine quatre cellules autour de la direction (d√©terminant la structure des couches de cellules apr√®s avoir ajout√© ces quatre cellules environnantes √† la collection en tant que cellules de paroi).  Ensuite, l'algorithme r√©p√®te les processus (4, 5) pour trouver l'une des cellules enregistr√©es du mur, puis cr√©e une route. </p><br><p>  Les figures ci-dessous montrent le processus de construction d'un gabarit de labyrinthe rectiligne.  L'utilisateur d√©finit la taille du mod√®le de labyrinthe et lorsque vous cliquez sur le bouton ¬´Labyrinthe¬ª, le mod√®le de labyrinthe est automatiquement calcul√© et g√©n√©r√©. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/010/907/daa/010907daa37626467e305b22c0aa1a1d.png" alt="image"><br><p>  Si l'utilisateur souhaite √©diter le mod√®le du labyrinthe cr√©√© automatiquement, le mode ¬´√âditer¬ª est s√©lectionn√©.  L'utilisateur modifie avec la souris dans le champ de pr√©sentation du mod√®le de labyrinthe en cliquant sur la cellule, apr√®s quoi il est automatiquement converti de mur en route ou de route en mur.  Une fois le mod√®le de labyrinthe g√©n√©r√©, l'utilisateur a la possibilit√© de visualiser le labyrinthe r√©sultant au format 3D. </p><br><div class="spoiler">  <b class="spoiler_title">Voir le labyrinthe en 3D</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/b74/a6b/ef7/b74a6bef7fa8825141bc36493321d282.png" alt="image"></div></div><br><h4>  La m√©thode de cr√©ation d'un labyrinthe circulaire </h4><br><p>  La deuxi√®me fonction du syst√®me propos√© par l'auteur pour cr√©er un paysage de labyrinthe est la m√©thode de g√©n√©ration d'un labyrinthe circulaire.  Cette m√©thode cr√©e automatiquement des labyrinthes circulaires de diff√©rentes tailles et motifs et est un bon ajout √† la fonction de g√©n√©ration de motifs de labyrinthe sous la forme d'une grille rectangulaire.  Ainsi, cette m√©thode √©tend l'exp√©rience visuelle des utilisateurs en r√©alit√© virtuelle.  Le processus de cr√©ation et d'installation des murs et des cellules de route est fondamentalement identique.  Mais pour un labyrinthe circulaire, les caract√©ristiques d'entr√©e sont le rayon du labyrinthe et le nombre d'entr√©es dans le labyrinthe. </p><br><p>  Tout d'abord, lorsque l'utilisateur entre dans le rayon souhait√© du labyrinthe, les parois des parois du labyrinthe circulaire sont automatiquement calcul√©es par l'algorithme de trac√© d'un cercle √† partir d'un point central.  Ensuite, la paroi du labyrinthe circulaire est dupliqu√©e plusieurs fois avec un certain intervalle (ns) du cercle ext√©rieur.  En fonction du nombre d'entr√©es entr√©es par l'utilisateur, les passages sont cr√©√©s en faisant tourner les cellules du mur autant de fois que les entr√©es doivent provenir du cercle le plus √† l'ext√©rieur. </p><br><p>  Les cellules qui deviendront le point de d√©part pour entrer dans le cercle ext√©rieur sont s√©lectionn√©es au hasard autant de fois que le nombre d'entr√©es du labyrinthe devrait √™tre.  Ensuite, dans la cellule s√©lectionn√©e, une cellule de paroi est s√©lectionn√©e dont la longueur co√Øncide avec l'intervalle (ns) entre les parois circulaires, et elle tourne juste assez pour toucher la paroi circulaire int√©rieure. <br>  Enfin, lorsqu'une cellule de paroi se produit dans la position dans laquelle elle tourne et touche la paroi circulaire int√©rieure, l'algorithme ci-dessus est r√©p√©t√©. </p><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>: nr ‚Üê   . <span class="hljs-number"><span class="hljs-number">2</span></span>: ne ‚Üê    . <span class="hljs-number"><span class="hljs-number">3</span></span>: procedure     (nr, ne) <span class="hljs-number"><span class="hljs-number">4</span></span>: ns ‚Üê       . <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nr &gt; ns <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>:         . <span class="hljs-number"><span class="hljs-number">7</span></span>: nr = nr - ns. <span class="hljs-number"><span class="hljs-number">8</span></span>: end <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: nc ‚Üê    . <span class="hljs-number"><span class="hljs-number">10</span></span>: Arre[ne] ‚Üê  ,  ne      . <span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = nc, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>:     . <span class="hljs-number"><span class="hljs-number">12</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, ne <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span>:     ns    (Arre[j]). <span class="hljs-number"><span class="hljs-number">14</span></span>:   . <span class="hljs-number"><span class="hljs-number">15</span></span>:  Arre[j],  ,      . <span class="hljs-number"><span class="hljs-number">16</span></span>: end <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>: end <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span>: end procedure</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Le texte original de l'algorithme</b> <div class="spoiler_text"><pre> <code class="cpp hljs">nr ‚Üê radius of the circular maze. ne ‚Üê number of maze entrances. <span class="hljs-function"><span class="hljs-function">procedure CIRCULAR MAZE GENERATION </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PROCESS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nr, ne)</span></span></span><span class="hljs-function"> ns ‚Üê interval between maze </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> user road. </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">while</span></span></span><span class="hljs-function"> nr &gt; ns </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> define wall cell by </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">using</span></span></span><span class="hljs-function"> Bresenham's circle drawing algorithm. nr </span></span>= nr - ns. end <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nc ‚Üê number of drawing circles. Arre[ne] ‚Üê as many entrance cells as ne are selected from wall cell of the outermost circle. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = nc, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: generate passages in every circle. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, ne <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> select cells with length of ns in entrance cell (Arre[j]). rotate selected cells. renew Arre[j] by finding a cell that meets the inner circle after rotation. end <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> end <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> end procedure</code> </pre> </div></div><br><p>  L'algorithme ci-dessus de ce processus est bas√© sur les param√®tres d'entr√©e du rayon du labyrinthe circulaire et le nombre d'entr√©es entr√©es par l'utilisateur.  En outre, la figure ci-dessous montre le processus de cr√©ation d'un labyrinthe circulaire. </p><br><div class="spoiler">  <b class="spoiler_title">Le processus de cr√©ation d'un labyrinthe circulaire</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/getpro/habr/post_images/a01/779/464/a01779464bb19ef73d03faec81fdd7fe.png" alt="image"></p></div></div><br><h4>  Labyrinthe bas√© sur des croquis </h4><br><p>  La derni√®re fonction du syst√®me de cr√©ation de labyrinthe dans ce travail est la g√©n√©ration du labyrinthe bas√©e sur l'esquisse.  Les motifs de labyrinthes rectilignes et circulaires sont des labyrinthes homog√®nes.  Cependant, dans la plupart des cas, le parc de labyrinthe que nous pouvons rencontrer dans la vie quotidienne a une forme irr√©guli√®re.  Par cons√©quent, dans ce travail, une fonction est propos√©e qui, √† partir d'une image d'esquisse dessin√©e √† la main d'un utilisateur, peut facilement cr√©er une surface naturelle du labyrinthe, ainsi qu'un mod√®le de labyrinthe sous forme √©lectronique.  Cette fonctionnalit√© vous permet d'utiliser les sections de labyrinthe dans diverses applications, telles que les syst√®mes de recherche de chemin ou les parcs virtuels. </p><br><p>  La fonction de g√©n√©ration de labyrinthe propos√©e permet √† l'utilisateur d'utiliser un motif de labyrinthe dessin√© √† l'aide d'un logiciel graphique tel que Photoshop ou un croquis num√©ris√© dessin√© √† la main sur une feuille de papier.  L'image est charg√©e dans un syst√®me dans lequel l'algorithme de traitement d'image est appliqu√©, gr√¢ce auquel l'image est convertie en une carte de texture de labyrinthe.  Ce processus se d√©roule en trois √©tapes. </p><br><ul><li>  La premi√®re √©tape est le processus d'obtention d'une image d'esquisse dans le syst√®me.  Pour effectuer des calculs de processus ult√©rieurs, une image miniature est convertie en une image monocanal en niveaux de gris. </li><li>  La deuxi√®me √©tape est le processus de rupture des murs et des routes en utilisant la binarisation.  Ici, la valeur seuil est un √©l√©ment important pour d√©terminer les murs et les routes.  Le syst√®me a la possibilit√© de modifier la valeur du seuil d'entr√©e via l'interface. </li><li>  La troisi√®me √©tape est le processus de remplissage des trous qui surviennent pendant le processus de binarisation. </li></ul><br><p>  √Ä travers ces √©tapes, un labyrinthe naturel est cr√©√©.  Le syst√®me fournit √©galement un √©l√©ment de menu qui permet √† l'utilisateur de contr√¥ler le nombre d'it√©rations de l'op√©ration de remplissage. <br>  La figure ci-dessous montre le processus de g√©n√©ration d'une carte de texture de labyrinthe dans un mode √©tape par √©tape √† partir d'un croquis dessin√© par l'utilisateur du labyrinthe. </p><br><div class="spoiler">  <b class="spoiler_title">G√©n√©ration de labyrinthe √† partir d'un croquis utilisateur</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/ed5/8e6/bd4ed58e6db635e149cb239f834cf910.png" alt="image"></div></div><br><h3>  R√©sultats exp√©rimentaux et analyse </h3><br><p>  Le syst√®me propos√© pour cr√©er un paysage de labyrinthe a √©t√© impl√©ment√© √† l'aide de Microsoft Visual Studio 2013, OpenCV 2.4.11 et DirectX SDK 9.0c.  En outre, le moteur Unity 2017.3.1f1 (64 bits) a √©t√© utilis√© pour cr√©er un paysage de labyrinthe, finalis√© √† l'aide d'un travail graphique, bas√© sur une carte de texture de labyrinthe g√©n√©r√©e automatiquement √† l'aide du syst√®me de cr√©ation de labyrinthe de l'auteur.  Pour tester ce paysage et visualiser le r√©sultat en r√©alit√© virtuelle, le syst√®me a √©t√© int√©gr√© √† l'aide du dispositif Oculus Rift CV1 HMD et du SDK Oculus (ovr_unity_utilities 1.22.0) avec le moteur Unity3D.  Enfin, le PC utilis√© pour l'exp√©rience et la mise en ≈ìuvre avait des sp√©cifications Intel Core i7-6700, 16 Go de RAM (m√©moire √† acc√®s al√©atoire) et un processeur graphique Geforce 1080. </p><br><p>  La figure ci-dessous montre trois paysages de labyrinthe virtuels.  Ce sont les r√©sultats de la g√©n√©ration de relief √† partir des mod√®les de labyrinthe calcul√©s en utilisant les fonctions consid√©r√©es de ce syst√®me de d√©veloppement.  De plus, vous pouvez voir que divers environnements de labyrinthe virtuel sont cr√©√©s en ajoutant des facteurs graphiques conform√©ment au concept. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c27/dc1/eb0/c27dc1eb01144258e2387960c9f49691.png" alt="image"><br><p>  De plus, une enqu√™te pilote a √©t√© men√©e aupr√®s des participants communs.  Premi√®rement, en ce qui concerne les performances du syst√®me, √† l'aide de tests comparatifs ayant pour fonction de cr√©er des paysages de moteurs de jeux commerciaux, il a √©t√© confirm√© que le syst√®me propos√© permet aux utilisateurs (d√©veloppeurs) de modifier facilement et intuitivement les sections souhait√©es du labyrinthe.  Cela a r√©duit le temps requis et a conduit √† un degr√© √©lev√© de satisfaction des utilisateurs avec le syst√®me. </p><br><p>  A travers une enqu√™te sur le sentiment de pr√©sence, il a √©t√© confirm√© que les paysages labyrinthiques en r√©alit√© virtuelle peuvent offrir aux utilisateurs une nouvelle exp√©rience visuelle.  L'analyse statistique a √©galement confirm√© que tous les sites obtenus √† l'aide des trois fonctions propos√©es √©taient satisfaisants sans aucune diff√©rence significative entre eux.  √Ä l'avenir, le syst√®me sera affin√© pour fournir un environnement de labyrinthe virtuel √† grande √©chelle, tel qu'un parc de labyrinthes ou un parc √† th√®me, o√π plusieurs utilisateurs pourront d√©couvrir l'espace du labyrinthe ensemble en r√©alit√© virtuelle. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455744/">https://habr.com/ru/post/fr455744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455734/index.html">L'habitude de faire maintenant</a></li>
<li><a href="../fr455736/index.html">Consensus sur les crypto-monnaies avec l'exploitation mini√®re hybride et multi-PoW</a></li>
<li><a href="../fr455738/index.html">Comment gagner un milliard en mon√©tisant vos donn√©es?</a></li>
<li><a href="../fr455740/index.html">Apprentissage automatique dans une soci√©t√© d'investissement: nous classons les appels au support technique</a></li>
<li><a href="../fr455742/index.html">Faire de la musique: quand des solutions simples surpassent le deep learning</a></li>
<li><a href="../fr455746/index.html">Celesta 7.x: ORM, migration et test ¬´dans un seul paquet¬ª</a></li>
<li><a href="../fr455754/index.html">Tests d'un stratostat d√©rivant. Lancement de Rogozin et LoRa dans la stratosph√®re</a></li>
<li><a href="../fr455756/index.html">Est [favor] e</a></li>
<li><a href="../fr455758/index.html">Hacking de croissance chez Retail Rocket: de la recherche d'hypoth√®ses aux techniques de test</a></li>
<li><a href="../fr455760/index.html">La magie de SwiftUI ou sur les constructeurs de fonctions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>