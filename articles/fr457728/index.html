<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☘️ 📡 👩🏿‍🤝‍👩🏾 Tables de hachage dans Go. Détails d'implémentation 🤱🏽 👂 🔰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous discuterons de l'implémentation de la carte dans un langage sans génériques, examinerons ce qu'est une table de hachage, comment elle est organis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tables de hachage dans Go. Détails d'implémentation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457728/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb1/923/9cc/eb19239cc91d38445932da1ade5a5e7d.png" alt="image" width="400" height="400"></div><br><br>  Nous discuterons de l'implémentation de la carte dans un langage sans génériques, examinerons ce qu'est une table de hachage, comment elle est organisée dans Go, quels sont les avantages et les inconvénients de cette implémentation, et ce à quoi vous devez faire attention lorsque vous utilisez cette structure. <br><br>  Détails sous la coupe. <br><a name="habracut"></a><br><hr><br>  Attention!  Si vous connaissez déjà les tables de hachage dans Go, je vous conseille de sauter les bases et d'aller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , sinon il y a un risque de se lasser du moment le plus intéressant. <br><br><h4>  Qu'est-ce qu'une table de hachage </h4><br>  Pour commencer, je vais vous rappeler ce qu'est une table de hachage.  Il s'agit d'une structure de données qui vous permet de stocker des paires clé-valeur et, en règle générale, de posséder des fonctions: <br><br><ul><li>  Cartographie: <code>map(key) → value</code> <br></li><li>  Inserts: <code>insert(map, key, value)</code> <br></li><li>  Suppressions: <code>delete(map, key)</code> <br></li><li>  Recherche: <code>lookup(key) → value</code> <br></li></ul><br><h4>  Table de hachage en langue go </h4><br>  Une table de hachage dans la langue go est représentée par le mot-clé map et peut être déclarée de l'une des manières ci-dessous (plus à leur sujet plus tard): <br><br><pre> <code class="go hljs"> m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) m := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{key1: val1, key2: val2}</code> </pre><br>  Les principales opérations sont réalisées comme suit: <br><br><ul><li>  Insérer: <br><br><pre> <code class="go hljs">m[key] = value</code> </pre> <br></li><li>  Enlèvement: <br><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">delete</span></span>(m, key)</code> </pre> <br></li><li>  Recherche: <br><br><pre> <code class="go hljs">value = m[key]</code> </pre> <br>  ou <br><br><pre> <code class="go hljs">value, ok = m[key]</code> </pre> </li></ul><br><h4>  Faire le tour d'une table en aller </h4><br>  Considérez le programme suivant: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { m[i] = ((i % <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"key: %d, value: %t\n"</span></span>, k, v) } }</code> </pre><br>  Lancement 1: <br><br><pre> <code class="plaintext hljs">key: 3, value: false key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true</code> </pre><br>  Exécuter 2: <br><br><pre> <code class="plaintext hljs">key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true key: 3, value: false</code> </pre><br>  Comme vous pouvez le voir, la sortie varie d'une exécution à l'autre.  Et tout cela parce que la carte de Go n'est pas ordonnée, c'est-à-dire qu'elle n'est pas ordonnée.  Cela signifie que vous n'avez pas besoin de vous fier à l'ordre lors de vos déplacements.  La raison peut être trouvée dans le code source du langage d'exécution: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// mapiterinit initializes the hiter struct used for ranging over maps. func mapiterinit(t *maptype, h *hmap, it *hiter) {... // decide where to start r := uintptr(fastrand()) ... it.startBucket = r &amp; bucketMask(hB)...}</span></span></code> </pre><br>  L'emplacement de recherche est déterminé <b>au hasard</b> , rappelez-vous ceci!  La rumeur veut que les développeurs d'exécution forcent les utilisateurs à ne pas se fier à l'ordre. <br><br><h4>  Aller à la recherche de table </h4><br>  Regardons à nouveau un morceau de code.  Supposons que nous voulons créer des paires "nombre" - "nombre de fois 10": <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} fmt.Println(m, m[<span class="hljs-number"><span class="hljs-number">0</span></span>], m[<span class="hljs-number"><span class="hljs-number">1</span></span>], m[<span class="hljs-number"><span class="hljs-number">2</span></span>]) }</code> </pre><br>  Nous lançons: <br><br><pre> <code class="plaintext hljs">map[0:0 1:10] 0 10 0</code> </pre><br>  Et nous voyons que lorsque nous avons essayé d'obtenir la valeur de deux (que nous avons oublié de mettre), nous avons obtenu 0. Nous trouvons des lignes expliquant ce comportement dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> : «Une tentative de récupération d'une valeur de carte avec une clé qui n'est pas présente dans la carte retournera la valeur zéro pour le type des entrées dans la carte. ", mais traduit en russe, cela signifie que lorsque nous essayons d'obtenir la valeur de la carte, mais qu'elle n'est pas là, nous obtenons une" valeur de type zéro ", ce qui dans le cas du nombre 0. Que faire, si nous voulons distinguer les cas 0 et l'absence 2?  Pour ce faire, nous avons créé une forme spéciale d '"affectation multiple" - une forme où au lieu de la valeur unique habituelle, la carte renvoie une paire: la valeur elle-même et un autre booléen qui répond à la question de savoir si la clé demandée est présente dans la carte ou non " <br><br>  Correctement, le morceau de code précédent ressemblera à ceci: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} m2, ok := m[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-comment"><span class="hljs-comment">// somehow process this case m2 = 20 } fmt.Println(m, m[0], m[1], m2) }</span></span></code> </pre><br>  Et au démarrage, nous obtenons: <br><br> <code>map[0:0 1:10] 0 10 20 <br></code> <br><h4>  Créez une table dans Go. </h4><br>  Supposons que nous voulons compter le nombre d'occurrences de chaque mot dans une chaîne, lancez un dictionnaire pour cela et parcourez-le. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, word := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>, <span class="hljs-string"><span class="hljs-string">"from"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"best"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span>, <span class="hljs-string"><span class="hljs-string">"in"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>} { m[word]++ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(k, v) } }</code> </pre><br>  Voyez-vous une capture de <s>gopher</s> ?  - Et il l'est! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c02/89f/536/c0289f53662657b012659f89d71add02.png" alt="image" width="200" height="400"></div><br>  Lorsque nous essayons de démarrer un tel programme, nous obtenons une panique et le message "affectation à l'entrée dans une carte nulle".  Et tout cela parce que mapa est un type de référence et qu'il ne suffit pas de déclarer une variable, vous devez l'initialiser: <br><br><pre> <code class="go hljs">m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)</code> </pre><br>  Un peu plus bas, il sera clair pourquoi cela fonctionne de cette façon.  Au début, il y avait déjà présenté 4 façons de créer une carte, nous en avons examiné deux - cette déclaration en tant que variable et la création via make.  Vous pouvez également créer en utilisant la conception " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Littéraux composites</a> " <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{}</code> </pre> <br>  et si vous le souhaitez, même initialiser immédiatement avec des valeurs, cette méthode est également valide.  Quant à la création en utilisant new - à mon avis, cela n'a pas de sens, car cette fonction alloue de la mémoire à la variable et lui renvoie un pointeur rempli avec un type de valeur zéro, qui dans le cas de la carte sera nul (nous obtenons le même résultat que en var, plus précisément un pointeur sur celui-ci). <br><a name="GoMap"></a><br><h4>  Comment la carte est-elle transmise à une fonction? </h4><br>  Supposons que nous ayons une fonction qui essaie de changer le nombre qui lui a été transmis.  Voyons ce qui se passe avant et après l'appel: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { n = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { n := <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n before foo ="</span></span>, n) foo(n) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n after foo ="</span></span>, n) }</code> </pre><br>  Un exemple, je pense, est assez évident, mais inclut toujours la conclusion: <br><br><pre> <code class="plaintext hljs">n before foo = 15 n after foo = 15</code> </pre><br>  Comme vous l'avez probablement deviné, la fonction n est venue par valeur, pas par référence, donc la variable d'origine n'a pas changé. <br><br>  Faisons un tour de carte similaire: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] before foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) foo(m) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] after foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) }</code> </pre><br>  Et voilà: <br><br><pre> <code class="go hljs">m[<span class="hljs-number"><span class="hljs-number">10</span></span>] before foo = <span class="hljs-number"><span class="hljs-number">15</span></span> m[<span class="hljs-number"><span class="hljs-number">10</span></span>] after foo = <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  La valeur a changé.  "Eh bien, Mapa est adopté par référence?", Demandez-vous.  <b>Non.</b>  Il n'y a aucun lien dans Go.  Il est impossible de créer 2 variables avec 1 adresse, comme en C ++ par exemple.  Mais alors vous pouvez créer 2 variables pointant vers la même adresse (mais ce sont des pointeurs, et ils sont dans Go). <br><br>  Supposons que nous ayons une fonction fn qui initialise la carte m.  Dans la fonction principale, nous déclarons simplement une variable, l'envoyons pour initialiser et regarder ce qui s'est passé ensuite. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in fn?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fn(m) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in main?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre><br>  Conclusion: <br><br> <code>m == nil in fn?: false <br> m == nil in main?: true <br></code> <br>  Ainsi, la variable m a été passée <b>par valeur</b> , par conséquent, comme dans le cas du passage d'un entier régulier à la fonction, elle n'a pas changé (la copie locale de la valeur dans fn a changé).  Alors pourquoi la valeur située en m change-t-elle?  Pour répondre à cette question, considérez le code du langage d'exécution: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields }</span></span></code> </pre><br>  Map in Go n'est qu'un pointeur sur la structure hmap.  C'est la réponse à la question de savoir pourquoi, malgré le fait que la mappe est passée à la fonction par valeur, les valeurs elles-mêmes changent - tout dépend du pointeur.  La structure hmap contient également les éléments suivants: le nombre d'éléments, le nombre de «compartiments» (présentés sous forme de logarithme pour accélérer les calculs), le germe pour la randomisation des hachages (pour le rendre plus difficile à ajouter - essayez de ramasser les clés afin qu'il y ait des collisions continues), toutes sortes de champs de service et surtout, un pointeur vers des compartiments où les valeurs sont stockées.  Regardons l'image: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/979/e11/792/979e11792b1b87cc2a2548ebd3bd1743.png" alt="image"><br><br>  L'image montre une représentation schématique de la structure en mémoire - il y a un en-tête hmap, le pointeur vers lequel est une carte dans Go (il est créé lorsqu'il est déclaré avec var, mais il n'est pas initialisé, ce qui provoque le blocage du programme lors de la tentative d'insertion).  Le champ des compartiments est un référentiel de paires clé-valeur, il existe plusieurs de ces compartiments, chacun contient 8 paires.  Tout d'abord dans le "bucket" se trouvent des emplacements pour des bits de hachage supplémentaires (e0..e7 est appelé e - car <i>des</i> bits de hachage <i>supplémentaires</i> ).  Viennent ensuite les clés et les valeurs en tant que liste de toutes les clés, puis une liste de toutes les valeurs. <br><br>  Selon le hachage de la fonction, il est déterminé dans quel «bucket» nous mettons la valeur, à l'intérieur de chaque «bucket» il peut y avoir jusqu'à 8 collisions, à la fin de chaque «bucket» il y a un pointeur vers un autre, si le précédent déborde. <br><br><h4>  Comment évolue la carte? </h4><br>  Dans le code source, vous pouvez trouver la ligne: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// Maximum average load of a bucket that triggers growth is 6.5.</span></span></code> </pre> <br>  c'est-à-dire que s'il y a en moyenne plus de 6,5 éléments dans chaque compartiment, une augmentation du tableau de compartiments se produit.  Dans le même temps, le tableau est alloué 2 fois plus, et les anciennes données y sont copiées en petites portions à chaque insertion ou suppression, afin de ne pas créer de très gros retards.  Par conséquent, toutes les opérations seront légèrement plus lentes dans le processus d'évacuation des données (lors de la recherche, nous devons également rechercher à deux endroits).  Après une évacuation réussie, de nouvelles données commencent à être utilisées. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/c06/2aa/f00c062aa458e48d0475635e06a3697a.jpg" alt="image" width="300" height="300"></div><br><h4>  Prendre l'adresse de l'élément de carte. </h4><br>  Un autre point intéressant - au tout début de l'utilisation du langage que je voulais faire comme ceci: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> a := &amp;m[<span class="hljs-number"><span class="hljs-number">1</span></span>] fmt.Println(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], *a) }</code> </pre><br>  Mais Go dit: "ne peut pas prendre l'adresse de m [1]".  L'explication de la raison pour laquelle il est impossible de prendre l'adresse de la valeur réside dans la procédure d'évacuation des données.  Imaginez que nous prenions l'adresse de la valeur, puis la mapa a grandi, une nouvelle mémoire a été allouée, les données ont été évacuées, les anciennes ont été supprimées, le pointeur est devenu incorrect, de telles opérations sont donc interdites. <br><br><h4>  Comment la carte est-elle implémentée sans génériques? </h4><br>  Ni une interface vide, ni la génération de code n'y sont pour rien; le tout est de la remplacer lors de la compilation.  Considérez ce que les fonctions familières de Go deviennent: <br><br><pre> <code class="plaintext hljs">v := m["k"] → func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer v, ok := m["k"] → func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) m["k"] = 9001 → func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer delete(m, "k") → func mapdelete(t *maptype, h *hmap, key unsafe.Pointer)</code> </pre><br>  Nous voyons qu'il existe des fonctions mapaccess pour les accès, pour l'écriture et la suppression de mapassign et mapdelete, respectivement.  Toutes les opérations utilisent unsafe.Pointer, qui ne se soucie pas du type vers lequel il pointe, et les informations sur chaque valeur sont décrites par un <b>descripteur de type</b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> mapType <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { key *_type elem *_type ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> _type <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { size <span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span> alg *typeAlg ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> typeAlg <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { hash <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uintptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uintptr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function">...}</span></span></code> </pre><br>  MapType stocke les descripteurs (_type) de la clé et de la valeur.  Pour un descripteur de type, des opérations (typeAlg) de comparaison, prenant un hachage, une taille, etc. sont définies, donc on sait toujours comment les produire. <br><br>  Un peu plus sur son fonctionnement.  Lorsque nous écrivons v = m [k] (en essayant d'obtenir la valeur de v à partir de la clé k), le compilateur génère quelque chose comme ceci: <br><br><pre> <code class="go hljs">kPointer := unsafe.Pointer(&amp;k) vPointer := mapaccess1(typeOf(m), m, kPointer) v = *(*typeOfvalue)vPointer</code> </pre><br>  Autrement dit, nous prenons un pointeur sur une clé, la structure mapType, à partir de laquelle nous découvrons les descripteurs de la clé et de la valeur, le pointeur pour se mapper lui-même (c'est-à-dire, map) et le transmettre à mapaccess1, qui renverra un pointeur sur la valeur.  Nous plaçons le pointeur sur le type souhaité, déréférençons et obtenons la valeur. <br><br>  Examinons maintenant le code de recherche de l'exécution (qui est légèrement adapté à la lecture): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *mapType, m *mapHeader, key unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pointer</span></span></span></span> {</code> </pre><br>  La fonction recherche la clé dans la carte et renvoie un pointeur sur la valeur correspondante, les arguments nous sont déjà familiers - c'est mapType, qui stocke les descripteurs des types et valeurs de clé, la carte elle-même (mapHeader) et un pointeur sur la mémoire qui stocke la clé.  Nous renvoyons un pointeur vers la mémoire qui stocke la valeur. <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || m.count == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zero }</code> </pre><br>  Ensuite, nous vérifions si le pointeur vers l'en-tête de la carte n'est pas nul, s'il y a 0 élément et renvoyons une valeur nulle, si c'est le cas. <br><br><pre> <code class="go hljs"> hash := t.key.hash(key, m.seed) <span class="hljs-comment"><span class="hljs-comment">// hash := hashfn(key) bucket := hash &amp; (1&lt;&lt;m.logB-1) // bucket := hash % nbuckets extra := byte(hash &gt;&gt; 56) // extra := top 8 bits of hash b := (*bucket)(add(m.buckets, bucket*t.bucketsize)) // b := &amp;m.buckets[bucket]</span></span></code> </pre><br>  Nous calculons le hachage de clé (nous savons calculer pour une clé donnée à partir d'un descripteur de type).  Ensuite, nous essayons de comprendre quel «seau» vous devez aller voir (le reste de la division par le nombre de «seaux», les calculs sont légèrement accélérés).  Ensuite, nous calculons le hachage supplémentaire (nous prenons les 8 bits les plus significatifs du hachage) et déterminons la position du «bucket» en mémoire (arithmétique d'adresse). <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.extra[i] != extra { <span class="hljs-comment"><span class="hljs-comment">// check 8 extra hash bits continue } k := add(b, dataOffset+i*t.key.size) // pointer to ki in bucket if t.key.equal(key, k) { // return pointer to vi return add(b, dataOffset+8*t.key.size+i*t.value.size) } } b = b.overflow if b == nil { return zero } }</span></span></code> </pre><br>  La recherche, si vous regardez, n'est pas si compliquée: nous passons par les chaînes de "seaux", en passant au suivant, si vous ne l'avez pas trouvé.  La recherche dans le "bucket" commence par une comparaison rapide du hachage supplémentaire (c'est pourquoi ces e0 ... e7 au début de chacun sont un "mini" hachage de la paire pour une comparaison rapide).  Si elle ne correspond pas, allez plus loin, si c'est le cas, alors nous vérifions plus attentivement - nous déterminons où se trouve la clé soupçonnée d'être recherchée, comparons si elle est égale à ce qui a été demandé.  S'il est égal, déterminez la position de la valeur en mémoire et retournez.  Comme vous pouvez le voir, rien de surnaturel. <br><br><h4>  Conclusion </h4><br>  Utilisez des cartes, mais sachez et comprenez comment elles fonctionnent!  Vous pouvez éviter un rake en comprenant certaines des subtilités - pourquoi il est impossible de prendre l'adresse de la valeur, pourquoi tout tombe pendant la déclaration sans initialisation, pourquoi il est préférable d'allouer de la mémoire à l'avance, si le nombre d'éléments est connu (nous éviterons les évacuations) et bien plus encore. <br><br><hr><br>  Références: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Allez les cartes en action", Andrew Gerrand</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Comment le runtime go implémente les cartes efficacement», Dave Cheney</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Comprendre le type à emporter", William Kennedy</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Implémentation de la carte intérieure, Keith Randall</a> <br>  <a href="">code source de la carte, Go Runtime</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">golang spec</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aller efficace</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gopher images</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457728/">https://habr.com/ru/post/fr457728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457714/index.html">Débordement de pile en anglais: Community Kill Guide</a></li>
<li><a href="../fr457718/index.html">HyperCard, le lien perdu dans l'évolution du Web</a></li>
<li><a href="../fr457720/index.html">Autodesk Maya: fonctionnalités de base utiles pour travailler avec des modèles 3D</a></li>
<li><a href="../fr457722/index.html">SQL: Problème de présence de temps: compte rendu</a></li>
<li><a href="../fr457724/index.html">OpenCV sur STM32F7-Discovery</a></li>
<li><a href="../fr457730/index.html">Dans le bureau, il y a une illusion de contrôle - ce n'est pas sur la télécommande. Conversation avec Devhab</a></li>
<li><a href="../fr457734/index.html">La révolution de l'Open Source en Italie commence</a></li>
<li><a href="../fr457736/index.html">"Les outils ne sont pas aussi importants que la capacité de penser aux systèmes qu'ils créent." Grande interview avec Martin Kleppman</a></li>
<li><a href="../fr457738/index.html">Comment nous avons implémenté SD-Access et pourquoi c'était nécessaire</a></li>
<li><a href="../fr457742/index.html">Auto-scaling horizontal des foyers Kubernetes et Prometheus pour une haute disponibilité et une disponibilité de l'infrastructure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>