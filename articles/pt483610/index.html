<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è∏Ô∏è üë©‚Äç‚öïÔ∏è üëéüèΩ Um aut√¥mato √© uma coisa do evento? üëéüèª üíò ü§∞üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Tendo ouvido dos l√°bios autorit√°rios que ‚Äúaut√¥matos s√£o uma coisa de evento‚Äù [3], percebi que aut√¥matos finitos s√£o marcados completam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Um aut√¥mato √© uma coisa do evento?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483610/"><h3>  1. Introdu√ß√£o </h3><br>  Tendo ouvido dos l√°bios autorit√°rios que ‚Äúaut√¥matos s√£o uma coisa de evento‚Äù [3], percebi que aut√¥matos finitos s√£o marcados completamente.  Julgue por si mesmo: na biblioteca Qt, um modelo de evento de aut√¥matos [1] √© implementado, na UML eles tamb√©m s√£o [2], analisamos os aut√¥matos do pacote de extens√£o Simulink-Stateflow do sistema MATLAB [4] (daqui em diante simplesmente Stateflow) e sobre eventos, etc.  etc.  Nesse contexto, a afirma√ß√£o do Ph.D.  A.A.  √â impertinente interpretar de uma maneira diferente, porque  nada mais pode ser, porque n√£o pode ser. <br><br>  Mas, se voc√™ se lembra da teoria dos aut√¥matos finitos (TCA), n√£o h√° uma palavra sobre aut√¥matos de eventos nela!  Mas, para contradizer a teoria, s√£o necess√°rios argumentos pesados.  Existe alguma raz√£o para duvidar do profissionalismo de D. Harell, como criador da nota√ß√£o na qual a linguagem UML, o pacote Stateflow, baseia suas id√©ias, que, por sua vez, n√£o s√£o desconhecidas por A.A.  Impertinente?  De fato, existem UML, Stateflow, programa√ß√£o SWITCH e outras op√ß√µes de programa√ß√£o autom√°tica e, em um grau ou outro, funcionam com √™xito. <br><br>  Ent√£o, √© poss√≠vel remover o ‚Äúestigma dos eventos‚Äù do modelo de m√°quina de estados finitos, separando os ‚Äúcosteletas das moscas‚Äù?  I.e.  separar a teoria dos aut√¥matos e dos modelos computacionais semelhantes aos modelos de D. Harel.  E considerar que estes √∫ltimos, embora utilizem a terminologia da teoria dos aut√¥matos, representam, a julgar pela sua implementa√ß√£o, o desenvolvimento de um modelo de diagramas de blocos de programas. <br><a name="habracut"></a><br>  <i>Observa√ß√£o 1. Nesse caso, estamos falando sobre o modelo de gerenciamento de programa, e n√£o sobre o pr√≥prio modelo de programa (para obter mais detalhes sobre os modelos, consulte [5]).</i> <br><br>  Portanto, lembre-se, a biblioteca Qt implementa um modelo de evento de uma m√°quina de estados finitos, que foi emprestada da UML.  O mesmo modelo √© implementado pelo Stateflow.  I.e.  a fonte dos eventos √© a UML, onde os aut√¥matos s√£o baseados na nota√ß√£o proposta por D. Harel.  Mas culpar o √∫ltimo por criar essa programa√ß√£o autom√°tica tamb√©m n√£o seria verdade, porque  "Eventfulness" √© uma tend√™ncia das abordagens modernas para a implementa√ß√£o de modelos de software.  Ele √© baseado em opini√µes oficiais, como as mencionadas ‚Äúm√°quinas s√£o uma coisa do evento‚Äù e a alta popularidade de linguagens e tecnologias como a UML.  Sem d√∫vida, este √© o resultado da imita√ß√£o de m√°quinas sob os princ√≠pios existentes de opera√ß√£o de sistemas operacionais. <br><br>  Mas, repetimos, como n√£o parece estranho, mas para alguns pode at√© se tornar not√≠cia, na teoria dos aut√¥matos n√£o h√° modelo de evento de um aut√¥mato finito.  Pelo menos na parte considerada cl√°ssica (veja para mais detalhes, por exemplo, [6] ou [7]).  Existe uma clara contradi√ß√£o entre teoria e pr√°tica.  Em tal situa√ß√£o, voc√™ precisa fazer algo com a teoria ou de alguma forma influenciar a pr√°tica.  Mas, talvez, os programadores estejam certos em seu desejo de finalizar o modelo de uma m√°quina de estados finitos, incluindo o conceito de "evento" nela [8, 9]? <br><br>  Mas como conectar os desejos dos programadores ao fato de que ‚Äúas maiores dificuldades no uso da abordagem de aut√¥matos est√£o relacionadas √† compreens√£o dos recursos do funcionamento dos aut√¥matos nos sistemas de eventos‚Äù (ver [8]).  Gostaria de entender as causas de tais problemas e, nesse contexto, implementar m√°quinas de eventos e / ou seus an√°logos.  Para esse prop√≥sito, para detalhes, tomamos a implementa√ß√£o de aut√¥matos no Qt e os repetimos usando o modelo de um aut√¥mato finito cl√°ssico. <br><br>  Essa implementa√ß√£o de aut√¥matos de eventos √© necess√°ria para avaliar e / ou superar os "recursos" mencionados.  O uso do modelo cl√°ssico tamb√©m estender√° a teoria dos aut√¥matos √† pr√°tica da ‚Äúprograma√ß√£o de eventos‚Äù.  E, no final, um anal√≥gico baseado em outro modelo expandir√° apenas a √°rea de aplica√ß√£o de modelos de m√°quinas de estados finitos. <br><br><h3>  2. Eventos, sinais e identidade de g√™nero de aut√¥matos </h3><br>  Na UML, um evento √© "um fen√¥meno significativo que tem uma certa posi√ß√£o no tempo e no espa√ßo ... e acarreta certas consequ√™ncias" [10].  Um evento na teoria dos aut√¥matos √© um subconjunto dos caracteres de entrada representados pelos caracteres do alfabeto de sa√≠da (existe at√© o conceito de √°lgebra de eventos no TCA) [6].  A mesma coisa que causa a transi√ß√£o de um aut√¥mato √© chamada de sinais de entrada na teoria dos aut√¥matos.  S√£o as conseq√º√™ncias e ‚Äúa raz√£o, a transi√ß√£o do aut√¥mato de um estado para outro.  Nesse caso, os sinais de sa√≠da s√£o "a resposta do aut√¥mato aos sinais de entrada". Ambos se referem a instantes de tempo determinados pelas transi√ß√µes correspondentes do aut√¥mato "[6]. Na UML, o sinal (sinal) √©" uma entidade nomeada que serve como um meio de comunica√ß√£o entre objetos ‚Äù[10]. <br><br>  Assim, os nomes dos termos s√£o os mesmos, mas o significado investido neles √© diferente.  Embora, se voc√™ os reorganizar, poder√° encontrar uma semelhan√ßa: fica claro que os eventos na UML correspondem aos sinais das m√°quinas de estados finitos no TCA.  Mas, talvez, diferentes entidades tamb√©m estejam ocultas sob o termo "m√°quina de estados finitos"?  Vamos tentar descobrir, come√ßando pelos eventos ... <br><br>  O aut√¥mato de evento √© um aut√¥mato passivo, porque  funciona apenas no momento da chegada dos eventos.  Por outro lado, o aut√¥mato cl√°ssico representa o modelo ativo.  Ele funciona sem refer√™ncia a nada (para mais detalhes sobre aut√¥matos passivos e ativos, consulte [9]).  Aqui a associa√ß√£o com dois corredores implora, onde o primeiro √© impulsionado por chutes (eventos) e o segundo √© executado por si s√≥. <br><br>  Ao contr√°rio de [8], n√£o associaremos inicialmente os momentos de ocorr√™ncia de eventos com o in√≠cio do aut√¥mato.  Portanto, permaneceremos na estrutura da teoria dos aut√¥matos, que determina a natureza ass√≠ncrona do funcionamento dos aut√¥matos em rela√ß√£o ao ambiente externo.  Ele fala apenas de tempo discreto, no qual a mudan√ßa de estados √© realizada por um per√≠odo arbitrariamente pequeno, mas n√£o igual a zero, em tempo real.  E a raz√£o para as transi√ß√µes √© o estado atual e os sinais de entrada da m√°quina, onde as consequ√™ncias s√£o a instala√ß√£o de um novo estado e os valores dos sinais de sa√≠da da m√°quina (para obter mais detalhes sobre a defini√ß√£o de m√°quinas, consulte [6]). <br><br>  A teoria dos aut√¥matos √© flex√≠vel na determina√ß√£o do tempo discreto, que √© um modelo em tempo real.  Portanto, um ciclo de tempo discreto pode ter um valor fixo ou flutuante de um intervalo em tempo real e, de acordo com isso, as m√°quinas s√£o chamadas s√≠ncronas ou ass√≠ncronas.  Ao mesmo tempo, o intervalo de tempo associado ao rel√≥gio pode ter qualquer valor, incluindo um valor infinitamente pequeno, mas n√£o igual a zero. <br><br>  <i>Observa√ß√£o 2. Um modelo de m√°quina de estados finitos √© um dos poucos modelos formais que inclui em sua defini√ß√£o um modelo em tempo real de forma expl√≠cita.</i> <br><br>  Como resultado, a velocidade formalmente "infinita" do aut√¥mato ativo permite que qualquer evento seja tratado como um sinal de entrada potencial (em termos de UML, a condi√ß√£o [11] corresponde a ele).  A m√°quina precisar√° apenas "capturar" esses eventos / sinais e fazer uma pausa entre eles.  Tudo isso realmente define o protocolo para o trabalho conjunto do meio e do aut√¥mato.  O protocolo tamb√©m deve resolver o problema de reconhecer eventos id√™nticos recebidos sucessivamente.  Sem isso, por exemplo, dois s√≠mbolos id√™nticos, recebidos um ap√≥s o outro, podem ser percebidos como um. <br><br>  Formalmente, as nuances do processamento de eventos n√£o s√£o significativas (consulte o mesmo aut√¥mato abstrato), mas na implementa√ß√£o pr√°tica de algoritmos constru√≠dos pelo tipo de modelo de evento, elas devem ser levadas em considera√ß√£o.  No caso da biblioteca Qt, sua contabilidade est√° oculta nas classes de implementa√ß√£o do aut√¥mato.  Al√©m disso, levaremos em conta as diferen√ßas entre aut√¥matos cl√°ssicos e de eventos, usando o exemplo da implementa√ß√£o da calculadora mais simples de [1], onde √© dada sua "implementa√ß√£o de evento".  Em contraste com essa solu√ß√£o, modelos equivalentes ser√£o criados com base na m√°quina cl√°ssica de estados finitos. <br><br><h3>  3. Modelos de calculadora </h3><br>  Ent√£o, vamos come√ßar ... Chamamos sinais de eventos, evento de aut√¥matos comuns ... ou na ordem inversa e / ou vice-versa?  Ugh!  Confuso.  Em suma, o "glocky cuzdra shteko budlanula" completo e algo "cachos".  Para descobrir quem √© quem, o que e o que chamar, a maneira mais segura √© escolher um "bokra" espec√≠fico e "bater nele" ... O programa de "calculadora autom√°tica" continuar√° sendo esse "lado". <br><br><h4>  3.1  Modelo de calculadora ativo </h4><br>  Na fig.  1 mostra o modelo original da classe Calculator de [1].  Na apar√™ncia, parece uma m√°quina abstrata cl√°ssica sem sa√≠da.  A diferen√ßa √© que o Qt conecta a√ß√µes quando entra e sai de um estado.  Na sa√≠da, eles s√£o acionados pelo sinal de sa√≠da () e, ao entrar no estado, pelo sinal de entrada ().  Mas, observamos, essas a√ß√µes n√£o s√£o representadas no gr√°fico de forma alguma. <br><br>  Se compararmos o modelo na Fig.  1 com um aut√¥mato com um estado abstrato (seus outros nomes s√£o estruturais, aut√¥mato l√≥gico), pode-se ver facilmente que as a√ß√µes na sa√≠da do estado correspondem aos sinais do aut√¥mato de Mealy e as a√ß√µes na entrada correspondem aos sinais do aut√¥mato de Moore. <br>  Observa√ß√£o 3. Al√©m disso, considerando a implementa√ß√£o de software do modelo, n√£o falaremos sobre sinais, eventos, condi√ß√µes, etc., mas sobre as a√ß√µes dos aut√¥matos, assumindo que no n√≠vel do programa eles estejam associados a determinadas a√ß√µes do programa, que no caso geral representado por fun√ß√µes de software. <br><br>  O chamado aut√¥mato Mili-Moore combinado (ou um aut√¥mato diferentemente misto [12]), equivalente ao aut√¥mato na Fig.  1, √© mostrado na Fig. 2, onde as fun√ß√µes correspondentes aos sinais de entrada e sa√≠da do aut√¥mato tamb√©m s√£o mostradas √† direita do gr√°fico. <br><br><img src="https://habrastorage.org/webt/dq/ki/ps/dqkipszttmbkgyexe9labqsio9e.jpeg" alt="imagem"><br>  <i>Fig. 1.</i>  <i>Diagrama da m√°quina de eventos da calculadora</i> <br><br><img src="https://habrastorage.org/webt/c3/la/ue/c3laueqyd9oiwdf9aiu5gpyi_yk.jpeg" alt="imagem"><br>  <i>Fig. 2.</i>  <i>Calculadora da classe de aut√¥matos Count Miley-Moore</i> <br><br>  Para um modelo semelhante a um aut√¥mato na Fig. 2, por a√ß√µes de entrada / sa√≠da, queremos dizer predicados e a√ß√µes que s√£o fun√ß√µes-m√©todos de programa de classes [aut√¥matos].  Os predicados analisam o estado atual dos elementos de mem√≥ria (vari√°veis, propriedades de classe) de forma alguma (isso √© importante!) Sem afet√°-los, mas dependendo de seu valor, retorne um valor booleano.  A√ß√µes de um valor n√£o retornam, mas alteram os elementos de mem√≥ria. <br>  A partir da fig.  2 segue-se que o modelo da calculadora, como a ‚Äúcaixa preta‚Äù, possui quatro canais de entrada e sete canais de sa√≠da em termos do n√∫mero de predicados e a√ß√µes.  √â f√°cil ver que, em compara√ß√£o com um aut√¥mato abstrato, que por defini√ß√£o n√£o possui mais de um canal de entrada e de sa√≠da, um aut√¥mato estrutural com muitos canais √© mais universal, flex√≠vel e conveniente. <br><br>  O modelo na fig.  2 pode ser simplificado ‚Äúcolando‚Äù os estados 1 e 2. Para fazer isso, primeiro voc√™ precisa transformar o aut√¥mato original em um aut√¥mato Mealy.  N√≥s o obtemos carregando os arcos que entram no estado dos sinais com os sinais representados pelos sinais dos v√©rtices do aut√¥mato de Moore.  Depois disso, a opera√ß√£o de colagem se torna aparente.  O resultado da colagem dos estados no estado 2, que agora se torna inicial, √© mostrado na Fig.  3) <br><br><img src="https://habrastorage.org/webt/qa/en/yw/qaenywlioaky3gizvfju27faxmm.jpeg" alt="imagem"><br>  <i>Fig. 3.</i>  <i>O resultado da transforma√ß√£o e colagem dos estados do aut√¥mato na Fig. 2</i> <br><br>  Explique a a√ß√£o y1 e a vari√°vel nTypeButtons.  No total, eles implementam um protocolo que simula eventos.  A vari√°vel nTypeButtons determina o tipo de s√≠mbolos de entrada do aut√¥mato dividindo-os em s√≠mbolos digitais, s√≠mbolos de opera√ß√£o, o s√≠mbolo "reset" e o s√≠mbolo "igual".  Seu valor igual a zero significa a aus√™ncia de caracteres de entrada (nenhuma das teclas da calculadora √© pressionada).  Ap√≥s o processamento do s√≠mbolo, isso tamb√©m significa que o s√≠mbolo de entrada √© percebido automaticamente.  Isso bloqueia a resposta ao caractere de entrada. <br><br>  O c√≥digo para a classe da calculadora criada no √¢mbito do ambiente de programa√ß√£o autom√°tica de componentes visuais (VKPa) [5] √© mostrado nas listagens 1, 2. <br><br><div class="spoiler">  <b class="spoiler_title">Listagem 1. Cabe√ßalho da classe FCalculator</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lfsaappl.h"</span></span></span><span class="hljs-meta"> enum Buttons { digit0 = 0, digit1, digit2, digit3, digit4, digit5, digit6, digit7, digit8, digit9, opPlus, opMinus, opCancel, opEqual, opNone }; class FCalculator : public LFsaAppl { public: void MooreAction(); LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FCalculator(pTAppCore, nameFsa, pCVarFsaLibrary); } FCalculator(TAppCore *pInfo, string strNam, CVarFsaLibrary *pCVFL); virtual ~FCalculator(void); public: void digitButtonPressed(int button); void operationButtonPressed(int button); private: void s1Entered(); void s2Entered(); void s3Entered(); void s3Exited(); void s5Entered(); void s5Exited(); private: int Rf, Rb; Buttons transitionButton, Op; int nTypeButtons; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 0 - none; 1 - digit button; 2 - operation button; void doOp(Buttons op); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y3(); void y5(); void y6(); void y7(); void y8(); void y9(); void y10(); int nState{2}; };</span></span></span></span></code> </pre> <br><br></div></div><br>  Vamos explicar  No VKPa, qualquer classe de aut√¥mato herda as propriedades da classe de aut√¥mato base LFsaAppl.  O m√©todo Create () cria c√≥pias das classes inclu√≠das nas bibliotecas din√¢micas dos processos autom√°ticos.  O m√©todo virtual MooreAction () se sobrep√µe quando um modelo de aut√¥mato Moore √© selecionado, definindo a√ß√µes associadas aos estados do aut√¥mato.  Os m√©todos x [n] e y [n] s√£o os predicados e a√ß√µes associados aos canais de entrada / sa√≠da do aut√¥mato.  O algoritmo de comportamento da classe [aut√¥mato] √© representado pela tabela de transi√ß√£o (consulte a Listagem 2), que consiste em uma matriz de cadeias de caracteres do tipo LArc.  O restante do c√≥digo repete o c√≥digo da classe de origem Calculator. <br><br><div class="spoiler">  <b class="spoiler_title">Listagem 2. Implementa√ß√£o da classe FCalculator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FCalculator.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"DlgCalculator.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ui_cdlgcalculator.h"</span></span></span><span class="hljs-meta"> static LArc TBL_Calculator[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//* LArc("1", "2","x1", "y1"), // [0-9] LArc("2", "1","x3", "y1"), // [c] LArc("2", "2","x1", "y1"), // [0-9] LArc("2", "3","x2", "y1"), // [+][-] LArc("3", "1","x3", "y3"), // [c] LArc("3", "3","x2", "y3"), // [+][-] LArc("3", "4","x1", "y3"), // [0-9] LArc("3", "5","x4", "y3"), // [=] LArc("4", "1","x3", "y1"), // [c] LArc("4", "3","x2", "y1"), // [+][-] LArc("4", "4","x1", "y1"), // [0-9] LArc("4", "5","x4", "y1"), // [=] LArc("5", "1","x3", "y5"), // [c] LArc("5", "2","x1", "y5"), // [0-9] LArc("5", "3","x2", "y5"), // [+][-] //*/ /* LArc("2", "2","x1", "y1y7"), // [0-9] LArc("2", "2","x3", "y1y6"), // [c] LArc("2", "3","x2", "y1y8"), // [+][-] LArc("3", "2","x3", "y3y6"), // [c] LArc("3", "3","x2", "y3y8"), // [+][-] LArc("3", "4","x1", "y3y7"), // [0-9] LArc("3", "5","x4", "y3y9"), // [=] LArc("4", "2","x3", "y1y6"), // [c] LArc("4", "3","x2", "y1y8"), // [+][-] LArc("4", "4","x1", "y1y7"), // [0-9] LArc("4", "5","x4", "y1y9"), // [=] LArc("5", "2","x3", "y5y6"), // [c] LArc("5", "2","x1", "y5y7"), // [0-9] LArc("5", "3","x2", "y5y8"), // [+][-] */ // LArc("1", "1","--", "y10"), // SWITCH LArc() }; FCalculator::FCalculator(TAppCore *pInfo, string strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Calculator, strNam, nullptr, pCVFL) { pTAppCore = pInfo; Rf= 0; Rb = 0; Op = opNone; } FCalculator::~FCalculator(void) { } //   int FCalculator::x1() { if (nTypeButtons != 1) return false; else return true; } //   +, - int FCalculator::x2() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton != opCancel &amp;&amp; transitionButton != opEqual ) return true; else return false; } //  Cancel int FCalculator::x3() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton == opCancel) return true; else return false; } //  opEqual int FCalculator::x4() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton == opEqual) return true; else return false; } void FCalculator::y1() { nTypeButtons = 0; } void FCalculator::y3() { s3Exited(); } void FCalculator::y5() { s5Exited(); } void FCalculator::y6() { s1Entered(); } // 1 void FCalculator::y7() { s2Entered(); } // 2, 4 void FCalculator::y8() { s3Entered(); } // 3 void FCalculator::y9() { s5Entered(); } // 5 void FCalculator::y10() { switch(nState) { case 2: if (x1()) { y1();y7(); } if (x3()) { y1();y6(); } if (x2()) { y1();y8(); nState = 3; } break; case 3: if (x3()) { y3();y6(); nState = 2; } if (x2()) { y3();y8(); } if (x1()) { y3();y7(); nState = 4; } if (x4()) { y3();y9(); nState = 5; } break; case 4: if (x3()) { y1();y6(); nState = 2; } if (x2()) { y1();y8(); nState = 3; } if (x1()) { y1();y7(); } if (x4()) { y1();y9(); nState = 5; } break; case 5: if (x3()) { y5();y6(); nState = 2; } if (x1()) { y5();y7(); nState = 2; } if (x2()) { y5();y8(); nState = 3; } break; } } void FCalculator::MooreAction() { // return; string strState = FGetState(); if (strState=="1") { y6(); } else if (strState=="2") { y7(); } else if (strState=="3") { y8(); } else if (strState=="4") { y7(); } else if (strState=="5") { y9(); } } /////////////////////////////////////////////////////////////////////////// void FCalculator::digitButtonPressed(int button) { transitionButton = static_cast&lt;Buttons&gt;(button); nTypeButtons = 1; } void FCalculator::operationButtonPressed(int button) { transitionButton = static_cast&lt;Buttons&gt;(button); nTypeButtons = 2; } void FCalculator::s1Entered() { Rf = 0; Rb = 0; Op = opNone; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } void FCalculator::s2Entered() { if (Rf &lt; 9999999) { Rf = Rf*10 + transitionButton; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } } void FCalculator::s3Entered() { if (Rb != 0) { doOp(Op); static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } Rb = Rf; Op = transitionButton; } void FCalculator::s3Exited() { nTypeButtons = 0; if (transitionButton &gt; digit9 &amp;&amp; transitionButton &lt; opCancel ) { doOp(transitionButton); Rb = 0; Op = transitionButton; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } else { Rf = 0; } } void FCalculator::s5Entered() { doOp(Op); Op = opNone; Rb = Rf; // added by me static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } void FCalculator::s5Exited() { nTypeButtons = 0; if (transitionButton &lt;= 9) { Rb = 0; Rf = 0; } } void FCalculator::doOp(Buttons op) { switch (op) { case opPlus: Rf = Rf + Rb; break; case opMinus: Rf = Rb - Rf; break; default: break; } }</span></span></span></span></code> </pre><br><br></div></div><br>  A Lista 2 de aviso cont√©m tr√™s tabelas de salto (duas s√£o comentadas).  √â assim que os recursos do controle dedicado s√£o realizados quando, ap√≥s a remo√ß√£o do coment√°rio, o comportamento da classe pode ser alterado "por clique" sem afetar seus m√©todos e propriedades.  O m√©todo y10 e a linha correspondente na tabela de transi√ß√£o (consulte a linha marcada com o coment√°rio SWICH) foram introduzidos para simular a tecnologia SWITCH (para obter mais detalhes, consulte [9]) dentro da estrutura da tecnologia VKPA.  Nesse caso, o comportamento de qualquer aut√¥mato √© modelado por uma chamada c√≠clica ao operador SWITCH, que imita o comportamento do aut√¥mato (aqui o aut√¥mato VKPa atua como um ambiente externo). <br><br><h4>  3.2  Modelo de calculadora passiva </h4><br>  O modelo ativo da calculadora varre constantemente os canais de entrada.  Assim que o valor da vari√°vel nTypeButtons se torna diferente de zero, isso serve como um sinal da chegada do pr√≥ximo s√≠mbolo √† entrada do aut√¥mato.  Como resultado, a transi√ß√£o e a a√ß√£o y1 s√£o acionadas, redefinindo a vari√°vel nTypeButtons, bloqueando o reativamento autom√°tico da m√°quina pelo mesmo caractere. <br>  Diferentemente do modelo da ‚Äúcalculadora ativa‚Äù, um aut√¥mato de evento n√£o pode, por defini√ß√£o, reprocessar um s√≠mbolo de entrada.  Agora est√° claro que "as maiores dificuldades em usar a abordagem de aut√¥matos ... em sistemas de eventos" parecem se resumir a suprimir a atividade de um aut√¥mato ativo e vincular seu funcionamento a eventos.  Mostramos o procedimento para mudar para um aut√¥mato passivo usando o exemplo da ‚Äúcalculadora ativa‚Äù rec√©m-criada. <br>  O ambiente VKPa cont√©m um modo de opera√ß√£o passo a passo, introduzido para depurar processos autom√°ticos.  Mas pode ser usado para simular m√°quinas de eventos.  Para fazer isso, 1) defina o espa√ßo do aut√¥mato no qual o aut√¥mato √© colocado um modo de opera√ß√£o passo a passo (observe, n√£o um aut√¥mato separado, mas todo o espa√ßo do aut√¥mato que cont√©m aut√¥matos) e 2) relacione os momentos de ocorr√™ncia de eventos com a execu√ß√£o de uma etapa discreta da opera√ß√£o do espa√ßo.  A Listagem 3 demonstra como fazer isso, refletindo apenas as altera√ß√µes feitas no modelo (o cabe√ßalho da classe permanece inalterado). <br><br><div class="spoiler">  <b class="spoiler_title">Listagem 3. Uma variante eventual da classe FCalculator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> LArc TBL_Calculator[] = { LArc(<span class="hljs-string"><span class="hljs-string">"st"</span></span>, <span class="hljs-string"><span class="hljs-string">"st"</span></span>,<span class="hljs-string"><span class="hljs-string">"^x12"</span></span>, <span class="hljs-string"><span class="hljs-string">"y12"</span></span>), <span class="hljs-comment"><span class="hljs-comment">// LArc("st", "1","x12", "y11"), // // ... }; ... //   bool FCalculator::FCreationOfLinksForVariables() { pNet = GetPointerToNet(); //    if (pNet) { string str = pNet-&gt;strName; //    //  -  pSV = this-&gt;pTAppCore-&gt;pSetVarSetting-&gt;GetAddressVar(const_cast&lt;char*&gt;(str.c_str())); } return true; } ... // int FCalculator::x12() { if (!pNet) return false; if (!pSV) return false; return true; } ... //    step-by-step void FCalculator::y11() { pSV-&gt;bIfStepByStep = true; } //   void FCalculator::y12() { FCreationOfLinksForVariables(); } // ... ///////////////////////////////////////////////////////////////////////////////////////////////////////////////// void FCalculator::digitButtonPressed(int button) { ... pSV-&gt;bIfStopAllTasks = false; //     } void FCalculator::operationButtonPressed(int button) { ... pSV-&gt;bIfStopAllTasks = false; //     } ...</span></span></code> </pre><br><br></div></div><br>  Aqui, primeiramente, √© introduzido um estado [inicial] adicional, no qual a refer√™ncia ao espa√ßo em que a m√°quina est√° localizada e o link para o objeto que determina as propriedades do espa√ßo (incluindo seu modo de opera√ß√£o) s√£o verificados.  Eh forma a a√ß√£o de y12.  Quando os links s√£o configurados, ocorre uma transi√ß√£o para o [antigo] estado inicial do modelo da calculadora com a instala√ß√£o de um modo de opera√ß√£o passo a passo do espa√ßo do aut√¥mato. <br><br>  Al√©m disso, o modelo opera em um modo passo a passo da opera√ß√£o espacial.  O lan√ßamento de uma etapa implementa o c√≥digo inserido nos manipuladores de eventos associados √† entrada do pr√≥ximo caractere (consulte a Listagem 3 para as altera√ß√µes feitas nos m√©todos digitButtonPressed e operationButtonPressed). <br><br><h3>  4. porque </h3><br>  Por que inventar algo, se existe, como se pode supor, um modelo de evento mais avan√ßado de D. Harel.  E como pensar de maneira diferente se foi executada em UML, Stateflow, na biblioteca Qt, etc.  etc.  e n√£o h√° muito p√¢nico sobre suas falhas.  Bem, eles chamaram os eventos de sinais e transformaram a m√°quina ativa em passiva ... E se o modelo, como eles dizem, tamb√©m √© formalmente equivalente √†s m√°quinas cl√°ssicas de Mili / Moore, ent√£o como n√£o acreditar nele?  E assim √©, se todas essas declara√ß√µes forem tomadas apenas com f√© ... <br><br>  Veja o in√≠cio do evento (foi exatamente o que fizemos acima).  Um aut√¥mato estrutural cl√°ssico possui, por exemplo, muitos canais de entrada, cada um dos quais associado a um sinal, e eles podem ser processados ‚Äã‚Äãsimultaneamente / em paralelo.  Mas a UML diz que ‚Äúcada objeto pode processar apenas um evento de cada vez‚Äù e mesmo ‚Äúse dois eventos ocorrerem simultaneamente, o objeto ainda os processar√° um de cada vez‚Äù [10].  Assim, no n√≠vel de defini√ß√£o, sinais e eventos s√£o equivalentes, mas o id√≠lio entra em colapso no processo de implementa√ß√£o de transi√ß√µes de modelo. <br><br>  Considere o exemplo com o qual come√ßo a testar / aprender qualquer idioma ou tecnologia.  √â sobre a implementa√ß√£o de software do modelo de elemento AND-NOT.  No n√≠vel estrutural, corresponde √† ‚Äúcaixa preta‚Äù, que possui dois canais de entrada e uma sa√≠da, e no algor√≠tmico, o aut√¥mato mostrado na Fig.  4) <br><br><img src="https://habrastorage.org/webt/6q/7d/ve/6q7dve1toup6onrda9kkjsqzg2u.jpeg" alt="imagem"><br>  <i>Fig.</i>  <i>4. O modelo de aut√¥mato do elemento AND NOT</i> <br><br>  Como criar um modelo de procedimento regular (consulte a Listagem 4) ou como implementar um aut√¥mato no VKPa (consulte a Listagem 5) √© compreens√≠vel, mas como repetir isso com base no aut√¥mato de evento da biblioteca Qt n√£o √© muito claro devido ao problema de implementar a transi√ß√£o do estado ‚Äú1‚Äù para indicar "0", o que requer a an√°lise simult√¢nea de v√°rios eventos. <br><br>  Listagem 4. Implementa√ß√£o de objeto do modelo de procedimento AND-NOT <br><br><div class="spoiler">  <b class="spoiler_title">Listagem 4. Implementa√ß√£o de objeto do modelo de procedimento AND-NOT</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INE</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: INE() {} ~INE(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bX1, bX2, bY; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bY = !(bX1&amp;&amp;bX2); } };</code> </pre><br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Listagem 5. Implementa√ß√£o de objeto do modelo de aut√¥mato AND-NOT</b> <div class="spoiler_text"><pre> <code class="cpp hljs">LArc T_INE[] = { LArc(<span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"x1x2"</span></span>, <span class="hljs-string"><span class="hljs-string">"y1"</span></span>), LArc(<span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"^x1"</span></span>, <span class="hljs-string"><span class="hljs-string">"y2"</span></span>), LArc(<span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"^x2"</span></span>, <span class="hljs-string"><span class="hljs-string">"y2"</span></span>), }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ine</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LFsaAppl { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Ine(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> strNam = <span class="hljs-string"><span class="hljs-string">"-"</span></span>): LFsaAppl(T_INE, strNam) {} ~Ine(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bX1, bX2; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bX1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bX2; } };</code> </pre><br><br></div></div>  Assim, permita que a implementa√ß√£o do modelo de evento do elemento NAND no √¢mbito das classes de aut√¥matos Qt seja "li√ß√£o de casa" para os Habrovanos.  S√≥ posso citar sua decis√£o no Stateflow como uma ‚Äúcereja no bolo‚Äù.  √â mostrado na fig.  5. O relevo do Stateflow √© usado aqui, o que permite n√£o marcar a transi√ß√£o com um evento: se o nome do evento n√£o for especificado, a transi√ß√£o ocorrer√° quando ocorrer um evento (consulte o r√≥tulo da transi√ß√£o em [13], por exemplo). <br><br><img src="https://habrastorage.org/webt/_9/j7/4e/_9j74efmsk0ema7itfdezvpmfca.jpeg" alt="imagem"><br>  <i>Fig.</i>  <i>5. Um modelo de aut√¥mato de um elemento AND-NOT no Stateflow</i> <br><br>  Assim, m√°quinas de estado s√£o um modelo h√≠brido (ativo-passivo) de uma m√°quina.  √â verdade que n√£o est√° claro como a m√°quina se comportar√° na aus√™ncia de nenhum evento.  Pode-se supor que ‚Äúcongelar√°‚Äù em antecipa√ß√£o a eventos.  E se n√£o forem?  I.e.  no final, ainda √© mais prov√°vel que seja um modelo de m√°quina passiva do que ativa.  Embora apenas na apar√™ncia seja dif√≠cil distinguir deste √∫ltimo. <br><br><h3>  5. Conclus√£o </h3><br>  Em rela√ß√£o aos eventos, podemos dizer que, devido √† atividade, a implementa√ß√£o do modelo cl√°ssico de aut√¥matos parece prefer√≠vel ao modelo de aut√¥matos s√≠ncronos.  Se falamos sobre programa√ß√£o autom√°tica em geral, o pacote de extens√£o Stateflow demonstra como pode ser um tipo de programa√ß√£o completamente diferente.  Mas, infelizmente, at√© agora apenas em perspectiva, porque  os problemas permanecem devido ao modelo computacional Stateflow, que permanece essencialmente um diagrama de blocos.  Parece que, exatamente por essas raz√µes, juntamente com os aut√¥matos, a programa√ß√£o visual no Statefow √© representada pela nota√ß√£o de fluxogramas. <br><br>  Descobrir onde est√° a programa√ß√£o autom√°tica real e onde est√° a sua imita√ß√£o √© um dos nossos principais objetivos.  No artigo anterior [5], resolvemos uma das tarefas b√°sicas propostas - formulamos o conceito de programas de aut√¥matos.  Em seguida, voc√™ precisa lidar com a defini√ß√£o de um modelo de gerenciamento de programa, que deve ser aut√¥mato finito e ser eficaz e conveniente para os programadores. <br><br>  Tendo lidado com os eventos, lan√ßamos as bases para esse trabalho.  Em outros artigos, j√° entenderemos os detalhes do modelo proposto por D. Harel.  Seguindo um pouco √† frente, dizemos que, para ser franco, ela distorceu o entendimento dos aut√¥matos.  Mas, por outro lado, devemos dar o devido devido, revelou problemas que n√£o permitiriam, sem t√™-lo, formar uma programa√ß√£o autom√°tica eficaz dentro da estrutura do modelo cl√°ssico que atrairia programadores. <br><br>  Descobrimos acima que, pelo menos no n√≠vel do evento, os aut√¥matos cl√°ssicos n√£o t√™m problemas.  Vamos entender mais ... Enquanto isso, isso √© apenas o come√ßo.  Estamos esperando muitas coisas interessantes e, note, n√£o indo al√©m da teoria cl√°ssica dos aut√¥matos.  Isso √© crucial se queremos uma programa√ß√£o verdadeiramente automatizada.  Desejamos-lhe sucesso!  :) <br><br><h3>  Refer√™ncias </h3><br>  1. Borovsky A.N.  Qt4.7.  Programa√ß√£o pr√°tica em C ++.  - SPb.: BHV-Petersburg, 2012 .-- 496 p. <br>  2. BUCH G., RAMBO J., JACOBSON I. UML.  Manual do usu√°rio.  Segunda edi√ß√£o.  Akademiya IT: Moscou, 2007 - 493 p. <br>  3. Shalyto A. A. Uma nova palestra sobre programa√ß√£o autom√°tica.  2019, [Recurso eletr√¥nico], <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">Modo de</a> acesso: <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">www.youtube.com/watch?v=PPWTxceMutk&amp;feature=youtu.be</a> , gratuito.  Yaz.  Russo  (data do tratamento em 5 de dezembro de 2019). <br>  4. Fluxo de estado.  <a href="https://www.mathworks.com/products/stateflow.html" rel="nofollow">www.mathworks.com/products/stateflow.html</a> , gratuito.  Yaz.  Ingl√™s  (data de circula√ß√£o 7.01.2020). <br>  5. M√°quina de Turing, como modelo de programas de aut√¥matos.  <a href="https://habr.com/ru/post/481998/">habr.com/en/post/481998</a> , gr√°tis.  Yaz.  Russo  (data de circula√ß√£o 7.01.2020). <br>  6. Melikhov A.N.  Gr√°ficos orientados e m√°quinas de estados finitos.  M.: Nauka, 1971. 416 p. <br>  7. KUDRYAVTSEV VB, Aleshin S.V., PODKOLZIN A.S.  Introdu√ß√£o √† teoria dos aut√¥matos - M .: Science.  Cap.  ed.  F√≠sica-Matem√°tica.  lit., 1985 - 320 p. <br>  8. Tukkel N.I., Shalyto A.A.  Implementa√ß√£o de aut√¥matos na programa√ß√£o de sistemas de eventos.  "Programador", 2002. No. 4.  C.74-80. <br>  9. Polikarpova N., A. Shalyto A. Programa√ß√£o de aut√¥matos.  2nd ed., St. Petersburg.: Peter, 2011 - 176 p. <br>  10. Rambo J., Jacobson A., Butch G. UML: refer√™ncia especial.  - S√£o Petersburgo: Peter, 2002 - 656 p. <br>  11. Goma H. ‚Äã‚ÄãUML.  Projeto de sistemas em tempo real, aplicativos paralelos e distribu√≠dos: por.  do ingl√™s  - M.: DMK Press, 2002. - 2002. - 704 p. <br>  12. SHALYTO A.A.  Tecnologia SWITCH.  Algoritmiza√ß√£o e programa√ß√£o de tarefas de controle l√≥gico.  S√£o Petersburgo: Nauka, 1998, 628 s. <br>  13. Rogachev G.N.  Nota√ß√µes de fluxo de estado.  <a href="http://bourabai.kz/cm/stateflow13.htm" rel="nofollow">bourabai.kz/cm/stateflow13.htm</a> , gratuito.  Yaz.  Russo  (data do recurso 01.10.2020). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt483610/">https://habr.com/ru/post/pt483610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt483598/index.html">Ovos de P√°scoa ainda mais musicais: continuamos a falar de presentes para ouvintes atentos</a></li>
<li><a href="../pt483600/index.html">Liberte seu Android</a></li>
<li><a href="../pt483602/index.html">Confer√™ncia DefCon 27: Nos bastidores da cria√ß√£o de crach√°s eletr√¥nicos Parte 2</a></li>
<li><a href="../pt483604/index.html">Ir√≠dio: recebe e decodifica sinais de constela√ß√£o de sat√©lites em casa</a></li>
<li><a href="../pt483608/index.html">Visualiza√ß√£o dos limites de uma solu√ß√£o classificadora baseada em imagem</a></li>
<li><a href="../pt483612/index.html">Motorista da Tesla √© multado por escovar os dentes enquanto dirige no piloto autom√°tico</a></li>
<li><a href="../pt483614/index.html">M√©todos de combate ao roubo em um clube de rob√≥tica</a></li>
<li><a href="../pt483616/index.html">Projeto Lacmus: Como a vis√£o computacional ajuda a salvar pessoas perdidas</a></li>
<li><a href="../pt483624/index.html">Competi√ß√£o da Yandex.Taxi: an√°lise da pista de back-end do campeonato de programa√ß√£o</a></li>
<li><a href="../pt483626/index.html">Como descrever um trabalho de 100 gitlab em 100 linhas no Jsonnet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>