<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåê üëåüèø üë®üèª‚Äçüè´ C√≥digo de entropia rANS ou como escrever seu pr√≥prio arquivador üë≥üèø üë®üèª‚Äçüíª üßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo pode ser de interesse para quem est√° envolvido em compacta√ß√£o de dados ou deseja gravar seu pr√≥prio arquivador. 

  

 O artigo est√° escri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥digo de entropia rANS ou como escrever seu pr√≥prio arquivador</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/441814/">  Este artigo pode ser de interesse para quem est√° envolvido em compacta√ß√£o de dados ou deseja gravar seu pr√≥prio arquivador. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/jz/w8/xk/jzw8xkq1k6enudm8xozmna6m3ia.jpeg"></a> <br><br>  O artigo est√° escrito principalmente nos materiais do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog</a> , mantidos por Fabian Giesen. <br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  O m√©todo de codifica√ß√£o de entropia rANS ( <b>r</b> ange + ANS) √© o irm√£o do algoritmo FSE, sobre o qual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escrevi anteriormente</a> .  A abreviatura ANS significa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sistemas Num√©ricos Assim√©tricos</a> , e o intervalo de palavras no nome sugere a semelhan√ßa desse m√©todo com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">codifica√ß√£o por intervalo</a> .  O autor de rANS √© <a href="">Yarek Duda</a> . <br><br>  O m√©todo rANS permite alcan√ßar uma compress√£o quase ideal a uma velocidade muito alta.  Neste rANS n√£o √© pior que o FSE, o que n√£o √© surpreendente: ambos os algoritmos s√£o baseados em uma base te√≥rica comum.  No entanto, o algoritmo rANS √© muito mais simples de implementar que o FSE. <br><br>  Primeiro, haver√° uma longa parte "te√≥rica", e depois tentaremos escrever um arquivador simples. <br><br><h2>  Descri√ß√£o do m√©todo </h2><br>  A opera√ß√£o do algoritmo √© determinada pelas seguintes f√≥rmulas simples: <br><br>  <b>Codifica√ß√£o:</b> <code>C(s,x): x := (x / Fs) * M + Bs + (x % Fs)</code> <br>  <b>Decodifica√ß√£o:</b> <code>D(x): s = sym[x % M], x := Fs * (x / M) + (x % M) - Bs</code> <br><br>  Vamos analis√°-los em detalhes. <br><br>  A fun√ß√£o de codifica√ß√£o <b>C (s, x)</b> recebe o caractere <b>s</b> a ser codificado (seja um n√∫mero inteiro) e o estado atual do codificador <b>x</b> (tamb√©m um n√∫mero inteiro). <br><br>  <b>F <sub>s</sub></b> - frequ√™ncia do s√≠mbolo <b>s</b> .  A divis√£o por Fs acima √© um n√∫mero inteiro. <br>  <b>M</b> √© a soma das frequ√™ncias de todos os s√≠mbolos do alfabeto ( <b>M =</b> Œ£ <b>F <sub>s</sub></b> ). <br>  <b>Em <sub>s</sub></b> , o in√≠cio do intervalo correspondente ao caractere codificado (na figura abaixo). <br>  <b>x</b> % <b>Fs</b> √© o restante da divis√£o de <b>x</b> por <b>F <sub>s</sub></b> . <br><br>  O princ√≠pio de opera√ß√£o √© o mesmo da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">codifica√ß√£o aritm√©tica</a> : pegamos o segmento <b>[</b> 0, <b>M)</b> e o dividimos em partes para que cada caractere <b>s</b> corresponda a um intervalo de tamanho igual √† frequ√™ncia do caractere <b>Fs</b> .  A ocorr√™ncia do valor <b>x% M</b> em qualquer intervalo indica a codifica√ß√£o do s√≠mbolo correspondente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6i/vl/ql/6ivlqldcqlkeuwsxu6fcypus39o.png"></div><br>  No in√≠cio da codifica√ß√£o, inicialize <b>x com</b> um valor adequado arbitr√°rio e calcule a fun√ß√£o <b>C (s, x)</b> para todos os caracteres codificados em sequ√™ncia. <br><br>  Cada c√°lculo da fun√ß√£o <b>C (s, x)</b> aumenta o valor de <b>x</b> .  Quando ficar muito grande, voc√™ deve despejar os dados na sa√≠da: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt;= x_max) {   writeToStream(x % b); <span class="hljs-comment"><span class="hljs-comment">//     x /= b; //  x }</span></span></code> </pre> <br>  Esta etapa √© chamada <i>renormaliza√ß√£o</i> .  Depois disso, voc√™ pode continuar a codifica√ß√£o. <br><br>  Acima no c√≥digo, novas constantes apareceram: <b>x_max</b> e <b>b</b> .  Em teoria, os n√∫meros <b>M</b> , <b>be</b> <b>x_max</b> s√£o relacionados por algumas rela√ß√µes, mas na pr√°tica √© mais eficaz usar os seguintes valores se o estado uint32 for usado para o estado <code>x</code> : <br><br>  <b>M</b> = 2 ^ <b>k</b> , onde <b>k</b> &lt;= 16 <br>  <b>b</b> = 2 ^ 16 (metade do tamanho de uint32) <br><br>  A escolha de <b>M</b> = 2 ^ <b>k</b> se deve ao fato de haver divis√£o por <b>M</b> na fun√ß√£o de decodifica√ß√£o, portanto, a divis√£o com o restante pode ser substitu√≠da por opera√ß√µes bit a bit. <br><br>  O valor de <b>k</b> √© selecionado dentre as seguintes considera√ß√µes: quanto maior, maior a precis√£o de <b>Fs</b> e mais eficiente a compress√£o.  Nesse caso, algumas despesas gerais para armazenar a tabela de frequ√™ncias devem ser levadas em considera√ß√£o, portanto nem sempre vale a pena usar os valores m√°ximos de <b>k</b> . <br><br>  O valor de <b>x_max</b> deve ser tal que nenhum estouro ocorra.  Com base na fun√ß√£o de codifica√ß√£o, obtemos <b>x</b> &lt; <b>uint32_max</b> * <b>Fs</b> / <b>M</b> ou uma maneira ligeiramente diferente: <b>x_max</b> &lt;= ( <b>b</b> * <b>L</b> ) * <b>Fs</b> / <b>M</b> , em que <b>L</b> &lt;= <b>uint32_max</b> / <b>b</b> .  No c√≥digo real, a condi√ß√£o assume a forma x / b&gt; = L / M * Fs para evitar excesso nos c√°lculos. <br><br>  O valor <b>b</b> = 2 ^ 16 (metade do tamanho de uint32) √© escolhido de tal maneira que se <b>x</b> excede <b>x_max</b> , uma divis√£o por <b>b √©</b> suficiente para continuar trabalhando.  Como resultado, o <code>while</code> terminar√° ap√≥s a primeira itera√ß√£o, o que significa que pode ser substitu√≠do por um simples <code>if</code> . <br><br>  Como resultado, a fun√ß√£o de codifica√ß√£o assume o seguinte formato: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RansState; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RANS_L = <span class="hljs-number"><span class="hljs-number">1u</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> k = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   constexpr uint32_t RANS_M = 1u &lt;&lt; k; // M = 2^k //   s void RansEnc(RansState&amp; x, uint32_t s, RansOutBuf&amp; out) {   assert(x &gt;= RANS_L); //        uint32 Fs = freq[s]; //   s   uint32 Bs = range_start[s]; //   s   assert(Fs &gt; 0 &amp;&amp; Fs &lt;= RANS_M);     // renormalize   if ((x &gt;&gt; 16) &gt;= (RANS_L &gt;&gt; k) * Fs) { // x / b &gt;=  L / M * Fs       out.put( x &amp; 0xffff );       x &gt;&gt;= 16;   }   x = ((x / Fs) &lt;&lt; k) + Bs + (x % Fs); // C(s,x)     assert(x &gt;= RANS_L); //      }</span></span></code> </pre> <br>  No final da codifica√ß√£o, voc√™ deve salvar o valor de <b>x</b> , pois a decodifica√ß√£o ser√° iniciada a partir dela.  E sim, decodificaremos do fim ao come√ßo, ou seja, do √∫ltimo caractere codificado ao primeiro.  (Em um artigo sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FSE,</a> este ponto √© explicado em detalhes suficientes.) <br><br>  Quero me aprofundar um pouco mais em como a f√≥rmula de codifica√ß√£o funciona. <br><br><pre> <code class="cpp hljs">x := (x / Fs) * M + Bs + (x % Fs)</code> </pre> <br>  Ap√≥s calcular ( <code>x / Fs) * M</code> , a vari√°vel <b>x</b> cont√©m os <b>k</b> bits menos significativos (lembre-se de que <b>M</b> = 2 ^ <b>k</b> ).  A adi√ß√£o de <code>+ Bs + (x % Fs)</code> grava essencialmente nesses bits um determinado valor no <i>intervalo do</i> caractere <b>s</b> , porque <b>Bs</b> √© o in√≠cio do intervalo e (x% Fs) √© o n√∫mero nesse intervalo (o tamanho do intervalo √© Fs).  Assim, ao decodificar, podemos determinar o caractere codificado pelo intervalo em que ele cai (x% M). <br><br>  <b>Decodifica√ß√£o</b> <br><br>  Vamos para a fun√ß√£o de decodifica√ß√£o. <br><br><pre> <code class="cpp hljs">D(x): s = sym[x % M], x := Fs * (x / M) + (x % M) - Bs</code> </pre> <br>  Como j√° entendemos acima, o caractere desejado <b>s</b> √© determinado pelo restante da divis√£o <b>x</b> % <b>M.</b>  Em que intervalo o valor (x% M) caiu, esse caractere foi codificado. <br><br>  Anteriormente, definimos especificamente M = 2 ^ k para simplificar a fun√ß√£o de decodifica√ß√£o.  Acabou assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RansDecode(RansState&amp; x, RansInBuf&amp; in) {   assert(x &gt;= RANS_L); <span class="hljs-comment"><span class="hljs-comment">//       uint32_t x_mod = x &amp; (RANS_M - 1); // = x % M   //  ,    x_mod,     assert(x_mod &lt; dct.size());   uint32_t s = dct[x_mod]; //     uint32 Fs = freq[s]; //   s   uint32 Bs = range_start[s]; //    s   x = (x &gt;&gt; k) * Fs + x_mod - Bs;     // renormalize   if (x &lt; RANS_L) {       x = (x &lt;&lt; 16) | in.read16(); //  16    }     assert(x &gt;= RANS_L); //     return s; }</span></span></code> </pre> <br>  A decodifica√ß√£o come√ßa com o mesmo <b>x</b> que foi obtido no final da codifica√ß√£o.  Para fazer isso, ele deve ser salvo junto com os dados codificados. <br><br>  No final da decodifica√ß√£o, o estado do decodificador <b>x</b> deve ser exatamente o mesmo que a codifica√ß√£o.  Em geral, em cada etapa <b>x</b> deve ser exatamente o mesmo que na etapa de codifica√ß√£o correspondente.  Esse fato ajuda muito na depura√ß√£o. <br><br>  Como voc√™ pode ver, a decodifica√ß√£o funciona mais r√°pido que a codifica√ß√£o, pois n√£o h√° opera√ß√µes de divis√£o. <br><br>  O momento mais dif√≠cil na fun√ß√£o de decodifica√ß√£o √© o m√©todo para determinar em qual intervalo o valor caiu (x% M). <br><br>  O m√©todo mais f√°cil e r√°pido √© usar a tabela <b>sym []</b> , tamanho <b>M.</b>  Nesse caso, obtemos uma tabela do mesmo tamanho que no algoritmo FSE, com a diferen√ßa de que, em rANS, a tabela n√£o est√° ‚Äúmisturada‚Äù, os caracteres est√£o em ordem e essa tabela √© muito mais f√°cil de construir. <br><br>  A principal desvantagem dessa abordagem √© o tamanho da tabela <b>sym</b> , que cresce exponencialmente com o aumento de <b>k</b> . <br><br><h2>  M√©todo de alias </h2><br>  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√©todo alternativo</a> foi inventado para determinar com mais efici√™ncia o acerto em um intervalo.  Este m√©todo permite determinar rapidamente o intervalo desejado usando pequenas tabelas - pelo n√∫mero de caracteres no alfabeto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kv/v0/gu/kvv0guji6nfuxxr6mcjorxxsv9a.png"></div><br>  Uma explica√ß√£o longa e longa pode ser encontrada aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dardos, Dados e Moedas</a> .  Descreverei a ess√™ncia do m√©todo resumidamente: pegamos um peda√ßo do intervalo mais longo e o anexamos ao intervalo mais curto para que o tamanho total seja exatamente <b>M</b> / <b>N</b> (onde <b>N</b> √© o n√∫mero de caracteres no alfabeto).  Acontece que, se voc√™ fizer isso sequencialmente, sempre terminar√° com <b>N</b> pares de tamanho <b>M</b> / <b>N.</b> <br><br>  Naturalmente, <b>M</b> deve ser divis√≠vel por <b>N.</b>  E se lembrarmos que temos <b>M</b> = 2 ^ <b>k</b> , ent√£o o tamanho do alfabeto tamb√©m ser√° uma pot√™ncia de dois.  Isso n√£o √© um problema, pois voc√™ sempre pode suplementar o alfabeto ao tamanho desejado com caracteres n√£o utilizados com uma frequ√™ncia zero. <br><br>  O fato de o intervalo de caracteres ser dividido em v√°rias partes complica um pouco o procedimento de codifica√ß√£o, mas n√£o muito.  Se voc√™ se lembra do FSE, ent√£o os intervalos eram geralmente espalhados por todo o intervalo, como se um mixer louco tivesse trabalhado neles e nada funcionasse =) <br><br>  Determinar o intervalo desejado n√£o √© dif√≠cil: divida <b>x</b> por <b>N</b> e caia em um dos pares.  Em seguida, comparamos o restante da divis√£o de <b>x% N</b> com o limite entre os segmentos em um par e ca√≠mos em um intervalo ou em outro. <br><br><h2>  Tentamos na pr√°tica </h2><br>  Usaremos o c√≥digo do <a href="">exemplo finalizado</a> . <br><br>  Tomamos os dados para compacta√ß√£o do arquivo: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> in_size; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* in_bytes = read_file(<span class="hljs-string"><span class="hljs-string">"book1"</span></span>, &amp;in_size);</code> </pre> <br>  <b>1.</b> Primeiro, voc√™ precisa decidir sobre <b>a estrutura de dados</b> . <br><br>  Usamos a op√ß√£o mais simples: codificaremos um byte usando o alfabeto [0 ... 255]. <br><br>  <b>2.</b> O pr√≥ximo passo √© determinar a <b>frequ√™ncia dos caracteres do</b> alfabeto: <br><br>  (fun√ß√£o <code>stats.count_freqs</code> ) <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; in_size; i++) {   freqs[in_bytes[i]]++; }</code> </pre> <br>  <b>3.</b> Portanto, temos frequ√™ncias de s√≠mbolos, mas agora precisamos <b>normaliz√°-las</b> , isto √©, reduzir (ou aumentar) proporcionalmente para que, no total, obtenha M = 2 ^ k.  Esta n√£o √© uma tarefa t√£o simples como pode parecer, por isso usamos uma fun√ß√£o pronta: <br><br><pre> <code class="plaintext hljs">stats.normalize_freqs(...);</code> </pre> <br>  A prop√≥sito, voc√™ precisa determinar o valor de <b>k</b> .  Como nosso alfabeto consiste em 256 caracteres, <b>k</b> menor que 8 n√£o deve ser utilizado.  Primeiro, use o m√°ximo - 16 e depois tente outros valores. <br><br>  <b>4.</b> Crie uma <b>tabela de alias</b> : <br><br><pre> <code class="cpp hljs">stats.make_alias_table();</code> </pre> <br>  <b>5.</b> Codificamos a <b>partir do final</b> e decodificamos na ordem normal. <br><br><pre> <code class="cpp hljs">RansState rans; <span class="hljs-comment"><span class="hljs-comment">//  rANS,    x RansEncInit(&amp;rans); //    uint8_t* ptr = out_buf + out_max_size; // *end* of output buffer for (size_t i = in_size; i &gt; 0; i--) { // NB: working in reverse!   int s = in_bytes[i - 1];   RansEncPutAlias(&amp;rans, &amp;ptr, &amp;stats, s, prob_bits); } //   .     . RansEncFlush(&amp;rans, &amp;ptr);</span></span></code> </pre> <br>  Al√©m disso, o exemplo por refer√™ncia decodifica dados compactados usando estat√≠sticas prontas.  Na vida real, para decodifica√ß√£o, voc√™ precisa salvar uma tabela de frequ√™ncias (estat√≠sticas) junto com os dados compactados.  No caso mais simples, voc√™ ter√° que gastar N * k bits nele. <br><br>  Como prometido acima, vejamos os resultados da compacta√ß√£o para v√°rios valores de k (no c√≥digo √© <code>prob_bits</code> ), levando em considera√ß√£o o aumento de tamanho devido ao registro da tabela de frequ√™ncias: <br><br>  ( <i>Tamanho</i> <i>original do arquivo</i> book1: 768771) <br>  k = 16: 435059 + 512 = 435571 bytes <br>  k = <b>15</b> : 435078 + 480 = <b>435558</b> bytes <br>  k = 14: 435113 + 448 = 435561 bytes <br>  k = 13: 435239 + 416 = 435655 bytes <br>  k = 12: 435603 + 384 = 435987 bytes <br>  k = 11: 436530 + 352 = 436882 bytes <br>  k = 10: 440895 + 320 = 441215 bytes <br>  k = 9: 453418 + 288 = 453706 bytes <br>  k = 8: 473126 + 256 = 473382 bytes <br><br>  Voc√™ pode ver que quanto maior k, melhor a compacta√ß√£o.  Mas em um certo ponto (em k = 16), a sobrecarga da tabela de frequ√™ncias come√ßa a superar os benef√≠cios de aumentar a precis√£o.  Se voc√™ compactar um arquivo menor, esse efeito aparecer√° em k menor. <br><br>  Voc√™ tamb√©m precisa dizer algumas palavras sobre o truque chamado "rANS intercalados", que tamb√©m √© implementado <a href="">neste exemplo</a> .  A id√©ia √© que, alternadamente, o uso de duas vari√°veis ‚Äã‚Äãde estado independentes fa√ßa melhor uso do paralelismo do processador.  Como resultado, a decodifica√ß√£o √© ainda mais r√°pida. <br><br>  Concluindo, quero observar que o m√©todo de compacta√ß√£o de arquivos selecionado √© muito simples.  Ele n√£o leva em considera√ß√£o os recursos dos dados, e √© por isso que a compacta√ß√£o est√° longe de ser √≥tima.  Se voc√™ observar atentamente a entrada, poder√° descobrir que algumas <i>combina√ß√µes de letras</i> s√£o mais comuns que outras, e outras nem sequer ocorrem.  Usando esse fato, a compacta√ß√£o pode ser significativamente aprimorada.  Mas este √© um t√≥pico para um artigo separado. <br><br><h2>  Posf√°cio </h2><br>  Por que escrever seu pr√≥prio arquivador quando existem muitos utilit√°rios testados pelo tempo?  A resposta √© bem simples: arquivadores adaptados a um formato espec√≠fico s√£o muito melhores. <br><br>  Ao desenvolver jogos na <b>Playrix</b> , geralmente confiamos na necessidade de reduzir o tamanho da compila√ß√£o.  Os jogos est√£o em constante evolu√ß√£o, a quantidade de conte√∫do est√° aumentando e o espa√ßo √© limitado. <br><br>  Mais uma vez <s>,</s> olhando <s>ansiosamente</s> para os recursos, percebemos que alguns arquivos podem ser compactados muito melhor do que o zip, devido √† sua estrutura.  Durante os experimentos, conseguimos reduzir significativamente o tamanho do nosso pr√≥prio formato de anima√ß√£o; tamb√©m existem algumas mudan√ßas na compacta√ß√£o de arquivos gr√°ficos. <br><br>  Ao desenvolver algoritmos de compress√£o, um codificador de entropia universal, como rANS ou FSE, √© uma ferramenta indispens√°vel.  Ele assume completamente a tarefa de escrever caracteres com o menor n√∫mero de bits, permitindo que o desenvolvedor se concentre nos principais detalhes do algoritmo.  E tamb√©m funciona muito r√°pido, tanto na codifica√ß√£o quanto na decodifica√ß√£o. <br><br>  Espero que este artigo ajude voc√™ a conhecer o rANS e come√ßar a us√°-lo em seus projetos. <br><br><h2>  Refer√™ncias </h2><br>  Aqui voc√™ pode ver exemplos de implementa√ß√£o de rANS (com diferentes op√ß√µes de otimiza√ß√£o): <br><br>  Fabian Giesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/rygorous/ryg_rans</a> <br><br>  Voc√™ pode ler detalhes e detalhes interessantes no blog de Fabian (em ingl√™s): <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">notas rANS</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rANS com distribui√ß√µes de probabilidade est√°tica</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rANS na pr√°tica</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441814/">https://habr.com/ru/post/pt441814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441804/index.html">Onde ensinar programa√ß√£o para crian√ßas?</a></li>
<li><a href="../pt441806/index.html">VPN sem VPN ou uma hist√≥ria sobre o uso n√£o convencional de SSH</a></li>
<li><a href="../pt441808/index.html">Convidamos voc√™ no dia 6 de mar√ßo ao ElixirLangMoscow Meetup # 9</a></li>
<li><a href="../pt441810/index.html">Eclipse para microcontroladores (STM32) + Depurador com reconhecimento de tarefas FreeRTOS</a></li>
<li><a href="../pt441812/index.html">Assista ao Meetup ao vivo na Acronis</a></li>
<li><a href="../pt441816/index.html">Autoridades francesas multaram o banco UBS em US $ 4 bilh√µes por ajudar os clientes a evitar impostos</a></li>
<li><a href="../pt441818/index.html">Desempenho equilibrado do site. Parte 2: Otimiza√ß√£o t√©cnica</a></li>
<li><a href="../pt441820/index.html">Devo√ß√£o ao terror removida do Steam - a causa novamente √© Winnie the Pooh, Xi Jinping e a raiva da China por conota√ß√µes pol√≠ticas</a></li>
<li><a href="../pt441824/index.html">Gerenciamento de inc√™ndio como parte do trabalho do l√≠der</a></li>
<li><a href="../pt441826/index.html">O que est√° acontecendo no mercado de streaming de √°udio: discutindo o desenvolvimento de plataformas de streaming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>