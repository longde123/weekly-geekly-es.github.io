<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§õüèº üå∞ üë©üèø‚Äçü§ù‚Äçüë®üèΩ Crea un sombreador de agua de dibujos animados para la web. Parte 1 ‚öõÔ∏è üíª üôèüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En mi tutorial "Creaci√≥n de sombreadores", observ√© principalmente los sombreadores de fragmentos, que son suficientes para implementar cualquier efect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crea un sombreador de agua de dibujos animados para la web. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416953/"> En mi tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Creaci√≥n de sombreadores", observ√©</a> principalmente los sombreadores de fragmentos, que son suficientes para implementar cualquier efecto 2D y ejemplos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">ShaderToy</a> .  Pero hay toda una categor√≠a de t√©cnicas que requieren el uso de sombreadores de v√©rtices.  En este tutorial, hablar√© sobre la creaci√≥n de un sombreador de agua estilizado de dibujos animados y le presentar√© los sombreadores de v√©rtices.  Tambi√©n hablar√© sobre el b√∫fer de profundidad y c√≥mo usarlo para obtener m√°s informaci√≥n sobre la escena y crear l√≠neas de espuma marina. <br><br>  As√≠ se ver√° el efecto final.  Una demostraci√≥n interactiva se puede ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">aqu√≠</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/58d/814/c3858d814aa8ca99c2c0c58535503482.jpg"></div><br>  Este efecto consta de los siguientes elementos: <br><br><ol><li>  Una malla de agua transl√∫cida con pol√≠gonos subdivididos y v√©rtices desplazados para crear olas. </li><li>  L√≠neas de agua est√°ticas en la superficie. </li><li>  Flotabilidad simulada del barco. </li><li>  L√≠neas din√°micas de espuma alrededor de los l√≠mites de los objetos en el agua. </li><li>  Postprocesamiento para crear distorsi√≥n de todo bajo el agua. </li></ol><br>  En este sentido, me gusta el hecho de que toca muchos conceptos diferentes de gr√°ficos por computadora, por lo que nos permitir√° utilizar las ideas de los tutoriales anteriores, as√≠ como desarrollar t√©cnicas que pueden aplicarse en nuevos efectos. <br><a name="habracut"></a><br>  En este tutorial, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">usar√© PlayCanvas</a> , simplemente porque es un conveniente IDE web gratuito, pero todo se puede aplicar a cualquier otro entorno WebGL sin ning√∫n problema.  Al final del art√≠culo, se presentar√° la versi√≥n del c√≥digo fuente para Three.js.  Asumiremos que ya conoce bien los sombreadores de fragmentos y la interfaz de PlayCanvas.  Puede actualizar su conocimiento sobre sombreadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y familiarizarse con PlayCanvas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h2>  Entorno </h2><br>  El prop√≥sito de esta secci√≥n es configurar nuestro proyecto PlayCanvas e insertar en √©l varios objetos ambientales que influir√°n en el agua. <br><br>  Si no tiene una cuenta de PlayCanvas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">reg√≠strela</a> y cree un nuevo <strong>proyecto en blanco</strong> .  Por defecto, debe tener un par de objetos en la escena, una c√°mara y una fuente de luz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f57/00e/57f/f5700e57f7434006e48831c30378d0df.png"></div><br><h3>  Insertar modelos </h3><br>  Un gran recurso para encontrar modelos 3D para la web es el proyecto Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">Poly</a> .  Tom√© el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">modelo de barco</a> desde all√≠.  Despu√©s de descargar y descomprimir el archivo, encontrar√° archivos <code>.obj</code> y <code>.png</code> en √©l. <br><br><ol><li>  Arrastre ambos archivos a la ventana Activos del proyecto PlayCanvas. </li><li>  Seleccione el material generado autom√°ticamente y seleccione el archivo <code>.png</code> como su mapa difuso. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b60/499/7cc/b604997ccaad7c5d0d97a81f6da3be98.png"></div><br>  Ahora puede arrastrar <strong>Tugboat.json</strong> a la escena y eliminar los objetos Box y Plane.  Si el barco parece demasiado peque√±o, puede aumentar su escala (configuro el valor en 50). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4c/307/250/c4c30725001beeacf4a2149735f95a1b.png"></div><br>  Del mismo modo, puede agregar cualquier otro modelo a la escena. <br><br><h3>  C√°mara en √≥rbita </h3><br>  Para configurar la c√°mara volando en √≥rbita, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">copiaremos</a> el script de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">este ejemplo de PlayCanvas</a> .  Siga el enlace y haga clic en <strong>Editor</strong> para abrir el proyecto. <br><br><ol><li>  Copie el contenido de <code>mouse-input.js</code> y <code>orbit-camera.js</code> de este proyecto tutorial en archivos con los mismos nombres de su proyecto. </li><li>  Agregue un componente de <strong>secuencia de comandos</strong> a la c√°mara. </li><li>  Adjunte dos guiones a la c√°mara. </li></ol><br><blockquote>  <em>Sugerencia: para organizar el proyecto, puede crear carpetas en la ventana Activos.</em>  <em>Puse estos dos guiones de c√°mara en la carpeta Guiones / C√°mara /, mi modelo en Modelos / y el material en la carpeta Materiales /.</em> </blockquote><br>  Ahora, cuando comienzas el juego (el bot√≥n de inicio en la parte superior derecha de la ventana de la escena) deber√≠as ver un bote que puedes inspeccionar con una c√°mara movi√©ndolo en √≥rbita con el mouse. <br><br><h2>  Divisi√≥n de pol√≠gonos de superficie de agua </h2><br>  El prop√≥sito de esta secci√≥n es crear una malla subdividida que se utilizar√° como la superficie del agua. <br><br>  Para crear una superficie de agua, adaptamos parte del c√≥digo del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">tutorial de generaci√≥n de relieve</a> .  Cree un nuevo <code>Water.js</code> script <code>Water.js</code> .  Abra este script para editarlo y cree una nueva funci√≥n <code>GeneratePlaneMesh</code> que se ver√° as√≠: <br><br><pre> <code class="javascript hljs">Water.prototype.GeneratePlaneMesh = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 -    ,     if(options === undefined) options = {subdivisions:100, width:10, height:10}; // 2 -  , UV   var positions = []; var uvs = []; var indices = []; var row, col; var normals; for (row = 0; row &lt;= options.subdivisions; row++) { for (col = 0; col &lt;= options.subdivisions; col++) { var position = new pc.Vec3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0)); positions.push(position.x, position.y, position.z); uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions); } } for (row = 0; row &lt; options.subdivisions; row++) { for (col = 0; col &lt; options.subdivisions; col++) { indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + (row + 1) * (options.subdivisions + 1)); } } //   normals = pc.calculateNormals(positions, indices); //    var node = new pc.GraphNode(); var material = new pc.StandardMaterial(); //   var mesh = pc.createMesh(this.app.graphicsDevice, positions, { normals: normals, uvs: uvs, indices: indices }); var meshInstance = new pc.MeshInstance(node, mesh, material); //      var model = new pc.Model(); model.graph = node; model.meshInstances.push(meshInstance); this.entity.addComponent('model'); this.entity.model.model = model; this.entity.model.castShadows = false; //   ,       };</span></span></code> </pre> <br>  Ahora podemos llamarlo en la funci√≥n de <code>initialize</code> : <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GeneratePlaneMesh({<span class="hljs-attr"><span class="hljs-attr">subdivisions</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}); };</code> </pre> <br>  Ahora, cuando comienzas el juego, solo deber√≠as ver una superficie plana.  Pero esto no es solo una superficie plana, es una malla formada por miles de picos.  Como ejercicio, intente verificar esto usted mismo (esta es una buena raz√≥n para estudiar el c√≥digo que acaba de copiar). <br><br><blockquote>  <em>Problema 1: cambie la coordenada Y de cada v√©rtice por un valor aleatorio para que el plano se vea como la figura a continuaci√≥n.</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/397/111/391/397111391bbb4e1cafd0e658005ed1cc.jpg"></div><br><h2>  Las olas </h2><br>  El prop√≥sito de esta secci√≥n es designar la superficie del agua de su propio material y crear ondas animadas. <br><br>  Para obtener los efectos que necesitamos, debe configurar su propio material.  La mayor√≠a de los motores 3D tienen un conjunto de sombreadores predefinidos para renderizar objetos y una forma de redefinirlos.  Aqu√≠ hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">buen enlace</a> sobre c√≥mo hacer esto en PlayCanvas. <br><br><h3>  Accesorio de sombreador </h3><br>  <code>CreateWaterMaterial</code> una nueva funci√≥n <code>CreateWaterMaterial</code> que <code>CreateWaterMaterial</code> nuevo material con un sombreador modificado y lo devuelva: <br><br><pre> <code class="javascript hljs">Water.prototype.CreateWaterMaterial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     var material = new pc.Material(); //    ,       material.name = "DynamicWater_Material"; //    //        . var gd = this.app.graphicsDevice; var fragmentShader = "precision " + gd.precision + " float;\n"; fragmentShader = fragmentShader + this.fs.resource; var vertexShader = this.vs.resource; //       . var shaderDefinition = { attributes: { aPosition: pc.gfx.SEMANTIC_POSITION, aUv0: pc.SEMANTIC_TEXCOORD0, }, vshader: vertexShader, fshader: fragmentShader }; //     this.shader = new pc.Shader(gd, shaderDefinition); //      material.setShader(this.shader); return material; };</span></span></code> </pre> <br>  Esta funci√≥n toma el c√≥digo de sombreador de v√©rtices y fragmentos de los atributos del script.  As√≠ que definamos en la parte superior del archivo (despu√©s de la l√≠nea <code>pc.createScript</code> ): <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'vs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Vertex Shader'</span></span> }); Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Fragment Shader'</span></span> });</code> </pre> <br>  Ahora podemos crear estos archivos de sombreador y adjuntarlos a nuestro script.  Regrese al editor y cree dos archivos de sombreador: <strong>Water.frag</strong> y <strong>Water.vert</strong> .  Adjunte estos sombreadores al script como se muestra en la figura a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/fa4/d8a/0a2fa4d8a998e8abe1fc63da301f0ad9.png"></div><br>  Si los nuevos atributos no se muestran en el editor, haga clic en el bot√≥n <strong>Analizar</strong> para actualizar el script. <br><br>  Ahora pegue este sombreador b√°sico en <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); gl_FragColor = color; }</code> </pre> <br>  Y este est√° en <strong>Water.vert</strong> : <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Finalmente, regrese a <strong>Water.js</strong> para usar nuestro nuevo material en lugar del material est√°ndar.  Es decir, en lugar de: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.StandardMaterial();</code> </pre> <br>  insertar: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateWaterMaterial();</code> </pre> <br>  Ahora, despu√©s de comenzar el juego, el avi√≥n deber√≠a ser azul. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/797/8ff/e797978ff286ff2f15b3b8465debf767.png"></div><br><h3>  Reinicio en caliente </h3><br>  Por ahora, acabamos de configurar espacios en blanco para nuestro nuevo material.  Antes de comenzar a escribir efectos reales, quiero configurar la recarga autom√°tica de c√≥digo. <br><br>  Habiendo comentado la funci√≥n de <code>swap</code> en cualquier archivo de script (por ejemplo, en Water.js), habilitaremos la recarga en caliente.  M√°s adelante veremos c√≥mo usar esto para mantener el estado incluso al actualizar el c√≥digo en tiempo real.  Pero por ahora, solo queremos volver a aplicar los sombreadores despu√©s de realizar los cambios.  Antes de ejecutar en WebGL, se compilan los sombreadores, por lo que para hacer esto necesitamos volver a crear nuestro material. <br><br>  Verificaremos si el contenido de nuestro c√≥digo de sombreador ha cambiado y, de ser as√≠, crearemos el material nuevamente.  Primero, guarde los sombreadores actuales en <strong>initialize</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize,       Water.prototype.initialize = function() { this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Y en la <strong>actualizaci√≥n</strong> verificamos si se han producido cambios: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  update,     Water.prototype.update = function(dt) { if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ //   ,      var newMaterial = this.CreateWaterMaterial(); //     var model = this.entity.model.model; model.meshInstances[0].material = newMaterial; //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; } };</span></span></code> </pre> <br>  Ahora, para asegurarte de que esto funciona, inicia el juego y cambia el color del avi√≥n en <strong>Water.frag</strong> a un azul m√°s agradable.  Despu√©s de guardar el archivo, debe actualizarse incluso sin reiniciar y reiniciar.  Aqu√≠ est√° el color que eleg√≠: <br><br><pre> <code class="javascript hljs">vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>);</code> </pre> <br><h4>  Sombreadores de v√©rtices </h4><br>  Para crear ondas, debemos mover cada v√©rtice de nuestra malla en cada cuadro.  Parece que ser√° muy ineficiente, pero cada v√©rtice de cada modelo ya est√° transformado en cada cuadro renderizado.  Esto es lo que hace el sombreador de v√©rtices. <br><br>  Si percibimos un sombreador de fragmentos como una funci√≥n que se ejecuta para cada p√≠xel, obtiene su posici√≥n y devuelve el color, entonces un <em>sombreador de v√©rtice es una funci√≥n</em> que se ejecuta para cada p√≠xel, obtiene su posici√≥n y devuelve <em>su posici√≥n</em> . <br><br>  Un sombreador de v√©rtices por defecto obtiene una <em>posici√≥n en el mundo</em> modelo y devuelve su <em>posici√≥n en la pantalla</em> .  Nuestra escena 3D se establece en coordenadas x, y y z, pero el monitor es un plano plano bidimensional, por lo que proyectamos un mundo 3D en una pantalla 2D.  Las matrices del tipo, proyecci√≥n y modelo est√°n involucradas en dicha proyecci√≥n, por lo tanto, no lo consideraremos en este tutorial.  Pero si desea comprender qu√© sucede exactamente en cada etapa, aqu√≠ hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">muy buena gu√≠a</a> . <br><br>  Es decir, esta l√≠nea: <br><br><pre> <code class="javascript hljs">gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  recibe <code>aPosition</code> como una posici√≥n en el mundo 3D de un v√©rtice particular y lo convierte en <code>gl_Position</code> , es decir, en la posici√≥n final en la pantalla 2D.  El prefijo "a" en aPosition indica que este valor es un <em>atributo</em> .  No olvide que la variable <em>uniforme</em> es un valor que podemos definir en la CPU y pasarlo al sombreador.  Mantiene el mismo valor para todos los p√≠xeles / v√©rtices.  Por otro lado, el valor del atributo se obtiene de la <em>matriz de</em> CPU especificada.  Se llama un sombreador de v√©rtices para cada valor de esta matriz de atributos. <br><br>  Puede ver que estos atributos est√°n configurados en la definici√≥n de sombreador que configuramos en Water.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderDefinition = { <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">aPosition</span></span>: pc.gfx.SEMANTIC_POSITION, <span class="hljs-attr"><span class="hljs-attr">aUv0</span></span>: pc.SEMANTIC_TEXCOORD0, }, <span class="hljs-attr"><span class="hljs-attr">vshader</span></span>: vertexShader, <span class="hljs-attr"><span class="hljs-attr">fshader</span></span>: fragmentShader };</code> </pre> <br>  PlayCanvas se encarga de configurar y transmitir una matriz de posiciones de v√©rtice para una <code>aPosition</code> al pasar esta enumeraci√≥n, pero en el caso general, podemos pasar cualquier matriz de datos al sombreador de v√©rtices. <br><br><h3>  Movimiento de v√©rtices </h3><br>  Supongamos que queremos comprimir todo el plano multiplicando todos los valores de <code>x</code> por 0.5.  ¬øNecesitamos cambiar <code>aPosition</code> o <code>gl_Position</code> ? <br><br>  Probemos una <code>aPosition</code> primero.  No podemos cambiar el atributo directamente, pero podemos crear una copia: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; pos.x *= <span class="hljs-number"><span class="hljs-number">0.5</span></span>; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Ahora el avi√≥n deber√≠a verse m√°s como un rect√°ngulo.  Y no hay nada extra√±o al respecto.  Pero, ¬øqu√© sucede si intentamos cambiar <code>gl_Position</code> ? <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; <span class="hljs-comment"><span class="hljs-comment">//pos.x *= 0.5; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, 1.0); gl_Position.x *= 0.5; }</span></span></code> </pre> <br>  Hasta que empiece a mover la c√°mara, puede verse igual.  Cambiamos las coordenadas del espacio de la pantalla, es decir, la imagen depender√° de <em>c√≥mo la veamos</em> . <br><br>  Entonces podemos mover los v√©rtices y, al mismo tiempo, es importante distinguir entre el trabajo en el mundo y los espacios de la pantalla. <br><br><blockquote>  <em>Tarea 2: ¬øpuedes mover toda la superficie del plano varias unidades hacia arriba (a lo largo del eje Y) en el sombreador de v√©rtices sin distorsionar su forma?</em> </blockquote><br><blockquote>  <em>Tarea 3: Dije que gl_Position es bidimensional, pero gl_Position.z tambi√©n existe.</em>  <em>¬øPuede verificar si este valor afecta algo y, de ser as√≠, para qu√© se utiliza?</em> </blockquote><br><h3>  Agregar tiempo </h3><br>  Lo √∫ltimo que necesitamos antes de comenzar a crear ondas en movimiento es una variable uniforme que se pueda usar como tiempo.  Declarar uniforme en el sombreador de v√©rtices: <br><br><pre> <code class="javascript hljs">uniform float uTime;</code> </pre> <br>  Ahora, para pasarlo al sombreador, <strong>regresemos</strong> a <strong>Water.js</strong> y definamos la variable de tiempo en initialize: <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/////     this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Ahora, para transferir la variable al sombreador, usamos <code>material.setParameter</code> .  Primero, establecemos el valor inicial al final de la funci√≥n <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     this.shader = new pc.Shader(gd, shaderDefinition); //////////////   material.setParameter('uTime',this.time); this.material = material; //      //////////////// //      material.setShader(this.shader); return material;</span></span></code> </pre> <br>  Ahora, en la funci√≥n de <code>update</code> , podemos realizar un incremento de tiempo y acceder al material usando el enlace creado para esto: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.material.setParameter(<span class="hljs-string"><span class="hljs-string">'uTime'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time);</code> </pre> <br>  Finalmente, en la funci√≥n de intercambio, copiamos el valor anterior para que, incluso despu√©s de cambiar el c√≥digo, contin√∫e aumentando sin restablecer a 0. <br><br><pre> <code class="javascript hljs">Water.prototype.swap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">old</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = old.time; };</code> </pre> <br>  Ahora todo est√° listo.  Ejecute el juego para asegurarse de que no haya errores.  Ahora <code>Water.vert</code> nuestro avi√≥n usando la funci√≥n de tiempo en <code>Water.vert</code> : <br><br><pre> <code class="javascript hljs">pos.y += cos(uTime)</code> </pre> <br>  ¬°Y nuestro avi√≥n deber√≠a comenzar a moverse hacia arriba y hacia abajo!  Como ahora tenemos una funci√≥n de intercambio, tambi√©n podemos actualizar Water.js sin tener que reiniciar.  Para asegurarse de que esto funciona, intente cambiar el incremento de tiempo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/9fe/64a/ae99fe64ab5d40e47e3760ac1dae1dd7.gif"></div><br><blockquote>  <em>Tarea 4: ¬øpuedes mover los v√©rtices para que se vean como las ondas en la figura a continuaci√≥n?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1be/c55/056/1bec55056dc955769178773c2d58fe7c.gif"></div><br>  D√©jame decirte que examin√© en detalle el tema de varias formas de crear olas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">aqu√≠</a> .  El art√≠culo est√° relacionado con 2D, pero los c√°lculos matem√°ticos son aplicables a nuestro caso.  Si solo quiere ver la soluci√≥n, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">aqu√≠ est√° la esencia</a> . <br><br><h2>  Translucidez </h2><br>  El prop√≥sito de esta secci√≥n es crear una superficie de agua transl√∫cida. <br><br>  Puede notar que el color devuelto a Water.frag tiene un valor de canal alfa de 0.5, pero la superficie a√∫n permanece opaca.  En muchos casos, la transparencia a√∫n se convierte en un problema no resuelto en los gr√°ficos por computadora.  Una forma econ√≥mica de resolverlo es usar la mezcla. <br><br>  Por lo general, antes de dibujar un p√≠xel, verifica el valor en el <em>b√∫fer de profundidad</em> y lo compara con su propio valor de profundidad (su posici√≥n en el eje Z) para determinar si se vuelve a dibujar el p√≠xel actual de la pantalla.  Esto es lo que le permite renderizar la escena correctamente sin tener que ordenar los objetos de atr√°s hacia adelante. <br><br>  Al mezclar, en lugar de simplemente rechazar el p√≠xel o sobrescribir, podemos combinar el color del p√≠xel ya representado (objetivo) con el p√≠xel que vamos a dibujar (la fuente).  Puede encontrar una lista de todas las funciones de mezcla disponibles en WebGL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">aqu√≠</a> . <br><br>  Para que el canal alfa funcione de acuerdo con nuestras expectativas, queremos que el color combinado del resultado sea una fuente multiplicada por un canal alfa m√°s un p√≠xel de destino multiplicado por uno menos alfa.  En otras palabras, si alfa = 0.4, entonces el color final debe tener un valor: <br><br><pre> <code class="javascript hljs">finalColor = source * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + destination * <span class="hljs-number"><span class="hljs-number">0.6</span></span>;</code> </pre> <br>  En PlayCanvas, esta es la operaci√≥n que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">realiza pc.BLEND_NORMAL</a> . <br><br>  Para habilitarlo, simplemente configure la propiedad del material dentro de <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs">material.blendType = pc.BLEND_NORMAL;</code> </pre> <br>  Si ahora comienzas el juego, ¬°el agua se volver√° transl√∫cida!  Sin embargo, todav√≠a es imperfecto.  El problema surge cuando la superficie transl√∫cida se superpone sobre s√≠ misma, como se muestra a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/6b0/653/6df6b0653c6a86a4cd5d8b0500e22f04.png"></div><br>  Podemos eliminarlo usando <em>alfa para cobertura</em> , una t√©cnica de muestreo m√∫ltiple para transparencia, en lugar de combinar: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//material.blendType = pc.BLEND_NORMAL; material.alphaToCoverage = true;</span></span></code> </pre> <br>  Pero solo est√° disponible en WebGL 2. En el resto del tutorial, en aras de la simplicidad, utilizar√© la mezcla. <br><br><h2>  Para resumir </h2><br>  Configuramos el entorno y creamos una superficie transl√∫cida del agua con ondas animadas del sombreador de v√©rtices.  En la segunda parte del tutorial, consideraremos la flotabilidad de los objetos, agregaremos l√≠neas a la superficie del agua y crearemos l√≠neas de espuma a lo largo de los l√≠mites de los objetos que se cruzan con la superficie. <br><br>  En la tercera (√∫ltima) parte, consideraremos la aplicaci√≥n del efecto de posprocesamiento de las distorsiones subacu√°ticas y consideraremos ideas para una mejora adicional. <br><br><h2>  C√≥digo fuente </h2><br>  El proyecto PlayCanvas terminado se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">aqu√≠</a> .  Nuestro repositorio tambi√©n tiene un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external">puerto de proyecto en Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416953/">https://habr.com/ru/post/es416953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416943/index.html">Materiales √∫tiles para dise√±ar interfaces de voz.</a></li>
<li><a href="../es416945/index.html">Como hicimos BelAZ. Parte 1 - Hierro</a></li>
<li><a href="../es416947/index.html">Juega antes de los Juegos Ol√≠mpicos: los deportes electr√≥nicos se vuelven oficiales</a></li>
<li><a href="../es416949/index.html">La actualizaci√≥n a gran escala del Sr. Steven para instalar una red de caza cuatro veces mayor se ha completado</a></li>
<li><a href="../es416951/index.html">Clusters de Kubernetes en servicio VPC</a></li>
<li><a href="../es416955/index.html">Peque√±os trucos con Elasticsearch</a></li>
<li><a href="../es416957/index.html">¬øQu√© m√°quina l√°ser comprar? Revisi√≥n confiable de la m√°quina l√°ser Raylogic 11G</a></li>
<li><a href="../es416959/index.html">Apple presenta la nueva funci√≥n antirrobo de iOS</a></li>
<li><a href="../es416961/index.html">Resoluci√≥n autom√°tica de conflictos mediante transformaciones operativas.</a></li>
<li><a href="../es416963/index.html">Como hicimos BelAZ. Parte 2 - Pruebas de laboratorio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>