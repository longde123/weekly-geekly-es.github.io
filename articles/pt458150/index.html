<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ê üíª üçò Microoptimiza√ß√£o de olho m√°gico em compiladores C ++ e C # üèµÔ∏è üö≥ ü§≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na escola, quando resolvemos equa√ß√µes ou consideramos f√≥rmulas, tentamos reduzi-las primeiro v√°rias vezes, por exemplo, Z = X - (Y + X) reduzido para ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microoptimiza√ß√£o de olho m√°gico em compiladores C ++ e C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458150/"><p> Na escola, quando resolvemos equa√ß√µes ou consideramos f√≥rmulas, tentamos reduzi-las primeiro v√°rias vezes, por exemplo, <code>Z = X - (Y + X)</code> reduzido para <code>Z = -Y</code> .  Nos compiladores modernos, esse √© um subconjunto das chamadas otimiza√ß√µes de olho m√°gico, nas quais, grosso modo, um conjunto de padr√µes reduzimos as express√µes, substitu√≠mos as instru√ß√µes pelas mais r√°pidas para um processador em particular, etc.  Neste artigo, compilei uma cole√ß√£o dessas otimiza√ß√µes encontradas nas fontes LLVM, GCC e .NET Core (CoreCLR). </p><br><p>  Vamos come√ßar com exemplos simples: </p><br><pre> <code class="cpp hljs"> X * <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X -X * -Y =&gt; X * Y -(X - Y) =&gt; Y - XX * Z - Y * Z =&gt; Z * (X - Y)</code> </pre> <br><p>  verifique o √∫ltimo exemplo em C ++ e em C #: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * z - y * z; <span class="hljs-comment"><span class="hljs-comment">// =&gt; z * (x - y) }</span></span></code> </pre> <br><p>  e observe o assembler de Clang (LLVM), GCC, MSVC e .NET Core: <br><img src="https://habrastorage.org/webt/up/xl/zo/upxlzopwz17gkq290kycswi4_qq.png"></p><a name="habracut"></a><br><p>  Todos os tr√™s compiladores C ++ (GCC, Clang e MSVC) reduziram uma multiplica√ß√£o (vemos apenas uma instru√ß√£o <code>imul</code> ).  O C # n√£o fez isso com o RyuJIT, mas n√£o se apresse em censur√°-lo por isso, √© s√≥ que essa classe de otimiza√ß√µes est√° dispon√≠vel em uma composi√ß√£o limitada l√°.  Para que voc√™ entenda, a implementa√ß√£o de toda a transforma√ß√£o InstCombine no LLVM leva mais de 30k linhas de c√≥digo (+ 20k linhas no DAGCombiner.cpp); al√©m disso, essa transforma√ß√£o geralmente causa uma compila√ß√£o longa.  <a href="">A prop√≥sito, o site</a> respons√°vel por essa otimiza√ß√£o est√° l√°.  O GCC possui uma DSL especial que descreve o canal de otimiza√ß√£o ( <a href="">aqui est√° um trecho</a> ). </p><br><p>  Decidi, pelo bem do artigo, tentar implementar essa otimiza√ß√£o no C # JIT (segure minha cerveja): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/692/14c/c65/69214cc65fd41d79f8d53caf4021c9af.png" alt="imagem"></p><br><p>  O commit completo pode ser visto aqui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">EgorBo / coreclr</a> .  Vamos verificar minha melhoria agora (no Visual Studio 2019 + Disasmo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/e77/de9/e53e77de91d647f78f021d10fb57a8c9.png" alt="imagem"></p><br><p>  Isso funciona!  <code>lea</code> + <code>imul</code> vez de <code>imul</code> , <code>imul</code> e <code>add</code> . </p><br><p>  Vamos voltar ao C ++ e acompanhar essa otimiza√ß√£o no Clang.  Para fazer isso, solicite √† clang que nos forne√ßa o IR LLVM inicial via <code>-emit-llvm -g0</code> e, em seguida, entregue-o ao LLVM para o otimizador, usando os par√¢metros <code>-O2 -print-before-all -print-after-all</code> , a fim de capturar o momento exato da transforma√ß√£o remove a multiplica√ß√£o do conjunto <code>-O2</code> (tudo isso pode ser visto no maravilhoso recurso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">godbolt.org</a> ): </p><br><pre> <code class="plaintext hljs">; *** IR Dump Before Combine redundant instructions *** define dso_local i32 @_Z5Case1iii(i32, i32, i32) { %4 = mul nsw i32 %0, %2 %5 = mul nsw i32 %1, %2 %6 = sub nsw i32 %4, %5 ret i32 %6 } ; *** IR Dump After Combine redundant instructions *** define dso_local i32 @_Z5Case1iii(i32, i32, i32) { %4 = sub i32 %0, %1 %5 = mul i32 %4, %2 ret i32 %5 }</code> </pre> <br><p>  Voc√™ tamb√©m pode se divertir no godbolt com as ferramentas LLVM - opt (otimizador) e llc (para compilar o LLVM IR no asm): </p><br><p><img src="https://habrastorage.org/webt/yr/x-/dw/yrx-dw9mx9tqbrp97ts3smndy0i.png"></p><br><p>  Voltar para os exemplos.  Encontrei este exemplo muito bom no GCC. </p><br><pre> <code class="cpp hljs">X == C - X =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> C is odd</code> </pre> <br><p>  E √© verdade: se <code></code> (constante, literal) √© igual, por exemplo, voc√™ pode escrever <code>4 == 8 - 4</code> .  Mas se, em vez de 8, voc√™ escrever um n√∫mero √≠mpar, n√£o poder√° encontrar um <code>X</code> para que a igualdade seja cumprida: </p><br><p><img src="https://habrastorage.org/webt/lt/qn/pq/ltqnpqgmnbcyszoj0dv7nawouk8.png"></p><br><h3 id="ieee754-nanosit-otvetnyy-udar">  IEEE754 contra-ataca </h3><br><p>  Muitas otimiza√ß√µes funcionam para diferentes tipos de dados, por exemplo, <code>byte</code> , <code>int</code> , <code>unsigned</code> , <code>float</code> , <code>double</code> .  Com o √∫ltimo, as coisas n√£o s√£o t√£o simples e as otimiza√ß√µes s√£o tratadas pela especifica√ß√£o IEEE754, que ficar√° louca se voc√™ reduzir <code>A - B - A</code> para <code>-B</code> ou <code>(A * B) * C</code> reorganiz√°-lo para <code>A * (B * C)</code> t. para.  opera√ß√µes n√£o s√£o associativas.  Mas h√° um modo especial nos compiladores modernos que permite negligenciar valores de especifica√ß√£o e limite (NaN, + -Inf, + -0.0) nesses casos e executar otimiza√ß√µes com seguran√ßa - esse √© o Fast Math (minha solicita√ß√£o de PR para adicionar esse modo ao C # pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ) </p><br><p>  Como voc√™ pode ver em <code>-ffast-math</code> n√£o existem mais dois <code>vsubss</code> : <br><img src="https://habrastorage.org/webt/s3/et/-9/s3et-9dc6vml6f-ous27z-1xlhm.png"></p><br><p>  Al√©m das express√µes, os otimizadores tamb√©m levam em considera√ß√£o o malabarismo com fun√ß√µes matem√°ticas de <code>math.h</code> , por exemplo, o produto dos m√≥dulos do n√∫mero X √© igual ao produto do n√∫mero X: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(X) =&gt; X * X</code> </pre> <br><p>  A raiz quadrada √© sempre positiva: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &lt; Y =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Y is negative. <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  Por que calcular a raiz, se √© poss√≠vel, no est√°gio de compila√ß√£o, calcular o quadrado da constante √† direita? </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &gt; C =&gt; X &gt; C * C</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/988/d7e/cbd/988d7ecbd50be253a6b3314760ed3348.png" alt="imagem"></p><br><p>  Mais opera√ß√µes raiz: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) == <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(Y) =&gt; X == Y <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) =&gt; X <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(Y) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X * Y) logN(<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X)) =&gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>*logN(X)</code> </pre> <br><p>  Um pouco mais de matem√°tica escolar: </p><br><pre> <code class="cpp hljs">expN(X) * expN(Y) -&gt; expN(X + Y)</code> </pre> <br><p>  E minha otimiza√ß√£o favorita: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(X) / <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(X) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(X)</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/93a/875/4dd/93a8754dd42b07497f6a164bb60172af.png" alt="imagem"></p><br><p>  Muitas opera√ß√µes chatas e booleanas: </p><br><pre> <code class="cpp hljs">((a ^ b) | a) -&gt; (a | b) (a &amp; ~b) | (a ^ b) --&gt; a ^ b ((a ^ b) | a) -&gt; (a | b) (X &amp; ~Y) |^+ (~X &amp; Y) -&gt; X ^ Y A - (A &amp; B) into ~B &amp; A X &lt;= Y - <span class="hljs-number"><span class="hljs-number">1</span></span> equals to X &lt; Y A &lt; B || A &gt;= B -&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> ...   !</code> </pre> <br><h3 id="nizkourovnevye-optimizacii">  Otimiza√ß√µes de baixo n√≠vel </h3><br><p>  Existe um conjunto de otimiza√ß√£o que, √† primeira vista, n√£o faz sentido com t.z.  matem√°ticos, mas s√£o mais amig√°veis ‚Äã‚Äãao ferro. </p><br><pre> <code class="cpp hljs">X / <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; X * <span class="hljs-number"><span class="hljs-number">0.5</span></span></code> </pre> <br><p>  substitua a divis√£o pela multiplica√ß√£o: </p><br><p><img src="https://habrastorage.org/webt/1n/nz/d2/1nnzd2msn5lxzxlx5t3-hr680cc.png"></p><br><p>  A opera√ß√£o de multiplica√ß√£o de frota geralmente possui melhores caracter√≠sticas de lat√™ncia / taxa de transfer√™ncia do que a divis√£o.  Por exemplo, aqui est√£o as op√ß√µes para Intel Haswell: <br><img src="https://habrastorage.org/webt/i1/ej/l_/i1ejl__p9hfkduty-cn4vq0vzvu.png"></p><br><p>  No modo matem√°tico n√£o r√°pido, ele s√≥ pode ser usado se a constante for uma pot√™ncia de dois. <br>  A prop√≥sito, recentemente tentei adicionar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">essa</a> otimiza√ß√£o em C #.  I.e.  se, por exemplo, voc√™ precisar abrir um arquivo com um modelo 3D e reduzir todas as coordenadas em 10 vezes, * 0,1 lidar√° com isso 20-100% mais r√°pido, o que pode ser significativo. </p><br><p>  A mesma l√≥gica para: </p><br><pre> <code class="cpp hljs">X * <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; X + X</code> </pre> <br><p>  Comparar com zero ( <code>test</code> ) √© melhor do que comparar com unidade ( <code>cmp</code> ) - meu PR para obter detalhes √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotnet / coreclr # 25458</a> : </p><br><pre> <code class="plaintext hljs">X &gt;= 1 =&gt; X &gt; 0 X &lt; 1 =&gt; X &lt;= 0 X &lt;= -1 =&gt; X &gt;= 0 X &gt; -1 =&gt; X &gt;= 0</code> </pre> <br><p>  E como voc√™ gosta disso: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">0.5</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x) <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">0.25</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X)) <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; X * X ; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">mul </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>=&gt; X * X * X ; <span class="hljs-number"><span class="hljs-number">2</span></span> mul</code> </pre> <br><p><img src="https://habrastorage.org/webt/hd/ag/lm/hdaglmbx5f7zfibbpgzdre0swjo.png"></p><br><p>  O que voc√™ acha, quantas opera√ß√µes de multiplica√ß√£o voc√™ precisa para contar <code>mod(X, 4)</code> ou <code>X * X * X * X</code> ? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f5d/118/3c0/f5d1183c005a7f72b6fbabdd18995d7e.png" alt="imagem"></p><br><p>  Dois!  Assim como para o c√°lculo do 3¬∫ grau, e no caso 4, usamos apenas um registro <code>xmm0</code> . </p><br><p>  Muitos processadores oferecem suporte a uma instru√ß√£o especial (FMA), que permite executar a multiplica√ß√£o e adi√ß√£o de cada vez, mantendo a precis√£o durante a multiplica√ß√£o: </p><br><pre> <code class="cpp hljs">X * Y + Z =&gt; fmadd(X, Y, Z)</code> </pre> <br><p><img src="https://habrastorage.org/webt/jf/z5/nh/jfz5nh9fl6-wkx8cfmubntv7o4g.png"></p><br><p>  Mais dois dos meus exemplos favoritos s√£o dobrar alguns algoritmos em uma instru√ß√£o (se o processador suportar): <br><img src="https://habrastorage.org/webt/qj/pv/ya/qjpvya5-s-itzzxubosjpnwonkc.png"></p><br><h3 id="lovushki-dlya-optimizaciy">  Armadilhas de otimiza√ß√£o </h3><br><p>  Acho que todo mundo entende que voc√™ n√£o pode se apressar e reduzir express√µes por tr√™s raz√µes: </p><br><ul><li>  Voc√™ pode quebrar o c√≥digo em alguns valores de limite, excesso, efeitos colaterais ocultos, etc. ... O Bugzilla LLVM cont√©m muitos bugs do InstCombine. </li><li>  Idealmente, as otimiza√ß√µes devem trabalhar juntas em uma sequ√™ncia espec√≠fica. </li><li>  A express√£o ou partes dela que voc√™ deseja reduzir podem ser usadas em outros lugares e sua redu√ß√£o levar√° √† degrada√ß√£o do desempenho. </li></ul><br><p>  Vejamos um exemplo para o √∫ltimo par√°grafo (espionado no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dire√ß√µes futuras para otimizar compiladores</a> ). </p><br><p>  Imagine que temos este c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> na = -a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nb = -b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> na + nb; }</code> </pre> <br><p>  precisamos fazer tr√™s opera√ß√µes: <code>0 - a</code> , <code>0 - b</code> <code>na + nb</code> .  Mas o otimizador para n√≥s reduz isso para dois - <code>return -(a + b);</code>  : </p><br><pre> <code class="plaintext hljs">define dso_local i32 @_Z4Foo1ii(i32, i32) { %3 = add i32 %0, %1 ; a + b %4 = sub i32 0, %3 ; 0 - %3 ret i32 %4 }</code> </pre> <br><p>  Agora imagine que precisamos escrever valores intermedi√°rios <code>na</code> e <code>nb</code> para vari√°veis ‚Äã‚Äãglobais: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> na = -a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nb = -b; x = na; y = nb; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> na + nb; }</code> </pre> <br><p>  O otimizador ainda encontra esse padr√£o e remove as opera√ß√µes desnecess√°rias (do seu ponto de vista) <code>0 - a</code> e <code>0 - b</code> , mas, na verdade, elas s√£o necess√°rias!  n√≥s escrevemos os resultados dessas opera√ß√µes "desnecess√°rias" em vari√°veis ‚Äã‚Äãglobais!  Isso leva a este c√≥digo: </p><br><pre> <code class="cpp hljs">define dso_local i32 @_Z4Foo2ii(i32, i32) { %<span class="hljs-number"><span class="hljs-number">3</span></span> = sub nsw i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - a %<span class="hljs-number"><span class="hljs-number">4</span></span> = sub nsw i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - b store i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, i32* @x, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> store i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>, i32* @y, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = add i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ; a + b %<span class="hljs-number"><span class="hljs-number">6</span></span> = sub i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">5</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - %<span class="hljs-number"><span class="hljs-number">5</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">6</span></span> }</code> </pre> <br><p>  Quatro opera√ß√µes matem√°ticas em vez de tr√™s!  Nosso otimizador falhou e n√£o estava convencido de que as express√µes intermedi√°rias que ele otimizava ainda eram necess√°rias para algu√©m.  Agora, vejamos a sa√≠da do C # RuyJIT, na qual n√£o existe essa otimiza√ß√£o inteligente: </p><br><p><img src="https://habrastorage.org/webt/fs/ar/jf/fsarjfwtbnpmp5hzbidevgo3eui.png"></p><br><p>  Tr√™s opera√ß√µes em vez de quatro - o C # acabou sendo mais r√°pido que o C ++ :-)! </p><br><h3 id="a-nuzhny-li-takie-optimizacii">  Essas otimiza√ß√µes s√£o necess√°rias? </h3><br><p>  Voc√™ nunca sabe como o c√≥digo cuidar√° do compilador alinha tudo o que pode e faz dobragem constante, propaga√ß√£o de c√≥pia, CSE etc.  - uma imagem completamente diferente ser√° aberta para ele.  O LLVM IR e o .NET IL n√£o est√£o vinculados a uma linguagem de programa√ß√£o espec√≠fica, e voc√™ n√£o pode ter certeza de que um PL espec√≠fico / novo possa efetivamente se traduzir em IR.  Bem, por que falar sobre isso, se voc√™ pode testar o desempenho do InstCombine em um aplicativo espec√≠fico ;-).  √â improv√°vel que isso seja uma diferen√ßa impressionante, mas quem sabe. </p><br><h3 id="a-chto-na-schet-c">  E o C #? </h3><br><p>  Como eu disse, as otimiza√ß√µes das express√µes que examinamos provavelmente est√£o ausentes no C #.  Mas quando digo C #, quero dizer que o tempo de execu√ß√£o mais popular √© o CoreCLR e o RyuJIT.  Mas, al√©m do CoreCLR, existem outros tempos de execu√ß√£o, incluindo aqueles que usam o LLVM como back-end: Mono (veja meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tweet</a> ), Unity Burst, IL2CPP (via clang) e LILLC - aqui voc√™ pode comparar com seguran√ßa os resultados C ++ com clang.  Os caras do Unity at√© reescrevem o c√≥digo C ++ interno em C # sem nenhuma perda de desempenho, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">prova</a> ! </p><br><p>  Aqui est√£o alguns canais de otimiza√ß√£o que podem ser encontrados no arquivo <code>morph.cpp</code> no c√≥digo-fonte <code>morph.cpp</code> partir dos coment√°rios (h√° claramente um pouco mais): </p><br><pre> <code class="cpp hljs">*(&amp;X) =&gt; X X % <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> X / <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X X % Y =&gt; X - (X / Y) * Y X ^ <span class="hljs-number"><span class="hljs-number">-1</span></span> =&gt; ~x X &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> X &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> X + <span class="hljs-number"><span class="hljs-number">1</span></span> == C2 =&gt; X == C2 - C1 ((X + C1) + C2) =&gt; (X + (C1 + C2)) ((X + C1) + (Y + C2)) =&gt; ((X + Y) + (C1 + C2))</code> </pre> <br><p>  Um pouco mais pode ser encontrado em <code>lowering.cpp</code> (n√≠vel baixo), mas em geral o RyuJIT obviamente perde aqui para os compiladores C ++.  O RyuJIT tem prioridades ligeiramente diferentes - antes do advento da Tiering Compilation, ele precisava fornecer uma velocidade de compila√ß√£o aceit√°vel, o que faz muito bem ao contr√°rio dos compiladores C ++ (lembre-se da passagem InstCombine de 30 linhas no LLVM e leia a postagem interessante em geral <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">" "Lamenta√ß√µes C ++ modernas"</a> ) e √© muito mais √∫til desenvolver otimiza√ß√µes no campo da desvirtualiza√ß√£o de chamadas, elimina√ß√£o de boxe e aloca√ß√µes (a mesma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aloca√ß√£o de pilha de objetos</a> ) - tudo isso, obviamente, √© muito mais importante do que minimizar a divis√£o do seno pelo cosseno na tangente. </p><br><p>  Talvez com o advento da compila√ß√£o em camadas, com o tempo, muitas novas otimiza√ß√µes n√£o sejam cr√≠ticas para o tempo de compila√ß√£o para a camada 1 ou mesmo a camada 2.  Talvez at√© com sua API de suplemento e DSL - voc√™ acabou de ler este artigo, nele Prathamesh Kulkarni adicionou otimiza√ß√£o de express√£o no GCC em apenas algumas linhas DSL: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">simplify</span></span> (<span class="hljs-name"><span class="hljs-name">plus</span></span> (<span class="hljs-name"><span class="hljs-name">mult</span></span> (<span class="hljs-name"><span class="hljs-name">SIN</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">SIN</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">mult</span></span> (<span class="hljs-name"><span class="hljs-name">COS</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">COS</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag_unsafe_math_optimizations</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span>. { build_one_cst (<span class="hljs-name"><span class="hljs-name">TREE_TYPE</span></span> (@<span class="hljs-number"><span class="hljs-number">0</span></span>))<span class="hljs-comment"><span class="hljs-comment">; }))</span></span></code> </pre> <br><p>  para esta express√£o de um livro de matem√°tica ;-): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span>(X) + <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span>(X) equals to <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h3 id="poleznye-ssylki">  Links √∫teis </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Dire√ß√µes futuras para otimizar compiladores"</a> , Nuno P. Lopes e John Regehr </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Como o LLVM otimiza uma fun√ß√£o"</a> , John Regehr </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"A surpreendente intelig√™ncia dos compiladores modernos"</a> , Daniel Lemire </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Adicionando otimiza√ß√£o do olho m√°gico ao GCC"</a> , Prathamesh Kulkarni </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"1. C ++, C # e Unity"</a> , Lucas Meijer </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lamenta√ß√µes "modernas" em C ++ "</a> , Aras Pranckeviƒçius </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Otimiza√ß√µes de olho m√°gico comprovadamente corretas com vivo"</a> , Nuno P. Lopes, David Menendez, Santosh Nagarakatte e John Regehr </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458150/">https://habr.com/ru/post/pt458150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458126/index.html">A arte sutil da hip√≥tese matem√°tica</a></li>
<li><a href="../pt458130/index.html">‚ÄúA Palavra M√°gica‚Äù para os empregadores - experi√™ncia do IIBS NITU ‚ÄúMISiS‚Äù</a></li>
<li><a href="../pt458134/index.html">A computa√ß√£o qu√¢ntica pode mudar tudo, e a IBM est√° competindo com Microsoft, Intel e Google para assumir o controle.</a></li>
<li><a href="../pt458142/index.html">Desenvolvendo Breakout no Svelte</a></li>
<li><a href="../pt458144/index.html">Not√≠cias da semana: Raspberry Pi 4 √† venda, Internet no exame unificado do estado, Roskomnadzor e servi√ßos de VPN, uma rede neural despeja as pessoas</a></li>
<li><a href="../pt458154/index.html">A incr√≠vel hist√≥ria da origem da porta USB que mudou tudo</a></li>
<li><a href="../pt458156/index.html">Comparando o PostgreSQL com FreeBSD, CentOS, Ubuntu Debian e openSUSE</a></li>
<li><a href="../pt458158/index.html">Procurando por aster√≥ides - projeto Hubble Asteroid Hunter</a></li>
<li><a href="../pt458160/index.html">Bloqueio de prioridade no .NET</a></li>
<li><a href="../pt458164/index.html">Intelig√™ncia artificial - uma pergunta ser√° feita para cada resposta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>