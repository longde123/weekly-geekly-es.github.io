<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîª üöÄ üï¢ Angulaire sans zone.js: performances maximales üçù üèº üë™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les d√©veloppeurs angulaires doivent beaucoup √† zone.js. Elle, par exemple, aide √† atteindre une facilit√© presque magique en travaillant avec Angular. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angulaire sans zone.js: performances maximales</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/476956/">  Les d√©veloppeurs angulaires doivent beaucoup √† zone.js.  Elle, par exemple, aide √† atteindre une facilit√© presque magique en travaillant avec Angular.  En fait, presque toujours, lorsque vous avez juste besoin de changer une propri√©t√©, et que nous la changeons sans penser √† rien, Angular restitue les composants correspondants.  Par cons√©quent, ce que l'utilisateur voit contient toujours les derni√®res informations.  C'est tout simplement g√©nial. <br><br>  Ici, je voudrais explorer certains aspects de la fa√ßon dont l'utilisation du nouveau compilateur Ivy (qui est apparu dans Angular 9) peut grandement faciliter le rejet de l'utilisation de zone.js. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/476956/"><img src="https://habrastorage.org/webt/9m/ql/xa/9mqlxapag9joinziuleg8frnslm.jpeg"></a> <br><br>  En abandonnant cette biblioth√®que, j'ai pu augmenter consid√©rablement les performances de l'application Angular fonctionnant sous une charge importante.  Dans le m√™me temps, j'ai r√©ussi √† impl√©menter les m√©canismes dont j'avais besoin en utilisant les d√©corateurs TypeScript, ce qui a conduit √† tr√®s peu de ressources syst√®me suppl√©mentaires. <br><br>  Veuillez noter que l'approche d'optimisation des applications angulaires, pr√©sent√©e dans cet article, n'est possible que parce que Angular Ivy et AOT sont activ√©s par d√©faut.  Cet article est √©crit √† des fins p√©dagogiques, il ne vise pas √† promouvoir l'approche qui y est pr√©sent√©e au d√©veloppement de projets Angular. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pourquoi pourriez-vous avoir besoin d'utiliser Angular sans zone.js?</font> </h2><br>  Avant de continuer, posons une question importante: ¬´Vaut-il la peine de se d√©barrasser de zone.js, √©tant donn√© que cette biblioth√®que nous aide √† restituer les mod√®les avec peu d'effort?¬ª  Bien s√ªr, cette biblioth√®que est tr√®s utile.  Mais, comme d'habitude, vous devez tout payer. <br><br>  Si votre application a des exigences de performances sp√©cifiques, la d√©sactivation de zone.js peut aider √† r√©pondre √† ces exigences.  Un exemple d'application dans laquelle les performances sont cruciales est un projet dont l'interface est mise √† jour tr√®s souvent.  Dans mon cas, un tel projet s'est av√©r√© √™tre une application de trading en temps r√©el.  Sa partie client re√ßoit en permanence des messages via le protocole WebSocket.  Les donn√©es de ces messages doivent √™tre affich√©es le plus rapidement possible. <br><br><h2>  <font color="#3AC1EF">Supprimer zone.js d'Angular</font> </h2><br>  Angular peut tr√®s facilement fonctionner sans zone.js.  Pour ce faire, vous devez d'abord mettre en commentaire ou supprimer la commande d'importation correspondante, qui se trouve dans le fichier <code>polyfills.ts</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a4/f95/17e/7a4f9517eb4898e51240862c08e4faa9.png"></div><br>  <i><font color="#999999">Commande d'importation zone.js mise en commentaire</font></i> <br><br>  Ensuite - vous devez √©quiper le module racine avec les options suivantes: <br><br><pre> <code class="javascript hljs">platformBrowserDynamic()  .bootstrapModule(AppModule, {    <span class="hljs-attr"><span class="hljs-attr">ngZone</span></span>: <span class="hljs-string"><span class="hljs-string">'noop'</span></span>  })  .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err));</code> </pre> <br><h2>  <font color="#3AC1EF">Lierre angulaire: changements d'auto-d√©tection avec …µdetectChanges et …µmarkDirty</font> </h2><br>  Avant de commencer √† cr√©er un d√©corateur TypeScript, nous devons savoir comment Ivy vous permet d'appeler le processus de d√©tection des modifications de composants, de le rendre sale et de contourner zone.js et DI. <br><br>  Deux fonctions suppl√©mentaires sont maintenant √† notre disposition, export√©es de <code>@angular/core</code> .  Ce sont <code>…µdetectChanges</code> et <code>…µmarkDirty</code> .  Ces deux fonctions sont toujours destin√©es √† un usage interne et sont instables - le symbole <code>…µ</code> est situ√© au d√©but de leurs noms. <br><br>  Voyons comment utiliser ces fonctionnalit√©s. <br><br><h3>  <font color="#3AC1EF">‚ñç Fonction DmarkDirty</font> </h3><br>  Cette fonction vous permet de marquer un composant, le rendant ¬´sale¬ª, c'est-√†-dire ayant besoin d'un nouveau rendu.  Si le composant n'√©tait pas marqu√© ¬´sale¬ª avant son appel, elle pr√©voit de d√©marrer le processus de d√©tection des modifications. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { …µmarkDirty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> markDirty } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    markDirty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç …µDetectChanges, fonction</font> </h3><br>  La documentation interne angulaire indique que, pour des raisons de performances, vous ne devez pas utiliser <code>…µdetectChanges</code> .  Au lieu de cela, il est recommand√© d'utiliser la fonction <code>…µmarkDirty</code> .  La fonction <code>…µdetectChanges</code> invoque de mani√®re synchrone le processus de d√©tection des changements dans un composant et ses sous-composants. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { …µdetectChanges <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> detectChanges } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    detectChanges(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h2>  <font color="#3AC1EF">D√©tecter automatiquement les modifications √† l'aide du d√©corateur TypeScript</font> </h2><br>  Bien que les fonctionnalit√©s fournies par Angular augmentent l'utilisabilit√© du d√©veloppement en laissant le DI tourner, le programmeur peut toujours √™tre frustr√© par le fait qu'il doit importer et appeler ces fonctions lui-m√™me pour d√©marrer le processus de d√©tection des modifications. <br><br>  Afin de simplifier le d√©marrage automatique de la d√©tection des modifications, vous pouvez √©crire un d√©corateur TypeScript, qui r√©soudra ind√©pendamment ce probl√®me.  Bien s√ªr, il y a quelques limites ici, dont nous discuterons ci-dessous, mais dans mon cas, cette approche s'est av√©r√©e √™tre exactement ce dont j'avais besoin. <br><br><h3>  <font color="#3AC1EF">‚ñç Pr√©sentation du d√©corateur @observed</font> </h3><br>  Afin de d√©tecter les changements, en faisant le moins d'efforts possible, nous allons cr√©er un d√©corateur qui peut √™tre appliqu√© de trois fa√ßons.  √Ä savoir, il s'applique aux entit√©s suivantes: <br><br><ul><li>  Aux m√©thodes synchrones. </li><li>  Objets observables. </li><li>  Aux objets ordinaires. </li></ul><br>  Prenons quelques petits exemples.  Dans le fragment de code suivant, nous appliquons le d√©corateur <code>@observed</code> √† l'objet d' <code>state</code> et √† la m√©thode <code>changeTitle</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">''</span></span>;    @observed() state = {        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>    };    @observed()    changeTitle(title: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    }    changeName(name: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.name = name;    } }</code> </pre> <br><ul><li>  Pour v√©rifier les modifications apport√©es √† l'objet d' <code>state</code> , nous utilisons un objet proxy qui intercepte les modifications apport√©es √† l'objet et appelle la proc√©dure de d√©tection des modifications. </li><li>  Nous <code>changeTitle</code> m√©thode <code>changeTitle</code> en appliquant une fonction qui appelle d'abord cette m√©thode, puis d√©marre le processus de d√©tection des modifications. </li></ul><br>  Et voici un exemple avec <code>BehaviorSubject</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{    @observed() show$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);    toggle() {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.next(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.value);    } }</code> </pre> <br>  Dans le cas d'objets observables, l'utilisation d'un d√©corateur semble un peu plus compliqu√©e.  √Ä savoir, vous devez vous abonner √† l'objet observ√© et marquer le composant comme ¬´sale¬ª dans l'abonnement, mais vous devez √©galement effacer l'abonnement.  Pour ce faire, nous r√©affectons <code>ngOnInit</code> et <code>ngOnDestroy</code> pour vous abonner et le nettoyer plus tard. <br><br><h3>  <font color="#3AC1EF">‚ñçCr√©ation d'un d√©corateur</font> </h3><br>  Voici la signature d√©coratrice <code>observed</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  </span></span></span><span class="hljs-function">) </span></span>{} }</code> </pre> <br>  Comme vous pouvez le voir, le <code>descriptor</code> est un param√®tre facultatif.  En effet, nous avons besoin que le d√©corateur soit appliqu√© aux m√©thodes et aux propri√©t√©s.  Si le param√®tre existe, cela signifie que le d√©corateur est appliqu√© √† la m√©thode.  Dans ce cas, nous faisons ceci: <br><br><ul><li>  Enregistrez la propri√©t√© de <code>descriptor.</code>  <code>value</code> . </li><li>  Nous red√©finissons la m√©thode comme suit: appelez la fonction d'origine, puis appelez <code>markDirty(this)</code> afin de d√©marrer le processus de d√©tection de changement.  Voici √† quoi √ßa ressemble: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptor) {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> original = descriptor.value; <span class="hljs-comment"><span class="hljs-comment">//     descriptor.value = function(...args: any[]) {    original.apply(this, args); //       markDirty(this);  }; } else {  //   }</span></span></code> </pre> </li></ul><br>  Ensuite, vous devez v√©rifier de quel type de propri√©t√© il s'agit.  Il peut s'agir d'un objet observable ou d'un objet ordinaire.  Ici, nous utiliserons une autre API angulaire interne.  Il n'est, je crois, pas destin√© √† √™tre utilis√© dans des applications r√©guli√®res (d√©sol√©!). <br><br>  Nous parlons de la propri√©t√© <code>…µcmp</code> , qui donne acc√®s aux propri√©t√©s trait√©es par Angular apr√®s leur d√©finition.  Nous pouvons les utiliser pour remplacer les m√©thodes des <code>onDestroy</code> <code>onInit</code> et <code>onDestroy</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getCmp = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function"> =&gt;</span></span> (type).…µcmp; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cmp = getCmp(target.constructor); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onInit = cmp.onInit || noop; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onDestroy = cmp.onDestroy || noop;</code> </pre> <br>  Afin de marquer une propri√©t√© comme une propri√©t√© √† surveiller, nous utilisons <code>ReflectMetadata</code> et d√©finissons sa valeur sur <code>true</code> .  Par cons√©quent, nous saurons que nous devons observer la propri√©t√© lorsque le composant est initialis√©: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.set(target, propertyKey, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Il est maintenant temps de remplacer le crochet <code>onInit</code> et de v√©rifier les propri√©t√©s lors de la cr√©ation de l'instance de composant: <br><br><pre> <code class="javascript hljs">cmp.onInit = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  checkComponentProperties(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  onInit.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); };</code> </pre> <br>  Nous d√©finissons la fonction <code>checkComponentProperties</code> , qui contournera les propri√©t√©s du composant, en les filtrant en fonction de la valeur d√©finie pr√©c√©demment √† l'aide de <code>Reflect.set</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkComponentProperties = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> props = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(ctx);  props.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, prop);  }).filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    checkProperty.call(ctx, propertyKey);  }); };</code> </pre> <br>  La fonction <code>checkProperty</code> sera responsable de la d√©coration des propri√©t√©s individuelles.  Tout d'abord, nous v√©rifions si la propri√©t√© est un objet observable ou r√©gulier.  S'il s'agit d'un objet observable, nous y souscrivons et ajoutons l'abonnement √† la liste des abonnements stock√©s dans le composant pour ses besoins internes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkProperty = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name: string</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[name] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Observable) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscriptions = getSubscriptions(ctx);    subscriptions.add(ctx[name].subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {      markDirty(ctx);    }));  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//    } };</span></span></code> </pre> <br>  Si la propri√©t√© est un objet ordinaire, nous la convertirons en objet Proxy et appellerons <code>markDirty</code> dans sa fonction de <code>handler</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {  set(obj, prop, value) {    obj[prop] = value;    …µmarkDirty(ctx);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;  } }; ctx[name] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(ctx, handler);</code> </pre> <br>  Enfin, vous devez effacer l'abonnement apr√®s avoir d√©truit le composant: <br><br><pre> <code class="javascript hljs">cmp.onDestroy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[subscriptionsSymbol]) {    ctx[subscriptionsSymbol].unsubscribe();  }  onDestroy.call(ctx); };</code> </pre> <br>  Les possibilit√©s de ce d√©corateur ne peuvent √™tre qualifi√©es de compl√®tes.  Ils ne couvrent pas toutes les utilisations possibles qui peuvent appara√Ætre dans une grande application.  Par exemple, ce sont des appels √† des fonctions de mod√®le qui retournent des objets observables.  Mais j'y travaille. <br><br>  Malgr√© cela, le d√©corateur ci-dessus suffit pour mon petit projet.  Vous trouverez son code complet √† la fin du document. <br><br><h2>  <font color="#3AC1EF">Analyse des r√©sultats d'acc√©l√©ration des applications</font> </h2><br>  Maintenant que nous avons parl√© un peu des m√©canismes internes d'Ivy et de la fa√ßon de cr√©er un d√©corateur en utilisant ces m√©canismes, il est temps de tester ce que nous avons dans une vraie application. <br><br>  Pour d√©couvrir l'effet de la suppression de zone.js sur les performances des applications angulaires, j'ai utilis√© mon projet de loisir <a href="https://github.com/gbuomprisco/cryptofolio">Cryptofolio</a> . <br><br>  J'ai appliqu√© le d√©corateur √† tous les liens n√©cessaires utilis√©s dans les mod√®les et d√©sactiv√© zone.js.  Par exemple, consid√©rez le composant suivant: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetPricerComponent</span></span></span><span class="hljs-class"> </span></span>{  @observed() price$: Observable&lt;string&gt;;  @observed() trend$: Observable&lt;Trend&gt;;   <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Deux variables sont utilis√©es dans le mod√®le: le <code>price</code> (le <code>price</code> l'actif sera situ√© ici) et la <code>trend</code> (cette variable peut prendre des valeurs √† la <code>up</code> , √† la <code>up</code> et √† la <code>down</code> , indiquant la direction du changement de prix).  Je les ai d√©cor√©s avec <code>@observed</code> . <br><br><h3>  <font color="#3AC1EF">Size Taille du bundle de projet</font> </h3><br>  Pour commencer, regardons √† quel point la taille du bundle de projet a diminu√© tout en se d√©barrassant de zone.js.  Voici le r√©sultat de la construction du projet avec zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/cb3/7e8/a0bcb37e870dfdcafa1c49a80aeaeb04.png"></div><br>  <i><font color="#999999">R√©sultat de la construction d'un projet avec zone.js</font></i> <br><br>  Et voici le montage sans zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/6ae/adc/7d56aeadce675e6953e5e603b3594c2c.png"></div><br>  <i><font color="#999999">Le r√©sultat de la construction d'un projet sans zone.js</font></i> <br><br>  Faites attention au <code>polyfills-es2015.xxx.js</code> .  Si le projet utilise zone.js, sa taille est d'environ 35 Ko.  Mais sans zone.js - seulement 130 octets. <br><br><h3>  <font color="#3AC1EF">OotingD√©marrage</font> </h3><br>  J'ai recherch√© deux options d'application en utilisant Lighthouse.  Les r√©sultats de cette √©tude sont donn√©s ci-dessous.  Il convient de noter que je ne les prendrais pas trop au s√©rieux.  Le fait est qu'en essayant de trouver les valeurs moyennes, j'ai obtenu des r√©sultats significativement diff√©rents en effectuant plusieurs mesures pour la m√™me version d'application. <br><br>  Peut-√™tre que la diff√©rence dans l'√©valuation des deux options d'application ne d√©pend que de la taille des bundles. <br><br>  Voici donc le r√©sultat obtenu pour une application qui utilise zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfd/922/5f3/dfd9225f368de1f7c3e43d47bddbad16.png"></div><br>  <i><font color="#999999">R√©sultats d'analyse pour une application qui utilise zone.js</font></i> <br><br>  Et voici ce qui s'est pass√© apr√®s avoir analys√© l'application dans laquelle zone.js n'est pas utilis√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/684/9ba/f416849ba2f210d1ed48345e607a3d8f.png"></div><br>  <i><font color="#999999">R√©sultats d'analyse pour une application qui n'utilise pas zone.js</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç Performance</font> </h3><br>  Et maintenant, nous sommes arriv√©s au plus int√©ressant.  Il s'agit des performances d'une application ex√©cut√©e sous charge.  Nous voulons savoir comment le processeur se sent lorsque l'application affiche des mises √† jour de prix pour des centaines d'actifs plusieurs fois par seconde. <br><br>  Afin de charger l'application, j'ai cr√©√© 100 entit√©s qui fournissent des donn√©es conditionnelles √† des prix qui changent toutes les 250 ms.  Si le prix augmente, il s'affiche en vert.  Si r√©duit - rouge.  Tout cela pourrait s√©rieusement charger mon MacBook Pro. <br><br>  Il convient de noter qu'en travaillant dans le secteur financier sur plusieurs applications con√ßues pour la transmission √† haute fr√©quence de fragments de donn√©es, j'ai rencontr√© √† plusieurs reprises une situation similaire. <br><br>  Pour analyser la fa√ßon dont diff√©rentes versions de l'application utilisent les ressources du processeur, j'ai utilis√© les outils de d√©veloppement Chrome. <br><br>  Voici √† quoi ressemble l'application qui utilise zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbf/11b/56f/fbf11b56ffe060d5bcdc4680a0ddd347.gif"></div><br>  <i><font color="#999999">Charge syst√®me cr√©√©e par une application qui utilise zone.js</font></i> <br><br>  Et voici comment fonctionne une application dans laquelle zone.js n'est pas utilis√©e. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/657/240/8fb65724082e810619f061cb238c76da.gif"></div><br>  <i><font color="#999999">Charge syst√®me cr√©√©e par une application qui n'utilise pas zone.js</font></i> <br><br>  Nous analysons ces r√©sultats en faisant attention au graphique de charge du processeur (jaune): <br><br><ul><li>  Comme vous pouvez le voir, une application qui utilise zone.js charge constamment le processeur de 70 √† 100%!  Si vous maintenez l'onglet du navigateur ouvert pendant longtemps, cr√©ant une telle charge sur le syst√®me, l'application qui s'ex√©cute peut bien √©chouer. </li><li>  Et la version de l'application o√π zone.js n'est pas utilis√©e cr√©e une charge stable sur le processeur dans la plage de 30 √† 40%.  Super! </li></ul><br>  Veuillez noter que ces r√©sultats ont √©t√© obtenus avec la fen√™tre Chrome Developer Tools ouverte, ce qui met √©galement √† rude √©preuve le syst√®me et ralentit l'application. <br><br><h3>  <font color="#3AC1EF">‚ñç augmentation de la charge</font> </h3><br>  J'ai essay√© de m'assurer que chaque entit√© responsable de la mise √† jour du prix √©mettrait 4 mises √† jour suppl√©mentaires chaque seconde en plus de ce qu'elle produit d√©j√†. <br><br>  Voici ce que nous avons r√©ussi √† d√©couvrir sur l'application dans laquelle zone.js n'est pas utilis√©: <br><br><ul><li>  Cette application faisait normalement face √† la charge, utilisant maintenant environ 50% des ressources du processeur. </li><li>  Il a r√©ussi √† charger le processeur autant que l'application avec zone.js, uniquement lorsque les prix √©taient mis √† jour toutes les 10 ms (les nouvelles donn√©es, comme auparavant, provenaient de 100 entit√©s). </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Analyse des performances avec Angular Benchpress</font> </h3><br>  L'analyse des performances que j'ai men√©e ci-dessus ne peut pas √™tre qualifi√©e de particuli√®rement scientifique.  Pour une √©tude plus s√©rieuse des performances de diff√©rents frameworks, je recommanderais d'utiliser <a href="https://krausest.github.io/js-framework-benchmark/current.html">ce benchmark</a> .  Pour la recherche, Angular doit choisir la version habituelle de ce framework et sa version sans zone.js. <br><br>  Moi, inspir√© par quelques id√©es de ce benchmark, j'ai cr√©√© un <a href="https://github.com/Gbuomprisco/zoneless-angular">projet</a> qui effectue des calculs lourds.  J'ai test√© ses performances avec <a href="https://github.com/angular/angular/tree/master/packages/benchpress">Angular Benchpress</a> . <br><br>  Voici le code du composant test√©: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{  public data = [];  @observed()  run(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  append(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  removeAll() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();  }  @observed()  remove(item) {    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, l = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length; i &lt; l; i++) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data[i].id === item.id) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>);        <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;      }    }  }  trackById(item) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item.id;  }  private clear() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = [];  }  private buildData(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = start + length;    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = start; n &lt;= end; n++) {      <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.push({        <span class="hljs-attr"><span class="hljs-attr">id</span></span>: n,        <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()      });    }  } }</code> </pre> <br>  J'ai lanc√© un petit ensemble de r√©f√©rences en utilisant Protractor et Benchpress.  Les op√©rations ont √©t√© effectu√©es un nombre sp√©cifi√© de fois. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/167/a7b/5c2167a7bae21093e5e7cdc9f2482361.gif"></div><br>  <i><font color="#999999">Benchpress en action</font></i> <br><br><h4>  R√©sultats </h4><br>  Voici un √©chantillon des r√©sultats obtenus avec Benchpress. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5a/467/0f0/f5a4670f0af5b461a1f0fad2d7f982b3.png"></div><br>  <i><font color="#999999">R√©sultats Benchpress</font></i> <br><br>  Voici une explication des indicateurs pr√©sent√©s dans ce tableau: <br><br><ul><li>  <code>gcAmount</code> : volume des op√©rations gc (garbage collection), Kb. </li><li>  <code>gcTime</code> : temps de fonctionnement gc, ms. </li><li>  <code>majorGcTime</code> : heure des principales op√©rations gc, ms. </li><li>  <code>pureScriptTime</code> : temps d'ex√©cution du script en ms, hors op√©rations gc et rendu. </li><li>  <code>renderTime</code> : temps de rendu, ms. </li><li>  <code>scriptTime</code> : temps d'ex√©cution du script prenant en compte les op√©rations gc et le rendu. </li></ul><br>  Nous allons maintenant consid√©rer l'analyse des performances de certaines op√©rations dans diff√©rentes variantes d'application.  Le vert montre les r√©sultats d'une application qui utilise zone.js, l'orange montre les r√©sultats d'une application sans zone.js.  Veuillez noter que seul le temps de rendu est analys√© ici.  Si vous √™tes int√©ress√© par tous les r√©sultats des tests, cochez <a href="https://github.com/Gbuomprisco/zoneless-angular">ici</a> . <br><br><h4>  Test: cr√©ation de 1000 lignes </h4><br>  Dans le premier test, 1000 lignes sont cr√©√©es. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/d48/745/944d48745c79b697bececc092c78c9be.png"></div><br>  <i><font color="#999999">R√©sultats des tests</font></i> <br><br><h4>  Test: cr√©ation de 10 000 lignes </h4><br>  √Ä mesure que la charge sur les applications augmente, la diff√©rence de leurs performances augmente √©galement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/971/8aa/7e19718aadeec04390f1f4b7fa408f89.png"></div><br>  <i><font color="#999999">R√©sultats des tests</font></i> <br><br><h4>  Test: rejoignez 1000 lignes </h4><br>  Dans ce test, 1 000 lignes sont ajout√©es √† 10 000 lignes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f3/682/d30/3f3682d3064b9158ef95146426d2638b.png"></div><br>  <i><font color="#999999">R√©sultats des tests</font></i> <br><br><h4>  Test: suppression de 10 000 lignes </h4><br>  Ici, 10 000 lignes sont cr√©√©es, qui sont ensuite supprim√©es. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f85/d5d/bb7/f85d5dbb78b094bd9bb9afccbce148e3.png"></div><br>  <i><font color="#999999">R√©sultats des tests</font></i> <br><br><h2>  <font color="#3AC1EF">Code source de TypeScript Decorator</font> </h2><br>  Ci-dessous se trouve le code source du d√©corateur TypeScript discut√© ici.  Ce code peut √©galement √™tre trouv√© <a href="">ici</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tslint:disable import { Observable, Subscription } from 'rxjs'; import { Type, …µComponentType as ComponentType, …µmarkDirty as markDirty } from '@angular/core'; interface ComponentDefinition {  onInit(): void;  onDestroy(): void; } const noop = () =&gt; { }; const getCmp = &lt;T&gt;(type: Function) =&gt; (type as any).…µcmp as ComponentDefinition; const subscriptionsSymbol = Symbol('__ng__subscriptions'); export function observed() {  return function(    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  ) {    if (descriptor) {      const original = descriptor.value;      descriptor.value = function(...args: any[]) {        original.apply(this, args);        markDirty(this);      };    } else {      const cmp = getCmp(target.constructor);      if (!cmp) {        throw new Error(`Property …µcmp is undefined`);      }      const onInit = cmp.onInit || noop;      const onDestroy = cmp.onDestroy || noop;      const getSubscriptions = (ctx) =&gt; {        if (ctx[subscriptionsSymbol]) {          return ctx[subscriptionsSymbol];        }        ctx[subscriptionsSymbol] = new Subscription();        return ctx[subscriptionsSymbol];      };      const checkProperty = function(name: string) {        const ctx = this;        if (ctx[name] instanceof Observable) {          const subscriptions = getSubscriptions(ctx);          subscriptions.add(ctx[name].subscribe(() =&gt; markDirty(ctx)));        } else {          const handler = {            set(obj: object, prop: string, value: unknown) {              obj[prop] = value;              markDirty(ctx);              return true;            }          };          ctx[name] = new Proxy(ctx, handler);        }      };      const checkComponentProperties = (ctx) =&gt; {        const props = Object.getOwnPropertyNames(ctx);        props.map((prop) =&gt; {          return Reflect.get(target, prop);        }).filter(Boolean).forEach(() =&gt; {          checkProperty.call(ctx, propertyKey);        });      };      cmp.onInit = function() {        const ctx = this;        onInit.call(ctx);        checkComponentProperties(ctx);      };      cmp.onDestroy = function() {        const ctx = this;        onDestroy.call(ctx);        if (ctx[subscriptionsSymbol]) {          ctx[subscriptionsSymbol].unsubscribe();        }      };      Reflect.set(target, propertyKey, true);    }  }; }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Bien que j'esp√®re que vous avez aim√© mon histoire sur l'optimisation des performances des projets Angular, j'esp√®re √©galement que je ne vous inclinerai pas √† vous pr√©cipiter pour supprimer zone.js de votre projet.  La strat√©gie d√©crite ici doit √™tre le tout dernier recours auquel vous pouvez recourir pour augmenter les performances de votre application Angular. <br><br>  Vous devez d'abord essayer des approches telles que l'utilisation de la strat√©gie de d√©tection des modifications OnPush, l'application de <code>trackBy</code> , la d√©sactivation des composants, l'ex√©cution de code en dehors de zone.js, la liste noire des √©v√©nements zone.js (cette liste de m√©thodes d'optimisation peut √™tre poursuivie).  L'approche pr√©sent√©e ici est assez ch√®re, et je ne suis pas s√ªr que tout le monde soit pr√™t √† payer un prix aussi √©lev√© pour ses performances. <br><br>  En fait, le d√©veloppement sans zone.js n'est peut-√™tre pas la chose la plus attrayante.  Ce n'est peut-√™tre pas seulement pour la personne impliqu√©e dans le projet, qui est sous son contr√¥le total.  C'est-√†-dire qu'il est propri√©taire de d√©pendances et a la capacit√© et le temps de tout mettre sous sa forme appropri√©e. <br><br>  S'il s'av√®re que vous avez tout essay√© et que le goulot d'√©tranglement de votre projet est pr√©cis√©ment zone.js, alors vous devriez peut-√™tre essayer d'acc√©l√©rer Angular en d√©tectant ind√©pendamment les changements. <br><br>  J'esp√®re que cet article vous a permis de voir ce que Angular attend √† l'avenir, de quoi Ivy est capable et ce que zone.js peut faire pour maximiser la vitesse d'application. <br><br>  <b>Chers lecteurs!</b>  Comment optimisez-vous vos projets Angular qui n√©cessitent des performances maximales? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476956/">https://habr.com/ru/post/fr476956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476938/index.html">Luxe inaccessible d'Intel: Core i9-9990XE avec 14 c≈ìurs √† une fr√©quence de 5,0 GHz (2 parties)</a></li>
<li><a href="../fr476940/index.html">S√©maphore sur les √©v√©nements C ++</a></li>
<li><a href="../fr476944/index.html">Le cerveau de l'entreprise. Commencer</a></li>
<li><a href="../fr476948/index.html">Trajectoires quantiques et ce avec quoi ils mangent</a></li>
<li><a href="../fr476954/index.html">Le travail n'est pas un loup, partie 3. D√©butant - grandir ou survivre?</a></li>
<li><a href="../fr476958/index.html">√âmulateur Omega Red + PS1 = Kojima Genius</a></li>
<li><a href="../fr476970/index.html">EkbDotNet Meeting No. 1 - Ekaterinbourg rejoint la communaut√© DotNet.Ru</a></li>
<li><a href="../fr476972/index.html">Deno: Le temps de Node.JS est √©coul√©?</a></li>
<li><a href="../fr476974/index.html">Apprenez la conception Web r√©active en 5 minutes</a></li>
<li><a href="../fr476976/index.html">6 erreurs de prise de parole en public lors de conf√©rences</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>