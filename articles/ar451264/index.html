<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏻 📠 🛴 التطبيق العملي لل ELK. تكوين logstash 🀄️ 👎🏿 👇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مقدمة 
 نشر النظام التالي ، في مواجهة الحاجة إلى معالجة عدد كبير من السجلات المختلفة. كما اختارت الأداة ELK. هذه المقالة سوف تناقش تجربتنا مع ضبط هذا ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>التطبيق العملي لل ELK. تكوين logstash</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451264/" style=";text-align:right;direction:rtl"><h1 style=";text-align:right;direction:rtl">  مقدمة </h1><br>  نشر النظام التالي ، في مواجهة الحاجة إلى معالجة عدد كبير من السجلات المختلفة.  كما اختارت الأداة ELK.  هذه المقالة سوف تناقش تجربتنا مع ضبط هذا المكدس. <br><br>  نحن لا نضع هدفًا لوصف جميع إمكانياته ، لكننا نريد التركيز بدقة على حل المشكلات العملية.  ويرجع ذلك إلى حقيقة أنه في وجود كمية كبيرة بما يكفي من الوثائق والصور الجاهزة ، هناك الكثير من المزالق ، على الأقل وجدناها. <br><a name="habracut"></a><br>  نشرنا المكدس عبر عامل الميناء.  علاوة على ذلك ، كان لدينا عامل ترسيم compose.yml مكتوب جيدًا ، والذي سمح لنا برفع الرصة دون أي مشاكل تقريبًا.  وبدا لنا أن النصر كان قريبًا بالفعل ، والآن سنحرف قليلاً لتناسب احتياجاتنا وهذا كل شيء. <br><br>  لسوء الحظ ، فإن محاولة ضبط النظام لتلقي السجلات ومعالجتها من تطبيقنا لم تتوج بالنجاح.  لذلك ، قررنا أن الأمر يستحق استكشاف كل مكون على حدة ، ثم العودة إلى علاقاتهم. <br><br>  لذلك ، بدأنا مع logstash. <br><br><h1 style=";text-align:right;direction:rtl">  البيئة ، النشر ، إطلاق Logstash في الحاوية </h1><br>  بالنسبة للنشر ، نستخدم عامل التثبيت ، وقد أجريت التجارب الموصوفة هنا على نظامي MacOS و Ubuntu 18.0.4. <br><br>  صورة logstash التي تم تسجيلها معنا في عامل التحميل الأصلي - compose.yml هي docker.elastic.co/logstash/logstash:6.3.2 <br><br>  سوف نستخدمها للتجارب. <br><br>  لتشغيل logstash ، كتبنا منفصلة عامل ميناء compose.yml.  بالطبع ، كان من الممكن إطلاق الصورة من سطر الأوامر ، لكننا قمنا بحل مشكلة معينة ، حيث تم إطلاق كل شيء من عامل التأسيس. <br><br><h2 style=";text-align:right;direction:rtl">  لفترة وجيزة حول ملفات التكوين </h2><br>  على النحو التالي من الوصف ، يمكن تشغيل logstash على حد سواء لقناة واحدة ، في هذه الحالة ، تحتاج إلى نقل ملف * .conf أو لعدة قنوات ، في هذه الحالة ، يجب نقل ملف pipelines.yml ، والذي بدوره سيربط بالملفات .conf لكل قناة. <br>  ذهبنا في الطريق الثاني.  بدا لنا أكثر عالمية وقابلة للتطوير.  لذلك ، أنشأنا pipelines.yml ، وقمنا بإنشاء دليل خطوط الأنابيب الذي سنضع فيه ملفات .conf لكل قناة. <br><br>  داخل الحاوية يوجد ملف تكوين آخر - logstash.yml.  نحن لا نلمسها ، استخدمها كما هي. <br><br>  لذلك ، هيكل الدلائل لدينا: <br><br><img src="https://habrastorage.org/webt/ci/zd/49/cizd49eci9alvlbi1fwk8nyyaky.png"><br><br>  للحصول على المدخلات ، في الوقت الحالي ، نعتقد أنه برنامج tcp على المنفذ 5046 ، ولأنه سوف نستخدم stdout. <br><br>  هنا هو مثل هذا التكوين البسيط لأول مرة.  منذ المهمة الأولى هي إطلاق. <br><br>  لذلك ، لدينا هذا عامل ميناء compose.yml <br><br><pre style=";text-align:right;direction:rtl"><code class="plaintext hljs">version: '3' networks: elk: volumes: elasticsearch: driver: local services: logstash: container_name: logstash_one_channel image: docker.elastic.co/logstash/logstash:6.3.2 networks: - elk ports: - 5046:5046 volumes: - ./config/pipelines.yml:/usr/share/logstash/config/pipelines.yml:ro - ./config/pipelines:/usr/share/logstash/config/pipelines:ro</code> </pre> <br>  ماذا نرى هنا؟ <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تم أخذ الشبكات والمجلدات من عامل الترسيم الأصلي compose.yml (واحد حيث تم إطلاق المكدس بالكامل) وأعتقد أنها لا تؤثر بشكل كبير على الصورة العامة هنا. </li><li style=";text-align:right;direction:rtl">  نقوم بإنشاء خدمة logstash واحدة من صورة docker.elastic.co/logstash/logstash:6.3.2 ومنحها اسم logstash_one_channel. </li><li style=";text-align:right;direction:rtl">  نقوم بإعادة توجيه المنفذ 5046 داخل الحاوية إلى نفس المنفذ الداخلي. </li><li style=";text-align:right;direction:rtl">  نقوم بتعيين ملف إعدادات قناتنا ./config/pipelines.yml إلى الملف /usr/share/logstash/config/pipelines.yml داخل الحاوية ، حيث سيقوم logstash باستلامه وجعله للقراءة فقط ، في حالة حدوث ذلك. </li><li style=";text-align:right;direction:rtl">  نعرض دليل ./config/pipelines ، حيث لدينا ملفات إعدادات القناة ، في دليل / usr / share / logstash / config / pipelines ونجعله أيضًا للقراءة فقط. </li></ol><br><img src="https://habrastorage.org/webt/5u/s3/dw/5us3dwu8forutzwmtlfnlcjt-ic.png"><br><br>  ملف Pipelines.yml <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">- pipeline.id: HABR pipeline.workers: 1 pipeline.batch.size: 1 path.config: "./config/pipelines/habr_pipeline.conf"</code> </pre><br>  هنا ، يتم وصف قناة واحدة مع معرف HABR والمسار إلى ملف التكوين الخاص بها. <br><br>  وأخيراً الملف "./config/pipelines/habr_pipeline.conf" <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">input { tcp { port =&gt; "5046" } } filter { mutate { add_field =&gt; [ "habra_field", "Hello Habr" ] } } output { stdout { } }</code> </pre><br>  دعونا لا نذهب إلى وصفه الآن ، حاول أن تجري: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">docker-compose up</code> </pre><br>  ماذا نرى؟ <br><br>  بدأت الحاوية.  يمكننا التحقق من عملها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'13123123123123123123123213123213'</span></span> | nc localhost 5046</code> </pre><br>  ونحن نرى الجواب في وحدة التحكم في الحاوية: <br><br><img src="https://habrastorage.org/webt/uj/oy/tz/ujoytzcsc_mmiagm05savxahnzm.jpeg"><br><br>  لكن في الوقت نفسه ، نرى أيضًا: <br><br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 28: 59،790] <font color="«CC0000»">[خطأ] [logstash.licensechecker.licensereader] غير قادر على استرداد معلومات الترخيص من خادم الترخيص {: message =&gt; "Elasticsearch Unreachable: [http: // elasticsearch: 9200 /]</font> [Manticore :: ResolutionFailure] elasticsearch "، ... <br><br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 28: 59،894] [INFO] [logstash.pipeline] <font color="green">بدأ تشغيل خط الأنابيب بنجاح</font> {: pipeline_id =&gt; ". Monitoring-logstash" ،: thread =&gt; "# &lt;Thread: 0x119abb86 run&gt;"} <br><br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 28: 59،988] [INFO] [logstash.agent] خطوط الأنابيب التي تشغل {: count =&gt; 2 ،: running_pipelines =&gt; [: HABR ،: ". Monitoring-logstash"] ،: non_running_pipelines =&gt; [ ]} <br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 29: 00،015] <font color="«CC0000»">[خطأ] [logstash.inputs.metrics] تم تثبيت X-Pack على Logstash ولكن ليس على Elasticsearch.</font>  <font color="«CC0000»">الرجاء تثبيت X-Pack على Elasticsearch لاستخدام ميزة المراقبة.</font>  <font color="«CC0000»">ميزات أخرى قد تكون متاحة.</font> <br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 29: 00،526] [INFO] [logstash.agent] تم البدء بنجاح في نقطة نهاية واجهة برمجة تطبيقات Logstash {: port =&gt; 9600} <br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 29: 04،478] [INFO] [logstash.outputs.elasticsearch] تشغيل التحقق من الصحة لمعرفة ما إذا كان اتصال Elasticsearch يعمل {: healthcheck_url =&gt; http: // elasticsearch: 9200 / ،: path =&gt; "/"} <br>  ل <font color="«#38B9C7»">ogstash_one_channel |</font>  [2019-04-29T11: 29: 04،487] <font color="orange">[WARN] [logstash.outputs.elasticsearch] حاول إعادة إحياء الاتصال بمثال ES الميت ، لكن حصل خطأ.</font>  <font color="orange">{: url =&gt; "elasticsearch: 9200 /" ،: error_type =&gt; LogStash :: المخرجات :: ElasticSearch :: HttpClient :: Pool :: HostUnreachableError ،: error =&gt; "Elasticsearch Unreachable: [http: // elasticsearch: 9200 / ] [Manticore :: ResolutionFailure] elasticsearch ”}</font> <br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 29: 04،704] [INFO] [logstash.licensechecker.licensereader] إجراء فحص صحي لمعرفة ما إذا كان اتصال Elasticsearch يعمل {: healthcheck_url =&gt; http: // elasticsearch: 9200 / ،: path =&gt; "/"} <br>  <font color="«#38B9C7»">logstash_one_channel |</font>  [2019-04-29T11: 29: 04،710] <font color="orange">[WARN] [logstash.licensechecker.licensereader] حاول إعادة إحياء الاتصال بمثال ES الميت ، لكن حصل خطأ.</font>  <font color="orange">{: url =&gt; "elasticsearch: 9200 /" ،: error_type =&gt; LogStash :: المخرجات :: ElasticSearch :: HttpClient :: Pool :: HostUnreachableError ،: error =&gt; "Elasticsearch Unreachable: [http: // elasticsearch: 9200 / ] [Manticore :: ResolutionFailure] elasticsearch ”}</font> <br><br>  وسجلنا يزحف طوال الوقت. <br><br>  أبرزت هنا باللون الأخضر رسالة تفيد بأن خط الأنابيب بدأ بنجاح ، رسالة حمراء - رسالة خطأ وصفراء - رسالة حول محاولة الاتصال بـ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">elasticsearch</a> : 9200. <br>  يحدث هذا لأن logstash.conf المضمنة في الصورة لديه فحص للتحقق من توفر elasticsearch.  بعد كل شيء ، يفترض logstash أنه يعمل كجزء من مكدس Elk ، وقمنا بفصله. <br><br>  يمكنك العمل ، ولكن ليست مريحة. <br><br>  يكمن الحل في تعطيل هذا الفحص من خلال متغير البيئة XPACK_MONITORING_ENABLED. <br><br>  قم بإجراء تغيير على docker-compose.yml وتشغيله مرة أخرى: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">version: '3' networks: elk: volumes: elasticsearch: driver: local services: logstash: container_name: logstash_one_channel image: docker.elastic.co/logstash/logstash:6.3.2 networks: - elk environment: XPACK_MONITORING_ENABLED: "false" ports: - 5046:5046 volumes: - ./config/pipelines.yml:/usr/share/logstash/config/pipelines.yml:ro - ./config/pipelines:/usr/share/logstash/config/pipelines:ro</code> </pre><br>  الآن ، كل شيء على ما يرام.  الحاوية جاهزة للتجريب. <br><br>  يمكننا مرة أخرى الكتابة في وحدة التحكم التالية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'13123123123123123123123213123213'</span></span> | nc localhost 5046</code> </pre><br>  وانظر: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">logstash_one_channel | { logstash_one_channel | "message" =&gt; "13123123123123123123123213123213", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T11:43:44.582Z, logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "host" =&gt; "gateway", logstash_one_channel | "port" =&gt; 49418 logstash_one_channel | }</code> </pre><br><h1 style=";text-align:right;direction:rtl">  العمل داخل قناة واحدة </h1><br>  لذلك ، بدأنا.  الآن يمكنك بالفعل قضاء الوقت لتكوين logstash مباشرة.  لن نلمس ملف pipelines.yml الآن ، وسنرى ما يمكنك الحصول عليه من خلال العمل مع قناة واحدة. <br><br>  يجب أن أقول أن المبدأ العام للعمل مع ملف تكوين القناة موصوف جيدًا في الدليل الرسمي ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> <br>  إذا كنت تريد القراءة باللغة الروسية ، فقد استخدمنا هذه <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المقالة هنا</a> (ولكن بناء جملة الاستعلام قديم هناك ، يجب أن نأخذ ذلك في الاعتبار). <br><br>  دعنا نذهب بالتتابع من قسم الإدخال.  لقد رأينا بالفعل العمل على برنامج التعاون الفني.  ماذا يمكن أن يكون موضع اهتمام هنا؟ <br><br><h2 style=";text-align:right;direction:rtl">  اختبار الرسائل باستخدام نبضات </h2><br>  هناك فرصة مثيرة للاهتمام لإنشاء رسائل اختبار تلقائية. <br>  للقيام بذلك ، تحتاج إلى تضمين البرنامج المساعد heartbean في قسم الإدخال. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">input { heartbeat { message =&gt; "HeartBeat!" } }</code> </pre><br>  بدوره ، تبدأ مرة واحدة في الدقيقة لتلقي <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">logstash_one_channel | { logstash_one_channel | "@timestamp" =&gt; 2019-04-29T13:52:04.567Z, logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "message" =&gt; "HeartBeat!", logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "host" =&gt; "a0667e5c57ec" logstash_one_channel | }</code> </pre><br>  نريد الحصول على أكثر من مرة ، نحتاج إلى إضافة المعلمة الفاصل. <br>  هكذا نتلقى رسالة كل 10 ثوانٍ. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">input { heartbeat { message =&gt; "HeartBeat!" interval =&gt; 10 } }</code> </pre><br><h2 style=";text-align:right;direction:rtl">  استرداد البيانات من ملف </h2><br>  قررنا أيضًا رؤية وضع الملف.  إذا كان يعمل بشكل طبيعي مع الملف ، فمن المحتمل أنه لن تكون هناك حاجة إلى وكيل ، حسنًا ، على الأقل للاستخدام المحلي. <br><br>  وفقًا للوصف ، يجب أن يكون وضع التشغيل مشابهًا للذيل -f ، على سبيل المثال  يقرأ الأسطر الجديدة أو ، كخيار ، يقرأ الملف بأكمله. <br><br>  إذن ما نريد الحصول عليه: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  نريد الحصول على خطوط يتم إلحاقها بملف سجل واحد. </li><li style=";text-align:right;direction:rtl">  نريد تلقي البيانات المكتوبة إلى عدة ملفات سجل ، مع التمكن من مشاركة ما جاء منها. </li><li style=";text-align:right;direction:rtl">  نريد التحقق من أنه عند إعادة تشغيل logstash ، لن تتلقى هذه البيانات مرة أخرى. </li><li style=";text-align:right;direction:rtl">  نريد التحقق من أنه في حالة تعطيل logstash ، واستمرار كتابة البيانات إلى الملفات ، فعند تشغيلها ، سنحصل على هذه البيانات. </li></ol><br>  لإجراء التجربة ، أضف سطرًا آخر إلى docker-compose.yml ، وافتح الدليل الذي نضع فيه الملفات. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">version: '3' networks: elk: volumes: elasticsearch: driver: local services: logstash: container_name: logstash_one_channel image: docker.elastic.co/logstash/logstash:6.3.2 networks: - elk environment: XPACK_MONITORING_ENABLED: "false" ports: - 5046:5046 volumes: - ./config/pipelines.yml:/usr/share/logstash/config/pipelines.yml:ro - ./config/pipelines:/usr/share/logstash/config/pipelines:ro - ./logs:/usr/share/logstash/input</code> </pre><br>  وتغيير قسم الإدخال في habr_pipeline.conf <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">input { file { path =&gt; "/usr/share/logstash/input/*.log" } }</code> </pre><br>  نبدأ: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">docker-compose up</code> </pre><br>  لإنشاء ملفات السجل وتسجيلها ، سنستخدم الأمر: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> &gt;&gt; logs/number1.log</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ logstash_one_channel | "host" =&gt; "ac2d4e3ef70f", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T14:28:53.876Z, logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "message" =&gt; "1", logstash_one_channel | "path" =&gt; "/usr/share/logstash/input/number1.log" logstash_one_channel | }</code> </pre><br>  نعم ، إنه يعمل! <br><br>  في الوقت نفسه ، نرى أننا أضفنا حقل المسار تلقائيًا.  لذلك في المستقبل ، يمكننا تصفية السجلات به. <br><br>  دعونا نحاول مرة أخرى: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'2'</span></span> &gt;&gt; logs/number1.log</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ logstash_one_channel | "host" =&gt; "ac2d4e3ef70f", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T14:28:59.906Z, logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "message" =&gt; "2", logstash_one_channel | "path" =&gt; "/usr/share/logstash/input/number1.log" logstash_one_channel | }</code> </pre><br><br>  والآن إلى ملف آخر: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> &gt;&gt; logs/number2.log</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ logstash_one_channel | "host" =&gt; "ac2d4e3ef70f", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T14:29:26.061Z, logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "message" =&gt; "1", logstash_one_channel | "path" =&gt; "/usr/share/logstash/input/number2.log" logstash_one_channel | }</code> </pre><br>  ! ممتاز  تم التقاط الملف ، كان المسار صحيحًا ، كل شيء على ما يرام. <br><br>  وقف logstash وإعادة تشغيل.  لننتظر  الصمت.  أي  نحن لا نتلقى هذه السجلات مرة أخرى. <br><br>  والآن التجربة الأكثر جرأة. <br><br>  نضع logstash وتنفيذ: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'3'</span></span> &gt;&gt; logs/number2.log <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'4'</span></span> &gt;&gt; logs/number1.log</code> </pre><br>  قم بتشغيل logstash مرة أخرى وانظر: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">logstash_one_channel | { logstash_one_channel | "host" =&gt; "ac2d4e3ef70f", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "message" =&gt; "3", logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "path" =&gt; "/usr/share/logstash/input/number2.log", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T14:48:50.589Z logstash_one_channel | } logstash_one_channel | { logstash_one_channel | "host" =&gt; "ac2d4e3ef70f", logstash_one_channel | "habra_field" =&gt; "Hello Habr", logstash_one_channel | "message" =&gt; "4", logstash_one_channel | "@version" =&gt; "1", logstash_one_channel | "path" =&gt; "/usr/share/logstash/input/number1.log", logstash_one_channel | "@timestamp" =&gt; 2019-04-29T14:48:50.856Z logstash_one_channel | }</code> </pre><br>  الصيحة!  تم التقاط كل شيء. <br><br>  ولكن ، يجب أن نحذر مما يلي.  إذا تم حذف الحاوية التي تحتوي على logstash (عامل الإيقاف ، logstash_one_channel &amp;&amp; docker rm logstash_one_channel) ، فلن يتم التقاط أي شيء.  داخل الحاوية ، تم حفظ موضع الملف الذي تمت قراءته.  إذا تم التشغيل من نقطة الصفر ، فسيتم قبول الخطوط الجديدة فقط. <br><br><h3 style=";text-align:right;direction:rtl">  قراءة الملفات الموجودة </h3><br>  لنفترض أننا قمنا بتشغيل logstash لأول مرة ، ولكن لدينا بالفعل سجلات ونود معالجتها. <br>  إذا قمنا بتشغيل logstash باستخدام قسم الإدخال الذي استخدمناه أعلاه ، فلن نحصل على أي شيء.  سيتم معالجة الأسطر الجديدة فقط بواسطة logstash. <br><br>  من أجل سحب الخطوط من الملفات الموجودة ، أضف سطرًا إضافيًا إلى قسم الإدخال: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">input { file { start_position =&gt; "beginning" path =&gt; "/usr/share/logstash/input/*.log" } }</code> </pre><br>  علاوة على ذلك ، هناك فارق بسيط ، وهذا يؤثر فقط على الملفات الجديدة التي لم يرها logstash حتى الآن.  بالنسبة لنفس الملفات التي سقطت بالفعل في مجال عرض logstash ، فقد تذكر حجمها بالفعل وسيأخذ الآن إدخالات جديدة فيها فقط. <br><br>  دعونا نتناول دراسة قسم المدخلات.  هناك العديد من الخيارات ، لكن بالنسبة لنا ، يكفي إجراء مزيد من التجارب في الوقت الحالي. <br><br><h2 style=";text-align:right;direction:rtl">  التوجيه وتحويل البيانات </h2><br>  دعونا نحاول حل المشكلة التالية ، دعنا نقول أن لدينا رسائل من قناة واحدة ، بعضها إعلامي ، ورسالة خطأ جزئيًا.  تختلف في العلامة.  بعض المعلومات ، والبعض الآخر خطأ. <br><br>  نحن بحاجة إلى فصلها في الإخراج.  أي  نكتب رسائل إعلامية في قناة واحدة ، ورسائل خطأ في قناة أخرى. <br><br>  للقيام بذلك ، انتقل من قسم الإدخال إلى التصفية والإخراج. <br><br>  باستخدام قسم التصفية ، سنقوم بتحليل الرسالة الواردة ، ونستخرج منها تجزئة (أزواج قيمة المفتاح) ، والتي يمكنك العمل معها بالفعل ، أي  تفكيك حسب الظروف.  وفي قسم الإخراج ، نختار الرسائل ونرسل كل منها إلى قناتنا. <br><br><h3 style=";text-align:right;direction:rtl">  تحليل رسالة باستخدام grok </h3><br>  من أجل تحليل السلاسل النصية والحصول على مجموعة من الحقول منها ، هناك مكون إضافي خاص في قسم التصفية - grok. <br><br>  لا تهدف إلى إعطاء هنا وصفاً مفصلاً هنا (لهذا أشير إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الوثائق الرسمية</a> ) ، سأقدم مثالي البسيط. <br><br>  للقيام بذلك ، تحتاج إلى تحديد تنسيق خطوط الإدخال.  لدي لهم: <br><br>  1 INFO message1 <br>  2 رسالة خطأ 2 <br><br>  أي  يأتي المعرف أولاً ، ثم INFO / ERROR ، ثم بعض الكلمات بدون مسافات. <br>  ليست صعبة ، ولكن يكفي لفهم كيف يعمل. <br><br>  لذلك ، في قسم التصفية ، في البرنامج المساعد grok ، نحتاج إلى تحديد نمط لتحليل خطوطنا. <br><br>  سيبدو مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">filter { grok { match =&gt; { "message" =&gt; ["%{INT:message_id} %{LOGLEVEL:message_type} %{WORD:message_text}"] } } }</code> </pre><br>  هذا هو في الأساس تعبير منتظم.  يتم استخدام الأنماط الجاهزة ، مثل INT و LOGLEVEL و WORD.  وصفهم ، وكذلك أنماط أخرى ، ويمكن الاطلاع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا.</a> <br><br>  الآن ، مروراً بعامل التصفية هذا ، سوف تتحول السلسلة إلى تجزئة من ثلاثة حقول: message_id ، message_type ، message_text. <br><br>  سيتم عرضها في قسم الإخراج. <br><br><h3 style=";text-align:right;direction:rtl">  توجيه الرسائل في قسم الإخراج باستخدام الأمر if </h3><br>  في قسم المخرجات ، كما نتذكر ، كنا سنقسم الرسائل إلى دفقين.  بعض - وهو iNFO ، سوف نخرج إلى وحدة التحكم ، ومع وجود أخطاء ، سوف نخرج إلى ملف. <br><br>  كيف يمكننا تقسيم هذه الوظائف؟  شرط المشكلة يطالب بالفعل الحل - لدينا بالفعل حقل message_type المحدد ، والذي يمكن أن يأخذ قيمتين فقط INFO و ERROR.  هو بالنسبة له أننا سوف نختار خيار استخدام العبارة if. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">if [message_type] == "ERROR" { #     } else { #    stdout }</code> </pre><br>  يمكن العثور على وصف للعمل مع الحقول والمشغلين في هذا القسم من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الدليل الرسمي</a> . <br><br>  الآن ، حول الاستنتاج الفعلي نفسه. <br><br>  الإخراج إلى وحدة التحكم ، كل شيء واضح هنا - stdout {} <br><br>  وهنا هو الإخراج إلى الملف - تذكر أننا ندير كل شيء من الحاوية ، وبالتالي فإن الملف الذي نكتب النتيجة إليه يمكن الوصول إليه من الخارج ، نحتاج إلى فتح هذا الدليل في docker-compose.yml. <br><br>  المجموع: <br><br>  يبدو قسم الإخراج في ملفنا كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> output { if [message_type] == "ERROR" { file { path =&gt; "/usr/share/logstash/output/test.log" codec =&gt; line { format =&gt; "custom format: %{message}"} } } else {stdout { } } }</code> </pre><br>  في docker-compose.yml أضف وحدة تخزين أخرى لإخراجها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">version: '3' networks: elk: volumes: elasticsearch: driver: local services: logstash: container_name: logstash_one_channel image: docker.elastic.co/logstash/logstash:6.3.2 networks: - elk environment: XPACK_MONITORING_ENABLED: "false" ports: - 5046:5046 volumes: - ./config/pipelines.yml:/usr/share/logstash/config/pipelines.yml:ro - ./config/pipelines:/usr/share/logstash/config/pipelines:ro - ./logs:/usr/share/logstash/input - ./output:/usr/share/logstash/output</code> </pre><br>  نبدأ ، نحاول ، نرى التقسيم إلى قسمين. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar451264/">https://habr.com/ru/post/ar451264/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar451254/index.html">الفئة: الحديد أونبوإكسينغ موفر IaaS</a></li>
<li><a href="../ar451256/index.html">ما هو نظام الإبلاغ المثالي. هل من الواقعي أن نفهم ما يحدث في الشركة؟</a></li>
<li><a href="../ar451258/index.html">امسكني اذا استطعت. خطاب المدير</a></li>
<li><a href="../ar451260/index.html">10 أحداث موضوعية من جامعة ITMO</a></li>
<li><a href="../ar451262/index.html">علماء من جامعة ستانفورد: أداة يمكن وضعها في الأذن ستكون قادرة على مراقبة أداء الدماغ</a></li>
<li><a href="../ar451266/index.html">النمذجة ثلاثية الأبعاد في العالم الحديث</a></li>
<li><a href="../ar451268/index.html">فيكتور جاموف عن Kafka Streams IQ على jug.msk.ru</a></li>
<li><a href="../ar451270/index.html">ب = الاهتمام ، أو كيفية خلق الوقت</a></li>
<li><a href="../ar451272/index.html">إذا كنت تدق الباب بالفعل: كيفية حماية المعلومات على الأجهزة</a></li>
<li><a href="../ar451274/index.html">سلاح مثالي ، حرب وجهات نظر وإنسان يصل إلى السقف</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>