<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏽 🉑 🐤 Tabel hash di Go. Detail implementasi 🚽 🚒 😚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami akan membahas implementasi peta dalam bahasa tanpa obat generik, mempertimbangkan apa tabel hash, bagaimana ini diatur dalam Go, apa pro dan kont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tabel hash di Go. Detail implementasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457728/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb1/923/9cc/eb19239cc91d38445932da1ade5a5e7d.png" alt="gambar" width="400" height="400"></div><br><br>  Kami akan membahas implementasi peta dalam bahasa tanpa obat generik, mempertimbangkan apa tabel hash, bagaimana ini diatur dalam Go, apa pro dan kontra dari implementasi ini, dan apa yang harus Anda perhatikan ketika menggunakan struktur ini. <br><br>  Detail di bawah potongan. <br><a name="habracut"></a><br><hr><br>  Perhatian!  Jika Anda sudah terbiasa dengan tabel hash di Go, saya menyarankan Anda untuk melewatkan dasar-dasar dan pergi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , jika tidak ada risiko bosan saat yang paling menarik. <br><br><h4>  Apa itu tabel hash </h4><br>  Untuk memulainya, saya akan mengingatkan Anda apa itu tabel hash.  Ini adalah struktur data yang memungkinkan Anda untuk menyimpan pasangan nilai kunci, dan, sebagai aturannya, memiliki fungsi: <br><br><ul><li>  Pemetaan: <code>map(key) → value</code> <br></li><li>  Sisipan: <code>insert(map, key, value)</code> <br></li><li>  Penghapusan: <code>delete(map, key)</code> <br></li><li>  Cari: <code>lookup(key) → value</code> <br></li></ul><br><h4>  Tabel hash dalam bahasa go </h4><br>  Tabel hash dalam bahasa go diwakili oleh kata kunci peta dan dapat dideklarasikan dengan salah satu cara di bawah ini (selengkapnya tentang mereka nanti): <br><br><pre> <code class="go hljs"> m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) m := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{key1: val1, key2: val2}</code> </pre><br>  Operasi utama dilakukan sebagai berikut: <br><br><ul><li>  Masukkan: <br><br><pre> <code class="go hljs">m[key] = value</code> </pre> <br></li><li>  Penghapusan: <br><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">delete</span></span>(m, key)</code> </pre> <br></li><li>  Cari: <br><br><pre> <code class="go hljs">value = m[key]</code> </pre> <br>  atau <br><br><pre> <code class="go hljs">value, ok = m[key]</code> </pre> </li></ul><br><h4>  Pergi berkeliling meja di mana saja </h4><br>  Pertimbangkan program berikut: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { m[i] = ((i % <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"key: %d, value: %t\n"</span></span>, k, v) } }</code> </pre><br>  Peluncuran 1: <br><br><pre> <code class="plaintext hljs">key: 3, value: false key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true</code> </pre><br>  Jalankan 2: <br><br><pre> <code class="plaintext hljs">key: 4, value: true key: 0, value: true key: 1, value: false key: 2, value: true key: 3, value: false</code> </pre><br>  Seperti yang Anda lihat, output bervariasi dari satu menjalankan ke menjalankan.  Dan semua karena peta di Go tidak berurutan, artinya, tidak dipesan.  Ini berarti Anda tidak perlu bergantung pada pesanan saat berkeliling.  Alasannya dapat ditemukan dalam kode sumber runtime bahasa: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// mapiterinit initializes the hiter struct used for ranging over maps. func mapiterinit(t *maptype, h *hmap, it *hiter) {... // decide where to start r := uintptr(fastrand()) ... it.startBucket = r &amp; bucketMask(hB)...}</span></span></code> </pre><br>  Lokasi pencarian ditentukan <b>secara acak</b> , ingat ini!  Rumor mengatakan bahwa pengembang runtime memaksa pengguna untuk tidak bergantung pada pesanan. <br><br><h4>  Pergi mencari tabel </h4><br>  Mari kita lihat sepotong kode lagi.  Misalkan kita ingin membuat pasangan "angka" - "angka kali 10": <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} fmt.Println(m, m[<span class="hljs-number"><span class="hljs-number">0</span></span>], m[<span class="hljs-number"><span class="hljs-number">1</span></span>], m[<span class="hljs-number"><span class="hljs-number">2</span></span>]) }</code> </pre><br>  Kami meluncurkan: <br><br><pre> <code class="plaintext hljs">map[0:0 1:10] 0 10 0</code> </pre><br>  Dan kami melihat bahwa ketika kami mencoba untuk mendapatkan nilai dua (yang kami lupa letakkan) kami mendapat 0. Kami menemukan baris dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi yang</a> menjelaskan perilaku ini: “Upaya untuk mengambil nilai peta dengan kunci yang tidak ada di peta akan mengembalikan nilai nol untuk jenis entri di peta. ", tetapi diterjemahkan ke dalam bahasa Rusia, ini berarti bahwa ketika kami mencoba untuk mendapatkan nilai dari peta, tetapi tidak ada di sana, kami mendapatkan" nilai tipe nol ", yang dalam hal angka 0. Apa yang harus dilakukan, jika kita ingin membedakan antara kasus 0 dan tidak adanya 2?  Untuk melakukan ini, kami datang dengan bentuk khusus "penugasan berganda" - suatu bentuk di mana alih-alih nilai tunggal biasa, peta mengembalikan pasangan: nilai itu sendiri dan Boolean lain yang menjawab pertanyaan apakah kunci yang diminta ada di peta atau tidak " <br><br>  Potongan kode yang sebelumnya akan terlihat seperti ini: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} m2, ok := m[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-comment"><span class="hljs-comment">// somehow process this case m2 = 20 } fmt.Println(m, m[0], m[1], m2) }</span></span></code> </pre><br>  Dan saat startup, kami mendapatkan: <br><br> <code>map[0:0 1:10] 0 10 20 <br></code> <br><h4>  Buat tabel di Go. </h4><br>  Misalkan kita ingin menghitung jumlah kemunculan setiap kata dalam sebuah string, mulai kamus untuk ini dan lanjutkan. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, word := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>, <span class="hljs-string"><span class="hljs-string">"from"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"best"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span>, <span class="hljs-string"><span class="hljs-string">"in"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>} { m[word]++ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> m { <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(k, v) } }</code> </pre><br>  Apakah Anda melihat tangkapan <s>gopher</s> ?  - Dan dia! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c02/89f/536/c0289f53662657b012659f89d71add02.png" alt="gambar" width="200" height="400"></div><br>  Ketika kami mencoba memulai program semacam itu, kami mendapatkan kepanikan dan pesan "tugas untuk masuk di peta nil".  Dan semua karena mapa adalah tipe referensi dan tidak cukup untuk mendeklarasikan variabel, Anda perlu menginisialisasi: <br><br><pre> <code class="go hljs">m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)</code> </pre><br>  Sedikit lebih rendah akan jelas mengapa ini bekerja seperti ini.  Pada awalnya, sudah disajikan 4 cara untuk membuat peta, dua di antaranya kami periksa - deklarasi ini sebagai variabel dan pembuatan melalui make.  Anda juga dapat membuat menggunakan desain " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komposit literal</a> " <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[key_type]value_type{}</code> </pre> <br>  dan jika Anda ingin, bahkan segera menginisialisasi dengan nilai-nilai, metode ini juga valid.  Adapun pembuatan menggunakan baru - menurut saya, itu tidak masuk akal, karena fungsi ini mengalokasikan memori untuk variabel dan mengembalikan pointer ke itu diisi dengan nilai nol dari jenisnya, yang dalam kasus peta akan nihil (kami mendapatkan hasil yang sama seperti di var, lebih tepatnya sebuah pointer ke sana). <br><a name="GoMap"></a><br><h4>  Bagaimana peta diteruskan ke suatu fungsi? </h4><br>  Misalkan kita memiliki fungsi yang mencoba mengubah angka yang diteruskan ke sana.  Mari kita lihat apa yang terjadi sebelum dan sesudah panggilan: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { n = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { n := <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n before foo ="</span></span>, n) foo(n) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"n after foo ="</span></span>, n) }</code> </pre><br>  Sebuah contoh, saya pikir, cukup jelas, tetapi masih termasuk kesimpulan: <br><br><pre> <code class="plaintext hljs">n before foo = 15 n after foo = 15</code> </pre><br>  Seperti yang mungkin Anda tebak, fungsi n datang dengan nilai, bukan oleh referensi, sehingga variabel asli tidak berubah. <br><br>  Mari kita lakukan trik mapa yang serupa: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] before foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) foo(m) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"m[10] after foo ="</span></span>, m[<span class="hljs-number"><span class="hljs-number">10</span></span>]) }</code> </pre><br>  Dan lihatlah: <br><br><pre> <code class="go hljs">m[<span class="hljs-number"><span class="hljs-number">10</span></span>] before foo = <span class="hljs-number"><span class="hljs-number">15</span></span> m[<span class="hljs-number"><span class="hljs-number">10</span></span>] after foo = <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Nilainya telah berubah.  "Yah, Mapa disahkan dengan referensi?", Anda bertanya.  <b>Tidak.</b>  Tidak ada tautan di Go.  Tidak mungkin membuat 2 variabel dengan 1 alamat, seperti dalam C ++ misalnya.  Tapi kemudian Anda bisa membuat 2 variabel yang menunjuk ke alamat yang sama (tetapi ini adalah pointer, dan mereka dalam Go). <br><br>  Misalkan kita memiliki fungsi fn yang menginisialisasi peta m.  Pada fungsi utama, kita cukup mendeklarasikan variabel, mengirimkannya untuk menginisialisasi dan melihat apa yang terjadi setelahnya. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { m = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in fn?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fn(m) fmt.Println(<span class="hljs-string"><span class="hljs-string">"m == nil in main?:"</span></span>, m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre><br>  Kesimpulan: <br><br> <code>m == nil in fn?: false <br> m == nil in main?: true <br></code> <br>  Jadi, variabel m diteruskan <b>oleh nilai</b> , oleh karena itu, seperti dalam kasus meneruskan int reguler ke fungsi, itu tidak berubah (salinan lokal dari nilai dalam fn berubah).  Lalu mengapa nilai yang terletak pada m itu sendiri berubah?  Untuk menjawab pertanyaan ini, pertimbangkan kode dari runtime bahasa: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields }</span></span></code> </pre><br>  Map in Go hanyalah sebuah penunjuk ke struktur hmap.  Ini adalah jawaban untuk pertanyaan mengapa, terlepas dari kenyataan bahwa peta dilewatkan ke fungsi berdasarkan nilai, nilai-nilai itu sendiri di dalamnya berubah - itu semua tentang penunjuk.  Struktur hmap juga berisi yang berikut: jumlah elemen, jumlah "ember" (disajikan sebagai logaritma untuk mempercepat perhitungan), seeding untuk hash acak (untuk membuatnya lebih sulit untuk ditambahkan - coba mengambil kunci sehingga ada tabrakan terus-menerus), semua jenis bidang layanan dan yang paling penting, sebuah penunjuk ke kotak tempat nilai disimpan.  Mari kita lihat gambarnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/979/e11/792/979e11792b1b87cc2a2548ebd3bd1743.png" alt="gambar"><br><br>  Gambar ini menunjukkan gambar skematis dari struktur dalam memori - ada header hmap, penunjuk yang merupakan peta di Go (dibuat ketika dideklarasikan dengan var, tetapi tidak diinisialisasi, yang menyebabkan program macet ketika mencoba memasukkannya).  Bidang kotak adalah tempat penyimpanan pasangan nilai kunci, ada beberapa kotak seperti itu, masing-masing berisi 8 pasang.  Pertama di "bucket" adalah slot untuk bit hash tambahan (e0..e7 disebut e - karena bit hash <i>tambahan</i> ).  Berikutnya adalah kunci dan nilai sebagai daftar semua kunci terlebih dahulu, lalu daftar semua nilai. <br><br>  Menurut hash dari fungsi, ditentukan di mana "ember" kita beri nilai, di dalam setiap "ember" bisa ada hingga 8 tabrakan, di akhir setiap "ember" ada penunjuk ke yang lain, jika yang sebelumnya meluap. <br><br><h4>  Bagaimana peta itu tumbuh? </h4><br>  Di kode sumber, Anda dapat menemukan baris: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// Maximum average load of a bucket that triggers growth is 6.5.</span></span></code> </pre> <br>  yaitu, jika ada rata-rata lebih dari 6,5 elemen di setiap bucket, terjadi peningkatan susunan bucket.  Pada saat yang sama, array dialokasikan 2 kali lebih banyak, dan data lama disalin ke dalamnya dalam porsi kecil setiap penyisipan atau penghapusan, sehingga tidak membuat penundaan yang sangat besar.  Oleh karena itu, semua operasi akan sedikit lebih lambat dalam proses evakuasi data (saat mencari, kami juga harus mencari di dua tempat).  Setelah evakuasi yang berhasil, data baru mulai digunakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/c06/2aa/f00c062aa458e48d0475635e06a3697a.jpg" alt="gambar" width="300" height="300"></div><br><h4>  Mengambil alamat elemen peta. </h4><br>  Hal menarik lainnya - di awal menggunakan bahasa yang ingin saya lakukan seperti ini: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { m := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) m[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> a := &amp;m[<span class="hljs-number"><span class="hljs-number">1</span></span>] fmt.Println(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], *a) }</code> </pre><br>  Tapi Go mengatakan: "tidak dapat mengambil alamat m [1]".  Penjelasan mengapa tidak mungkin untuk mengambil alamat nilai terletak pada prosedur evakuasi data.  Bayangkan kita mengambil alamat nilai, dan kemudian mapa tumbuh, memori baru dialokasikan, data dievakuasi, yang lama dihapus, penunjuknya menjadi salah, sehingga operasi seperti itu dilarang. <br><br><h4>  Bagaimana peta diimplementasikan tanpa obat generik? </h4><br>  Baik antarmuka kosong, maupun pembuatan kode tidak ada hubungannya dengan itu, semuanya adalah untuk menggantikannya pada waktu kompilasi.  Pertimbangkan apa fungsi akrab dari Go berubah menjadi: <br><br><pre> <code class="plaintext hljs">v := m["k"] → func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer v, ok := m["k"] → func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) m["k"] = 9001 → func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer delete(m, "k") → func mapdelete(t *maptype, h *hmap, key unsafe.Pointer)</code> </pre><br>  Kami melihat bahwa ada fungsi akses map untuk mengakses, masing-masing untuk menulis dan menghapus mapassign dan mapdelete.  Semua operasi menggunakan unsafe.Pointer, yang tidak peduli apa yang ditunjukkannya, dan informasi tentang setiap nilai dijelaskan oleh <b>deskriptor tipe</b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> mapType <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { key *_type elem *_type ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> _type <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { size <span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span> alg *typeAlg ...} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> typeAlg <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { hash <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uintptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uintptr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function">...}</span></span></code> </pre><br>  MapType menyimpan deskriptor (_type) kunci dan nilai.  Untuk deskriptor tipe, operasi (typeAlg) perbandingan, mengambil hash, ukuran, dan sebagainya didefinisikan, jadi kami selalu tahu cara memproduksinya. <br><br>  Sedikit lagi tentang cara kerjanya.  Ketika kita menulis v = m [k] (mencoba mendapatkan nilai v dari kunci k), kompiler menghasilkan sesuatu seperti berikut: <br><br><pre> <code class="go hljs">kPointer := unsafe.Pointer(&amp;k) vPointer := mapaccess1(typeOf(m), m, kPointer) v = *(*typeOfvalue)vPointer</code> </pre><br>  Yaitu, kita mengambil sebuah pointer ke kunci, struktur mapType, dari mana kita menemukan deskriptor mana dari kunci dan nilai, pointer ke hmap itu sendiri (yaitu, peta) dan meneruskan semuanya ke mapaccess1, yang akan mengembalikan pointer ke nilai.  Kami mengarahkan pointer ke tipe yang diinginkan, dereference dan mendapatkan nilainya. <br><br>  Sekarang mari kita lihat kode pencarian dari runtime (yang sedikit disesuaikan untuk membaca): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *mapType, m *mapHeader, key unsafe.Pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pointer</span></span></span></span> {</code> </pre><br>  Fungsi mencari kunci di peta dan mengembalikan pointer ke nilai yang sesuai, argumen sudah akrab bagi kita - ini adalah mapType, yang menyimpan deskriptor dari jenis dan nilai kunci, memetakan sendiri (mapHeader) dan pointer ke memori yang menyimpan kunci.  Kami mengembalikan pointer ke memori yang menyimpan nilai. <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || m.count == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zero }</code> </pre><br>  Selanjutnya, kami memeriksa apakah pointer ke header peta tidak nol, jika ada 0 elemen di sana dan mengembalikan nilai nol, jika demikian. <br><br><pre> <code class="go hljs"> hash := t.key.hash(key, m.seed) <span class="hljs-comment"><span class="hljs-comment">// hash := hashfn(key) bucket := hash &amp; (1&lt;&lt;m.logB-1) // bucket := hash % nbuckets extra := byte(hash &gt;&gt; 56) // extra := top 8 bits of hash b := (*bucket)(add(m.buckets, bucket*t.bucketsize)) // b := &amp;m.buckets[bucket]</span></span></code> </pre><br>  Kami menghitung hash kunci (kami tahu cara menghitung kunci yang diberikan dari deskriptor tipe).  Lalu kami mencoba memahami "ember" mana yang perlu Anda tuju (sisa pembagian dengan jumlah "ember", perhitungannya hanya sedikit dipercepat).  Kemudian kita menghitung hash tambahan (kita mengambil 8 bit hash paling signifikan) dan menentukan posisi "ember" dalam memori (aritmatika alamat). <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.extra[i] != extra { <span class="hljs-comment"><span class="hljs-comment">// check 8 extra hash bits continue } k := add(b, dataOffset+i*t.key.size) // pointer to ki in bucket if t.key.equal(key, k) { // return pointer to vi return add(b, dataOffset+8*t.key.size+i*t.value.size) } } b = b.overflow if b == nil { return zero } }</span></span></code> </pre><br>  Cari, jika Anda melihat, tidak begitu rumit: kita pergi melalui rantai "ember", pindah ke yang berikutnya, jika Anda tidak menemukannya.  Pencarian di "bucket" dimulai dengan perbandingan cepat hash tambahan (itulah sebabnya e0 ... e7 di awal masing-masing adalah hash "mini" dari pasangan untuk perbandingan cepat).  Jika tidak cocok, melangkah lebih jauh, jika tidak, maka kami memeriksa lebih hati-hati - kami menentukan di mana kunci yang dicurigai dicari terletak di memori, membandingkan apakah itu sama dengan apa yang diminta.  Jika sama, tentukan posisi nilai dalam memori dan kembali.  Seperti yang Anda lihat, tidak ada yang supranatural. <br><br><h4>  Kesimpulan </h4><br>  Gunakan peta, tetapi ketahui dan pahami cara kerjanya!  Anda dapat menghindari menyapu dengan memahami beberapa seluk-beluk - mengapa Anda tidak dapat mengambil alamat nilainya, mengapa semuanya jatuh selama deklarasi tanpa inisialisasi, mengapa lebih baik mengalokasikan memori terlebih dahulu, jika jumlah elemen diketahui (kami akan menghindari evakuasi) dan banyak lagi. <br><br><hr><br>  Referensi: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pergi peta dalam aksi", Andrew Gerrand</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Bagaimana go runtime mengimplementasikan peta secara efisien", Dave Cheney</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Memahami tipe in go", William Kennedy</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi peta di dalam, Keith Randall</a> <br>  <a href="">kode sumber peta, Go Runtime</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">golang spec</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pergi efektif</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gambar gopher</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457728/">https://habr.com/ru/post/id457728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457714/index.html">Stack Overflow dalam bahasa Inggris: Community Kill Guide</a></li>
<li><a href="../id457718/index.html">HyperCard, tautan yang hilang dalam evolusi Web</a></li>
<li><a href="../id457720/index.html">Autodesk Maya: Berguna, fitur dasar untuk bekerja dengan model 3D</a></li>
<li><a href="../id457722/index.html">SQL: Masalah Waktu Kehadiran: Pembekalan</a></li>
<li><a href="../id457724/index.html">OpenCV pada STM32F7-Discovery</a></li>
<li><a href="../id457730/index.html">Di kantor ada ilusi kontrol - tidak ada di remote. Percakapan dengan Devhab</a></li>
<li><a href="../id457734/index.html">Revolusi Sumber Terbuka Italia Dimulai</a></li>
<li><a href="../id457736/index.html">"Alat tidak sepenting kemampuan untuk berpikir tentang sistem yang mereka buat." Wawancara hebat dengan Martin Kleppman</a></li>
<li><a href="../id457738/index.html">Bagaimana kami menerapkan SD-Access, dan mengapa itu diperlukan</a></li>
<li><a href="../id457742/index.html">Penskalaan otomatis horizontal Kubernet dan Prometheus untuk ketersediaan tinggi dan ketersediaan infrastruktur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>