<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôªÔ∏è üå∂Ô∏è üôåüèº An√°lisis de rendimiento de consultas en ClickHouse. Informe Yandex üëµüèø üç≤ ü•Ç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øQu√© pasa si su consulta de base de datos no se ejecuta lo suficientemente r√°pido? ¬øC√≥mo saber si una consulta utiliza los recursos inform√°ticos de ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lisis de rendimiento de consultas en ClickHouse. Informe Yandex</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/459198/">  ¬øQu√© pasa si su consulta de base de datos no se ejecuta lo suficientemente r√°pido?  ¬øC√≥mo saber si una consulta utiliza los recursos inform√°ticos de manera √≥ptima o puede acelerarse?  En la √∫ltima conferencia de HighLoad ++ en Mosc√∫, habl√© sobre la introspecci√≥n del rendimiento de las consultas, y sobre lo que proporciona el DBMS ClickHouse, y sobre las caracter√≠sticas del sistema operativo que todos deber√≠an conocer. <br><br><img src="https://habrastorage.org/webt/mi/yo/wu/miyowuhgorpfpl9zih8cszids0y.jpeg"><br><br>  Cada vez que hago una solicitud, me preocupa no solo el resultado, sino tambi√©n lo que hace esta solicitud.  Por ejemplo, funciona por un segundo.  ¬øEs mucho o poco?  Siempre pienso: ¬øpor qu√© no medio segundo?  Luego optimizo algo, lo acelero y funciona durante 10 ms.  Por lo general estoy satisfecho.  Pero a√∫n as√≠, en este caso trato de hacer una expresi√≥n facial disgustada y pregunto: "¬øPor qu√© no 5 ms?"  ¬øC√≥mo puedo saber cu√°nto tiempo pasa procesando la solicitud?  ¬øSe puede acelerar en principio? <br><br><a name="habracut"></a>  Por lo general, la velocidad de procesamiento de solicitudes es aritm√©tica simple.  Escribimos el c√≥digo, probablemente de manera √≥ptima, y ‚Äã‚Äãtenemos alg√∫n dispositivo en el sistema.  Los dispositivos tienen especificaciones.  Por ejemplo, la velocidad de lectura del cach√© L1.  O el n√∫mero de lecturas aleatorias que puede hacer un SSD.  Todos lo sabemos.  Necesitamos tomar estas caracter√≠sticas, sumar, restar, multiplicar, dividir y verificar la respuesta.  Pero esto es en el caso ideal, esto casi nunca sucede.  Casi.  De hecho, esto a veces sucede en ClickHouse. <br><br>  Considere los hechos triviales sobre qu√© dispositivos y qu√© recursos hay en nuestros servidores. <br><br><img src="https://habrastorage.org/webt/6e/gz/us/6egzusxqlzhg81ledkch36wrld4.jpeg" width="700"><br><br>  Procesador, memoria, disco, red.  Organic√© especialmente estos recursos de tal manera, comenzando por el m√°s simple y conveniente para su revisi√≥n y optimizaci√≥n, y terminando con el m√°s inconveniente y complejo.  Por ejemplo, ejecuto una solicitud y veo que mi programa parece descansar en la CPU.  ¬øQu√© significa esto?  Lo que encontrar√© es alg√∫n tipo de bucle interno, una funci√≥n que se ejecuta con mayor frecuencia, reescribe el c√≥digo, vuelve a compilar y, una vez, mi programa se ejecuta m√°s r√°pido. <br><br>  Si gastas demasiada RAM, entonces todo es un poco m√°s complicado.  Necesita repensar la estructura de datos, exprimir algunos bits.  En cualquier caso, reinicio mi programa y gasta menos RAM.  Es cierto que esto es a menudo en detrimento del procesador. <br><br>  Si todo depende de los discos, entonces esto tambi√©n es m√°s dif√≠cil, porque puedo cambiar la estructura de datos en el disco, pero tengo que convertir estos datos m√°s tarde.  Si hago una nueva versi√≥n, la gente tendr√° que hacer alg√∫n tipo de migraci√≥n de datos.  Resulta que el disco ya es mucho m√°s complicado, y es mejor pensarlo de antemano. <br><br>  Una red ... Realmente no me gusta una red, porque a menudo no est√° completamente claro lo que est√° sucediendo en ella, especialmente si es una red entre continentes, entre centros de datos.  Algo se est√° desacelerando all√≠, y ni siquiera es su red, ni su servidor, y no puede hacer nada.  Lo √∫nico que puede pensar de antemano es c√≥mo se transmitir√°n los datos y c√≥mo minimizar la interacci√≥n en la red. <br><br>  Sucede que no se utiliza un solo recurso en el sistema, y ‚Äã‚Äãel programa solo est√° esperando algo.  De hecho, este es un caso muy com√∫n, porque nuestro sistema est√° distribuido, y puede haber muchos procesos y flujos diferentes, y algunos est√°n esperando a otro, y todo esto debe estar conectado de alguna manera entre s√≠ para considerarlo adecuadamente. <br><br><img src="https://habrastorage.org/webt/vq/mk/sa/vqmksaynboi4frop2kzfcvk9q4w.jpeg" width="700"><br><br>  Lo m√°s simple es observar la utilizaci√≥n de los recursos, en alg√∫n valor num√©rico.  Por ejemplo, comienzas algo superior, y √©l escribe: el procesador es 100%.  O ejecute iostat, y √©l escribe: los discos son 100%.  Es cierto que esto a menudo no es suficiente.  Una persona ver√° que el programa se basa en discos.  Que se puede hacer  Simplemente puede notar esto y descansar, decidir que todo, nada puede optimizarse.  Pero, de hecho, cada uno de los dispositivos dentro de s√≠ mismo es bastante complicado.  El procesador tiene un mont√≥n de dispositivos inform√°ticos para diferentes tipos de operaciones.  Los discos pueden tener una matriz RAID.  Si hay un SSD, entonces hay dentro de su propio procesador, su propio controlador, lo que hace que no est√© claro qu√©.  Y un valor, 50% o 100%, no es suficiente.  La regla b√°sica: si ve que alg√∫n recurso se utiliza al 100%, no se rinda.  A menudo, a√∫n puedes mejorar algo.  Pero sucede y viceversa.  Digamos que ve que el reciclaje es del 50%, pero no se puede hacer nada. <br><br>  Echemos un vistazo m√°s de cerca a esto. <br><br><img src="https://habrastorage.org/webt/pa/wj/uo/pawjuoieudajqc097ysekq30wnc.jpeg" width="700"><br><br>  El recurso m√°s f√°cil y conveniente es el procesador.  Te ves en la parte superior, dice que el procesador es 100%.  Pero debe tenerse en cuenta que este no es un procesador 100%.  El programa superior no sabe qu√© hace el procesador all√≠.  Ella mira desde la perspectiva del planificador del sistema operativo.  Es decir, ahora se est√° ejecutando alg√∫n tipo de subproceso de programa en el procesador.  El procesador hace algo, y luego se mostrar√° el 100% si se promedia con el tiempo.  Al mismo tiempo, el procesador est√° haciendo algo y no est√° claro qu√© tan efectivo es.  Puede ejecutar un n√∫mero diferente de instrucciones por ciclo.  Si hay pocas instrucciones, el propio procesador puede esperar algo, por ejemplo, cargar datos desde la memoria.  Al mismo tiempo, se mostrar√° lo mismo en la parte superior: 100%.  Estamos esperando que el procesador siga nuestras instrucciones.  Y lo que hace por dentro no est√° claro. <br><br>  Finalmente, solo hay un rastrillo cuando crees que tu programa se basa en el procesador.  Esto es cierto, pero por alguna raz√≥n el procesador tiene una frecuencia m√°s baja.  Puede haber muchas razones: sobrecalentamiento, limitaci√≥n de potencia.  Por alguna raz√≥n, en el centro de datos hay una limitaci√≥n de energ√≠a, o simplemente se puede activar el ahorro de energ√≠a.  Luego, el procesador cambiar√° constantemente de una frecuencia m√°s alta a una m√°s baja, pero si su carga es inestable, esto no ser√° suficiente y, en promedio, el c√≥digo se ejecutar√° m√°s lentamente.  Vea el turbostato para la frecuencia actual del procesador.  Verifique el sobrecalentamiento en dmesg.  Si sucediera algo as√≠, dir√≠a: ‚ÄúSobrecalentamiento.  Frecuencia bajada. <br><br>  Si est√° interesado en la cantidad de errores de cach√© que hay dentro, cu√°ntas instrucciones se ejecutan por ciclo, use el registro de rendimiento.  Grabe alguna muestra del programa.  Adem√°s, ser√° posible mirarlo utilizando estad√≠sticas de rendimiento o informe de rendimiento. <br><br><img src="https://habrastorage.org/webt/hl/4v/up/hl4vupofzsuha-s7cyxtba-po0c.jpeg" width="600"><br><br>  Y viceversa.  Digamos que miras hacia arriba y el procesador tiene menos del 50% de reciclaje.  Suponga que tiene 32 n√∫cleos de procesador virtual en su sistema y 16 n√∫cleos f√≠sicos. En los procesadores Intel, esto se debe a que el hiperprocesamiento es doble.  Pero esto no significa que los n√∫cleos adicionales sean in√∫tiles.  Todo depende de la carga.  Supongamos que tiene algunas operaciones de √°lgebra lineal bien optimizadas o tiene hashes para extraer bitcoins.  Luego, el c√≥digo ser√° claro, se ejecutar√°n muchas instrucciones por ciclo, no habr√° errores de cach√©, predicciones err√≥neas de ramificaciones tambi√©n.  E hiperprocesamiento no ayuda.  Ayuda cuando tienes un n√∫cleo esperando algo, mientras que el otro puede ejecutar simult√°neamente instrucciones desde otro hilo. <br><br>  ClickHouse tiene ambas situaciones.  Por ejemplo, cuando hacemos agregaci√≥n de datos (GROUP BY) o filtrado por conjunto (subconsulta IN), tendremos una tabla hash.  Si la tabla hash no cabe en el cach√© del procesador, se producir√°n errores de cach√©.  Esto dif√≠cilmente se puede evitar.  En este caso, el hiperprocesamiento nos ayudar√°. <br><br>  De manera predeterminada, ClickHouse usa solo n√∫cleos de procesadores f√≠sicos, excluyendo hyper-threading.  Si sabe que su solicitud puede beneficiarse del hiperprocesamiento, solo duplique el n√∫mero de subprocesos: SET max threads = 32, y su solicitud ser√° m√°s r√°pida. <br><br>  Sucede que el procesador se usa perfectamente, pero mira el gr√°fico y ve, por ejemplo, el 10%.  Y su horario, por ejemplo, es de cinco minutos en el peor de los casos.  Incluso si es un segundo, todav√≠a hay alg√∫n tipo de valor promedio.  De hecho, constantemente ten√≠a solicitudes, se ejecutan r√°pidamente, en 100 ms por segundo, y esto es normal.  Porque ClickHouse intenta ejecutar la solicitud lo m√°s r√°pido posible.  √âl no intenta usar y sobrecalentar completa y constantemente sus procesadores. <br><br><img src="https://habrastorage.org/webt/39/ka/ei/39kaeie-ngofbbynsnlq4mum_d0.jpeg" width="700"><br><br>  Echemos un vistazo m√°s de cerca, una opci√≥n un poco complicada.  Hay una consulta con una expresi√≥n en subconsulta.  Dentro de la subconsulta, tenemos 100 millones de n√∫meros aleatorios.  Y simplemente filtramos este resultado. <br><br>  Vemos una imagen as√≠.  Por cierto, ¬øqui√©n dir√° con qu√© herramienta puedo ver esta maravillosa imagen?  Absolutamente cierto - perf.  Estoy muy contento de que sepas esto. <br><br>  Abr√≠ perf, pensando que ahora entiendo todo.  Abro la lista de ensambladores.  All√≠ escrib√≠ con qu√© frecuencia la ejecuci√≥n del programa se realiz√≥ en una instrucci√≥n en particular, es decir, con qu√© frecuencia hubo un puntero de instrucci√≥n.  Aqu√≠ los n√∫meros est√°n en porcentaje, y est√° escrito que casi el 90% de las veces se ejecut√≥ la instrucci√≥n% edx,% edx, es decir, verificar cuatro bytes para cero. <br><br>  La pregunta es: ¬øpor qu√© un procesador puede tardar tanto en simplemente comparar cuatro bytes con cero?  (respuestas de la audiencia ...) No hay resto de la divisi√≥n.  Hay cambios de bit, luego hay una instrucci√≥n crc32q, pero como si el puntero de instrucci√≥n nunca ocurriera en ella.  Y la generaci√≥n de n√∫meros aleatorios no est√° en este listado.  Hab√≠a una funci√≥n separada, y est√° muy bien optimizada, no se ralentiza.  Algo m√°s se est√° desacelerando aqu√≠.  La ejecuci√≥n del c√≥digo se detiene en esta instrucci√≥n y pasa mucho tiempo.  Idle loop?  No  ¬øPor qu√© deber√≠a insertar bucles vac√≠os?  Adem√°s, si inserto el bucle inactivo, eso tambi√©n ser√≠a visible en perf.  No hay divisi√≥n por cero, simplemente hay una comparaci√≥n con cero. <br><br>  El procesador tiene una tuber√≠a, puede ejecutar varias instrucciones en paralelo.  Y cuando el puntero de la instrucci√≥n est√° en alg√∫n lugar, esto no significa en absoluto que est√© ejecutando esta instrucci√≥n.  Tal vez est√° esperando otras instrucciones. <br><br>  Tenemos una tabla hash para verificar que alg√∫n n√∫mero ocurra en alg√∫n conjunto.  Para esto, hacemos una b√∫squeda en la memoria.  Cuando hacemos una b√∫squeda en la memoria, tenemos una falta de memoria cach√©, ya que la tabla hash contiene 100 millones de n√∫meros, no se garantiza que quepa en ninguna memoria cach√©.  Entonces, para ejecutar la instrucci√≥n de verificaci√≥n cero, estos datos ya deber√≠an estar cargados desde la memoria.  Y esperamos hasta que se carguen. <br><br><img src="https://habrastorage.org/webt/w9/7b/ed/w97bediv43zlhfvat95k7qdar3k.jpeg" width="700"><br><br>  Ahora el siguiente recurso, un poco m√°s complejo: las unidades.  Los SSD tambi√©n se denominan a veces unidades, aunque esto no es del todo correcto.  Las SSD tambi√©n se incluir√°n en este ejemplo. <br><br>  Abrimos, por ejemplo, iostat, muestra una utilizaci√≥n del 100%. <br><br>  En las conferencias, a menudo sucede que el orador sube al escenario y dice con pathos: ‚ÄúLas bases de datos siempre se apoyan en el disco.  Por lo tanto, creamos una base de datos en memoria.  Ella no disminuir√° la velocidad ".  Si una persona se te acerca y te lo dice, puedes enviarlo con seguridad.  Habr√° algunos problemas: dices que lo resolv√≠.  :) <br><br>  Supongamos que un programa se basa en discos, la utilizaci√≥n es 100. Pero esto, por supuesto, no significa que usemos discos de manera √≥ptima. <br><br>  Un ejemplo t√≠pico es cuando solo tienes mucho acceso aleatorio.  Incluso si el acceso es secuencial, simplemente lee el archivo secuencialmente, pero a√∫n puede ser m√°s o menos √≥ptimo. <br><br>  Por ejemplo, tiene una matriz RAID, varios dispositivos, por ejemplo, 8 discos.  Y solo lee de forma secuencial sin leer con anticipaci√≥n, con un tama√±o de b√∫fer de 1 MB, y el tama√±o del fragmento en su banda en RAID tambi√©n es de 1 MB.  Luego, cada lectura que tendr√° de un dispositivo.  O, si no est√° alineado, desde dos dispositivos.  Medio megabyte ir√° a alguna parte, otro medio megabyte a otra parte, y as√≠ sucesivamente: los discos se utilizar√°n por turnos: uno, luego otro, luego un tercero. <br><br>  Necesita ser le√≠do con anticipaci√≥n.  O, si tiene O_DIRECT, aumente el tama√±o del b√∫fer.  Es decir, la regla es: 8 discos, tama√±o de fragmento 1 MB, establezca el tama√±o del b√∫fer en al menos 8 MB.  Pero esto funcionar√° de manera √≥ptima solo si la lectura est√° alineada.  Y si no est√° alineado, primero habr√° piezas adicionales, y debe poner m√°s, multiplicar por unas pocas m√°s. <br><br>  O, por ejemplo, tiene RAID 10. ¬øCon qu√© velocidad puede leer desde RAID 10, por ejemplo, desde 8 discos?  ¬øCu√°l ser√° la ventaja?  Cu√°druple, porque hay un espejo, u ocho veces?  En realidad, depende de c√≥mo se crea el RAID, con qu√© disposici√≥n de trozos en franjas. <br><br>  Si usa mdadm en Linux, puede especificar el dise√±o cercano y el dise√±o lejano all√≠, siendo casi mejor para escribir, lejos para leer. <br><br>  Siempre recomiendo usar un dise√±o lejano, porque cuando escribes en la base de datos anal√≠tica, generalmente no es tan cr√≠tico en el tiempo, incluso si hay mucha m√°s escritura que lectura.  Esto se hace mediante alg√∫n proceso en segundo plano.  Pero cuando lees, debes completarlo lo m√°s r√°pido posible.  Por lo tanto, es mejor optimizar RAID para lectura configurando un dise√±o lejano. <br><br>  Por suerte, en Linux mdadm lo establecer√° en un dise√±o cercano de forma predeterminada, y obtendr√° solo la mitad del rendimiento.  Hay muchos rastrillos de este tipo. <br><br>  Otro rastrillo terrible es RAID 5 o RAID 6. Todo escala bien all√≠ mediante lecturas y escrituras secuenciales.  En RAID 5, la multiplicidad es "el n√∫mero de dispositivos menos uno".  Esto escala bien incluso con lecturas aleatorias, pero no escala bien con lecturas aleatorias.  Haga un registro en cualquier lugar, y necesita leer los datos de todos los otros discos, introducirlos (XOR - aprox. Ed.) Y escribir en otro lugar.  Para esto, se utiliza un cierto cach√© de tiras, un rastrillo terrible.  En Linux, de manera predeterminada, se crea RAID 5 y se ralentizar√°.  Y pensar√°s que RAID 5 siempre se ralentiza, porque esto es comprensible.  Pero, de hecho, la raz√≥n es la configuraci√≥n incorrecta. <br><br>  Otro ejemplo.  Est√°s leyendo desde un SSD, y te compraste un buen SSD, dice 300 mil lecturas aleatorias por segundo en la especificaci√≥n.  Y por alguna raz√≥n no puedes hacerlo.  Y usted piensa: s√≠, todos ellos se encuentran en sus especificaciones, no existe tal cosa.  Pero todas estas lecturas deben hacerse en paralelo, con el m√°ximo grado de paralelismo.  La √∫nica forma de hacer esto de manera √≥ptima es usar E / S as√≠ncrona, que se implementa usando las llamadas al sistema io_submit, io_getevents, io_setup, etc. <br><br>  Por cierto, los datos en el disco, si los almacena, siempre necesita comprimir.  Dar√© un ejemplo de la pr√°ctica.  Una persona nos contact√≥ en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chat de soporte de</a> ClickHouse y dijo: <br><br>  - ClickHouse comprime los datos.  Veo que descansa en el procesador.  Tengo SSD NVMe muy r√°pidos, tienen una velocidad de lectura de varios gigabytes por segundo.  ¬øEs posible de alguna manera deshabilitar la compresi√≥n en ClickHouse? <br>  "No, de ninguna manera", le digo.  - Necesita mantener los datos comprimidos. <br>  - Deteng√°monos, solo habr√° otro algoritmo de compresi√≥n que no hace nada. <br>  - F√°cil  Ingrese estas letras en esta l√≠nea de c√≥digo. <br>  "De hecho, todo es muy simple", respondi√≥ un d√≠a despu√©s.  - Lo hice <br>  - ¬øCu√°nto ha cambiado el rendimiento? <br>  "No se pudo probar", escribi√≥ otro d√≠a despu√©s.  - Hay demasiados datos.  Ya no caben en SSD. <br><br>  Veamos ahora c√≥mo se ver√≠a la lectura del disco.  Comenzamos dstat, muestra la velocidad de lectura. <br><br><div class="spoiler">  <b class="spoiler_title">El primer ejemplo de dstat y iostat</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tp/bv/hc/tpbvhccpx_oezqb-bl61xfhcrtq.gif"><br></div></div><br>  Aqu√≠ est√° la columna de lectura: 300 MB / s.  Leemos de discos.  Es mucho o poco, no lo s√©. <br><br>  Ahora ejecuto iostat para verificar esto.  Aqu√≠ puedes ver el desglose por dispositivo.  Tengo RAID, md2 y ocho discos duros.  Cada uno de ellos muestra reciclaje, ni siquiera alcanza el 100% (50-60%).  Pero lo m√°s importante es que leo de cada disco solo a una velocidad de 20-30 MB / s.  Y desde peque√±o record√© la regla de que puedes leer en alg√∫n lugar desde 100 MB / s desde el disco duro.  Por alguna raz√≥n, esto todav√≠a no ha cambiado mucho. <br><br><div class="spoiler">  <b class="spoiler_title">Segundo ejemplo de dstat y iostat</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/yv/x-/wf/yvx-wf4ufaglo2ehwozvvh1mj48.gif"><br></div></div><br>  Aqu√≠ hay otro ejemplo.  La lectura es m√°s √≥ptima.  Ejecuto dstat y tengo una velocidad de lectura de 1 GB / s de este RAID 5 de ocho unidades.  ¬øQu√© muestra iostat?  S√≠, casi 1 GB / s. <br><br>  Ahora las unidades est√°n finalmente cargadas al 100%.  Es cierto, por alguna raz√≥n, dos son 100%, y el resto son 95%.  Probablemente, todav√≠a son un poco diferentes.  Pero con cada uno de ellos leo 150 MB / s, incluso m√°s genial de lo que puede ser.  Cual es la diferencia  En el primer caso, le√≠ con un tama√±o de b√∫fer insuficiente en piezas insuficientes.  Es simple, te digo verdades comunes. <br><br>  Por cierto, si cree que los datos a√∫n no necesitan ser comprimidos para la base de datos anal√≠tica, es decir, un informe de la conferencia HighLoad ++ Siberia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habrastaty basado en el informe</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aprox</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ed</a> .).  Los organizadores decidieron hacer los informes m√°s duros en Novosibirsk. <br><br><img src="https://habrastorage.org/webt/pu/6k/kp/pu6kkpnztqtp_elvxpta__ya8f0.jpeg" width="700"><br><br>  El siguiente ejemplo es la memoria.  Continuando con verdades comunes.  Primero, en Linux, nunca vea lo que muestra gratis.  Para aquellos que est√°n mirando, crearon especialmente el sitio linuxatemyram.com.  Adelante, habr√° una explicaci√≥n.  Tampoco necesita mirar la cantidad de memoria virtual, porque ¬øcu√°l es la diferencia, cu√°nto espacio de direcciones ha asignado el programa?  Mira cu√°nta memoria f√≠sica se usa. <br><br>  Y un rastrillo m√°s con el que ni siquiera est√° claro c√≥mo luchar.  Recuerde: el hecho de que a los asignadores a menudo no les gusta dar memoria al sistema es normal.  Hicieron mmap, pero munmap ya no lo hace.  La memoria no volver√° al sistema.  El programa piensa: s√© mejor c√≥mo usar√© la memoria.  Me lo dejo a m√≠ mismo.  Porque las llamadas al sistema mmap y munmap son bastante lentas.  Cambiar el espacio de direcciones, restablecer los cach√©s TLB del procesador; es mejor no hacerlo.  Sin embargo, el sistema operativo todav√≠a tiene la capacidad de liberar memoria correctamente utilizando la llamada al sistema madvise.  El espacio de direcciones permanecer√°, pero f√≠sicamente la memoria se puede descargar. <br><br>  Y nunca habilite el intercambio en servidores de producci√≥n con bases de datos.  Usted piensa: no hay suficiente memoria, incluir√© el intercambio.  Despu√©s de eso, la solicitud dejar√° de funcionar.  Romper√° el tiempo sin fin. <br><br><img src="https://habrastorage.org/webt/mb/0d/2n/mb0d2nmqxl5zq7hu5foyae9ir40.jpeg" width="650"><br><br>  Con una red de rastrillo demasiado t√≠pica.  Si crea una conexi√≥n TCP cada vez, se tarda un tiempo antes de seleccionar el tama√±o de ventana correcto, ya que el protocolo TCP no sabe qu√© tan r√°pido ser√° necesario transmitir datos.  Se adapta a esto. <br><br>  O imagine: est√° transfiriendo un archivo y tiene una gran latencia en su red y una p√©rdida de paquetes decente.  Entonces no es del todo obvio si es correcto usar TCP para transferir archivos.  Creo que est√° mal, ya que TCP garantiza la coherencia.  Por otro lado, puede transferir la mitad del archivo y la otra al mismo tiempo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use al menos varias conexiones TCP o no use TCP en absoluto para la transferencia de datos. </font><font style="vertical-align: inherit;">Supongamos que si descarga datos, pel√≠culas y programas de TV con torrentes, TCP no se puede usar all√≠. </font><font style="vertical-align: inherit;">Y los datos necesitan ser comprimidos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si tiene una red de 100 gigabits dentro del bastidor, no puede comprimirla. </font><font style="vertical-align: inherit;">Pero si tiene 10 gigabits entre centros de datos, especialmente entre Europa y Estados Unidos, entonces qui√©n sabe c√≥mo se arrastrar√°n sus bytes bajo el oc√©ano. </font><font style="vertical-align: inherit;">Exprimirlos. </font><font style="vertical-align: inherit;">Deje arrastrar menos bytes. </font></font><br><br><img src="https://habrastorage.org/webt/xy/ch/_m/xych_mjdelh5uydffukjrxzbf-k.jpeg" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øTodos vieron esta foto? </font><font style="vertical-align: inherit;">Si todo es lento en el sistema, tiene las herramientas necesarias. </font><font style="vertical-align: inherit;">Comenzar√° a usarlos, comenzar√° a lidiar con el problema y, por experiencia, encontrar√° otros 10 problemas. </font><font style="vertical-align: inherit;">Estas herramientas son lo suficientemente potentes como para mantenerte ocupado durante mucho tiempo.</font></font><br><br><img src="https://habrastorage.org/webt/mp/p_/bq/mpp_bqykipgfxtbiu6i8_a4xfpm.jpeg" width="400"><br><br>   : ¬´   -  ¬ª ‚Äî          .      iotop,  ,           ,   iops. <br><br>         ,     .  . <br><br><div class="spoiler"> <b class="spoiler_title">: top  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/8r/3l/wg/8r3lwg_u4l6bexuezkp-s3kdvno.gif"><br></div></div><br>   top  -,   ,  clickHouse-server  -  , -  .   ,   ,    Shift+H,      .    ,  ClickHouse  .   ParalInputsProc,   .  BackgrProcPool ‚Äî   merges     .   ,            . <br><br>    ?     ClickHouse,  ,     .    BackgroundProcessingPool.     15 . 16  1,  1 ‚Äî   .  16?  ,    Linux ‚Äî   ,  : ¬´16 .  ¬ª.  :) <br><br>        clickhouse-benchmark.        clickhouse-client.    ,    clickhouse-client,  .      -         .             . <br><br><div class="spoiler"> <b class="spoiler_title">: clickhouse-benchmark + perf top</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bu/ol/_g/buol_gwiuvuqmnn3xxxzpkafc6g.gif"><br></div></div><br>         .  clickhouse-benchmark,  ,      ,   ,     ,           .       peft top.   peft top,       .  ,    -     -,      uniq: UniquesHashSet.  .    ,   .      ,   . <br><br>  , ,    .        ‚Äî   -.    ,  , XOR  -  .   -.        -   -.      ,              -. <br><br>     , , crc32q.         ,        ,     -   ,       -   . <br><br>     ,        ClickHouse.            , ,   .       ClickHouse. <br><br><img src="https://habrastorage.org/webt/je/ki/1x/jeki1xaabpztoth-0ixuuq5abny.jpeg" width="700"><br><br>     .  ,    ‚Äî  ,   SHOW PROCESSLIST.   .    ,  SELECT * FROM system processes.       :  , ,   .     ClickHouse top. <br><br>     ClickHouse ?       background-. Background- ‚Äî    merges.   ,  merges ,    SELECT * FROM system.merges. <br><br><div class="spoiler"> <b class="spoiler_title"> c </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pb/gd/b3/pbgdb3f6o8qyvh6ez81heoo82tu.gif"><br></div></div><br> ,   .  -.    .  ‚Äî  ClickHouse.       .      ,  ,  . ,       . - traf_testing.  ?   ,       ,       .   ClickHouse  . <br><br><img src="https://habrastorage.org/webt/ni/aj/ro/niajrokowxcc2bp1n2ookwy8ljy.jpeg" width="700"><br><br>  .    ,      . ,    ,  ,    ,     .   query_log.        ‚Äî      ,   -    ,  SELECT ,    -  .   query_log     ,    .   -     .    ‚Äî    ,    .     :       . <br><br> ,  ,      ‚Äî merge, inserts,   .      part_log.      ,      . <br><br><img src="https://habrastorage.org/webt/lt/vn/cp/ltvncpwym4jc0qpjpofzygrb9qs.jpeg" width="700"><br><br>   query_log   clickhouse-benchmark.   select  ,    ,      stdin  clickhouse-benchmark. <br><br>     query_log  -   ,       . <br><br><img src="https://habrastorage.org/webt/zh/pm/tt/zhpmttv4oacr3fqnvanjwhrdsdg.jpeg" width="450"><br><br>       ,  ,   .     .     SET send_logs_level = 'trace',       ,    . <br><br><div class="spoiler"> <b class="spoiler_title">:  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/3z/l0/g9/3zl0g92l6zqdt7gxtqogm-wt-ai.gif"><br></div></div><br> ,   .  ,     98%.   ,       .  Es muy simple  SET send_logs_level = 'trace',  ,    .  - : merging aggregated data,   .       1% .       ,    . <br><br>        ,   ,      query_log. <br><br>  . SELECT * FROM system.query_log    .  . ,   ,     ,      query_log. .      ‚Äî  ,    ,   ,       . . <br><br><img src="https://habrastorage.org/webt/6h/em/o3/6hemo3c8u8d4qv2bwxlt-xa0x_w.jpeg" width="470"><br><br>   ClickHouse   .   ‚Äî           system.events, system.metrics  system.asynchronous_metrics. Events ‚Äî    , ,     . 100 .          ‚Äî 10 .  system.metrics ‚Äî     . ,     10 ,     10  . <br><br>  system.asynchronous_metrics     ,     .  .          ‚Äî   .  , system.asynchronous_metrics ‚Äî  ,     - . ,   . <br><br>       ,     .      SHOW PROCESSLIST       .  query_log,        . <br><br><img src="https://habrastorage.org/webt/0p/cp/1r/0pcp1rjgl8aj4w29tcnj73n5eay.jpeg" width="520"><br><br> ,   .  ,    . ,   .   ,    ,       .   ,     Linux,   .    Linux    .     ,     .  ,    .      . <br><br> , OSReadChars  OSReadBytes.   ?  ,       ,        ,     .   ,        .   ,       ,         ,   .  ,   -      ,      . <br><br><div class="spoiler"> <b class="spoiler_title">  page cache</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ft/zd/z3/ftzdz3ycxppmbghwuxu108y3rcs.gif"><br></div></div><br> ,   .    - .  ,  40    , 6,7 . . ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . , , . <br><br>      ,    1,3 ,  5  .  Por qu√© ,     ‚Äî      page cache.         ? <br><br><div class="spoiler"> <b class="spoiler_title"> c  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hr/cj/as/hrcjasfstnujjgo-fx9ene7t1g0.gif"><br></div></div><br>     .       . ,   ,        .   .     :     3,2 ,    ‚Äî 2,5 . , ,         ,   .  Por qu√© -, :  read ahead.        ,       ‚Äî  ? -,         ‚Äî 4  , , 512 KB.     .    ,     .   ,  - read ahead. <br><br><img src="https://habrastorage.org/webt/dj/nb/kj/djnbkjh9mdniw34_odlupzqigfa.jpeg" width="700"><br><br>      .      .     ,     . , , ReadBytes ‚Äî  ,     .  3 ,     3 .  ,   ,    . <br><br>    ‚Äî IOWait. 87 .    7 ,  IOWait ‚Äî 87. ?  ‚Äî    .     .   ,      ,     87 .       ,  - . <br><br>    ‚Äî CPUWait.     ,  ,       ,       .  -     ‚Äî ,   .      CPU.         CPU.      - ,    .        ‚Äî ,  ,   user space.    ,     - .  Bien <br><br>  ‚Äî  ,    Linux.         - ,    .    , ,       . <br><br><div class="spoiler"> <b class="spoiler_title">: query_thread_log</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fq/py/tf/fqpytfrrdsz4nxr8179r4pklzkm.gif"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y ahora lo m√°s avanzado que tenemos: query_thread_log. </font><font style="vertical-align: inherit;">Con √©l, puede comprender en qu√© perdi√≥ el tiempo cada ejecuci√≥n de consulta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Busco mi solicitud, selecciono por query_id e indico la m√©trica "La cantidad de tiempo de procesador empleado en el espacio del usuario". </font><font style="vertical-align: inherit;">Aqu√≠ est√°n nuestras corrientes. </font><font style="vertical-align: inherit;">Para el procesamiento paralelo de la solicitud, se asignaron 16 hilos. </font><font style="vertical-align: inherit;">Cada uno de ellos pas√≥ 800 ms. </font><font style="vertical-align: inherit;">Y luego se asignaron otros 16 subprocesos para la fusi√≥n del estado de las funciones agregadas, se gastaron 0.25 s en cada uno de ellos. </font><font style="vertical-align: inherit;">Ahora puedo entender exactamente lo que cada solicitud tom√≥ tiempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informe en video sobre HighLoad ++:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ondHe_JUyW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459198/">https://habr.com/ru/post/459198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459182/index.html">GitLab: con el lanzamiento de la versi√≥n 12.1, dejamos de admitir MySQL</a></li>
<li><a href="../459184/index.html">Habilidades de unidad b√°sica</a></li>
<li><a href="../459188/index.html">Debian 10 Buster y Linux 5.2 lanzados</a></li>
<li><a href="../459194/index.html">C√≥mo nos hicimos amigos de SCSS con las variables CSS utilizando el tema del kit de interfaz de usuario</a></li>
<li><a href="../459196/index.html">De monolitos a equipos modulares.</a></li>
<li><a href="../459204/index.html">10 ++ formas de trabajar con registros de hardware en C ++ (por ejemplo, IAR y Cortex M)</a></li>
<li><a href="../459206/index.html">9 a√±os en un monolito en Node.JS</a></li>
<li><a href="../459208/index.html">Correr con pr√≥tesis: simulaci√≥n de Nekstgen del movimiento humano usando m√∫sculos, huesos y una red neuronal</a></li>
<li><a href="../459212/index.html">Implementaci√≥n de propiedad en C ++</a></li>
<li><a href="../459214/index.html">Tolerancia a fallos en el almacenamiento de Qsan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>