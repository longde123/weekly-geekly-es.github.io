<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÆÔ∏è üë®üèæ‚Äçüíº üöµüèΩ Postgres Pro Standard 12.1 Dirilis ü§±üèæ üíÉüèø üëäüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Postgres Pro Standard DBMS dirancang untuk memberikan produk kami kepada pengguna lebih cepat daripada yang kami dapat melalui PostgreSQL. Fitur-fitur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Postgres Pro Standard 12.1 Dirilis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479618/">  Postgres Pro Standard DBMS dirancang untuk memberikan produk kami kepada pengguna lebih cepat daripada yang kami dapat melalui PostgreSQL.  Fitur-fitur yang belum termasuk dalam PostgreSQL, tetapi berada di jalur yang solid di sana, kami sertakan dalam Postgres Pro Standard.  Juga, Postgres Pro Standard mencakup beberapa ekstensi yang diminta oleh pelanggan kami, tetapi tidak tersedia dalam distribusi PostgreSQL standar. <br><br>  Kadang-kadang ada pengecualian ketika dalam Postgres Pro Standard, atas permintaan pengguna dan untuk memuaskan mereka, fitur-fitur yang kurang sepele dimasukkan, yang di tempat yang baik hanya di Postgres Pro Enterprise.  Secara khusus, ini adalah PTRACK, tentangnya di bawah ini. <br><br>  Tidak semua, tetapi bagian yang adil dari ekstensi tambahan dan utilitas yang termasuk dalam Standar, dikembangkan oleh Postgres Professional.  Semua tambalan Postgres Pro diciptakan dan diimplementasikan dengan upaya kami sendiri.  Mari kita mulai dengan perbaikan yang membutuhkan intervensi dalam mesin basis data. <br><a name="habracut"></a><br>  Postgres Pro Standard berbeda dari PostgreSQL pada dua tingkatan: himpunan ekstensi dan utilitas yang ada dalam perakitan, dan kernel itu sendiri.  Beberapa tambalan bermanfaat telah diterapkan pada kernel yang mengoptimalkan kinerja (misalnya, detektor kunci non-pengereman) dan tambalan yang meningkatkan efisiensi utilitas dan ekstensi (misalnya, untuk membuat pg_probackup bekerja dengan kekuatan penuh, tambalan PTRACK 2.0 diterapkan).  Perbedaan antara versi inti Standard dan PostgreSQL diminimalkan untuk kompatibilitas semaksimal mungkin.  Katakanlah ekstensi pg_pathman adalah bagian dari Standard, tetapi dapat diunduh dari github, dibangun dan diinstal pada vanilla PostgreSQL, tidak akan ada masalah kompatibilitas. <br>  Mari kita mulai dengan perubahan di kernel. <br><br><h3>  Memeriksa Versi ICU </h3><br>  Dalam PostgreSQL, secara default, mereka digunakan untuk membandingkan string dengan membandingkannya menggunakan pustaka standar C. Namun ada juga kemungkinan menggunakan pustaka <a href="http://site.icu-project.org/">ICU yang</a> dikembangkan oleh IBM untuk tujuan yang sama.  Perpustakaan ini sangat berharga bagi kami terutama karena menyediakan penyortiran platform-independen.  Itulah sebabnya, misalnya, digunakan dalam 1C, dan rakitan "untuk one-es" PostgreSQL telah lama bekerja dengan pustaka ini. <br><br>  Selain itu, perbandingan string melalui ICU terkadang lebih cepat daripada melalui libc, dan jumlah karakter yang diketahui lebih besar.  Secara umum, perpustakaan bermanfaat.  Postgres Pro Standard telah bekerja dengannya sejak versi pertama (9.5).  Di PostgreSQL, bekerja dengan ICU telah dimungkinkan sejak versi 10. <br><br>  Perpustakaan bermanfaat, tetapi Anda perlu mengingat beberapa situasi darurat.  Misalkan pengguna DBMS telah memutuskan untuk memutakhirkan OS.  Bersama-sama dengan OS, perpustakaan ICU juga dapat ditingkatkan, dan urutan kata dalam penyortiran akan berubah.  Setelah itu, segera semua indeks akan menjadi tidak dapat digunakan: pencarian indeks akan memberikan hasil yang salah.  Dalam kasus seperti itu, pangkalan mengatakan bahwa versi ICU telah berubah dan berhenti. <br><br>  Tapi ini adalah keputusan yang sangat sulit.  Setelah diskusi dan survei pelanggan, diputuskan untuk melunakkan perilaku.  Sekarang hanya versi COLLATION (aturan penyortiran) yang diperiksa.  Jika versi COLLATION yang digunakan dalam database telah berubah, database mengeluarkan peringatan ketika DBMS dimulai, tetapi tidak berhenti.  Ini juga mengingatkan pengguna pada awal setiap sesi. <br><br><h3>  Optimalisasi kunci, gabungan, dan GROUP BY </h3><br>  Mekanisme deteksi kebuntuan dapat menurunkan kinerja.  Standar tidak bisa lagi: patch kernel memungkinkannya bekerja tanpa pengereman.  Setelah perbaikan besar pada mekanisme verifikasi, masalah ini hanya muncul pada sejumlah besar inti dan koneksi. <br><br>  Peningkatan estimasi jumlah hasil gabungan di hadapan indeks yang sesuai. <br><br>  Sekarang Anda dapat menggunakan indeks yang sesuai untuk mengelompokkan dan mengurutkan bidang.  Fitur ini pertama kali dimasukkan dalam Standar 11.1.1 dan Perusahaan 11.2.1.  Standar 12 kami juga memiliki satu. <br><br>  Fedor Sigaev, CTO dari Postgres Professional, telah menawarkan tambalan-tambalan yang bermanfaat ini kepada masyarakat, mereka sedang dipertimbangkan dan, mudah-mudahan, akan dimasukkan dalam versi PG 13. <br><br>  Kami menggambarkan optimalisasi operasi GROUP BY dengan contoh: mereka jelas dan mudah direproduksi. <br><br>  Inti dari tambalan ini adalah Postgres tidak mengoptimalkan urutan bidang yang terdaftar dalam GROUP BY.  Dan waktu eksekusi tergantung pada urutan pengelompokan (dengan hasil permintaan yang sama).  Ada detail dalam <a href="https://postgrespro.ru/list/thread-id/2388982">diskusi</a> di milis <a href="https://postgrespro.ru/list/pgsql-hackers">peretas</a> . <br><br>  Jika nilai di kolom pertama yang diproses unik, maka tidak ada yang perlu dibandingkan.  Jika Anda mulai dari kolom lain, maka Anda harus membandingkan. <br><br><br>  Mendapatkan ke tes: <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> id, i/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> p, format(<span class="hljs-string"><span class="hljs-string">'%60s'</span></span>, i%<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>) i;</code> </pre> <br><br>  Dalam bidang teks v, 60 spasi dihasilkan, diikuti oleh angka 0 atau 1. Entri terlihat seperti ini: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; id | p | v <span class="hljs-comment"><span class="hljs-comment">---------+--------+-------------------------------------------------------------- 1000000 | 500000 | 0 999999 | 499999 | 1 999998 | 499999 | 0 (3 rows)</span></span></code> </pre> <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">ANALYSE</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_hashagg=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_workers= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_workers_per_gather = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><br>  Kelompokkan hasilnya: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p, v;</code> </pre> <br><br>  Paket PostgreSQL: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=204036.84..218981.05 rows=494421 width=73) (actual time=843.999..1194.985 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=204036.84..206536.84 rows=1000000 width=65) (actual time=843.990..946.769 rows=1000000 loops=1) Sort Key: p, v Sort Method: external sort Disk: 73320kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.158..151.645 rows=1000000 loops=1) Planning time: 0.317 ms Execution time: 1250.086 ms (8 rows)</span></span></code> </pre> <br><br>  Sekarang dalam urutan terbalik: v, dan hanya kemudian p: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> v, p; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------ GroupAggregate (cost=204036.84..218981.05 rows=494421 width=73) (actual time=2552.477..3353.890 rows=1000000 loops=1) Group Key: v, p -&gt; Sort (cost=204036.84..206536.84 rows=1000000 width=65) (actual time=2552.469..3111.516 rows=1000000 loops=1) Sort Key: v, p Sort Method: external merge Disk: 76264kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.082..126.578 rows=1000000 loops=1) Planning time: 0.060 ms Execution time: 3411.048 ms (8 rows)</span></span></code> </pre> <br><br>  Ternyata kebalikannya terasa lebih lambat.  Ini karena bidang pertama <code>v</code> dianalisis dengan sebaran nilai yang kecil.  Anda harus melakukan banyak pemeriksaan pada bidang yang tersisa (di sini - bidang p). <br><br>  Mari kita lihat bagaimana kueri yang sama akan bekerja dengan tambalan yang memilih urutan optimal untuk memproses kolom: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------- GroupAggregate (cost=237400.11..252417.09 rows=501698 width=73) (actual time=415.541..703.647 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=237400.11..239900.11 rows=1000000 width=65) (actual time=415.533..507.785 rows=1000000 loops=1) Sort Key: p, v Sort Method: external merge Disk: 73488kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.059..139.587 rows=1000000 loops=1) Planning Time: 0.123 ms Execution Time: 742.118 ms (8 rows)</span></span></code> </pre> <br><br>  Dan dalam urutan terbalik: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=237400.11..252417.09 rows=501698 width=73) (actual time=414.322..714.593 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=237400.11..239900.11 rows=1000000 width=65) (actual time=414.312..517.707 rows=1000000 loops=1) Sort Key: p, v Sort Method: external merge Disk: 76384kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.071..129.835 rows=1000000 loops=1) Planning Time: 0.140 ms Execution Time: 753.031 ms (8 rows)</span></span></code> </pre> <br><br>  Rencananya mengatakan bahwa di sana dan di sana urutan pemrosesan sama: Sortir Key: p, v.  Dengan demikian, waktunya kira-kira sama.  Sekarang bandingkan apa yang terjadi ketika indeks digunakan. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> btg(p, v); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_bitmapscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> v, p ;</code> </pre> <br><br>  Di PostgreSQL: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------- GroupAggregate (cost=0.55..74660.04 rows=494408 width=73) (actual time=0.013..391.317 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..62216.16 rows=999974 width=65) (actual time=0.009..120.298 rows=1000000 loops=1) Heap Fetches: 0 Planning time: 0.078 ms Execution time: 442.923 ms (6 rows)</span></span></code> </pre> <br><br>  Dan dalam urutan terbalik: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=243904.22..258848.04 rows=494408 width=73) (actual time=2558.485..3352.240 rows=1000000 loops=1) Group Key: v, p -&gt; Sort (cost=243904.22..246404.16 rows=999974 width=65) (actual time=2558.478..3110.242 rows=1000000 loops=1) Sort Key: v, p Sort Method: external merge Disk: 76264kB -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..62216.16 rows=999974 width=65) (actual time=0.011..133.563 rows=1000000 loops=1) Heap Fetches: 0 Planning time: 0.093 ms Execution time: 3409.335 ms (9 rows)</span></span></code> </pre> <br><br>  Sekarang dalam Standar: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------- GroupAggregate (cost=0.55..74196.82 rows=501685 width=73) (actual time=0.150..412.174 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..61680.16 rows=999974 width=65) (actual time=0.134..149.669 rows=1000000 loops=1) Heap Fetches: 0 Planning Time: 0.175 ms Execution Time: 448.635 ms (6 rows)</span></span></code> </pre> <br><br>  Dan dalam urutan terbalik: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------- GroupAggregate (cost=0.55..74196.82 rows=501685 width=73) (actual time=0.014..307.258 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..61680.16 rows=999974 width=65) (actual time=0.008..89.204 rows=1000000 loops=1) Heap Fetches: 0 Planning Time: 0.054 ms Execution Time: 337.766 ms (6 rows)</span></span></code> </pre> <br><br>  Waktunya sama lagi, yang alami: pada kenyataannya, tindakannya sama. <br><br><h3>  Mengganti byte nol saat boot </h3><br>  Postgres Pro tidak menerima nol byte (0x00) dalam data, jadi dengan COPY FROM mereka harus diganti, <a href="https://postgrespro.ru/docs/postgrespro/12/runtime-config-compatible">jika tidak akan ada kesalahan</a> .  Ini adalah masalah nyata yang ditemui pelanggan saat mengimpor data dari file CSV.  Solusinya adalah mengganti byte nol dengan karakter ASCII yang diberikan.  Itu harus berbeda dari karakter QUOTE dan DELIMITER yang digunakan ketika menjalankan COPY FROM;  jika tidak, hasilnya mungkin tidak terduga.  Secara default, nilai variabel nul_byte_replacement_on_import (string) '\ 0', yaitu, tidak ada penggantian yang dilakukan. <br><br><h3>  WaitLSN </h3><br>  LSN adalah <a href="https://postgrespro.ru/docs/postgrespro/12/sql-waitlsn">nomor urut dalam log</a> , yaitu, penunjuk ke posisi dalam WAL (Log Sequence Number).  Perintah WAITLSN sedang menunggu untuk memainkan LSN yang ditentukan.  Jika aplikasi berfungsi dengan master dan replika, maka Anda perlu memastikan bahwa mereka sinkron dari waktu ke waktu.  WAITLSN adalah mekanisme interproses di PostgrePro yang mengontrol sinkronisasi selama <a href="https://postgrespro.ru/docs/postgrespro/12/runtime-config-replication">replikasi sinkron</a> .  Secara default, waktu tunggu tidak terbatas.  Anda dapat membatalkan menunggu dengan menekan Ctrl + C atau menghentikan server postgres.  Anda juga dapat mengatur batas waktu dengan menambahkan petunjuk TIMEOUT, atau memeriksa status LSN target tanpa menunggu dengan menggunakan petunjuk NOWAIT. <br>  Misalkan aplikasi melakukan tindakan tertentu, menerima nomor LSN dari DBMS pada master dan sekarang ingin memastikan bahwa tindakan pada replika akan disinkronkan dengan master, mis.  aplikasi dapat memastikan bahwa apa yang direkam pada wizard telah tiba di replika dan siap dibaca.  Secara default, ini biasanya tidak dijamin.  WAITLSN memungkinkan Anda untuk mengontrol interaksi ini dan memilih mode tidur dari INFINITELY secara default, ke TIMEOUT dan NOWAIT. <br><br><h3>  Membaca ulang variabel dari recovery.conf sebelumnya </h3><br>  Pada sinyal SIGHUP, PostgreSQL membaca ulang postgresql.conf, tetapi tidak recovery.conf.  Patch kernel yang relatif baru diperkenalkan dalam Standar dan Perusahaan 10.4.1.  terpaksa membaca ulang dan recovery.conf.  Tetapi di Postgres 12 tidak ada file recovery.conf sama sekali: semua variabel darinya ditransfer ke postgresql.conf.  Meskipun demikian, meskipun seluruh file dibaca kembali, variabel dari recovery.conf tidak didefinisikan ulang oleh SIGHUP, tetapi diperlukan restart Postgres.  Dalam Standar, ini tidak diperlukan: semuanya dibaca dan didefinisikan ulang. <br><br><h3>  Dukungan PTRACK </h3><br>  PTRACK 2.0 adalah mekanisme PTRACK yang dirancang ulang untuk versi Standar dan Perusahaan 11 dan sebelumnya.  Pada level DBMS, ia bekerja berkat patch kernel, dan sekarang ekstensi ptrack telah ditambahkan ke <a href="https://postgrespro.ru/docs/postgrespro/12/ptrack">patch</a> .  PTRACK 2.0 melacak perubahan halaman data dan menyediakan antarmuka untuk mengambil informasi ini.  Ini dapat digunakan baik untuk tujuan diagnostik, misalnya, untuk mendapatkan gagasan tentang seberapa kuat instance "bermutasi" relatif ke titik waktu tertentu, ditetapkan sebagai nomor urut dalam log (LSN), dan untuk membuat cadangan tambahan. <br><br>  Bagian paling sulit dan "mahal" dari prosedur cadangan tambahan, sebagai aturan, adalah untuk mengisolasi bagian dari halaman yang diubah dari seluruh set halaman dalam sebuah cluster.  Karena kenyataan bahwa server dapat melakukan tugas ini dan dengan cepat memberikan informasi tentang halaman yang diubah, waktu cadangan tambahan menggunakan PTRACK berkurang secara signifikan. <br><br>  PTRACK 2.0 menggunakan tabel hash dari ukuran yang ditentukan dalam memori bersama, disinkronkan secara berkala dengan file ptrack.map. <br><br>  Karena perubahan mendasar dari mekanisme operasi internal dan antarmuka pengguna yang tidak kompatibel dengan versi yang lebih lama, ekstensi ptrack hanya tersedia dalam versi ke-12 dari PostgresPro Standard and Enterprise, dan akan tersedia sebagai patch dan ekstensi pada PostgreSQL 12. <br><br><h3>  Mengedit perintah dalam psql untuk Windows </h3><br>  Dukungan lanjutan untuk mengedit perintah input di psql untuk Windows diimplementasikan menggunakan WinEditLine.  Sekarang Anda dapat menampilkan karakter huruf yang berbeda secara bersamaan (khususnya, Cyrillic biasanya ditampilkan pada Windows non-Rusia). <br><br><h3>  Struktur Paket Terpadu </h3><br><br>  Struktur paket paket biner untuk semua distribusi Linux dipersatukan untuk menyederhanakan migrasi di antara mereka dan memungkinkan untuk menginstal beberapa produk berbasis PostgreSQL yang berbeda bersama-sama tanpa konflik.  Ini dapat ditemukan di <a href="https://postgrespro.ru/docs/postgrespro/12/installation-bin">Bab 16 dari</a> Dokumentasi. <br><br>  Sekarang tentang ekstensi: <br><br><h3>  dump_stat </h3><br>  Itu muncul sedini 9,5.  Saat mentransfer atau memulihkan data, akumulasi statistik biasanya tidak ditransfer.  Jika Anda memasang kembali dengan perintah ANALYZE, maka itu akan dieksekusi untuk seluruh cluster, dan bukan untuk database yang ditentukan.  Ini mungkin memerlukan banyak waktu ekstra untuk database besar. <br><br>  Ekstensi dump_stat <a href="https://postgrespro.ru/docs/postgrespro/12/dump-stat">menyediakan fungsi</a> yang memungkinkan Anda membongkar dan mengembalikan konten tabel pg_statistic.  Saat melakukan pengunggahan / pemulihan data, Anda dapat menggunakan dump_stat untuk mentransfer statistik yang ada ke server baru, tanpa harus menjalankan perintah ANALYZE untuk seluruh kluster. <br><br>  Fungsi dump_statistic membongkar isi katalog sistem pg_statistic.  Ini menghasilkan INSERT untuk setiap tuple di pg_statistic, kecuali untuk yang berisi statistik tentang tabel dalam skema information_schema dan pg_catalog. <br><br><h3>  jsquery </h3><br>  Ingatlah bahwa <a href="https://postgrespro.ru/docs/postgrespro/12/jsquery">ini adalah ekstensi</a> untuk bekerja dengan JSON (B), bukan JS.  Ini menyediakan satu set fungsi untuk memproses tipe data ini.  Ini adalah bahasa permintaan khusus untuk pencarian yang efisien, menggunakan indeks, di JSON (B).  Dalam <a href="https://habr.com/ru/company/postgrespro/blog/448612/">artikel di hub,</a> Anda dapat melihat beberapa contoh jsquery dan metode alternatif bekerja dengan JSON (B), misalnya JSONPath (keduanya pengembangan perusahaan kami). <br><br><h3>  online_analyze </h3><br>  Ekstensi ini <a href="https://postgrespro.ru/docs/postgrespro/12/online-analyze">menyediakan</a> serangkaian fungsi yang segera memperbarui statistik dalam tabel yang ditentukan setelah operasi INSERT, UPDATE, DELETE, atau SELECT INTO di dalamnya.  Penulis ekstensi adalah Fedor Sigaev. <br><br>  Untuk menggunakan modul online_analyze, Anda harus memuat pustaka bersama: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">LOAD</span></span> <span class="hljs-string"><span class="hljs-string">'online_analyze'</span></span>;</code> </pre> <br><br>  Pembaruan statistik dapat disesuaikan.  Misalnya, atur persentase ukuran tabel atau jumlah minimum (ambang) perubahan baris, setelah itu statistik akan segera dikumpulkan. <br><br><h3>  pg_pathman </h3><br>  <a href="https://postgrespro.ru/docs/postgrespro/12/pg-pathman">Ekstensi pg_pathman</a> di Postgres Professional dibuat lebih awal daripada di kernel PostgreSQL dan mengimplementasikan serangkaian fungsi yang cukup lengkap untuk membuat partisi.  Oleh karena itu, banyak operasi dengan bagian dapat dilakukan dengan mekanisme satu dan lainnya.  Dianjurkan untuk tidak mencampur bagian yang dibuat oleh partisi deklaratif dan pg_pathman. <br><br>  Namun, banyak operasi pg_pathman masih lebih cepat dan beberapa fitur hilang di PostgreSQL.  Misalnya, pembuatan otomatis (pemotongan) bagian.  Di PostgreSQL, Anda perlu mengatur batas-batas setiap bagian.  Jika kita mengisi data tentang yang tidak diketahui sebelumnya berapa banyak bagian yang dapat dan harus tersebar, maka lebih mudah untuk mengatur interval dan membiarkan perangkat lunak memotong bagian itu sendiri - sebanyak yang diperlukan.  pg_pathman tahu caranya, PostgreSQL tidak.  Tapi, dimulai dengan PG 11, ada bagian default (default), di mana Anda bisa membuang semua catatan yang tidak jatuh ke bagian dengan batas yang ditentukan. <br><br>  Ada kesepakatan dasar dengan para pemimpin komunitas PostgreSQL bahwa di masa depan yang terbaik, sementara fitur unik pg_pathman akan jatuh ke cabang utama.  Tetapi sampai saat itu, pg_pathman dapat membuat hidup lebih mudah untuk admin DB aplikasi dan pemrogram aplikasi. <br><br>  Buat ekstensi: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_pathman;</code> </pre> <br><br>  pg_pathman memungkinkan Anda untuk memecah tabel besar menjadi beberapa bagian dan menyediakan API yang nyaman - serangkaian fungsi untuk membuat bagian dan bekerja dengannya.  Misalnya, menggunakan fungsi <br><br><pre> <code class="pgsql hljs">create_range_partitions(relation <span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, expression <span class="hljs-type"><span class="hljs-type">TEXT</span></span>, start_value <span class="hljs-type"><span class="hljs-type">ANYELEMENT</span></span>, p_interval <span class="hljs-type"><span class="hljs-type">INTERVAL</span></span>, p_count <span class="hljs-type"><span class="hljs-type">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, partition_data <span class="hljs-type"><span class="hljs-type">BOOLEAN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>);</code> </pre> <br>  kita bisa bertanya <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'dt'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>);</code> </pre> <br><br>  setelah itu kami menambahkan bagian: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'log_archive'</span></span>, <span class="hljs-string"><span class="hljs-string">'ts0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-02-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'log_1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-02-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-03-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span><span class="hljs-string"><span class="hljs-string">', log_2'</span></span>);</code> </pre> <br><br>  Log arsip akan dibuat di ruang tabel ts0, sisanya secara default.  Tapi Anda tidak bisa menentukan bagian secara eksplisit, tetapi percaya operasi DBMS ini dengan mengatur interval dan membuat bagian dalam satu langkah: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'dt'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>);</code> </pre> <br><br>  Pada tabel sederhana, akan terlihat seperti ini: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> pg_pathmania(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, val <span class="hljs-type"><span class="hljs-type">float</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pg_pathmania(val) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> random() * <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'pg_pathmania'</span></span>, <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); test_parti=# \d+ pg_pathmania <span class="hljs-keyword"><span class="hljs-keyword">Table</span></span> "public.pg_pathmania" <span class="hljs-keyword"><span class="hljs-keyword">Column</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Collation</span></span> | Nullable | <span class="hljs-keyword"><span class="hljs-keyword">Default</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span> | S tats target | Description <span class="hljs-comment"><span class="hljs-comment">--------+------------------+-----------+----------+-----------------------+---------+------+------ id | integer | | not null | nextval('pg_pathmania_id_seq'::regclass) | plain | | val | double precision | | | | plain | | Child tables: pg_pathmania_1, pg_pathmania_10, pg_pathmania_11, pg_pathmania_12, pg_pathmania_13, pg_pathmania_14, pg_pathmania_15, pg_pathmania_16, pg_pathmania_17, pg_pathmania_18, pg_pathmania_19, pg_pathmania_2, pg_pathmania_20, pg_pathmania_21, pg_pathmania_3, pg_pathmania_4, pg_pathmania_5, pg_pathmania_6, pg_pathmania_7, pg_pathmania_8, pg_pathmania_9</span></span></code> </pre> <br><br>  Di PostgreSQL, kita harus membuat setiap bagian dengan tim kita sendiri.  Dalam kasus seperti itu, tentu saja, mereka menulis skrip yang menghasilkan kode DDL yang diperlukan secara otomatis.  Anda tidak perlu menulis skrip di pg_pathman, semuanya sudah ada di sana.  Tapi ini bukan yang paling menarik.  Kami akan menyisipkan catatan yang tidak hanya didapat oleh id ke bagian mana pun yang ada, tetapi juga tidak jatuh ke bagian terdekat: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pg_pathmania(id, val) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-number"><span class="hljs-number">277.835794724524</span></span>);</code> </pre> <br><br>  Sekali lagi, periksa isi tabel dengan \ d + pg_pathmania: <br><br><pre> <code class="pgsql hljs">Child <span class="hljs-keyword"><span class="hljs-keyword">tables</span></span>: pg_pathmania_1, pg_pathmania_10, ... pg_pathmania_39, pg_pathmania_4, pg_pathmania_40, pg_pathmania_41,</code> </pre> <br><br>  Inilah yang terjadi: pg_pathman melihat bahwa catatan dengan id = 2000 tidak jatuh ke bagian yang sudah dibuat, menghitung berapa banyak yang harus dibuat, mengetahui interval RANGE yang tabelnya dipartisi sebelumnya, dan menciptakan bagian di mana catatan baru jatuh, dan, tentu saja, semua bagian antara batas atas dari bagian lama dan batas bawah dari bagian baru.  Ini sangat nyaman, dan dalam kasus-kasus di mana nilai-nilai bidang pemisahan data yang diperbarui diprediksi dengan buruk, ini merupakan keuntungan serius pg_pathman. <br><br><h3>  pg_query_state </h3><br>  Ekstensi yang kami kembangkan ini <a href="https://postgrespro.ru/docs/postgrespro/12/pg-query-state">memungkinkan</a> kami <a href="https://postgrespro.ru/docs/postgrespro/12/pg-query-state">untuk mengetahui</a> kondisi permintaan saat ini dalam proses penayangan.  Itu sudah ada sejak versi 9.5 dan disebabkan oleh lahirnya banyak permintaan admin pelanggan. <br><br>  Faktanya adalah bahwa EXPLAIN ANALYZE memungkinkan Anda untuk melihat statistik eksekusi yang dikumpulkan dari setiap node dari pohon paket, tetapi statistik ini dikumpulkan hanya setelah kueri diselesaikan.  Namun dalam hidup, sayangnya, ada situasi ketika Anda perlu melihat apa yang permintaannya belum selesai dan mungkin tidak akan berakhir.  pg_query_state memungkinkan Anda untuk melihat statistik saat ini dari query yang berjalan dalam proses servis eksternal.  Dalam hal ini, format output yang dihasilkan hampir identik dengan output dari perintah EXPLAIN ANALYZE yang biasa. <br><br>  Utilitas: <br><br><h3>  pgBuncer </h3><br>  <a href="http://www.pgbouncer.org/">Ini adalah</a> <a href="https://postgrespro.ru/docs/postgrespro/12/pgbouncer">penarik koneksi yang populer</a> sehingga akan aneh untuk membicarakannya di sini.  Hanya saja itu adalah bagian dari Standar, dan itu harus diinstal secara terpisah dalam kasus vanilla PostgreSQL. <br><br><h3>  pg_probackup </h3><br>  <a href="https://postgrespro.ru/docs/postgrespro/12/app-pgprobackup">pg_probackup</a> adalah salah satu perkembangan kami yang paling populer.  Ini adalah manajer cadangan dan pemulihan yang sedang dikembangkan dan diperbarui terutama oleh Anastasia Lubennikova, Grigory Smolkin, dan komunitas pengguna. <br><br>  Keunggulan kompetitif pg_probackup: cadangan inkremental dengan granularitas blok (8KB), tiga mode cadangan inkremental (PAGE, DELTA, PTRACK), pemeriksaan integritas cadangan atas permintaan, verifikasi cluster PostgreSQL, kompresi cadangan, pemulihan sebagian, dll. <br><br>  Mode penyalinan tambahan PTRACK, mengandalkan <a href="https://postgrespro.ru/docs/postgrespro/12/ptrack">ekstensi dengan nama yang sama</a> sebagai bagian dari mekanisme yang dirancang ulang - PTRACK 2.0 - telah menjadi lebih cepat dan sekarang jelas merupakan mode pg_probackup tercepat dan "termurah". <br><br><h3>  pg_repack </h3><br>  <a href="https://postgrespro.ru/docs/postgrespro/12/app-pgrepack">pg_repack adalah</a> utilitas populer, operasinya mirip dengan VACUUM FULL atau <a href="https://postgrespro.ru/docs/postgrespro/12/sql-cluster">CLUSTER</a> .  Itu tidak hanya mengemas ulang tabel, menghapus void, tetapi juga tahu cara mengembalikan urutan fisik indeks berkerumun.  Tidak seperti CLUSTER dan VACUUM FULL, ia melakukan operasi ini "saat bepergian", melakukan tanpa kunci tabel eksklusif dan umumnya bekerja secara efisien.  Itu tidak termasuk dalam versi vanilla. <br><br><h3>  pg_variables </h3><br>  Tentang ekstensi ini di habr ada <a href="https://habr.com/ru/company/postgrespro/blog/302200/">artikel</a> menarik <a href="https://habr.com/ru/company/postgrespro/blog/302200/">dari</a> karyawan kami Ivan Frolkov.  Alasan untuk perpanjangan adalah bahwa bekerja dengan hasil antara kadang-kadang tidak nyaman dan mahal.  Artikel ini mengeksplorasi alternatif.  Yang paling umum adalah tabel sementara. <br><br>  Sebagai gudang data sementara, ekstensi pg_variables jauh lebih produktif daripada tabel sementara (tes pgbench ada dalam artikel), dan itu lebih nyaman: set data didefinisikan oleh pasangan "paket-variabel", yang dapat dilewatkan sebagai parameter, dikembalikan dari fungsi, dll. Ada fungsi set / get untuk bekerja dengan variabel.  Jadi, misalnya, Anda dapat menyimpan banyak variabel (paket adalah nama paket, dan ekspresi setelah titik desimal adalah variabel dalam paket ini: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pgv_set_int(<span class="hljs-string"><span class="hljs-string">'package'</span></span>,<span class="hljs-string"><span class="hljs-string">'#'</span></span>||n,n), n <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> gs(n);</code> </pre> <br><br>  Variabel memiliki properti yang menarik: bukan bug atau keuntungan, tetapi fitur: data yang disimpan oleh ekstensi berarti ada di luar transaksi - mereka disimpan baik dalam hal memperbaiki transaksi dan dalam kasus rollback;  Selain itu, bahkan ketika menjalankan perintah terpisah, sebagian data dapat diperoleh: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pgv_insert(<span class="hljs-string"><span class="hljs-string">'package'</span></span>, <span class="hljs-string"><span class="hljs-string">'errs'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>(n)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> gs(n) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span>/(n<span class="hljs-number"><span class="hljs-number">-3</span></span>)&lt;&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>; ERROR: there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a <span class="hljs-type"><span class="hljs-type">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the variable "errs" <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> same key test_parti=# <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgv_select(<span class="hljs-string"><span class="hljs-string">'package'</span></span>,<span class="hljs-string"><span class="hljs-string">'errs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r(i <span class="hljs-type"><span class="hljs-type">int</span></span>); i <span class="hljs-comment"><span class="hljs-comment">--- 1 2 (2 rows)</span></span></code> </pre> <br><br>  Di satu sisi, ini sangat tidak nyaman - dalam beberapa kasus perlu untuk menghapus data yang dimasukkan secara tidak benar, tetapi di sisi lain hal ini dapat menjadi sangat berguna - misalnya, menyimpan beberapa data bahkan jika terjadi kemunduran transaksi.  <a href="https://github.com/postgrespro/pg_variables">Dokumentasi</a> memiliki detail. <br><br>  Kesimpulannya, beberapa ekstensi lagi: <br><br><h3>  sr_plan, plantuner </h3><br>  <b>sr_plan</b> <a href="https://postgrespro.ru/docs/postgrespro/12/sr-plan">menyimpan dan mengembalikan paket</a> kueri.  Sertakan seperti ini: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> sr_plan.write_mode = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;</code> </pre> <br><br>  Setelah itu, paket untuk semua kueri berikutnya akan disimpan dalam tabel sr_plans hingga variabel ini disetel ke false.  Paket semua permintaan, termasuk yang berulang, disimpan. <br><br>  <b>plantuner</b> <a href="https://postgrespro.ru/docs/postgrespro/12/plantuner">mendukung</a> petunjuk bagi scheduler untuk menghubungkan atau memutus indeks yang ditentukan saat menjalankan kueri.  Hanya ada dua variabel GUC: enable_index / desable_index: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> plantuner.disable_index=<span class="hljs-string"><span class="hljs-string">'id_idx2'</span></span>;</code> </pre> <br><br><h3>  Ekstensi untuk pencarian teks lengkap: shared_ispell, pg_tsparser </h3><br>  Ekstensi shared_ispell, yang memungkinkan Anda untuk menempatkan <a href="https://postgrespro.ru/docs/postgrespro/12/hunspell-dict">kamus</a> di memori bersama, adalah dalam Standar dan bukan di PostgreSQL.  Kumpulan hunspell-dict kami memiliki kamus untuk bahasa: <br><br><ul><li>  hunspell_en_us, </li><li>  hunspell_fr, </li><li>  hunspell_nl_nl, </li><li>  hunspell_ru_ru </li></ul><br><br>  <b>Ekstensi pg_tsparser</b> adalah <a href="https://postgrespro.ru/docs/postgrespro/12/pg-tsparser">penganalisis</a> pencarian teks <a href="https://postgrespro.ru/docs/postgrespro/12/pg-tsparser">alternatif</a> .  Ekstensi ini mengubah strategi penguraian teks standar untuk kata-kata yang mencakup garis bawah, serta angka dan huruf yang dipisahkan oleh garis bawah.  Selain setiap bagian dari kata yang dikembalikan secara default, pg_tsparser juga mengembalikan seluruh kata.  Ini sangat penting untuk dokumentasi teknis atau artikel seperti ini, di mana kode program ditemukan, dan di dalamnya ada kata-kata seperti "pg_tsparser", "pg_probackup", "jsonb_build_object".  Parser ini memahami kata-kata ini tidak hanya sebagai satu set komponen, tetapi juga sebagai token tunggal, dan dengan demikian meningkatkan kualitas pencarian. <br><br><h3>  Ekstensi untuk 1C </h3><br><ul><li>  <b><a href="https://postgrespro.ru/docs/postgrespro/12/mchar">mchar</a></b> adalah tipe data opsional untuk kompatibilitas dengan Microsoft SQL Server; </li><li>  <b><a href="https://postgrespro.ru/docs/postgrespro/12/fulleq">fulleq</a></b> - menyediakan operator kesetaraan tambahan untuk kompatibilitas dengan Microsoft SQL Server; </li><li> <b><a href="https://postgrespro.ru/docs/postgrespro/12/fasttrun"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fasttrun</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - menyediakan fungsi transaksi-tidak aman untuk memotong tabel sementara, yang mencegah direktori pg_class dari tumbuh.</font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menyimpulkan ulasan singkat ini, tetapi bukan perbedaan antara PostgresPro Standard dan PostgreSQL. </font><font style="vertical-align: inherit;">Kami menyebutkan yang utama, tetapi Anda dapat membandingkan versi secara detail dengan memulai, misalnya, </font></font><a href="https://postgrespro.ru/docs/postgrespro/12/index"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari halaman ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479618/">https://habr.com/ru/post/id479618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479590/index.html">10 perusahaan pengembang aplikasi teratas pada tahun 2020</a></li>
<li><a href="../id479592/index.html">Bagaimana cara mencapai tujuan Anda?</a></li>
<li><a href="../id479598/index.html">Kucing dan anjing memberi makan robot</a></li>
<li><a href="../id479600/index.html">DSL lain untuk validasi</a></li>
<li><a href="../id479602/index.html">Apa genom lengkap dan mengapa itu diperlukan</a></li>
<li><a href="../id479620/index.html">Membalikkan logika</a></li>
<li><a href="../id479622/index.html">Cara kerja prototipe transaksi anonim di blockchain Waves</a></li>
<li><a href="../id479624/index.html">Greg Postgres Professional Oleg Bartunov memberi tahu Faride Roslovets tentang PostgreSQL dan bisnis di Rusia</a></li>
<li><a href="../id479626/index.html">Resonator dengan twist yang tidak diketahui oleh fisikawan</a></li>
<li><a href="../id479636/index.html">Tumpukan navigasi sendiri. Lebih baik daripada ROS?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>