<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏿 🔋 ⤵️ 我如何编写标准的C ++ 11库，或者为什么boost如此令人恐惧。 第4.3章 📿 ➿ ✍🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="先前部分的摘要 
 由于使用C ++ 11编译器的能力受到限制，并且由于缺乏替代性，boost希望在编译器随附的C ++ 98 / C ++ 03库之上编写自己的标准C ++ 11库实现。 

 实现了static_assert ， noexcept ， countof ，并且在考虑了所有非标准定义...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我如何编写标准的C ++ 11库，或者为什么boost如此令人恐惧。 第4.3章</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418347/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="我们继续冒险。" width="300" height="350" align="left"><h3> 先前部分的摘要 </h3><br> 由于使用C ++ 11编译器的能力受到限制，并且由于缺乏替代性，boost希望在编译器随附的C ++ 98 / C ++ 03库之上编写自己的标准C ++ 11库实现。 <br><br>  <b>实现了static_assert</b> ， <b>noexcept</b> ， <b>countof</b> ，并且在考虑了所有非标准定义和编译器功能之后，出现了有关当前编译器支持的功能的信息。  <b>包含了</b>自己的<b>nullptr</b>实现，该实现在编译阶段选择。 <br><br> 现在是使用<b>type_traits</b>和所有这些“特殊模板魔术”的时候了。 在本章的前面部分中，我们检查了我对标准库基本模板的实现，在这一部分中，我们将讨论SFINAE技术与模板的结合以及一些代码生成。 <br><br> 链接到GitHub，为不耐烦的读者和非读者提供今天的结果： <br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">欢迎有建设性的批评和批评</a></b> </blockquote>  cat下有更多的C ++模板。 <br><a name="habracut"></a><br><h4> 目录 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引言</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1章。Viam supervadet vadens</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2章。#ifndef __CPP11_SUPPORT__＃定义__COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3章。找到理想的nullptr实现</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4章C ++模板魔术</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.1我们从小处着手</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.2关于日志为我们编译了多少个奇迹般的错误</a> <br>  .... <b>4.3指针和所有所有</b> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.4模板库还需要什么</a> <br> 第五章 <br>  ... <br><br><h3> 第4章。模板“魔术” C ++。 延续性 </h3><br><h4>  4.3指针和所有所有 </h4><br> 在这一阶段，我只能获得有关类型是否为<i>std :: is_array</i>的数组的信息，并且有可能启动指针模板。 实施也是微不足道的，但并非没有假设。 <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_array template&lt;class&gt; struct is_array : public false_type { }; template&lt;class _Tp, std::size_t _Size&gt; struct is_array&lt;_Tp[_Size]&gt; : public true_type { }; /*template&lt;class _Tp&gt; struct is_array&lt;_Tp[]&gt;: public true_type { }; */</span></span></code> </pre> <br> 给定长度的数组的简单模板专门化可以“捕获”所有类型的数组，但是，不完整的类型<i>T []</i> （未指定长度的数组）会引起问题。 事实是，在专门设计模板时，某些编译器（C ++ Builder）未定义此类型，并且我在这里还没有找到通用的解决方案。 <br><br> 在库被“教导”以定义内置类型，类型存储器中的对齐方式，在编译时通过模板使用类型修饰符和其他基本功能之后，就该使用指针和引用了。 <br><br><img src="https://habrastorage.org/webt/ti/rp/mi/tirpmiwggsavcvlxyjbo8dlv5ee.png" alt="图片" width="300" height="280" align="left"> 在C ++中，可以区分两组指针-指向类成员的指针和指向其他对象的指针。 为什么这种分离对于标准库的进一步实施很重要？ 事实是，指向类成员的指针由于存在<b>this而</b>与其他指针有显着差异，即 指向此类的对象的指针。 而且按照标准，指向类成员的指针具有用于定义的单独语法，是单独的类型，并且不能通过常规指针表示。 实际上，这转化为以下事实：指向类成员的指针的大小通常大于常规指针的大小（ <i>==</i> <b>sizeof（void *）</b> ），因为 为了实现类的虚拟成员函数以及存储<b>this</b>指针，编译器通常将指向类成员的指针作为结构实现（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了解</a>虚函数和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">structure</a> ）。 根据标准，编译器可以自行决定是否给出指向类成员的指针的方式，但是在考虑其他代码时，我们会记住大小和表示方式上的这种差异。 <br><br> 要定义指向对象的常规指针，我们将编写一个简单的<i>is_pointer</i>模板，以及一个<i>is_lvalue_reference</i>模板用于对象引用（ <i>我们</i>将is_rvalue_reference <i>放在一边</i> ，因为直到第11个标准，都没有<i>&amp;&amp;</i>运算符以及整个move语义）： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_pointer_helper</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_pointer_helper</span></span></span><span class="hljs-class">&lt;_Tp*&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type { }; } <span class="hljs-comment"><span class="hljs-comment">// is_pointer template&lt;class _Tp&gt; struct is_pointer : public detail::_is_pointer_helper&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type { }; // is_lvalue_reference template&lt;class&gt; struct is_lvalue_reference : public false_type { }; template&lt;class _Tp&gt; struct is_lvalue_reference&lt;_Tp&amp;&gt; : public true_type { };</span></span></code> </pre><br> 这里不再有任何根本上的新内容，所有相同的操作都在本章的前面部分进行过。 让我们继续定义对象的指针-现在让我们看一下函数的指针。 <br><blockquote> 重要的是要了解，根据标准，类的函数和成员函数是完全不同的实体： <br><br><ul><li> 第一个指针将是普通的（指向对象的指针），第二个指针将具有指向类成员的指针。 </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*func_ptr)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  'func_ptr'    'void func(int){}' void (ClassType::*mem_func_ptr)(int); //  'mem_func_ptr'  -  'ClassType'  'void ClassType::func(int){}'</span></span></code> </pre><br><ul><li> 您可以创建到第一个链接（对象链接），但是不能创建第二个链接。 </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (&amp;func_ref)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  'func_ref'    'void func(int){}' //-------------------- //   -    </span></span></code> </pre></blockquote> 在这里，我仅提及一些有关代码生成的内容。 由于在C ++ 11之前还没有参数数目可变的模板，因此可以<a href="">通过</a>在输入端<a href="">具有大量参数的主模板进行特殊化</a>并通过默认的伪参数对其进行初始化来<a href="">确定</a>所有参数可能不同<a href="">的模板</a> 。 同样的情况也适用于函数重载，例如 也没有带有可变数量参数的宏。 由于用手编写了60-70行相同类型的模板专业化代码，因此重载函数是一项相当乏味且无用的任务，而且还充满了犯错误的可能性，为此我编写了一个简单的模板和函数重载代码生成器。 我决定限制自己将函数定义为24个参数，这在代码中看起来很麻烦，但简单明了： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class"> :</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)()&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(...)&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0)&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0 ...)&gt; :</span></span> true_type {};</code> </pre><br>  <b>...</b> <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T3</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T4</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T5</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T6</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T7</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T8</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T9</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T10</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T11</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T12</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T13</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T14</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T15</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T16</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T17</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T18</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T19</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T20</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T21</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T22</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T23</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T24</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T3</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T4</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T5</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T6</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T7</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T8</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T9</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T10</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T11</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T12</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T13</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T14</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T15</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T16</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T17</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T18</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T19</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T20</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T21</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T22</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T23</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T24</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24 ...)&gt; :</span></span> true_type {}; }</code> </pre><br> 我们为SFINAE技术定义了上一章中我们熟悉的类型： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-comment"><span class="hljs-comment">// SFINAE magic typedef char _yes_type; struct _no_type { char padding[8]; }; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">为了方便起见还有一些宏</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IS_MEM_FUN_PTR_CLR \ template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS) const volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...) const volatile); #ifdef _STDEX_CDECL _no_type _STDEX_CDECL _is_mem_function_ptr(...); #define _IS_MEM_FUN_CDECL_PTR \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS) const volatile); #define _IS_MEM_FUN_STDCALL_PTR \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS) const volatile); #define _IS_MEM_FUN_FASTCALL_PTR \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS) const volatile); #else _no_type _is_mem_function_ptr(...); #define _IS_MEM_FUN_CDECL_PTR #define _IS_MEM_FUN_STDCALL_PTR #define _IS_MEM_FUN_FASTCALL_PTR #endif #define _IS_MEM_FUN_PTR \ _IS_MEM_FUN_PTR_CLR \ _IS_MEM_FUN_CDECL_PTR \ _IS_MEM_FUN_STDCALL_PTR \ _IS_MEM_FUN_FASTCALL_PTR }</span></span></span></span></code> </pre><br></div></div><br> 定义了宏，以便重新定义<b>TYPES</b>和<b>ARGS</b>定义为类型和参数的列表，然后用<b>_IS_MEM_FUN_PTR</b>宏替换预处理器为所有可能的函数类型生成定义，相对方便。 还值得关注的事实是，对于Microsoft的编译器来说， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调用协议</a> （ <b>__fastcall</b> ， <b>__stdcall</b>和<b>__cdecl</b> ）也<b>很重要</b> ，因为 使用不同的约定，函数将有所不同，尽管它们具有相同的参数集和返回值。 结果，整个宏宏设计非常紧凑地使用： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES , class T0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS T0 _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES , class T0, class T1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS T0, T1 _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS</span></span></code> </pre><br>  <b>...</b> <br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES , class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24 _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      define  : #undef _IS_MEM_FUN_PTR #undef _IS_MEM_FUN_PTR_CLR #undef _IS_MEM_FUN_CDECL_PTR #undef _IS_MEM_FUN_STDCALL_PTR #undef _IS_MEM_FUN_FASTCALL_PTR }</span></span></span></span></code> </pre><br> 现在，所有内容都写成： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsRef</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_mem_function_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> _Tp *p; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(_is_mem_function_ptr(_is_mem_function_ptr_impl::p)) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(_yes_type)); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, _is_mem_function_ptr_impl::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)&gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_mem_function_ptr_impl</span></span></span><span class="hljs-class">&lt;_Tp, true&gt;:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_mem_function_ptr_helper</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _is_mem_function_ptr_impl&lt;_Tp, is_reference&lt;_Tp&gt;::value&gt;::type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsMemberFunctionPtr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser_impl</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser_impl</span></span></span><span class="hljs-class">&lt;_Tp, false&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _is_function_ptr_helper&lt;_Tp*&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsRef</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">true</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser</span></span></span><span class="hljs-class">&lt;_Tp, false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _is_function_chooser_impl&lt;_Tp, _is_mem_function_ptr_helper&lt;_Tp&gt;::value&gt;::value; }; }</code> </pre><br> 要检查类型是否为类的成员函数，首先要检查该类型是否为引用。 然后，将创建此类型的指针并将其替换为probe函数。 使用SFINAE技术，编译器为此类指针选择探针函数的必要重载，并根据与<i>_yes_type</i>的比较结果形成结果。 <br><br> 基于对类的成员函数的检查，对类型是否属于函数类型进行类型检查。 我们检查类型是否为引用，如果不是，则为该类型的指针寻找合适的模板探针结构专业化，对于具有最多24个参数的任何函数指针，其<i>均为true_type</i> 。 <br><br> 现在，我们使用结果来实现<i>is_function</i> 。 在这里，由于与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一部分</a>相同的原因，我无法从<i>integral_constant</i>继承此结构，因此“模拟”了<i>integrated_constant</i>的行为。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_function template&lt;class _Tp&gt; struct is_function { static const bool value = detail::_is_function_chooser&lt;_Tp, is_reference&lt;_Tp&gt;::value&gt;::value; typedef const bool value_type; typedef integral_constant&lt;bool, is_function::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } };</span></span></code> </pre><br> 为了实现<i>is_member_function_pointer，</i>它仍然更加简单： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_member_function_pointer template&lt;class _Tp&gt; struct is_member_function_pointer : public detail::_is_mem_function_ptr_helper&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type { };</span></span></code> </pre><br> 此外，基于这些模式，原则上我们可以确定类型是否是该类的成员： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_impl1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _not_&lt; _or_&lt;_is_function_ptr_helper&lt;_Tp&gt;, _is_mem_function_ptr_helper&lt;_Tp&gt; &gt; &gt;::type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_impl2</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_impl2</span></span></span><span class="hljs-class">&lt;_Tp _Cp::*&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_helper</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _and_&lt;_is_member_object_pointer_impl1&lt;_Tp&gt;, _is_member_object_pointer_impl2&lt;_Tp&gt; &gt;::type {}; } <span class="hljs-comment"><span class="hljs-comment">// is_member_object_pointer template&lt;class _Tp&gt; struct is_member_object_pointer : public detail::_is_member_object_pointer_helper&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type { };</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">从第一部分开始对类型使用'and'，'or'，'not'逻辑运算</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void_type</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//typedef void void_type; template&lt;class _B1 = void_type, class _B2 = void_type, class _B3 = void_type, class _B4 = void_type&gt; struct _or_ : public conditional&lt;_B1::value, _B1, _or_&lt;_B2, _or_&lt;_B3, _B4&gt; &gt; &gt;::type { }; template&lt;&gt; struct _or_&lt;void_type, void_type, void_type, void_type&gt;; template&lt;class _B1&gt; struct _or_&lt;_B1, void_type, void_type, void_type&gt; : public _B1 { }; template&lt;class _B1, class _B2&gt; struct _or_&lt;_B1, _B2, void_type, void_type&gt; : public conditional&lt;_B1::value, _B1, _B2&gt;::type { }; template&lt;class _B1, class _B2, class _B3&gt; struct _or_&lt;_B1, _B2, _B3, void_type&gt; : public conditional&lt;_B1::value, _B1, _or_&lt;_B2, _B3&gt; &gt;::type { }; template&lt;class _B1 = void_type, class _B2 = void_type, class _B3 = void_type, class _B4 = void_type&gt; struct _and_; template&lt;&gt; struct _and_&lt;void_type, void_type, void_type, void_type&gt;; template&lt;class _B1&gt; struct _and_&lt;_B1, void_type, void_type, void_type&gt; : public _B1 { }; template&lt;class _B1, class _B2&gt; struct _and_&lt;_B1, _B2, void_type, void_type&gt; : public conditional&lt;_B1::value, _B2, _B1&gt;::type { }; template&lt;class _B1, class _B2, class _B3&gt; struct _and_&lt;_B1, _B2, _B3, void_type&gt; : public conditional&lt;_B1::value, _and_&lt;_B2, _B3&gt;, _B1&gt;::type { }; template&lt;class _Pp&gt; struct _not_ { static const bool value = !bool(_Pp::value); typedef const bool value_type; typedef integral_constant&lt;bool, _not_::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } }; }</span></span></code> </pre><br></div></div><br> 在这里，我们对类型使用逻辑运算，这些运算在<i>条件</i>模板的帮助<i>下</i>最终选择合适的模板类型。 因此，在编译阶段，模板编程的所有辉煌之处，我们已经掌握了有关类型是否为类成员的信息。 相当“愤怒”，但多么壮观和有效！ <br><br> 在相同的逻辑元素上进行更多的纯模板编程，我们具有<i>is_fundamental</i> ， <i>is_compound</i>等。 迹象（这使我高兴，但是您呢？）： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_arithmetic template&lt;class _Tp&gt; struct is_arithmetic : public detail::_or_&lt;is_integral&lt;_Tp&gt;, is_floating_point&lt;_Tp&gt; &gt;::type { }; // is_fundamental template&lt;class _Tp&gt; struct is_fundamental : public detail::_or_&lt;is_arithmetic&lt;_Tp&gt;, is_void&lt;_Tp&gt;, is_null_pointer&lt;_Tp&gt; &gt;::type {}; // is_object template&lt;class _Tp&gt; struct is_object : public detail::_not_&lt; detail::_or_&lt; is_function&lt;_Tp&gt;, is_reference&lt;_Tp&gt;, is_void&lt;_Tp&gt; &gt; &gt;::type {}; // is_scalar template&lt;class _Tp&gt; struct is_scalar : public detail::_or_&lt;is_arithmetic&lt;_Tp&gt;, is_pointer&lt;_Tp&gt;, is_member_pointer&lt;_Tp&gt;, is_null_pointer&lt;_Tp&gt;/*, is_enum&lt;_Tp&gt;*/ &gt;::type {}; // is_compound template&lt;class _Tp&gt; struct is_compound: public detail::_not_&lt;is_fundamental&lt;_Tp&gt; &gt;::type { };</span></span></code> </pre><blockquote> 细心的读者会注意到<i>is_enum</i>的定义<i>已被</i>注释掉。 事实是我没有找到将<b>枚举</b>与其他类型区分开的方法，但是我认为如果不使用依赖于编译器的宏，这是可行的。 也许一位细心而有见识的读者会在这方面告诉您您的方式或思路。 </blockquote> 要确定类型是类这一事实，现在就不再需要： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsReference</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_class_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_class_helper</span></span></span><span class="hljs-class">&lt;_Tp, false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, (is_scalar&lt;_Tp&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//&amp;&amp; !is_union&lt;_Tp&gt;::value &gt;::value &amp;&amp; (is_array&lt;_Tp&gt;::value == bool(false)) &amp;&amp; (is_void&lt;_Tp&gt;::value == bool(false)) &amp;&amp; (is_function&lt;_Tp&gt;::value == bool(false))&gt; type; }; } // is_class template&lt;class _Tp&gt; struct is_class : public detail::_is_class_helper&lt;typename remove_cv&lt;_Tp&gt;::type, is_reference&lt;_Tp&gt;::value&gt;::type { };</span></span></code> </pre><br> 一切都会好起来的，但是在一般情况下，C ++中的并集不能与类区别开来。 因为它们的“外部表现形式”非常相似，并且没有编译错误，我无法验证差异（例如，无法从<b>union</b>继承）。 也许有人会告诉您一个棘手的方法来确定编译时的并集，然后<i>is_class</i>将完全符合标准。 <br><br> 在本章的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最后一部分</a> ，我将讨论如何实现<i>std ::衰减</i>和<i>std :: common_type</i> ，以及还有哪些要添加到<b>type_traits中</b> 。 <br><br> 谢谢您的关注。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418347/">https://habr.com/ru/post/zh-CN418347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418335/index.html">积极Hack Days 8的对抗：解析攻击链</a></li>
<li><a href="../zh-CN418337/index.html">热门，夏季DataGrip 2018.2</a></li>
<li><a href="../zh-CN418339/index.html">“手动”操纵器</a></li>
<li><a href="../zh-CN418341/index.html">系统管理员日快乐！ 具有意义的贺卡</a></li>
<li><a href="../zh-CN418345/index.html">信息交换格式的文档-简便</a></li>
<li><a href="../zh-CN418349/index.html">Azure Kubernetes服务（AKS）和PowerShell</a></li>
<li><a href="../zh-CN418353/index.html">思维导图而不是测试用例，或者可视化如何使您更快地测试应用程序</a></li>
<li><a href="../zh-CN418355/index.html">按哈希表排序（也按树数和HashMap排序）</a></li>
<li><a href="../zh-CN418357/index.html">DEFCON 23.“对专业网络跟踪者的自白。” 肯·威斯汀</a></li>
<li><a href="../zh-CN418359/index.html">金融科技摘要：识别金融超市的公民，QIWI前雇员开采了2.4％的比特币，金砖四国和区块链</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>