<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèΩ üòã ‚õ∏Ô∏è Guide complet pour changer d'expressions dans Java 12 üì± ü§úüèæ üë®üèæ‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le bon vieux switch en Java depuis le premier jour. Nous l'utilisons tous et nous y sommes habitu√©s - en particulier ses bizarreries. (Est-ce que quel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide complet pour changer d'expressions dans Java 12</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443464/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/lt/a6/pqlta6vh4m5bec2xrtku1smn7em.jpeg"></div><br><p> Le bon vieux <code>switch</code> en Java depuis le premier jour.  Nous l'utilisons tous et nous y sommes habitu√©s - en particulier ses bizarreries.  (Est-ce que quelqu'un d'autre est ennuy√© par la <code>break</code> ?) Mais maintenant tout commence √† changer: dans Java 12, le <strong>commutateur</strong> au lieu d'un op√©rateur est devenu une expression: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// as we'll see in "Exhaustiveness", `default` is not necessary default -&gt; throw new IllegalArgumentException("Seriously?!"); };</span></span></code> </pre> <br><p>  <strong>Switch a d√©sormais</strong> la possibilit√© de renvoyer le r√©sultat de son travail, qui peut √™tre affect√© √† une variable;  Vous pouvez √©galement utiliser la syntaxe de style lambda, qui vous permet de vous d√©barrasser de la transmission pour tous les <code>case</code> o√π il n'y a pas d'instruction <code>break</code> . </p><br><p>  Dans ce guide, je vais vous expliquer tout ce que vous devez savoir sur les expressions de commutateur dans Java 12. </p><a name="habracut"></a><br><h2 id="predvaritelnyy-obzor">  Aper√ßu </h2><br><p>  Selon les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©cifications pr√©liminaires du langage</a> , les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expressions de commutateur</a> commencent tout juste √† √™tre impl√©ment√©es dans Java 12. </p><br><p>  Cela signifie que cette construction de contr√¥le peut √™tre modifi√©e dans les futures versions de la sp√©cification de langage. </p><br><p>  Pour commencer √† utiliser la nouvelle version de <code>switch</code> vous devez utiliser l'option de ligne de commande <code>--enable-preview</code> pendant la compilation et au d√©marrage du programme (vous devez √©galement utiliser <code>--release 12</code> lors de la compilation - note du traducteur). </p><br><p>  Gardez donc √† l'esprit que le <strong>commutateur</strong> , en tant qu'expression, n'a pas actuellement la syntaxe finale dans Java 12. </p><br><p>  Si vous avez envie de jouer avec tout cela vous-m√™me, vous pouvez visiter mon projet de d√©monstration Java X sur un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . </p><br><h2 id="problema-s-operatorami-v-switch">  Probl√®me avec les instructions dans le commutateur </h2><br><p>  Avant de passer √† un aper√ßu des innovations en mati√®re de <strong>commutation</strong> , √©valuons rapidement une situation.  Supposons que nous soyons confront√©s √† une "terrible" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">boul√©e ternaire</a> et que nous voulions la convertir en boul√©e ordinaire.  Voici une fa√ßon de proc√©der: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// don't forget to `break` or you're screwed! break; case FALSE: result = false; break; case FILE_NOT_FOUND: // intermediate variable for demo purposes; // wait for it... var ex = new UncheckedIOException("This is ridiculous!", new FileNotFoundException()); throw ex; default: // ... here we go: // can't declare another variable with the same name var ex2 = new IllegalArgumentException("Seriously?!"); throw ex2; }</span></span></code> </pre> <br><p>  D'accord, c'est tr√®s g√™nant.  Comme de nombreuses autres options de <strong>commutation</strong> trouv√©es dans "nature", l'exemple ci-dessus calcule simplement la valeur d'une variable et l'affecte, mais l'impl√©mentation est contourn√©e (d√©clarer le <code>result</code> l'identifiant et l'utiliser plus tard), r√©p√©t√©e (ma <code>break</code> 'et toujours le r√©sultat de copier-coller) et sujette aux erreurs (vous avez oubli√© une autre branche? Oh!).  Il y a clairement quelque chose √† am√©liorer. </p><br><p>  Essayons de r√©soudre ces probl√®mes en pla√ßant le <strong>commutateur</strong> dans une m√©thode distincte: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toBoolean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException(<span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// without default branch, the method wouldn't compile default: throw new IllegalArgumentException("Seriously?!"); } }</span></span></code> </pre> <br><p>  C'est beaucoup mieux: il n'y a pas de variable fictive, pas de <code>break</code> encombrant le code et les messages du compilateur sur l'absence de <code>default</code> (m√™me si ce n'est pas n√©cessaire, comme dans ce cas). </p><br><p>  Mais, si vous y r√©fl√©chissez, nous ne sommes pas tenus de cr√©er des m√©thodes juste pour contourner la fonction de langage maladroite.  Et cela sans m√™me consid√©rer qu'un tel refactoring n'est pas toujours possible.  Non, nous avons besoin d'une meilleure solution! </p><br><h2 id="predstavlyaem-switch-vyrazheniya">  Pr√©sentation des expressions de commutateur! </h2><br><p>  Comme je l'ai montr√© au d√©but de l'article, √† partir de Java 12 et sup√©rieur, vous pouvez r√©soudre le probl√®me ci-dessus comme suit: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// as we'll see in "Exhaustiveness", `default` is not necessary default -&gt; throw new IllegalArgumentException("Seriously?!"); };</span></span></code> </pre> <br><p>  Je pense que c'est assez √©vident: si <code>ternartBool</code> est <code>TRUE</code> , alors le <code>result</code> 'sera d√©fini sur <code>true</code> (en d'autres termes, <code>TRUE</code> devient <code>true</code> ).  <code>FALSE</code> devient <code>false</code> . </p><br><p>  Deux pens√©es surgissent imm√©diatement: </p><br><ul><li>  <code>switch</code> peut avoir un r√©sultat; </li><li>  qu'est-ce que les fl√®ches? </li></ul><br><p>  Avant de me plonger dans les d√©tails des nouvelles fonctionnalit√©s du <strong>commutateur</strong> , je parlerai au d√©but de ces deux aspects principaux. </p><br><h3 id="vyrazhenie-ili-operator">  Expression ou d√©claration </h3><br><p>  Vous serez peut-√™tre surpris que le <strong>changement soit</strong> d√©sormais une expression.  Mais qu'√©tait-il avant? </p><br><p>  Avant Java 12, un <strong>commutateur</strong> √©tait un op√©rateur - une construction imp√©rative qui r√©gule le flux de contr√¥le. </p><br><p>  Consid√©rez les diff√©rences entre les anciennes et les nouvelles versions de <strong>switch</strong> comme la diff√©rence entre <code>if</code> et l'op√©rateur ternaire.  Ils v√©rifient tous les deux la condition logique et effectuent des branchements en fonction de son r√©sultat. </p><br><p>  La diff√©rence est que <code>if</code> ex√©cute simplement le bloc correspondant, tandis que l'op√©rateur ternaire renvoie un r√©sultat: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(condition) { result = doThis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = doThat(); } result = condition ? doThis() : doThat();</code> </pre> <br><p>  Il en va de m√™me pour <strong>switch</strong> : avant Java 12, si vous vouliez calculer la valeur et enregistrer le r√©sultat, vous devez soit l'assigner √† une variable (puis la <code>break</code> ), soit la renvoyer √† partir d'une m√©thode cr√©√©e sp√©cifiquement pour l' <code>switch</code> . </p><br><p>  Maintenant, l'expression enti√®re de l' <strong>instruction switch</strong> est √©valu√©e (la branche correspondante est s√©lectionn√©e pour ex√©cution) et le r√©sultat des calculs peut √™tre affect√© √† une variable. </p><br><p>  Une autre diff√©rence entre l'expression et l'instruction est que l' <strong>instruction switch</strong> , car elle fait partie de l'instruction, doit se terminer par un point-virgule, contrairement √† l' <strong>instruction switch</strong> classique. </p><br><h3 id="strelka-ili-dvoetochie">  Fl√®che ou deux points </h3><br><p>  L'exemple d'introduction a utilis√© la nouvelle syntaxe de style lambda avec une fl√®che entre l'√©tiquette et la partie en cours d'ex√©cution.  Il est important de comprendre que pour cela, il n'est pas n√©cessaire d'utiliser <code>switch</code> comme expression.  En fait, l'exemple ci-dessous est √©quivalent au code donn√© au d√©but de l'article: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Seriously?!!?"</span></span>); };</code> </pre> <br><p>  Notez que vous pouvez maintenant utiliser <code>break</code> avec une valeur!  Cela correspond parfaitement aux <code>switch</code> √† l'ancienne qui utilisent <code>break</code> sans aucune signification.  Alors, dans quel cas une fl√®che signifie-t-elle une expression au lieu d'un op√©rateur, pourquoi est-elle ici?  Juste une syntaxe hipster? </p><br><p>  Historiquement, les deux-points marquent simplement le point d'entr√©e du bloc d'instructions.  √Ä partir de ce moment, l'ex√©cution de tout le code ci-dessous commence, m√™me lorsqu'une autre √©tiquette est rencontr√©e.  En <code>switch</code> nous savons que cela passe au <code>case</code> suivant (chute): l'√©tiquette du <code>case</code> d√©termine o√π le flux de contr√¥le passe.  Pour le compl√©ter, vous avez besoin d'une <code>break</code> ou d'un <code>return</code> . </p><br><p>  √Ä son tour, l'utilisation de la fl√®che signifie que seul le bloc √† sa droite sera ex√©cut√©.  Et aucun "√©chec". </p><br><h2 id="podrobnee-ob-evolyucii-switch">  En savoir plus sur l'√©volution du commutateur </h2><br><h3 id="neskolko-metok-na-case">  Plusieurs √©tiquettes sur le bo√Ætier </h3><br><p>  Jusqu'√† pr√©sent, chaque <code>case</code> qu'une seule √©tiquette.  Mais maintenant, tout a chang√© - un <code>case</code> peut correspondre √† plusieurs √©tiquettes: </p><br><pre> <code class="java hljs">String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// `default, case FILE_NOT_FOUND -&gt; ...` does not work // (neither does other way around), but that makes // sense because using only `default` suffices default -&gt; "insane"; };</span></span></code> </pre> <br><p>  Le comportement doit √™tre √©vident: <code>TRUE</code> et <code>FALSE</code> produisent le m√™me r√©sultat - l'expression "sain" est √©valu√©e. </p><br><p>  Il s'agit d'une innovation plut√¥t int√©ressante qui a remplac√© l'utilisation multiple du <code>case</code> lorsqu'il √©tait n√©cessaire de mettre en ≈ìuvre une transition directe vers le <code>case</code> suivant. </p><br><h3 id="tipy-za-predelami-enum">  Types en dehors d'Enum </h3><br><p>  Tous les exemples de <code>switch</code> de cet article utilisent <code>enum</code> .  Et les autres types?  Les expressions et les <code>switch</code> peuvent √©galement fonctionner avec <code>String</code> , <code>int</code> , (consultez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> ) <code>short</code> , <code>byte</code> , <code>char</code> et leurs wrappers.  Jusqu'√† pr√©sent, rien n'a chang√©, bien que l'id√©e d'utiliser des types de donn√©es tels que <code>float</code> et <code>long</code> soit toujours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valide</a> (du deuxi√®me au dernier paragraphe). </p><br><h2 id="podrobnee-o-strelke">  Plus sur la fl√®che </h2><br><p>  Examinons deux propri√©t√©s sp√©cifiques √† la forme de fl√®che d'un enregistrement s√©parateur: </p><br><ul><li>  absence de transition de bout en bout au <code>case</code> suivant; </li><li>  blocs d'op√©rateurs. </li></ul><br><h3 id="otsutstvie-skvoznogo-perehoda-k-sleduyuschemu-case">  Pas de transmission au cas suivant </h3><br><p>  Voici ce que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 325</a> dit √† ce sujet: </p><br><blockquote>  La conception actuelle de l' <code>switch</code> en Java est √©troitement li√©e aux langages tels que C et C ++ et prend en charge la s√©mantique de bout en bout par d√©faut.  Bien que cette m√©thode traditionnelle de contr√¥le soit souvent utile pour √©crire du code de bas niveau (comme les analyseurs pour le codage binaire), puisque le <code>switch</code> utilis√© dans le code de niveau sup√©rieur, les erreurs de cette approche commencent √† l'emporter sur sa flexibilit√©. </blockquote><p>  Je suis totalement d'accord et salue l'opportunit√© d'utiliser <strong>switch</strong> sans comportement par d√©faut: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Bool was sane"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// in colon-form, if `ternaryBool` is `TRUE` or `FALSE`, // we would see both messages; in arrow-form, only one // branch is executed default -&gt; System.out.println("Bool was insane"); }</span></span></code> </pre> <br><p>  Il est important d'apprendre que cela n'a rien √† voir avec l'utilisation de <strong>switch</strong> comme expression ou comme instruction.  Le facteur d√©cisif ici est la fl√®che contre le c√¥lon. </p><br><h3 id="bloki-operatorov">  Blocs op√©rateur </h3><br><p>  Comme dans le cas des lambdas, la fl√®che peut pointer vers un seul op√©rateur (comme ci-dessus) ou un bloc mis en √©vidence avec des accolades: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(Bool.random()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bool true"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// return with `break`, not `return` break true; } case FALSE -&gt; { System.out.println("Bool false"); break false; } case FILE_NOT_FOUND -&gt; { var ex = new UncheckedIOException("This is ridiculous!", new FileNotFoundException()); throw ex; } default -&gt; { var ex = new IllegalArgumentException("Seriously?!"); throw ex; } };</span></span></code> </pre> <br><p>  Les blocs qui doivent √™tre cr√©√©s pour les op√©rateurs multilignes ont un avantage suppl√©mentaire (qui n'est pas requis lors de l'utilisation de deux points), ce qui signifie que pour utiliser les m√™mes noms de variables dans diff√©rentes branches, le <code>switch</code> ne n√©cessite pas de traitement sp√©cial. </p><br><p>  S'il vous a sembl√© inhabituel de sortir des blocs en utilisant la <code>break</code> plut√¥t que le <code>return</code> , ne vous inqui√©tez pas - cela m'a √©galement intrigu√© et m'a sembl√© √©trange.  Mais ensuite, j'y ai r√©fl√©chi et je suis arriv√© √† la conclusion que cela avait du sens, car il pr√©serve l'ancien style de la construction de <code>switch</code> , qui utilise la <code>break</code> sans valeurs. </p><br><h2 id="podrobnee-o-vyrazheniyah-switch">  En savoir plus sur les instructions switch </h2><br><p>  Et enfin et surtout, les sp√©cificit√©s de l'utilisation de <code>switch</code> comme expression: </p><br><ul><li>  expressions multiples; </li><li>  retour anticip√© ( <code>return</code> anticip√©); </li><li>  couverture de toutes les valeurs. </li></ul><br><p>  Veuillez noter que peu importe le formulaire utilis√©! </p><br><h3 id="mnozhestvennye-vyrazheniya">  Expressions multiples </h3><br><p>  Les expressions de commutateur sont des expressions multiples.  Cela signifie qu'ils n'ont pas leur propre type, mais peuvent √™tre parmi plusieurs types.  Le plus souvent, les expressions lambda sont utilis√©es comme telles: <code>s -&gt; s + " "</code> , peuvent √™tre <code>Function&lt;String, String&gt;</code> , mais peuvent √©galement √™tre <code>Function&lt;Serializable, Object&gt;</code> ou <code>UnaryOperator&lt;String&gt;</code> . </p><br><p>  √Ä l'aide d'expressions de commutateur, un type est d√©termin√© par l'interaction entre l'endroit o√π le <strong>commutateur est</strong> utilis√© et les types de ses branches.  Si une expression de commutateur est affect√©e √† une variable typ√©e, pass√©e en argument ou autrement utilis√©e dans un contexte o√π le type exact est connu (c'est ce qu'on appelle le type cible), toutes ses branches doivent correspondre √† ce type.  Voici ce que nous avons fait jusqu'√† pr√©sent: </p><br><pre> <code class="java hljs">String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"insane"</span></span>; };</code> </pre> <br><p>  Par cons√©quent, le <code>switch</code> affect√© √† la variable de <code>result</code> de type <code>String</code> .  Par cons√©quent, <code>String</code> est le type cible et toutes les branches doivent renvoyer un r√©sultat de type <code>String</code> . </p><br><p>  La m√™me chose se produit ici: </p><br><pre> <code class="java hljs">Serializable serializableMessage = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (bool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// note that we don't throw the exception! // but it's `Serializable`, so it matches the target type default -&gt; new IllegalArgumentException("insane"); };</span></span></code> </pre> <br><p>  Que va-t-il se passer maintenant? </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compiler infers super type of `String` and // `IllegalArgumentException` ~&gt; `Serializable` var serializableMessage = switch (bool) { case TRUE, FALSE -&gt; "sane"; // note that we don't throw the exception! default -&gt; new IllegalArgumentException("insane"); };</span></span></code> </pre> <br><p>  (Pour l'utilisation du type var, lisez dans notre dernier article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">26 recommandations pour l'utilisation du type var en Java</a> - note du traducteur) </p><br><p>  Si le type cible est inconnu, du fait que nous utilisons var, le type est calcul√© en trouvant le supertype le plus sp√©cifique des types cr√©√©s par les branches. </p><br><h3 id="ranniy-vozvrat">  Retour anticip√© </h3><br><p>  La cons√©quence de la diff√©rence entre l'expression et l' <code>switch</code> est que vous pouvez utiliser <code>return</code> pour quitter l' <code>switch</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-comment"><span class="hljs-comment">// `return` is only possible from block case TRUE, FALSE -&gt; { return "sane"; } default -&gt; { return "This is ridiculous!"; } }; }</span></span></code> </pre> <br><p>  ... vous ne pouvez pas utiliser <code>return</code> dans une expression ... </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-comment"><span class="hljs-comment">// this does not compile - error: // "return outside of enclosing switch expression" case TRUE, FALSE -&gt; { return "sane"; } default -&gt; { return "This is ridiculous!"; } }; }</span></span></code> </pre> <br><p>  Cela a du sens si vous utilisez une fl√®che ou un deux-points. </p><br><h3 id="pokrytie-vseh-variantov">  Couvrant toutes les options </h3><br><p>  Si vous utilisez <code>switch</code> comme op√©rateur, peu importe que toutes les options soient couvertes ou non.  Bien s√ªr, vous pouvez accidentellement ignorer le <code>case</code> , et le code ne fonctionnera pas correctement, mais le compilateur ne s'en soucie pas - vous, votre IDE et vos outils d'analyse de code resteront seuls. </p><br><p>  Les expressions de commutateur aggravent ce probl√®me.  O√π doit-on passer si l'√©tiquette souhait√©e est manquante?  La seule r√©ponse que Java puisse donner est de retourner <code>null</code> pour les types de r√©f√©rence et une valeur par d√©faut pour les primitives.  Cela provoquerait beaucoup d'erreurs dans le code principal. </p><br><p>  Pour √©viter un tel r√©sultat, le compilateur peut vous aider.  Pour les instructions switch, le compilateur insistera pour que toutes les options possibles soient couvertes.  Regardons un exemple qui pourrait conduire √† une erreur de compilation: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compile error: // "the switch expression does not cover all possible input values" boolean result = switch (ternaryBool) { case TRUE -&gt; true; // no case for `FALSE` case FILE_NOT_FOUND -&gt; throw new UncheckedIOException( "This is ridiculous!", new FileNotFoundException()); };</span></span></code> </pre> <br><p>  La solution suivante est int√©ressante: l'ajout de la branche <code>default</code> corrigera certainement l'erreur, mais ce n'est pas la seule solution - vous pouvez toujours ajouter un <code>case</code> pour <code>FALSE</code> . </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compiles without `default` branch because // all cases for `ternaryBool` are covered boolean result = switch (ternaryBool) { case TRUE -&gt; true; case FALSE -&gt; false; case FILE_NOT_FOUND -&gt; throw new UncheckedIOException( "This is ridiculous!", new FileNotFoundException()); };</span></span></code> </pre> <br><p>  Oui, le compilateur pourra enfin d√©terminer si toutes les valeurs d'√©num√©ration sont couvertes (si toutes les options sont √©puis√©es), et ne pas d√©finir de valeurs par d√©faut inutiles!  Asseyons-nous un instant dans une gratitude silencieuse. </p><br><p>  Bien que cela soul√®ve encore une question.  Et si quelqu'un prend et transforme un <strong>bool√©en</strong> fou en <strong>bool√©en</strong> quaternion en ajoutant une quatri√®me valeur?  Si vous recompilez l'expression de commutateur pour le <strong>Bool</strong> √©tendu, vous obtiendrez une erreur de compilation (l'expression n'est plus exhaustive).  Sans recompilation, cela se transformera en un probl√®me d'ex√©cution.  Pour r√©soudre ce probl√®me, le compilateur passe √† la branche <code>default</code> , qui se comporte de la m√™me mani√®re que celle que nous avons utilis√©e jusqu'√† pr√©sent, lan√ßant une exception. </p><br><p>  Dans Java 12, l'√©tendue de toutes les valeurs sans la branche <code>default</code> ne fonctionne que pour l' <code>enum</code> , mais lorsque le <code>switch</code> devient plus puissant dans les futures versions de Java, il peut √©galement fonctionner avec des types arbitraires.  Si les √©tiquettes de <code>case</code> peuvent non seulement v√©rifier l'√©galit√©, mais aussi faire des comparaisons (par exemple, _ &lt;5 -&gt; ...) - cela couvrira toutes les options pour les types num√©riques. </p><br><h2 id="razmyshlenie">  Penser </h2><br><p>  Nous avons appris de l'article que Java 12 transforme un <code>switch</code> en une expression, lui donnant de nouvelles fonctionnalit√©s: </p><br><ul><li>  maintenant un <code>case</code> peut correspondre √† plusieurs √©tiquettes; </li><li>  Le nouveau <code>case ‚Ä¶ -&gt; ‚Ä¶</code> forme de fl√®che <code>case ‚Ä¶ -&gt; ‚Ä¶</code> suit la syntaxe des expressions lambda: <br><ul><li>  les op√©rateurs ou blocs sur une seule ligne sont autoris√©s; </li><li>  le passage au <code>case</code> suivant <code>case</code> emp√™ch√©; </li></ul></li><li>  maintenant, l'expression enti√®re est √©valu√©e comme une valeur, qui peut ensuite √™tre affect√©e √† une variable ou pass√©e dans le cadre d'une instruction plus grande; </li><li>  expression multiple: si le type cible est connu, alors toutes les branches doivent lui correspondre.  Sinon, un type sp√©cifique est d√©fini qui correspond √† toutes les branches; </li><li>  <code>break</code> peut renvoyer une valeur d'un bloc; </li><li>  pour une expression de <code>switch</code> utilisant <code>enum</code> , le compilateur v√©rifie la port√©e de toutes ses valeurs.  Si <code>default</code> absent, une branche est ajout√©e qui l√®ve une exception. </li></ul><br><p>  O√π cela nous m√®nera-t-il?  Tout d'abord, comme il ne s'agit pas de la version finale de <code>switch</code> , vous avez toujours le temps de laisser des commentaires sur la liste de diffusion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Amber</a> si vous n'√™tes pas d'accord avec quelque chose. </p><br><p>  Ensuite, en supposant que le <strong>commutateur</strong> reste tel qu'il est actuellement, je pense que la forme de fl√®che deviendra la nouvelle option par d√©faut.  Sans passage direct au <code>case</code> suivant et avec des expressions lambda concises (il est tr√®s naturel d'avoir un cas et une instruction sur une ligne), le <code>switch</code> semble beaucoup plus compact et n'affecte pas la lisibilit√© du code.  Je suis s√ªr que je n'utiliserai deux points que si je dois traverser le passage. </p><br><p>  Qu'en penses-tu?  Satisfait de la tournure des √©v√©nements? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443464/">https://habr.com/ru/post/fr443464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443452/index.html">L'arm√©e russe cr√©era son propre Internet ferm√©</a></li>
<li><a href="../fr443456/index.html">Nous vous invitons √† Yandex NLP pendant une semaine</a></li>
<li><a href="../fr443458/index.html">6 bugs syst√®me divertissants dans le fonctionnement de Kubernetes [et leur solution]</a></li>
<li><a href="../fr443460/index.html">11 r√©ponses sur Yandex.Directory</a></li>
<li><a href="../fr443462/index.html">Piratage de cam√©ras: vecteurs d'attaque, outils de recherche de vuln√©rabilit√©s et anti-tracking</a></li>
<li><a href="../fr443466/index.html">Roi du d√©veloppement</a></li>
<li><a href="../fr443468/index.html">Quels outils de surveillance de r√©seau sont devenus des leaders dans la version de Gartner</a></li>
<li><a href="../fr443470/index.html">L'histoire de la frappe sur l'exemple d'un grand projet</a></li>
<li><a href="../fr443472/index.html">Vous avez un probl√®me pour acc√©der au cloud? 7 conseils pour ne pas g√¢cher</a></li>
<li><a href="../fr443476/index.html">Comment SimCity a inspir√© toute une g√©n√©ration d'urbanistes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>