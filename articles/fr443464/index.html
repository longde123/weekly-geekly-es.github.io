<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏽 😋 ⛸️ Guide complet pour changer d'expressions dans Java 12 📱 🤜🏾 👨🏾‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le bon vieux switch en Java depuis le premier jour. Nous l'utilisons tous et nous y sommes habitués - en particulier ses bizarreries. (Est-ce que quel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide complet pour changer d'expressions dans Java 12</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443464/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/lt/a6/pqlta6vh4m5bec2xrtku1smn7em.jpeg"></div><br><p> Le bon vieux <code>switch</code> en Java depuis le premier jour.  Nous l'utilisons tous et nous y sommes habitués - en particulier ses bizarreries.  (Est-ce que quelqu'un d'autre est ennuyé par la <code>break</code> ?) Mais maintenant tout commence à changer: dans Java 12, le <strong>commutateur</strong> au lieu d'un opérateur est devenu une expression: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// as we'll see in "Exhaustiveness", `default` is not necessary default -&gt; throw new IllegalArgumentException("Seriously?!"); };</span></span></code> </pre> <br><p>  <strong>Switch a désormais</strong> la possibilité de renvoyer le résultat de son travail, qui peut être affecté à une variable;  Vous pouvez également utiliser la syntaxe de style lambda, qui vous permet de vous débarrasser de la transmission pour tous les <code>case</code> où il n'y a pas d'instruction <code>break</code> . </p><br><p>  Dans ce guide, je vais vous expliquer tout ce que vous devez savoir sur les expressions de commutateur dans Java 12. </p><a name="habracut"></a><br><h2 id="predvaritelnyy-obzor">  Aperçu </h2><br><p>  Selon les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spécifications préliminaires du langage</a> , les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expressions de commutateur</a> commencent tout juste à être implémentées dans Java 12. </p><br><p>  Cela signifie que cette construction de contrôle peut être modifiée dans les futures versions de la spécification de langage. </p><br><p>  Pour commencer à utiliser la nouvelle version de <code>switch</code> vous devez utiliser l'option de ligne de commande <code>--enable-preview</code> pendant la compilation et au démarrage du programme (vous devez également utiliser <code>--release 12</code> lors de la compilation - note du traducteur). </p><br><p>  Gardez donc à l'esprit que le <strong>commutateur</strong> , en tant qu'expression, n'a pas actuellement la syntaxe finale dans Java 12. </p><br><p>  Si vous avez envie de jouer avec tout cela vous-même, vous pouvez visiter mon projet de démonstration Java X sur un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . </p><br><h2 id="problema-s-operatorami-v-switch">  Problème avec les instructions dans le commutateur </h2><br><p>  Avant de passer à un aperçu des innovations en matière de <strong>commutation</strong> , évaluons rapidement une situation.  Supposons que nous soyons confrontés à une "terrible" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">boulée ternaire</a> et que nous voulions la convertir en boulée ordinaire.  Voici une façon de procéder: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// don't forget to `break` or you're screwed! break; case FALSE: result = false; break; case FILE_NOT_FOUND: // intermediate variable for demo purposes; // wait for it... var ex = new UncheckedIOException("This is ridiculous!", new FileNotFoundException()); throw ex; default: // ... here we go: // can't declare another variable with the same name var ex2 = new IllegalArgumentException("Seriously?!"); throw ex2; }</span></span></code> </pre> <br><p>  D'accord, c'est très gênant.  Comme de nombreuses autres options de <strong>commutation</strong> trouvées dans "nature", l'exemple ci-dessus calcule simplement la valeur d'une variable et l'affecte, mais l'implémentation est contournée (déclarer le <code>result</code> l'identifiant et l'utiliser plus tard), répétée (ma <code>break</code> 'et toujours le résultat de copier-coller) et sujette aux erreurs (vous avez oublié une autre branche? Oh!).  Il y a clairement quelque chose à améliorer. </p><br><p>  Essayons de résoudre ces problèmes en plaçant le <strong>commutateur</strong> dans une méthode distincte: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toBoolean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException(<span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// without default branch, the method wouldn't compile default: throw new IllegalArgumentException("Seriously?!"); } }</span></span></code> </pre> <br><p>  C'est beaucoup mieux: il n'y a pas de variable fictive, pas de <code>break</code> encombrant le code et les messages du compilateur sur l'absence de <code>default</code> (même si ce n'est pas nécessaire, comme dans ce cas). </p><br><p>  Mais, si vous y réfléchissez, nous ne sommes pas tenus de créer des méthodes juste pour contourner la fonction de langage maladroite.  Et cela sans même considérer qu'un tel refactoring n'est pas toujours possible.  Non, nous avons besoin d'une meilleure solution! </p><br><h2 id="predstavlyaem-switch-vyrazheniya">  Présentation des expressions de commutateur! </h2><br><p>  Comme je l'ai montré au début de l'article, à partir de Java 12 et supérieur, vous pouvez résoudre le problème ci-dessus comme suit: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// as we'll see in "Exhaustiveness", `default` is not necessary default -&gt; throw new IllegalArgumentException("Seriously?!"); };</span></span></code> </pre> <br><p>  Je pense que c'est assez évident: si <code>ternartBool</code> est <code>TRUE</code> , alors le <code>result</code> 'sera défini sur <code>true</code> (en d'autres termes, <code>TRUE</code> devient <code>true</code> ).  <code>FALSE</code> devient <code>false</code> . </p><br><p>  Deux pensées surgissent immédiatement: </p><br><ul><li>  <code>switch</code> peut avoir un résultat; </li><li>  qu'est-ce que les flèches? </li></ul><br><p>  Avant de me plonger dans les détails des nouvelles fonctionnalités du <strong>commutateur</strong> , je parlerai au début de ces deux aspects principaux. </p><br><h3 id="vyrazhenie-ili-operator">  Expression ou déclaration </h3><br><p>  Vous serez peut-être surpris que le <strong>changement soit</strong> désormais une expression.  Mais qu'était-il avant? </p><br><p>  Avant Java 12, un <strong>commutateur</strong> était un opérateur - une construction impérative qui régule le flux de contrôle. </p><br><p>  Considérez les différences entre les anciennes et les nouvelles versions de <strong>switch</strong> comme la différence entre <code>if</code> et l'opérateur ternaire.  Ils vérifient tous les deux la condition logique et effectuent des branchements en fonction de son résultat. </p><br><p>  La différence est que <code>if</code> exécute simplement le bloc correspondant, tandis que l'opérateur ternaire renvoie un résultat: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(condition) { result = doThis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = doThat(); } result = condition ? doThis() : doThat();</code> </pre> <br><p>  Il en va de même pour <strong>switch</strong> : avant Java 12, si vous vouliez calculer la valeur et enregistrer le résultat, vous devez soit l'assigner à une variable (puis la <code>break</code> ), soit la renvoyer à partir d'une méthode créée spécifiquement pour l' <code>switch</code> . </p><br><p>  Maintenant, l'expression entière de l' <strong>instruction switch</strong> est évaluée (la branche correspondante est sélectionnée pour exécution) et le résultat des calculs peut être affecté à une variable. </p><br><p>  Une autre différence entre l'expression et l'instruction est que l' <strong>instruction switch</strong> , car elle fait partie de l'instruction, doit se terminer par un point-virgule, contrairement à l' <strong>instruction switch</strong> classique. </p><br><h3 id="strelka-ili-dvoetochie">  Flèche ou deux points </h3><br><p>  L'exemple d'introduction a utilisé la nouvelle syntaxe de style lambda avec une flèche entre l'étiquette et la partie en cours d'exécution.  Il est important de comprendre que pour cela, il n'est pas nécessaire d'utiliser <code>switch</code> comme expression.  En fait, l'exemple ci-dessous est équivalent au code donné au début de l'article: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Seriously?!!?"</span></span>); };</code> </pre> <br><p>  Notez que vous pouvez maintenant utiliser <code>break</code> avec une valeur!  Cela correspond parfaitement aux <code>switch</code> à l'ancienne qui utilisent <code>break</code> sans aucune signification.  Alors, dans quel cas une flèche signifie-t-elle une expression au lieu d'un opérateur, pourquoi est-elle ici?  Juste une syntaxe hipster? </p><br><p>  Historiquement, les deux-points marquent simplement le point d'entrée du bloc d'instructions.  À partir de ce moment, l'exécution de tout le code ci-dessous commence, même lorsqu'une autre étiquette est rencontrée.  En <code>switch</code> nous savons que cela passe au <code>case</code> suivant (chute): l'étiquette du <code>case</code> détermine où le flux de contrôle passe.  Pour le compléter, vous avez besoin d'une <code>break</code> ou d'un <code>return</code> . </p><br><p>  À son tour, l'utilisation de la flèche signifie que seul le bloc à sa droite sera exécuté.  Et aucun "échec". </p><br><h2 id="podrobnee-ob-evolyucii-switch">  En savoir plus sur l'évolution du commutateur </h2><br><h3 id="neskolko-metok-na-case">  Plusieurs étiquettes sur le boîtier </h3><br><p>  Jusqu'à présent, chaque <code>case</code> qu'une seule étiquette.  Mais maintenant, tout a changé - un <code>case</code> peut correspondre à plusieurs étiquettes: </p><br><pre> <code class="java hljs">String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// `default, case FILE_NOT_FOUND -&gt; ...` does not work // (neither does other way around), but that makes // sense because using only `default` suffices default -&gt; "insane"; };</span></span></code> </pre> <br><p>  Le comportement doit être évident: <code>TRUE</code> et <code>FALSE</code> produisent le même résultat - l'expression "sain" est évaluée. </p><br><p>  Il s'agit d'une innovation plutôt intéressante qui a remplacé l'utilisation multiple du <code>case</code> lorsqu'il était nécessaire de mettre en œuvre une transition directe vers le <code>case</code> suivant. </p><br><h3 id="tipy-za-predelami-enum">  Types en dehors d'Enum </h3><br><p>  Tous les exemples de <code>switch</code> de cet article utilisent <code>enum</code> .  Et les autres types?  Les expressions et les <code>switch</code> peuvent également fonctionner avec <code>String</code> , <code>int</code> , (consultez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> ) <code>short</code> , <code>byte</code> , <code>char</code> et leurs wrappers.  Jusqu'à présent, rien n'a changé, bien que l'idée d'utiliser des types de données tels que <code>float</code> et <code>long</code> soit toujours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valide</a> (du deuxième au dernier paragraphe). </p><br><h2 id="podrobnee-o-strelke">  Plus sur la flèche </h2><br><p>  Examinons deux propriétés spécifiques à la forme de flèche d'un enregistrement séparateur: </p><br><ul><li>  absence de transition de bout en bout au <code>case</code> suivant; </li><li>  blocs d'opérateurs. </li></ul><br><h3 id="otsutstvie-skvoznogo-perehoda-k-sleduyuschemu-case">  Pas de transmission au cas suivant </h3><br><p>  Voici ce que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 325</a> dit à ce sujet: </p><br><blockquote>  La conception actuelle de l' <code>switch</code> en Java est étroitement liée aux langages tels que C et C ++ et prend en charge la sémantique de bout en bout par défaut.  Bien que cette méthode traditionnelle de contrôle soit souvent utile pour écrire du code de bas niveau (comme les analyseurs pour le codage binaire), puisque le <code>switch</code> utilisé dans le code de niveau supérieur, les erreurs de cette approche commencent à l'emporter sur sa flexibilité. </blockquote><p>  Je suis totalement d'accord et salue l'opportunité d'utiliser <strong>switch</strong> sans comportement par défaut: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Bool was sane"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// in colon-form, if `ternaryBool` is `TRUE` or `FALSE`, // we would see both messages; in arrow-form, only one // branch is executed default -&gt; System.out.println("Bool was insane"); }</span></span></code> </pre> <br><p>  Il est important d'apprendre que cela n'a rien à voir avec l'utilisation de <strong>switch</strong> comme expression ou comme instruction.  Le facteur décisif ici est la flèche contre le côlon. </p><br><h3 id="bloki-operatorov">  Blocs opérateur </h3><br><p>  Comme dans le cas des lambdas, la flèche peut pointer vers un seul opérateur (comme ci-dessus) ou un bloc mis en évidence avec des accolades: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(Bool.random()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bool true"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// return with `break`, not `return` break true; } case FALSE -&gt; { System.out.println("Bool false"); break false; } case FILE_NOT_FOUND -&gt; { var ex = new UncheckedIOException("This is ridiculous!", new FileNotFoundException()); throw ex; } default -&gt; { var ex = new IllegalArgumentException("Seriously?!"); throw ex; } };</span></span></code> </pre> <br><p>  Les blocs qui doivent être créés pour les opérateurs multilignes ont un avantage supplémentaire (qui n'est pas requis lors de l'utilisation de deux points), ce qui signifie que pour utiliser les mêmes noms de variables dans différentes branches, le <code>switch</code> ne nécessite pas de traitement spécial. </p><br><p>  S'il vous a semblé inhabituel de sortir des blocs en utilisant la <code>break</code> plutôt que le <code>return</code> , ne vous inquiétez pas - cela m'a également intrigué et m'a semblé étrange.  Mais ensuite, j'y ai réfléchi et je suis arrivé à la conclusion que cela avait du sens, car il préserve l'ancien style de la construction de <code>switch</code> , qui utilise la <code>break</code> sans valeurs. </p><br><h2 id="podrobnee-o-vyrazheniyah-switch">  En savoir plus sur les instructions switch </h2><br><p>  Et enfin et surtout, les spécificités de l'utilisation de <code>switch</code> comme expression: </p><br><ul><li>  expressions multiples; </li><li>  retour anticipé ( <code>return</code> anticipé); </li><li>  couverture de toutes les valeurs. </li></ul><br><p>  Veuillez noter que peu importe le formulaire utilisé! </p><br><h3 id="mnozhestvennye-vyrazheniya">  Expressions multiples </h3><br><p>  Les expressions de commutateur sont des expressions multiples.  Cela signifie qu'ils n'ont pas leur propre type, mais peuvent être parmi plusieurs types.  Le plus souvent, les expressions lambda sont utilisées comme telles: <code>s -&gt; s + " "</code> , peuvent être <code>Function&lt;String, String&gt;</code> , mais peuvent également être <code>Function&lt;Serializable, Object&gt;</code> ou <code>UnaryOperator&lt;String&gt;</code> . </p><br><p>  À l'aide d'expressions de commutateur, un type est déterminé par l'interaction entre l'endroit où le <strong>commutateur est</strong> utilisé et les types de ses branches.  Si une expression de commutateur est affectée à une variable typée, passée en argument ou autrement utilisée dans un contexte où le type exact est connu (c'est ce qu'on appelle le type cible), toutes ses branches doivent correspondre à ce type.  Voici ce que nous avons fait jusqu'à présent: </p><br><pre> <code class="java hljs">String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"insane"</span></span>; };</code> </pre> <br><p>  Par conséquent, le <code>switch</code> affecté à la variable de <code>result</code> de type <code>String</code> .  Par conséquent, <code>String</code> est le type cible et toutes les branches doivent renvoyer un résultat de type <code>String</code> . </p><br><p>  La même chose se produit ici: </p><br><pre> <code class="java hljs">Serializable serializableMessage = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (bool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// note that we don't throw the exception! // but it's `Serializable`, so it matches the target type default -&gt; new IllegalArgumentException("insane"); };</span></span></code> </pre> <br><p>  Que va-t-il se passer maintenant? </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compiler infers super type of `String` and // `IllegalArgumentException` ~&gt; `Serializable` var serializableMessage = switch (bool) { case TRUE, FALSE -&gt; "sane"; // note that we don't throw the exception! default -&gt; new IllegalArgumentException("insane"); };</span></span></code> </pre> <br><p>  (Pour l'utilisation du type var, lisez dans notre dernier article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">26 recommandations pour l'utilisation du type var en Java</a> - note du traducteur) </p><br><p>  Si le type cible est inconnu, du fait que nous utilisons var, le type est calculé en trouvant le supertype le plus spécifique des types créés par les branches. </p><br><h3 id="ranniy-vozvrat">  Retour anticipé </h3><br><p>  La conséquence de la différence entre l'expression et l' <code>switch</code> est que vous pouvez utiliser <code>return</code> pour quitter l' <code>switch</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-comment"><span class="hljs-comment">// `return` is only possible from block case TRUE, FALSE -&gt; { return "sane"; } default -&gt; { return "This is ridiculous!"; } }; }</span></span></code> </pre> <br><p>  ... vous ne pouvez pas utiliser <code>return</code> dans une expression ... </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-comment"><span class="hljs-comment">// this does not compile - error: // "return outside of enclosing switch expression" case TRUE, FALSE -&gt; { return "sane"; } default -&gt; { return "This is ridiculous!"; } }; }</span></span></code> </pre> <br><p>  Cela a du sens si vous utilisez une flèche ou un deux-points. </p><br><h3 id="pokrytie-vseh-variantov">  Couvrant toutes les options </h3><br><p>  Si vous utilisez <code>switch</code> comme opérateur, peu importe que toutes les options soient couvertes ou non.  Bien sûr, vous pouvez accidentellement ignorer le <code>case</code> , et le code ne fonctionnera pas correctement, mais le compilateur ne s'en soucie pas - vous, votre IDE et vos outils d'analyse de code resteront seuls. </p><br><p>  Les expressions de commutateur aggravent ce problème.  Où doit-on passer si l'étiquette souhaitée est manquante?  La seule réponse que Java puisse donner est de retourner <code>null</code> pour les types de référence et une valeur par défaut pour les primitives.  Cela provoquerait beaucoup d'erreurs dans le code principal. </p><br><p>  Pour éviter un tel résultat, le compilateur peut vous aider.  Pour les instructions switch, le compilateur insistera pour que toutes les options possibles soient couvertes.  Regardons un exemple qui pourrait conduire à une erreur de compilation: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compile error: // "the switch expression does not cover all possible input values" boolean result = switch (ternaryBool) { case TRUE -&gt; true; // no case for `FALSE` case FILE_NOT_FOUND -&gt; throw new UncheckedIOException( "This is ridiculous!", new FileNotFoundException()); };</span></span></code> </pre> <br><p>  La solution suivante est intéressante: l'ajout de la branche <code>default</code> corrigera certainement l'erreur, mais ce n'est pas la seule solution - vous pouvez toujours ajouter un <code>case</code> pour <code>FALSE</code> . </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compiles without `default` branch because // all cases for `ternaryBool` are covered boolean result = switch (ternaryBool) { case TRUE -&gt; true; case FALSE -&gt; false; case FILE_NOT_FOUND -&gt; throw new UncheckedIOException( "This is ridiculous!", new FileNotFoundException()); };</span></span></code> </pre> <br><p>  Oui, le compilateur pourra enfin déterminer si toutes les valeurs d'énumération sont couvertes (si toutes les options sont épuisées), et ne pas définir de valeurs par défaut inutiles!  Asseyons-nous un instant dans une gratitude silencieuse. </p><br><p>  Bien que cela soulève encore une question.  Et si quelqu'un prend et transforme un <strong>booléen</strong> fou en <strong>booléen</strong> quaternion en ajoutant une quatrième valeur?  Si vous recompilez l'expression de commutateur pour le <strong>Bool</strong> étendu, vous obtiendrez une erreur de compilation (l'expression n'est plus exhaustive).  Sans recompilation, cela se transformera en un problème d'exécution.  Pour résoudre ce problème, le compilateur passe à la branche <code>default</code> , qui se comporte de la même manière que celle que nous avons utilisée jusqu'à présent, lançant une exception. </p><br><p>  Dans Java 12, l'étendue de toutes les valeurs sans la branche <code>default</code> ne fonctionne que pour l' <code>enum</code> , mais lorsque le <code>switch</code> devient plus puissant dans les futures versions de Java, il peut également fonctionner avec des types arbitraires.  Si les étiquettes de <code>case</code> peuvent non seulement vérifier l'égalité, mais aussi faire des comparaisons (par exemple, _ &lt;5 -&gt; ...) - cela couvrira toutes les options pour les types numériques. </p><br><h2 id="razmyshlenie">  Penser </h2><br><p>  Nous avons appris de l'article que Java 12 transforme un <code>switch</code> en une expression, lui donnant de nouvelles fonctionnalités: </p><br><ul><li>  maintenant un <code>case</code> peut correspondre à plusieurs étiquettes; </li><li>  Le nouveau <code>case … -&gt; …</code> forme de flèche <code>case … -&gt; …</code> suit la syntaxe des expressions lambda: <br><ul><li>  les opérateurs ou blocs sur une seule ligne sont autorisés; </li><li>  le passage au <code>case</code> suivant <code>case</code> empêché; </li></ul></li><li>  maintenant, l'expression entière est évaluée comme une valeur, qui peut ensuite être affectée à une variable ou passée dans le cadre d'une instruction plus grande; </li><li>  expression multiple: si le type cible est connu, alors toutes les branches doivent lui correspondre.  Sinon, un type spécifique est défini qui correspond à toutes les branches; </li><li>  <code>break</code> peut renvoyer une valeur d'un bloc; </li><li>  pour une expression de <code>switch</code> utilisant <code>enum</code> , le compilateur vérifie la portée de toutes ses valeurs.  Si <code>default</code> absent, une branche est ajoutée qui lève une exception. </li></ul><br><p>  Où cela nous mènera-t-il?  Tout d'abord, comme il ne s'agit pas de la version finale de <code>switch</code> , vous avez toujours le temps de laisser des commentaires sur la liste de diffusion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Amber</a> si vous n'êtes pas d'accord avec quelque chose. </p><br><p>  Ensuite, en supposant que le <strong>commutateur</strong> reste tel qu'il est actuellement, je pense que la forme de flèche deviendra la nouvelle option par défaut.  Sans passage direct au <code>case</code> suivant et avec des expressions lambda concises (il est très naturel d'avoir un cas et une instruction sur une ligne), le <code>switch</code> semble beaucoup plus compact et n'affecte pas la lisibilité du code.  Je suis sûr que je n'utiliserai deux points que si je dois traverser le passage. </p><br><p>  Qu'en penses-tu?  Satisfait de la tournure des événements? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443464/">https://habr.com/ru/post/fr443464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443452/index.html">L'armée russe créera son propre Internet fermé</a></li>
<li><a href="../fr443456/index.html">Nous vous invitons à Yandex NLP pendant une semaine</a></li>
<li><a href="../fr443458/index.html">6 bugs système divertissants dans le fonctionnement de Kubernetes [et leur solution]</a></li>
<li><a href="../fr443460/index.html">11 réponses sur Yandex.Directory</a></li>
<li><a href="../fr443462/index.html">Piratage de caméras: vecteurs d'attaque, outils de recherche de vulnérabilités et anti-tracking</a></li>
<li><a href="../fr443466/index.html">Roi du développement</a></li>
<li><a href="../fr443468/index.html">Quels outils de surveillance de réseau sont devenus des leaders dans la version de Gartner</a></li>
<li><a href="../fr443470/index.html">L'histoire de la frappe sur l'exemple d'un grand projet</a></li>
<li><a href="../fr443472/index.html">Vous avez un problème pour accéder au cloud? 7 conseils pour ne pas gâcher</a></li>
<li><a href="../fr443476/index.html">Comment SimCity a inspiré toute une génération d'urbanistes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>