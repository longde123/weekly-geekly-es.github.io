<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèø üöé üèõÔ∏è √âcrire un traducteur simple en lisp - I üçï üí∫ üëû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Essayons d'√©crire en Lisp ... un traducteur d'un langage imp√©ratif simple. Non, non, je ne me suis pas tromp√© - c'est le traducteur. Il sera diffus√© e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√âcrire un traducteur simple en lisp - I</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419103/"><p>  Essayons d'√©crire en Lisp ... un traducteur d'un langage imp√©ratif simple.  Non, non, je ne me suis pas tromp√© - c'est le traducteur.  Il sera diffus√© en code Lisp.  Et puis ce code peut √™tre ex√©cut√© par le syst√®me Lisp. </p><br><p>  Ici, le service inestimable sera fourni par le fait qu'en Lisp, il n'y a pas de barri√®re entre le code et les donn√©es (c'est une propri√©t√© rare de certains langages de programmation appel√©s ¬´homo-identit√©¬ª).  Mais les capacit√©s visuelles de Lisp joueront √©galement un r√¥le important. </p><br><p>  En tant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qu'impl√©mentation,</a> j'utiliserai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HomeLisp</a> .  Les personnes int√©ress√©es peuvent adapter ce projet au Common Lisp.  Je dirai tout de suite - par rapport au probl√®me consid√©r√©, la diff√©rence significative entre Common Lisp et HomeLisp ne concerne que le traitement des lignes et des fichiers. </p><br><p>  T√©l√©chargez une version portable de HomeLisp <a href="">ici</a> .  La documentation se trouve √©galement sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le m√™me</a> site.  Ceux qui le souhaitent peuvent copier le code de l'article et v√©rifier imm√©diatement les performances. </p><br><p> Le sujet port√© √† votre attention a servi de base √† mon atelier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">au c√©l√®bre Novosibirsk LSHUP-2018</a> .  Les r√©sultats de l'atelier sont disponibles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Et puis j'ai expos√© mon approche.  Je suppose que le lecteur conna√Æt le langage Lisp. </p><br><h4 id="pristupaem">  Descendre </h4><br><p>  Commen√ßons par le ¬´langage imp√©ratif simple¬ª que nous diffuserons en Lisp. <br>  La langue ne traitera que les donn√©es num√©riques.  Le code dans ce langage se compose de fonctions (proc√©dures qui renvoient des valeurs).  Parmi ces fonctions, une devrait √™tre appel√©e principale.  C'est avec cette fonction que commence l'ex√©cution du code.  Mais pourquoi vous lier ainsi?  Nous √©crivons des fonctions dans un langage imp√©ratif, elles sont diffus√©es en Lisp et peuvent √™tre utilis√©es avec des fonctions Lisp.  Mais ne prenons pas de l'avance sur nous-m√™mes ... </p><a name="habracut"></a><br><p>  L'ensemble des op√©rateurs de langage est habituel: affectation, branchement, cycle arithm√©tique, sortie anticip√©e du cycle, entr√©e, sortie et appel de fonction.  Cependant, syntaxiquement, un appel de fonction est ex√©cut√© comme une affectation (r√©sultat d'un appel).  Laissez les commentaires contenir un ast√©risque √† la premi√®re position de la ligne.  Le langage, bien s√ªr, devrait permettre de cr√©er des fonctions r√©cursives.  Pour plus de clart√©, je vais donner des exemples de code - imprimer des nombres impairs successifs et calculer leur somme: </p><br><pre><code class="hljs lua">proc main() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> s,n,k <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span> to n k=<span class="hljs-number"><span class="hljs-number">2</span></span>*i<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> k s=s+k end_for <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> s end_proc</code> </pre> <br><p>  Dans son esprit, c'est un langage de base.  Je l'appellerai ¬´mini-basique¬ª.  Notre traducteur doit convertir le code donn√© en fonction Lisp suivante: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> main <span class="hljs-literal"><span class="hljs-literal">nil</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">s</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">n</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">k</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> n (<span class="hljs-name"><span class="hljs-name">read</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> to n) (<span class="hljs-name"><span class="hljs-name">setq</span></span> k (<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> i) <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">printline</span></span> k) (<span class="hljs-name"><span class="hljs-name">setq</span></span> s (<span class="hljs-name"><span class="hljs-name">+</span></span> sk))) (<span class="hljs-name"><span class="hljs-name">printline</span></span> s)))</code> </pre> <br><p>  J'aime vraiment le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">it√©ratif</a> , qui est impl√©ment√© en tant que macro dans les packages Common Lisp professionnels.  Dans HomeLisp, la fonction iter (qui impl√©mente une grande partie des capacit√©s de macro it√©ration) est incluse dans le langage principal.  C'est ma d√©pendance √† l'iter qui a entra√Æn√© la traduction des cycles de notre ¬´mini-basique¬ª en appels iter. </p><br><p>  Par o√π commencer la mise en ≈ìuvre?  Commen√ßons par s√©lectionner le fichier √† diffuser et lisons et imprimons ce fichier ligne par ligne.  Nous devrons d√©marrer le traducteur plusieurs fois, alors laissez ce d√©but depuis le d√©but √™tre pratique.  Voici √† quoi pourrait ressembler cette fonction: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> fname) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> fname (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>)))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*))</code> </pre> <br><p>  La fonction a un param√®tre facultatif <strong>fname</strong> - le nom du fichier dont le contenu sera diffus√©.  Lors de la saisie de la fonction, deux variables globales sont cr√©√©es: <strong><em>numLine,</em></strong> num√©ro de ligne du fichier source et <strong><em>flagerr</em></strong> , l'indicateur d'√©tat d'erreur.  Avant la fin de la fonction, ces variables sont d√©truites (la fonction HomeLisp <strong>non</strong> d√©finie d√©truit les variables globales). </p><br><p>  Si le nom du fichier d'entr√©e est omis, la fen√™tre de dialogue standard pour s√©lectionner le fichier <strong>(sysGetOpenName) est</strong> appel√©e.  Le r√©pertoire actuel <strong>(sysHome) est</strong> utilis√© comme r√©pertoire de d√©marrage.  Ensuite, un caract√®re unique est cr√©√© pour le manipulateur de fichiers et le fichier est ouvert pour la lecture de texte.  Ensuite, dans une boucle sans fin, le fichier est lu ligne par ligne (fonction <strong>getLine</strong> ).  Apr√®s chaque op√©ration, il est v√©rifi√© si une erreur s'est produite et si la fin du fichier est atteinte.  Si une erreur se produit ou si la fin du fichier est corrig√©e, le cycle s'arr√™te, le fichier se ferme et s'il y a eu des erreurs, un message final s'affiche. <br>  En fait, la lecture du fichier est effectu√©e par la fonction <strong>getLine</strong> : </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> getLine (<span class="hljs-name"><span class="hljs-name">fil</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stri</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEof</span></span> fil) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *numline*)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">filGetline</span></span> fil)) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> (<span class="hljs-name"><span class="hljs-name">format</span></span> *numline* <span class="hljs-string"><span class="hljs-string">"0000"</span></span>) <span class="hljs-string"><span class="hljs-string">" "</span></span> (<span class="hljs-name"><span class="hljs-name">strRTrim</span></span> stri))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">strATrim</span></span> stri)) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> stri) (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">return</span></span> stri)))))</code> </pre> <br><p>  Cette fonction accepte l'identifiant d'un fichier ouvert et, dans une boucle infinie, effectue les actions suivantes: </p><br><ul><li>  v√©rifie l'√©tat de fin de fichier.  Dans ce cas, la boucle se rompt et la fonction renvoie une cha√Æne vide; </li><li>  le compteur de lignes de lecture augmente de un; </li><li>  la ligne suivante du fichier est lue; </li><li>  la ligne de lecture est imprim√©e avec la suppression des espaces possibles √† droite; </li><li>  si la ligne de lecture n'est pas vide et ne contient pas d'ast√©risque en premi√®re position, alors elle <br>  retourne de la fonction; </li></ul><br><p>  Ainsi, toutes les lignes du fichier dans leur forme d'origine tombent dans la liste de sortie. </p><br><h4 id="razbivaem-na-procedury">  Nous entrons dans les proc√©dures </h4><br><p>  Maintenant, apprenons √† notre code √† diviser le flux d'entr√©e en proc√©dures distinctes.  Tout d'abord, la cha√Æne saisie devra √™tre divis√©e en jetons (unit√©s lexicales d'entr√©e indivisibles).  Ce processus est appel√© analyse;  nous devons cr√©er un analyseur.  L'√©criture d'analyseurs est un th√®me classique, il existe des biblioth√®ques d'analyseurs pr√™ts √† l'emploi et des outils sp√©ciaux qui vous permettent de g√©n√©rer l'analyseur n√©cessaire ... Nous suivrons notre propre chemin. </p><br><p>  Avant de d√©crire l'algorithme de l'analyseur, nous faisons attention au fait que tous les caract√®res de la cha√Æne d'entr√©e peuvent √™tre divis√©s en deux classes: </p><br><ul><li>  Caract√®res ordinaires; </li><li>  Caract√®res de s√©paration. </li></ul><br><p>  Ainsi, dans l'op√©rateur d'affectation <strong>¬´x = 15 + y ^ 2¬ª, les</strong> caract√®res <strong>x, 1,5, y</strong> et <strong>2</strong> sont des caract√®res ordinaires et les caract√®res <strong>¬´espace¬ª</strong> , <strong>+</strong> , <strong>^</strong> sont des d√©limiteurs.  En quoi un caract√®re normal est-il diff√©rent d'un s√©parateur?  S√©parateur - s√©pare toujours un jeton d'un autre.  Notre op√©rateur d'affectation, divis√© en jetons, ressemble √† ceci: <strong>"x", "=", "15", "y", "^", "2"</strong> . </p><br><p>  Comme vous pouvez le voir, tous les d√©limiteurs ne tombent pas dans le r√©sultat de l'analyse (les espaces, en particulier, ne tombent pas).  Nous appellerons les s√©parateurs qui ne tombent pas dans le r√©sultat comme des s√©parateurs du premier type.  Les autres s√©parateurs seront appel√©s s√©parateurs du deuxi√®me type. </p><br><p>  L'entr√©e de l'analyseur sera une cha√Æne, la sortie est une liste de jetons de cha√Æne.  En tant que lecteur, une variable locale sera utilis√©e - la batterie.  La batterie contient initialement une cha√Æne vide. </p><br><p>  L'algorithme d'analyse peut √™tre le suivant: nous lisons la ligne d'entr√©e caract√®re par caract√®re.  Si vous rencontrez un personnage normal, concat√©nez-le avec la batterie.  Si un d√©limiteur est trouv√©, alors: </p><br><ul><li>  Pour le s√©parateur du premier type, nous r√©initialisons la valeur de la batterie (si elle n'est pas vide) dans la liste de sortie, effacez la batterie et lisons le caract√®re suivant; </li><li>  Pour le s√©parateur du deuxi√®me type, nous vidons √©galement la valeur d'une batterie non vide dans la liste de sortie, et apr√®s cela, nous entrons le s√©parateur accept√© du deuxi√®me type (en tant que jeton ind√©pendant) dans la liste de sortie, effacez la batterie et passez √† la lecture du caract√®re suivant. </li></ul><br><p>  Voici le code de l'analyseur: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> parser (<span class="hljs-name"><span class="hljs-name">txt</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">d1</span></span> <span class="hljs-string"><span class="hljs-string">" ,"</span></span>) (<span class="hljs-name"><span class="hljs-name">d2</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">res</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lex</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>) ) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> s in-string (<span class="hljs-name"><span class="hljs-name">strCat</span></span> txt (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> d1 <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">plusp</span></span> (<span class="hljs-name"><span class="hljs-name">strInd</span></span> d1 s)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> lex) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> lex into res)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex <span class="hljs-string"><span class="hljs-string">""</span></span>)) ((<span class="hljs-name"><span class="hljs-name">plusp</span></span> (<span class="hljs-name"><span class="hljs-name">strInd</span></span> d2 s)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> lex) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> lex into res)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> s into res) (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex (<span class="hljs-name"><span class="hljs-name">strCat</span></span> lex s))))) res))</code> </pre> <br><p>  En plus du param√®tre requis, la fonction poss√®de deux param√®tres facultatifs: <strong>d1</strong> contient une cha√Æne dont chaque caract√®re a un s√©parateur du premier type et la ligne <strong>d2</strong> contient des s√©parateurs du deuxi√®me type. </p><br><p>  La logique du programme de la fonction <strong>analyseur</strong> est d√©crite ci-dessus.  Il faut seulement noter qu'avant de commencer le travail, un s√©parateur est ajout√© √† la fin de la ligne d'entr√©e.  Ceci est fait de sorte que le dernier jeton trait√© "se bloque" dans la batterie (la variable locale <strong>lex</strong> joue le r√¥le de la batterie). </p><br><p>  V√©rifions notre analyseur ¬´en action¬ª: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">parser</span></span> <span class="hljs-string"><span class="hljs-string">"x = 15 + y^2"</span></span>) ==&gt; (<span class="hljs-string"><span class="hljs-string">"x"</span></span> <span class="hljs-string"><span class="hljs-string">"="</span></span> <span class="hljs-string"><span class="hljs-string">"15"</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> <span class="hljs-string"><span class="hljs-string">"y"</span></span> <span class="hljs-string"><span class="hljs-string">"^"</span></span> <span class="hljs-string"><span class="hljs-string">"2"</span></span>)</code> </pre> <br><p>  C'est vrai, non?  Mais travailler avec des listes de cha√Ænes n'est pas tout √† fait Lisp.  Passons de la liste des cha√Ænes √† la liste des atomes.  Pour ce faire, nous avons besoin d'une fonction qui ... colle √† nouveau tous les jetons dans une longue ligne (mais ins√®re un espace entre les jetons), puis colle le crochet d'ouverture au d√©but de cette ligne, ferme le crochet de fermeture jusqu'√† la fin ... puis force Lisp √† lire la liste: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> txt <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>))))</code> </pre> <br><p>  Maintenant, si nous soumettons l'op√©rateur d'affectation √† l'entr√©e de la fonction mk-intf, nous obtenons: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> <span class="hljs-string"><span class="hljs-string">"x = 15 + y^2"</span></span>) ==&gt; (<span class="hljs-name"><span class="hljs-name">X</span></span> = <span class="hljs-number"><span class="hljs-number">15</span></span> + Y ^ <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Ce qui, vous voyez, est beaucoup plus agr√©able. </p><br><p>  Modifions maintenant un peu la fonction de d√©marrage: cette fonction devra lire et traiter des proc√©dures enti√®res: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> fname) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">when</span></span> fname (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*))</code> </pre> <br><p>  Dans le corps de la boucle, la fonction <strong>action-proc</strong> est appel√©e (pour traiter la proc√©dure), qui formera d√©j√† le corps de la proc√©dure accept√©e sur Lisp.  Le corps de la proc√©dure, stock√© en tant qu'expression S dans la variable <strong>curr-proc</strong> , est ensuite pass√© √† l'entr√©e de <strong>eval</strong> .  Et la fonction accept√©e se ¬´r√©incarne¬ª dans l'environnement Lisp! </p><br><p>  Que doit faire <strong>action-proc</strong> ?  Cette fonction re√ßoit l'identifiant du fichier ouvert en param√®tre.  La fonction lit le fichier ligne par ligne √† partir du fichier, saute les lignes vides et les commentaires, analyse le reste des lignes, le traduit sous forme de liste et g√©n√®re le corps de la proc√©dure. </p><br><p>  Nous allons progressivement ¬´apprendre¬ª la g√©n√©ration d' <strong>action-proc</strong> .  Et commen√ßons par apprendre √† notre fonction √† reconna√Ætre le d√©but et la fin d'une proc√©dure.  Dans une mini-basique, le d√©but de la proc√©dure est: </p><br><pre> <code class="hljs lisp">proc name(<span class="hljs-name"><span class="hljs-name">p1</span></span>,p2,p3)</code> </pre> <br><p>  essayez d'analyser une ligne comme celle-ci: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> <span class="hljs-string"><span class="hljs-string">"proc name(p1,p2,p3)"</span></span>) ==&gt; (<span class="hljs-name"><span class="hljs-name">PROC</span></span> NAME (<span class="hljs-name"><span class="hljs-name">P1</span></span> P2 P3))</code> </pre> <br><p>  Comment la fonction <strong>action-proc</strong> doit <strong>-elle</strong> r√©pondre √† cette entr√©e?  Naturellement, en vous assurant que la t√™te de la liste est un atome <strong>PROC</strong> , vous devez prendre le deuxi√®me √©l√©ment de la liste comme nom de la fonction et le troisi√®me √©l√©ment comme liste de param√®tres.  Le nom et la liste des param√®tres doivent √™tre stock√©s dans des variables locales.  Lorsque l'op√©rateur <strong>end_proc</strong> est <strong>lu</strong> , vous devez alors former un formulaire <strong>defun</strong> avec un corps vide (jusqu'√† pr√©sent) √† partir du nom de la fonction et de la liste des param√®tres, et renvoyer ce formulaire comme r√©sultat.  Voici √† quoi √ßa ressemble: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) `(defun ,proc-name ,proc-parm (quote OK))))</code> </pre> <br><p>  Pour la formation finale de la clause <strong>defun</strong> , un verrou invers√© est utilis√©.  Notez que la proc√©dure g√©n√©r√©e renverra un atome <strong>OK</strong> comme r√©sultat. </p><br><p>  Maintenant, nous pouvons v√©rifier notre code en action.  Mettez le code suivant dans le fichier 0000.mbs: </p><br><pre> <code class="hljs lisp">proc f1(<span class="hljs-name"><span class="hljs-name">x</span></span>,y) end_proc proc f2(<span class="hljs-name"><span class="hljs-name">x</span></span>) end_proc</code> </pre> <br><p>  Ex√©cutez la proc√©dure de <strong>d√©marrage</strong> , s√©lectionnez 0000.mbs et voyez sur la console: </p><br><pre> <code class="hljs lisp"><span class="hljs-number"><span class="hljs-number">0001</span></span> proc f1(<span class="hljs-name"><span class="hljs-name">x</span></span>,y) <span class="hljs-number"><span class="hljs-number">0002</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0003</span></span> proc f2(<span class="hljs-name"><span class="hljs-name">x</span></span>) <span class="hljs-number"><span class="hljs-number">0004</span></span> end_proc</code> </pre> <br><p>  Si vous le souhaitez, vous pouvez vous assurer que la machine Lisp dispose d√©sormais de deux fonctions (jusqu'ici inutiles) <strong>f1</strong> et <strong>f2</strong> : </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f1) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">XY</span></span>) (<span class="hljs-name"><span class="hljs-name">QUOTE</span></span> OK)) (<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f2) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">X</span></span>) (<span class="hljs-name"><span class="hljs-name">QUOTE</span></span> OK))</code> </pre> <br><p>  De plus!  Ils peuvent d√©j√† √™tre d√©marr√©s: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">f1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) ==&gt; OK (<span class="hljs-name"><span class="hljs-name">f2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) ==&gt; OK</code> </pre> <br><p>  Notre traducteur a pris un premier souffle ... </p><br><h4 id="vvod-vyvod-i-lokalnye-peremennye">  Variables d'entr√©e, de sortie et locales </h4><br><p>  Il est maintenant temps d'enseigner √† notre traducteur nouveau-n√© comment g√©rer la <strong>saisie</strong> , l' <strong>impression</strong> et <strong>les</strong> op√©rateurs <strong>locaux</strong> . </p><br><p>  La fa√ßon la plus simple de g√©rer la saisie et l'impression.  Les deux op√©rateurs ont la m√™me structure syntaxique: mot-cl√© et variable.  L' <strong>entr√©e</strong> op√©rateur <strong>x</strong> doit se transformer en une telle forme Lisp <strong>(setq x (lecture))</strong> .  En cons√©quence, l'op√©rateur <strong>print x se</strong> transforme en un formulaire <strong>(printline x)</strong> .  Pour stocker ces formulaires, vous devez fournir le <strong>corps de</strong> variable local dans la fonction <strong>action-proc</strong> .  Cette variable accumulera des formulaires qui effectuent des calculs de la fonction future.  Alors tout est assez simple: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) `(defun ,proc-name ,proc-parm ,@body)))</code> </pre> <br><p>  Pr√©parons maintenant ce code source sur un mini-basique: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">proc</span></span> f1(x,y) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> y end_proc <span class="hljs-keyword"><span class="hljs-keyword">proc</span></span> f2(x) input x <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x end_proc</code> </pre> <br><p>  et essayez de le traduire ... Nous aurons deux fonctions Lisp <strong>f1</strong> et <strong>f2</strong> .  Examinons leurs expressions de d√©finition et v√©rifions qu'elles sont g√©n√©r√©es correctement: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f1) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">XY</span></span>) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> X) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> Y)) (<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f2) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">X</span></span>) (<span class="hljs-name"><span class="hljs-name">SETQ</span></span> X (<span class="hljs-name"><span class="hljs-name">READ</span></span>)) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> X))</code> </pre> <br><p>  Vous pouvez appeler ces fonctions et vous assurer qu'elles fonctionnent exactement comme pr√©vu.  Que cela ne vous d√©range pas que nous entrions la valeur dans la variable de param√®tre - nous n'avons tout simplement pas encore de variables locales ... Ajoutons-les. </p><br><p>  L'op√©rateur <strong>local</strong> peut √™tre n'importe o√π dans la proc√©dure et se produire plusieurs fois.  Si l'op√©rateur <strong>local</strong> est rencontr√© lors du traitement d'une proc√©dure, vous devez prendre une liste de variables et l'enregistrer dans une variable locale.  Une fois que l'instruction <strong>end_proc</strong> est <strong>satisfaite,</strong> vous devez g√©n√©rer le formulaire <strong>let</strong> et y ¬´enfermer¬ª toutes les instructions ex√©cutables (pour l'instant, seulement <strong>saisir</strong> et <strong>imprimer</strong> ).  Voici √† quoi ressemblera maintenant <strong>action-proc</strong> : </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lv</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'local) (<span class="hljs-name"><span class="hljs-name">setq</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">append</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in (<span class="hljs-name"><span class="hljs-name">setof</span></span> loc-var)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> a <span class="hljs-number"><span class="hljs-number">0</span></span>) into lv)) `(defun ,proc-name ,proc-parm (let ,lv ,@body))))</code> </pre> <br><p>  La liste des variables locales est accumul√©e dans la variable <strong>loc-var</strong> .  Une fois le traitement de la proc√©dure termin√©, une liste de paires du formulaire <strong>(nom 0)</strong> est construite √† partir de cette liste.  Dans ce cas, la duplication de noms identiques n'est pas souhaitable ... Comment l'emp√™cher?  Bien s√ªr, il est possible de v√©rifier √† chaque traitement de l'op√©rateur <strong>local</strong> s'il y a des noms en double (le cas √©ch√©ant, donner un message d'erreur).  Mais, me semble-t-il, il vaut mieux simplement √©liminer les r√©p√©titions, c'est ce que les <strong>appels appellent</strong> .  Maintenant, traduisons et ex√©cutons ce programme: </p><br><pre> <code class="hljs lua">proc f1(x,y) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> a,b,c <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> x <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> y <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> a <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> a end_proc</code> </pre> <br><p>  Nous nous assurons que cela fonctionne exactement comme le sugg√®re l'algorithme.  Mais le plus int√©ressant est √† venir! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">De l√†,</a> vous pouvez t√©l√©charger la version finale de ce que nous sommes sur <del>  w </del>  cod√© ... </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre!</a> <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419103/">https://habr.com/ru/post/fr419103/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419089/index.html">Comment tricher en jouant aux d√©s - Conseils d'experts</a></li>
<li><a href="../fr419091/index.html">Des objets radioactifs parmi nous</a></li>
<li><a href="../fr419097/index.html">Mambot - un bot dans le Telegram pour les femmes enceintes</a></li>
<li><a href="../fr419099/index.html">WebSockets en angulaire. Partie 2. Solutions de produits</a></li>
<li><a href="../fr419101/index.html">Cr√©er un jeu de nuit hackathon</a></li>
<li><a href="../fr419105/index.html">Lien vers l'√©mission Slurm (Kubernetes Intensive)</a></li>
<li><a href="../fr419107/index.html">Pr√©sentation de la partie de fichier Dell EMC Unity et exemples de configuration</a></li>
<li><a href="../fr419109/index.html">Expliquez la frange dans Android P. Que faire avec Android Cutout?</a></li>
<li><a href="../fr419111/index.html">Food Design Digest juillet 2018</a></li>
<li><a href="../fr419115/index.html">CD bootable et jeu r√©tro dans un tweet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>