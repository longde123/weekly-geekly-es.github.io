<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçü§ù‚Äçüë®üèΩ üë∑üèº üçì Particionamiento en SQL Server üïò üôçüèø üññüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El particionamiento ("particionamiento") en SQL Server, con aparente simplicidad ("lo que hay all√≠: distribuye la tabla y los √≠ndices por grupos de ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Particionamiento en SQL Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464665/"> El particionamiento ("particionamiento") en SQL Server, con aparente simplicidad ("lo que hay all√≠: distribuye la tabla y los √≠ndices por grupos de archivos, obtiene ganancias en administraci√≥n y rendimiento") es un tema bastante extenso.  A continuaci√≥n, tratar√© de describir c√≥mo crear y aplicar una funci√≥n y un esquema de partici√≥n y qu√© problemas puede encontrar.  No hablar√© sobre los beneficios, excepto por una cosa: cambiar secciones, cuando eliminas instant√°neamente un gran conjunto de datos de una tabla, o viceversa, carga instant√°neamente un conjunto no menos grande en una tabla. <br><a name="habracut"></a><br>  Como dice <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">msdn</a> : ‚ÄúLos datos de tablas e √≠ndices particionados se dividen en bloques que pueden distribuirse entre varios grupos de archivos en la base de datos.  Los datos se dividen horizontalmente, por lo que los grupos de filas se asignan a secciones individuales.  Todas las secciones del mismo √≠ndice o tabla deben estar en la misma base de datos.  Una tabla o √≠ndice se considera una entidad l√≥gica √∫nica cuando se ejecutan consultas o actualizaciones de datos ". <br><br>  Las principales ventajas tambi√©n se enumeran all√≠: <br><br><ul><li>  Transfiera y acceda a subconjuntos de datos de manera r√°pida y eficiente mientras mantiene la integridad del conjunto de datos </li><li>  Las operaciones de mantenimiento se pueden realizar m√°s r√°pido con una o m√°s secciones; </li><li>  Puede aumentar la velocidad de ejecuci√≥n de consultas, dependiendo de las consultas que a menudo se ejecutan en su configuraci√≥n de hardware. </li></ul><br>  En otras palabras, la partici√≥n se usa para el escalado horizontal.  La tabla / los √≠ndices est√°n "distribuidos" por diferentes grupos de archivos, que se pueden ubicar en diferentes discos f√≠sicos, lo que aumenta significativamente la conveniencia de la administraci√≥n y, en teor√≠a, le permite mejorar el rendimiento de las consultas a estos datos: puede leer solo la secci√≥n deseada (menos datos) o leer todo en paralelo (los dispositivos son diferentes, lea r√°pidamente).  En la pr√°ctica, todo es algo m√°s complicado y aumentar el rendimiento de las consultas en tablas particionadas solo puede funcionar si sus consultas usan la selecci√≥n por el campo por el que particion√≥.  Si a√∫n no tiene experiencia con tablas particionadas, solo tenga en cuenta que el rendimiento de sus consultas puede no cambiar, pero puede deteriorarse despu√©s de particionar su tabla. <br><br>  Hablemos de la ventaja absoluta que definitivamente se lleva bien con la partici√≥n (pero que tambi√©n necesita poder usar): este es un aumento garantizado en la conveniencia de administrar su base de datos.  Por ejemplo, tiene una tabla con mil millones de registros, de los cuales 900 millones pertenecen a per√≠odos anteriores ("cerrados") y son de solo lectura.  Con la ayuda de la secci√≥n, puede transferir estos datos antiguos a un grupo de archivos de solo lectura separado, hacer una copia de seguridad y ya no arrastrarlo a todas sus copias de seguridad diarias: la velocidad de creaci√≥n de una copia de seguridad aumentar√° y el tama√±o disminuir√°.  Puede reconstruir el √≠ndice no sobre toda la tabla, sino sobre secciones seleccionadas.  Adem√°s, la disponibilidad de su base de datos est√° creciendo: si uno de los dispositivos que contiene el grupo de archivos con la secci√≥n falla, los dem√°s seguir√°n estando disponibles. <br><br>  Para lograr los beneficios restantes (cambiar de secci√≥n al instante; aumentar la productividad), debe dise√±ar espec√≠ficamente la estructura de datos y escribir consultas. <br>  Supongo que ya he avergonzado al lector lo suficiente y ahora puedo proceder a practicar. <br><br>  Primero, cree una base de datos con 4 grupos de archivos en los que realizaremos experimentos: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> [PartitionTest] <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> primary (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestPrimary'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestPrimary.mdf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg1] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG1'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG1.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg2] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG2'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG2.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg3] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG3'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG3.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">'PTest_Log'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTest_log.ldf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">2048</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB); go <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> [PartitionTest] <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">recovery</span></span> simple; go <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> partitionTest;</code> </pre> <br>  Crea una tabla que atormentaremos. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ptest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>));</code> </pre> <br>  Y ll√©nalo con datos de un a√±o: <br><pre> <code class="sql hljs">;<span class="hljs-keyword"><span class="hljs-keyword">with</span></span> nums <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ptest(dt, dummy_int, dummy_char) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dateadd</span></span>(hh, rn<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">'20180101'</span></span>) dt, rn dummy_int, <span class="hljs-string"><span class="hljs-string">'dummy char column #'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span>(rn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> row_number() <span class="hljs-keyword"><span class="hljs-keyword">over</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>))) rn <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nums n1, nums n2, nums n3, nums n4 )t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> rn &lt; <span class="hljs-number"><span class="hljs-number">8761</span></span></code> </pre> <br>  Ahora la tabla pTest contiene un registro por cada hora de 2018. <br><br>  Ahora necesita crear una funci√≥n de partici√≥n que describa las condiciones de contorno para dividir datos en secciones.  SQL Server solo admite particiones de rango. <br><br>  Vamos a dividir nuestra tabla en la columna dt (fecha y hora) para que cada secci√≥n contenga datos durante 4 meses (aqu√≠ la arruin√©; de hecho, la primera secci√≥n contendr√° datos para 3, la segunda para 4, la tercera durante 5 meses, pero para fines de demostraci√≥n, esto no es un problema) <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  Todo parece ser normal, pero aqu√≠ deliberadamente comet√≠ un "error".  Si observa la sintaxis en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">msdn</a> , ver√° que durante la creaci√≥n puede especificar a qu√© secci√≥n pertenecer√° el borde especificado: a la izquierda o a la derecha.  Por defecto, por alguna raz√≥n desconocida, el borde especificado se refiere a la secci√≥n "izquierda", por lo que para mi caso ser√≠a correcto crear una funci√≥n de partici√≥n de la siguiente manera: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  Si bien en realidad ejecut√©: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  Pero volveremos a esto m√°s tarde y recrearemos nuestra funci√≥n de partici√≥n.  Mientras tanto, continuamos con lo que sucedi√≥ para entender qu√© sucedi√≥ y por qu√© no es muy bueno para nosotros. <br><br>  Despu√©s de crear la funci√≥n de partici√≥n, debe crear un esquema de partici√≥n.  Claramente une secciones a grupos de archivos: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> pfTest <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ([FG1], [FG2], [FG3])</code> </pre> <br>  Como puede ver, nuestras tres secciones estar√°n en diferentes grupos de archivos.  Ahora es el momento de dividir nuestra mesa.  Para hacer esto, necesitamos crear un √≠ndice agrupado y, en lugar de especificar el grupo de archivos en el que debe ubicarse, especifique el esquema de partici√≥n: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_pTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> psTest(dt)</code> </pre> <br>  Y aqu√≠, tambi√©n, comet√≠ un "error" en el esquema actual: muy bien podr√≠a haber creado un √≠ndice agrupado √∫nico en esta columna, sin embargo, al crear un √≠ndice √∫nico, la columna utilizada para particionar deber√≠a incluirse en el √≠ndice.  Y quiero mostrar lo que puede encontrar con esta configuraci√≥n. <br><br>  Ahora veamos qu√© obtuvimos en la configuraci√≥n actual (la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitud se toma de aqu√≠</a> ): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sc.name + N<span class="hljs-string"><span class="hljs-string">'.'</span></span> + so.name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Schema.Table], si.index_id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], si.type_desc <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Structure], si.name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>], stat.row_count <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Rows</span></span>], stat.in_row_reserved_page_count * <span class="hljs-number"><span class="hljs-number">8.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Row</span></span> GB], stat.lob_reserved_page_count * <span class="hljs-number"><span class="hljs-number">8.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">LOB</span></span> GB], p.partition_number <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Partition</span></span> <span class="hljs-comment"><span class="hljs-comment">#], pf.name as [Partition Function], CASE pf.boundary_value_on_right WHEN 1 then 'Right / Lower' ELSE 'Left / Upper' END as [Boundary Type], prv.value as [Boundary Point], fg.name as [Filegroup] FROM sys.partition_functions AS pf JOIN sys.partition_schemes as ps on ps.function_id=pf.function_id JOIN sys.indexes as si on si.data_space_id=ps.data_space_id JOIN sys.objects as so on si.object_id = so.object_id JOIN sys.schemas as sc on so.schema_id = sc.schema_id JOIN sys.partitions as p on si.object_id=p.object_id and si.index_id=p.index_id LEFT JOIN sys.partition_range_values as prv on prv.function_id=pf.function_id and p.partition_number= CASE pf.boundary_value_on_right WHEN 1 THEN prv.boundary_id + 1 ELSE prv.boundary_id END /* For left-based functions, partition_number = boundary_id, for right-based functions we need to add 1 */ JOIN sys.dm_db_partition_stats as stat on stat.object_id=p.object_id and stat.index_id=p.index_id and stat.index_id=p.index_id and stat.partition_id=p.partition_id and stat.partition_number=p.partition_number JOIN sys.allocation_units as au on au.container_id = p.hobt_id and au.type_desc ='IN_ROW_DATA' /* Avoiding double rows for columnstore indexes. */ /* We can pick up LOB page count from partition_stats */ JOIN sys.filegroups as fg on fg.data_space_id = au.data_space_id ORDER BY [Schema.Table], [Index ID], [Partition Function], [Partition #];</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/72/qu/op/72quopaqu1glcalpur92qrwy6eo.png"><br><br>  Por lo tanto, obtuvimos tres secciones poco exitosas: la primera almacena datos desde el principio del tiempo hasta el 01/04/2018 00:00:00 inclusive, la segunda, desde el 01/01/2018 00:00:01 hasta el 01/08/2018 00:00:00 inclusive, el tercero desde el 01/08/2018 00:00:01 hasta el fin del mundo (deliberadamente perd√≠ la fracci√≥n de un segundo, porque no recuerdo en qu√© gradaci√≥n SQL Server escribe estas fracciones, pero el significado se transmite correctamente). <br>  Ahora cree un √≠ndice no agrupado en el campo dummy_int, "alineado" de acuerdo con el mismo esquema de partici√≥n. <br><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© necesitamos un √≠ndice alineado?</b> <div class="spoiler_text">  necesitamos un √≠ndice alineado para poder realizar la operaci√≥n de cambiar una secci√≥n (interruptor), y esta es una de esas operaciones para las cuales, a menudo, se molestan con la partici√≥n.  Si hay al menos un √≠ndice no alineado en la tabla, no puede cambiar la secci√≥n <br></div></div><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> nonclustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> nix_pTest_dummyINT <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest(dummy_int) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> psTest(dt);</code> </pre> <br>  Y veamos por qu√© dije que sus consultas pueden volverse m√°s lentas despu√©s de la implementaci√≥n del seccionamiento.  Ejecute la solicitud: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dummy_int = <span class="hljs-number"><span class="hljs-number">54</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Y veamos las estad√≠sticas de ejecuci√≥n: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 3, logical reads 6, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Y el plan de implementaci√≥n: <br><br><img src="https://habrastorage.org/webt/-i/ey/ay/-ieyay17s-rifng9eaij7bobfes.png"><br><br>  Dado que nuestro √≠ndice est√° "alineado" por secciones, condicionalmente, cada secci√≥n tiene su propio √≠ndice, que est√° "desconectado" con los √≠ndices de otras secciones.  No impusimos condiciones en el campo por el que se divide el √≠ndice, por lo que SQL Server se ve obligado a ejecutar Index Seek en cada secci√≥n, de hecho, 3 Index Seek en lugar de una. <br><br>  Intentemos excluir una secci√≥n: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dummy_int = <span class="hljs-number"><span class="hljs-number">54</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> dt &lt; <span class="hljs-string"><span class="hljs-string">'20180801'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Y veamos las estad√≠sticas de ejecuci√≥n: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 2, logical reads 4, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  S√≠, se excluy√≥ una secci√≥n y la b√∫squeda del valor deseado se realiz√≥ en solo dos secciones. <br>  Esto es algo que debe recordarse al decidir la partici√≥n.  Si tiene consultas que no utilizan una restricci√≥n en el campo por el que se divide la tabla, puede tener un problema. <br><br>  Ya no necesitamos el √≠ndice no agrupado, as√≠ que lo elimino <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> nix_pTest_dummyINT <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øY por qu√© se necesitaba un √≠ndice sin cl√∫ster?</b> <div class="spoiler_text">  en general, no lo necesitaba, podr√≠a mostrar lo mismo con el √≠ndice de cl√∫ster, no s√© por qu√© lo cre√©, pero como lo hice y tom√© capturas de pantalla, no pierda lo bueno <br></div></div><br>  Ahora considere el siguiente escenario: archivamos los datos de esta tabla cada 4 meses: eliminamos los datos antiguos y agregamos una secci√≥n para los pr√≥ximos cuatro meses (la organizaci√≥n de la "ventana deslizante" se describe en msdn y el mont√≥n de blogs). <br><br>  Dividimos la tarea en subtareas peque√±as y comprensibles: <br><br><ol><li>  Agregar una secci√≥n para datos del 01/01/2019 al 01/04/2019 </li><li>  Crear una mesa de escenario vac√≠a </li><li>  Cambie la secci√≥n de datos hasta el 01/04/2018 en la tabla de etapas </li><li>  Deshazte de la secci√≥n vac√≠a </li></ol><br>  Vamos: <br><br>  1. Anunciamos que la nueva secci√≥n se crear√° en el grupo de archivos FG1, porque pronto se nos liberar√°: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1];</code> </pre> <br>  Y cambie la funci√≥n de partici√≥n agregando un nuevo borde: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190101'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Nos fijamos en las estad√≠sticas: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 1, logical reads 76171, physical reads 0, read-ahead reads 753, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'Worktable'. Scan count 1, logical reads 7440, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Hay 8809 p√°ginas en la tabla (√≠ndice de cl√∫ster), por lo que el n√∫mero de lecturas, por supuesto, est√° m√°s all√° del bien y del mal.  Veamos lo que tenemos ahora en secciones. <br><br><img src="https://habrastorage.org/webt/s0/hy/yx/s0hyyxxh7iny_jc3t3k48ca83hs.png"><br><br>  En general, todo es como se esperaba: ha aparecido una nueva secci√≥n con un l√≠mite superior (recuerde que las condiciones de l√≠mite para nosotros pertenecen a la secci√≥n izquierda) 01/01/2019 y una secci√≥n vac√≠a en la que habr√° otros datos con una fecha m√°s larga. <br><br>  Todo parece estar bien, pero ¬øpor qu√© hay tantas lecturas?  Observamos cuidadosamente la figura anterior y vemos que los datos de la tercera secci√≥n que estaban en FG3 terminaron en FG1, pero la siguiente secci√≥n, vac√≠a, en FG3. <br><br>  2. Crear una mesa de escenario. <br><br>  Para cambiar (cambiar) una secci√≥n a una tabla y viceversa, necesitamos una tabla vac√≠a en la que se creen las mismas restricciones e √≠ndices que en nuestra tabla particionada.  La tabla debe estar en el mismo grupo de archivos que la secci√≥n que queremos "cambiar" all√≠.  La primera secci√≥n (archivada) se encuentra en FG1, por lo que creamos una tabla y un √≠ndice de cl√∫ster en el mismo lugar: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>)) ; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br>  No necesita particionar esta tabla. <br><br>  3. Ahora estamos listos para cambiar: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Y esto es lo que obtenemos: <br><br><pre> <code class="sql hljs"> 4947,  16,  1,  59 <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SWITCH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> failed. There <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> identical <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">source</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">'PartitionTest.dbo.pTest'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-string"><span class="hljs-string">'cix_stageTest_id'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> target <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">'PartitionTest.dbo.stageTest'</span></span> .</code> </pre> <br>  Es curioso, veamos qu√© tenemos en los √≠ndices: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.name tblName, i.name indexName, c.name columnName, ic.is_included_column <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.indexes i <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.objects o <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> i.object_id = o.object_id <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.index_columns ic <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ic.object_id = i.object_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ic.index_id = i.index_id <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.columns c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ic.column_id = c.column_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.object_id = c.object_id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'pTest'</span></span>, <span class="hljs-string"><span class="hljs-string">'stageTest'</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/8e/mf/1u/8emf1uqyw18p6rghqkv3enygfx0.png"><br><br>  ¬øRecuerdas que escrib√≠ que era necesario hacer un √≠ndice agrupado √∫nico en una tabla particionada?  Eso es precisamente por qu√© era necesario.  Al crear un √≠ndice agrupado √∫nico, SQL Server requerir√≠a incluir expl√≠citamente la columna por la cual dividimos la tabla en el √≠ndice, por lo que lo agreg√≥ √©l mismo y olvid√≥ decirlo.  Y realmente no entiendo por qu√©. <br>  Pero, en general, el problema es comprensible, recreamos el √≠ndice del cl√∫ster en la tabla del escenario. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, dt) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (drop_existing = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br>  Y ahora, una vez m√°s, intentamos cambiar la secci√≥n: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Ta Dam!  La secci√≥n est√° cambiada, vea lo que nos cost√≥: <br><br><pre> <code class="sql hljs">SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 3 ms.</code> </pre> <br>  Pero nada  Cambiar una secci√≥n a una tabla vac√≠a y viceversa (una tabla completa a una secci√≥n vac√≠a) es una operaci√≥n √∫nicamente en metadatos y esta es exactamente la raz√≥n por la cual la partici√≥n es algo muy, muy bueno. <br><br>  Veamos qu√© hay con nuestras secciones: <br><br><img src="https://habrastorage.org/webt/mb/7j/pl/mb7jpl32ekb7e-vgl3mjfczd1ru.png"><br><br>  Y todo es genial con ellos.  En la primera secci√≥n, quedan cero registros, se dejaron de forma segura para la tabla stageTest.  Podemos seguir adelante <br><br>  4. Todo lo que nos queda es eliminar nuestra primera secci√≥n vac√≠a.  Hag√°moslo y veamos qu√© sucede: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Y esto tambi√©n es una operaci√≥n solo en metadatos, en nuestro caso.  Nos fijamos en las secciones: <br><br><img src="https://habrastorage.org/webt/ju/ce/lf/jucelfzq4upnfi3fqg_8snuurho.png"><br><br>  Tenemos, como era, solo 3 secciones, cada una en su propio grupo de archivos.  Misi√≥n cumplida  ¬øQu√© podr√≠a mejorarse aqu√≠?  Bueno, en primer lugar, me gustar√≠a que los valores l√≠mite se refieran a las secciones "correctas", de modo que las secciones contengan todos los datos durante 4 meses.  Y me gustar√≠a ver que la creaci√≥n de una nueva secci√≥n cuesta menos.  Lea los datos diez veces m√°s que la tabla misma: busto. <br><br>  No podemos hacer nada con el primero ahora, pero con el segundo lo intentaremos.  Creemos una nueva secci√≥n que contendr√° datos del 01/01/2019 al 01/04/2019, y no hasta el final de los tiempos: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG2]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Y vemos: <br><br><pre> <code class="sql hljs">SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms.</code> </pre> <br>  Ja!  Entonces, ¬øahora esta operaci√≥n solo est√° en metadatos?  S√≠, si "divide" una secci√≥n vac√≠a: esta es una operaci√≥n solo en metadatos, por lo tanto, ser√° la decisi√≥n correcta mantener las secciones vac√≠as garantizadas tanto a la izquierda como a la derecha y, si es necesario, seleccionar una nueva: "cortarlas" desde all√≠. <br><br>  Ahora veamos qu√© sucede si quiero devolver los datos de la tabla de escenario a la tabla particionada.  Para hacer esto, necesitar√©: <br><br><ol><li>  Crear una nueva secci√≥n a la izquierda para datos </li><li>  Cambie la tabla a esta secci√≥n. </li></ol><br>  Intentamos (y recordamos que stageTest en FG1): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Vemos: <br><br><pre> <code class="sql hljs">Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'ptest'. Scan count 1, logical reads 2939, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Bueno, no est√° mal, es decir  lee solo la secci√≥n izquierda (que dividimos) y eso es todo.  Esta bien  Para cambiar una tabla no vac√≠a no particionada en una secci√≥n de tabla particionada, la tabla fuente debe tener restricciones para que SQL Server sepa que todo estar√° bien y que el cambio se puede realizar como una operaci√≥n en metadatos (en lugar de leer todo en una fila y verificar si la secci√≥n cumple o no las condiciones) ): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> check_dt <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (dt &lt;= <span class="hljs-string"><span class="hljs-string">'20180401'</span></span>)</code> </pre> <br>  Intentando cambiar: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Estad√≠sticas: <br><br><pre> <code class="sql hljs"> SQL Server Execution Times: CPU time = 15 ms, elapsed time = 39 ms.</code> </pre> <br>  Nuevamente, la operaci√≥n es solo en metadatos.  Vemos qu√© hay con nuestras secciones: <br><br><img src="https://habrastorage.org/webt/c2/wv/xe/c2wvxe_ex2iyvv3v7l9hvxokq70.png"><br><br>  Esta bien  Parece resuelto.  Y ahora intentaremos recrear la funci√≥n y el esquema de particionamiento (elimin√© el esquema y la funci√≥n de particionamiento, recre√© y rellen√© la tabla y volv√≠ a crear el √≠ndice del cl√∫ster utilizando el nuevo esquema de particionamiento): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  Veamos qu√© secciones tenemos ahora: <br><br><img src="https://habrastorage.org/webt/b6/mw/j2/b6mwj2konz7su7x_ng5eonsgukw.png"><br><br>  Bueno, ahora tenemos tres secciones "l√≥gicas": desde el principio hasta el 01/04/2018 00:00:00 (no incluido), desde el 01/04/2018 00:00:00 (incluido) hasta el 01/08/2018 00:00:00 ( no incluido) y el tercero, todo lo que es mayor o igual a 01/01/2018 00:00:00. <br><br>  Ahora intentemos realizar la misma tarea de archivar datos que realizamos con la funci√≥n de partici√≥n anterior. <br><br>  1. Agregar una nueva secci√≥n: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190101'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Nos fijamos en las estad√≠sticas: <br><br><pre> <code class="sql hljs">Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'ptest'. Scan count 1, logical reads 3685, physical reads 0, read-ahead reads 4, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'Worktable'. Scan count 1, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  No est√° mal, al menos razonablemente, lea solo la √∫ltima secci√≥n.  Nos fijamos en lo que tenemos en las secciones: <br><br><img src="https://habrastorage.org/webt/1l/yr/i9/1lyri90cqmu969imje4edli1e7m.png"><br><br>  Tenga en cuenta que ahora, la tercera secci√≥n completa se ha mantenido en su lugar en FG3, y se ha creado una nueva secci√≥n vac√≠a en FG1. <br><br>  2. Creamos una tabla de escenario y el √≠ndice de cl√∫ster CORRECTO en ella <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>)) ; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, dt) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br>  3. Cambiar secci√≥n <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Las estad√≠sticas dicen que la operaci√≥n de metadatos es: <br><br><pre> <code class="sql hljs">SQL Server Execution Times: CPU time = 0 ms, elapsed time = 5 ms.</code> </pre> <br>  Ahora, todo sin sorpresas. <br><br>  4. Eliminar la secci√≥n innecesaria <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Y aqu√≠ tenemos una sorpresa: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 1, logical reads 27057, physical reads 0, read-ahead reads 251, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Nos fijamos en lo que tenemos con las secciones: <br><br><img src="https://habrastorage.org/webt/qn/_j/xr/qn_jxrttkmls8amaycjwxqrescu.png"><br><br>  Y aqu√≠ queda claro: nuestra secci√≥n # 2 se movi√≥ del grupo de archivos fg2 al grupo de archivos fg1.  Clase.  ¬øPodemos hacer algo al respecto? <br><br>  Tal vez solo necesitemos tener siempre una secci√≥n vac√≠a y "destruir" el borde entre la secci√≥n izquierda "siempre vac√≠a" y la secci√≥n que "cambiamos" a otra tabla. <br><br>  <b>En conclusi√≥n:</b> <br><br><ol><li>  Utilice la sintaxis completa para crear la funci√≥n de partici√≥n, no conf√≠e en los valores predeterminados; es posible que no obtenga lo que desea. </li><li>  Mant√©ngase a la izquierda y a la derecha en la secci√≥n vac√≠a: ser√°n muy √∫tiles para organizar una "ventana deslizante". </li><li>  Dividir y fusionar secciones no vac√≠as: siempre duele, ev√≠telo si es posible. </li><li>  Verifique sus consultas: si no usan el filtro por la columna en la que planea dividir la tabla y necesita la capacidad de cambiar de secci√≥n, su rendimiento puede disminuir significativamente. </li><li>  Si quieres hacer algo, primero prueba que no est√© en producci√≥n. </li></ol><br>  Espero que el material haya sido √∫til.  Tal vez result√≥ ser arrugado, si crees que algo de lo declarado no se revela, escribe, intentar√© terminarlo.  Gracias por su atencion </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464665/">https://habr.com/ru/post/464665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464651/index.html">Biblioteca generadora de c√≥digo ensamblador para microcontroladores AVR. Parte 5</a></li>
<li><a href="../464655/index.html">C√≥mo los salarios y la popularidad de los lenguajes de programaci√≥n han cambiado en los √∫ltimos 2 a√±os</a></li>
<li><a href="../464657/index.html">Ingenier√≠a inversa cornisa el√©ctrica AM82TV</a></li>
<li><a href="../464659/index.html">Seguridad de aplicaciones o C√≥mo incrustar seguridad en el desarrollo personalizado. Experiencia personal en AGIMA</a></li>
<li><a href="../464661/index.html">A qui√©n confiar el dise√±o de las instalaciones t√©cnicas de reequipamiento y reconstrucci√≥n</a></li>
<li><a href="../464671/index.html">Reciba SMS regulares para mensajeros instant√°neos de Viber y Telegram (usando puertas de enlace GoIP)</a></li>
<li><a href="../464673/index.html">TinyFL - controlador de linterna microcontrolador</a></li>
<li><a href="../464675/index.html">An√°lisis de los mecanismos de localizaci√≥n de la interfaz de la aplicaci√≥n en Splunk</a></li>
<li><a href="../464677/index.html">Inversiones en bolsa y costos asociados: cu√°nto cuestan los servicios de una empresa de corretaje</a></li>
<li><a href="../464679/index.html">Voxgun: un servicio para crear contenido de video profesional sin ning√∫n esfuerzo adicional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>