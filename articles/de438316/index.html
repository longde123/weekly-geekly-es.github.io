<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëà üë©‚Äçüë©‚Äçüëß‚Äçüëß üé£ Grundlagen des signierten Distanzfelds in 2D ‚û∞ üèÇüèæ üì∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Obwohl Netze die einfachste und vielseitigste M√∂glichkeit zum Rendern sind, gibt es andere Optionen f√ºr die Darstellung von Formen in 2D und 3D. Eine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen des signierten Distanzfelds in 2D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438316/">  Obwohl Netze die einfachste und vielseitigste M√∂glichkeit zum Rendern sind, gibt es andere Optionen f√ºr die Darstellung von Formen in 2D und 3D.  Eine h√§ufig verwendete Methode sind SDF (Signed Distance Fields).  Signierte Entfernungsfelder bieten eine kosteng√ºnstigere Strahlverfolgung, erm√∂glichen einen reibungslosen Ablauf verschiedener Formen und sparen Texturen mit niedriger Aufl√∂sung f√ºr qualitativ hochwertige Bilder. <br><br>  Wir werden zun√§chst das Vorzeichen der Distanzfelder mit zweidimensionalen Funktionen erzeugen, sp√§ter jedoch weiterhin in 3D.  Ich werde die Koordinaten des Weltraums verwenden, damit wir so wenig wie m√∂glich von Skalierung und UV-Koordinaten abh√§ngig sind. Wenn Sie also nicht verstehen, wie dies funktioniert, lesen Sie dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial auf einer flachen √úberlagerung</a> , in der erkl√§rt wird, was passiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eb/w-/sj/ebw-sjziw5loorrc2yj1wsl1vyu.gif"></div><a name="habracut"></a><br><h2>  Vorbereitung der Stiftung </h2><br>  Wir werden die Eigenschaften vor√ºbergehend vom Basis-Flat-Overlay-Shader wegwerfen, da wir uns vorerst um die technische Basis k√ºmmern.  Dann schreiben wir die Position des Scheitelpunkts in der Welt direkt in die Fragmentstruktur und werden sie nicht zuerst in UV konvertieren.  In der letzten Phase der Vorbereitung werden wir eine neue Funktion schreiben, die die Szene berechnet und die Entfernung zur n√§chsten Oberfl√§che zur√ºckgibt.  Dann rufen wir die Funktionen auf und verwenden das Ergebnis als Farbe. <br><br><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//           Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //         o.position = UnityObjectToClipPos(v.vertex); //     o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { //      return 0; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback   ,       }</span></span></code> </pre> <br>  Ich werde alle Funktionen f√ºr die signierten Distanzfelder in eine separate Datei schreiben, damit wir sie wiederholt verwenden k√∂nnen.  Dazu erstelle ich eine neue Datei.  Wir werden nichts B√∂ses hinzuf√ºgen, dann setzen wir es und schlie√üen den bedingten Include-Schutz ab, wobei wir zuerst pr√ºfen, ob die Pr√§prozessorvariable gesetzt ist.  Wenn es noch nicht definiert ist, definieren wir es und vervollst√§ndigen das bedingte if-Konstrukt nach den Funktionen, die wir einschlie√üen m√∂chten.  Dies hat den Vorteil, dass der Shader besch√§digt wird, wenn wir die Datei zweimal hinzuf√ºgen (z. B. wenn wir zwei verschiedene Dateien hinzuf√ºgen, von denen jede die Funktionen hat, die wir ben√∂tigen, und beide dieselbe Datei hinzuf√ºgen).  Wenn Sie sicher sind, dass dies niemals passieren wird, k√∂nnen Sie diese Pr√ºfung nicht durchf√ºhren. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in include file // include guards that keep the functions from being included more than once #ifndef SDF_2D #define SDF_2D // functions #endif</span></span></code> </pre> <br>  Wenn sich die Include-Datei im selben Ordner wie der Haupt-Shader befindet, k√∂nnen wir sie einfach mit dem Pragma-Konstrukt einschlie√üen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in main shader #include "2D_SDF.cginc"</span></span></code> </pre> <br>  Wir sehen also nur eine schwarze Oberfl√§che auf der gerenderten Oberfl√§che, die bereit ist, die Entfernung mit einem Zeichen darauf anzuzeigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25b/a3a/188/25ba3a188962c645fc6a12cfb5aed751.png"></div><br><h2>  Kreis </h2><br>  Die einfachste Funktion des vorzeichenbehafteten Distanzfeldes ist die Kreisfunktion.  Die Funktion erh√§lt nur die Position der Probe und den Radius des Kreises.  Wir beginnen mit der L√§nge des Probenpositionsvektors.  Wir erhalten also einen Punkt an der Position (0, 0), der einem Kreis mit einem Radius von 0 √§hnelt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(samplePosition); }</code> </pre> <br>  Anschlie√üend k√∂nnen Sie die Kreisfunktion in der Szenenfunktion aufrufen und die zur√ºckgegebene Entfernung zur√ºckgeben. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = circle(position, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/839/6a8/f87/8396a8f8780b6b30deb88d1009f6f5c7.png"></div><br>  Dann addieren wir den Radius zu den Berechnungen.  Ein wichtiger Aspekt der vorzeichenbehafteten Abstandsfunktionen ist, dass wir innerhalb des Objekts einen negativen Abstand zur Oberfl√§che erhalten (dies bedeutet das Wort vorzeichenbehaftet im Feld vorzeichenbehaftete Entfernung).  Um den Kreis auf einen Radius zu vergr√∂√üern, subtrahieren wir einfach den Radius von der L√§nge.  Somit bewegt sich die Oberfl√§che, die sich √ºberall dort befindet, wo die Funktion 0 zur√ºckgibt, nach au√üen.  Das, was f√ºr einen Kreis mit einer Gr√∂√üe von 0 in zwei Einheiten des Abstands von der Oberfl√§che liegt, ist nur eine Einheit von einem Kreis mit einem Radius von 1 und eine Einheit innerhalb des Kreises (der Wert ist -1) f√ºr einen Kreis mit einem Radius von 3; <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(samplePosition) - radius; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/b83/57f/e7ab8357f4c844bc7bc58dfda6406d9d.png"></div><br>  Jetzt k√∂nnen wir den Kreis nur noch von der Mitte aus verschieben.  Um dies zu beheben, k√∂nnen Sie der Kreisfunktion ein neues Argument hinzuf√ºgen, um den Abstand zwischen der Probenposition und dem Mittelpunkt des Kreises zu berechnen, und den Radius von diesem Wert subtrahieren, um einen Kreis zu definieren.  Sie k√∂nnen den Ursprung auch neu definieren, indem Sie den Raum des Abtastpunkts verschieben und dann einen Kreis in diesem Raum erhalten.  Die zweite Option sieht viel komplizierter aus, aber da das Verschieben von Objekten eine Operation ist, die wir f√ºr alle Figuren verwenden m√∂chten, ist sie viel universeller, und deshalb werde ich sie erkl√§ren. <br><br><h2>  Umzug </h2><br>  "Transformation des Raumes eines Punktes" - klingt viel schlimmer als es tats√§chlich ist.  Dies bedeutet, dass wir den Punkt an die Funktion √ºbergeben und die Funktion ihn √§ndert, damit wir ihn auch in Zukunft verwenden k√∂nnen.  Bei einer √úbertragung subtrahieren wir einfach den Versatz vom Punkt.  Die Position wird subtrahiert, wenn wir die Formen in die positive Richtung verschieben m√∂chten, da sich die Formen, die wir im Raum rendern, in die entgegengesetzte Richtung zur Bewegung des Raums bewegen. <br><br>  Wenn wir zum Beispiel eine Kugel in Position <code>(3, 4)</code> zeichnen m√∂chten, m√ºssen wir den Raum so √§ndern, dass <code>(3, 4)</code> zu <code>(0, 0)</code> , und daf√ºr m√ºssen wir <code>(3, 4)</code> subtrahieren.  Wenn wir nun eine Kugel um einen <i>neuen</i> Ursprungspunkt zeichnen, ist dies ein <i>alter</i> Punkt <code>(3, 4)</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in sdf functions include file float2 translate(float2 samplePosition, float2 offset){ return samplePosition - offset; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = translate(position, float2(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = circle(circlePosition, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/7ca/6cc/7e57ca6cc1b5953b03811fd2d48ac3f1.png"></div><br><h2>  Rechteck </h2><br>  Eine andere einfache Form ist ein Rechteck.  Zun√§chst betrachten wir die Komponenten separat.  Zuerst erhalten wir den Abstand vom Zentrum, wobei wir den absoluten Wert nehmen.  Dann subtrahieren wir √§hnlich wie bei einem Kreis die H√§lfte der Gr√∂√üe (die im Wesentlichen dem Radius eines Rechtecks ‚Äã‚Äã√§hnelt).  Um nur zu zeigen, wie die Ergebnisse aussehen werden, geben wir vorerst nur eine Komponente zur√ºck. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rectangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, float2 halfSize)</span></span></span></span>{ float2 componentWiseEdgeDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(samplePosition) - halfSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentWiseEdgeDistance.x; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/d5f/62a/14dd5f62af057366f38cdfaa2bc19315.png"></div><br>  Jetzt k√∂nnen wir eine billige Version des Rechtecks ‚Äã‚Äãerhalten, indem wir einfach die gr√∂√üte Komponente 2 zur√ºckgeben. Dies funktioniert in vielen F√§llen, aber nicht korrekt, da nicht der richtige Abstand um die Ecken angezeigt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/b19/e06/a9cb19e061cb980c3fe8a2d533b2fbfb.png"></div><br>  Die korrekten Werte f√ºr das Rechteck au√üerhalb der Figur k√∂nnen erhalten werden, indem zuerst das Maximum zwischen den Abst√§nden zu den Kanten und 0 und dann seine L√§nge genommen werden. <br><br>  Wenn wir den Abstand von unten nicht auf 0 begrenzen, berechnen wir einfach den Abstand zu den Ecken (wobei edgeDistances <code>(0, 0)</code> ), aber die Koordinaten zwischen den Ecken fallen nicht unter 0, sodass die gesamte Kante verwendet wird.  Dies hat den Nachteil, dass 0 als Abstand von der Kante f√ºr das gesamte Innere der Figur verwendet wird. <br><br>  Um den Abstand 0 f√ºr den gesamten inneren Teil zu korrigieren, m√ºssen Sie den Innenabstand einfach mit der billigen Rechteckformel (unter Verwendung des Maximalwerts aus der x- und y-Komponente) generieren und dann sicherstellen, dass er niemals 0 √ºberschreitet, und den Minimalwert daraus auf 0 setzen. Dann addieren wir den externen Abstand, der niemals kleiner als 0 ist, und den inneren Abstand, der niemals 0 √ºberschreitet, und erhalten die fertige Distanzfunktion. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rectangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, float2 halfSize)</span></span></span></span>{ float2 componentWiseEdgeDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(samplePosition) - halfSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outsideDistance = length(max(componentWiseEdgeDistance, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outsideDistance + insideDistance; }</code> </pre> <br>  Da wir die √úbertragungsfunktion zuvor in universeller Form aufgezeichnet haben, k√∂nnen wir sie jetzt auch verwenden, um ihre Mitte an einen beliebigen Ort zu verschieben. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = translate(position, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc0/8eb/671/cc08eb671ae5314ae32d3a20cd685b4b.png"></div><br><h2>  Drehen Sie sich </h2><br>  Das Drehen von Formen √§hnelt dem Bewegen.  Bevor wir den Abstand zur Figur berechnen, drehen wir die Koordinaten in die entgegengesetzte Richtung.  Um das Verst√§ndnis der Rotationen so weit wie m√∂glich zu vereinfachen, multiplizieren wir die Rotation mit 2 * pi, um den Winkel im Bogenma√ü zu erhalten.  Daher √ºbergeben wir eine Rotation an die Funktion, wobei 0,25 eine viertel Umdrehung, 0,5 eine halbe Umdrehung und 1 eine vollst√§ndige Umdrehung ist (Sie k√∂nnen Konvertierungen anders durchf√ºhren, wenn es Ihnen nat√ºrlicher erscheint).  Wir kehren auch die Drehung um, da wir die Position aus dem gleichen Grund wie beim Bewegen in die entgegengesetzte Richtung zur Drehung der Figur drehen m√ºssen. <br><br>  Um die gedrehten Koordinaten zu berechnen, berechnen wir zuerst den Sinus und den Cosinus basierend auf dem Winkel.  Hlsl hat eine Sincos-Funktion, die diese beiden Werte schneller berechnet als wenn sie separat berechnet werden. <br><br>  Wenn wir einen neuen Vektor f√ºr die Komponente x konstruieren, nehmen wir die urspr√ºngliche Komponente x multipliziert mit dem Kosinus und die Komponente y multipliziert mit dem Sinus.  Dies kann leicht in Erinnerung bleiben, wenn Sie sich daran erinnern, dass der Cosinus von 0 1 ist, und wenn er um 0 gedreht wird, soll die Komponente x des neuen Vektors genau dieselbe sein wie zuvor (dh mit 1 multiplizieren).  Die Komponente y, die zuvor nach oben zeigte und keinen Beitrag zur Komponente x leistete, dreht sich nach rechts, und ihre Werte beginnen bei 0 und werden zun√§chst gr√∂√üer, dh ihre Bewegung wird vollst√§ndig durch einen Sinus beschrieben. <br><br>  F√ºr die Komponente y des neuen Vektors multiplizieren wir den Kosinus mit der Komponente y des alten Vektors und subtrahieren den Sinus multipliziert mit der alten Komponente x.  Um zu verstehen, warum wir den Sinus, multipliziert mit der Komponente x, subtrahieren, anstatt ihn zu addieren, stellen Sie sich am besten vor, wie sich der Vektor <code>(1, 0)</code> im Uhrzeigersinn √§ndert.  Die y-Komponente des Ergebnisses beginnt bei 0 und wird dann kleiner als 0. Dies ist das Gegenteil des Verhaltens des Sinus, daher √§ndern wir das Vorzeichen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = rotation * PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sine, cosine; sincos(angle, sine, cosine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); }</code> </pre> <br>  Nachdem wir die Rotationsmethode geschrieben haben, k√∂nnen wir sie in Kombination mit der √úbertragung verwenden, um die Figur zu bewegen und zu drehen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y); circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/99b/da0/d4699bda0f35c10163998bd22fac5eab.gif"></div><br>  In diesem Fall drehen wir zuerst das Objekt um die Mitte der gesamten Szene, sodass die Drehung auch die √úbertragung beeinflusst.  Um eine Figur relativ zu ihrer eigenen Mitte zu drehen, m√ºssen Sie sie zuerst verschieben und dann drehen.  Aufgrund dieser zum Zeitpunkt der Drehung ge√§nderten Reihenfolge wird der Mittelpunkt der Figur zum Mittelpunkt des Koordinatensystems. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, _Time.y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/3f3/12d/8e53f312d343fcbe95d000703001da3c.gif"></div><br><h2>  Skalieren </h2><br>  Die Skalierung funktioniert √§hnlich wie andere Arten, Formen zu transformieren.  Wir teilen die Koordinaten durch Skalierung, rendern die Figur im Raum mit einer reduzierten Skalierung und im Basiskoordinatensystem werden sie gr√∂√üer. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samplePosition / scale; }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, <span class="hljs-number"><span class="hljs-number">.125</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pulseScale = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">3.14</span></span>); circlePosition = scale(circlePosition, pulseScale); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e66/043/a58/e66043a5877fbdcbcc38629d70334481.gif"></div><br>  Obwohl dies die Skalierung korrekt durchf√ºhrt, skaliert auch der Abstand.  Der Hauptvorteil des vorzeichenbehafteten Entfernungsfelds besteht darin, dass wir immer die Entfernung zur n√§chsten Oberfl√§che kennen, das Herauszoomen diese Eigenschaft jedoch vollst√§ndig zerst√∂rt.  Dies kann leicht behoben werden, indem das aus der Vorzeichenentfernungsfunktion (in unserem Fall das <code>rectangle</code> ) erhaltene Distanzfeld mit der Skala multipliziert wird.  Aus dem gleichen Grund k√∂nnen wir nicht leicht ungleichm√§√üig skalieren (mit unterschiedlichen Skalierungen f√ºr die x- und y-Achse). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, <span class="hljs-number"><span class="hljs-number">.125</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pulseScale = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">3.14</span></span>); circlePosition = scale(circlePosition, pulseScale); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) * pulseScale; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/1bd/da1/8021bdda196f8300516f04cdf965c8af.gif"></div><br><h2>  Visualisierung </h2><br>  Signierte Entfernungsfelder k√∂nnen f√ºr eine Vielzahl von Dingen verwendet werden, z. B. zum Erstellen von Schatten, Rendern von 3D-Szenen, Physik und Rendern von Text.  Wir m√∂chten jedoch noch nicht tief in die Komplexit√§t eintauchen, daher werde ich nur zwei Techniken ihrer Visualisierung erl√§utern.  Die erste ist eine klare Form mit Antialiasing, die zweite ist das Rendern von Linien in Abh√§ngigkeit von der Entfernung. <br><br><h3>  Klare Form </h3><br>  Diese Methode √§hnelt der beim Rendern von Text h√§ufig verwendeten Methode und erstellt eine klare Form.  Wenn wir ein Distanzfeld nicht aus einer Funktion erzeugen, sondern aus einer Textur lesen m√∂chten, k√∂nnen wir Texturen mit einer viel niedrigeren Aufl√∂sung als √ºblich verwenden und gute Ergebnisse erzielen.  TextMesh Pro verwendet diese Technik zum Rendern von Text. <br><br>  Um diese Technik anzuwenden, nutzen wir die Tatsache, dass die Daten in den Entfernungsfeldern signiert sind und wir den Grenzwert kennen.  Wir beginnen mit der Berechnung, wie weit sich das Distanzfeld zum n√§chsten Pixel √§ndert.  Dies sollte der gleiche Wert sein wie die L√§nge der Koordinaten√§nderung, aber es ist einfacher und zuverl√§ssiger, die Entfernung mit einem Vorzeichen zu berechnen. <br><br>  Nachdem wir die Entfernungs√§nderung erhalten haben, k√∂nnen wir einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reibungslosen Schritt</a> von der halben Entfernungs√§nderung zu minus / plus der halben Entfernungs√§nderung machen.  Dies f√ºhrt ein einfaches Abschneiden um etwa 0 durch, jedoch mit Gl√§ttung.  Dann k√∂nnen Sie diesen gegl√§tteten Wert f√ºr jeden ben√∂tigten Bin√§rwert verwenden.  In diesem Beispiel werde ich den Shader in einen Transparenz-Shader √§ndern und ihn f√ºr den Alphakanal verwenden.  Ich mache einen glatten Schritt von einem positiven zu einem negativen Wert, weil wir wollen, dass der negative Wert des Distanzfeldes sichtbar ist.  Wenn Sie nicht genau verstehen, wie Transparenz-Rendering hier funktioniert, empfehlen wir Ihnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mein Tutorial zum</a> Transparenz-Rendering zu lesen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//properties Properties{ _Color("Color", Color) = (1,1,1,1) }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in subshader outside of pass Tags{ "RenderType"="Transparent" "Queue"="Transparent"} Blend SrcAlpha OneMinusSrcAlpha ZWrite Off</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> antialiasedCutoff = smoothstep(distanceChange, -distanceChange, dist); fixed4 col = fixed4(_Color, antialiasedCutoff); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/a08/e1c/86da08e1cfcb25212c6bf3c22dfa1dc8.gif"></div><br><h3>  H√∂henlinien </h3><br>  Eine andere √ºbliche Technik zum Visualisieren von Entfernungsfeldern besteht darin, Entfernungen als Linien anzuzeigen.  In unserer Implementierung werde ich ein paar dicke Linien und ein paar d√ºnne Linien dazwischen hinzuf√ºgen.  Ich werde auch die Innen- und Au√üenseite der Figur in verschiedenen Farben bemalen, damit Sie sehen k√∂nnen, wo sich das Objekt befindet. <br><br>  Wir beginnen mit der Darstellung des Unterschieds zwischen der Innenseite und der Au√üenseite der Figur.  Die Farben k√∂nnen im Material angepasst werden, daher werden neue Eigenschaften sowie Shader-Variablen f√ºr die Innen- und Au√üenfarben der Figur hinzugef√ºgt. <br><br><pre> <code class="cpp hljs">Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//global shader variables float4 _InsideColor; float4 _OutsideColor;</span></span></code> </pre> <br>  Dann √ºberpr√ºfen wir im Fragment-Shader, wo sich das Pixel befindet, was wir rendern, indem wir den Abstand mit dem Vorzeichen mit 0 mit der <code>step</code> .  Wir verwenden diese Variable, um von der inneren zur √§u√üeren Farbe zu interpolieren und sie auf dem Bildschirm zu rendern. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/13c/15b/98913c15b68cb3fcca4b6d1e4a3f70c0.gif"></div><br>  Um Linien zu rendern, m√ºssen wir zun√§chst angeben, wie oft und wie dick Linien gerendert werden sollen, und die Eigenschaften und die entsprechenden Shader-Variablen festlegen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Properties _LineDistance("Mayor Line Distance", Range(0, 2)) = 1 _LineThickness("Mayor Line Thickness", Range(0, 0.1)) = 0.05</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//shader variables float _LineDistance; float _LineThickness;</span></span></code> </pre> <br>  Um die Linien zu rendern, berechnen wir zun√§chst die Abstands√§nderung, damit wir sie sp√§ter zum Gl√§tten verwenden k√∂nnen.  Wir haben es auch bereits durch 2 geteilt, weil wir sp√§ter die H√§lfte davon addieren und die H√§lfte davon subtrahieren, um den √Ñnderungsabstand von 1 Pixel abzudecken. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>;</code> </pre> <br>  Dann nehmen wir die Distanz und transformieren sie so, dass sie sich an sich wiederholenden Punkten genauso verh√§lt.  Dazu teilen wir es zuerst durch den Abstand zwischen den Linien, w√§hrend wir nicht bei jedem ersten Schritt vollst√§ndige Zahlen erhalten, sondern vollst√§ndige Zahlen nur auf der Grundlage des von uns festgelegten Abstands. <br><br>  Dann addieren wir 0,5 zur Zahl, nehmen den Bruchteil und subtrahieren erneut 0,5.  Der Bruchteil und die Subtraktion werden hier ben√∂tigt, damit die Linie im sich wiederholenden Muster durch Null geht.  Wir addieren 0,5, um den Bruchteil zu erhalten, um eine weitere Subtraktion von 0,5 zu neutralisieren - der Versatz f√ºhrt dazu, dass die Werte, bei denen der Graph 0 ist, bei 0, 1, 2 usw. liegen und nicht bei 0,5, 1,5, usw. <br><br>  Die letzten Schritte zum Konvertieren des Werts - wir nehmen den absoluten Wert und multiplizieren ihn erneut mit dem Abstand zwischen den Linien.  Durch den absoluten Wert bleiben die Bereiche vor und nach den Punkten der Linie gleich, was das Erstellen von Ausschnitten f√ºr die Linien erleichtert.  Die letzte Operation, bei der wir den Wert erneut mit dem Abstand zwischen den Linien multiplizieren, wird ben√∂tigt, um die Division am Anfang der Gleichung zu neutralisieren. Dank dessen ist die √Ñnderung des Werts wieder dieselbe wie zu Beginn, und die zuvor berechnete √Ñnderung des Abstands ist immer noch korrekt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/db3/de9/a89db3de916eaf871c4525348272a635.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance;</code> </pre> <br>  Nachdem wir den Abstand zu den Linien basierend auf dem Abstand zur Figur berechnet haben, k√∂nnen wir die Linien zeichnen.  Wir machen einen reibungslosen Schritt von Liniendicke minus der H√§lfte der Abstands√§nderung zu Liniendicke plus der H√§lfte der Abstands√§nderung und verwenden den gerade berechneten Linienabstand als Vergleichswert.  Nachdem wir diesen Wert berechnet haben, multiplizieren wir ihn mit der Farbe, um schwarze Linien zu erstellen (Sie k√∂nnen auch zu einer anderen Farbe wechseln, wenn Sie mehrfarbige Linien ben√∂tigen). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col * majorLines; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/890/6b1/452/8906b1452c9d7a05f39b5c3070f2c547.gif"></div><br>  Wir implementieren d√ºnne Linien zwischen dicken Linien auf die gleiche Weise - wir f√ºgen eine Eigenschaft hinzu, die bestimmt, wie viele d√ºnne Linien zwischen dicken sein sollen, und dann machen wir das, was wir mit dicken Linien gemacht haben, aber aufgrund des Abstands zwischen d√ºnnen Linien teilen wir den Abstand zwischen dicken Linien durch die Anzahl der d√ºnnen Linien zwischen sie.  Wir werden auch die Anzahl der d√ºnnen Linien <code>IntRange</code> , dank dessen k√∂nnen wir nur ganzzahlige Werte zuweisen und keine d√ºnnen Linien erhalten, die nicht <code>IntRange</code> dicken <code>IntRange</code> .  Nachdem wir d√ºnne Linien berechnet haben, multiplizieren wir sie mit der Farbe auf die gleiche Weise wie dicke. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//properties [IntRange]_SubLines("Lines between major lines", Range(1, 10)) = 4 _SubLineThickness("Thickness of inbetween lines", Range(0, 0.05)) = 0.01</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//shader variables float _SubLines; float _SubLineThickness;</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceBetweenSubLines = _LineDistance / _SubLines; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> subLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / distanceBetweenSubLines + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * distanceBetweenSubLines; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col * majorLines * subLines; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8c/664/bf0/e8c664bf0fb16337f77f242c4f3f5c01.gif"></div><br><h2>  Quellcode </h2><br><h3>  2D SDF-Funktionen </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/2D_SDF.cginc</a> </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h3>  Kreis Beispiel </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Circle.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Rectangle"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  Rechteck Beispiel </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Rectangle.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Rectangle"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  Cutoff </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Cutoff.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Cutoff"</span></span>{ Properties{ _Color(<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) } SubShader{ Tags{ <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span>} Blend SrcAlpha OneMinusSrcAlpha ZWrite Off Pass{ CGPROGRAM #include <span class="hljs-string"><span class="hljs-string">"UnityCG.cginc"</span></span> #include <span class="hljs-string"><span class="hljs-string">"2D_SDF.cginc"</span></span> #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2f</span></span></span><span class="hljs-class">{</span></span> float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; fixed3 _Color; <span class="hljs-function"><span class="hljs-function">v2f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(appdata v)</span></span></span></span>{ v2f o; <span class="hljs-comment"><span class="hljs-comment">//calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); float distanceChange = fwidth(dist) * 0.5; float antialiasedCutoff = smoothstep(distanceChange, -distanceChange, dist); fixed4 col = fixed4(_Color, antialiasedCutoff); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  Entfernungslinien </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/DistanceLines.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/DistanceLines"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.2); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  Ich hoffe, ich habe es geschafft, die Grundlagen von Distanzzeichenfeldern zu erkl√§ren, und Sie warten bereits auf einige neue Tutorials, in denen ich √ºber andere Verwendungsm√∂glichkeiten sprechen werde. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438316/">https://habr.com/ru/post/de438316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438304/index.html">Vergabe von Unterauftr√§gen? Cool du schl√§gst</a></li>
<li><a href="../de438306/index.html">Strahlung: Wochentags radiochemisches Labor</a></li>
<li><a href="../de438310/index.html">Instagram verwendet maschinelles Lernen, um gef√§lschte Follower zu entfernen</a></li>
<li><a href="../de438312/index.html">Netzwerkautomatisierung mit Ansible: Befehlsmodul</a></li>
<li><a href="../de438314/index.html">1. Check Point Maestro Hyperscale-Netzwerksicherheit - eine neue skalierbare Sicherheitsplattform</a></li>
<li><a href="../de438318/index.html">Wie man die asynchrone / wartende Syntax beherrscht: ein echtes Beispiel</a></li>
<li><a href="../de438320/index.html">Kindern das Programmieren beibringen</a></li>
<li><a href="../de438322/index.html">VSaaS 2025: CCTV-Technologie der Zukunft</a></li>
<li><a href="../de438326/index.html">5G in Russland: Warum wird es ben√∂tigt, wie viel kostet es und wann wird es erscheinen? Kurz zur Hauptsache</a></li>
<li><a href="../de438328/index.html">Wie hoch ist die Gehaltsblase f√ºr Programmierer?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>