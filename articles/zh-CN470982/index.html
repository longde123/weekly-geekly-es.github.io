<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌕 👩🏻 👧🏼 使用PVS-Studio在Travis CI，Buddy和AppVeyor中分析提交和请求请求 😦 📦 ⛹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="从7.04版开始，针对Linux和macOS上的C和C ++语言的PVS-Studio分析仪提供了检查指定文件列表的测试功能。 使用新模式，您可以将分析器配置为检查提交和请求。 本文介绍如何在Travis CI，Buddy和AppVeyor等流行的CI（连续集成）系统中设置对来自GitHub项目的某...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用PVS-Studio在Travis CI，Buddy和AppVeyor中分析提交和请求请求</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/470982/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac4/d08/0e7/ac4d080e7661626569ef514abe190662.png" alt="图片11"></div><br> 从7.04版开始，针对Linux和macOS上的C和C ++语言的PVS-Studio分析仪提供了检查指定文件列表的测试功能。 使用新模式，您可以将分析器配置为检查提交和请求。 本文介绍如何在Travis CI，Buddy和AppVeyor等流行的CI（连续集成）系统中设置对来自GitHub项目的某些修改文件的检查。 <br><a name="habracut"></a><br><h2> 检查文件列表的方式 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio</a>是一种工具，旨在检测用C，C ++，C＃和Java编写的程序源代码中的错误和潜在漏洞。 在Windows，Linux和macOS上的64位系统上运行。 <br><br> 在适用于Linux和macOS的PVS-Studio 7.04版本中，现在提供了检查文件列表的模式。 它适用于项目，其构建系统允许生成<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">compile_commands.json</a>文件。 为了使分析器获得有关某些文件编译的信息，这是必需的。 如果您的构建系统不支持compile_commands.json文件的生成，则可以尝试使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Bear</a>实用程序生成此类文件。 <br><br> 这种检查文件列表的方式也可以与strace生成的编译器运行跟踪日志一起使用（pvs-studio-analyzer跟踪）。 为此，首先需要完成完整的项目构建并进行跟踪，以便分析器收集有关所有已检查文件的编译参数的完整信息。 <br><br> 但是，此选项有一个很大的缺点-您必须在每次运行时都对整个项目执行完整的构建跟踪，这与快速提交检查的想法背道而驰。 或者，如果您缓存跟踪结果本身，则在跟踪源文件的结构依赖关系发生更改（例如，在一个源文件中添加了新的#include）后，后续的分析器运行可能会不完整。 <br><br> 因此，我们不建议您使用通过跟踪日志检查文件列表的模式来检查提交或请求请求。 如果在检查提交时可以执行增量构建，请考虑使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">增量分析</a>模式。 <br><br> 用于分析的源文件列表保存在文本文件中，并使用<i>-S</i>参数传递给分析器： <br><br><pre><code class="bash hljs">pvs-studio-analyzer analyze ... -f build/compile_commands.json -S check-list.txt</code> </pre> <br> 该文件包含文件的相对路径和绝对路径，其中每个新文件都位于新行中。 您可以同时指定分析的文件名和不同的文本。 至于文本，分析器将注意到它不是文件名，并且将忽略该行。 如果手动指定文件，则对注释很有用。 但是，通常会在CI分析期间生成文件列表，例如，它可以是来自提交或拉取请求的文件。 <br><br> 现在，使用这种模式，您可以在新代码进入主开发分支之前快速对其进行检查。 在<i>plog-converter</i>实用程序中添加了<i>--indicate-warnings</i>标志，以便检查系统响应分析器警告的存在。 <br><br><pre> <code class="bash hljs">plog-converter ... --indicate-warnings ... -o /path/to/report.tasks ...</code> </pre> <br> 使用此标志，如果分析仪报告中有警告，则转换器将返回非零代码。 您可以阻止预提交挂钩，提交或拉取请求，并显示生成的分析器报告，共享或通过邮件发送。 <br><br>  <i>注意事项</i>  <i>在文件列表的第一次分析期间，将检查整个项目，因为分析器必须从头文件生成与项目源文件相关的文件。</i>  <i>这是C和C ++文件分析的独特之处。</i>  <i>将来，此依赖文件可以被缓存，并且将由分析器自动更新。</i>  <i>与增量分析模式相比，使用检查文件列表的模式检查提交的优势在于您只需要缓存此文件，而不是对象文件。</i> <br><br><h2> 拉取请求分析的一般原则 </h2><br> 整个项目分析需要花费大量时间，因此仅检查其中一部分是有意义的。 问题是您需要将新文件与其余项目文件分开。 <br><br> 让我们看一下两分支提交树的示例： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/722/646/68c/72264668c4a90b96ccb63f363a46c683.png" alt="图片5"></div><br><br> 想象一下， <i>A1</i>提交包含大量已经检查过的代码。 以前，我们从<i>A1</i>提交创建了一个分支，并更改了一些文件。 <br><br> 当然，您已经注意到，在<i>A1</i>之后发生了另外两个提交，并且另外两个分支合并了，因为我们没有在<i>master中</i>提交。  <i>修补程序</i>准备就绪的时刻到了。 这就是为什么我们收到合并<i>B3</i>和<i>A3的</i>请求请求的原因。 <br><br> 我们可以检查它们合并的结果，但是它太长且不合理，因为仅修改了一些文件。 因此，仅分析已更改的内容更为有效。 <br><br> 为此，我们将收到分支之间的差异，该差异位于分支的HEAD中，我们希望将其合并到master中： <br><br><pre> <code class="bash hljs">git diff --name-only HEAD origin/<span class="hljs-variable"><span class="hljs-variable">$MERGE_BASE</span></span> &gt; .pvs-pr.list</code> </pre> <br> 稍后我们将详细考虑<i>$ MERGE_BASE</i> 。 事实是，并非每个CI服务都在合并基础上提供所需的信息，因此每次我们都必须考虑获取此数据的新方法。 下面将针对所描述的每个Web服务对此进行详细考虑。 <br><br> 因此，我们得到了分支之间的区别，这是修改后的文件名的列表。 现在，我们需要将此<i>.pvs-pr.list</i>文件提供给分析器。 我们之前已将输出重定向到它。 <br><br><pre> <code class="bash hljs">pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ -S .pvs-pr.list</code> </pre> <br> 分析之后，我们需要将日志文件（PVS-Studio.log）转换为用户友好的格式： <br><br><pre> <code class="bash hljs">plog-converter -t errorfile PVS-Studio.log --cerr -w</code> </pre> <br> 此命令将输出<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">stderr</a>中的错误列表（标准错误流）。 <br><br> 问题在于，我们不仅需要输出错误，而且还需要报告有关问题的构建和测试服务。 为此，在转换器中添加了<i>-W</i> （-- <i>indicate-warnings</i> ）标志。 如果至少有一个分析器警告，则<i>plog-converter</i>实用程序的返回码将更改为2，这反过来将向CI服务报告有关请求请求文件中潜在错误的信息。 <br><br><h2> 特拉维斯 </h2><br> 以<i>.travis.yml</i>文件的形式进行配置。 为了方便起见，我建议您在单独的bash脚本中隔离所有与PVS-Studio相关的命令，这些脚本具有将从文件<i>.travis.yml</i> （ <i>bash script_name.sh function_name</i> ）中调用的<i>函数</i> 。 <br><br> 通过扩展脚本，您将获得更多功能。 在<i>安装</i>部分中编写以下内容： <br><br><pre> <code class="xml hljs">install: - bash .travis.sh travis_install</code> </pre> <br> 如果您有一些说明，则可以在除去连字符的情况下在脚本中移动它们。 <br><br> 打开<i>.travis.sh</i>文件，并在<i>travis_install（）</i>函数中添加分析器安装： <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">travis_install</span></span></span></span>() { wget -q -O - https://files.viva64.com/etc/pubkey.txt \ | sudo apt-key add - sudo wget -O /etc/apt/sources.list.d/viva64.list \ https://files.viva64.com/etc/viva64.list sudo apt-get update -qq sudo apt-get install -qq pvs-studio }</code> </pre> <br> 现在，让我们在<i>脚本</i>部分中运行分析器： <br><br><pre> <code class="xml hljs">script: - bash .travis.sh travis_script</code> </pre> <br> 在bash脚本中： <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">travis_script</span></span></span></span>() { pvs-studio-analyzer credentials <span class="hljs-variable"><span class="hljs-variable">$PVS_USERNAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$PVS_KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TRAVIS_PULL_REQUEST</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">"false"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> git diff --name-only origin/HEAD &gt; .pvs-pr.list pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ -S .pvs-pr.list \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> plog-converter -t errorfile PVS-Studio.log --cerr -w }</code> </pre> <br> 您必须在构建项目后运行此代码，例如，如果您在CMake上构建： <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">travis_script</span></span></span></span>() { CMAKE_ARGS=<span class="hljs-string"><span class="hljs-string">"-DCMAKE_EXPORT_COMPILE_COMMANDS=On </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${CMAKE_ARGS}</span></span></span><span class="hljs-string">"</span></span> cmake <span class="hljs-variable"><span class="hljs-variable">$CMAKE_ARGS</span></span> CMakeLists.txt make -j8 }</code> </pre> <br> 您将获得以下内容： <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">travis_script</span></span></span></span>() { CMAKE_ARGS=<span class="hljs-string"><span class="hljs-string">"-DCMAKE_EXPORT_COMPILE_COMMANDS=On </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${CMAKE_ARGS}</span></span></span><span class="hljs-string">"</span></span> cmake <span class="hljs-variable"><span class="hljs-variable">$CMAKE_ARGS</span></span> CMakeLists.txt make -j8 pvs-studio-analyzer credentials <span class="hljs-variable"><span class="hljs-variable">$PVS_USERNAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$PVS_KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TRAVIS_PULL_REQUEST</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">"false"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> git diff --name-only origin/HEAD &gt; .pvs-pr.list pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ -S .pvs-pr.list \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> plog-converter -t errorfile PVS-Studio.log --cerr -w }</code> </pre> <br> 您很可能已经注意到环境变量<i>$ TRAVIS_PULL_REQUEST</i>和<i>$ TRAVIS_BRANCH</i> 。  Travis CI声明了它们本身： <br><br><ul><li>  <i>$ TRAVIS_PULL_REQUEST</i>存储拉取请求号，如果是常规分支则为<i>false</i> ； </li><li>  <i>$ TRAVIS_REPO_SLUG</i>存储项目存储库的名称。 </li></ul><br> 这是此函数的运算算法： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebe/643/58b/ebe64358b6f4cc73db5d4b0094919faa.png" alt="图片13"></div><br>  Travis CI会响应返回码，因此警告的出现将报告服务，以将提交标记为包含错误。 <br><br> 现在，让我们仔细看看以下代码行： <br><pre> <code class="bash hljs">git diff --name-only origin/HEAD &gt; .pvs-pr.list</code> </pre> <br> 事实是，Travis CI在分析拉取请求时会自动合并分支： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/443/986/1f4/4439861f46637d41119e83f83e2e440b.png" alt="图片8"></div><br> 这就是为什么我们分析<i>A4</i>而不是<i>B3-&gt; A3的原因</i> 。 由于这种特殊性，我们需要评估与<i>A3</i>的差异， <i>A3</i>是从<i>原点开始</i>分支的头。 <br><br> 还有一个重要的细节-从编译的翻译单元（* .c，* .cc，* .cpp等）缓存头文件的依赖项。 在首次运行期间，分析器会以检查文件列表的方式评估这些依赖关系，然后将其存储在.PVS-Studio目录中。  Travis CI允许缓存存储库，因此我们将数据保存在<i>.PVS-Studio /</i>目录中： <br><br><pre> <code class="xml hljs">cache: directories: - .PVS-Studio/</code> </pre> <br> 该代码必须添加到<i>.travis.yml</i>文件中：此目录存储分析后收集的各种数据。 此数据极大地加快了文件列表分析或增量分析的后续运行。 如果您不这样做，分析器将每次分析所有文件。 <br><br><h2> 好友 </h2><br> 与Travis CI一样， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Buddy</a>使您能够自动从GitHub构建和测试项目。 与Travis CI不同，它是在Web界面中配置的（提供bash支持），因此无需在项目中存储配置文件。 <br><br> 首先，我们需要在管道中添加新的步骤： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/2fd/36e/75e2fd36e9a4420ff74256429ff73e0c.gif" alt="图片1"></div><br> 让我们指定用于构建项目的编译器。 请注意在此步骤中安装的Docker容器。 例如，GCC有一个特殊的容器： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95b/837/7ad/95b8377adbac7e50e55d97c5b318f56c.png" alt="图片6"></div><br> 现在，让我们安装PVS-Studio和必要的实用程序： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/fba/02b/88efba02b5a4c34f55c4344744812cc7.gif" alt="图片2"></div><br> 将以下行添加到编辑器： <br><br><pre> <code class="bash hljs">apt-get update &amp;&amp; apt-get -y install wget gnupg jq wget -q -O - https://files.viva64.com/etc/pubkey.txt | apt-key add - wget -O /etc/apt/sources.list.d/viva64.list \ https://files.viva64.com/etc/viva64.list apt-get update &amp;&amp; apt-get -y install pvs-studio</code> </pre> <br> 让我们转到“运行”选项卡（第一个图标），然后将以下代码添加到适当的编辑器字段中： <br><pre> <code class="bash hljs">pvs-studio-analyzer credentials <span class="hljs-variable"><span class="hljs-variable">$PVS_USERNAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$PVS_KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BUDDY_EXECUTION_PULL_REQUEST_NO</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PULL_REQUEST_ID=<span class="hljs-string"><span class="hljs-string">"pulls/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BUDDY_EXECUTION_PULL_REQUEST_NO</span></span></span><span class="hljs-string">"</span></span> MERGE_BASE=`wget -qO - \ https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${BUDDY_REPO_SLUG}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span> \ | jq -r <span class="hljs-string"><span class="hljs-string">".base.ref"</span></span>` git diff --name-only HEAD origin/<span class="hljs-variable"><span class="hljs-variable">$MERGE_BASE</span></span> &gt; .pvs-pr.list pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck \ -S .pvs-pr.list <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> plog-converter -t errorfile PVS-Studio.log --cerr -w</code> </pre> <br> 如果您阅读有关Travs-CI的部分，则此代码是您熟悉的。 但是这里有一个新的步骤： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/c65/3e3/a7ac653e3e89c4fc2a2b425b1ccefec8.png" alt="图片14"></div><br> 事实是，现在我们不分析合并的结果，而是分析经过检查的拉取请求的分支的HEAD： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/722/646/68c/72264668c4a90b96ccb63f363a46c683.png" alt="图片10"></div><br> 因此，我们处于<i>B3</i>提交中，我们需要与<i>A3</i>取得区别： <br><br><pre> <code class="bash hljs">PULL_REQUEST_ID=<span class="hljs-string"><span class="hljs-string">"pulls/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BUDDY_EXECUTION_PULL_REQUEST_NO</span></span></span><span class="hljs-string">"</span></span> MERGE_BASE=`wget -qO - \ https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${BUDDY_REPO_SLUG}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span> \ | jq -r <span class="hljs-string"><span class="hljs-string">".base.ref"</span></span>` git diff --name-only HEAD origin/<span class="hljs-variable"><span class="hljs-variable">$MERGE_BASE</span></span> &gt; .pvs-pr.list</code> </pre> <br> 要定义<i>A3，请</i>使用GitHub API： <br><br><pre> <code class="bash hljs">https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${USERNAME}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${REPO}</span></span>/pulls/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span></code> </pre> <br> 我们使用了Buddy为我们提供的以下变量： <br><br><ul><li>  <i>$ BUDDY_EXECUTION_PULL_REQEUST_NO-</i>拉取请求的编号； </li><li>  <i>$ BUDDY_REPO_SLUG-</i>用户名和存储库的组合（例如，max / test）。 </li></ul><br> 现在，使用下面的按钮保存更改，并启用拉取请求分析： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74c/5d6/876/74c5d6876c07c0b2e0c10cdabb8b0f78.gif" alt="图片3"></div><br> 与Travis CI不同，我们不必为缓存指定<i>.pvs-studio</i> ，因为Buddy会自动缓存所有文件以供以后运行。 因此，剩下的最后一件事是在Buddy中保存PVS-Studio的登录名和密码。 保存更改后，我们将返回到管道中。 我们需要继续设置变量，并插入PVS-Studio的登录名和密钥： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb1/816/e3e/eb1816e3e4aff72ad55b187ec1ebf0a2.gif" alt="图片4"></div><br> 此后，将从每个新的拉取请求或提交开始检查。 如果提交包含错误，Buddy会在拉取请求页面上指出该错误。 <br><br><h2> 传送带 </h2><br>  AppVeyor设置与Buddy类似，因为所有操作都在Web界面中发生，因此无需在项目存储库中添加* .yml文件。 <br><br> 让我们转到项目查看中的“设置”选项卡： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f11/2fc/576/f112fc576fc1f8bf7552625578093292.png" alt="图片12"></div><br> 向下滚动此页面，并为拉取请求构建启用缓存保存： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/8f3/f34/be88f3f34708075a49bdd13c65f5bc26.png" alt="图片18"></div><br><br> 现在，我们进入“环境”选项卡，在这里我们将为构建和所需的环境变量指定图像： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/26a/80c/45326a80c62211c6b29bd16fad1ef0d1.png" alt="图片19"></div><br> 如果您已经阅读了前面的部分，则已经熟悉了这两个变量<i>-PVS_KEY</i>和<i>PVS_USERNAME</i> 。 如果没有，请让我提醒您，检查PVS-Studio分析仪许可证需要它们。 将来，我们将在Bash脚本中再次与他们会面。 <br><br> 在底部的同一页面上，让我们指定缓存文件夹： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e2/967/dbf/4e2967dbfb796e2d0104d5b6539be65a.png" alt="图片15"></div><br> 如果不这样做，我们将分析整个项目而不是几个文件，但是将接收指定文件的输出。 因此，输入存储库的正确名称很重要。 <br><br> 现在该检查脚本了。 打开“测试”选项卡，然后选择“脚本”： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/dbd/0d6/b5fdbd0d6d448174bc05222fe1965c1c.png" alt="图片20"></div><br> 以下代码应插入此表单中： <br><br><pre> <code class="bash hljs">sudo apt-get update &amp;&amp; sudo apt-get -y install jq wget -q -O - https://files.viva64.com/etc/pubkey.txt \ | sudo apt-key add - sudo wget -O /etc/apt/sources.list.d/viva64.list \ https://files.viva64.com/etc/viva64.list sudo apt-get update &amp;&amp; sudo apt-get -y install pvs-studio pvs-studio-analyzer credentials <span class="hljs-variable"><span class="hljs-variable">$PVS_USERNAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$PVS_KEY</span></span> PWD=$(<span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span> -L) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$APPVEYOR_PULL_REQUEST_NUMBER</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PULL_REQUEST_ID=<span class="hljs-string"><span class="hljs-string">"pulls/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$APPVEYOR_PULL_REQUEST_NUMBER</span></span></span><span class="hljs-string">"</span></span> MERGE_BASE=`wget -qO - \ https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${APPVEYOR_REPO_NAME}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span> \ | jq -r <span class="hljs-string"><span class="hljs-string">".base.ref"</span></span>` git diff --name-only HEAD origin/<span class="hljs-variable"><span class="hljs-variable">$MERGE_BASE</span></span> &gt; .pvs-pr.list pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck \ --dump-files --dump-log pvs-dump.log \ -S .pvs-pr.list <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> plog-converter -t errorfile PVS-Studio.log --cerr -w</code> </pre> <br> 让我们注意代码的以下部分： <br><br><pre> <code class="bash hljs">PWD=$(<span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span> -L) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$APPVEYOR_PULL_REQUEST_NUMBER</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PULL_REQUEST_ID=<span class="hljs-string"><span class="hljs-string">"pulls/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$APPVEYOR_PULL_REQUEST_NUMBER</span></span></span><span class="hljs-string">"</span></span> MERGE_BASE=`wget -qO - \ https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${APPVEYOR_REPO_NAME}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span> \ | jq -r <span class="hljs-string"><span class="hljs-string">".base.ref"</span></span>` git diff --name-only HEAD origin/<span class="hljs-variable"><span class="hljs-variable">$MERGE_BASE</span></span> &gt; .pvs-pr.list pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck \ --dump-files --dump-log pvs-dump.log \ -S .pvs-pr.list <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pvs-studio-analyzer analyze -j8 \ -o PVS-Studio.log \ --disableLicenseExpirationCheck <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br> 这是pwd命令的输出值到变量的非常具体的分配，默认情况下必须存储该值。 起初看起来很奇怪，但是让我解释一下所有内容。 <br><br> 在AppVeyor中设置分析器时，我偶然发现了非常奇怪的分析器行为。 一方面，一切正常，但分析并未开始。 花了很多时间才注意到我们位于/ home / appveyor / projects / testcalc /目录中，而分析器确定我们位于/ opt / appveyor / build-agent /中。 那时我意识到$ PWD变量是欺骗性的。 因此，在运行分析之前，我手动更新了它的值。 <br><br> 进一步的操作顺序与以前相同： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/1be/5b1/a991be5b13dd4e17ccb9cb47e4f48cf2.png" alt="图片16"></div><br> 现在看一下这个片段： <br><br><pre> <code class="bash hljs">PULL_REQUEST_ID=<span class="hljs-string"><span class="hljs-string">"pulls/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$APPVEYOR_PULL_REQUEST_NUMBER</span></span></span><span class="hljs-string">"</span></span> MERGE_BASE=`wget -qO - \ https://api.github.com/repos/<span class="hljs-variable"><span class="hljs-variable">${APPVEYOR_REPO_NAME}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PULL_REQUEST_ID}</span></span> \ | jq -r <span class="hljs-string"><span class="hljs-string">".base.ref"</span></span>`</code> </pre> <br> 在其中，我们得到与已检查的拉取请求相关的分支之间的差异。 为此，我们需要以下环境变量： <br><br><ul><li>  $ APPVEYOR_PULL_REQUEST_NUMBER-拉取请求号； </li><li>  $ APPVEYOR_REPO_NAME-用户名和项目存储库。 </li></ul><br><h2> 结论 </h2><br> 好吧，我们尚未考虑所有可能的持续集成服务，但是它们都有相似的操作细节。 但是对于缓存，每个服务都重新发明了自己的轮子，因此总是不同的。 <br><br> 在某些情况下（例如在Travis-CI中），它需要几行代码-缓存可以完美地工作。 在其他情况下（例如在AppVeyor中），只需在设置中指定目录。 但是有些服务需要创建特殊的密钥，并试图说服系统使您有机会重写缓存的片段。 因此，如果您想在持续集成服务上配置拉取请求分析（上面没有考虑），首先，请确保您不会在缓存方面遇到问题。 <br><br> 谢谢您的关注。 如果无法解决问题，您可以放心地写信给我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持部门</a> 。 我们会给您一个提示和帮助。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470982/">https://habr.com/ru/post/zh-CN470982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470966/index.html">肯·汤普森（Ken Thompson）的Unix密码</a></li>
<li><a href="../zh-CN470974/index.html">分析师掌握的被动DNS</a></li>
<li><a href="../zh-CN470976/index.html">冰之歌（血腥企业）和火焰之歌（DevOps和IaC）</a></li>
<li><a href="../zh-CN470978/index.html">分析师市场研究：他们在哪里学习，使用什么工具以及赚多少钱</a></li>
<li><a href="../zh-CN470980/index.html">软件机器人（RPA）在银行业中解决的任务</a></li>
<li><a href="../zh-CN470984/index.html">使用PVS-Studio在Travis CI，Buddy和AppVeyor中分析提交和请求请求</a></li>
<li><a href="../zh-CN470988/index.html">Slerm DevOps在莫斯科开放注册</a></li>
<li><a href="../zh-CN470990/index.html">在线营销工具包：3个可促进视觉传达的应用程序</a></li>
<li><a href="../zh-CN470994/index.html">从无聊的书呆子的角度继承JavaScript：Constructors Factory</a></li>
<li><a href="../zh-CN470996/index.html">简单的<img>标签如何对企业造成高风险？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>