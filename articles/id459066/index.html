<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèº üì° üë† Database menulis dan membaca balancing üßëüèæ‚Äçü§ù‚Äçüßëüèª üòã üëå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya , saya menjelaskan konsep dan implementasi database yang dibangun berdasarkan fungsi, bukan tabel dan bidang seperti dalam da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Database menulis dan membaca balancing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lsfusion/blog/459066/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/0w/wi/gl/0wwiglioocbaxcpjodrzg5x1ocs.jpeg" alt="gambar"></div><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> saya menjelaskan konsep dan implementasi database yang dibangun berdasarkan fungsi, bukan tabel dan bidang seperti dalam database relasional.  Ini memberi banyak contoh yang menunjukkan keuntungan dari pendekatan ini dibandingkan klasik.  Banyak yang menemukan mereka tidak cukup meyakinkan. <br><br>  Dalam artikel ini saya akan menunjukkan bagaimana konsep ini memungkinkan Anda untuk dengan cepat dan nyaman menyeimbangkan penulisan dan membaca ke database tanpa ada perubahan dalam logika kerja.  Mereka mencoba menerapkan fungsi yang serupa dalam DBMS komersial modern (khususnya, Oracle dan Microsoft SQL Server).  Di akhir artikel, saya akan menunjukkan apa yang terjadi pada mereka, secara halus, tidak terlalu. <br><a name="habracut"></a><br><h3>  Deskripsi </h3><br>  Seperti sebelumnya, untuk pemahaman yang lebih baik, saya akan memulai deskripsi dengan contoh-contoh.  Misalkan kita perlu menerapkan logika yang akan mengembalikan daftar departemen dengan jumlah karyawan di dalamnya dan total gaji mereka. <br><br>  Dalam database fungsional, akan terlihat seperti ini: <br><div class="scrollable-table"><table><tbody><tr><td><code><font color="#a626a4">CLASS</font> Department ''; <br> name '' = <font color="#a626a4">DATA</font> <font color="#a626a4">STRING</font> [ <font color="#986801">100</font> ] (Department); <br> <br> <font color="#a626a4">CLASS</font> Employee ''; <br> department '' = <font color="#a626a4">DATA</font> Department (Employee); <br> salary '' = <font color="#a626a4">DATA</font> <font color="#a626a4">NUMERIC</font> [ <font color="#986801">10</font> , <font color="#986801">2</font> ] (Employee); <br> <br> countEmployees '- ' (Department d) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">IF</font> department(Employee e) = d; <br> salarySum ' ' (Department d) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> salary(Employee e) <font color="#a626a4">IF</font> department(e) = d; <br> <br> SELECT name(Department d), countEmployees(d), salarySum(d); <br></code> </td></tr></tbody></table></div>  Kompleksitas menjalankan kueri ini dalam DBMS apa pun akan setara dengan <i>O (jumlah karyawan)</i> , karena untuk perhitungan ini Anda perlu memindai seluruh tabel karyawan, dan kemudian mengelompokkannya menurut departemen.  Akan ada juga penambahan kecil (kami percaya bahwa ada lebih banyak karyawan daripada departemen) tergantung pada rencana yang dipilih <i>O (jumlah log karyawan)</i> atau <i>O (jumlah departemen)</i> untuk pengelompokan dan sebagainya. <br><br>  Jelas bahwa overhead untuk eksekusi dapat berbeda dalam DBMS yang berbeda, tetapi kompleksitasnya tidak akan berubah dengan cara apa pun. <br><br>  Dalam implementasi yang diusulkan, DBMS fungsional akan membentuk satu subquery, yang akan menghitung nilai yang diperlukan untuk departemen, dan kemudian membuat GABUNG dengan tabel departemen untuk mendapatkan nama.  Namun, untuk setiap fungsi, ketika mendeklarasikan, dimungkinkan untuk menentukan marker MATERIALISASI khusus.  Sistem akan secara otomatis membuat bidang yang sesuai untuk setiap fungsi tersebut.  Ketika nilai fungsi berubah, nilai bidang akan berubah dalam transaksi yang sama.  Saat mengakses fungsi ini, banding akan dilakukan ke bidang terhitung. <br><br>  Secara khusus, jika Anda menempatkan MATERIALISASI untuk fungsi-fungsi yang <i>dihitung Karyawan</i> dan <i>gaji</i> , maka dalam tabel dengan daftar departemen, dua bidang ditambahkan di mana jumlah karyawan dan total gaji mereka akan disimpan.  Dengan perubahan apa pun pada karyawan, gaji atau afiliasi mereka dengan departemen, sistem akan secara otomatis mengubah nilai-nilai bidang ini.  Kueri di atas akan mulai mengakses bidang ini secara langsung dan akan dieksekusi untuk <i>O (jumlah departemen)</i> . <br><br>  Apa batasannya?  Hanya satu hal: fungsi seperti itu harus memiliki jumlah nilai input yang terbatas yang nilainya didefinisikan.  Jika tidak, tidak mungkin untuk membangun tabel yang menyimpan semua nilainya, karena tidak mungkin ada tabel dengan jumlah baris yang tak terbatas. <br><br>  Contoh: <br><div class="scrollable-table"><table><tbody><tr><td> <code>employeesCount '    &gt; N' (Department d, <font color="#a626a4">NUMERIC</font> [ <font color="#986801">10</font> , <font color="#986801">2</font> ] N) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> salary(Employee e) <font color="#a626a4">IF</font> department(e) = d <font color="#a626a4">AND</font> salary(e) &gt; N; <br></code> </td></tr></tbody></table></div>  Fungsi ini didefinisikan untuk jumlah nilai tak terbatas dari angka N (misalnya, nilai negatif apa pun cocok).  Oleh karena itu, tidak dapat dimasukkan MATERIALISASI.  Dengan demikian, ini adalah batasan logis dan bukan teknis (yaitu, bukan karena kami tidak dapat mengimplementasikan ini).  Kalau tidak, tidak ada batasan.  Anda dapat menggunakan pengelompokan, pengurutan, DAN dan ATAU, PARTISI, rekursi, dll. <br><br>  Misalnya, dalam tugas 2.2 artikel sebelumnya, Anda dapat menggunakan MATERIALISASI pada kedua fungsi: <br><div class="scrollable-table"><table><tbody><tr><td> <code>bought <font color="#50a14f">''</font> (Customer c, Product p, <font color="#a626a4">INTEGER</font> y) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> sum(Detail d) <font color="#a626a4">IF</font> <br> customer(order(d)) = c <font color="#a626a4">AND</font> <br> product(d) = p <font color="#a626a4">AND</font> <br> extractYear(date(order(d))) = y <font color="#a626a4">MATERIALIZED</font> ; <br> rating <font color="#50a14f">''</font> (Customer c, Product p, <font color="#a626a4">INTEGER</font> y) = <br> <font color="#a626a4">PARTITION</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">ORDER</font> <font color="#a626a4">DESC</font> bought(c, p, y), p <font color="#a626a4">BY</font> c, y <font color="#a626a4">MATERIALIZED</font> ; <br> SELECT contactName(Customer c), name(Product p) <font color="#a626a4">WHERE</font> rating(c, p, <font color="#986801">1997</font> ) &lt; <font color="#986801">3</font> ; <br></code> </td></tr></tbody></table></div>  Sistem itu sendiri akan membuat satu tabel dengan kunci tipe <i>Pelanggan</i> , <i>Produk</i> dan <i>INTEGER</i> , menambahkan dua bidang ke dalamnya dan akan memperbarui nilai bidang di dalamnya dengan perubahan apa pun.  Setelah panggilan lebih lanjut ke fungsi-fungsi ini, mereka tidak akan dihitung, tetapi nilai-nilai dari bidang yang sesuai akan dibaca. <br><br>  Menggunakan mekanisme ini, Anda bisa, misalnya, menyingkirkan rekursi (CTE) dalam kueri.  Secara khusus, pertimbangkan grup yang membuat pohon menggunakan hubungan anak / orang tua (setiap grup memiliki tautan ke orang tuanya): <br><div class="scrollable-table"><table><tbody><tr><td> <code>parent = <font color="#a626a4">DATA</font> Group (Group); <br></code> </td></tr></tbody></table></div>  Dalam database fungsional, logika rekursi dapat didefinisikan sebagai berikut: <br><div class="scrollable-table"><table><tbody><tr><td> <code>level (Group child, Group parent) = <font color="#a626a4">RECURSION</font> <font color="#986801">1l</font> <font color="#a626a4">IF</font> child <font color="#a626a4">IS</font> Group <font color="#a626a4">AND</font> parent == child <br> <font color="#a626a4">STEP</font> <font color="#986801">2l</font> <font color="#a626a4">IF</font> parent == parent($parent); <br> isParent (Group child, Group parent) = <font color="#a626a4">TRUE</font> <font color="#a626a4">IF</font> level(child, parent) <font color="#a626a4">MATERIALIZED</font> ; <br></code> </td></tr></tbody></table></div>  Karena MATERIALIZED ditempelkan untuk fungsi <i>isParent</i> , sebuah tabel dengan dua kunci (grup) akan dibuat untuk itu, di mana bidang <i>isParent</i> akan benar hanya jika kunci pertama adalah turunan dari yang kedua.  Jumlah entri dalam tabel ini akan sama dengan jumlah grup dikalikan kedalaman rata-rata pohon.  Jika perlu, misalnya, untuk menghitung jumlah keturunan kelompok tertentu, maka Anda dapat mengakses fungsi ini: <br><div class="scrollable-table"><table><tbody><tr><td> <code>childrenCount (Group g) = <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">IF</font> isParent(Group child, g); <br></code> </td></tr></tbody></table></div>  Tidak akan ada CTE dalam kueri SQL.  Sebagai gantinya, akan ada GROUP BY sederhana. <br><br>  Dengan menggunakan mekanisme ini, Anda juga dapat dengan mudah mendenormalkan basis data jika perlu: <br><div class="scrollable-table"><table><tbody><tr><td> <code><font color="#a626a4">CLASS</font> Order <font color="#50a14f">''</font> ; <br> date <font color="#50a14f">''</font> = <font color="#a626a4">DATA</font> <font color="#a626a4">DATE</font> (Order); <br> <br> <font color="#a626a4">CLASS</font> OrderDetail <font color="#50a14f">' '</font> ; <br> order <font color="#50a14f">''</font> = <font color="#a626a4">DATA</font> Order (OrderDetail); <br> date <font color="#50a14f">''</font> (OrderDetail d) = date(order(d)) <font color="#a626a4">MATERIALIZED</font> <font color="#a626a4">INDEXED</font> ; <br></code> </td></tr></tbody></table></div>  Saat Anda memanggil fungsi <i>tanggal</i> untuk baris pesanan, bacaan akan dari tabel dengan baris urutan bidang yang ada indeksnya.  Saat mengubah tanggal pesanan, sistem itu sendiri secara otomatis akan menghitung ulang tanggal yang dinon-denalkan di baris. <br><br><h3>  Manfaatnya </h3><br>  Mengapa seluruh mekanisme ini dibutuhkan?  Dalam DBMS klasik, tanpa menulis ulang kueri, pengembang atau DBA hanya dapat mengubah indeks, menentukan statistik, dan memberi tahu perencana kueri bagaimana cara mengeksekusinya (apalagi, HINT hanya tersedia dalam DBMS komersial).  Tidak peduli seberapa keras mereka berusaha, mereka tidak akan dapat memenuhi permintaan pertama dalam artikel untuk <i>O (jumlah departemen)</i> tanpa mengubah permintaan dan menambah pemicu.  Dalam skema yang diusulkan, pada tahap pengembangan, Anda tidak perlu memikirkan struktur penyimpanan data dan agregasi mana yang akan digunakan.  Semua ini dapat dengan mudah diubah dengan cepat, langsung beroperasi. <br><br>  Dalam praktiknya, ini adalah sebagai berikut.  Beberapa orang mengembangkan logika secara langsung berdasarkan tugas.  Mereka tidak berpengalaman dalam algoritme dan kompleksitasnya, atau dalam rencana pelaksanaan, atau dalam jenis join'ov, atau dalam komponen teknis lainnya.  Orang-orang ini lebih banyak analis bisnis daripada pengembang.  Kemudian, semuanya masuk ke pengujian atau operasi.  Log kueri panjang diaktifkan.  Ketika permintaan panjang terdeteksi, maka orang lain (lebih teknis - pada kenyataannya DBA) memutuskan untuk memasukkan MATERIALISASI pada beberapa fungsi perantara.  Dengan demikian, pencatatan sedikit melambat (karena memperbarui bidang tambahan dalam transaksi diperlukan).  Namun, tidak hanya permintaan ini dipercepat secara signifikan, tetapi juga semua orang lain yang menggunakan fungsi ini.  Pada saat yang sama, membuat keputusan tentang fungsi tertentu mana yang akan terwujud relatif sederhana.  Dua parameter utama: jumlah nilai input yang mungkin (persis berapa banyak rekaman akan berada di tabel yang sesuai), dan seberapa sering digunakan dalam fungsi lain. <br><br><h3>  Analog </h3><br>  DBMS komersial modern memiliki mekanisme yang serupa: PANDANGAN MATERIALISASI dengan FAST REFRESH (Oracle) dan INDEXED VIEW (Microsoft SQL Server).  Dalam PostgreSQL, MATERIALIZED VIEW tidak dapat memperbarui dalam transaksi, tetapi hanya berdasarkan permintaan (dan bahkan dengan batasan yang sangat ketat), jadi kami tidak mempertimbangkannya.  Tetapi mereka memiliki beberapa masalah, yang sangat membatasi penggunaannya. <br><br>  Pertama, Anda dapat mengaktifkan materialisasi hanya jika Anda telah membuat TAMPILAN biasa.  Jika tidak, Anda harus menulis ulang permintaan yang tersisa untuk mengakses tampilan yang baru dibuat untuk menggunakan materialisasi ini.  Atau biarkan semuanya apa adanya, tetapi setidaknya akan tidak efektif jika ada data tertentu yang sudah dihitung, tetapi banyak pertanyaan tidak selalu menggunakannya, tetapi hitung lagi. <br><br>  Kedua, mereka memiliki sejumlah besar pembatasan: <br><br><div class="spoiler">  <b class="spoiler_title">Oracle</b> <div class="spoiler_text"><blockquote><h5>  5.3.8.4 Batasan Umum tentang Refresh Cepat </h5><br>  Permintaan definisi tampilan terwujud dibatasi sebagai berikut: <br><ul><li>  Tampilan terwujud tidak boleh berisi referensi ke ekspresi tidak berulang seperti <code>SYSDATE</code> dan <code>ROWNUM</code> . </li><li>  Tampilan terwujud tidak boleh berisi referensi ke tipe data <code>RAW</code> atau <code>LONG</code> <code>RAW</code> . </li><li>  Itu tidak dapat berisi subquery daftar <code>SELECT</code> . </li><li>  Itu tidak dapat berisi fungsi analitik (misalnya, <code>RANK</code> ) dalam klausa <code>SELECT</code> . </li><li>  Itu tidak bisa referensi tabel di mana indeks <code>XMLIndex</code> didefinisikan. </li><li>  Itu tidak bisa berisi klausa <code>MODEL</code> . </li><li>  Itu tidak bisa mengandung klausa <code>HAVING</code> dengan subquery. </li><li>  Itu tidak dapat berisi kueri bersarang yang memiliki <code>ANY</code> , <code>ALL</code> , atau <code>NOT</code> <code>EXISTS</code> . </li><li>  Itu tidak boleh mengandung klausa <code>[START WITH ‚Ä¶] CONNECT BY</code> . </li><li>  Itu tidak dapat berisi beberapa tabel detail di situs yang berbeda. </li><li>  <code>ON</code> <code>COMMIT</code> tampilan terwujud tidak dapat memiliki tabel detail jarak jauh. </li><li>  Tampilan terwujud yang bersarang harus memiliki gabungan atau agregat. </li><li>  Tampilan gabungan terwujud dan tampilan agregat terwujud dengan klausa <code>GROUP</code> <code>BY</code> tidak dapat memilih dari tabel yang diorganisir indeks. </li></ul><br><h5>  5.3.8.5 Batasan tentang Perbarui Cepat pada Tampilan Terwujud dengan Hanya Bergabung </h5><br>  Menentukan kueri untuk tampilan terwujud hanya dengan penggabungan dan tidak ada agregat yang memiliki pembatasan penyegaran cepat berikut: <br><ul><li>  Semua pembatasan dari " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembatasan Umum tentang Refresh Cepat</a> ". </li><li>  Mereka tidak dapat memiliki klausa atau agregat <code>GROUP</code> <code>BY</code> . </li><li>  Baris pendek semua tabel dalam daftar <code>FROM</code> harus muncul di daftar <code>SELECT</code> dari kueri. </li><li>  Log tampilan terwujud harus ada dengan baris baris untuk semua tabel dasar dalam daftar <code>FROM</code> dari permintaan. </li><li>  Anda tidak dapat membuat tampilan terwujud cepat yang dapat disegarkan dari beberapa tabel dengan gabungan sederhana yang menyertakan kolom tipe objek dalam pernyataan <code>SELECT</code> . </li></ul><br>  Juga, metode penyegaran yang Anda pilih tidak akan efisien secara optimal jika: <br><ul><li>  Permintaan mendefinisikan menggunakan gabungan luar yang berperilaku seperti gabungan dalam.  Jika kueri pendefinisian berisi gabungan seperti itu, pertimbangkan untuk menulis ulang kueri pendefinisian untuk berisi gabungan internal. </li><li>  Daftar <code>SELECT</code> dari tampilan terwujud berisi ekspresi pada kolom dari beberapa tabel. </li></ul><br><h5>  5.3.8.6 Pembatasan pada Refresh Cepat pada Tampilan Terwujud dengan Agregat </h5><br>  Menentukan kueri untuk tampilan terwujud dengan agregat atau gabungan memiliki batasan berikut tentang penyegaran cepat: <br><ul><li>  Semua pembatasan dari " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembatasan Umum tentang Refresh Cepat</a> ". </li></ul><br>  Penyegaran cepat didukung untuk tampilan terwujud <code>ON</code> <code>COMMIT</code> dan <code>ON</code> <code>DEMAND</code> , namun pembatasan berikut berlaku: <br><ul><li>  Semua tabel dalam tampilan terwujud harus memiliki log tampilan terwujud, dan log tampilan terwujud harus: <br><ul><li>  Berisi semua kolom dari tabel yang dirujuk dalam tampilan terwujud. </li><li>  Tentukan dengan <code>ROWID</code> dan <code>INCLUDING</code> <code>VALUES</code> <code>NEW</code> . </li><li>  Tentukan klausa <code>SEQUENCE</code> jika tabel diharapkan memiliki campuran sisipan / beban langsung, penghapusan, dan pembaruan. </li></ul><br></li><li>  Hanya <code>SUM</code> , <code>COUNT</code> , <code>AVG</code> , <code>VARIANCE</code> , <code>VARIANCE</code> , <code>MIN</code> dan <code>MAX</code> yang didukung untuk penyegaran cepat. </li><li>  <code>COUNT(*)</code> harus ditentukan. </li><li>  Fungsi agregat harus terjadi hanya sebagai bagian terluar dari ekspresi.  Yaitu, agregat seperti <code>AVG(AVG(x))</code> atau <code>AVG(x)</code> + <code>AVG(x)</code> tidak diperbolehkan. </li><li>  Untuk setiap agregat seperti <code>AVG(expr)</code> , <code>COUNT(expr)</code> harus ada.  Oracle merekomendasikan agar <code>SUM(expr)</code> dicantumkan. </li><li>  Jika <code>VARIANCE(expr)</code> atau <code>STDDEV(expr</code> ) ditentukan, <code>COUNT(expr)</code> dan <code>SUM(expr)</code> harus ditentukan.  Oracle merekomendasikan agar <code>SUM(expr *expr)</code> ditentukan. </li><li>  Kolom <code>SELECT</code> dalam kueri mendefinisikan tidak bisa menjadi ekspresi kompleks dengan kolom dari beberapa tabel dasar.  Solusi yang mungkin untuk ini adalah dengan menggunakan tampilan terwujud bersarang. </li><li>  Daftar <code>SELECT</code> harus mengandung semua kolom <code>GROUP</code> <code>BY</code> . </li><li>  Tampilan terwujud tidak didasarkan pada satu atau beberapa tabel jarak jauh. </li><li>  Jika Anda menggunakan tipe data <code>CHAR</code> di kolom filter log tampilan terwujud, set karakter situs master dan tampilan terwujud harus sama. </li><li>  Jika tampilan terwujud memiliki salah satu dari berikut ini, maka penyegaran cepat hanya didukung pada sisipan DML konvensional dan beban langsung. <br><ul><li>  Tampilan <code>MIN</code> dengan agregat <code>MIN</code> atau <code>MAX</code> </li><li>  Tampilan <code>SUM(expr)</code> yang memiliki <code>SUM(expr)</code> tetapi tidak ada <code>COUNT(expr)</code> </li><li>  Tampilan <code>COUNT(*)</code> tanpa <code>COUNT(*)</code> </li></ul><br>  Pandangan terwujud semacam itu disebut pandangan terwujud hanya sisipan. </li><li>  Tampilan terwujud dengan <code>MAX</code> atau <code>MIN</code> cepat disegarkan setelah menghapus atau mencampur pernyataan DML jika tidak memiliki klausa <code>WHERE</code> . <br>  Penyegaran cepat maks / mnt setelah penghapusan atau DML campuran tidak memiliki perilaku yang sama dengan kasus khusus penyisipan.  Ini menghapus dan menghitung ulang nilai maks / min untuk grup yang terpengaruh.  Anda harus menyadari dampak kinerjanya. </li><li>  Tampilan terwujud dengan tampilan bernama atau subqueries dalam klausa <code>FROM</code> dapat disegarkan dengan cepat asalkan pandangan dapat sepenuhnya digabungkan.  Untuk informasi tentang pandangan mana yang akan digabung, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oracle Database SQL Language Reference</a> . </li><li>  Jika tidak ada gabungan luar, Anda mungkin memiliki pilihan dan bergabung sewenang-wenang dalam klausa <code>WHERE</code> . </li><li>  Tampilan agregat terwujud dengan sambungan luar cepat disegarkan setelah DML konvensional dan beban langsung, asalkan hanya tabel luar yang telah dimodifikasi.  Juga, batasan unik harus ada pada kolom gabungan dari tabel gabungan dalam.  Jika ada gabungan luar, semua gabungan harus dihubungkan oleh <code>AND</code> dan harus menggunakan operator kesetaraan ( <code>=</code> ). </li><li>  Untuk tampilan terwujud dengan <code>CUBE</code> , <code>ROLLUP</code> , kumpulan pengelompokan, atau gabungannya, batasan berikut ini berlaku: <br><ul><li>  Daftar <code>SELECT</code> harus berisi pengelompokan pengelompokan yang dapat berupa fungsi <code>GROUPING_ID</code> pada semua fungsi <code>GROUP</code> <code>BY</code> expressions atau <code>GROUPING</code> untuk setiap ekspresi <code>GROUP</code> <code>BY</code> .  Misalnya, jika klausa <code>GROUP</code> <code>BY</code> dari tampilan material adalah " <code>GROUP</code> <code>BY</code> <code>CUBE(a, b)</code> ", maka daftar <code>SELECT</code> harus mengandung " <code>GROUPING_ID(a, b)</code> " atau " <code>GROUPING(a)</code> <code>AND</code> <code>GROUPING(b)</code> "agar tampilan terwujud menjadi cepat disegarkan. </li><li>  <code>GROUP</code> <code>BY</code> tidak boleh menghasilkan pengelompokan duplikat.  Misalnya, " <code>GROUP BY a, ROLLUP(a, b)</code> " tidak dapat disegarkan dengan cepat karena menghasilkan pengelompokan duplikat " <code>(a), (a, b), AND (a)</code> ". </li></ul></li></ul><br><h5>  5.3.8.7 Pembatasan pada Refresh Cepat pada Tampilan Terwujud dengan UNION ALL </h5><br>  Pandangan <code>UNION</code> set <code>UNION</code> <code>ALL</code> operator mendukung opsi <code>REFRESH</code> <code>FAST</code> jika kondisi berikut dipenuhi: <br><ul><li>  Permintaan yang menentukan harus memiliki operator <code>UNION</code> <code>ALL</code> di tingkat atas. <br><br>  Operator <code>UNION</code> <code>ALL</code> tidak dapat disematkan di dalam subquery, dengan satu pengecualian: <code>UNION</code> <code>ALL</code> dapat berada di subquery dalam klausa <code>FROM</code> asalkan kueri pendefinisiannya adalah dari bentuk <code>SELECT * FROM</code> (lihat atau subquery dengan <code>UNION</code> <code>ALL</code> ) seperti berikut ini. contoh: <br><pre>  CREATE VIEW view_with_unionall AS
 (PILIH c.rowid crid, c.cust_id, 2 umarker
  DARI pelanggan c MANA c.cust_last_name = 'Smith'
  UNION ALL
  SELECT c.rowid crid, c.cust_id, 3 umarker
  DARI pelanggan c MANA c.cust_last_name = 'Jones');<font></font>
<font></font>
 BUAT TAMPILAN MATERIALISASI unionall_inside_view_mv
 REFRESH CEPAT PADA PERMINTAAN SEBAGAI
 SELECT * FROM view_with_unionall;
</pre>  Perhatikan bahwa view <code>view_with_unionall</code> memenuhi persyaratan untuk refresh cepat. </li><li>  Setiap blok permintaan dalam <code>UNION</code> <code>ALL</code> query harus memenuhi persyaratan tampilan terwujud cepat dengan agregat atau tampilan cepat terwujud dengan bergabung. <br><br>  Log tampilan terwujud yang sesuai harus dibuat pada tabel seperti yang diperlukan untuk jenis tampilan terwujud cepat yang dapat disegarkan. <br>  Perhatikan bahwa Oracle Database juga memungkinkan kasus khusus dari tampilan satu tabel terwujud dengan bergabung hanya jika kolom <code>ROWID</code> telah dimasukkan dalam daftar <code>SELECT</code> dan dalam log tampilan terwujud.  Ini ditunjukkan dalam permintaan mendefinisikan view <code>view_with_unionall</code> . </li><li>  Daftar <code>SELECT</code> dari setiap kueri harus menyertakan penanda <code>UNION</code> <code>ALL</code> , dan kolom <code>UNION</code> <code>ALL</code> harus memiliki nilai numerik atau string konstan yang berbeda di setiap cabang <code>UNION</code> <code>ALL</code> .  Selanjutnya, kolom penanda harus muncul di posisi ordinal yang sama di daftar <code>SELECT</code> dari setiap blok permintaan.  Lihat " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UNION ALL Marker dan Query Rewrite</a> " untuk informasi lebih lanjut mengenai <code>UNION</code> <code>ALL</code> marker. </li><li>  Beberapa fitur seperti gabungan luar, permintaan tampilan teragregasi hanya menyisipkan agregat dan tabel jarak jauh tidak didukung untuk tampilan terwujud dengan <code>UNION</code> <code>ALL</code> .  Perhatikan, bagaimanapun, bahwa pandangan terwujud yang digunakan dalam replikasi, yang tidak mengandung gabungan atau agregat, dapat dengan cepat di-refresh ketika <code>UNION</code> <code>ALL</code> atau tabel jarak jauh digunakan. </li><li>  Parameter inisialisasi kompatibilitas harus diatur ke 9.2.0 atau lebih tinggi untuk membuat tampilan terwujud yang cepat di-refresh dengan <code>UNION</code> <code>ALL</code> . </li></ul></blockquote></div></div><br>  Saya tidak ingin menyinggung penggemar Oracle, tetapi menilai dari daftar keterbatasan mereka, tampaknya mekanisme ini tidak ditulis dalam kasus umum menggunakan beberapa jenis model, tetapi ribuan orang India, di mana setiap orang diizinkan untuk menulis utas mereka sendiri, dan masing-masing dari mereka bisa dan lakukan.  Menggunakan mekanisme ini untuk logika nyata seperti berjalan di ladang ranjau.  Kapan saja, Anda bisa mendapatkan tambang, mengenai salah satu batasan yang tidak jelas.  Bagaimana ini bekerja juga merupakan masalah yang terpisah, tetapi di luar ruang lingkup artikel ini. <br><br><div class="spoiler">  <b class="spoiler_title">Microsoft SQL Server</b> <div class="spoiler_text"><blockquote><h3>  Persyaratan tambahan </h3><br>  Selain opsi SET dan persyaratan fungsi deterministik, persyaratan berikut harus dipenuhi: <br><ul><li>  Pengguna yang menjalankan <code>CREATE INDEX</code> harus menjadi pemilik tampilan. </li><li>  Saat Anda membuat indeks, opsi <code>IGNORE_DUP_KEY</code> harus disetel ke OFF (pengaturan default). </li><li>  Tabel harus direferensikan dengan nama dua bagian, <em>skema</em> <strong>.</strong>  <em>tablename</em> dalam definisi tampilan. </li><li>  Fungsi yang ditentukan pengguna yang dirujuk dalam tampilan harus dibuat dengan menggunakan opsi <code>WITH SCHEMABINDING</code> . </li><li>  Setiap fungsi yang ditentukan pengguna yang dirujuk dalam tampilan harus direferensikan dengan nama dua bagian, <em>&lt;schema&gt;</em> <strong>.</strong>  <em>&lt;fungsi&gt;</em> . </li><li>  Properti akses data dari fungsi yang ditentukan pengguna harus <code>NO SQL</code> , dan properti akses eksternal harus <code>NO</code> . </li><li>  Fungsi runtime bahasa umum (CLR) dapat muncul dalam daftar pilih tampilan, tetapi tidak dapat menjadi bagian dari definisi kunci indeks berkerumun.  Fungsi CLR tidak dapat muncul dalam klausa WHERE tampilan atau klausa ON operasi JOIN dalam tampilan. </li><li>  Fungsi dan metode CLR tipe CLR yang ditentukan pengguna yang digunakan dalam definisi tampilan harus memiliki properti yang ditetapkan seperti yang ditunjukkan pada tabel berikut. <br><div class="scrollable-table"><table><thead><tr><th>  Properti </th><th>  Catatan </th></tr></thead><tbody><tr><td>  DETERMINISTIK = BENAR </td><td>  Harus dinyatakan secara eksplisit sebagai atribut dari metode Microsoft .NET Framework. </td></tr><tr><td>  PRECISE = BENAR </td><td>  Harus dinyatakan secara eksplisit sebagai atribut dari metode .NET Framework. </td></tr><tr><td>  AKSES DATA = TANPA SQL </td><td>  Ditentukan dengan menetapkan atribut DataAccess ke DataAccessKind.None dan atribut SystemDataAccess ke SystemDataAccessKind.None. </td></tr><tr><td>  AKSES EKSTERNAL = TIDAK </td><td>  Properti ini default untuk TIDAK untuk rutinitas CLR. </td></tr><tr><td></td><td></td></tr></tbody></table></div></li><li>  Tampilan harus dibuat dengan menggunakan opsi <code>WITH SCHEMABINDING</code> . </li><li>  Tampilan harus merujuk hanya tabel dasar yang ada dalam database yang sama dengan tampilan.  Tampilan tidak dapat merujuk tampilan lain. </li><li>  Pernyataan SELECT dalam definisi tampilan tidak boleh mengandung elemen Transact-SQL berikut: <br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td> <code>COUNT</code> </td> <td>  Fungsi ROWSET ( <code>OPENDATASOURCE</code> , <code>OPENQUERY</code> , <code>OPENROWSET</code> , DAN <code>OPENXML</code> ) </td><td>  <code>OUTER</code> bergabung ( <code>LEFT</code> , <code>RIGHT</code> , atau <code>FULL</code> ) </td></tr><tr><td>  Tabel turunan (didefinisikan dengan menentukan pernyataan <code>SELECT</code> dalam klausa <code>FROM</code> ) </td><td>  Bergabung sendiri </td><td>  Menentukan kolom dengan menggunakan <code>SELECT *</code> atau <code>SELECT &lt;table_name&gt;.*</code> </td></tr><tr><td> <code>DISTINCT</code> </td> <td>  <code>STDEV</code> , <code>STDEVP</code> , <code>VAR</code> , <code>VARP</code> , atau <code>AVG</code> </td><td>  Ekspresi tabel umum (CTE) </td></tr><tr><td>  <strong>float</strong> <sup>1</sup> , <strong>teks</strong> , <strong>ntext</strong> , <strong>gambar</strong> , <strong>XML</strong> , atau kolom <strong>filestream</strong> </td><td>  Subquery </td><td>  Klausa <code>OVER</code> , yang mencakup fungsi peringkat atau jendela agregat </td></tr><tr><td>  Predikat teks lengkap ( <code>CONTAINS</code> , <code>FREETEXT</code> ) </td><td>  Fungsi <code>SUM</code> yang mereferensikan ekspresi nullable </td><td> <code>ORDER BY</code> </td> </tr><tr><td>  Fungsi agregat yang ditentukan pengguna CLR </td><td> <code>TOP</code> </td> <td>  <code>CUBE</code> , <code>ROLLUP</code> , atau <code>GROUPING SETS</code> </td></tr><tr><td>  <code>MIN</code> , <code>MAX</code> </td><td>  <code>UNION</code> , <code>EXCEPT</code> , atau <code>INTERSECT</code> </td><td> <code>TABLESAMPLE</code> </td> </tr><tr><td>  Variabel tabel </td><td>  <code>OUTER APPLY</code> atau <code>CROSS APPLY</code> </td><td>  <code>PIVOT</code> , <code>UNPIVOT</code> </td></tr><tr><td>  Kumpulan kolom yang jarang </td><td>  Fungsi bernilai inline (TVF) atau multi-pernyataan tabel (MSTVF) </td><td> <code>OFFSET</code> </td> </tr><tr><td> <code>CHECKSUM_AGG</code> </td> <td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><br>  <sup>1</sup> Tampilan yang diindeks dapat berisi kolom <strong>float</strong> ;  Namun, kolom tersebut tidak dapat dimasukkan dalam kunci indeks berkerumun. </li><li>  Jika <code>GROUP BY</code> ada, definisi VIEW harus mengandung <code>COUNT_BIG(*)</code> dan tidak boleh mengandung <code>HAVING</code> .  Batasan <code>GROUP BY</code> ini hanya berlaku untuk definisi tampilan yang diindeks.  Kueri dapat menggunakan tampilan yang diindeks dalam rencana pelaksanaannya bahkan jika itu tidak memenuhi batasan <code>GROUP BY</code> . </li><li>  Jika definisi tampilan berisi klausa <code>GROUP BY</code> , kunci indeks berkerumun unik hanya dapat merujuk kolom yang ditentukan dalam klausa <code>GROUP BY</code> . </li></ul></blockquote></div></div><br>  Di sini Anda dapat melihat bahwa orang India tidak tertarik, karena mereka memutuskan untuk melakukan sesuai dengan skema "kita akan berbuat sedikit, tetapi baik."  Artinya, mereka memiliki lebih banyak ranjau di lapangan, tetapi lokasi mereka lebih transparan.  Hal yang paling menyedihkan adalah batasan ini: <br><blockquote>  Tampilan harus merujuk hanya tabel dasar yang ada dalam database yang sama dengan tampilan.  Tampilan tidak dapat merujuk tampilan lain. </blockquote><br>  Dalam terminologi kami, ini berarti bahwa suatu fungsi tidak dapat mengakses fungsi terwujud lainnya.  Ini memotong seluruh ideologi sejak awal. <br>  Juga, batasan ini (dan selanjutnya dalam teks) sangat mengurangi kasus penggunaan: <br><blockquote>  Pernyataan SELECT dalam definisi tampilan tidak boleh mengandung elemen Transact-SQL berikut: <br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td> <code>COUNT</code> </td> <td>  Fungsi ROWSET ( <code>OPENDATASOURCE</code> , <code>OPENQUERY</code> , <code>OPENROWSET</code> , DAN <code>OPENXML</code> ) </td><td>  <code>OUTER</code> bergabung ( <code>LEFT</code> , <code>RIGHT</code> , atau <code>FULL</code> ) </td></tr><tr><td>  Tabel turunan (didefinisikan dengan menentukan pernyataan <code>SELECT</code> dalam klausa <code>FROM</code> ) </td><td>  Bergabung sendiri </td><td>  Menentukan kolom dengan menggunakan <code>SELECT *</code> atau <code>SELECT &lt;table_name&gt;.*</code> </td></tr><tr><td> <code>DISTINCT</code> </td> <td>  <code>STDEV</code> , <code>STDEVP</code> , <code>VAR</code> , <code>VARP</code> , atau <code>AVG</code> </td><td>  Ekspresi tabel umum (CTE) </td></tr><tr><td>  <strong>float</strong> <sup>1</sup> , <strong>teks</strong> , <strong>ntext</strong> , <strong>gambar</strong> , <strong>XML</strong> , atau kolom <strong>filestream</strong> </td><td>  Subquery </td><td>  Klausa <code>OVER</code> , yang mencakup fungsi peringkat atau jendela agregat </td></tr><tr><td>  Predikat teks lengkap ( <code>CONTAINS</code> , <code>FREETEXT</code> ) </td><td>  Fungsi <code>SUM</code> yang mereferensikan ekspresi nullable </td><td> <code>ORDER BY</code> </td> </tr><tr><td>  Fungsi agregat yang ditentukan pengguna CLR </td><td> <code>TOP</code> </td> <td>  <code>CUBE</code> , <code>ROLLUP</code> , atau <code>GROUPING SETS</code> </td></tr><tr><td>  <code>MIN</code> , <code>MAX</code> </td><td>  <code>UNION</code> , <code>EXCEPT</code> , atau <code>INTERSECT</code> </td><td> <code>TABLESAMPLE</code> </td> </tr><tr><td>  Variabel tabel </td><td>  <code>OUTER APPLY</code> atau <code>CROSS APPLY</code> </td><td>  <code>PIVOT</code> , <code>UNPIVOT</code> </td></tr><tr><td>  Kumpulan kolom yang jarang </td><td>  Fungsi bernilai inline (TVF) atau multi-pernyataan tabel (MSTVF) </td><td> <code>OFFSET</code> </td> </tr><tr><td> <code>CHECKSUM_AGG</code> </td> <td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div></blockquote><br>  GABUNG LUAR, UNION, ORDER OLEH, dan lainnya dilarang.  Mungkin lebih mudah untuk menunjukkan apa yang bisa digunakan daripada apa yang tidak.  Daftarnya mungkin jauh lebih kecil. <br><br>  Untuk meringkas: satu set besar pembatasan di masing-masing (saya perhatikan komersial) DBMS vs tidak ada (dengan pengecualian satu logis daripada teknis) dalam teknologi LGPL.  Namun, perlu dicatat bahwa menerapkan mekanisme ini dalam logika relasional agak lebih rumit daripada fungsional yang dijelaskan. <br><br><h3>  Implementasi </h3><br>  Bagaimana cara kerjanya?  PostgreSQL digunakan sebagai "mesin virtual".  Di dalamnya ada algoritma kompleks yang membangun kueri.  Ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumbernya</a> .  Dan tidak hanya ada satu set heuristik dengan sekelompok seandainya.  Jadi, jika Anda memiliki beberapa bulan untuk belajar, maka Anda dapat mencoba memahami arsitekturnya. <br><br>  Apakah ini bekerja secara efisien?  Cukup efektif.  Sayangnya, membuktikan ini sulit.  Saya hanya bisa mengatakan bahwa jika Anda mempertimbangkan ribuan permintaan yang ada dalam aplikasi besar, maka secara rata-rata permintaan itu lebih efektif daripada pengembang yang baik.  Seorang programmer SQL yang sangat baik dapat menulis permintaan apa pun dengan lebih efisien, tetapi dengan ribuan pertanyaan, ia tidak akan memiliki motivasi atau waktu untuk melakukan ini.  Satu-satunya hal yang dapat saya berikan sebagai bukti keefektifan adalah bahwa berdasarkan platform yang dibangun pada DBMS ini, beberapa proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem ERP</a> bekerja di mana terdapat ribuan fungsi MATERIALISASI yang berbeda, dengan ribuan pengguna dan basis data terrabyte dengan ratusan juta catatan yang berfungsi pada server prosesor ganda biasa.  Namun, siapa pun dapat menguji / menyangkal keefektifannya dengan mengunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">platform</a> dan PostgreSQL, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengaktifkan</a> pencatatan query SQL dan mencoba mengubah logika dan data di sana. <br><br>  Dalam artikel berikut, saya juga akan berbicara tentang bagaimana Anda dapat menggantung pembatasan pada fungsi, bekerja dengan sesi perubahan, dan banyak lagi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459066/">https://habr.com/ru/post/id459066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459046/index.html">Cara menerapkan secara mandiri (Bukti Keberadaan) dalam 2 langkah</a></li>
<li><a href="../id459050/index.html">Modul pengetikan Vuex yang kuat</a></li>
<li><a href="../id459052/index.html">Cara membandingkan: "mobil luar biasa" dan "gubuk jelek", dalam survei pemasaran dan dalam data besar</a></li>
<li><a href="../id459054/index.html">Heatmap of klik - bagaimana perilaku pengguna di situs</a></li>
<li><a href="../id459062/index.html">Intisari materi menarik untuk pengembang seluler # 305 (pada 1 - 7 Juli)</a></li>
<li><a href="../id459068/index.html">Windows Server 2008 R2 - Sang Raja Mati, Hidup Sang Raja</a></li>
<li><a href="../id459070/index.html">Menciptakan Tower Defense in Unity: Towers and Shooting Enemies</a></li>
<li><a href="../id459074/index.html">Petty little joy # 7: three untuk harga satu konsol animasi, algoritma dan debugging</a></li>
<li><a href="../id459078/index.html">CERN beralih ke perangkat lunak sumber terbuka - mengapa?</a></li>
<li><a href="../id459080/index.html">Fitur HttpUrlConnection dari java.net</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>