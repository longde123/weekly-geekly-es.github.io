<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💤 👩🏿‍🎨 👂🏿 Sedikit tentang sederhana. Desain tes. Bagian 1 🎫 👨🏻‍💻 🧥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini, pengujian perangkat lunak adalah salah satu proses utama untuk menciptakan suatu produk. Tidak masalah apa pun metodologi, pendekatan, prose...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sedikit tentang sederhana. Desain tes. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462553/">  Saat ini, pengujian perangkat lunak adalah salah satu proses utama untuk menciptakan suatu produk.  Tidak masalah apa pun metodologi, pendekatan, proses, atau pengujian perangkat lunak yang Anda gunakan dengan cara apa pun selalu ada dalam proses Anda.  Dalam beberapa tahun terakhir (dan mungkin bahkan satu dekade), pengujian perangkat lunak telah berkembang menjadi bidang TI yang terpisah, yang terus berkembang di komunitas global. <br><a name="habracut"></a><br>  <i>Dan ya, hari ini kita akan berbicara tentang penguji manual (fungsional) biasa, tanpa bias dalam otomatisasi, beban kerja, dan jenis pengujian teknis lainnya!</i> <br><br>  Sekarang profesi penguji manual adalah salah satu proses TI paling populer dan salah satu cara termudah untuk masuk ke TI. <br><br>  Mengapa <br><br>  <s>Karena penguji tidak melakukan apa-apa, mereka tidak membutuhkan pengetahuan.</s>  <s>Semua orang bisa menguji!</s> <br><br>  Karena profesi seorang penguji manual pada tahap awal tidak memerlukan pengetahuan dan keterampilan khusus.  "Pengetahuan" utama untuk tester adalah kemampuan untuk "menghancurkan" dan berpikir analitis.  Dan yang paling penting - untuk memiliki pola pikir non-standar, untuk menemukan solusi non-sepele untuk tugas-tugas tersebut.  Monster tertentu yang tahu cara menghancurkan dan menghancurkan :) <br><br>  Hard skill selalu dapat diajarkan, tetapi soft skill, sayangnya, sangat sulit untuk diajarkan, karena itu adalah karakter seseorang, sikapnya terhadap sesuatu, dll.  Biasanya saya memandang manajer yang merekrut spesialis dalam pengujian manual untuk keterampilan keras.  Kenapa kamu melakukan ini ???  (Anda dapat meninggalkan jawaban di komentar) Baiklah, oke, mari kita lanjutkan :) <br><br>  Jika kita mempertimbangkan fitur teknis pengujian yang harus diketahui oleh penguji manual, maka mereka dapat dibagi menjadi 2 bagian utama, <s>mungkin banyak yang akan tidak setuju dengan saya, mereka akan berteriak seperti itu, Anda salah, pengujian sangat sulit</s> - ini adalah persiapan untuk pengujian dan pengujian. <br><br>  Kami akan mempertimbangkan bagian paling menarik dan menarik dari pengujian - persiapan untuk pengujian.  Pada bagian dari proses pengujian inilah tergantung pada seberapa baik dan benar Anda melakukan pengujian itu sendiri, menemukan cacat yang diperlukan dan memastikan <s>wajah puas Pelanggan (atau produk mitra),</s> kualitas tugas setelah implementasi. <br><br>  Banyak dari Anda yang terlibat dalam pengujian, dengan satu atau lain cara, sedang bersiap untuk pengujian.  Perbedaannya biasanya hanya pada seberapa besar Anda memformalkan tahap proses pengujian ini.  Jika Anda melakukan pengujian penelitian, jangan menulis skrip pengujian, mereka <s>memberi Anda sistem dan Anda segera bergegas ke medan perang,</s> bagaimanapun, Anda sedang bersiap untuk pengujian.  Seringkali, pada proyek sederhana, penguji mungkin tidak memperhatikan hal ini, karena tahap analitik dan persiapan untuk pengujian berlangsung pada tingkat yang tidak disadari.  Namun meski begitu, dia masih ada di sana. <br><br>  Dan dalam seri artikel ini kita akan membicarakan hal ini. <br><br>  Di tempat kerja saya, saya sering memberikan pelatihan untuk penguji genggam, dan saya menghadapi situasi yang tampaknya semua orang pernah mendengar tentang teknik desain pengujian, tetapi tidak ada yang menggunakannya dalam pekerjaan. <br><br>  Ini terlihat seperti ini: <br><br><ul><li>  Mengapa kita membutuhkan teknik desain uji? </li><li>  Untuk mengidentifikasi validasi untuk pengujian dengan benar. </li><li>  Apakah Anda menggunakannya dalam pekerjaan Anda? </li><li>  Secara eksplisit tidak, kami sendiri yang menentukan apa yang perlu diperiksa. </li></ul><br>  Mengapa ini terjadi?  Bagaimanapun, teknik desain tes adalah dasar untuk menulis skrip tes.  Ini sama dengan bisa mengendarai mobil, tetapi tidak tahu aturan lalu lintas.  Mengapa penguji tidak menggunakannya dalam pekerjaan mereka? <br><br>  Jawabannya sederhana. <br><br>  Pertama, ketika penguji diajarkan dalam kursus pengujian (atau belajar mandiri pada buku dan artikel), mereka diberitahu bagaimana menerapkan teknik desain tes pada contoh dasar.  Dan masalah utama dari pelatihan tersebut adalah bahwa penguji tidak dapat mentransfer pengetahuan yang diperoleh ke tugas nyata mereka.  Artinya, gunakan teknik desain tes dalam pekerjaan sehari-hari. <br>  Kedua, ketika mengajar teknik desain tes, proses ini sangat formal, yang terlihat seperti tester perlu memformalkan segala sesuatu dalam karyanya.  Dan biasanya tidak ada yang membutuhkan ini untuk siapa pun. <br><br>  Dengan kata sederhana, teknik desain pengujian adalah seperangkat aturan yang memungkinkan Anda untuk menentukan daftar cek untuk pengujian dengan benar.  Dan yang paling penting adalah <s>menggunakan aturan-aturan ini selalu dan di mana-mana :)</s> untuk dapat menerapkan aturan-aturan ini pada tingkat intuitif.  Ini adalah kemampuan untuk "melakukan analisis di kepala" yang membedakan penguji yang baik! <br><br>  Di organisasi saya, serta standar dan praktik yang diterima secara umum, tugas desain pengujian adalah: <br><br><ul><li>  Persyaratan pengujian dan analisis risiko </li><li>  Menentukan Pemeriksaan untuk Pengujian </li><li>  Formalisasi cek dalam bentuk skrip uji </li><li>  Prioritas pemeriksaan </li><li>  Menentukan Pendekatan Pengujian </li></ul><br>  Dalam seri artikel ini, saya akan mencoba untuk memberi tahu Anda tidak hanya tentang teknik desain pengujian, tetapi juga tentang bagaimana menggunakan SEMUA dari mereka (yaitu, semuanya bersama-sama, dan bukan satu atau dua spesifik) dalam praktiknya, termasuk contoh fungsi dari bank kami.  Cara menghasilkan cek untuk pengujian menggunakan teknik desain uji untuk sistem dan proses besar.  Dan yang paling penting, Anda akan mendapatkan jawaban kapan dan di mana tes untuk menerapkan teknik desain tes. <br><br>  Jadi mari kita mulai. <br><br>  Dan kita akan mulai dengan yang paling sederhana, yaitu sekitar 2 teknik desain uji dasar yang semua orang dengar, dan saya yakin mereka menerapkannya, tetapi kemungkinan besar pada tingkat intuitif dalam pekerjaan mereka. <br>  Ini adalah kelas kesetaraan dan nilai batas. <br><br>  Apa itu kelas ekivalensi? <br><br>  <b>Kelas Equivalence</b> adalah sekumpulan input (atau output) data perangkat lunak yang diproses oleh suatu program berdasarkan satu algoritma atau mengarah ke satu hasil. <br><br>  Artinya, ini adalah seperangkat nilai tertentu yang dapat Anda gantikan dalam program dan mendapatkan hasil yang sama.  Hasilnya tidak hanya nilai-nilai spesifik, tindakan program, tetapi juga hanya ruang lingkup.  Oleh karena itu, kelas kesetaraan paling sederhana di mana tes dibagi adalah 2 kelas utama: skenario positif dan negatif. <br><br>  Mereka selalu ada di sana.  Setiap tester membagi cek ke dalam kelas-kelas ini, tetapi tidak setiap tester tahu mengapa dia melakukannya.  Jawabannya adalah kelas kesetaraan. <br><br>  Selanjutnya, setiap kelas ekivalensi dapat dibagi menjadi kelas tambahan, dll.  sampai waktu pemeriksaan tidak akan mengarah ke titik dan hasil tes khusus. <br><br>  <u>Pertimbangkan sebuah contoh:</u> <br><br>  Sistem penilaian menghitung tingkat bunga pinjaman untuk klien berdasarkan usianya, yang dimasukkan dalam bentuk: <br><br><ul><li>  Berumur 18 hingga 25 tahun - 18% </li><li>  Dari 25 hingga 45 tahun - 16% </li><li>  Lebih dari 45 tahun - 20% </li></ul><br>  Kami mendefinisikan 2 kelas utama - ini adalah skenario <b>positif dan negatif</b> . <br><br>  Skenario positif adalah semua nilai yang mengarah pada hasil, skenario negatif adalah nilai yang hasilnya tidak digambarkan sebagai hasil yang diharapkan. <br><br>  Selanjutnya, kami membagi kelas skenario positif menjadi 3 kelas nilai input 18-24, 25-44 dan 45+ <br><br>  Di kelas skenario negatif, kami membentuk nilai berdasarkan kebutuhan untuk memeriksa kegagalan program, jadi kami memiliki 0, 1-17, nilai negatif, input karakter, dll. <br><br>  Hasil dari partisi ini adalah nilai atau rentang nilai di mana kita hanya perlu melakukan satu pemeriksaan dengan nilai apa pun dari rentang data.  Situasi seperti nilai tunggal dalam rentang dapat terjadi.  Ini juga merupakan kelas ekivalensi yang terpisah dan juga memerlukan verifikasi. <br><br>  Total yang kita miliki. <br><br><ul><li>  Pemeriksaan positif: Memasukkan nilai: 19, 30, 48 (nilai dapat berupa rentang kelas apa pun yang diberikan) </li><li>  Pemeriksaan negatif: 0, 3, -1, A, dll. </li></ul><br>  Sangat penting bahwa teknik desain tes tidak diterapkan secara independen dari yang lain!  Sekarang kita melihatnya secara terpisah, tetapi pada akhirnya saya akan mengajarkan Anda bagaimana menggunakannya bersama. <br><br>  Fitur lain dari kelas ekivalensi adalah aplikasi mereka.  Saya membedakan 3 level penerapan teknik desain tes untuk mempersiapkan pengujian. <br><br><ul><li>  <b>Level pertama</b> adalah memeriksa elemen-elemen sistem (misalnya, bidang, kotak centang, tombol, dll.) </li><li>  <b>Tingkat kedua</b> - memeriksa logika sistem saat menggabungkan data dalam elemen-elemen sistem </li><li>  <b>Tingkat ketiga</b> adalah memeriksa proses bisnis sistem dan logika program. </li></ul><br>  Secara visual, tampilannya seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/oj/ma/n2ojma7uwljauyzwqiewqdm_bn8.jpeg" width="600" height="350" alt="gambar"></div><br>  Kelas kesetaraan lebih relevan dengan tingkat 1 dan digunakan untuk menguji elemen program.  Namun secara ideologis, pendekatan ini dapat diterapkan ke tingkat lain. <br><br>  Bagian integral dari pengecekan setiap elemen adalah teknik lain - <b>nilai batas</b> . <br><br>  Nilai batas melengkapi kelas yang setara, dengan demikian sepenuhnya mencakup pemeriksaan elemen perangkat lunak. <br><br>  <b>Nilai batas</b> adalah teknik desain uji yang melengkapi kelas kesetaraan dengan pemeriksaan tambahan pada batas kondisi. <br><br>  Tampaknya semuanya sederhana! <br><br>  Mari kita kembali ke contoh kita sebelumnya. <br><br>  Sistem penilaian menghitung tingkat bunga pinjaman untuk klien berdasarkan usianya, yang dimasukkan dalam bentuk: <br><br><ul><li>  Berumur 18 hingga 25 tahun - 18% </li><li>  Dari 25 hingga 45 tahun - 16% </li><li>  Lebih dari 45 tahun - 20% </li></ul><br>  Apa yang akan menjadi perbatasan di sini? <br><br>  Jika Anda berpikir tentang panjangnya lapangan di halaman Habra, atau tentang liburan di negara-negara hangat, saya ingin membuat Anda marah, ini tidak begitu :) <br><br>  Apa yang menentukan nilai batas perlu sesuatu yang lain.  Yaitu, tentukan nilai mana yang merupakan awal dan akhir untuk kelas kami.  Dan yang paling penting !!!  Penelitian bertahun-tahun di bidang pengujian telah menunjukkan bahwa sebagian besar cacat ditemukan oleh penguji di persimpangan nilai yang mengubah kondisi kerja program. <br><br>  Oleh karena itu, selain nilai batas, kami menggunakan nilai 2 tambahan untuk pengujian, nilai sebelum batas dan nilai setelah batas. <br><br>  Sebagai hasilnya, kami memiliki: <br><br>  Batas-batas kelas kami: 17, 18, 19, 24, 25, 26, 44, 45, 46, dan maks. <br><br>  Juga, kami memiliki kelas negatif, yaitu dari 0 hingga 18. Oleh karena itu, kami juga harus menggunakan nilai batas untuk pengujian: -1, 0, 1, 17,18 <br><br>  Selanjutnya, kami mengecualikan nilai duplikat, dan kami memperoleh nilai untuk memeriksa elemen entri data. <br><br>  -1, 0, 1, 17, 18, 19, 24, 25, 26, 44, 45, 46, maks. <br><br>  Nilai maksimal biasanya ditentukan oleh Pelanggan atau analis.  Jika Anda tidak dapat memberikan, maka Anda harus menjatuhkannya dan tidak mencentangnya, Anda harus memilih nilai yang sesuai dengan akal sehat (jarang ada orang yang akan datang untuk pinjaman pada usia 100). <br><br>  Langkah selanjutnya adalah memaksakan nilai batas pada nilai-nilai kelas ekivalensi, mengecualikan pemeriksaan yang tidak perlu menggunakan aturan "satu nilai cukup untuk memeriksa satu kelas" dan menyelesaikan daftar. <br><br>  Jika sebelumnya kita memiliki 3 nilai untuk 3 kelas, 19, 30 dan 48, maka setelah menentukan nilai batas, kita dapat mengecualikan nilai 30 dan 48 dari daftar dan menggantinya dengan nilai pra-batas, seperti 26 (bukan 30) dan 46 ( bukannya 48). <br><br>  Nilai batas ditentukan tidak hanya untuk nilai numerik, tetapi juga untuk nilai alfabet (misalnya, batas alfabet dan pengodean), tanggal dan waktu, dan nilai semantik.  Batas nilai numerik tergantung pada format input, jika Anda memiliki bilangan bulat, misalnya 2, maka nilai batas akan menjadi 1 dan 3. Jika nilai fraksional, maka batas untuk angka 2 akan menjadi 1,9 (1,99) atau 2,1 ( 2.01), dll. <br><br>  Teknik desain tes Level 1 sederhana dan mudah.  Saya pikir Anda akan mengatakan itu mudah, tetapi mengapa memeriksa setiap elemen dengan seksama.  Dan Anda akan benar! .. <br><br>  Paling sering mereka digunakan dalam pengembangan perangkat lunak baru, karena sekali setelah memeriksa elemen-elemen sistem selama pengembangan, mereka kemudian tidak sering mengalami perubahan pada tingkat operasi elemen.  Anda tidak perlu terus memeriksa setiap nilai elemen di setiap layar program Anda, tetapi perlu diingat bahwa jika logika pemrosesan dalam elemen program berubah, Anda harus memverifikasi ulang bahwa nilai elemen diproses dengan benar. <br><br>  <s>Yah, terlalu mudah ???</s>  <s>Sekarang kita akan mulai menganalisis teknik yang lebih kompleks, bersiap-siaplah.</s> <br><br>  Teknisi desain pengujian Level 2 bertanggung jawab atas variabilitas dan kombinatorik data saat menguji perangkat lunak. <br><br>  Teknik utama dari desain tes adalah <b>pengujian parwise (pengujian berpasangan)</b> .  Inti dari teknik ini adalah meminimalkan variabilitas kombinasi cek yang memadai untuk memastikan perangkat lunak berkualitas tinggi. <br><br>  Dengan kata sederhana, aturan Pareto diterapkan dalam teknik ini, 80% dari kualitas dapat dicapai hanya dalam 20% dari pemeriksaan kombinasi data. <br><br>  Teknik ini dikembangkan melalui lebih dari 15 tahun penelitian IEEE di bidang analisis penyebab cacat dalam sistem.  Hasil penelitian menunjukkan bahwa 98% dari semua cacat terjadi ketika konflik pasangan data input atau satu parameter input. <br><br>  Mengapa pasangan itu dipilih?  <s>Selami rimba statistik matematika dan teori probabilitas untuk menemukan jawabannya</s> . <br><br>  Tentu saja, kami tidak akan pergi ke sana hari ini. Teori probabilitas terlalu rumit untuk spesialis TI sederhana, semuanya sederhana, lakukan permainan dadu reguler dengan 6 wajah. <br><br>  Biarkan hilangnya nilai 2 adalah cacat, maka probabilitas cacat saat melempar kubus adalah 1/6 = 0,167. <br><br>  Jika kita melempar 2 dadu, maka probabilitas jatuh 2 deuces (2 cacat) menjadi lebih rendah dan sama dengan 0,167 * 0,167 = 0,028, untuk 3 sudah 0,005, dll. <br><br>  Ternyata probabilitas cacat terjadi dengan kombinasi 3 atau lebih parameter sangat kecil sehingga dapat dibuang. <br><br>  Ketika kami menguji program, selalu ada sejumlah elemen yang mempengaruhi hasil, misalnya, formulir untuk mengisi data pada aplikasi pinjaman.  Ada sejumlah bidang yang bersama-sama memberikan hasil.  Ini adalah kombinatorik data saat mengisi bidang yang kami periksa menggunakan pengujian berpasangan. <br><br>  Mari kita lihat contoh fungsionalitas desain kartu jarak jauh di bank. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/wf/ez/ihwfezh5gyel9qv_iay8a4kryae.jpeg" width="600" height="350" alt="gambar"></div><br>  Jika kami perhatikan dengan teliti, kami akan melihat lima bidang data dengan Anda: <br><br><ul><li>  Nama lengkap </li><li>  Tanggal lahir </li><li>  Ponsel </li><li>  Seri Nomor Paspor </li><li>  Email </li><li>  serta 2 kotak centang. </li></ul><br>  Tugas kami, menggunakan teknik-teknik tingkat pertama, adalah untuk menentukan daftar kelas kesetaraan yang dapat diambil oleh program. <br><br>  PENTING bahwa ketika menggunakan teknik pengujian berpasangan, kita tidak berbicara tentang hasil tes.  Penting bagi kita untuk memeriksa variabilitas data saat mengisi aplikasi. <br><br>  Jadi <br><br>  <b>Bidang nama lengkap</b> dapat mengambil nilai (kelas): <br><br><ul><li>  Nama dalam bahasa Rusia </li><li>  Nilai tidak valid </li><li>  Nilai kosong </li></ul><br>  Sangat sering penguji tidak mengerti nilai apa yang harus dipilih untuk teknik yang diberikan, jika mereka tidak dibatasi oleh kemampuan untuk masuk.  Sebagai contoh, jika kita memiliki kesempatan untuk memilih jenis kelamin seseorang M atau F, maka semuanya sederhana, ada 2 makna.  Tetapi ketika kita memiliki garis untuk input data, maka dalam pengujian berpasangan kita tidak memeriksa kebenaran mengisi bidang tertentu, karena  pemeriksaan ini harus dilakukan pada tingkat pertama dari desain pengujian (atau gabungkan dengan pengujian berpasangan).  Kami menggunakan kelas ekivalensi untuk bidang ini, karena kami tidak peduli akan seperti apa nilainya. <br><br>  Kita melangkah lebih jauh, <b>tanggal lahir</b> , serta <b>ponsel, seri dan nomor paspor</b> juga dapat memiliki 3 status: <br><br><ul><li>  Nilai yang valid </li><li>  Nilai tidak valid </li><li>  Nilai kosong </li></ul><br>  Karena  <b>Email adalah</b> opsional, bidang ini memiliki 2 nilai: <br><br><ul><li>  Nilai yang valid </li><li>  Nilai tidak valid </li></ul><br>  Kotak centang biasanya hanya memiliki 2 negara - Y atau N. <br><br>  Untuk memeriksa semua kombinasi dari formulir ini, kita perlu melakukan lebih dari 1000 tes, tetapi menggunakan pengujian berpasangan, kita hanya perlu 9 tes! <br>  Magic, saya tidak berpikir :) <br><br>  Langkah selanjutnya adalah menyusun array ortogonal dengan kombinasi data.  Cara termudah untuk menyusun array adalah dengan mengisi data berpasangan, dimulai dengan elemen yang memiliki jumlah nilai tertinggi dan kemudian menurun.  Karena dalam contoh kita ada 4 elemen dengan jumlah nilai yang sama, kita dapat memilih pasangan apa saja. <br><br>  Kami mengambil nama lengkap dan seri nomor paspor.  Tugas kita adalah untuk memilah-milah semua nilai pasangan yang diberikan di antara mereka sendiri: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/oc/yl/biocylsouwnybii-vkdbkbi2zbw.jpeg" width="600" height="350" alt="gambar"></div><br>  Setelah mengulangi lebih dari satu pasangan, kami membuat pasangan lain dan mulai mengulangi nilai-nilai tersebut (misalnya, nomor ponsel) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/kf/ri/rakfri0sevisw9d-abbhvntzpmw.jpeg" width="650" height="400" alt="gambar"></div><br>  Kami menghubungkan elemen berikutnya dan seterusnya sampai seluruh tabel terisi penuh, yang akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wq/ho/j2/wqhoj2c_888apqnsuold0rxcz-k.jpeg" width="650" height="400" alt="gambar"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/4i/ul/yb4iuls3ekn461go28yny01gckk.jpeg" width="650" height="400" alt="gambar"></div><br>  Dengan demikian, kami mendapatkan 9 tes dengan kelas kesetaraan khusus yang dapat kami perkenalkan untuk menguji kerja variabilitas data untuk formulir.  Kami dapat mengisi kelas dengan nilai-nilai spesifik yang kami dapatkan dengan Anda menggunakan tingkat pertama teknik desain tes. <br><br>  Sebagai kesimpulan dari artikel ini, saya akan mengatakan bahwa teknik desain-uji yang ditinjau hanya mencakup sebagian dari pemeriksaan untuk menguji program, yaitu, memeriksa operasi yang benar dari elemen-elemen program dan hasil kombinasi mereka selama operasinya.  Pada bagian kedua, kami akan beralih ke teknik desain uji yang memungkinkan Anda mengerjakan keajaiban pengujian untuk menguji logika program dan prosesnya.  Ini adalah komponen yang sangat penting dari pengujian manual, dan justru inilah yang sering Anda uji di tempat kerja Anda! <br><br>  Semoga bermanfaat! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462553/">https://habr.com/ru/post/id462553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462543/index.html">Java meetup di Raiffeisenbank</a></li>
<li><a href="../id462545/index.html">Pemblokiran telegram, subnet / 16 Hetzner, pengalaman dengan ILV</a></li>
<li><a href="../id462547/index.html">SGX Malvar: bagaimana penjahat mengeksploitasi teknologi baru Intel untuk tujuan yang salah</a></li>
<li><a href="../id462549/index.html">Quorum blockchain: integrasi ke dalam kode Java</a></li>
<li><a href="../id462551/index.html">Pertanyaan pengembang populer tentang pengujian</a></li>
<li><a href="../id462555/index.html">Diskusi: bagaimana jika bekerja tanpa cookie - kami memberi tahu Anda apa alternatifnya</a></li>
<li><a href="../id462563/index.html">Webinar "Bagaimana cara bertahan kepatuhan?" Pendekatan terbaik untuk memenuhi persyaratan peraturan ”</a></li>
<li><a href="../id462565/index.html">Cara menyiapkan data untuk Penambangan Proses SAP oleh Celonis</a></li>
<li><a href="../id462567/index.html">Sodinokibi Ransomware: Studi Lengkap</a></li>
<li><a href="../id462569/index.html">Sistem transportasi bersama kami dan dengan mereka atau "Stasiun bus melawan agregator 2"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>