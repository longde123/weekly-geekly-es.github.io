<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ½â€âš•ï¸ ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿ â›µï¸ Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 2 ğŸ“ª ğŸ›ï¸ ğŸ‘©ğŸ¾â€ğŸ­</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425561/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: â€œPendahuluan: model ancamanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 3: â€œBuffer Overflows: Exploits and Protectionâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 4: â€œPemisahan Hak Istimewaâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 5: "Dari mana sistem keamanan berasal?" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> <br>  Kuliah 6: â€œPeluangâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 7: â€œKotak Pasir Klien Asliâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 8: â€œModel Keamanan Jaringanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 9: "Keamanan Aplikasi Web" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 10: â€œEksekusi simbolikâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  <b>Hadirin:</b> Tampaknya Anda belum membicarakan tentang cara bit digunakan untuk menyimpan integer int. <br><br>  <b>Profesor:</b> Ini pertanyaan yang sangat bagus.  Dan itu benar-benar berkaitan dengan bagaimana Anda mendefinisikan keterbatasan Anda, bukan?  Oleh karena itu, jika Anda melihat contoh sederhana kami dari awal, Anda akan melihat bahwa kami mengasumsikan kehadiran bilangan bulat yang kami pelajari di sekolah dasar.  Pada saat yang sama, kami sepenuhnya memutuskan untuk mengabaikan kesalahan overflow.  Jika Anda peduli tentang kesalahan overflow, dan penting bagi Anda bahwa tidak ada kesalahan seperti itu, maka menggunakan angka integer matematis tidak akan membantu untuk memperbaiki masalah. <br><br><img src="https://habrastorage.org/webt/d4/-r/y0/d4-ry0kha0k0koshx0mwy3zwums.jpeg"><br><br>  Yang Anda butuhkan adalah menyajikan jumlah ini bukan sebagai bilangan bulat, tetapi sebagai vektor bit.  Ketika Anda mewakili mereka sebagai vektor bit, Anda harus menggunakan pandangan yang lebih luas.  Di sini kita kembali ke pemecah SMT.  Aspek teori modular adalah bahwa pemecah itu sendiri dapat diperluas menggunakan teori yang berbeda. <br><br>  Teori yang paling populer adalah teori vektor bit panjang tetap.  Ini berarti bahwa jika Anda menginterpretasikan rumus Anda dalam teori vektor bit panjang tetap, Anda harus terlebih dahulu menetapkan panjang vektor bit.  Artinya, Anda harus secara eksplisit menunjukkan bahwa ini akan digunakan untuk vektor bit yang panjangnya 32 bit, atau 8 bit, atau 64 bit. <br><br><img src="https://habrastorage.org/webt/_n/af/n-/_nafn-pei3kbsz4sxqgnbvi8ggy.jpeg"><br><br>  Ada teori lain yang disebut teori array TOA.  Dan kita akan berbicara sedikit tentangnya.  Berbeda dengan teori bit vektor, yang dirancang untuk hal-hal dengan panjang tetap, teori array dimaksudkan untuk koleksi yang ukurannya tidak diketahui apriori. <br><br>  Sekarang, dalam praktiknya, tidak ada yang menggunakan teori array, misalnya, untuk memodelkan bilangan bulat, karena terlalu mahal.  Membicarakan masalah jauh lebih mahal ketika Anda tidak tahu batasannya.  Oleh karena itu, sebagai suatu peraturan, orang menggunakan teori panjang vektor bit yang tetap dalam diskusi bilangan bulat atau bahkan simbol. <br><br>  Teori lain yang sangat luas adalah teori aritmatika integer nyata, dan khususnya aritmatika integer linier. <br><br><img src="https://habrastorage.org/webt/qb/aa/8t/qbaa8tza3h3ahkhgi5eeo1ba4mw.jpeg"><br><br>  Orang-orang sangat menyukai teori ini karena memberikan argumentasi yang efektif, tetapi tidak terlalu baik ketika Anda berbicara tentang program, karena di sini Anda benar-benar peduli dengan masalah meluap.  Namun teori ini banyak digunakan untuk banyak hal. <br><br>  Teori lain yang sering digunakan adalah teori fungsi yang tidak diinterpretasikan.  Apa arti teori ini? <br><br><img src="https://habrastorage.org/webt/8k/8l/1j/8k8l1jurngs68kehvett1zaaifk.jpeg"><br><br>  Itu artinya Anda memiliki formula tertentu.  Dalam rumus ini, Anda tahu bahwa Anda memanggil suatu fungsi, tetapi Anda tidak tahu apa-apa tentang fungsi ini kecuali kenyataan bahwa jika Anda memasukkan beberapa input ke dalamnya, Anda akan mendapatkan output yang sama. <br><br>  Ternyata ini sangat berguna ketika beralasan tentang hal-hal seperti menggunakan kode titik mengambang, pemodelan, sinus, cosinus, akar kuadrat.  Diskusi terperinci tentang hal-hal seperti itu bisa sangat memakan waktu dan mahal.  Tetapi menggunakan teori ini memungkinkan Anda untuk mengatakan: "Dengar, aku tidak terlalu peduli apa fungsi sinus.  Saya tidak peduli apa tepatnya yang akan dia berikan.  Saya hanya perlu tahu bahwa jika saya memanggil fungsi sinus di berbagai tempat program dengan input spesifik, saya akan mendapatkan data dari jenis yang sama di output.  Ini cukup bagi saya untuk beralasan tentang program saya. â€ <br><br>  Dan oleh karena itu, operasi yang paling umum dalam analisis sistem nyata adalah vektor bit yang bekerja dengan integer, log, dan pointer.  Bahkan, pointer sering diwakili oleh integer, karena kadang-kadang Anda tidak menetapkan bit vektor pada pointer.  Tetapi kadang-kadang Anda harus melakukan ini, dan kemudian Anda tidak bisa lagi menggunakan bilangan bulat. <br><br>  Jadi, kami memeriksa apa yang dapat dilakukan oleh pemecah SMT untuk Anda.  Bagaimana cara kerjanya?  Apa yang ada di dalam diri mereka yang membuat mereka bekerja? <br><br>  Faktanya, pemecah SMT mengandalkan kemampuan kami untuk memecahkan masalah kelayakan rumus SAT Boolean, pada kemampuan untuk mempertimbangkan masalah yang terkait hanya dengan kendala Boolean murni dan variabel Boolean, dan beri tahu kami apakah Anda akan memastikan bahwa program memberikan nilai yang ditetapkan ke variabel Boolean ini atau tidak. . <br><br>  Ini adalah sesuatu yang selama bertahun-tahun mengajar siswa senior, mengatakan bahwa ini sebenarnya adalah tugas NP-lengkap, dan dalam kasus di mana sesuatu turun ke SAT, Anda tidak boleh melakukan ini.  Tetapi ternyata kami memiliki pemecah SAT yang sangat baik. <br><br>  Jadi, saya akan memberi tahu Anda ide dasar tentang cara kerja pemecah SAT.  Itu terletak pada kenyataan bahwa Anda mengambil semua batasan Anda pada variabel Boolean dan memasukkannya ke dalam basis data.  Anda mungkin tidak dapat melihat huruf-huruf kecil di layar dengan jelas, tetapi hanya itu yang bisa saya lakukan. <br><br><img src="https://habrastorage.org/webt/h6/j8/gp/h6j8gpmtgfurf6gsslrlr76i8tw.jpeg"><br><br>  Saya akan berkomentar dan membicarakannya selama aksi, dan kemudian saya akan mempublikasikan slide sehingga Anda dapat melihat apa yang tertulis di sana. <br><br>  Jadi, di sini dalam tugas SAT kita memiliki semua variabel ini mewakili Boolean tidak diketahui, kan?  Kami ingin tahu apakah X mungkin benar pada saat yang sama (X = BENAR), dan Y menjadi benar, dan Z menjadi benar.  Ini adalah tidak diketahui kita.  Selain itu, semua batasan dalam bentuk konjungtif normal.  Ini berarti bahwa semua batasan kami adalah dalam bentuk X1 = true, atau X2 = true, atau X3 = true. <br><br><img src="https://habrastorage.org/webt/jh/b0/-v/jhb0-vkga5zdzwxjtu5zlg6euky.jpeg"><br><br>  Dalam formulir ini, kami memiliki semua keterbatasan kami, yang mengatakan bahwa X1 benar, atau X2 salah, atau X3 salah.  Anda mungkin ingat dari matematika diskrit bahwa rumus Boolean dapat direpresentasikan dalam bentuk ikat normal.  Ini berarti bahwa setiap representasi yang Anda gunakan untuk mewakili formula Boolean, Anda dapat dengan mudah mengonversi ke format ini. <br><br>  Jadi, kami memiliki database dengan banyak batasan dari formulir ini.  Pemecah SAT akan memilih salah satu dari variabel-variabel ini secara acak, misalkan X1.  Dan dia akan berkata: "mengapa tidak mengatur X1 menjadi kenyataan?  Saya tidak tahu apa-apa tentang pembatasan ini, jadi saya bisa berasumsi bahwa ini memang benar. "  Dan kemudian terjadi bahwa Anda akan memiliki batasan yang, misalnya, menyatakan bahwa X1 salah atau X7 benar. <br><br>  Jadi, jika Anda tahu bahwa X1 benar dan Anda tahu bahwa X1 salah atau X7 benar, apa yang Anda ketahui tentang X7? <br><br>  <b>Hadirin:</b> itu pasti benar! <br><br>  <b>Profesor:</b> ya, itu pasti benar.  Karena kalau tidak maka batasan ini tidak akan dipenuhi.  Jadi, sekarang Anda telah mendistribusikan nilai ini dari X1 ke X7.  Misalkan Anda sekarang memilih variabel acak lain, seperti X5. <br><br><img src="https://habrastorage.org/webt/c8/xt/rp/c8xtrpz4r9k438asupto0lwc5ni.jpeg"><br><br>  Sekarang anggaplah Anda memiliki batasan yang mengatakan: X7 salah, atau X6 benar, atau X5 salah.  Jadi, saya punya X5 = benar dan X7 = benar.  Ini berarti bahwa X6 sekarang juga harus benar.  Karena kalau tidak maka pembatasan ini akan dilanggar.  Jadi, sistem menyimpulkan bahwa X6 harus benar, dan melanjutkan proses, melakukan pemeriksaan yang tersedia dan melihat semua penawaran yang tersedia.  Sistem memeriksa apakah ada hal-hal lain yang tersirat oleh cek yang dimilikinya.  Dan dia mengikuti makna ini sampai satu dari dua hal terjadi. <br><br>  Yang pertama adalah Anda terus mengikuti konsekuensi dan mencoba hal-hal acak, dan akhirnya Anda menetapkan nilai untuk setiap variabel tanpa pernah menemui kontradiksi.  Jadi Anda melakukan segalanya dengan benar. <br><br>  Yang kedua - Anda dihadapkan dengan kontradiksi, dan kemudian Anda kembali ke kondisi yang membuat X4 benar, tidak termasuk kondisi yang membuat X4 salah.  Tetapi ada satu aturan aljabar Boolean yang harus diketahui semua orang: variabel tidak bisa benar dan salah pada saat yang sama. <br><br><img src="https://habrastorage.org/webt/yf/bk/tg/yfbktgumqupvocdxul_cx9wlt20.jpeg"><br><br>  Dan dikatakan bahwa Anda dihadapkan dengan kontradiksi, Anda jelas melakukan sesuatu yang salah dalam salah satu tugas acak yang Anda coba selesaikan ini. <br><br>  Mari kita menganalisis kontradiksi ini dan melihat tugas apa yang menyebabkan kontradiksi ini.  Berdasarkan penugasan yang menyebabkan kontradiksi ini, mari kita membuat klausul konflik baru yang merangkum kontradiksi ini. <br><br>  Apa yang terjadi bahwa X1 salah, dan X5 salah, dan X9 juga salah?  Pada dasarnya, ini didasarkan pada apa yang saya pelajari dari tugas acak ini, di mana saya menemukan bahwa salah satu dari hal-hal ini harus benar, bahwa tidak mungkin X1 benar dan X5 benar, dan X9 adalah salah, ini tidak mungkin. <br><br>  Saya tahu ini tidak dapat terjadi, karena ketika saya mencoba melakukannya, semuanya â€œmeledakâ€, saya mengakhiri program dengan kontradiksi. <br><br>  Jadi, pemecah SAT mencoba menyelesaikan tugas acak, memeriksa bagaimana hasilnya.  Ketika dia menghadapi kontradiksi, dia menganalisis serangkaian konsekuensi yang mengarah pada kontradiksi ini, dan akhirnya membentuk batasan baru, yang memastikan bahwa pemecah tidak pernah lagi menghadapi kontradiksi khusus ini, masalah khusus ini. <br>  Dengan demikian, kita dapat membayangkan pemecah SAT sebagai "kotak hitam" yang memberikan batasan Boolean dan dapat mengetahui apakah itu memuaskan atau tidak.  Solver SMT dibangun di atas solver SAT terbaik.  Mereka dapat menggunakan kekuatan pemecah SAT untuk menyelesaikan masalah NP-lengkap dengan alasan berorientasi subjek tentang teori yang didukung. <br><br>  Untuk mendapatkan ide tentang bagaimana ini bekerja, anggaplah Anda memiliki formula seperti itu. <br><br><img src="https://habrastorage.org/webt/fi/hc/za/fihczar0nfdk1h7j_jgkzixzpli.jpeg"><br><br>  Apakah bisa dilakukan?  Bisakah kita menemukan tes yang memuaskan untuknya?  Pemecah SMT dapat memisahkan bagian dari rumus ini, yang memerlukan penalaran dalam teori bilangan bulat.  Kami menggunakan struktur Boolean untuk memisahkan formula.  Jadi kami memiliki rumus F1, F2, F3 dan F4. <br><br><img src="https://habrastorage.org/webt/wi/yr/sy/wiyrsy_aikhwm3soegrypiu2vfk.jpeg"><br><br>  Sekarang ini adalah tugas Boolean yang murni logis - dapatkah saya menemukan tugas yang memuaskan untuk ini?  Pemecah SAT dapat mengatakan: "Ya, saya dapat menemukan sesuatu yang memuaskan tugas ini dengan melakukan F1 = benar, F2 = benar dan F3 = benar."  Ini memenuhi spesifikasi formula Boolean. <br><br><img src="https://habrastorage.org/webt/s5/ff/pc/s5ffpcpzbfo2cktluc4jrnnz9pk.jpeg">  \ <br><br>  Jadi, sekarang kita memiliki pertanyaan yang dapat kita tanyakan kepada pemecah untuk area tertentu, dalam hal ini hanya pemecah aritmatika linier.  Jadi kita bisa pergi ke pemecah teori Theory dan mengatakan: "Pemecah SAT mengklaim bahwa ini adalah tugas yang masuk akal, dan bahwa jika saya dapat membuat tugas ini berhasil, maka rumus saya akan terpenuhi." <br><br>  Saya dapat mengatakan bahwa F1 adalah X&gt; 5, F2 adalah Y &lt;5, dan F3 adalah Y&gt; X. Jadi saya dapat bertanya kepada pemecah SAT apakah mungkin untuk mendapatkan X dan Y sehingga X adalah&gt; 5, Y adalah &lt; 5, dan dalam hal ini Y akan menjadi&gt; X?  Sekarang ini adalah pertanyaan aritmatika linier murni, tidak ada logika Boolean. <br><br>  Dan apa jawaban untuk pertanyaan ini?  Tidak.  Tidak mungkin untuk memenuhi kondisi ini pada saat yang bersamaan. <br>  Jadi, ada metode tradisional untuk memecahkan masalah linier.  Anda dapat menggunakan metode simpleks, misalnya, untuk menyelesaikan sistem ketidaksetaraan linear.  Ada banyak metode yang dapat digunakan untuk menyelesaikan sistem ketidaksetaraan linear. <br><br><img src="https://habrastorage.org/webt/4g/q3/uy/4gq3uyrn1tqglftbpfldn0-vofe.jpeg"><br><br>  Jadi, pemecah SAT mengirim pertanyaan teoretis ke pemecah Teori.  Intinya adalah bahwa pemecah teori tahu semua tentang masalah ini dan dapat memberikan jawaban yang akurat untuk pertanyaan apakah kondisi ini akan berhasil. <br><br>  Dalam kasus ini, pemecah teori memproses permintaan, menemukan bahwa penetapan kondisi ini tidak dapat berfungsi, kembali ke pemecah SAT dan berkata: "hal-hal yang Anda lakukan tidak akan berhasil"! <br><br>  Tetapi dia tidak hanya mengatakan ya atau tidak, tetapi menjelaskan mengapa sesuatu tidak akan berhasil.  Dari kenyataan bahwa rumus-rumus ini tidak berfungsi, pemecah Teori menyimpulkan bahwa F1 dan F2 dan F3 tidak dapat ada secara bersamaan, dan memberi tahu pemecah SAT bahwa ketiga rumus ini saling eksklusif. <br><br>  Jadi sekarang kita memiliki beberapa informasi yang saya dapat kembali ke pemecah SAT dan bertanya kepadanya: "Hei, Anda bisa memberi saya solusi yang memuaskan tidak hanya kendala yang kami miliki di awal, tetapi juga kendala baru yang ditemukan oleh Teori pemecah "? <br><br>  Apakah ada tujuan lain yang sekarang memenuhi kedua keterbatasan ini? <br><br><img src="https://habrastorage.org/webt/3v/zx/ls/3vzxlsvv19wp3h-ifqye1fushps.jpeg"><br><br>  Jadi, kita membuang batasan awal X&gt; 5, Y &lt;5, Y&gt; X, ini tidak mengganggu kita lagi. <br><br><img src="https://habrastorage.org/webt/jc/es/mi/jcesmivnxfc8ur3hzivvmrt1ywc.jpeg"><br><br>  Kami memiliki batasan baru yang dapat kami atur ke pemecah Teori kami - X&gt; 5, Y &lt;5, Y&gt; 2. Kita dapat membuat Y sama dengan 3, dan X sama dengan 6, dan kemudian itu akan bekerja.  Sekarang Anda memiliki tugas yang memenuhi formula dalam teori dan memenuhi struktur Boolean dari tujuan ini.  Dan dengan itu, sistem dapat kembali dan berkata: "Ya, ini adalah tugas yang memenuhi semua keterbatasan Anda."  Ini adalah interaksi antara pemecah Teori dan pemecah SAT.  Pada kenyataannya, ini berarti dapat berbicara tentang formula Boolean yang sangat, sangat besar dan sangat kompleks.  Inilah yang memungkinkan eksekusi simbolis. <br><br>  Sekarang kita akan mempertimbangkan pertanyaan berikutnya - bagaimana transisi dari program ke pembatasan yang dapat kami berikan untuk pemecah SMT dilakukan. <br><br>  <b>Hadirin:</b> Apakah membangun NP SM solver selesai atau tidak? <br><br>  <b>Profesor:</b> Pemecah SMT pada dasarnya adalah masalah NP-kanonik lengkap.  Tetapi kebanyakan pemecah masalah hari ini termasuk dukungan untuk teori-teori tertentu yang benar-benar tidak dapat dipecahkan. <br><br>  <b>Pemirsa:</b> bagaimana Anda mendekati masalah ini di sistem Anda? <br><br>  <b>Profesor:</b> baik, pada akhirnya, Anda akan mendapatkan batasan yang dibuat dari program ini.  Anda akan memberikannya ke pemecah SMT.  Dan fakta bahwa ini adalah tugas-tugas NP-lengkap atau fakta bahwa mereka tidak memuaskan berarti bahwa jika Anda beruntung Anda akan menerima jawaban dalam hitungan detik.  Tetapi jika Anda tidak beruntung, maka mungkin butuh waktu lebih lama daripada penciptaan alam semesta. <br><br><img src="https://habrastorage.org/webt/ji/zl/eb/jizlebbqvbb7ni0w0snmlsx_dqm.jpeg"><br><br>  <b>Audiens:</b> apakah itu terjadi bahwa tugas-tugas sistem linear tidak lulus SAT? <br><br>  <b>Profesor:</b> ya, itu benar-benar terjadi.  Namun, alat-alat teknik yang ada membuatnya kurang umum.  Kami tidak memecahkan masalah acak SAT, kami tidak memecahkan masalah vektor bit sepenuhnya acak. <br><br>  Kami memecahkan masalah yang memiliki struktur tertentu sehingga seseorang dapat melihatnya dan memiliki keyakinan bahwa itu akan berhasil.  Kami mencoba membuat beberapa argumen di kepalanya untuk memahami mengapa ini berhasil.  Dan pemecah SAT menggunakan struktur ini.  Masalah Anda mungkin memiliki sejuta variabel Boolean, tetapi dalam kenyataannya sebagian besar variabel ini sangat bergantung pada nilai masing-masing.  Dengan demikian, jumlah derajat kebebasan dalam masalah sebenarnya jauh lebih sedikit daripada yang disarankan jutaan variabel. <br><br>  <b>Hadirin:</b> Anda mengatakan bahwa ini bukan pertanyaan ujian, tetapi kehidupan nyata.  Setelah seseorang membangun sistem ini, itu harus bekerja dan masuk akal.  Jadi ini mungkin tidak akan menjadi salah satu teori yang tidak perlu. <br><br>  <b>Profesor:</b> itu dia.  Karena itu, dalam praktiknya, saat Anda menggunakan alat ini, yang selalu Anda lakukan adalah mengatur batas waktu.  Secara umum, semuanya terjadi karena eksponensial tidak berarti Anda tidak dapat melakukan ini.  Eksponensialitas, yaitu, ketika satu fungsi dibatasi oleh fungsi lain, hanya berarti bahwa ada dinding bata di depannya yang dapat berfungsi, dan mereka akan bekerja dengan sangat cepat.  Eksponensialitas bekerja di kedua arah. <br><br><img src="https://habrastorage.org/webt/tm/yu/3j/tmyu3janxuwwu_ghngg9srbpg-0.jpeg"><br><br>  Ketika Anda menjauh dari tembok ini, banyak hal tumbuh sangat cepat, tetapi ketika Anda mendekati masalah yang lebih kecil atau lebih sederhana, masalah ini juga berakselerasi dengan sangat, sangat cepat.  Ini berarti bahwa banyak masalah berakhir dengan sangat cepat.  Dan kemudian masalah timeout terjadi.  Intinya adalah untuk merancang hal-hal sehingga di antara masalah yang cepat berakhir adalah mereka yang membawa manfaat praktis.  Ini adalah masalah yang mengarahkan Anda ke kerentanan keamanan sistem Anda, kesalahan, ke jalur yang mungkin belum pernah Anda jelajahi sebelumnya, atau untuk masukan yang akan melanggar jalur Anda jika Anda tidak memeriksanya terlebih dahulu. <br><br>  Jadi, kita tahu bagaimana beralih dari formula, dari serangkaian batasan ke jawaban yang mengatakan: "Ya, formula ini memiliki solusi, dan ini dia, ini solusi."  Atau dia akan berkata: "formula ini tidak memuaskan, karena tidak ada input yang memuaskan tugas Anda."  Jadi bagaimana kita mendapatkan formula dari program ini? <br><br>  Saat Anda melakukan eksekusi simbolis, Anda pergi ke cabang dan tidak tahu ke mana arahnya.  Ada dua opsi untuk apa yang harus dilakukan dalam kasus ini.    â€”  ,      ,             ,        . <br><br>  ,   ,         .   ,          SMT-.         .   ,               . <br><br>      : Â«   ,          ,     ,     ,      Â». <br><br>      ,     ,      .         .  ,     . <br><br>   ,   . ,     ,   . ,     â€“       ,        .        ?    ,     . <br><br><img src="https://habrastorage.org/webt/ty/jk/r0/tyjkr0wfkidwul4c72ksygznaky.jpeg"><br><br>     ,     ,    t=0    false. <br><br><img src="https://habrastorage.org/webt/9b/vk/fq/9bvkfq3d5pjdx1hvldxuu6sidvq.jpeg"><br><br>   ,    ,       ?       : ,      ,    . <br><br>  ,  ,      ,    ,   ,            ,     . <br><br>   ,     ,    t = 0,    x, y  0.       ,       . ,         ,  X ,  Y. <br><br>  ,      X &gt; Y. <br><br><img src="https://habrastorage.org/webt/px/us/2m/pxus2m_qn9igfcjvipllca7-juk.jpeg"><br><br> 55:00  <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> MIT Â«  Â».  10: Â« Â»,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yRVZPvHYHzw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Versi lengkap dari kursus ini tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps hingga Desember secara gratis</b> ketika membayar untuk jangka waktu enam bulan, Anda dapat memesan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 kali lebih murah? </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya kami yang memiliki </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV dari $ 249</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Belanda dan Amerika Serikat! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca tentang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara Membangun Infrastruktur Bldg. </font><font style="vertical-align: inherit;">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425561/">https://habr.com/ru/post/id425561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425551/index.html">Siapa yang harus menerima uang dari penjualan karya seni yang dibuat oleh AI?</a></li>
<li><a href="../id425553/index.html">Apa yang Dapat Diceritakan oleh Pangeran Monte Cristo Tentang Keamanan Siber</a></li>
<li><a href="../id425555/index.html">Charles Nutter pada bahasa dinamis di JVM di jug.msk.ru</a></li>
<li><a href="../id425557/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 1</a></li>
<li><a href="../id425559/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 3</a></li>
<li><a href="../id425563/index.html">California melarang penjualan perangkat IoT dengan atau tanpa kata sandi sederhana</a></li>
<li><a href="../id425565/index.html">Matematika fixed-point cepat untuk aplikasi keuangan di Jawa</a></li>
<li><a href="../id425569/index.html">Pengujian Fungsional PCB</a></li>
<li><a href="../id425571/index.html">Mengamankan server web di Linux</a></li>
<li><a href="../id425575/index.html">Peradangan saraf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>