<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèæ üëâ üíáüèΩ Ist es m√∂glich, realistische Bilder ohne Gleitkommazahlen zu rendern? üé≥ üßôüèø ü•ó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 

 "Was passiert, wenn wir die Gleitkommazahlen durch rationale Zahlen ersetzen und versuchen, das Bild zu rendern?" 

 Ich stellte mir die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ist es m√∂glich, realistische Bilder ohne Gleitkommazahlen zu rendern?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448558/"><h2>  Einf√ºhrung </h2><br><hr><br>  "Was passiert, wenn wir die Gleitkommazahlen durch rationale Zahlen ersetzen und versuchen, das Bild zu rendern?" <br><br>  Ich stellte mir diese Frage, nachdem ich √ºber den Tweet eines Forschers und Computergrafiklehrers Morgan McGwire nachgedacht hatte.  Er sprach dar√ºber, wie sehr Informatikstudenten √ºberrascht sind, als sie zum ersten Mal herausfinden, dass Kompromisse eingegangen werden m√ºssen, um die bekannten Gleitkommazahlen in modernen Computern zu speichern.  Und diese Kompromisse erschweren einfache Aufgaben, zum Beispiel die √úberpr√ºfung, ob ein Punkt zu einem Dreieck geh√∂rt.  Das Problem ist nat√ºrlich, dass die √úberpr√ºfung, ob vier Punkte in derselben Ebene liegen (Koplanarit√§t), unter Verwendung der Determinante oder einer Art Vektormultiplikation (aber tats√§chlich ist dies dasselbe) niemals einen Wert ergibt, der genau gleich Null ist, was erforderlich ist Dies sind mathematische Methoden.  Selbst wenn die tats√§chlichen Berechnungen, auf derselben Ebene zu sein, genau w√§ren, w√ºrden dieselben Kompromisse mit einer Genauigkeit von fast 1,0 die Antwort geben, dass die vier Punkte selbst nicht koplanar sind. <br><br>  Dies brachte mich auf die Idee - wenn wir annehmen, dass alle eingehenden Renderer-Daten (Scheitelpunktkoordinaten, 3D-Transformationen usw.) als rationale Zahlen festgelegt wurden, w√ºrden sie alle Operationen erstellen, von der Erzeugung eines Strahls √ºber die Beschleunigungsstruktur bis zur Kreuzung Strahlen mit Dreiecken sind nur rationale Zahlen?  Wenn das der Fall w√§re, k√∂nnten wir genau einen Koplanarit√§tstest durchf√ºhren!  Sie fragen sich vielleicht, warum eine in rationalen Zahlen ausgedr√ºckte 3D-Szene nur zu rationalen Zahlen f√ºhren sollte ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/c79/14b/a99c7914bc94ae608f4215c34cbe4f66.jpg"></div><br>  <i>Eine einfache Szene, deren Pfadverfolgung durch rationale Arithmetik durchgef√ºhrt wird.</i>  <i>Es wird ein Gleitkommazahlensystem verwendet, keine Gleitkommazahl.</i> <br><a name="habracut"></a><br>  Erstens ist eine rationale Zahl eine Zahl, die als Verh√§ltnis zweier ganzer Zahlen ausgedr√ºckt werden kann, beispielsweise 1/2 oder 355/113.  Zweitens basieren ‚Äûnormale Rendering-Operationen‚Äú, wie z. B. Bounding-Box-Tests, √úberpr√ºfen des Schnittpunkts eines Strahls mit einem Dreieck, Reflexion eines Strahls usw., auf Vektor- und Skalarprodukten sowie auf Skalarunterteilungen (einschlie√ülich) Koordinatentransformation und Matrixinversion, Quaternionen usw.), die wiederum auf vier Grundoperationen basieren: Addition, Subtraktion, Multiplikation und Division.  Beim Addieren, Subtrahieren, Multiplizieren und Dividieren rationaler Zahlen werden auch rationale Zahlen erhalten.  Der Mathematiker w√ºrde sagen, dass viele rationale Zahlen ein Feld bilden, das unter vier grundlegenden arithmetischen Operationen geschlossen wird.  F√ºr uns bedeutet dies, dass wir, wenn wir uns ausschlie√ülich an rationale Zahlen halten, tats√§chlich von den Eingabedaten der 3D-Szene zu einem vollst√§ndig gerenderten Bild √ºbergehen k√∂nnen, ohne die Welt der rationalen Zahlen zu verlassen. <br><br>  Ausnahmen von der Regel ‚ÄûAktionen auf rationale Zahlen ergeben rationale Zahlen‚Äú sind Quadratwurzeln und trigonometrische / transzendentale Funktionen.  Was letzteres betrifft, sage ich immer, wenn Sie trigonometrische Berechnungen in den geometrischen Innenr√§umen Ihres Renderers durchf√ºhren mussten, dann machen Sie h√∂chstwahrscheinlich etwas falsch (und ich habe gezeigt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie man die meisten Standardf√§lle behebt</a> ) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> auf Habr√©].  Bei Quadratwurzeln ist es mit Ausnahme von konischen Abschnitten (Kugeln, Zylinder usw.) und der Durchf√ºhrung von Schattierungen / DFOS / F√§rbungen nicht erforderlich, die Strahlen und die Normalen zu den Oberfl√§chen so oft wie gew√∂hnlich zu normalisieren.  Es muss sicherlich nicht getan werden, um einen Strahl, seinen Durchgang, Schnittpunkt, Reflexionen usw. zu erzeugen.  Leider sehe ich sehr oft, dass Programmierer Werte aus keinem anderen Grund normalisieren als "Nun, ich wei√ü nicht, ich mache es, damit ich auf Nummer sicher gehen kann."  In der Praxis ist es in dem Teil des Renderings, in dem die Geometrie verfolgt wird, sehr selten erforderlich, die Werte zu normalisieren. Daher hatte ich die Hoffnung, dass es m√∂glich ist, die gesamte Szene zu verfolgen, ohne die Welt der rationalen Zahlen zu verlassen - dies w√ºrde ich als "rationales Rendering" bezeichnen. <br><br>  Um dies in die Praxis umzusetzen, muss ich ein Zahlensystem erstellen, das auf rationalen Zahlen basiert, die ein Computer verwenden k√∂nnte.  Dar√ºber hinaus k√∂nnte ich die √ºblichen Pfadverfolgungsalgorithmen implementieren, Bilder ohne Genauigkeitsverlust berechnen, Koplanarit√§tspr√ºfungen mit genauen Antworten durchf√ºhren und alle Sch√ºler, die Computergrafiken studieren, gl√ºcklich machen. <br><br>  Dieser Artikel handelt von zwei N√§chten der Erforschung des Realismus einer solchen Idee.  Ich werde √ºber die vielen Aspekte sprechen, die ich gelernt habe, √ºber das, was ich mir ausgedacht habe, und √ºber einige √úberraschungen, die ich dabei entdeckt habe.  Der Artikel ist in mehr oder weniger chronologischer Reihenfolge meiner Arbeit verfasst.  Au√üerdem wurde es in meinem ungew√∂hnlich informellen und sehr unwissenschaftlichen Stil geschrieben (auf den ich stolz bin).  Das oben gezeigte Bild ist eine Art Spoiler, aber lesen Sie den Artikel bis zum Ende, weil ich √ºber das Gute und das Schlechte sprechen werde. <br><br><h2>  Vorbereitung </h2><br><hr><br>  Das erste, was ich tat, war, in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shadertoy einen minimal</a> begrenzten Tracer f√ºr eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">extrem einfache</a> Szene zu implementieren, die aus einer Ebene, einer Kugel, einem rechteckigen Parallelepiped und einem Dreieck besteht - den Bausteinen realer Renderer.  Dann habe ich den Code in eine C ++ - Datei kopiert und nach einigen geringf√ºgigen √Ñnderungen mit meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">piLibs-</a> Framework kompiliert.  Zum Vergleich habe ich ein verfolgtes Bild mit regul√§ren Zahlen gem√§√ü dem IEEE754-Standard mit Gleitkomma auf die CPU gerendert.  Ich habe auch die gesamte Strahlennormalisierung aus dem Trace-Code entfernt, da, wie oben erw√§hnt, keine davon tats√§chlich ben√∂tigt wird.  Ich m√∂chte Sie daran erinnern, dass f√ºr die Normalisierung eine Quadratwurzel erforderlich ist und rationale Zahlen bei ihrer Verwendung nicht erhalten bleiben (die Quadratwurzel einer rationalen Zahl ist keine rationale Zahl).  Wenig sp√§ter werden wir sehen, dass das Anwenden von Quadratwurzeln nat√ºrlich immer noch m√∂glich ist. Ich wollte nur den Code so mathematisch sauber wie m√∂glich machen, um zu sehen, wie weit ich mit der exakten Arithmetik rationaler Zahlen ohne Rundung gehen kann. <br><br>  Der letzte vorbereitende Schritt - Ich nahm alle vec3-, mat4x4- und anderen grundlegenden Algebra- / Mathematikklassen und √§nderte sie dann so, dass sie rational statt float verwendeten.  Da meine rationale Struktur alle Standardoperatoren (add, sub, mul, div, Vorzeichenumkehr, Vergleiche usw.) √ºberlastet, erfolgte der Austausch ohne Probleme.  Ich implementierte schnell die verbleibenden √ºblichen Operationen (abs, sign, mod, frakt, floor, sqrt usw.), was theoretisch ausreichte, um sch√∂ne rationale Renderings zu erhalten. <br><br><h2>  Test 1 - Die naive L√∂sung </h2><br><hr><br>  Aber mal sehen, wie diese erste Implementierung war.  Zuerst versuche ich immer das Einfachste und dann schaue ich mir die Ergebnisse an.  Der einfachste Weg, rationale Werte zu implementieren, bestand darin, zwei ganze Zahlen zu verwenden.  Wie der Name des Abschnitts andeutet, wird dies nicht meine endg√ºltige Entscheidung sein, aber f√ºr den ersten Versuch war es eine vern√ºnftige Entscheidung.  Daher sollte jede Zahl <b>x</b> als Z√§hler <b>N</b> und Nenner <b>D dargestellt</b> werden und den Wert <b>N</b> / <b>D bilden.</b>  Der <b>x-</b> Wert wird durch das bestm√∂gliche <b>N</b> / <b>D-</b> Paar (innerhalb der angegebenen Bittiefe) angen√§hert, das dem wahren <b>x-</b> Wert am n√§chsten kommt.  Ich entschied, dass beide Zahlen positiv sein m√ºssen und das Vorzeichen der Zahl in einem separaten Bit gespeichert werden sollte, um die Arbeit zu vereinfachen und Unklarheiten zu beseitigen, obwohl dies nicht sehr wichtig ist.  Zu diesem Zeitpunkt waren sowohl Z√§hler als auch Nenner vom Typ ohne Vorzeichen.  Aber selbst beim Trennen des Vorzeichens hatte <b>N</b> / <b>D</b> viel Redundanz: Zum Beispiel bezeichnen 1/4 und 7/28 dieselbe Zahl, haben aber v√∂llig unterschiedliche Bitdarstellungen.  Wir werden sp√§ter darauf eingehen, aber jetzt wollen wir unsere Aufmerksamkeit nicht konzentrieren und sehen, wie die vier grundlegenden arithmetischen Operationen in dieser rationalen Form aussehen. <br><br>  Zun√§chst ist zu beachten, dass das Subtrahieren von <b>a</b> - <b>b</b> einfach die Addition von <b>a</b> und dem Wert gegen√ºber <b>b ist</b> , d. H. <b>A</b> + ( <b>-b</b> ), wobei <b>-b</b> durch einfaches √Ñndern des Vorzeichens von <b>b</b> berechnet werden kann.  In √§hnlicher Weise ist das Teilen von <b>a</b> / <b>b</b> dasselbe wie das Multiplizieren von <b>a</b> und der Umkehrung von <b>b</b> .  Oder mit anderen Worten, <b>a</b> / <b>b</b> = <b>a</b> ¬∑ (1 / <b>b</b> ), wobei (1 / <b>b</b> ) berechnet werden kann, indem einfach die Stellen des Z√§hlers <b>b <sub>n</sub></b> und des Nenners <b>b <sub>d der</sub></b> Zahl <b>b ge√§ndert werden</b> .  Hier ist also die erste interessante Eigenschaft der rationalen Arithmetik: Division und Multiplikation haben die gleichen Kosten. Daher besteht im Gegensatz zum √ºblichen Gleitkomma-Rendering, bei dem Divisionen normalerweise vermieden, verz√∂gert oder unter den Verz√∂gerungen langsamer Texturanforderungen verborgen werden, keine Notwendigkeit, sich vor diesen Operationen in der rationalen Arithmetik zu f√ºrchten . <br><br>  Wir wenden uns der Addition mit Multiplikation zu: Wir wissen, dass die entgegengesetzten und inversen Werte trivial einfach zu berechnen sind, also erhalten wir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20f/b96/9c6/20fb969c6d2d6ad899898575244a8d20.png"></div><br>  Die Vorzeichenerhaltung w√§hrend der Multiplikation ist trivial, sie ist nur xor, da zwei positive Werte ein positives Ergebnis ergeben, sowie zwei negative.  Das Speichern eines Zeichens zum Hinzuf√ºgen ist ein komplizierterer Vorgang, und f√ºr eine schnelle L√∂sung habe ich es in drei Zweigen implementiert (das Hinzuf√ºgen ist trivial, wenn die Zeichen <b>a</b> und <b>b</b> √ºbereinstimmen, aber wenn sie nicht √ºbereinstimmen, m√ºssen Sie eine kleinere Zahl ausw√§hlen und von der gr√∂√üeren abziehen - in dem Artikel, den ich nicht habe Ich werde solche kleinen Details genauer beschreiben, aber den Quellcode einfach irgendwo auslegen. <br><br>  Ich werde auch die Implementierung von Fract () und Floor () √ºberspringen.  Wenn Sie versuchen, sie selbst zu implementieren, werden Sie ihre Einfachheit und Sch√∂nheit erkennen.  Auch die Vergleichsoperatoren sollten ber√ºcksichtigt werden.  Nachdem wir uns um die Zeichen gek√ºmmert haben und angenommen haben, dass <b>a</b> und <b>b</b> positiv sind, bekommen wir <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/b9c/831/6e4b9c831e9b49215c939fedc88ee0cd.png"></div><br>  Hierbei ist zu beachten, dass wir auch zum Vergleich einige Multiplikationsoperationen ben√∂tigen, die zum √úbergang zur n√§chsten Wortgr√∂√üe f√ºhren k√∂nnen und etwas niedriger wichtig sind. <br><br>  Schlie√ülich betrachten wir die Quadratwurzeln in einem separaten Abschnitt und wissen, dass wir sie gr√∂√ütenteils nicht ben√∂tigen (mit Ausnahme der Kugel aus diesem ersten Test). <br><br>  Dies war genug, um das erste Rendering auszuf√ºhren und die Testszene (Ebene + Kugel + Dreieck + rechteckiges Feld) zu verfolgen, um zu sehen, was daraus wurde.  Ich habe f√ºr diesen ersten Test gro√üz√ºgig rationale 65-Bit-Zahlen verwendet, die tats√§chlich eine gro√üe Datenmenge darstellen (vergleichbar mit dem "doppelten" Datentyp): 32 Bit werden vom Z√§hler √ºbernommen, 32 Bit sind der Nenner und ein weiteres Bit ist das Vorzeichen.  Das erste ist das Bild, das mit diesem naiven Ansatz erhalten wurde, das zweite ist das Bild, das unter Verwendung von Gleitkommazahlen (Referenz) erstellt wurde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/628/aca/f79628aca052bc725fa16953c8939a5c.png"></div><br>  <i>"Naive" rationale 65-Bit-Zahlen</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>Gleitkomma-Referenz</i> <br><br>  Das Ergebnis war ziemlich schlecht, die Box und das Dreieck erschienen nicht einmal auf dem Putz, und die Kugel und die Ebene des Bodens waren zu laut.  Das Problem war nat√ºrlich, dass jedes Mal, wenn meine rationalen Zahlen eine grundlegende arithmetische Operation in einer der algorithmischen Stufen des Renderns ausf√ºhrten, der Z√§hler und der Nenner immer unkontrollierter wurden, weil eine ganzzahlige Multiplikation verwendet wurde.  Stellen Sie sich Folgendes vor: Wenn die Einheiten unserer urspr√ºnglichen Welt Meter w√§ren und wir die Quellgeometrie (Eckpunkte und Kamera) millimetergenau verkn√ºpfen w√ºrden, w√ºrden nur die Quelldaten f√ºr eine relativ kleine Szene ein 16-Bit-Volumen belegen.  Gleichzeitig w√ºrden bei einer Standard-HD-Bildschirmaufl√∂sung und einer 4-fachen Gl√§ttung rationale Strahlrichtungszahlen leicht 12 Bit erfordern.  Das hei√üt, w√§hrend der ersten Interaktion von Strahl und Geometrie w√ºrde die einfachste arithmetische Operation unter Verwendung beider Eingabedatens√§tze das Ergebnis in 28-Bit-L√§ngen umwandeln - nahe genug an der 32-Bit-Grenze, die ich mir in dieser ersten Implementierung gesetzt habe.  Und das noch bevor wir das allererste Vektor- oder Skalarprodukt durchgef√ºhrt haben.  Bis das Skalarprodukt vollst√§ndig ist, w√ºrde der Renderer rationale Zahlen ben√∂tigen, die Hunderte von Bits lang sind, um Zahlen darzustellen.  Dies ist nat√ºrlich der schlimmste Fall, aber der durchschnittliche Fall w√ºrde nahe daran liegen.  Wenn man bedenkt, dass ich nur eine 32-Bit-Kapazit√§t f√ºr den Z√§hler und den Nenner zugewiesen habe, ist es leicht zu verstehen, wie schnell die Werte in diesem Test die Grenzen √ºberschreiten - es ist nicht √ºberraschend, dass mit Ausnahme der Bodenebene und eines Teils der Kugel fast nichts sichtbar ist. <br><br><h2>  Test 2 - Reduktion um den gr√∂√üten gemeinsamen Faktor </h2><br><hr><br>  Dann habe ich das System verbessert, indem ich die oben kurz erw√§hnte Eigenschaft verwendet habe - verschiedene rationale Zahlen k√∂nnen den gleichen Betrag bedeuten.  Tats√§chlich ist 6/12 der gleiche Wert wie 1/2, verwendet jedoch viel mehr Bits als das letzte.  Daher lautete die Idee wie folgt: Wenn ich nach jeder grundlegenden arithmetischen Operation (oder danach) alle gemeinsamen Teiler aus dem Z√§hler und den Nennern extrahieren und den Bruch in seine einfachste Form bringen w√ºrde, k√∂nnte ich vielleicht alles unter Kontrolle halten und die Operationen l√§nger fortsetzen mit exakter Arithmetik ohne Genauigkeitsverlust.  Vielleicht k√∂nnen Sie dies lange genug tun, um saubere, gerenderte Bilder zu erhalten?  Ich werde einen kleinen Exkurs machen, um ein anderes Beispiel zu zeigen: 588/910 kann auf 42/65 vereinfacht werden, da 14 ein Teiler von 588 und 910 ist. Aber um 42/65 zu speichern, werden offensichtlich weniger Bits ben√∂tigt als 588/910.  Das Finden der gr√∂√ütm√∂glichen Zahl, die gleichzeitig die beiden anderen Zahlen teilt, kann mit dem Great Common Divisor (GCD) -Algorithmus erfolgen, dessen effektive Implementierungen Sie √ºberall finden k√∂nnen (ich habe sie pers√∂nlich direkt aus Wikipedia kopiert und durch Ausf√ºhren des Scanschritts etwas beschleunigt Bits mit internen x64-Operationen).  Ausger√ºstet mit dem GCD-Algorithmus sollte meine rationale Klasse die w√§hrend des Rendervorgangs erzeugten Br√ºche st√§ndig vereinfachen.  Dies kann auf zwei Arten geschehen: <br><br>  Das erste besteht darin, das Zwischenergebnis der Additions- und Multiplikationsoperatoren in den n√§chsten Typ von Bitdaten umzuwandeln (in meiner aktuellen naiven L√∂sung ist es uin64_t), nach GCD in diesem umfangreicheren Datentyp zu suchen und das Ergebnis dann auf die urspr√ºngliche Bitl√§nge zu reduzieren (32).  Der zweite Weg besteht darin, zu analysieren, wie <b>a <sub>n</sub></b> , <b>a <sub>d</sub></b> , <b>b <sub>n</sub></b> und <b>b <sub>d</sub></b> in beiden arithmetischen Operatoren miteinander kombiniert werden, und gemeinsame Teiler daraus zu extrahieren, bevor die Multiplikation durchgef√ºhrt wird.  Der zweite Ansatz beseitigte im Wesentlichen die Notwendigkeit gro√üer Bitl√§ngen.  Da ich wusste, dass es ohnehin notwendig sein k√∂nnte, sie zu verwenden, entschied ich mich f√ºr die erste Methode, da sie einfacher zu implementieren war und es mir erm√∂glichte, meine Arbeit zu beschleunigen (der Abend vergeht sehr schnell).  Nachdem wir das alles getan haben, wollen wir sehen, welchen Render ich jetzt erstellen kann: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb9/bc5/66f/eb9bc566f927cab52570332aff765d02.png"></div><br>  <i>Rationale 65-Bit-Zahlen durch GCD reduziert</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>Gleitkomma-Referenz</i> <br><br>  Viel besser!  Bisher weit davon entfernt, nat√ºrlich ideal, aber es sieht vielversprechend aus.  Ich habe die Box und das Dreieck erscheinen lassen, und die Kugel scheint jetzt viel volumin√∂ser zu sein.  In der oberen rechten Ecke erschien jedoch ein lustiges Artefakt, und rationale Zahlen f√ºr viele Pixel gehen immer noch √ºber die Grenzen hinaus, was zu vielen Punkten im Bild f√ºhrt.  Es ist jedoch erw√§hnenswert, dass ich f√ºr einige (viele) Pixel anfing, <b>genaue</b> und perfekte Ergebnisse zu erzielen!  Das hei√üt, der Tracer fand mathematisch genaue Schnittpunkte von Punkten und Entfernungen, was die Hauptursache f√ºr den Versuch war, rationale Zahlen zu verwenden. <br><br>  Bevor ich zum n√§chsten Schritt im Prozess des Nachweises der Anwendbarkeit rationaler Zahlen √ºbergehe, m√∂chte ich kurz auf meine Erkenntnisse zur GCD und zur Reduzierung rationaler Zahlen eingehen. <br><br>  Die erste Entdeckung bezieht sich auf das Bitvolumen rationaler Zahlen.  Obwohl ich immer noch keine sch√∂nen Bilder rendern kann und dies wichtiger ist als die Sorge um die Optimierung des Datenvolumens, und obwohl diese fr√ºhe Implementierung immer noch eine gro√üe Anzahl von Bits (1 + 32 + 32) verwendete, habe ich bereits √ºber die zuvor erw√§hnte Verschwendung nachgedacht Bits in Form von √ºbersch√ºssigen Br√ºchen.  Insbesondere nach dem Hinzuf√ºgen einer Stufe mit einer GCD sind Bitkombinationen wie 2/4 nicht mehr anwendbar, da sie vor dem Schreiben in ein Register oder eine Variable automatisch auf 1/2 reduziert werden.  Das hei√üt, von allen 2 <sup>64</sup> Kombinationen von Bits, die ein Z√§hler und ein Nenner sein k√∂nnten, blieben in gewissem Sinne viele unbenutzt.  Und so etwas kann man nicht verschwenden.  Oder ist es m√∂glich?  Wie viel Platz verliere ich tats√§chlich?  Ich habe einen kleinen Exkurs gemacht, um dieses Problem zu untersuchen. <br><br><h2>  Exkurs - Auf gegenseitig Primzahlen </h2><br><hr><br>  Die folgenden Abbildungen zeigen die Verwendung von Bits f√ºr rationale Zahlen in 5/5 Bit und 7/7 Bit.  Die horizontalen und vertikalen Achsen der Graphen repr√§sentieren die Werte des Z√§hlers und Nenners aller m√∂glichen rationalen Zahlen mit Z√§hlern und Nennern bis zu 5 Bits (31) und 7 Bits (127).  Schwarze Pixel sind nicht verwendete Kombinationen, und wei√üe Pixel sind verwendete Br√ºche.  Beispielsweise ist die gesamte Diagonale bis auf das 1/1 Pixel schwarz, da alle Br√ºche der Form n / n auf 1/1 reduziert werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6c/f08/b9d/c6cf08b9df8d1adecee7836e92a228be.png"><br><br>  <i>Verwenden von Bits f√ºr 5/5 rational</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16e/79b/24b/16e79b24b234907f082af70a013ae971.png"><br><br>  <i>Verwenden von Bits f√ºr 7/7 rational</i> <br><br>  Wenn Sie die Pixel wie ich z√§hlen, k√∂nnen Sie schnell verstehen, dass der Anteil n√ºtzlicher Pixel mit einer Erh√∂hung der Anzahl der Bits tendenziell 60,8% betr√§gt.  Eine kleine Online-Recherche hat mir gezeigt, dass dieses Verh√§ltnis genau 6 / œÄ <sup>2</sup> betr√§gt, da es auch die Wahrscheinlichkeit ist, f√ºr zwei Zufallszahlen relativ prim (ohne gemeinsame Teiler) zu sein.  Sie fragen sich vielleicht, woher der Pi kommt?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellt sich heraus, dass ‚Äûsechs mal pi im Quadrat‚Äú ein Wert ist, der gleich Eins geteilt durch die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Riemannsche Zetafunktion ist,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die am Punkt 2, 1 / Œ∂ (2) berechnet wird. Dies sollte uns nicht sehr √ºberraschen, da die Riemannsche Zeta-Funktion h√§ufig bei Problemen mit Primzahlen und gegenseitig Primzahlen auftaucht.</font></font><br><br>     , ,          40%  .      ,      ,        ‚Ä¶      .  ,    ,  ,   ,  ,       .  -      -  -,          ,          ,          . ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren wir zur Analyse dessen zur√ºck, was wir erhalten haben: Ich kann Bilder mit Verzerrungen rendern, aber sehr stark von der Verteilung der Primzahlen in den Berechnungen abh√§ngen. Es h√§ngt von diesen Primzahlen ab, ob der GCD-Algorithmus den Ausdruck vereinfachen kann - sobald eine Primzahl oder ein Vielfaches davon in eine der Renderer-Zahlen (Vektoren, Skalare, Matrizen) f√§llt, "verschmutzt" er alle darauf folgenden Zahlen in weiteren arithmetischen Manipulationen. und bleibt f√ºr immer in ihnen. Daher ist garantiert, dass allm√§hlich alles zu wachsen beginnt, es ist nur eine Frage der Zeit. Neben der Tatsache, dass dies unvermeidlich ist, ist dies auch notwendig, da es sich um gegenseitig einfache Teiler handelt, die Informationen √ºber den Wert einer Zahl enthalten. Gleichzeitig brechen gro√üe Primzahlen alles sehr schnell. Es gibt also einen Konflikt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Letzte, was es zu beachten gilt, ist, dass ich immer noch doppelt so viele Bits wie die Standard-Gleitkommazahl verwendet habe, sodass es hier bisher keine wirklichen Vorteile gibt. </font><font style="vertical-align: inherit;">Nat√ºrlich habe ich versucht, rationale 16/16-Bit-Zahlen zu verwenden, was ein ehrlicherer Vergleich mit den tats√§chlichen Anforderungen f√ºr die Gleitkomma-Arithmetik w√§re, aber mit einer Genauigkeit von 16/16 hat das System, das ich mit Z√§hler + Nenner + GCD geschrieben habe, vollst√§ndig unleserliche Bilder erstellt.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test 3 - Normalisierung rationaler Zahlen </font></font></h2><br><hr><br> ,         . ,              .        <b></b> ,      ,           ,    ,  ,      ( ,     ‚Äî      ,            . ,     ,       ,           ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie dem auch sei, ich habe mich entschlossen zu pr√ºfen, was mit den Renderings passieren w√ºrde, wenn ich Z√§hler und Nenner irgendwie vor √úberlaufen sch√ºtzen w√ºrde. Am einfachsten w√§re es, sowohl den Z√§hler als auch den Nenner bei Bedarf um eine ausreichende Anzahl von Bits nach rechts zu verschieben, bis sie wieder in dem ihnen zugewiesenen Bitraum erscheinen. Tats√§chlich bedeutet dies eine ganzzahlige Division sowohl des Z√§hlers als auch des Nenners durch einen Wert, was bedeutet, dass der Wert der Zahl </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ungef√§hr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unver√§ndert </font><font style="vertical-align: inherit;">bleibt </font><font style="vertical-align: inherit;">. Und hier bin ich vom urspr√ºnglichen Ziel des Experiments abgewichen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In meiner ersten Implementierung habe ich mir die Anzahl der f√ºr Z√§hler und Nenner ben√∂tigten Bits angesehen, das Maximum f√ºr beide genommen und beide um diese Anzahl von Bits verschoben (auf die n√§chste Ganzzahl gerundet). </font><font style="vertical-align: inherit;">Als dies in den Additions- und Multiplikationsoperatoren implementiert wurde, sah alles ziemlich akzeptabel aus:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/c9d/8db/912c9d8dbc165e2aa14843cb3b3ccd12.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rationale 65-Bit-Zahlen, reduziert durch GCD und Normalisierung</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleitkomma-Standard</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da alles ziemlich gut aussah, habe ich zu diesem Zeitpunkt das Problem einer gro√üen Anzahl von Bits gel√∂st, die in der aktuellen Implementierung verwendet wurden. </font><font style="vertical-align: inherit;">Ich habe versucht, 16/16 (33 Bit) anstelle von 32/32 (65 Bit) zu verwenden, und die Bilder erwiesen sich als √ºberraschend gut! </font><font style="vertical-align: inherit;">Ich habe immer noch gesehen, dass es an einigen R√§ndern der Kugel kleine L√∂cher gibt, und in der Figur der Textur des Dreiecks gibt es kleine L√ºcken. </font><font style="vertical-align: inherit;">Dies ist jedoch nicht schlecht f√ºr Gr√∂√üen, die nahe genug an Gleitkommazahlen liegen. </font><font style="vertical-align: inherit;">Es gab mir Energie, neue Ideen zu lernen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test 4 - Floating Slash </font></font></h2><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt habe ich mich entschlossen, mich abzulenken und nicht mehr nach Ausreden zu suchen. Wenn ich etwas Interessantes f√ºr das Rendern in rationalen Zahlen finden m√∂chte, sollten sie 32 Bit und nicht mehr belegen. Es ist besser, eine gute Idee zu finden oder anzuhalten und dort zu enden (dies war zu Beginn des zweiten Versuchsabends).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst dachte ich, dass es sich lohnt, an den Ideen von GCD und Normalisierung festzuhalten, aber es war kl√ºger, sich der Speicherung und Verwendung von Bits zu n√§hern. Das erste, was mir einfiel, war, dass Z√§hler und Nenner zwar gro√ü werden k√∂nnen, dies aber oft nicht geschieht. Zumindest geschieht dies nicht gleichzeitig. Wenn der Z√§hler klein ist, k√∂nnen Sie den Nenner daher gro√ü sein lassen und umgekehrt. Nicht verwendete Bits eines von zwei ganzzahligen Werten k√∂nnen verwendet werden, um gr√∂√üere Werte darzustellen. Dann wurde mir klar, dass eine Gleitkommazahl in √§hnlicher Weise im Wesentlichen ein Festkommaformat ist, bei dem der ‚ÄûFestpunkt‚Äú variabel gemacht wird. Ich kann meine rationalen Zahlen nehmen und auch das Bitlayout der Bruchbruchvariablen variabel machen. Das hei√üt, es ist nicht schwer, den Bruch auf 16/16 zu setzen, aber zuzulassen, dass dieselbe 32-Bit-Variable manchmal 16/16 ist.und manchmal 5/27 oder 13/19, je nach Bedarf.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Auschecken hat sich gelohnt. </font><font style="vertical-align: inherit;">Auf jeden Fall k√∂nnen einige Zeilen Code zum Ein- und Auspacken in internen Setzern und Gettern schnell geschrieben werden. </font><font style="vertical-align: inherit;">Das logischste Schema f√ºr mich schien 1 | 5 | 26 zu sein, das hei√üt:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 Bit: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5-Bit- </font><font style="vertical-align: inherit;">Vorzeichen </font><font style="vertical-align: inherit;">: Bruchzeilenposition (B) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26-Bit: kombinierte Z√§hler- und Nennerdaten; </font><font style="vertical-align: inherit;">der Z√§hler ist das obere 26-B-Bit, der Nenner ist das untere B-Bit,</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wobei der Bruchbalken (B) die Gr√∂√üe des Nenners bestimmt. </font><font style="vertical-align: inherit;">Zum Beispiel wird die Nummer 7/3 als geschrieben</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/3 = 0 00010 000000000000000000000111 11, </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Vorzeichen 0 einen positiven Wert bedeutet, bezeichnet die Zeile des Bruchs 2 den Nenner (Nummer 3), f√ºr dessen Darstellung 2 Bits erforderlich sind, und der Rest der Bits geht an den Z√§hler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Den Lesern, die mit dem IEEE754-Standard gearbeitet haben, ist diese Beobachtung m√∂glicherweise bekannt: Die bin√§re Darstellung des Nenners beginnt immer mit ‚Äû1‚Äú, da die Bruchzeilenzahl sie immer auf die k√ºrzeste Darstellung abschneidet. </font><font style="vertical-align: inherit;">Das hei√üt, das erste Bit des Nenners ist optional. </font><font style="vertical-align: inherit;">In diesem Fall kann die Zahl "3" nur durch den Bin√§rwert "1" und den Wert der Bruchlinie "1" dargestellt werden:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/3 = 0 00001 0000000000000000000000111 1 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Trick hat mir nicht nur ein wertvolles St√ºck gespart, sondern auch einen hervorragenden Nebeneffekt: Wenn der Wert des Bruchteils Null ist, bedeutet dies nat√ºrlich gleichzeitig, dass der Nenner 1 ist und kein Speicherplatz zum Speichern ben√∂tigt wird. Dies bedeutet, dass sich meine rationale Darstellung von Zahlen pl√∂tzlich als vollst√§ndig kompatibel mit der √ºblichen ganzzahligen Darstellung und Arithmetik herausstellte, bis die Werte der Zahlen √ºber 2 </font><sup><font style="vertical-align: inherit;">26</font></sup><font style="vertical-align: inherit;"> steigen</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das hei√üt zu einer ausreichend gro√üen Schwelle. </font><font style="vertical-align: inherit;">Was f√ºr eine wundervolle √úberraschung! </font><font style="vertical-align: inherit;">Das hei√üt, theoretisch kann ich genau den gleichen Datentyp "rational" verwenden, um Standard-Rendering- und Shading-Operationen auszuf√ºhren, aber auch alle Logik und Aufgaben des Befehlsflusses im Pfad-Tracer ausf√ºhren - ich muss nicht mehr zwei Datentypen verwenden, wie es passiert in den meisten Renderern ("int" und "float") und f√ºhren Sie Konvertierungen in die eine und die andere Richtung durch! </font><font style="vertical-align: inherit;">Die Zeit lief mir jedoch davon, so dass ich nicht alle Schleifenindizes von ‚Äûint‚Äú auf ‚Äûrational‚Äú √§nderte. </font><font style="vertical-align: inherit;">Der Abend neigte sich dem Ende zu und ich musste noch viele Dinge √ºberpr√ºfen, um die Qualit√§t der Renderings zu verbessern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem ich die Implementierung erstellt hatte, konnte ich sie √ºberpr√ºfen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcb/a9b/34d/fcba9b34d81aae413f1288e6dcfcdf9b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32-Bit- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruchzahlen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1 | 5 | 26)</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i>32-    <b></b></i> <br><br> --, !   -    ,           ,      - .       . ,  ,           ,    ,        .                (  ),  ,            . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt war ich bereit, einen ernsthafteren Test durchzuf√ºhren (aber immer noch experimentell - das System ist noch lange nicht betriebsbereit). </font><font style="vertical-align: inherit;">Ich habe einen Pfad-Tracer mit einem minimalen Satz von Funktionen implementiert (nicht unbedingt physikalisch genau oder sogar unter Ber√ºcksichtigung der Physik) und eine Szene mit mehreren rechteckigen Parallelepipeds und zwei Lichtquellen erstellt, deren Referenzimplementierung auf der GPU hier zu finden ist: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.shadertoy.com/view/Xd2fzR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe die Szene erneut in das C ++ - Framework konvertiert, einige unn√∂tige Strahlennormalisierungen entfernt und das Rendern ausgef√ºhrt. </font><font style="vertical-align: inherit;">Folgendes habe ich bekommen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/e7d/951/5b9e7d951bbef194094a389017433a50.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32-Bit- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruchzahlen</font></font></b></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/58f/543/20d58f54338c93f88379f550faf52c51.jpg"></div><br> <i>32-    <b></b></i> <br><br> ,    !        ,      .     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/36d/404/72d/36d40472de509e4fe6a7520c7e6df5a4.png"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/9da/0d6/ffd9da0d613a076c0c624e5a9b2c15e9.png"><img src="https://habrastorage.org/getpro/habr/post_images/273/84b/a41/27384ba41a08f4771f8cf6c6cddd129d.png"><br><br> ,           ,      ;     .   ,     ,     .     ,   .   ,       ,        : <br><br><h2>    </h2><br><hr><br><h3>    64  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Idee der exakten Arithmetik kann weder in naiven rationalen 64-Bit-Zahlen noch in rationalen 32-Bit-Zahlen (1 | 5 | 26) mit einem Gleitlinienbruch verwirklicht werden. Und funktionieren 64-Bit-Gleitkommazahlen eines Bruchs? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich implementierte schnell die rationalen Zahlen 1 | 6 | 57 (obwohl ich neue interne x64-Mechanismen zum Verschieben von Bits lernen musste). Diese 57 Bit Z√§hler / Nenner erm√∂glichten die Verfolgung eines viel gr√∂√üeren Entfernungsintervalls. Ich habe es tats√§chlich geschafft, eine Szene mit mehreren Dreiecken </font><b><font style="vertical-align: inherit;">genau</font></b><font style="vertical-align: inherit;"> zu verfolgen</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arithmetik (nicht die oben erw√§hnte Szene mit rechteckigen Parallelepipeds und globaler Beleuchtung, sondern nur ein paar Dreiecke vor der Kamera). Und der Erfolg erwartete mich! Der Koplanarit√§tstest, den ich implementiert habe, um die Richtigkeit zu √ºberpr√ºfen, erforderte jedoch mehrere Skalar- und Vektorproduktoperationen, wodurch sich die Zahlen zu normalisieren begannen. Obwohl ich wusste, dass der Render genau war, konnte ich ihn daher nicht experimentell ‚Äûbeweisen‚Äú. Was f√ºr eine Ironie. Im Allgemeinen bedeutet dies, dass 64 Bit f√ºr mehrere Dreiecke ausreichten, komplexere Szenen jedoch immer noch auseinanderfallen. Dies lie√ü mich jedoch √ºber eine andere Frage nachdenken: Gibt es einen Algorithmus, mit dem die Koplanarit√§t getestet werden kann, der nicht auf absoluten Werten, sondern auf modularer Arithmetik basiert? Ich denkeIn der modularen Arithmetik sollten rationale Zahlen nicht in ihrer Gr√∂√üe ‚Äûexplodieren‚Äú. Ich hatte keine Zeit, dies alles zu untersuchen, und ich bin kein Experte f√ºr Zahlentheorie.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quadratwurzeln </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am letzten (zweiten) Forschungsabend habe ich mich entschlossen, kurz auf dieses Thema einzugehen und neue Informationen zu studieren. </font><font style="vertical-align: inherit;">Ich wollte die bestm√∂gliche Quadratwurzelfunktion f√ºr rationale Zahlen implementieren. </font><font style="vertical-align: inherit;">Meine derzeitige naive Entscheidung ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schlecht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) hat die ganzzahlige Quadratwurzel des Z√§hlers (mit entsprechender Rundung) genommen und dann dasselbe mit dem Nenner gemacht. </font><font style="vertical-align: inherit;">Da die Quadratwurzel eines Bruchs ein Bruchteil der Quadratwurzeln von Z√§hler und Nenner ist, liefert dieser Ansatz im Allgemeinen anst√§ndige Ergebnisse, die sich nicht zu sehr von der besten Antwort unterscheiden. </font><font style="vertical-align: inherit;">Aber er gibt sicherlich nicht die beste rationale Ann√§herung an die Quadratwurzel einer rationalen Zahl zur√ºck. </font><font style="vertical-align: inherit;">Er f√ºhrt zwei statt einer Ann√§herung durch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe folgendes versucht: Am Ende suchen wir hier nach zwei ganzen Zahlen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></b>  <b>y</b> , ,  <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/769/1eb/d9b/7691ebd9ba782aacba6bc480f13199a8.png"></div><br>          ()    (¬´¬ª ,      ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/9db/7db/aaf9db7db7d1ee8300d090ea1e97535b.png"></div><br>  Nachdem ich Wikipedia durchsucht hatte, stellte ich fest, dass diese spezielle Gleichung die sogenannte "Modified Pell's Gleichung" ist.  Es gibt Algorithmen, die die kleinsten <b>x-</b> und <b>y-</b> Werte finden, um diese Gleichung zu l√∂sen.  Leider verlagerte sich meine Aufmerksamkeit schnell auf andere merkw√ºrdige diophantinische Mathematik, und ich fuhr mit der Implementierung eines dieser Algorithmen nicht fort. <br><br><h3>  Effektivere Reduzierung </h3><br>  In den letzten Minuten des Abends dachte ich dar√ºber nach, die Idee zu untersuchen, mehrere Elemente zu verwenden, die in komplexen geometrischen Operatoren kombiniert werden, beispielsweise in einem Vektorprodukt.  Angenommen, die erste Komponente eines Vektorprodukts war <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/4b5/c33/c844b5c33c70116474bbaa0c63273ad7.png"></div><br>  unter der Annahme, dass sy = a / b, tz = c / d, ty = e / f, sz = g / h <br><br>  Dies bedeutete, dass ich jetzt versuchen kann, gemeinsame Teiler zu finden, zum Beispiel zwischen a und d oder e und h, und sie f√ºr die vorl√§ufige Reduktion zu verwenden. <br><br>  Ich hatte eine andere Idee: Wenn irgendwann die Rendergeschwindigkeit zum Problem wird, k√∂nnen Sie die Schritte zum Suchen nach GCD vollst√§ndig deaktivieren und nur die Normalisierung anwenden.  Eine schnelle √úberpr√ºfung ergab, dass in diesem Fall die Bildrender immer noch akzeptabel sind und mit einer viel h√∂heren Geschwindigkeit gut funktionieren.  In diesem Fall erhalten wir nat√ºrlich weniger arithmetisch genaue Ergebnisse. <br><br>  Als Kompromiss k√∂nnen Sie die Implementierung des Verfahrens oder des GCD-Schemas ablehnen und stattdessen etwas mathematisch Einfaches verwenden, das im Code fest codiert und effektiv ist und die Teilbarkeit durch nur 2, 3 und 5 bestimmt. Obwohl wir keine ersch√∂pfende Anzahl von Teilern finden, durch In der Praxis w√ºrde dies dazu f√ºhren, dass eine gro√üe Anzahl von Abk√ºrzungen gefunden wird.  Denken Sie dar√ºber nach - die Teilbarkeit durch 2 tritt dreimal h√§ufiger auf als die Teilbarkeit durch 7 und 20 Mal h√§ufiger als die Teilbarkeit durch 41! <br><br><h2>  Fazit </h2><br><hr><br>  Nach diesem Experiment begann ich zu glauben, dass es durchaus m√∂glich ist, dass eine Darstellung von Zahlen auf rationalen Zahlen basiert, √§hnlich dem, was ich als "Gleitlinienbruch" bezeichne.  Eine Darstellung, die mit ganzen Zahlen kompatibel ist und viele Operationen in exakter Arithmetik f√ºr viele Aufgaben ausf√ºhren kann (vorausgesetzt, die Eingabedaten werden in einer rationalen Form dargestellt).  Die 64-Bit-Version (1 | 6 | 57) hat gro√ües Potenzial, obwohl die 32-Bit-Version (1 | 5 | 26) bereits interessante Renderings erstellt. <br><br>  Wenn es kein Experiment f√ºr zwei Abende war, sondern etwas Professionelles, das in einem Studio oder einer Firma erstellt wurde, k√∂nnten in Zukunft die folgenden Schritte unternommen werden: <br><br>  * Erhalten Sie ein Histogramm der Anzahl der genau und nicht genau verfolgten Pixel (mit anderen Worten, der H√§ufigkeit der Normalisierungsausf√ºhrung). <br>  * Versuchen Sie, eine hartcodierte Reduzierung der Teiler 2, 3 und 5 zu implementieren und den Prozentsatz der verlorenen exakten Pixel zu messen <br>  * Zeigen Sie den Pixelunterschied zwischen Gleitkomma-Rendering und Bruch-Gleitkomma-Rendering an <br>  * Finden Sie ausgekl√ºgelte M√∂glichkeiten, die nicht verwendeten Werte des Bitformats "Floating Line Fractions" zu verwenden, um beispielsweise Inf und NaN zu bezeichnen <br>  * Implementieren Sie die Erkennung von NaN, Inf, Unterlauf, √úberlauf. <br><br>  Alles in allem war es eine faszinierende Studie.  Dabei entdeckte ich einige √úberraschungen, entwickelte eine kleine Erfindung und lernte viel √ºber die Pell-Gleichung, Quadratwurzeln, GCD, interne x86_64-Mechanismen, die Riemann-Zeta-Funktion und einige andere Aspekte.  Ich bin sehr zufrieden damit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448558/">https://habr.com/ru/post/de448558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448544/index.html">B√ºndel aus Stahl. Wie entstehen sie?</a></li>
<li><a href="../de448546/index.html">UITableView automatische Kopf- und Fu√üzeilengr√∂√üen mit AutoLayout</a></li>
<li><a href="../de448548/index.html">Konstruktion in der Kunst: von Brueghel bis Vasya Lozhkin</a></li>
<li><a href="../de448550/index.html">Berichtwettbewerb bei #PAYMENTSECURITY 2019 er√∂ffnet</a></li>
<li><a href="../de448552/index.html">ProLiant Series 100 - Der verlorene j√ºngere Bruder</a></li>
<li><a href="../de448560/index.html">KI-Transformationsplan: Wie leite ich ein Unternehmen im Zeitalter der KI?</a></li>
<li><a href="../de448562/index.html">Google hilft der Polizei bei der Suche nach Ger√§ten in der N√§he von Tatorten mithilfe von Standortdaten</a></li>
<li><a href="../de448564/index.html">Der erste in der Gruppe - der erste, der f√§llt: Bewertung der F√ºhrungsrisiken in selbstorganisierten Tiergruppen</a></li>
<li><a href="../de448568/index.html">Implementierung von ISO 27001: Gebrauchsanweisung</a></li>
<li><a href="../de448570/index.html">Wir sch√§tzen den Durchsatz des MIMO-Kanals (der Wassergie√üalgorithmus ist enthalten)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>