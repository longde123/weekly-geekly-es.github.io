<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÄ üñêÔ∏è üßëüèæ‚Äçü§ù‚Äçüßëüèæ As√≠ncrono / espera en C #: concepto, dise√±o interno, trucos √∫tiles ‚ò∏Ô∏è üï∫ üìõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen dia Esta vez, hablemos de un tema que todo adherente respetuoso del lenguaje C # comenz√≥ a comprender: la programaci√≥n asincr√≥nica usando Task o,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>As√≠ncrono / espera en C #: concepto, dise√±o interno, trucos √∫tiles</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470830/">  Buen dia  Esta vez, hablemos de un tema que todo adherente respetuoso del lenguaje C # comenz√≥ a comprender: la programaci√≥n asincr√≥nica usando Task o, en la gente com√∫n, async / wait.  Microsoft hizo un buen trabajo: para utilizar la asincron√≠a en la mayor√≠a de los casos, solo necesita conocer la sintaxis y ning√∫n otro detalle.  Pero si profundizas, el tema es bastante voluminoso y complejo.  Fue declarado por muchos, cada uno en su propio estilo.  Hay muchos art√≠culos interesantes sobre este tema, pero todav√≠a hay muchas ideas falsas al respecto.  Intentaremos corregir la situaci√≥n y masticar el material tanto como sea posible, sin sacrificar ni la profundidad ni la comprensi√≥n. <br><br><img src="https://habrastorage.org/webt/zn/or/r1/znorr1o7rsk1tzudgdrmgchrss4.jpeg"><br><a name="habracut"></a><br>  Temas / cap√≠tulos cubiertos: <br><br><ol><li> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El concepto de asincron√≠a</a></b> : los beneficios de la asincron√≠a y los mitos sobre un hilo "bloqueado" </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TAP.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Condiciones de sintaxis y compilaci√≥n</a></b> : requisitos previos para escribir un m√©todo de compilaci√≥n </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabaje con el uso de TAP</a></b> : la mec√°nica y el comportamiento del programa en c√≥digo asincr√≥nico (liberando subprocesos, iniciando tareas y esperando que se completen) </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Detr√°s de escena: la m√°quina de estado</a></b> : una descripci√≥n general de las transformaciones del compilador y las clases que genera </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los or√≠genes de la asincron√≠a.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El dispositivo de m√©todos asincr√≥nicos est√°ndar: m√©todos</a></b> asincr√≥nicos para trabajar con archivos y la red desde el interior </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las clases y trucos de TAP</a></b> son <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trucos</a></b> √∫tiles que pueden ayudarlo a administrar y acelerar un programa usando TAP </li></ol><a name="conception"></a><br><h2>  Concepto asincr√≥nico </h2><br>  La asincron√≠a en s√≠ misma est√° lejos de ser nueva.  La asincron√≠a generalmente implica realizar una operaci√≥n en un estilo que no implica bloquear el subproceso de llamada, es decir, iniciar la operaci√≥n sin esperar su finalizaci√≥n.  El bloqueo no es tan malo como se describe.  Uno puede encontrar afirmaciones de que los hilos bloqueados desperdician tiempo de CPU, funcionan m√°s lentamente y causan lluvia.  ¬øEsto √∫ltimo parece poco probable?  De hecho, los 2 puntos anteriores son iguales. <br><br>  En el nivel del planificador del sistema operativo, cuando un subproceso est√° en un estado "bloqueado", no se le asignar√° un tiempo precioso de procesador.  Las llamadas programadas, por regla general, corresponden a operaciones que provocan bloqueos, interrupciones del temporizador y otras interrupciones.  Es decir, cuando, por ejemplo, el controlador de disco completa la operaci√≥n de lectura e inicia una interrupci√≥n apropiada, se inicia el programador.  √âl decidir√° si iniciar un hilo que fue bloqueado por esta operaci√≥n, o alg√∫n otro con una prioridad m√°s alta. <br><br>  El trabajo lento parece a√∫n m√°s absurdo.  De hecho, de hecho, el trabajo es uno y el mismo.  Solo la operaci√≥n asincr√≥nica agregar√° un poco m√°s de sobrecarga. <br><br>  El desaf√≠o de la lluvia generalmente no es algo de esta √°rea. <br><br>  El principal problema de bloqueo es el consumo irrazonable de recursos inform√°ticos.  Incluso si nos olvidamos del tiempo para crear un subproceso y trabajar con un grupo de subprocesos, cada subproceso bloqueado consume espacio adicional.  Bueno, hay escenarios en los que solo un subproceso puede realizar cierto trabajo (por ejemplo, un subproceso de interfaz de usuario).  En consecuencia, no quisiera que √©l est√© ocupado con una tarea que otro hilo puede realizar, sacrificando el desempe√±o de operaciones exclusivas para √©l. <br><br>  La asincron√≠a es un concepto muy amplio y se puede lograr de muchas maneras. <br>  <b>Lo siguiente se puede distinguir en la historia de .NET</b> : <br><br><ol><li>  EAP (Patr√≥n asincr√≥nico basado en eventos): como su nombre lo indica, la caminata se basa en eventos que se activan cuando se completa la operaci√≥n y el m√©todo habitual que llama a esta operaci√≥n </li><li>  APM (Modelo de programaci√≥n asincr√≥nica): basado en 2 m√©todos.  El m√©todo BeginSmth devuelve la interfaz IAsyncResult.  El m√©todo EndSmth acepta IAsyncResult (si la operaci√≥n no se completa cuando se llama a EndSmth, el subproceso est√° bloqueado) </li><li>  TAP (Patr√≥n as√≠ncrono basado en tareas) es el mismo as√≠ncrono / espera (estrictamente hablando, estas palabras aparecieron despu√©s del enfoque y aparecieron los tipos de Tarea y Tarea &lt;Resultado&gt;, pero as√≠ncrono / espera mejor√≥ significativamente este concepto) </li></ol><br>  El √∫ltimo enfoque fue tan exitoso que todos olvidaron con √©xito los anteriores.  Entonces, ser√° sobre √©l. <br><a name="tap_syntax"></a><br><h2>  Patr√≥n asincr√≥nico basado en tareas.  Condiciones de sintaxis y compilaci√≥n </h2><br>  El m√©todo asincr√≥nico de estilo TAP est√°ndar es muy f√°cil de escribir. <br><br>  <b>Para hacer esto, necesitas</b> : <br><br><ol><li>  Para que el valor de retorno sea Tarea, Tarea &lt;T&gt; o nulo (no recomendado, discutido m√°s adelante).  En C # 7 llegaron los tipos de tareas (discutidos en el √∫ltimo cap√≠tulo).  En C # 8, IAsyncEnumerable &lt;T&gt; e IAsyncEnumerator &lt;T&gt; se agregan a esta lista. </li><li>  Para que el m√©todo est√© marcado con la palabra clave as√≠ncrona y contenga esperar dentro.  Estas palabras clave est√°n emparejadas.  Adem√°s, si el m√©todo contiene esperar, aseg√∫rese de marcarlo como as√≠ncrono, lo contrario no es cierto, pero no tiene sentido </li><li>  Para la decencia, cumpla con la convenci√≥n de sufijo as√≠ncrono.  Por supuesto, el compilador no considerar√° esto como un error.  Si es un desarrollador muy decente, puede agregar sobrecargas con un CancellationToken (discutido en el √∫ltimo cap√≠tulo) </li></ol><br>  Para tales m√©todos, el compilador hace un trabajo serio.  Y se vuelven completamente irreconocibles detr√°s de escena, pero m√°s sobre eso m√°s adelante. <br><br>  Se mencion√≥ que el m√©todo debe contener la palabra clave wait.  (La palabra) indica la necesidad de espera as√≠ncrona para que se realice la tarea, que es el objeto de tarea al que se aplica. <br><br>  <b>El objeto de tarea tambi√©n tiene ciertas condiciones para que se pueda aplicar la espera:</b> <br><br><ol><li>  El tipo esperado debe tener un m√©todo p√∫blico (o interno) GetAwaiter (), tambi√©n puede ser un m√©todo de extensi√≥n.  Este m√©todo devuelve un objeto de espera. </li><li>  El objeto de espera debe implementar la interfaz INotifyCompletion, que requiere la implementaci√≥n del m√©todo vac√≠o OnCompleted (continuaci√≥n de acci√≥n).  Tambi√©n debe tener la propiedad de instancia bool IsCompleted, el m√©todo vac√≠o GetResult ().  Puede ser una estructura o una clase. </li></ol><br>  El siguiente ejemplo muestra c√≥mo hacer un int esperado, e incluso nunca ejecutado. <br><br><div class="spoiler">  <b class="spoiler_title">Extensi√≥n int</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WeirdExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnyTypeAwaiter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAwaiter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnyTypeAwaiter(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AnyTypeAwaiter</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyCompletion</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCompleted =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action continuation</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } }</code> </pre> <br></div></div><br><a name="tap_progr"></a><br><h2>  Trabajar con TAP </h2><br>  Es dif√≠cil entrar a la jungla sin entender c√≥mo algo deber√≠a funcionar.  Considere TAP en t√©rminos de comportamiento del programa. <br><br>  En terminolog√≠a: el m√©todo asincr√≥nico en cuesti√≥n, cuyo c√≥digo ser√° considerado, llamar√© al <b>m√©todo asincr√≥nico</b> , y a los m√©todos asincr√≥nicos llamados dentro de √©l llamar√© la <b>operaci√≥n asincr√≥nica</b> . <br><br>  Tomemos el ejemplo m√°s simple, como una operaci√≥n asincr√≥nica tomamos Task.Delay, que demora el tiempo especificado sin bloquear la transmisi√≥n. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DelayOperationAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   { BeforeCall(); Task task = Task.Delay(1000); //  AfterCall(); await task; AfterAwait(); }</span></span></span></span></code> </pre><br>  La ejecuci√≥n del m√©todo en t√©rminos de comportamiento es la siguiente. <br><br><ol><li>  Se ejecuta todo el c√≥digo que precede a la invocaci√≥n de la operaci√≥n asincr√≥nica.  En este caso, este es el m√©todo <i>BeforeCall</i> </li><li>  Una llamada de operaci√≥n asincr√≥nica est√° en progreso.  En esta etapa, el hilo no se libera ni se bloquea.  Esta operaci√≥n devuelve el resultado: el objeto de tarea mencionado (generalmente Tarea), que se almacena en una variable local </li><li>  El c√≥digo se ejecuta despu√©s de llamar a la operaci√≥n asincr√≥nica, pero antes de esperar (esperar).  En el ejemplo: <i>AfterCall</i> </li><li>  Esperando la finalizaci√≥n del objeto de tarea (que se almacena en una variable local): espera tarea. <br><br>  Si la operaci√≥n asincr√≥nica se completa en este punto, la ejecuci√≥n contin√∫a sincr√≥nicamente en el mismo hilo. <br><br>  Si la operaci√≥n asincr√≥nica no se completa, se guarda el c√≥digo, que deber√° llamarse al finalizar la operaci√≥n asincr√≥nica (la llamada continuaci√≥n), y la secuencia vuelve al grupo de subprocesos y queda disponible para su uso. </li><li>  La ejecuci√≥n de las operaciones despu√©s de esperar - <i>AfterAwait</i> - se realiza inmediatamente, en el mismo hilo, cuando se complet√≥ la operaci√≥n en el momento de la espera, o, al finalizar la operaci√≥n, se toma un nuevo hilo que continuar√° (guardado en el paso anterior) </li></ol><br><a name="internals"></a><br><h2>  Detr√°s de escena  M√°quina de estado </h2><br>  De hecho, el compilador transforma nuestro m√©todo en un m√©todo auxiliar en el que se inicializa la clase generada, la m√°quina de estado.  Luego (la m√°quina) se inicia y el objeto Tarea utilizado en el paso 2 se devuelve del m√©todo. <br><br>  De particular inter√©s es el m√©todo <i>MoveNext de</i> la m√°quina de estados.  Este m√©todo hace lo que era antes de la conversi√≥n en el m√©todo asincr√≥nico.  Rompe el c√≥digo entre cada llamada en espera.  Cada parte se realiza en una determinada condici√≥n de la m√°quina.  El m√©todo <i>MoveNext en</i> s√≠ mismo se adjunta al objeto de espera como una continuaci√≥n.  La preservaci√≥n del estado garantiza la ejecuci√≥n de precisamente esa parte del mismo que l√≥gicamente sigui√≥ la expectativa. <br><br>  Como dicen, es mejor ver 1 vez que escuchar 100 veces, por lo que le recomiendo que se familiarice con el siguiente ejemplo.  Reescrib√≠ el c√≥digo un poco, mejor√© el nombre de las variables y coment√© generosamente. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fuente</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">M√©todo del trozo</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AsyncStateMachine(typeof(DelaysStateMachine))</span></span>] [DebuggerStepThrough] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DelaysStateMachine stateMachine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DelaysStateMachine(); stateMachine.taskMethodBuilder = AsyncTaskMethodBuilder.Create(); stateMachine.currentState = <span class="hljs-number"><span class="hljs-number">-1</span></span>; AsyncTaskMethodBuilder builder = stateMachine.taskMethodBuilder; taskMethodBuilder.Start(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> stateMachine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stateMachine.taskMethodBuilder.Task; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">M√°quina de estado</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DelaysStateMachine</span></span> : <span class="hljs-title"><span class="hljs-title">IAsyncStateMachine</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     await   //       await'a public int currentState; public AsyncTaskMethodBuilder taskMethodBuilder; //   private TaskAwaiter taskAwaiter; //  ,             ""  public int paramInt; private int localInt; private void MoveNext() { int num = currentState; try { TaskAwaiter awaiter5; TaskAwaiter awaiter4; TaskAwaiter awaiter3; TaskAwaiter awaiter2; TaskAwaiter awaiter; switch (num) { default: localInt = paramInt; //  await Console.WriteLine(1); //  await awaiter5 = Task.Delay(1000).GetAwaiter(); //  await if (!awaiter5.IsCompleted) //  await. ,    { num = (currentState = 0); // ,      taskAwaiter = awaiter5; //    ,        DelaysStateMachine stateMachine = this; //    taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter5, ref stateMachine); //                 return; } goto Il_AfterFirstAwait; //  ,   ,    case 0: //            ,        .   ,          awaiter5 = taskAwaiter; //   taskAwaiter = default(TaskAwaiter); //   num = (currentState = -1); //  goto Il_AfterFirstAwait; //       case 1: //  ,      ,    ,     . awaiter4 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterSecondAwait; case 2: // ,     . awaiter3 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterThirdAwait; case 3: //    awaiter2 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterFourthAwait; case 4: //    { awaiter = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); break; } Il_AfterFourthAwait: awaiter2.GetResult(); Console.WriteLine(5); //     awaiter = Task.Delay(1000).GetAwaiter(); //   if (!awaiter.IsCompleted) { num = (currentState = 4); taskAwaiter = awaiter; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); return; } break; Il_AfterFirstAwait: //  ,        awaiter5.GetResult(); //       Console.WriteLine(2); //  ,     await awaiter4 = Task.Delay(1000).GetAwaiter(); //    if (!awaiter4.IsCompleted) { num = (currentState = 1); taskAwaiter = awaiter4; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter4, ref stateMachine); return; } goto Il_AfterSecondAwait; Il_AfterThirdAwait: awaiter3.GetResult(); Console.WriteLine(4); //     awaiter2 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter2.IsCompleted) { num = (currentState = 3); taskAwaiter = awaiter2; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter2, ref stateMachine); return; } goto Il_AfterFourthAwait; Il_AfterSecondAwait: awaiter4.GetResult(); Console.WriteLine(3); //     awaiter3 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter3.IsCompleted) { num = (currentState = 2); taskAwaiter = awaiter3; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter3, ref stateMachine); return; } goto Il_AfterThirdAwait; } awaiter.GetResult(); } catch (Exception exception) { currentState = -2; taskMethodBuilder.SetException(exception); return; } currentState = -2; taskMethodBuilder.SetResult(); //    ,   ,       } void IAsyncStateMachine.MoveNext() {...} [DebuggerHidden] private void SetStateMachine(IAsyncStateMachine stateMachine) {...} void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine) {...} }</span></span></code> </pre><br></div></div><br>  Me concentro en la frase "en este momento no se ha ejecutado sincr√≥nicamente".  Una operaci√≥n asincr√≥nica tambi√©n puede seguir una ruta de ejecuci√≥n s√≠ncrona.  La condici√≥n principal para que el m√©todo asincr√≥nico actual se ejecute sincr√≥nicamente, es decir, sin cambiar el subproceso, es la finalizaci√≥n de la operaci√≥n asincr√≥nica en el momento de la verificaci√≥n <i>IsCompleted</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Este ejemplo demuestra claramente este comportamiento.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-comment"><span class="hljs-comment">//1 Task task = Task.Delay(1000); Thread.Sleep(1700); await task; Console.WriteLine(Thread.CurrentThread.ManagedThreadId); //1 }</span></span></code> </pre><br></div></div><br>  Sobre el contexto de sincronizaci√≥n.  El m√©todo <i>AwaitUnsafeOnCompleted</i> utilizado en la m√°quina finalmente resulta en una llamada al m√©todo <i>Task.SetContinuationForAwait</i> .  En este m√©todo, se recupera el contexto de sincronizaci√≥n actual <i>SynchronizationContext.Current</i> .  El contexto de sincronizaci√≥n se puede interpretar como un tipo de secuencia.  En caso de que est√© all√≠ y sea algo espec√≠fico (por ejemplo, el contexto del hilo de la interfaz de usuario), la continuaci√≥n se crea utilizando la clase <i>SynchronizationContextAwaitTaskContinuation</i> .  Esta clase para iniciar la continuaci√≥n llama al m√©todo Post en el contexto guardado, lo que garantiza que la continuaci√≥n se ejecute en el contexto exacto donde se ejecut√≥ el m√©todo.  La l√≥gica espec√≠fica para ejecutar la continuaci√≥n depende del m√©todo <i>Post</i> en un contexto que, por decirlo suavemente, no se conoce por su velocidad.  Si no hubo contexto de sincronizaci√≥n (o se indic√≥ que no nos importa en qu√© contexto la ejecuci√≥n continuar√° utilizando ConfigureAwait (falso), que se discutir√° en el √∫ltimo cap√≠tulo), la continuaci√≥n se realizar√° por el hilo del grupo. <br><a name="libs"></a><br><h2>  Los or√≠genes de la asincron√≠a.  Los m√©todos as√≠ncronos est√°ndar del dispositivo </h2><br>  Observamos c√≥mo se ve un m√©todo que utiliza as√≠ncrono y espera y qu√© sucede detr√°s de escena.  Esta informaci√≥n no es infrecuente.  Pero es importante comprender la naturaleza de las operaciones asincr√≥nicas.  Porque, como vimos en la m√°quina de estado, las operaciones asincr√≥nicas se invocan en el c√≥digo, a menos que su resultado se procese de manera m√°s astuta.  Sin embargo, ¬øqu√© sucede dentro de las operaciones asincr√≥nicas mismas?  Probablemente lo mismo, pero esto no puede suceder hasta el infinito. <br><br>  Una tarea importante es comprender la naturaleza de la asincron√≠a.  Cuando se trata de entender la asincron√≠a, hay una alternancia de estados "ahora claro" y "ahora nuevamente incomprensible".  Y esta alternancia ser√° hasta que se entienda la fuente de asincron√≠a. <br><br>  Cuando trabajamos con asincron√≠a, operamos en tareas.  Esto no es lo mismo que una secuencia.  Una tarea puede ser realizada por muchos hilos, y un hilo puede realizar muchas tareas. <br><br>  La asincron√≠a generalmente comienza con un m√©todo que devuelve Tarea (por ejemplo), pero no est√° etiquetado con as√≠ncrono y, por lo tanto, no utiliza esperar dentro.  Este m√©todo no tolera ning√∫n cambio del compilador; se ejecuta tal cual. <br><br>  <b>Entonces, veamos algunas de las ra√≠ces de la asincron√≠a.</b> <br><br><ol><li>  Task.Run, nueva tarea (..). Start (), Factory.StartNew y similares.  La forma m√°s f√°cil de comenzar la ejecuci√≥n asincr√≥nica.  Estos m√©todos simplemente crean un nuevo objeto de tarea, pasando un delegado como uno de los par√°metros.  La tarea se transfiere al planificador, lo que permite que sea ejecutada por uno de los subprocesos del grupo.  Se devuelve la tarea final que se puede esperar.  Por lo general, este enfoque se usa para comenzar a computar (vinculado a la CPU) en un hilo separado. </li><li>  TaskCompletionSource.  Una clase auxiliar que ayuda a controlar el objeto de la tarea.  Dise√±ado para aquellos que no pueden asignar un delegado para la implementaci√≥n y utiliza mecanismos m√°s sofisticados para controlar la finalizaci√≥n.  Tiene una API muy simple: SetResult, SetError, etc., que actualiza la tarea en consecuencia.  Esta tarea est√° disponible a trav√©s de la propiedad Tarea.  Quiz√°s dentro de usted cree hilos, tenga una l√≥gica compleja para su interacci√≥n o finalizaci√≥n por evento.  Un poco m√°s de detalles sobre esta clase estar√°n en la √∫ltima secci√≥n. </li></ol><br>  En un p√°rrafo adicional, puede hacer los m√©todos de las bibliotecas est√°ndar.  Estos incluyen leer / escribir archivos, trabajar con una red y similares.  Como regla, tales m√©todos populares y comunes usan llamadas al sistema que var√≠an en diferentes plataformas, y su dispositivo es extremadamente entretenido.  Considere trabajar con archivos y la red. <br><br><h3>  Archivos </h3><br>  Una nota importante: si desea trabajar con archivos, debe especificar useAsync = true al crear FileStream. <br><br>  Todo est√° organizado en archivos de manera no trivial y confusa.  La clase FileStream se declara como parcial.  Adem√°s, hay 6 complementos m√°s espec√≠ficos de la plataforma.  Entonces, en Unix, el acceso as√≠ncrono a un archivo arbitrario, como regla, usa una operaci√≥n s√≠ncrona en un hilo separado.  En Windows hay llamadas al sistema para la operaci√≥n asincr√≥nica, que, por supuesto, se utilizan.  Esto conduce a diferencias en el trabajo en diferentes plataformas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuentes</a> <br><br>  <b>Unix</b> <br><br>  El comportamiento est√°ndar al escribir o leer es realizar la operaci√≥n sincr√≥nicamente, si el b√∫fer lo permite y el flujo no est√° ocupado con otra operaci√≥n: <br><br>  1. Stream no est√° ocupado con otra operaci√≥n <br><br>  La clase Filestream tiene un objeto heredado de SemaphoreSlim con los par√°metros (1, 1), es decir, una secci√≥n cr√≠tica, el fragmento de c√≥digo protegido por este sem√°foro puede ser ejecutado por un solo hilo a la vez.  Este sem√°foro se usa tanto para leer como para escribir.  Es decir, es imposible producir simult√°neamente lectura y escritura.  En este caso, no se produce el bloqueo en el sem√°foro.  Se llama al m√©todo this._asyncState.WaitAsync (), que devuelve el objeto de tarea (no hay bloqueo ni espera, ser√≠a si la palabra clave de espera se aplicara al resultado del m√©todo).  Si el objeto de tarea dado no se completa, es decir, se captura el sem√°foro, entonces la continuaci√≥n (Task.ContinueWith) en la que se realiza la operaci√≥n se adjunta al objeto de espera devuelto.  Si el objeto est√° libre, debe verificar lo siguiente <br><br>  2. El buffer permite <br><br>  Aqu√≠ el comportamiento ya depende de la naturaleza de la operaci√≥n. <br><br>  Para la grabaci√≥n: se verifica que el tama√±o de los datos para escribir + posici√≥n en el archivo es menor que el tama√±o del b√∫fer, que por defecto es 4096 bytes.  Es decir, debemos escribir 4096 bytes desde el principio, 2048 bytes con un desplazamiento de 2048, y as√≠ sucesivamente.  Si este es el caso, la operaci√≥n se lleva a cabo sincr√≥nicamente, de lo contrario se adjunta la continuaci√≥n (Task.ContinueWith).  La secuela utiliza una llamada regular al sistema sincr√≥nico.  Cuando el b√∫fer est√° lleno, se escribe en el disco sincr√≥nicamente. <br>  Para leer: se verifica si hay suficientes datos en el b√∫fer para devolver todos los datos necesarios.  Si no, entonces, nuevamente, una continuaci√≥n (Task.ContinueWith) con una llamada al sistema s√≠ncrono. <br><br>  Por cierto, hay un detalle interesante.  Si una pieza de datos ocupa todo el b√∫fer, se escribir√°n directamente en el archivo, sin la participaci√≥n del b√∫fer.  Al mismo tiempo, hay una situaci√≥n en la que habr√° m√°s datos que el tama√±o del b√∫fer, pero todos pasar√°n por √©l.  Esto sucede si ya hay algo en el b√∫fer.  Luego, nuestros datos se dividir√°n en 2 porciones, una llenar√° el b√∫fer hasta el final y los datos se escribir√°n en el archivo, el segundo se escribir√° en el b√∫fer si entra en √©l o directamente en el archivo si no lo hace.  Entonces, si creamos una secuencia y le escribimos 4097 bytes, aparecer√°n inmediatamente en el archivo, sin llamar a Dispose.  Si escribimos 4095, entonces no habr√° nada en el archivo. <br><br>  <b>Ventanas</b> <br><br>  En Windows, el algoritmo para usar el b√∫fer y escribir directamente es muy similar.  Pero se observa una diferencia significativa directamente en las llamadas de escritura y lectura del sistema asincr√≥nico.  Hablando sin profundizar en las llamadas al sistema, existe una estructura superpuesta.  Tiene un campo importante para nosotros: HANDLE hEvent.  Este es un evento de reinicio manual que entra en estado de alarma al finalizar una operaci√≥n.  Volver a la implementaci√≥n.  Al escribir directamente, as√≠ como al b√∫fer, use llamadas asincr√≥nicas del sistema, que usan la estructura anterior como par√°metro.  Al grabar, se crea un objeto FileStreamCompletionSource, un heredero de TaskCompletionSource, en el que se especifica IOCallback.  Se llama por subproceso libre del grupo cuando finaliza la operaci√≥n.  En la devoluci√≥n de llamada, la estructura Superpuesta se analiza y el objeto Tarea se actualiza en consecuencia.  Eso es todo magia. <br><br><h3>  Red </h3><br>  Es dif√≠cil describir todo lo que vi entendiendo la fuente.  Mi camino se extend√≠a desde HttpClient a Socket y a SocketAsyncContext para Unix.  El esquema general es el mismo que con los archivos.  Para Windows, se utiliza la estructura superpuesta mencionada y la operaci√≥n se realiza de forma asincr√≥nica.  En Unix, las operaciones de red tambi√©n utilizan funciones de devoluci√≥n de llamada. <br><br>  Y una peque√±a explicaci√≥n.  Un lector atento notar√° que cuando se usan llamadas asincr√≥nicas entre una llamada y una devoluci√≥n de llamada, hay un cierto vac√≠o que de alguna manera funciona con los datos.  Aqu√≠ vale la pena aclarar la integridad.  En el ejemplo de los archivos, el controlador de disco realiza operaciones directas con el disco por el controlador de disco, es √©l quien da las se√±ales sobre c√≥mo mover las cabezas al sector deseado, etc.  El procesador es gratuito en este momento.  La comunicaci√≥n con el disco se produce a trav√©s de los puertos de entrada / salida.  Indican el tipo de operaci√≥n, la ubicaci√≥n de los datos en el disco, etc.  A continuaci√≥n, el controlador y el disco se dedican a esta operaci√≥n y al finalizar el trabajo generan una interrupci√≥n.  En consecuencia, una llamada asincr√≥nica del sistema solo aporta informaci√≥n a los puertos de entrada / salida, mientras que la s√≠ncrona tambi√©n espera los resultados, poniendo el flujo en un estado de bloqueo.  Este esquema no pretende ser absolutamente preciso (no se trata de este art√≠culo), pero ofrece una comprensi√≥n conceptual del trabajo. <br><br>  Ahora la naturaleza del proceso es clara.  Pero alguien puede preguntar, ¬øqu√© hacer con la asincron√≠a?  Es imposible escribir as√≠ncrono sobre un m√©todo para siempre. <br><br>  Primero de todo  Una solicitud puede hacerse como un servicio.  En este caso, el punto de entrada - Principal - est√° escrito desde cero por usted.  Hasta hace poco, Main no pod√≠a ser as√≠ncrono; en la versi√≥n 7 del lenguaje, se agreg√≥ esta caracter√≠stica.  Pero no cambia nada fundamentalmente, el compilador simplemente genera el Main habitual, y desde el as√≠ncrono solo se realiza un m√©todo est√°tico, que se llama en Main y se espera su finalizaci√≥n sincr√≥nicamente.  Entonces, lo m√°s probable es que tengas algunas acciones de larga duraci√≥n.  Por alguna raz√≥n, en este momento, muchas personas comienzan a pensar en c√≥mo crear subprocesos para este negocio: a trav√©s de Task, ThreadPool o Thread en general de forma manual, porque deber√≠a haber una diferencia en algo.  La respuesta es simple, por supuesto, Tarea.  Si usa el enfoque TAP, no interfiera con la creaci√≥n manual de hilos.  Esto es similar al uso de HttpClient para casi todas las solicitudes, y la POST se realiza de forma independiente a trav√©s de Socket. <br><br>  En segundo lugar.  Aplicaciones web.  Cada solicitud entrante hace que se extraiga un nuevo hilo de ThreadPool para su procesamiento.  La piscina, por supuesto, es grande, pero no infinita.  En el caso de que haya muchas solicitudes, es posible que no haya suficientes subprocesos y todas las solicitudes nuevas se colocar√°n en cola para su procesamiento.  Esta situaci√≥n se llama inanici√≥n.  Pero en el caso de usar controladores as√≠ncronos, como se discuti√≥ anteriormente, la secuencia regresa al grupo y se puede usar para procesar nuevas solicitudes.  Por lo tanto, el rendimiento del servidor aumenta significativamente. <br><br>  Observamos el proceso asincr√≥nico desde el principio hasta el final.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y armados con una comprensi√≥n de toda esta asincron√≠a, que contradice la naturaleza humana, consideraremos algunos trucos √∫tiles cuando trabajemos con c√≥digo asincr√≥nico. </font></font><br><a name="api"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clases y trucos √∫tiles al trabajar con TAP </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La diversidad est√°tica de la clase Task. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La clase Task tiene varios m√©todos est√°ticos √∫tiles. </font><font style="vertical-align: inherit;">Debajo est√°n los principales.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.WhenAny (..) es un combinador que toma IEnumerable / params de objetos de tarea y devuelve un objeto de tarea que se completar√° cuando se complete la primera tarea que se complete. </font><font style="vertical-align: inherit;">Es decir, le permite esperar una de varias tareas en ejecuci√≥n.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task.WhenAll (..) - combinador, acepta IEnumerable / params de objetos de tarea y devuelve un objeto de tarea, que se completar√° al completar todas las tareas transferidas </font></font></li><li> Task.FromResult&lt;T&gt;(T value) ‚Äî    ,    .          </li><li> Task.Delay(..) ‚Äî     </li><li> Task.Yield() ‚Äî  .   ,      .  ,    ,      </li></ol><br><h3> ConfigureAwait </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturalmente, la caracter√≠stica "avanzada" m√°s popular. Este m√©todo pertenece a la clase Task y le permite especificar si necesitamos continuar en el mismo contexto donde se llam√≥ a la operaci√≥n asincr√≥nica. Por defecto, sin usar este m√©todo, el contexto se recuerda y contin√∫a usando el m√©todo Post mencionado. Sin embargo, como dijimos, Post es un placer muy costoso. Por lo tanto, si el rendimiento est√° en el primer lugar y vemos que la continuaci√≥n, por ejemplo, no actualizar√° la interfaz de usuario, puede especificar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.ConfigureAwait (falso)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el objeto en espera </font><font style="vertical-align: inherit;">. Esto significa que no nos importa d√≥nde se realizar√° la continuaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora sobre el problema. Como dicen, aterrador no es ignorancia, sino falso conocimiento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De alguna manera, observ√© el c√≥digo de una aplicaci√≥n web, donde cada llamada asincr√≥nica estaba decorada con este acelerador. </font><font style="vertical-align: inherit;">Esto no tiene otro efecto que el asco visual. </font><font style="vertical-align: inherit;">La aplicaci√≥n web est√°ndar ASP.NET Core no tiene contextos √∫nicos (a menos que los escriba usted mismo, por supuesto). </font><font style="vertical-align: inherit;">Por lo tanto, el m√©todo Post no se llama all√≠ de todos modos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TaskCompletionSource &lt;T&gt; </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una clase que facilita la administraci√≥n de un objeto Task. </font><font style="vertical-align: inherit;">Una clase tiene muchas oportunidades, pero es m√°s √∫til cuando queremos envolver una tarea con una acci√≥n, cuyo final ocurre en un evento. </font><font style="vertical-align: inherit;">En general, la clase se cre√≥ para adaptar viejos m√©todos asincr√≥nicos a TAP, pero como hemos visto, se usa no solo para esto. </font><font style="vertical-align: inherit;">Un peque√±o ejemplo de trabajar con esta clase:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); FileSystemWatcher watcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileSystemWatcher { Path = Directory.GetCurrentDirectory(), NotifyFilter = NotifyFilters.LastAccess, EnableRaisingEvents = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; watcher.Changed += (o, e) =&gt; tcs.SetResult(e.FullPath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tcs.Task; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta clase crea un contenedor as√≠ncrono para obtener el nombre del archivo al que se accedi√≥ en la carpeta actual. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CancellationTokenSource </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le permite cancelar una operaci√≥n asincr√≥nica. </font><font style="vertical-align: inherit;">El esquema general se asemeja al uso de una TaskCompletionSource. </font><font style="vertical-align: inherit;">Primero, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se crea var cts = new CancellationTokenSource ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que, por cierto, es IDisposable, luego </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Token</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se pasa a operaciones asincr√≥nicas </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Adem√°s, siguiendo alguna l√≥gica suya, bajo ciertas condiciones, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llama al</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√©todo </font><i><font style="vertical-align: inherit;">cts.Cancel ()</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tambi√©n puede suscribirse a un evento o cualquier otra cosa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una buena pr√°ctica. </font><font style="vertical-align: inherit;">Al escribir su m√©todo asincr√≥nico que hace un trabajo en segundo plano, digamos en un tiempo infinito, simplemente puede insertar una l√≠nea en el cuerpo del bucle: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancellationToken.ThrowIfCancellationRequested ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que arrojar√° una excepci√≥n</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esta excepci√≥n se trata como una cancelaci√≥n de la operaci√≥n y no se guarda como una excepci√≥n dentro del objeto de tarea. </font><font style="vertical-align: inherit;">Adem√°s, la propiedad </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsCanceled</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el objeto Task se convertir√° en verdadera.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Longrunning </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A menudo hay situaciones, especialmente cuando se escriben servicios, cuando se crean varias tareas que funcionar√°n durante toda la vida √∫til del servicio o solo durante mucho tiempo. </font><font style="vertical-align: inherit;">Como recordamos, usar un grupo de subprocesos es justificadamente la sobrecarga de crear un subproceso. </font><font style="vertical-align: inherit;">Sin embargo, si rara vez se crea una transmisi√≥n (incluso una vez por hora), estos costos se nivelan y puede crear transmisiones separadas de manera segura. </font><font style="vertical-align: inherit;">Para ello, se crea una tarea, puede especificar una opci√≥n especial: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Factory.StartNew (la acci√≥n, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCreationOptions.LongRunning</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y, en general, me aconsejan que analiza toda la sobrecarga </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Factory.StartNew</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , hay muchas maneras de configurar de forma flexible las necesidades espec√≠ficas de la tarea.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Excepciones </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido a la naturaleza no determinista de la ejecuci√≥n de c√≥digo as√≠ncrono, la cuesti√≥n de las excepciones es muy relevante. Ser√≠a una pena si no pudieras atrapar la excepci√≥n y se arroj√≥ en el hilo izquierdo, matando el proceso. Se cre√≥ una clase </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para capturar una excepci√≥n en un hilo y lanzarlo en √©l </font><font style="vertical-align: inherit;">. Para detectar la excepci√≥n, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se utiliza</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el m√©todo est√°tico </font><i><font style="vertical-align: inherit;">ExceptionDispatchInfo.Capture (ex), que</font></i><font style="vertical-align: inherit;"> devuelve </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se puede pasar un enlace a este objeto a cualquier hilo, que luego llama al m√©todo Throw () para tirarlo. </font><font style="vertical-align: inherit;">El lanzamiento en s√≠ NO ocurre en el lugar de la llamada de operaci√≥n asincr√≥nica, sino en el lugar de uso del operador en espera. </font><font style="vertical-align: inherit;">Y como saben, esperar no se puede aplicar al vac√≠o. </font><font style="vertical-align: inherit;">Por lo tanto, si el contexto existiera, se lo pasar√° por el m√©todo Post. </font><font style="vertical-align: inherit;">De lo contrario, se emocionar√° en la secuencia de la piscina. </font><font style="vertical-align: inherit;">Y esto es casi 100% hola al colapso de la aplicaci√≥n. </font><font style="vertical-align: inherit;">Y aqu√≠ llegamos a la pr√°ctica del hecho de que deber√≠amos usar Task o Task &lt;T&gt;, pero no anular. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y una cosa m√°s. </font><font style="vertical-align: inherit;">El planificador tiene un evento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler.UnobservedTaskException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que se dispara cuando </font><i><font style="vertical-align: inherit;">se</font></i><font style="vertical-align: inherit;"> lanza una </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnobservedTaskException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta excepci√≥n se produce durante la recolecci√≥n de basura cuando el GC intenta recopilar un objeto de tarea que tiene una excepci√≥n no controlada.</font></font><br><br><h3> IAsyncEnumerable </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de C # 8 y .NET Core 3.0, no era posible usar un iterador de rendimiento en un m√©todo asincr√≥nico, lo que complicaba la vida y hac√≠a que devolviera la Tarea &lt;IEnumerable &lt;T&gt;&gt; de este m√©todo, es decir no hab√≠a forma de recorrer la colecci√≥n hasta que se recibi√≥ por completo. Ahora hay tal oportunidad. Obtenga m√°s informaci√≥n al respecto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para esto, el tipo de retorno debe ser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerable &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerator &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Para atravesar dicha colecci√≥n, debe usar el bucle foreach con la palabra clave wait. Adem√°s, los m√©todos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WithCancellation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pueden </font><i><font style="vertical-align: inherit;">invocar</font></i><font style="vertical-align: inherit;"> en el resultado de la operaci√≥n </font><font style="vertical-align: inherit;">, indicando el CancelationToken utilizado y la necesidad de continuar en el mismo contexto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se esperaba, todo se hace de la manera m√°s perezosa posible. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n se muestra un ejemplo y la conclusi√≥n que √©l da.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); IAsyncEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; enumerable = AsyncYielding(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time after calling: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerable.WithCancellation(..).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"element: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{element}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> IAsyncEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncYielding</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uselessElement <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) { Task task = Task.Delay(TimeSpan.FromSeconds(uselessElement)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Task run: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{uselessElement}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> task; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uselessElement; } } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempo despu√©s de llamar: 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejecuci√≥n de tarea: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempo: 1033 Ejecuci√≥n de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tarea: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempo: 3034 Ejecuci√≥n de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tarea: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempo: 6035</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Threadpool </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta clase se usa activamente cuando se programa con TAP. Por lo tanto, dar√© los detalles m√≠nimos de su implementaci√≥n. En el interior, ThreadPool tiene una serie de colas: una para cada hilo + una global. Al agregar un nuevo trabajo al grupo, se tiene en cuenta el subproceso que inici√≥ la adici√≥n. En caso de que sea un subproceso del grupo, el trabajo se coloca en su propia cola de este subproceso, si era otro subproceso, en el global. Cuando se selecciona un subproceso para trabajar, primero se ve su cola local. Si est√° vac√≠o, el hilo toma trabajos del global. Si est√° vac√≠o, comienza a robar a los dem√°s. Adem√°s, nunca debe confiar en el orden del trabajo, porque, de hecho, no hay orden. El n√∫mero predeterminado de subprocesos en un grupo depende de muchos factores, incluido el tama√±o del espacio de direcciones. Si hay m√°s solicitudes de ejecuci√≥n,que el n√∫mero de subprocesos disponibles, las solicitudes est√°n en cola.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los subprocesos en un grupo de subprocesos son subprocesos en segundo plano (propiedad isBackground = true). </font><font style="vertical-align: inherit;">Este tipo de subproceso no es compatible con la vida del proceso si todos los subprocesos en primer plano se han completado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El subproceso del sistema supervisa el estado del controlador de espera. </font><font style="vertical-align: inherit;">Cuando finaliza la operaci√≥n de espera, la devoluci√≥n de llamada transferida es ejecutada por el subproceso del grupo (recuerde los archivos en Windows).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipo de tarea </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencionado anteriormente, este tipo (estructura o clase) puede usarse como el valor de retorno del m√©todo asincr√≥nico. </font><font style="vertical-align: inherit;">Un tipo de generador debe asociarse con este tipo utilizando el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atributo [AsyncMethodBuilder (..)]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este tipo debe tener las caracter√≠sticas mencionadas anteriormente para poder aplicarle la palabra clave de espera. </font><font style="vertical-align: inherit;">Puede parametrizarse para m√©todos que no devuelven un valor y parametrizarse para aquellos que devuelven. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El constructor en s√≠ es una clase o estructura cuyo marco se muestra en el siguiente ejemplo. </font><font style="vertical-align: inherit;">El m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene un par√°metro de tipo T para un tipo de tarea parametrizada por T. Para los tipos no parametrizados, el m√©todo no tiene par√°metros.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interfaz de generador requerida</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTaskMethodBuilder</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MyTaskMethodBuilder&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start&lt;TStateMachine&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetStateMachine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAsyncStateMachine stateMachine</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception exception</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T result</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : INotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : ICriticalNotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyTask&lt;T&gt; Task { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El principio del trabajo desde el punto de vista de escribir su tipo de tarea se describir√° a continuaci√≥n. La mayor parte de esto ya se ha descrito al analizar el c√≥digo generado por el compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El compilador utiliza todos estos tipos para generar una m√°quina de estados. El compilador sabe qu√© constructores usar para los tipos que conoce, aqu√≠ especificamos qu√© se usar√° durante la generaci√≥n del c√≥digo. Si la m√°quina de estado es una estructura, se empaquetar√° al llamar a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetStateMachine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el constructor puede almacenar en cach√© la copia empaquetada si es necesario. El constructor debe llamar a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o despu√©s de que se llame para iniciar la ejecuci√≥n y avanzar la m√°quina de estados. Despu√©s de llamar a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la propiedad Task se devolver√° del m√©todo. Le recomiendo que regrese al m√©todo de c√≥digo auxiliar y vea estos pasos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la m√°quina de estado se completa con √©xito, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llama al</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√©todo </font><i><font style="vertical-align: inherit;">SetResult</font></i><font style="vertical-align: inherit;"> ; de lo contrario, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si la m√°quina de estado llega a esperar, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejecuta el</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√©todo </font><i><font style="vertical-align: inherit;">GetAwaiter ()</font></i><font style="vertical-align: inherit;"> del </font><font style="vertical-align: inherit;">tipo de tarea. Si el objeto wait implementa la interfaz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICriticalNotifyCompletion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e IsCompleted = false, la m√°quina de estado usa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitUnsafeOnCompleted (ref camarero, ref stateMachine)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AwaitUnsafeOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deber√≠a llamar a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">waititer.OnCompleted (action)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la acci√≥n deber√≠a llamar a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando se completa el objeto de espera. </font><font style="vertical-align: inherit;">De manera similar para la interfaz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INotifyCompletion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y el m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥mo usar esto depende de usted. </font><font style="vertical-align: inherit;">Pero le aconsejo que piense 514 veces antes de aplicar esto en la producci√≥n, y no para mimarlo. </font><font style="vertical-align: inherit;">A continuaci√≥n se muestra un ejemplo de uso. </font><font style="vertical-align: inherit;">Esboc√© solo un proxy para un generador est√°ndar que muestra en la consola qu√© m√©todo se llam√≥ y a qu√© hora. </font><font style="vertical-align: inherit;">Por cierto, el Main () as√≠ncrono no quiere soportar un tipo de expectativa personalizada (creo que m√°s de un proyecto de producci√≥n se corrompi√≥ irremediablemente debido a este error de Microsoft). </font><font style="vertical-align: inherit;">Si lo desea, puede modificar el registrador proxy utilizando un registrador normal y registrando m√°s informaci√≥n.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarea Proxy de registro</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Start"</span></span>); JustMethod().Task.Wait(); <span class="hljs-comment"><span class="hljs-comment">//   Console.WriteLine("Stop"); } public static async LogTask JustMethod() { await DelayWrapper(1000); } public static LogTask DelayWrapper(int milliseconds) =&gt; new LogTask { Task = Task.Delay(milliseconds)}; } [AsyncMethodBuilder(typeof(LogMethodBuilder))] public class LogTask { public Task Task { get; set; } public TaskAwaiter GetAwaiter() =&gt; Task.GetAwaiter(); } public class LogMethodBuilder { private AsyncTaskMethodBuilder _methodBuilder = AsyncTaskMethodBuilder.Create(); private LogTask _task; public static LogMethodBuilder Create() { Console.WriteLine($"Method: Create; {DateTime.Now :O}"); return new LogMethodBuilder(); } public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: Start; {DateTime.Now :O}"); _methodBuilder.Start(ref stateMachine); } public void SetStateMachine(IAsyncStateMachine stateMachine) { Console.WriteLine($"Method: SetStateMachine; {DateTime.Now :O}"); _methodBuilder.SetStateMachine(stateMachine); } public void SetException(Exception exception) { Console.WriteLine($"Method: SetException; {DateTime.Now :O}"); _methodBuilder.SetException(exception); } public void SetResult() { Console.WriteLine($"Method: SetResult; {DateTime.Now :O}"); _methodBuilder.SetResult(); } public void AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine); } public void AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitUnsafeOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); } public LogTask Task { get { Console.WriteLine($"Property: Task; {DateTime.Now :O}"); return _task ??= new LogTask {Task = _methodBuilder.Task}; } set =&gt; _task = value; } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n: </font><i><font style="vertical-align: inherit;">M√©todo de </font></i></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicio </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Crear; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7152733 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo: Inicio; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7262226 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo: AwaitUnsafeOnCompleted; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7275206 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propiedad: Tarea; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7292005 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo: SetResult; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 14.7297967 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stop</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eso es todo, gracias a todos.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470830/">https://habr.com/ru/post/470830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470820/index.html">Una prueba r√°pida de docenas de hip√≥tesis: c√≥mo salimos de la rutina y tenemos una discusi√≥n en otra ciudad</a></li>
<li><a href="../470822/index.html">Monitoreo de temperatura en la empresa.</a></li>
<li><a href="../470824/index.html">Di√°logos sobre promesa</a></li>
<li><a href="../470826/index.html">Mineros, Diversers y Cobalt: c√≥mo brindamos a los clientes acceso seguro a Internet</a></li>
<li><a href="../470828/index.html">Lista enlazada de Python: gatos en cajas</a></li>
<li><a href="../470834/index.html">Modelos de superinfecci√≥n, antibi√≥ticos y apocalipsis zombie</a></li>
<li><a href="../470838/index.html">Seguridad de contenedores en CI / CD</a></li>
<li><a href="../470844/index.html">El nuevo proyecto de los hermanos Durov: Telegram Open Network</a></li>
<li><a href="../470852/index.html">Procesando 40 TB de c√≥digo de 10 millones de proyectos en un servidor dedicado con Go por $ 100</a></li>
<li><a href="../470856/index.html">Telegram GRAM Wallet: t√©rminos de servicio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>