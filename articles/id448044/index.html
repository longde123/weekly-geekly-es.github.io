<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéΩ ü•Ö üôåüèø Beberapa aspek pemantauan MS SQL Server. Rekomendasi untuk mengatur tanda jejak ü•ã ü§¢ ü§∏üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kata Pengantar 
 Cukup sering, pengguna, pengembang dan administrator MS SQL Server DBMS menghadapi masalah kinerja database atau DBMS secara umum, ol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beberapa aspek pemantauan MS SQL Server. Rekomendasi untuk mengatur tanda jejak</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448044/"><h3>  Kata Pengantar </h3><br>  Cukup sering, pengguna, pengembang dan administrator MS SQL Server DBMS menghadapi masalah kinerja database atau DBMS secara umum, oleh karena itu pemantauan MS SQL Server sangat relevan. <br><br>  Artikel ini adalah tambahan untuk artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan Zabbix untuk memonitor database MS SQL Server</a> dan akan memeriksa beberapa aspek pemantauan MS SQL Server, khususnya: cara cepat menentukan sumber daya apa yang hilang, serta rekomendasi untuk mengatur jejak jejak. <br><br>  Agar skrip berikut berfungsi, Anda harus membuat skema inf dalam database yang diinginkan sebagai berikut: <br><br><div class="spoiler">  <b class="spoiler_title">Membuat skema inf</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> &lt;_&gt;; go <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> inf;</code> </pre> </div></div><a name="habracut"></a><br><h3>  Metode untuk mendeteksi kekurangan RAM </h3><br>  Indikator pertama dari kurangnya RAM adalah kasus ketika sebuah instance dari MS SQL Server memakan semua RAM yang dialokasikan untuk itu. <br><br>  Untuk melakukan ini, buat tampilan inf.vRAM berikut: <br><br><div class="spoiler">  <b class="spoiler_title">Membuat Tampilan inf.vRAM</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vRAM] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.[TotalAvailOSRam_Mb] <span class="hljs-comment"><span class="hljs-comment">--       , a.[RAM_Avail_Percent] --     , a.[Server_physical_memory_Mb] --       , a.[SQL_server_committed_target_Mb] --     MS SQL Server   , a.[SQL_server_physical_memory_in_use_Mb] --    MS SQL Server       , a.[SQL_RAM_Avail_Percent] --    MS SQL Server      MS SQL Server , a.[StateMemorySQL] --    MS SQL Server , a.[SQL_RAM_Reserve_Percent] --    MS SQL Server     --     , (case when a.[RAM_Avail_Percent]&lt;10 and a.[RAM_Avail_Percent]&gt;5 and a.[TotalAvailOSRam_Mb]&lt;8192 then 'Warning' when a.[RAM_Avail_Percent]&lt;=5 and a.[TotalAvailOSRam_Mb]&lt;2048 then 'Danger' else 'Normal' end) as [StateMemoryServer] from ( select cast(a0.available_physical_memory_kb/1024.0 as int) as TotalAvailOSRam_Mb , cast((a0.available_physical_memory_kb/casT(a0.total_physical_memory_kb as float))*100 as numeric(5,2)) as [RAM_Avail_Percent] , a0.system_low_memory_signal_state , ceiling(b.physical_memory_kb/1024.0) as [Server_physical_memory_Mb] , ceiling(b.committed_target_kb/1024.0) as [SQL_server_committed_target_Mb] , ceiling(a.physical_memory_in_use_kb/1024.0) as [SQL_server_physical_memory_in_use_Mb] , cast(((b.committed_target_kb-a.physical_memory_in_use_kb)/casT(b.committed_target_kb as float))*100 as numeric(5,2)) as [SQL_RAM_Avail_Percent] , cast((b.committed_target_kb/casT(a0.total_physical_memory_kb as float))*100 as numeric(5,2)) as [SQL_RAM_Reserve_Percent] , (case when (ceiling(b.committed_target_kb/1024.0)-1024)&lt;ceiling(a.physical_memory_in_use_kb/1024.0) then 'Warning' else 'Normal' end) as [StateMemorySQL] from sys.dm_os_sys_memory as a0 cross join sys.dm_os_process_memory as a cross join sys.dm_os_sys_info as b cross join sys.dm_os_sys_memory as v ) as a;</span></span></code> </pre></div></div><br>  Kemudian Anda dapat menentukan bahwa instance MS SQL Server mengkonsumsi semua memori yang dialokasikan untuk itu oleh permintaan berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> SQL_server_physical_memory_in_use_Mb, SQL_server_committed_target_Mb <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vRAM];</code> </pre><br>  Jika indikator SQL_server_physical_memory_in_use_Mb terus-menerus tidak kurang dari SQL_server_committed_target_Mb, maka Anda perlu memeriksa statistik ekspektasi. <br><br>  Untuk menentukan kurangnya RAM melalui statistik ekspektasi, buat tampilan inf.vWaits: <br><br><div class="spoiler">  <b class="spoiler_title">Membuat Tampilan inf.vWaits</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> [Waits] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> [wait_type], <span class="hljs-comment"><span class="hljs-comment">--   [wait_time_ms] / 1000.0 AS [WaitS],--      .    signal_wait_time_ms ([wait_time_ms] - [signal_wait_time_ms]) / 1000.0 AS [ResourceS],--        signal_wait_time_ms [signal_wait_time_ms] / 1000.0 AS [SignalS],--           [waiting_tasks_count] AS [WaitCount],--   .         100.0 * [wait_time_ms] / SUM ([wait_time_ms]) OVER() AS [Percentage], ROW_NUMBER() OVER(ORDER BY [wait_time_ms] DESC) AS [RowNum] FROM sys.dm_os_wait_stats WHERE [waiting_tasks_count]&gt;0 and [wait_type] NOT IN ( N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP', N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE', N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE', N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE', N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE', N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX', N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE', N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE', N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP', N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH', N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP', N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY', N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK', N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP', N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES', N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT', N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN', N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT') ) , ress as ( SELECT [W1].[wait_type] AS [WaitType], CAST ([W1].[WaitS] AS DECIMAL (16, 2)) AS [Wait_S],--      .    signal_wait_time_ms CAST ([W1].[ResourceS] AS DECIMAL (16, 2)) AS [Resource_S],--        signal_wait_time_ms CAST ([W1].[SignalS] AS DECIMAL (16, 2)) AS [Signal_S],--           [W1].[WaitCount] AS [WaitCount],--   .         CAST ([W1].[Percentage] AS DECIMAL (5, 2)) AS [Percentage], CAST (([W1].[WaitS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgWait_S], CAST (([W1].[ResourceS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgRes_S], CAST (([W1].[SignalS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgSig_S] FROM [Waits] AS [W1] INNER JOIN [Waits] AS [W2] ON [W2].[RowNum] &lt;= [W1].[RowNum] GROUP BY [W1].[RowNum], [W1].[wait_type], [W1].[WaitS], [W1].[ResourceS], [W1].[SignalS], [W1].[WaitCount], [W1].[Percentage] HAVING SUM ([W2].[Percentage]) - [W1].[Percentage] &lt; 95 -- percentage threshold ) SELECT [WaitType] ,MAX([Wait_S]) as [Wait_S] ,MAX([Resource_S]) as [Resource_S] ,MAX([Signal_S]) as [Signal_S] ,MAX([WaitCount]) as [WaitCount] ,MAX([Percentage]) as [Percentage] ,MAX([AvgWait_S]) as [AvgWait_S] ,MAX([AvgRes_S]) as [AvgRes_S] ,MAX([AvgSig_S]) as [AvgSig_S] FROM ress group by [WaitType];</span></span></code> </pre></div></div><br>  Dalam hal ini, Anda dapat menentukan kekurangan RAM dengan kueri berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> [Percentage]      ,[AvgWait_S]  <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [inf].[vWaits]  <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre><br>  Di sini Anda perlu memperhatikan kinerja Persentase dan AvgWait_S.  Jika mereka signifikan dalam totalitasnya, maka ada kemungkinan yang sangat tinggi bahwa RAM tidak cukup untuk turunan MS SQL Server.  Nilai-nilai penting ditentukan secara individual untuk setiap sistem.  Namun, Anda dapat mulai dengan metrik berikut: Persentase&gt; = 1 dan AvgWait_S&gt; = 0,005. <br><br>  Untuk mengeluarkan indikator ke sistem pemantauan (misalnya, Zabbix), Anda dapat membuat dua pertanyaan berikut: <br><br><ol><li>  berapa persen dalam jenis ekspektasi untuk RAM yang ditempati (jumlah untuk semua jenis ekspektasi tersebut): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>([Percentage]), <span class="hljs-number"><span class="hljs-number">0.00</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Percentage] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre></li><li>  berapa milidetik jenis ekspektasi untuk RAM yang ditempati (nilai maksimum semua penundaan rata-rata untuk semua jenis ekspektasi semacam itu): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">max</span></span>([AvgWait_S])*<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [AvgWait_MS] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre></li></ol><br>  Berdasarkan dinamika nilai yang diperoleh untuk kedua indikator ini, kita dapat menyimpulkan apakah ada cukup RAM untuk instance MS SQL Server. <br><br><h3>  Metode deteksi kelebihan CPU </h3><br>  Untuk mengidentifikasi kurangnya waktu CPU, cukup gunakan tampilan sistem sys.dm_os_schedulers.  Di sini, jika indikator runnable_tasks_count secara konstan lebih besar dari 1, maka ada kemungkinan tinggi bahwa jumlah core tidak cukup untuk turunan MS SQL Server. <br><br>  Untuk menampilkan indikator dalam sistem pemantauan (misalnya, Zabbix), Anda dapat membuat kueri berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>([runnable_tasks_count]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [runnable_tasks_count] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.dm_os_schedulers <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduler_id&lt;<span class="hljs-number"><span class="hljs-number">255</span></span>;</code> </pre><br>  Berdasarkan dinamika nilai yang diperoleh untuk indikator ini, kita dapat menyimpulkan apakah ada cukup waktu prosesor (jumlah inti CPU) untuk instance MS SQL Server. <br>  Namun, penting untuk diingat bahwa permintaan itu sendiri dapat meminta banyak utas sekaligus.  Dan terkadang pengoptimal tidak dapat dengan benar menilai kompleksitas permintaan itu sendiri.  Kemudian permintaan tersebut dapat dialokasikan terlalu banyak utas yang pada waktu tertentu tidak dapat diproses secara bersamaan.  Dan ini juga menyebabkan jenis penantian yang terkait dengan kurangnya waktu prosesor, dan pertumbuhan antrian untuk penjadwal yang menggunakan inti CPU tertentu, mis., Indikator runnable_tasks_count akan tumbuh dalam kondisi seperti itu. <br><br>  Dalam hal ini, sebelum menambah jumlah core CPU, Anda harus mengkonfigurasi dengan benar properti paralelisme dari instance MS SQL Server, dan dari versi 2016, mengkonfigurasi dengan benar properti paralelisme dari database yang diperlukan: <br><br><img src="https://habrastorage.org/webt/iu/dz/ul/iudzulebjpipajxjwgxc9vkgoka.png"><br><br><img src="https://habrastorage.org/webt/7u/pk/qf/7upkqfeuffvrmi98yx5bid3h3wm.png"><br><br>  Ini ada baiknya memperhatikan parameter berikut: <br><br><ol><li>  Derajat Paralelisme Maks - menetapkan jumlah utas maksimum yang dapat dialokasikan untuk setiap permintaan (standarnya adalah 0-batasan hanya oleh sistem operasi dan edisi MS SQL Server) </li><li>  Ambang Biaya untuk Paralelisme - perkiraan biaya paralelisme (standarnya adalah 5) </li><li>  Max DOP-menetapkan jumlah maksimum utas yang dapat dialokasikan untuk setiap kueri di tingkat basis data (tetapi tidak lebih dari nilai properti "Derajat Paralelisme") (standarnya adalah pembatasan 0 hanya oleh sistem operasi dan edisi MS SQL Server, serta pembatasan pada properti "Max Degree of Parallelism" dari seluruh instance MS SQL Server) </li></ol><br>  Tidak mungkin untuk memberikan resep yang sama baiknya untuk semua kasus, yaitu, Anda perlu menganalisis permintaan yang sulit. <br><br>  Dari pengalaman saya sendiri, saya merekomendasikan algoritma tindakan berikut untuk sistem OLTP untuk mengkonfigurasi properti paralelisme: <br><br><ol><li>  pertama melarang konkurensi dengan menetapkan level seluruh instance Max Degree of Parallelism ke 1 </li><li>  menganalisis permintaan yang paling sulit dan memilih jumlah utas yang optimal untuknya </li><li>  atur Max Degree of Parallelism ke jumlah optimal utas yang diperoleh dari item 2, dan untuk database spesifik setel nilai DOP Max yang diperoleh dari item 2 untuk setiap database </li><li>  menganalisis permintaan yang paling sulit dan mengidentifikasi efek negatif dari multithreading.  Jika ya, maka tambahkan Ambang Biaya untuk Paralelisme. <br>  Untuk sistem seperti 1C, Microsoft CRM dan Microsoft NAV, dalam banyak kasus, larangan multithreading cocok. </li></ol><br>  Juga, jika edisi Standar diinstal, maka dalam banyak kasus larangan multithreading cocok mengingat fakta bahwa edisi ini dibatasi oleh jumlah inti CPU. <br><br>  Untuk sistem OLAP, algoritma yang dijelaskan di atas tidak cocok. <br><br>  Dari pengalaman saya sendiri, saya merekomendasikan algoritma tindakan berikut untuk sistem OLAP untuk mengatur properti paralelisme: <br><br><ol><li>  menganalisis permintaan yang paling sulit dan memilih jumlah utas yang optimal untuknya </li><li>  atur Max Degree of Parallelism ke jumlah optimal utas yang diperoleh dari item 1, dan juga untuk database spesifik atur nilai Max DOP yang diperoleh dari item 1 untuk setiap database </li><li>  menganalisis permintaan yang paling sulit dan mengidentifikasi efek negatif dari batas concurrency.  Jika ya, turunkan Nilai Ambang Batas untuk nilai Paralelisme, atau ulangi langkah 1-2 dari algoritme ini </li></ol><br>  Yaitu, untuk sistem OLTP kita beralih dari single-threaded ke multithreading, dan untuk sistem OLAP, sebaliknya, kita beralih dari multithreading ke single-threaded.  Dengan demikian, dimungkinkan untuk memilih pengaturan konkurensi optimal untuk database tertentu dan seluruh instance MS SQL Server. <br>  Penting juga untuk memahami bahwa pengaturan properti konkurensi perlu diubah dari waktu ke waktu berdasarkan hasil pemantauan kinerja MS SQL Server. <br><br><h3>  Rekomendasi untuk mengatur tanda jejak </h3><br>  Dari pengalaman saya sendiri dan pengalaman rekan-rekan saya, saya sarankan mengatur tanda jejak berikut di tingkat startup dari layanan MS SQL Server untuk versi 2008-2016 untuk kinerja yang optimal: <br><br><ol><li>  610 - Mengurangi penebangan sisipan dalam tabel yang diindeks.  Ini dapat membantu dengan memasukkan ke dalam tabel dengan sejumlah besar catatan dan banyak transaksi, dengan harapan panjang yang sering dari WRITELOG untuk perubahan indeks </li><li>  1117 - Jika file dalam filegroup memenuhi ambang pertumbuhan otomatis, semua file dalam filegroup diperluas </li><li>  1118 - Memaksa semua objek berada di luasan yang berbeda (melarang luasan campuran), yang meminimalkan kebutuhan untuk memindai halaman SGAM, yang digunakan untuk melacak luasan campuran </li><li>  1224 - Menonaktifkan eskalasi kunci berdasarkan jumlah kunci.  Penggunaan memori yang berlebihan dapat mencakup eskalasi kunci. </li><li>  2371 - Mengubah ambang batas untuk pembaruan statistik otomatis tetap ke ambang batas untuk pembaruan statistik otomatis dinamis.  Penting untuk memperbarui rencana kueri untuk tabel besar di mana salah menentukan jumlah catatan mengarah ke rencana eksekusi yang salah </li><li>  3226 - Menekan pesan cadangan yang berhasil di log kesalahan </li><li>  4199 - Termasuk perubahan pengoptimal kueri yang dirilis dalam pembaruan kumulatif dan paket layanan SQL Server </li><li>  6532-6534 - Termasuk peningkatan kinerja kueri untuk tipe data spasial </li><li>  8048 - Mengonversi NUMA objek memori yang dipartisi menjadi CPU yang dipartisi </li><li>  8780 - Mengaktifkan alokasi waktu tambahan untuk menjadwalkan permintaan.  Beberapa permintaan tanpa tanda ini mungkin ditolak karena tidak memiliki rencana permintaan (kesalahan yang sangat jarang terjadi) </li><li>  9389 - Termasuk dinamis tambahan yang disediakan sementara buffer memori untuk operator mode batch, yang memungkinkan operator mode batch untuk meminta memori tambahan dan menghindari transfer data ke tempdb jika memori tambahan tersedia </li></ol><br>  Sebelum versi 2016, penting untuk menyertakan jejak bendera 2301, yang mencakup optimalisasi dukungan keputusan yang diperluas dan dengan demikian membantu dalam memilih rencana kueri yang lebih benar.  Namun, dimulai dengan versi 2016, seringkali memiliki efek negatif dalam waktu eksekusi kueri keseluruhan yang cukup panjang. <br><br>  Juga untuk sistem di mana ada banyak indeks (misalnya, untuk database 1C), saya sarankan Anda mengaktifkan jejak flag 2330, yang menonaktifkan pengumpulan penggunaan indeks, yang umumnya memiliki efek positif pada sistem. <br><br>  Pelajari lebih lanjut tentang tanda jejak di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Menggunakan tautan di atas, penting juga untuk mempertimbangkan versi dan rakitan MS SQL Server, karena untuk versi yang lebih baru, beberapa flag trace diaktifkan secara default atau tidak berpengaruh.  Misalnya, dalam versi 2017, relevan untuk hanya menetapkan 5 tanda jejak berikut: 1224, 3226, 6534, 8780 dan 9389. <br><br>  Anda dapat mengaktifkan atau menonaktifkan tanda jejak menggunakan masing-masing perintah DBCC TRACEON dan DBCC TRACEOFF.  Lihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini untuk</a> detail lebih lanjut. <br><br>  Anda bisa mendapatkan status tanda jejak menggunakan perintah DBCC TRACESTATUS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">selengkapnya</a> . <br><br>  Agar tanda jejak disertakan dalam autorun layanan MS SQL Server, Anda harus masuk ke SQL Server Configuration Manager dan menambahkan tanda jejak ini di properti layanan melalui -T: <br><br><img src="https://habrastorage.org/webt/nt/oe/l7/ntoel7jpaujursvrp07tvcbnw80.png"><br><br><h3>  Ringkasan </h3><br>  Pada artikel ini, beberapa aspek pemantauan MS SQL Server diperiksa, dengan bantuan yang Anda dapat dengan cepat mengidentifikasi kurangnya waktu luang RAM dan CPU, serta sejumlah masalah lain yang kurang jelas.  Bendera jejak yang paling umum digunakan dipertimbangkan. <br><br><h3>  Sumber </h3><br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Statistik Siaga SQL Server</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Statistik ekspektasi SQL Server atau tolong beri tahu saya di tempat yang menyakitkan</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tampilan Sistem sys.dm_os_schedulers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan Zabbix untuk melacak basis data MS SQL Server</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gaya Hidup SQL</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lacak bendera</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sql.ru</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448044/">https://habr.com/ru/post/id448044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448032/index.html">Lebih banyak robot: Walmart memperkenalkan ribuan mesin untuk beroperasi di tokonya</a></li>
<li><a href="../id448034/index.html">Cari tugas dalam JIRA (bahasa sederhana). Bagian 1: Pencarian Cepat dan Dasar</a></li>
<li><a href="../id448036/index.html">Impor ke J. Connect dari file daftar pengguna melalui API</a></li>
<li><a href="../id448038/index.html">Fitur baru untuk penulis ekstensi di Visual Studio 2019 v.16.1</a></li>
<li><a href="../id448040/index.html">Intisari materi menarik untuk pengembang ponsel # 294 (pada 8-14 April)</a></li>
<li><a href="../id448046/index.html">Radio Day: paten Marconi dan Popov</a></li>
<li><a href="../id448048/index.html">Memahami Angular Ivy: DOM tambahan dan DOM Virtual</a></li>
<li><a href="../id448050/index.html">Amatir holografi - bahan perak halida</a></li>
<li><a href="../id448052/index.html">Mikrotik. IPSEC vpn untuk NAT sebagai klien</a></li>
<li><a href="../id448054/index.html">SciPy, optimisasi dengan kondisi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>