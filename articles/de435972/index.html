<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõë üôãüèø üç∑ Einf√ºhrung der reaktiven Programmierung im Fr√ºhjahr üë©üèø‚Äçü§ù‚Äçüë©üèΩ üèïÔ∏è üåî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Diese Woche erwarten wir ein neues Spring 5- Buch aus der Druckerei: 


 Unter den interessanten Merkmalen von Spring 5 verdient die re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung der reaktiven Programmierung im Fr√ºhjahr</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/435972/">  Hallo Habr! <br><br>  Diese Woche erwarten wir ein neues Spring 5- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch</a> aus der Druckerei: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/o3/tt/apo3ttu5x8fqhvkjyzyrj8g3m2s.jpeg"></div><br>  Unter den interessanten Merkmalen von Spring 5 verdient die reaktive Programmierung eine besondere Erw√§hnung, deren Implementierung in diesem Rahmen in dem vorgeschlagenen Artikel von Matt Raible kurz beschrieben wird.  In dem oben genannten Buch werden reaktive Muster in Kapitel 11 er√∂rtert. <br><br>  Matt wurde von Josh Long mitautorisiert, Autor eines weiteren gro√üartigen Buches √ºber Java und Fr√ºhling, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java in the Cloud</a> ", das im letzten Sommer ver√∂ffentlicht wurde. <br><a name="habracut"></a><br>  Reaktive Programmierung ist Ihr Weg, um Systeme zu erstellen, die gegen hohe Lasten best√§ndig sind.  Die Verarbeitung von gro√üem Datenverkehr ist kein Problem mehr, da der Server nicht blockiert und Client-Prozesse nicht auf Antworten warten m√ºssen.  Der Client kann nicht direkt beobachten, wie das Programm auf dem Server ausgef√ºhrt wird, und mit ihm synchronisieren.  Wenn die API Schwierigkeiten hat, Anforderungen zu verarbeiten, sollte sie dennoch angemessene Antworten geben.  Sollte Nachrichten nicht unkontrolliert ablehnen und verwerfen.  Es muss die h√∂heren Komponenten dar√ºber informieren, dass es unter Last arbeitet, damit sie es teilweise von dieser Last befreien k√∂nnen.  Diese Technik wird als Gegendruck bezeichnet, ein wichtiger Aspekt der reaktiven Programmierung. <br><br>  Wir haben diesen Artikel gemeinsam mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Josh Long verfasst</a> .  Josh ist ein Java-Champion, Spring Developer Advocate und im Allgemeinen ein globaler Mitarbeiter von Pivotal.  Ich habe lange mit Spring gearbeitet, aber es war Josh, der mir den Spring Boot zeigte, es war auf der Devoxx-Konferenz in Belgien.  Seitdem sind wir starke Freunde geworden, wir lieben Java und schreiben coole Anwendungen. <br><br>  <b>Reaktive Programmierung oder E / A, E / A, wir machen uns an die Arbeit ...</b> <br><br>  Reaktive Programmierung ist ein Ansatz zum Erstellen von Software, die aktiv asynchrone E / A verwendet.  Asynchrone E / A ist eine kleine Idee, die mit gro√üen √Ñnderungen in der Programmierung behaftet ist.  Die Idee selbst ist einfach: Die Situation mit der ineffizienten Zuweisung von Ressourcen zu korrigieren, die Ressourcen freizusetzen, die ohne unser Eingreifen nicht verf√ºgbar gewesen w√§ren, und auf den Abschluss von I / O zu warten.  Die asynchrone Eingabe / Ausgabe kehrt den √ºblichen Ansatz f√ºr die E / A-Verarbeitung um: Der Client wird freigegeben und kann andere Aufgaben ausf√ºhren und auf neue Benachrichtigungen warten. <br><br>  √úberlegen Sie, was zwischen synchroner und asynchroner Eingabe / Ausgabe gemeinsam ist und welche Unterschiede zwischen ihnen bestehen. <br><br>  Wir werden ein einfaches Programm schreiben, das Daten aus der Quelle liest (insbesondere sprechen wir √ºber den Link <code>java.io.File</code> ).  Beginnen wir mit einer Implementierung, die den guten alten <code>java.io.InputStream</code> : <br><br>  <i>Beispiel 1. Synchrones Lesen von Daten aus einer Datei</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Synchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; consumer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (FileInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file)) { <span class="hljs-comment"><span class="hljs-comment">//1 byte[] data = new byte[FileCopyUtils.BUFFER_SIZE]; int res; while ((res = in.read(data, 0, data.length)) != -1) { //2 consumer.accept(BytesPayload.from(data, res)); //3 } } } }</span></span></code> </pre> <br><ol><li>  Wir stellen eine Datei zum Lesen mit der √ºblichen <code>java.io.File</code> </li><li>  Ziehen Sie die Ergebnisse zeilenweise aus der Quelle ... </li><li>  Ich habe diesen Code geschrieben, um <code>Consumer&lt;BytesPayloadgt;</code>  wird aufgerufen, wenn neue Daten eintreffen </li></ol><br>  Einfach genug, was sagst du?  Wenn Sie diesen Code ausf√ºhren, wird in der Protokollausgabe (links von jeder Zeile) angezeigt, dass alle Aktionen in einem einzelnen Thread ausgef√ºhrt werden. <br>  Hier extrahieren wir Bytes aus unseren Daten aus der Quelle (in diesem Fall handelt es sich um eine Unterklasse von <code>java.io.FileInputStream</code> die von <code>java.io.InputStream</code> geerbt wurde).  Was ist falsch an diesem Beispiel?  In diesem Fall verwenden wir einen InputStream, der auf Daten in unserem Dateisystem verweist.  Wenn die Datei vorhanden ist und die Festplatte funktioniert, funktioniert dieser Code wie erwartet. <br><br>  Was passiert jedoch, wenn wir die Daten nicht aus der <code>File</code> , sondern aus einem Netzwerk-Socket lesen und eine andere Implementierung von <code>InputStream</code> ?  Kein Grund zur Sorge!  Nat√ºrlich gibt es absolut keinen Grund zur Sorge, wenn die Geschwindigkeit des Netzwerks unendlich hoch ist.  Und wenn der Netzwerkkanal zwischen diesem und dem anderen Knoten niemals ausf√§llt.  Wenn diese Bedingungen erf√ºllt sind, funktioniert der Code einwandfrei. <br><br>  Aber was passiert, wenn das Netzwerk langsamer wird oder sich hinlegt?  In diesem Fall meine ich, dass wir den Zeitraum verl√§ngern, bis die Operation <code>in.read(‚Ä¶)</code> .  Tats√§chlich kann sie √ºberhaupt nicht zur√ºckkommen!  Dies ist ein Problem, wenn wir versuchen, mit dem Stream, aus dem wir Daten lesen, etwas anderes zu tun.  Nat√ºrlich k√∂nnen Sie jederzeit einen anderen Stream erstellen und Daten darin lesen.  Dies kann bis zu einem gewissen Punkt geschehen, aber am Ende werden wir die Grenze erreichen, an der das einfache Hinzuf√ºgen von Threads zur weiteren Skalierung nicht mehr ausreicht.  Wir werden keine echte Konkurrenz haben, die √ºber die Anzahl der Kerne auf unserer Maschine hinausgeht.  Sackgasse!  In diesem Fall k√∂nnen wir die Eingabe- / Ausgabeverarbeitung (Lesen ist hier gemeint) nur aufgrund zus√§tzlicher Fl√ºsse erh√∂hen, aber hier werden wir fr√ºher oder sp√§ter das Limit erreichen. <br><br>  In diesem Beispiel ist das Hauptwerk das Lesen - an anderen Fronten passiert fast nichts.  Wir sind abh√§ngig von I / O.  √úberlegen Sie, wie eine asynchrone L√∂sung uns hilft, die Monopolisierung unserer Fl√ºsse teilweise zu √ºberwinden. <br><br>  <i>Beispiel 2. Asynchrones Lesen von Daten aus einer Datei</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.AsynchronousFileChannel; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.CompletionHandler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Path; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.StandardOpenOption; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Collections; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.ExecutorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Executors; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Asynchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletionHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteBuffer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> position; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AsynchronousFileChannel fileChannel; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Consumer&lt;BytesPayload&gt; consumer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.consumer = c; Path path = file.toPath(); <span class="hljs-comment"><span class="hljs-comment">// 1 this.fileChannel = AsynchronousFileChannel.open(path, Collections.singleton(StandardOpenOption.READ), this.executorService); //2 ByteBuffer buffer = ByteBuffer.allocate(FileCopyUtils.BUFFER_SIZE); this.fileChannel.read(buffer, position, buffer, this); //3 while (this.bytesRead &gt; 0) { this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } } @Override public void completed(Integer result, ByteBuffer buffer) { //4 this.bytesRead = result; if (this.bytesRead &lt; 0) return; buffer.flip(); byte[] data = new byte[buffer.limit()]; buffer.get(data); //5 consumer.accept(BytesPayload.from(data, data.length)); buffer.clear(); this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } @Override public void failed(Throwable exc, ByteBuffer attachment) { log.error(exc); } }</span></span></code> </pre> <br><ol><li>  Dieses Mal passen wir <code>java.io.File</code> und machen daraus <code>Java NIO java.nio.file.Path</code> </li><li>  Beim Erstellen eines <code>Channel</code> wir insbesondere den Dienst <code>java.util.concurrent.ExecutorService</code> an, mit dem der <code>CompletionHandler</code> Handler aufgerufen wird, wenn die erforderlichen Daten angezeigt werden </li><li>  Wir beginnen mit dem Lesen, indem wir einen Link zu <code>CompletionHandler&lt;Integer, ByteBuffer&gt; (this)</code> </li><li>  Lesen Sie im R√ºckruf die Bytes aus dem <code>ByteBuffer</code> in die <code>ByteBuffer</code> <code>byte[]</code> </li><li>  Genau wie im Beispiel " <code>Synchronous</code> werden <code>byte[]</code> -Daten an den Verbraucher √ºbergeben. </li></ol><br>  Wir werden sofort eine Reservierung vornehmen: Dieser Code erwies sich als viel schwieriger!  Hier ist so viel los, dass sich Ihr Kopf sofort dreht. Lassen Sie mich jedoch darauf hinweisen, dass dieser Code Daten aus dem <code>Java NIO Channel</code> liest und diese Daten dann in einem separaten Thread verarbeitet, der f√ºr R√ºckrufe verantwortlich ist.  Somit wird der Strom, in dem das Lesen begann, nicht monopolisiert.  Wir kehren fast sofort nach dem Aufruf von <code>.read(..)</code> , und wenn wir endlich die Daten zur Verf√ºgung haben, erfolgt ein R√ºckruf - bereits in einem anderen Thread.  Wenn zwischen den Aufrufen von <code>.read()</code> eine Verz√∂gerung <code>.read()</code> Sie zu anderen Themen <code>.read()</code> indem Sie sie in unserem Thread ausf√ºhren.  Die Dauer einer asynchronen Leseoperation vom ersten bis zum letzten Byte ist bestenfalls nicht l√§nger als die einer synchronen Leseoperation.  In der Regel ist eine asynchrone Operation nicht l√§nger.  Wenn wir jedoch zu solchen zus√§tzlichen Schwierigkeiten kommen, k√∂nnen wir unsere Str√∂me effektiver handhaben.  Machen Sie mehr Arbeit, multiplexen Sie E / A in einem Pool mit einer endlichen Anzahl von Threads. <br><br>  Ich arbeite f√ºr ein Cloud-Computing-Unternehmen.  Wir m√∂chten, dass Sie neue Instanzen der Anwendung erhalten, um Probleme mit der horizontalen Skalierung zu l√∂sen!  Nat√ºrlich bin ich hier etwas unaufrichtig.  Asynchrone E / A erschweren die Arbeit ein wenig, aber ich hoffe, dieses Beispiel zeigt, wie n√ºtzlich reaktiver Code ist: Sie k√∂nnen mehr Anforderungen verarbeiten und mehr an Ihrer vorhandenen Hardware arbeiten, wenn die Leistung stark von E / A abh√§ngt.  Wenn die Leistung von der Verwendung des Prozessors abh√§ngt (z. B. sprechen wir √ºber Operationen mit Fibonacci-Zahlen, das Mining von Bitcoins oder Kryptografie), gibt uns die reaktive Programmierung nichts. <br><br>  Derzeit verwenden die meisten von uns keine <code>Channel</code> oder <code>InputStream</code> Implementierungen in ihrer t√§glichen Arbeit!  Wir m√ºssen √ºber Probleme auf der Ebene h√∂herer Abstraktionen nachdenken.  Es geht um Dinge wie Arrays oder vielmehr die Hierarchie <code>java.util.Collection</code> .  Die Sammlung <code>java.util.Collection</code> wird in einem InputStream sehr gut angezeigt: Beide Entit√§ten gehen davon aus, dass Sie alle Daten gleichzeitig und fast sofort bearbeiten k√∂nnen.  Es wird erwartet, dass Sie das Lesen der meisten <code>InputStreams</code> eher fr√ºher als sp√§ter beenden k√∂nnen.  Sammlungstypen werden beim Verschieben auf gr√∂√üere Datenmengen etwas unangenehm.  Was ist, wenn Sie es mit etwas potenziell Unendlichem (Unbegrenztem) zu tun haben - zum Beispiel mit Web-Sockets oder Serverereignissen?  Was tun, wenn zwischen den Aufnahmen eine Verz√∂gerung auftritt? <br><br>  Wir brauchen einen besseren Weg, um diese Art von Daten zu beschreiben.  Wir sprechen von asynchronen Ereignissen, die am Ende auftreten werden.  Es mag scheinen, dass <code>Future&lt;T&gt;</code> oder <code>CompletableFuture&lt;T&gt;</code> f√ºr diesen Zweck gut geeignet sind, aber sie beschreiben nur eine Sache, die am Ende passiert.  Tats√§chlich bietet Java keine geeignete Metapher, um diese Art von Daten zu beschreiben.  Sowohl der <code>Iterator</code> als auch der <code>Stream</code> Typ von Java 8 sind m√∂glicherweise nicht miteinander verbunden. Beide sind jedoch auf Pull ausgerichtet.  Sie selbst fordern den n√§chsten Eintrag an, nicht der Typ sollte einen R√ºckruf an Ihren Code senden.  Es wird davon ausgegangen, dass, wenn in diesem Fall eine Push-basierte Verarbeitung unterst√ºtzt w√ºrde, die es erm√∂glichen w√ºrde, auf Thread-Ebene viel mehr zu erreichen, die API auch eine Threading- und Planungssteuerung bereitstellen w√ºrde.  <code>Iterator</code> Implementierungen sagen nichts √ºber das Threading aus, und alle Java 8-Threads verwenden denselben Fork-Join-Pool. <br><br>  Wenn <code>Iterator</code> und <code>Stream</code> die Push-Verarbeitung wirklich unterst√ºtzen w√ºrden, w√ºrden wir auf ein anderes Problem sto√üen, das sich gerade im Zusammenhang mit E / A wirklich versch√§rft: Wir brauchen eine Art R√ºckpenetrationsmechanismus!  Da der Datenkonsument asynchron verarbeitet wird, wissen wir nicht, wann und in welcher Menge die Daten in der Pipeline sind.  Wir wissen nicht, wie viele Daten beim n√§chsten R√ºckruf verarbeitet werden m√ºssen: ein Byte oder ein Terabyte! <br><br>  Wenn Sie Daten aus einem <code>InputStream</code> , lesen Sie so viele Informationen, wie Sie verarbeiten <code>InputStream</code> , und nicht mehr.  In den vorherigen Beispielen lesen wir Daten mit einer festen und bekannten L√§nge in den <code>byte[]</code> -Puffer.  In einem asynchronen Kontext m√ºssen wir dem Anbieter eine M√∂glichkeit mitteilen, wie viele Daten wir verarbeiten m√∂chten. <br>  Ja, Sir.  Hier fehlt sicher etwas. <br><br>  <b>Suche nach der fehlenden Metapher</b> <br><br>  In diesem Fall suchen wir nach einer Metapher, die das Wesen der asynchronen E / A auf wunderbare Weise widerspiegelt, einen solchen Mechanismus f√ºr die umgekehrte Daten√ºbertragung unterst√ºtzt und es uns erm√∂glicht, den Ausf√ºhrungsfluss in verteilten Systemen zu steuern.  Bei der reaktiven Programmierung wird die F√§higkeit eines Clients, zu signalisieren, welche Last er bew√§ltigen kann, als "R√ºckfluss" bezeichnet. <br><br>  Jetzt gibt es eine Reihe guter Projekte - Vert.x, Akka Streams und RxJava -, die reaktive Programmierung unterst√ºtzen.  Das Spring-Team f√ºhrt auch ein Projekt namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reactor durch</a> .  Zwischen diesen verschiedenen Standards gibt es ein ziemlich breites allgemeines Feld, das de facto dem Standard der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reactive Streams-Initiative zugeordnet ist</a> .  Die Initiative Reactive Streams definiert vier Typen: <br><br>  <code>Publisher&lt;T&amp;gt</code> Schnittstelle <code>Publisher&lt;T&amp;gt</code> ;  erzeugt Werte, die letztendlich eintreffen k√∂nnen.  <code>Publisher&lt;T&amp;gt</code> Schnittstelle <code>Publisher&lt;T&amp;gt</code> ;  erzeugt Werte vom Typ <code>T</code> f√ºr <code>Subscriber&lt;T&gt;</code> . <br><br>  <i>Beispiel 3. Reaktive Streams: <code>Publisher&lt;T&gt;</code> -Schnittstelle</i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tgt; s)</span></span></span></span>; }</code> </pre> <br>  Der <code>Subscriber</code> abonniert <code>Publisher&lt;T&gt;</code> und erh√§lt √ºber seine <code>onNext(T)</code> -Methode Benachrichtigungen √ºber neue Werte vom Typ <code>T</code>  Wenn Fehler auftreten, wird die Methode <code>onError(Throwable)</code> .  Wenn die Verarbeitung normal abgeschlossen ist, wird die <code>onComplete</code> Methode des Teilnehmers aufgerufen. <br><br>  <i>Beispiel 4. Jetstreams: <code>Subscriber&lt;T&gt;</code> -Schnittstelle.</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Wenn der <code>Subscriber</code> ersten Mal eine Verbindung zu <code>Publisher</code> , erh√§lt er ein <code>Subscription</code> in der <code>Subscriber#onSubscribe</code> .  Abonnement Das <code>Subscription</code> ist m√∂glicherweise der wichtigste Teil der gesamten Spezifikation.  sie ist es, die den R√ºckfluss liefert.  Ein Abonnent-Abonnent verwendet die <code>Subscription#request</code> , um zus√§tzliche Daten anzufordern, oder die <code>Subscription#cancel</code> , um die Verarbeitung zu beenden. <br><br>  <i>Beispiel 5. Reaktive Streams: <code>Subscription&lt;T&gt;</code> -Schnittstelle</i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Die reaktive Stream-Spezifikation bietet einen weiteren n√ºtzlichen, wenn auch offensichtlichen Typ: <code>Processor&lt;A,B&gt;</code> ist nur eine Schnittstelle, die sowohl <code>Subscriber&lt;A&gt;</code> als auch <code>Publisher&lt;B&gt;</code> erbt. <br><br>  <i>Beispiel 6. Jetstreams: <code>Processor&lt;T&gt;</code> -Schnittstelle</i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ltT</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Eine Spezifikation ist nicht als Rezept f√ºr Implementierungen positioniert. Tats√§chlich besteht ihr Zweck darin, Typen zu definieren, um die Interoperabilit√§t zu unterst√ºtzen.  Der offensichtliche Vorteil von Typen, die mit reaktiven Flows verbunden sind, besteht darin, dass sie dennoch einen Platz in der Java 9-Version gefunden haben. Au√üerdem sind sie semantisch ‚Äûeins zu eins‚Äú und entsprechen Schnittstellen der Klasse <code>java.util.concurrent.Flow</code> , zum Beispiel: <code>java.util.concurrent.Flow.Publisher</code> . <br><br>  <b>Treffen Sie Reactor</b> <br><br>  Arten von reaktiven Str√∂men allein reichen nicht aus;  Implementierungen h√∂herer Ordnung sind erforderlich, um Operationen wie Filtern und Transformieren zu unterst√ºtzen.  Als solches ist das Reaktorprojekt praktisch;  Es baut auf der Reactive Streams-Spezifikation auf und bietet zwei <code>Publisher&lt;T&gt;</code> -Spezialisierungen. <br><br>  Erstens ist <code>Flux&lt;T&gt;</code> ein <code>Publisher</code> , der null oder mehr Werte erzeugt.  Das zweite, <code>Mono&lt;T&gt;</code> , ist <code>Publisher&lt;T&gt;</code> und erzeugt null oder einen Wert.  Beide ver√∂ffentlichen Werte und k√∂nnen sie entsprechend behandeln. Ihre Funktionen sind jedoch viel umfassender als die der Reactive Streams-Spezifikation.  Beide bieten Operatoren, mit denen Sie Wertstr√∂me verarbeiten k√∂nnen.  Reaktortypen lassen sich gut zusammensetzen - die Ausgabe eines von ihnen kann als Eingabe f√ºr den anderen dienen, und wenn ein Typ mit anderen Datenstr√∂men arbeiten muss, sind sie auf <code>Publisher&lt;T&gt;</code> -Instanzen angewiesen. <br><br>  Sowohl <code>Mono&lt;T&gt;</code> als auch <code>Flux&lt;T&gt;</code> implementieren <code>Publisher&lt;T&gt;</code> .  Wir empfehlen, dass Ihre Methoden <code>Publisher&lt;T&gt;</code> -Instanzen akzeptieren, aber <code>Flux&lt;T&gt;</code> oder <code>Mono&lt;T&gt;</code> .  Dies hilft dem Kunden zu unterscheiden, welche Art von Daten er erh√§lt. <br><br>  Angenommen, Sie haben <code>Publisher&lt;T&gt;</code> und wurden aufgefordert, die Benutzeroberfl√§che f√ºr diesen <code>Publisher&lt;T&gt;</code> anzuzeigen.  Sollte ich dann eine Seite mit Details f√ºr einen Datensatz anzeigen, da Sie <code>CompletableFuture&lt;T&gt;</code> ?  Oder eine √úbersichtsseite mit einer Liste oder einem Raster anzeigen, auf der alle Eintr√§ge Seite f√ºr Seite angezeigt werden?  Es ist schwer zu sagen. <br><br>  <code>Flux&lt;T&gt;</code> und <code>Mono&lt;T&gt;</code> sehr spezifisch.  Sie wissen, dass Sie eine √úberpr√ºfungsseite anzeigen m√ºssen, wenn <code>Flux&lt;T&gt;</code> empfangen wird, und eine Seite mit Details f√ºr einen (oder keinen einzelnen) Datensatz, wenn Sie <code>Mono&lt;T&gt;</code> empfangen. <br><br>  Reactor ist ein Open-Source-Projekt von Pivotal.  Jetzt ist er sehr beliebt geworden.  Facebook verwendet es in seinem D√ºsentriebwerk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um Remote-Prozeduren aufzurufen</a> , und verwendet es auch in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rsocket</a> , das vom RxJava-Erfinder Ben Christensen geleitet wird.  Salesforce verwendet es in seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reaktiven gRPC-Implementierung</a> .  Reactor implementiert reaktive Streams-Typen, sodass es mit anderen Technologien interagieren kann, die diese Typen unterst√ºtzen, z. B. mit <a href="">RxJava 2</a> von Netflix, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akka Streams</a> von Lightbend und mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vert.x-</a> Projekt von Eclipse Foundation.  David Cairnock, Direktor von RxJava 2, arbeitete auch aktiv mit Pivotal zusammen, um Reactor zu entwickeln und das Projekt noch besser zu machen.  Au√üerdem ist es nat√ºrlich in der einen oder anderen Form im Spring Framework vorhanden, beginnend mit Spring Framework 4.0. <br><br>  <b>Reaktive Programmierung mit Spring WebFlux</b> <br><br>  Bei aller N√ºtzlichkeit ist der Reaktor nur die Basis.  Unsere Anwendungen m√ºssen mit Datenquellen kommunizieren.  Muss Authentifizierung und Autorisierung unterst√ºtzen.  Der Fr√ºhling bietet all dies.  Wenn Reactor uns die fehlende Metapher gibt, hilft uns der Fr√ºhling alle, eine gemeinsame Sprache zu sprechen. <br><br>  Spring Framework 5.0 wurde im September 2017 ver√∂ffentlicht. Es baut auf der Reactor- und der Reactive Streams-Spezifikation auf.  Es verf√ºgt √ºber ein neues reaktives Laufzeit- und Komponentenmodell namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring WebFlux</a> . <br><br>  Spring WebFlux ist unabh√§ngig von der Servlet-API und erfordert keine Funktion.  Es wird mit Adaptern geliefert, mit denen Sie es bei Bedarf √ºber dem Servlet-Motor verwenden k√∂nnen. Dies ist jedoch nicht erforderlich.  Es bietet auch eine v√∂llig neue Netty-basierte Laufzeit namens Spring WebFlux.  Spring Framework 5, das mit Java 8 und Java EE 7 und h√∂her arbeitet, dient jetzt als Grundlage f√ºr einen Gro√üteil des Spring-√ñkosystems, einschlie√ülich Spring Data Kay, Spring Security 5, Spring Boot 2 und Spring Cloud Finchley. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435972/">https://habr.com/ru/post/de435972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435960/index.html">Gedankenexperiment: Flattern unterwegs</a></li>
<li><a href="../de435962/index.html">25 Jahre Aeron: Sensationen und Eindr√ºcke der aktualisierten Version von Aeron Remastered</a></li>
<li><a href="../de435964/index.html">Ethereum plant, 99% wirtschaftlicher zu sein</a></li>
<li><a href="../de435968/index.html">√úbersicht √ºber Deep Machine Learning-Algorithmen f√ºr Roboter</a></li>
<li><a href="../de435970/index.html">Anf√§ngerhandbuch zur Webserverentwicklung mit Node.js.</a></li>
<li><a href="../de435974/index.html">Three.js - Steuerelemente f√ºr Weltraum oder Planetarium</a></li>
<li><a href="../de435976/index.html">WebAssembly in der Produktion und das ‚ÄûMinenfeld‚Äú von Smart TV: ein Interview mit Andrei Nagih</a></li>
<li><a href="../de435978/index.html">Problemumgehungen f√ºr den biometrischen Schutz</a></li>
<li><a href="../de435984/index.html">Neuronale Netze und Sprachphilosophie</a></li>
<li><a href="../de435986/index.html">Windows reserviert 7 GB f√ºr Systemaktualisierungen, um zu vermeiden, dass der Festplattenspeicher knapp wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>