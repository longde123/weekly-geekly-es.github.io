<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛑 🙋🏿 🍷 Einführung der reaktiven Programmierung im Frühjahr 👩🏿‍🤝‍👩🏽 🏕️ 🌔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Diese Woche erwarten wir ein neues Spring 5- Buch aus der Druckerei: 


 Unter den interessanten Merkmalen von Spring 5 verdient die re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung der reaktiven Programmierung im Frühjahr</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/435972/">  Hallo Habr! <br><br>  Diese Woche erwarten wir ein neues Spring 5- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch</a> aus der Druckerei: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/o3/tt/apo3ttu5x8fqhvkjyzyrj8g3m2s.jpeg"></div><br>  Unter den interessanten Merkmalen von Spring 5 verdient die reaktive Programmierung eine besondere Erwähnung, deren Implementierung in diesem Rahmen in dem vorgeschlagenen Artikel von Matt Raible kurz beschrieben wird.  In dem oben genannten Buch werden reaktive Muster in Kapitel 11 erörtert. <br><br>  Matt wurde von Josh Long mitautorisiert, Autor eines weiteren großartigen Buches über Java und Frühling, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java in the Cloud</a> ", das im letzten Sommer veröffentlicht wurde. <br><a name="habracut"></a><br>  Reaktive Programmierung ist Ihr Weg, um Systeme zu erstellen, die gegen hohe Lasten beständig sind.  Die Verarbeitung von großem Datenverkehr ist kein Problem mehr, da der Server nicht blockiert und Client-Prozesse nicht auf Antworten warten müssen.  Der Client kann nicht direkt beobachten, wie das Programm auf dem Server ausgeführt wird, und mit ihm synchronisieren.  Wenn die API Schwierigkeiten hat, Anforderungen zu verarbeiten, sollte sie dennoch angemessene Antworten geben.  Sollte Nachrichten nicht unkontrolliert ablehnen und verwerfen.  Es muss die höheren Komponenten darüber informieren, dass es unter Last arbeitet, damit sie es teilweise von dieser Last befreien können.  Diese Technik wird als Gegendruck bezeichnet, ein wichtiger Aspekt der reaktiven Programmierung. <br><br>  Wir haben diesen Artikel gemeinsam mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Josh Long verfasst</a> .  Josh ist ein Java-Champion, Spring Developer Advocate und im Allgemeinen ein globaler Mitarbeiter von Pivotal.  Ich habe lange mit Spring gearbeitet, aber es war Josh, der mir den Spring Boot zeigte, es war auf der Devoxx-Konferenz in Belgien.  Seitdem sind wir starke Freunde geworden, wir lieben Java und schreiben coole Anwendungen. <br><br>  <b>Reaktive Programmierung oder E / A, E / A, wir machen uns an die Arbeit ...</b> <br><br>  Reaktive Programmierung ist ein Ansatz zum Erstellen von Software, die aktiv asynchrone E / A verwendet.  Asynchrone E / A ist eine kleine Idee, die mit großen Änderungen in der Programmierung behaftet ist.  Die Idee selbst ist einfach: Die Situation mit der ineffizienten Zuweisung von Ressourcen zu korrigieren, die Ressourcen freizusetzen, die ohne unser Eingreifen nicht verfügbar gewesen wären, und auf den Abschluss von I / O zu warten.  Die asynchrone Eingabe / Ausgabe kehrt den üblichen Ansatz für die E / A-Verarbeitung um: Der Client wird freigegeben und kann andere Aufgaben ausführen und auf neue Benachrichtigungen warten. <br><br>  Überlegen Sie, was zwischen synchroner und asynchroner Eingabe / Ausgabe gemeinsam ist und welche Unterschiede zwischen ihnen bestehen. <br><br>  Wir werden ein einfaches Programm schreiben, das Daten aus der Quelle liest (insbesondere sprechen wir über den Link <code>java.io.File</code> ).  Beginnen wir mit einer Implementierung, die den guten alten <code>java.io.InputStream</code> : <br><br>  <i>Beispiel 1. Synchrones Lesen von Daten aus einer Datei</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Synchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; consumer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (FileInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file)) { <span class="hljs-comment"><span class="hljs-comment">//1 byte[] data = new byte[FileCopyUtils.BUFFER_SIZE]; int res; while ((res = in.read(data, 0, data.length)) != -1) { //2 consumer.accept(BytesPayload.from(data, res)); //3 } } } }</span></span></code> </pre> <br><ol><li>  Wir stellen eine Datei zum Lesen mit der üblichen <code>java.io.File</code> </li><li>  Ziehen Sie die Ergebnisse zeilenweise aus der Quelle ... </li><li>  Ich habe diesen Code geschrieben, um <code>Consumer&lt;BytesPayloadgt;</code>  wird aufgerufen, wenn neue Daten eintreffen </li></ol><br>  Einfach genug, was sagst du?  Wenn Sie diesen Code ausführen, wird in der Protokollausgabe (links von jeder Zeile) angezeigt, dass alle Aktionen in einem einzelnen Thread ausgeführt werden. <br>  Hier extrahieren wir Bytes aus unseren Daten aus der Quelle (in diesem Fall handelt es sich um eine Unterklasse von <code>java.io.FileInputStream</code> die von <code>java.io.InputStream</code> geerbt wurde).  Was ist falsch an diesem Beispiel?  In diesem Fall verwenden wir einen InputStream, der auf Daten in unserem Dateisystem verweist.  Wenn die Datei vorhanden ist und die Festplatte funktioniert, funktioniert dieser Code wie erwartet. <br><br>  Was passiert jedoch, wenn wir die Daten nicht aus der <code>File</code> , sondern aus einem Netzwerk-Socket lesen und eine andere Implementierung von <code>InputStream</code> ?  Kein Grund zur Sorge!  Natürlich gibt es absolut keinen Grund zur Sorge, wenn die Geschwindigkeit des Netzwerks unendlich hoch ist.  Und wenn der Netzwerkkanal zwischen diesem und dem anderen Knoten niemals ausfällt.  Wenn diese Bedingungen erfüllt sind, funktioniert der Code einwandfrei. <br><br>  Aber was passiert, wenn das Netzwerk langsamer wird oder sich hinlegt?  In diesem Fall meine ich, dass wir den Zeitraum verlängern, bis die Operation <code>in.read(…)</code> .  Tatsächlich kann sie überhaupt nicht zurückkommen!  Dies ist ein Problem, wenn wir versuchen, mit dem Stream, aus dem wir Daten lesen, etwas anderes zu tun.  Natürlich können Sie jederzeit einen anderen Stream erstellen und Daten darin lesen.  Dies kann bis zu einem gewissen Punkt geschehen, aber am Ende werden wir die Grenze erreichen, an der das einfache Hinzufügen von Threads zur weiteren Skalierung nicht mehr ausreicht.  Wir werden keine echte Konkurrenz haben, die über die Anzahl der Kerne auf unserer Maschine hinausgeht.  Sackgasse!  In diesem Fall können wir die Eingabe- / Ausgabeverarbeitung (Lesen ist hier gemeint) nur aufgrund zusätzlicher Flüsse erhöhen, aber hier werden wir früher oder später das Limit erreichen. <br><br>  In diesem Beispiel ist das Hauptwerk das Lesen - an anderen Fronten passiert fast nichts.  Wir sind abhängig von I / O.  Überlegen Sie, wie eine asynchrone Lösung uns hilft, die Monopolisierung unserer Flüsse teilweise zu überwinden. <br><br>  <i>Beispiel 2. Asynchrones Lesen von Daten aus einer Datei</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.AsynchronousFileChannel; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.CompletionHandler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Path; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.StandardOpenOption; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Collections; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.ExecutorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Executors; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Asynchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletionHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteBuffer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> position; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AsynchronousFileChannel fileChannel; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Consumer&lt;BytesPayload&gt; consumer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.consumer = c; Path path = file.toPath(); <span class="hljs-comment"><span class="hljs-comment">// 1 this.fileChannel = AsynchronousFileChannel.open(path, Collections.singleton(StandardOpenOption.READ), this.executorService); //2 ByteBuffer buffer = ByteBuffer.allocate(FileCopyUtils.BUFFER_SIZE); this.fileChannel.read(buffer, position, buffer, this); //3 while (this.bytesRead &gt; 0) { this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } } @Override public void completed(Integer result, ByteBuffer buffer) { //4 this.bytesRead = result; if (this.bytesRead &lt; 0) return; buffer.flip(); byte[] data = new byte[buffer.limit()]; buffer.get(data); //5 consumer.accept(BytesPayload.from(data, data.length)); buffer.clear(); this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } @Override public void failed(Throwable exc, ByteBuffer attachment) { log.error(exc); } }</span></span></code> </pre> <br><ol><li>  Dieses Mal passen wir <code>java.io.File</code> und machen daraus <code>Java NIO java.nio.file.Path</code> </li><li>  Beim Erstellen eines <code>Channel</code> wir insbesondere den Dienst <code>java.util.concurrent.ExecutorService</code> an, mit dem der <code>CompletionHandler</code> Handler aufgerufen wird, wenn die erforderlichen Daten angezeigt werden </li><li>  Wir beginnen mit dem Lesen, indem wir einen Link zu <code>CompletionHandler&lt;Integer, ByteBuffer&gt; (this)</code> </li><li>  Lesen Sie im Rückruf die Bytes aus dem <code>ByteBuffer</code> in die <code>ByteBuffer</code> <code>byte[]</code> </li><li>  Genau wie im Beispiel " <code>Synchronous</code> werden <code>byte[]</code> -Daten an den Verbraucher übergeben. </li></ol><br>  Wir werden sofort eine Reservierung vornehmen: Dieser Code erwies sich als viel schwieriger!  Hier ist so viel los, dass sich Ihr Kopf sofort dreht. Lassen Sie mich jedoch darauf hinweisen, dass dieser Code Daten aus dem <code>Java NIO Channel</code> liest und diese Daten dann in einem separaten Thread verarbeitet, der für Rückrufe verantwortlich ist.  Somit wird der Strom, in dem das Lesen begann, nicht monopolisiert.  Wir kehren fast sofort nach dem Aufruf von <code>.read(..)</code> , und wenn wir endlich die Daten zur Verfügung haben, erfolgt ein Rückruf - bereits in einem anderen Thread.  Wenn zwischen den Aufrufen von <code>.read()</code> eine Verzögerung <code>.read()</code> Sie zu anderen Themen <code>.read()</code> indem Sie sie in unserem Thread ausführen.  Die Dauer einer asynchronen Leseoperation vom ersten bis zum letzten Byte ist bestenfalls nicht länger als die einer synchronen Leseoperation.  In der Regel ist eine asynchrone Operation nicht länger.  Wenn wir jedoch zu solchen zusätzlichen Schwierigkeiten kommen, können wir unsere Ströme effektiver handhaben.  Machen Sie mehr Arbeit, multiplexen Sie E / A in einem Pool mit einer endlichen Anzahl von Threads. <br><br>  Ich arbeite für ein Cloud-Computing-Unternehmen.  Wir möchten, dass Sie neue Instanzen der Anwendung erhalten, um Probleme mit der horizontalen Skalierung zu lösen!  Natürlich bin ich hier etwas unaufrichtig.  Asynchrone E / A erschweren die Arbeit ein wenig, aber ich hoffe, dieses Beispiel zeigt, wie nützlich reaktiver Code ist: Sie können mehr Anforderungen verarbeiten und mehr an Ihrer vorhandenen Hardware arbeiten, wenn die Leistung stark von E / A abhängt.  Wenn die Leistung von der Verwendung des Prozessors abhängt (z. B. sprechen wir über Operationen mit Fibonacci-Zahlen, das Mining von Bitcoins oder Kryptografie), gibt uns die reaktive Programmierung nichts. <br><br>  Derzeit verwenden die meisten von uns keine <code>Channel</code> oder <code>InputStream</code> Implementierungen in ihrer täglichen Arbeit!  Wir müssen über Probleme auf der Ebene höherer Abstraktionen nachdenken.  Es geht um Dinge wie Arrays oder vielmehr die Hierarchie <code>java.util.Collection</code> .  Die Sammlung <code>java.util.Collection</code> wird in einem InputStream sehr gut angezeigt: Beide Entitäten gehen davon aus, dass Sie alle Daten gleichzeitig und fast sofort bearbeiten können.  Es wird erwartet, dass Sie das Lesen der meisten <code>InputStreams</code> eher früher als später beenden können.  Sammlungstypen werden beim Verschieben auf größere Datenmengen etwas unangenehm.  Was ist, wenn Sie es mit etwas potenziell Unendlichem (Unbegrenztem) zu tun haben - zum Beispiel mit Web-Sockets oder Serverereignissen?  Was tun, wenn zwischen den Aufnahmen eine Verzögerung auftritt? <br><br>  Wir brauchen einen besseren Weg, um diese Art von Daten zu beschreiben.  Wir sprechen von asynchronen Ereignissen, die am Ende auftreten werden.  Es mag scheinen, dass <code>Future&lt;T&gt;</code> oder <code>CompletableFuture&lt;T&gt;</code> für diesen Zweck gut geeignet sind, aber sie beschreiben nur eine Sache, die am Ende passiert.  Tatsächlich bietet Java keine geeignete Metapher, um diese Art von Daten zu beschreiben.  Sowohl der <code>Iterator</code> als auch der <code>Stream</code> Typ von Java 8 sind möglicherweise nicht miteinander verbunden. Beide sind jedoch auf Pull ausgerichtet.  Sie selbst fordern den nächsten Eintrag an, nicht der Typ sollte einen Rückruf an Ihren Code senden.  Es wird davon ausgegangen, dass, wenn in diesem Fall eine Push-basierte Verarbeitung unterstützt würde, die es ermöglichen würde, auf Thread-Ebene viel mehr zu erreichen, die API auch eine Threading- und Planungssteuerung bereitstellen würde.  <code>Iterator</code> Implementierungen sagen nichts über das Threading aus, und alle Java 8-Threads verwenden denselben Fork-Join-Pool. <br><br>  Wenn <code>Iterator</code> und <code>Stream</code> die Push-Verarbeitung wirklich unterstützen würden, würden wir auf ein anderes Problem stoßen, das sich gerade im Zusammenhang mit E / A wirklich verschärft: Wir brauchen eine Art Rückpenetrationsmechanismus!  Da der Datenkonsument asynchron verarbeitet wird, wissen wir nicht, wann und in welcher Menge die Daten in der Pipeline sind.  Wir wissen nicht, wie viele Daten beim nächsten Rückruf verarbeitet werden müssen: ein Byte oder ein Terabyte! <br><br>  Wenn Sie Daten aus einem <code>InputStream</code> , lesen Sie so viele Informationen, wie Sie verarbeiten <code>InputStream</code> , und nicht mehr.  In den vorherigen Beispielen lesen wir Daten mit einer festen und bekannten Länge in den <code>byte[]</code> -Puffer.  In einem asynchronen Kontext müssen wir dem Anbieter eine Möglichkeit mitteilen, wie viele Daten wir verarbeiten möchten. <br>  Ja, Sir.  Hier fehlt sicher etwas. <br><br>  <b>Suche nach der fehlenden Metapher</b> <br><br>  In diesem Fall suchen wir nach einer Metapher, die das Wesen der asynchronen E / A auf wunderbare Weise widerspiegelt, einen solchen Mechanismus für die umgekehrte Datenübertragung unterstützt und es uns ermöglicht, den Ausführungsfluss in verteilten Systemen zu steuern.  Bei der reaktiven Programmierung wird die Fähigkeit eines Clients, zu signalisieren, welche Last er bewältigen kann, als "Rückfluss" bezeichnet. <br><br>  Jetzt gibt es eine Reihe guter Projekte - Vert.x, Akka Streams und RxJava -, die reaktive Programmierung unterstützen.  Das Spring-Team führt auch ein Projekt namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reactor durch</a> .  Zwischen diesen verschiedenen Standards gibt es ein ziemlich breites allgemeines Feld, das de facto dem Standard der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reactive Streams-Initiative zugeordnet ist</a> .  Die Initiative Reactive Streams definiert vier Typen: <br><br>  <code>Publisher&lt;T&amp;gt</code> Schnittstelle <code>Publisher&lt;T&amp;gt</code> ;  erzeugt Werte, die letztendlich eintreffen können.  <code>Publisher&lt;T&amp;gt</code> Schnittstelle <code>Publisher&lt;T&amp;gt</code> ;  erzeugt Werte vom Typ <code>T</code> für <code>Subscriber&lt;T&gt;</code> . <br><br>  <i>Beispiel 3. Reaktive Streams: <code>Publisher&lt;T&gt;</code> -Schnittstelle</i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tgt; s)</span></span></span></span>; }</code> </pre> <br>  Der <code>Subscriber</code> abonniert <code>Publisher&lt;T&gt;</code> und erhält über seine <code>onNext(T)</code> -Methode Benachrichtigungen über neue Werte vom Typ <code>T</code>  Wenn Fehler auftreten, wird die Methode <code>onError(Throwable)</code> .  Wenn die Verarbeitung normal abgeschlossen ist, wird die <code>onComplete</code> Methode des Teilnehmers aufgerufen. <br><br>  <i>Beispiel 4. Jetstreams: <code>Subscriber&lt;T&gt;</code> -Schnittstelle.</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Wenn der <code>Subscriber</code> ersten Mal eine Verbindung zu <code>Publisher</code> , erhält er ein <code>Subscription</code> in der <code>Subscriber#onSubscribe</code> .  Abonnement Das <code>Subscription</code> ist möglicherweise der wichtigste Teil der gesamten Spezifikation.  sie ist es, die den Rückfluss liefert.  Ein Abonnent-Abonnent verwendet die <code>Subscription#request</code> , um zusätzliche Daten anzufordern, oder die <code>Subscription#cancel</code> , um die Verarbeitung zu beenden. <br><br>  <i>Beispiel 5. Reaktive Streams: <code>Subscription&lt;T&gt;</code> -Schnittstelle</i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Die reaktive Stream-Spezifikation bietet einen weiteren nützlichen, wenn auch offensichtlichen Typ: <code>Processor&lt;A,B&gt;</code> ist nur eine Schnittstelle, die sowohl <code>Subscriber&lt;A&gt;</code> als auch <code>Publisher&lt;B&gt;</code> erbt. <br><br>  <i>Beispiel 6. Jetstreams: <code>Processor&lt;T&gt;</code> -Schnittstelle</i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ltT</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Eine Spezifikation ist nicht als Rezept für Implementierungen positioniert. Tatsächlich besteht ihr Zweck darin, Typen zu definieren, um die Interoperabilität zu unterstützen.  Der offensichtliche Vorteil von Typen, die mit reaktiven Flows verbunden sind, besteht darin, dass sie dennoch einen Platz in der Java 9-Version gefunden haben. Außerdem sind sie semantisch „eins zu eins“ und entsprechen Schnittstellen der Klasse <code>java.util.concurrent.Flow</code> , zum Beispiel: <code>java.util.concurrent.Flow.Publisher</code> . <br><br>  <b>Treffen Sie Reactor</b> <br><br>  Arten von reaktiven Strömen allein reichen nicht aus;  Implementierungen höherer Ordnung sind erforderlich, um Operationen wie Filtern und Transformieren zu unterstützen.  Als solches ist das Reaktorprojekt praktisch;  Es baut auf der Reactive Streams-Spezifikation auf und bietet zwei <code>Publisher&lt;T&gt;</code> -Spezialisierungen. <br><br>  Erstens ist <code>Flux&lt;T&gt;</code> ein <code>Publisher</code> , der null oder mehr Werte erzeugt.  Das zweite, <code>Mono&lt;T&gt;</code> , ist <code>Publisher&lt;T&gt;</code> und erzeugt null oder einen Wert.  Beide veröffentlichen Werte und können sie entsprechend behandeln. Ihre Funktionen sind jedoch viel umfassender als die der Reactive Streams-Spezifikation.  Beide bieten Operatoren, mit denen Sie Wertströme verarbeiten können.  Reaktortypen lassen sich gut zusammensetzen - die Ausgabe eines von ihnen kann als Eingabe für den anderen dienen, und wenn ein Typ mit anderen Datenströmen arbeiten muss, sind sie auf <code>Publisher&lt;T&gt;</code> -Instanzen angewiesen. <br><br>  Sowohl <code>Mono&lt;T&gt;</code> als auch <code>Flux&lt;T&gt;</code> implementieren <code>Publisher&lt;T&gt;</code> .  Wir empfehlen, dass Ihre Methoden <code>Publisher&lt;T&gt;</code> -Instanzen akzeptieren, aber <code>Flux&lt;T&gt;</code> oder <code>Mono&lt;T&gt;</code> .  Dies hilft dem Kunden zu unterscheiden, welche Art von Daten er erhält. <br><br>  Angenommen, Sie haben <code>Publisher&lt;T&gt;</code> und wurden aufgefordert, die Benutzeroberfläche für diesen <code>Publisher&lt;T&gt;</code> anzuzeigen.  Sollte ich dann eine Seite mit Details für einen Datensatz anzeigen, da Sie <code>CompletableFuture&lt;T&gt;</code> ?  Oder eine Übersichtsseite mit einer Liste oder einem Raster anzeigen, auf der alle Einträge Seite für Seite angezeigt werden?  Es ist schwer zu sagen. <br><br>  <code>Flux&lt;T&gt;</code> und <code>Mono&lt;T&gt;</code> sehr spezifisch.  Sie wissen, dass Sie eine Überprüfungsseite anzeigen müssen, wenn <code>Flux&lt;T&gt;</code> empfangen wird, und eine Seite mit Details für einen (oder keinen einzelnen) Datensatz, wenn Sie <code>Mono&lt;T&gt;</code> empfangen. <br><br>  Reactor ist ein Open-Source-Projekt von Pivotal.  Jetzt ist er sehr beliebt geworden.  Facebook verwendet es in seinem Düsentriebwerk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um Remote-Prozeduren aufzurufen</a> , und verwendet es auch in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rsocket</a> , das vom RxJava-Erfinder Ben Christensen geleitet wird.  Salesforce verwendet es in seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reaktiven gRPC-Implementierung</a> .  Reactor implementiert reaktive Streams-Typen, sodass es mit anderen Technologien interagieren kann, die diese Typen unterstützen, z. B. mit <a href="">RxJava 2</a> von Netflix, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akka Streams</a> von Lightbend und mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vert.x-</a> Projekt von Eclipse Foundation.  David Cairnock, Direktor von RxJava 2, arbeitete auch aktiv mit Pivotal zusammen, um Reactor zu entwickeln und das Projekt noch besser zu machen.  Außerdem ist es natürlich in der einen oder anderen Form im Spring Framework vorhanden, beginnend mit Spring Framework 4.0. <br><br>  <b>Reaktive Programmierung mit Spring WebFlux</b> <br><br>  Bei aller Nützlichkeit ist der Reaktor nur die Basis.  Unsere Anwendungen müssen mit Datenquellen kommunizieren.  Muss Authentifizierung und Autorisierung unterstützen.  Der Frühling bietet all dies.  Wenn Reactor uns die fehlende Metapher gibt, hilft uns der Frühling alle, eine gemeinsame Sprache zu sprechen. <br><br>  Spring Framework 5.0 wurde im September 2017 veröffentlicht. Es baut auf der Reactor- und der Reactive Streams-Spezifikation auf.  Es verfügt über ein neues reaktives Laufzeit- und Komponentenmodell namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring WebFlux</a> . <br><br>  Spring WebFlux ist unabhängig von der Servlet-API und erfordert keine Funktion.  Es wird mit Adaptern geliefert, mit denen Sie es bei Bedarf über dem Servlet-Motor verwenden können. Dies ist jedoch nicht erforderlich.  Es bietet auch eine völlig neue Netty-basierte Laufzeit namens Spring WebFlux.  Spring Framework 5, das mit Java 8 und Java EE 7 und höher arbeitet, dient jetzt als Grundlage für einen Großteil des Spring-Ökosystems, einschließlich Spring Data Kay, Spring Security 5, Spring Boot 2 und Spring Cloud Finchley. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435972/">https://habr.com/ru/post/de435972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435960/index.html">Gedankenexperiment: Flattern unterwegs</a></li>
<li><a href="../de435962/index.html">25 Jahre Aeron: Sensationen und Eindrücke der aktualisierten Version von Aeron Remastered</a></li>
<li><a href="../de435964/index.html">Ethereum plant, 99% wirtschaftlicher zu sein</a></li>
<li><a href="../de435968/index.html">Übersicht über Deep Machine Learning-Algorithmen für Roboter</a></li>
<li><a href="../de435970/index.html">Anfängerhandbuch zur Webserverentwicklung mit Node.js.</a></li>
<li><a href="../de435974/index.html">Three.js - Steuerelemente für Weltraum oder Planetarium</a></li>
<li><a href="../de435976/index.html">WebAssembly in der Produktion und das „Minenfeld“ von Smart TV: ein Interview mit Andrei Nagih</a></li>
<li><a href="../de435978/index.html">Problemumgehungen für den biometrischen Schutz</a></li>
<li><a href="../de435984/index.html">Neuronale Netze und Sprachphilosophie</a></li>
<li><a href="../de435986/index.html">Windows reserviert 7 GB für Systemaktualisierungen, um zu vermeiden, dass der Festplattenspeicher knapp wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>