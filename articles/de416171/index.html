<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèæ üí± üë¶üèª Visual Studio Coded UI Tests: Theorie und Praxis der Anwendung in unserem Unternehmen ü§µüèΩ ü¶è üà∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Automatisierte Benutzeroberfl√§chentests sind ein Thema, vor dem selbst erfahrene Entwickler vorsichtig sind. Dar√ºber hinaus ist die Technologie solche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Visual Studio Coded UI Tests: Theorie und Praxis der Anwendung in unserem Unternehmen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/416171/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/e4d/592/2aee4d592fcaceeb418e5833c067dcbd.png" alt="Bild 2"></div><br>  Automatisierte Benutzeroberfl√§chentests sind ein Thema, vor dem selbst erfahrene Entwickler vorsichtig sind.  Dar√ºber hinaus ist die Technologie solcher Tests nichts Au√üergew√∂hnliches, und im Fall von Visual Studio Coded UI Tests handelt es sich um eine Erweiterung des integrierten Unit-Test-Systems Visual Studio Team Test.  In diesem Artikel m√∂chte ich auf das Thema UI-Tests im Allgemeinen sowie auf unsere pers√∂nlichen Erfahrungen mit der Verwendung von Visual Studio-codierten UI-Tests bei der Arbeit am statischen Analysator PVS-Studio eingehen. <br><a name="habracut"></a><br><h2>  Die Grundlagen </h2><br>  Lassen Sie uns zun√§chst herausfinden, warum UI-Tests bei Entwicklern nicht so beliebt sind wie beispielsweise klassische Unit-Tests. <br><br>  Es gibt viele sogenannte ‚ÄûTestpyramiden‚Äú im Netzwerk, die die optimale empfohlene Verteilung der Anzahl der Tests auf die Anwendungsebenen anzeigen.  Alle Pyramiden sind √§hnlich und enthalten eine allgemeine Idee: So viele Tests wie m√∂glich sollten so nah wie m√∂glich am Code sein.  Umgekehrt.  Ich werde ein Beispiel f√ºr eine dieser Pyramiden geben, das zus√§tzliche Empfehlungen zum Verh√§ltnis der Anzahl der Tests in Prozent enth√§lt. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/7b5/b4b/4307b5b4b72a27aade942e0ff1747545.png" alt="Bild 4"></div><br>  An der Basis der Pyramide befinden sich Unit-Tests.  In der Tat sind solche Tests in der Entwicklungsphase einfacher durchzuf√ºhren und werden sehr schnell ausgef√ºhrt.  An der Spitze der Pyramide stehen dagegen automatisierte Schnittstellentests.  Diese Tests sollten nicht viele sein, da die Komplexit√§t ihrer Erstellung sowie die Ausf√ºhrungszeit ziemlich gro√ü sind.  Dar√ºber hinaus ist nicht klar, wem die Erstellung von UI-Tests anvertraut werden soll.  Im Wesentlichen handelt es sich um die Emulation von Benutzeraktionen.  All dies ist sehr weit vom Anwendungscode entfernt, sodass Entwickler diese Art von Arbeit nur ungern ausf√ºhren.  Und um qualitativ hochwertige automatisierte Tests von Schnittstellen ohne die Teilnahme (oder mit minimaler Beteiligung) von Programmierern durchzuf√ºhren, ist die Verwendung kostenpflichtiger Tools erforderlich.  Die Kombination all dieser Faktoren f√ºhrt h√§ufig dazu, dass UI-Tests √ºberhaupt nicht funktionieren und sich auf einzelne manuelle Tests neuer Funktionen beschr√§nken.  Dar√ºber hinaus sind Schnittstellentests nicht nur in der Entwicklungsphase, sondern auch w√§hrend des weiteren Anwendungslebenszyklus extrem teuer.  Selbst eine geringf√ºgige √Ñnderung der Benutzeroberfl√§che kann zu Fehlern bei der Ausf√ºhrung vieler Tests und der Notwendigkeit f√ºhren, diese zu √§ndern. <br><br>  Ich stelle fest, dass unser Testsystem derzeit im Allgemeinen den Empfehlungen entspricht.  Die Anzahl der automatisierten GUI-Tests (45) betr√§gt ungef√§hr ein Zehntel der Gesamtzahl der PVS-Studio-Tests.  Gleichzeitig ist die Anzahl der Unit-Tests nicht so gro√ü, aber sie werden durch eine Vielzahl anderer Testsysteme erg√§nzt: <br><br><ul><li> Leistungstests von Analysatoren (C / C ++ / C # / Java), bei denen sie einen gro√üen Pool von Testprojekten auf verschiedenen Betriebssystemen (Windows, Linux, macOS) √ºberpr√ºfen und die Protokolle neuer Warnungen mit den Referenzwarnungen vergleichen; </li><li>  Tests spezifischer Funktionen (Verfolgung des Starts von Compilern usw.); </li><li>  Externe Tests von Befehlszeilenanwendungen; </li><li>  Tests der korrekten Montage, Installation und Bereitstellung; </li><li>  Dokumentationstests. </li></ul><br>  In der Anfangsphase seiner Entwicklung war der PVS-Studio-Analysator eine Anwendung zum Auffinden von Fehlern beim Portieren von C / C ++ - Code auf eine 64-Bit-Plattform.  Ja, und er wurde damals auf andere Weise "Viva64" genannt.  Die Geschichte des Produkts finden Sie im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie das PVS-Studio-Projekt vor 10 Jahren begann</a> ".  Nach der Integration in Visual Studio 2005 erwarb der Analysator eine grafische Benutzeroberfl√§che, im Wesentlichen die Benutzeroberfl√§che der Visual Studio-IDE selbst, in der nach der Installation des Plug-Ins ein zus√§tzliches Men√º f√ºr den Zugriff auf die Analysatorfunktion angezeigt wurde.  Das Men√º bestand aus zwei oder drei Elementen, daher gab es dort nichts zu testen.  Zu dieser Zeit enthielt Visual Studio keine integrierten Tools zum Testen von GUIs. <br><br><h2>  Visual Studio Coded UI-Tests und Alternativen </h2><br>  Mit der Ver√∂ffentlichung von Visual Studio 2010, das ein integriertes System zum Erstellen von UI-Tests einf√ºhrte, √§nderte sich alles: Visual Studio Coded UI Tests (CUIT).  Basierend auf dem Unit Studio-Testsystem von Visual Studio Team Test verwendete CUIT zun√§chst die Microsoft Active Accessibility (MSAA) -Technologie, um auf visuelle Schnittstellenelemente zuzugreifen.  In Zukunft wurde die Technologie verbessert und ist derzeit ein entwickeltes Modell zur Automatisierung der Benutzeroberfl√§che zum Testen von UIA-Code (UI Automation).  Es erm√∂glicht dem Testsystem den Zugriff auf offene Felder (Objektname, interner Klassenname des Objekts, aktueller Status des Objekts, Platz in der hierarchischen Struktur der Schnittstelle usw.) von COM- und .NET-UI-Elementen, und das System erm√∂glicht es Ihnen, die Auswirkungen auf diese Elemente zu emulieren √ºber Standardeingabeger√§te (Maus, Tastatur).  Sofort werden Modi zum Aufzeichnen von Benutzeraktionen bei der Interaktion mit einer Benutzeroberfl√§che (√§hnlich wie bei Visual Studio-Makros), die Automatisierung der Erstellung einer ‚ÄûSchnittstellenzuordnung‚Äú (Eigenschaften von Steuerelementen, Suchparameter und Zugriff darauf) sowie die automatische Generierung von Steuercode unterst√ºtzt.  In Zukunft k√∂nnen alle gesammelten Informationen einfach ge√§ndert und auf dem neuesten Stand gehalten sowie Testsequenzen nach Ihren W√ºnschen angepasst werden, w√§hrend nur minimale Programmierkenntnisse vorhanden sind. <br><br>  Wie ich bereits sagte, k√∂nnen Sie jetzt beim Erstellen komplexer intelligenter UI-Tests auf Programmierkenntnisse verzichten, vorausgesetzt, Sie verwenden spezielle kostenpflichtige Tools.  Nun, wenn es keinen Wunsch oder keine F√§higkeit gibt, propriet√§re Testumgebungen zu verwenden, gibt es viele kostenlose Produkte und Frameworks.  Das Visual Studio Coded UI Tests-System ist eine Zwischenl√∂sung, mit der nicht nur der Prozess der Erstellung von UI-Tests so weit wie m√∂glich automatisiert werden kann.  Mit seiner Hilfe ist es einfach, beliebige Testsequenzen in den Programmiersprachen C # oder VB zu erstellen. <br><br>  All dies kann die Kosten f√ºr die Erstellung und Aufrechterhaltung der Relevanz von GUI-Tests erheblich senken.  Das verwendete Framework ist einfach zu verstehen und kann im Allgemeinen in Form eines Diagramms dargestellt werden. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10b/b6a/756/10bb6a7561749453f882bfa0c86b9f43.png" alt="Bild 1"></div><br>  Von den Schl√ºsselelementen sind die sogenannten "Schnittstellenadapter" zu beachten, die sich auf der niedrigsten Abstraktionsebene befinden.  Diese Ebene interagiert mit den finiten Elementen der Benutzeroberfl√§che, und ihre Funktionen k√∂nnen mithilfe zus√§tzlicher Adapter erweitert werden.  Oben befindet sich eine Ebene, die GUI-Zugriffstechnologien vor dem Rest des Codes verbirgt, einschlie√ülich Programmzugriffsschnittstellen und des eigentlichen Testanwendungscodes, der alle erforderlichen Elemente zum Testen der Automatisierung enth√§lt.  Die Technologie ist erweiterbar, jede Ebene kann im Rahmen des Frameworks mit den notwendigen Elementen erg√§nzt werden. <br><br>  Zu den Hauptfunktionen von CUIT von Microsoft geh√∂ren: <br><br><ul><li>  Funktionspr√ºfung von Benutzeroberfl√§chen.  Es werden klassische Windows-basierte Anwendungen, Webanwendungen und Dienste sowie WPF unterst√ºtzt </li><li>  Codegenerierung (einschlie√ülich automatisch) in VB / C # </li><li>  Integrationsf√§higkeit in den Montageprozess </li><li>  Lokale oder Remote-Starts, Berichterstellung </li><li>  Verf√ºgbarkeit der Aufzeichnung und Wiedergabe von Testsequenzen </li><li>  Gute Erweiterbarkeit </li></ul><br>  Trotz einer Reihe von Schwierigkeiten, die mit CUIT verbunden sind, wird die Verwendung dieser Testtechnologie aus einer Reihe von Gr√ºnden bevorzugt: <br><br><ul><li>  Effektive Interaktion von Entwicklern und Testern innerhalb eines Tools und einer Programmiersprache </li><li>  Zus√§tzliche Funktionen f√ºr die Arbeit mit der ‚ÄûSchnittstellenkarte‚Äú, die die Identifizierung von Steuerelementen ‚Äûon the fly‚Äú, die Synchronisierung von Elementen und den Abschluss von Testsequenzen erm√∂glicht </li><li>  Feinabstimmung des Wiedergabemechanismus, der es erm√∂glicht, zusammen mit grundlegenden Einstellungen wie einer Verz√∂gerung zwischen Operationen, einem Zeitlimit f√ºr die Elementsuche usw. spezielle Mechanismen im Code zu verwenden.  Beispiel: Sperren des aktuellen Threads, bis das Steuerelement mithilfe der <i>WaitForControlExist-</i> oder <i>WaitForReady-Methoden</i> mit der <i>WaitForReadyLevel-</i> Enumeration usw. aktiviert (visualisiert) wird. </li><li>  F√§higkeit, unbegrenzt komplexe Tests zu programmieren </li></ul><br>  Ich werde nicht weiter auf die theoretischen Aspekte der Visual Studio Coded UI Tests-Technologie eingehen. Sie werden alle in der entsprechenden Dokumentation beschrieben.  Dort finden Sie detaillierte Schritt-f√ºr-Schritt-Anleitungen zum Erstellen des einfachsten UI-Tests auf Basis dieses Systems.  Und ja, das System ist nicht kostenlos. Sie ben√∂tigen Visual Studio Enterprise, um damit arbeiten zu k√∂nnen. <br><br>  Die beschriebene Technologie ist nicht die einzige auf dem Markt.  Es gibt viele andere L√∂sungen.  Alle alternativen UI-Testsysteme k√∂nnen in kostenpflichtige und kostenlose unterteilt werden.  Dar√ºber hinaus h√§ngt die Wahl eines bestimmten Systems nicht immer von seinem Preis ab.  Beispielsweise kann die F√§higkeit, Tests ohne Programmierbedarf zu erstellen, als wichtiger Faktor dienen, gleichzeitig sind Tests jedoch m√∂glicherweise nicht flexibel genug.  Es ist auch wichtig, die erforderliche Testumgebung zu unterst√ºtzen - Betriebssysteme und Anwendungen.  Schlie√ülich k√∂nnen die rein spezifischen Merkmale der Anwendung und ihrer Benutzeroberfl√§che die Auswahl beeinflussen.  Hier sind einige beliebte Systeme und Technologien zum Testen von GUIs. <br><br>  <i>Bezahlt</i> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TestComplete</a> (SmartBear), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unified Functional Testing</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mikrofokus</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Squish</a> (Froglogic), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">automatisierte</a> Testwerkzeuge (Ranorex), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auberginenfunktion</a> (Aubergine) usw. <br><br>  <i>Kostenlos</i> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AutoIt</a> (Windows), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Selen</a> (Web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Katalon Studio</a> (Web, Mobile), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sahi</a> (Web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Robot Framework</a> (Web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LDTP</a> (Linux Desktop Testing Project), Open Source Frameworks: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TestStack.White</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UIAutomationVerify</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NET Windows-Automatisierungsbibliothek</a> usw. <br><br>  Nat√ºrlich ist diese Liste nicht vollst√§ndig.  Es ist jedoch offensichtlich, dass freie Systeme normalerweise auf ein bestimmtes Betriebssystem oder eine bestimmte Testtechnologie ausgerichtet sind.  Die allgemeine Regel lautet, dass Sie unter kostenpflichtigen Systemen viel schneller etwas finden, das speziell f√ºr Ihre Anforderungen geeignet ist, die Entwicklung und Wartung von Tests einfacher ist und die Liste der unterst√ºtzten Testumgebungen vollst√§ndig ist. <br><br>  In unserem Fall gab es kein Auswahlproblem: Mit der Ver√∂ffentlichung von Visual Studio 2010 mit zus√§tzlichen Tests f√ºr die codierte Benutzeroberfl√§che wurde es m√∂glich, unserer Testumgebung problemlos eine Reihe von Funktionstests hinzuzuf√ºgen, um die Benutzeroberfl√§che des PVS-Studio-Plug-Ins f√ºr Visual Studio zu testen. <br><br><h2>  PVS-Studio UI-Tests </h2><br>  Daher werden GUI-Tests in unserem Unternehmen seit mehr als 6 Jahren verwendet.  Die ersten UI-Tests f√ºr Visual Studio 2010 basierten auf der damals einzigen verf√ºgbaren MSAA-Technologie (Microsoft Active Accessibility).  Mit der Ver√∂ffentlichung von Visual Studio 2012 hat sich die MSAA-Technologie erheblich weiterentwickelt und hei√üt jetzt UIA (UI Automation).  Es wurde beschlossen, die UIA weiterhin zu verwenden und die MSAA-basierten Tests zu verlassen, um das Plug-In f√ºr Visual Studio 2010 zu testen (wir unterst√ºtzen und testen Plug-Ins f√ºr alle Versionen von Visual Studio, beginnend mit Visual Studio 2010). <br><br>  Infolgedessen haben wir zwei ‚ÄûZweige‚Äú von UI-Tests gebildet.  Dar√ºber hinaus verwendeten beide Zweige im Testprojekt eine gemeinsame Schnittstellenzuordnung und gemeinsamen Code.  Im Code sah es ungef√§hr so ‚Äã‚Äãaus (Methode zum Zur√ºcksetzen der Visual Studio-Einstellungen auf den Standard vor dem Ausf√ºhren des Tests): <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVSSettings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TestingMode mode)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">#region MSAA Mode </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (mode == TestingMode.MSAA) { .... return; } #endregion </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//UIA Mode .... }</span></span></span></span></code> </pre> <br>  Bei √Ñnderungen an der Plugin-Schnittstelle mussten √Ñnderungen an beiden Zweigen der UI-Tests vorgenommen werden. Durch Hinzuf√ºgen neuer Funktionen musste das Schnittstellenelement in der Karte dupliziert werden. Das hei√üt, es wurden zwei verschiedene Elemente f√ºr jede der MSAA- und UIA-Technologien erstellt.  All dies erforderte viel Aufwand, um nicht nur Tests zu erstellen oder zu √§ndern, sondern auch die Testumgebung in einem stabilen Zustand zu halten.  Ich werde auf diesen Aspekt n√§her eingehen. <br><br>  Nach meinen Beobachtungen ist die Stabilit√§t der Testumgebung beim Testen der GUI ein erhebliches Problem.  Dies ist haupts√§chlich auf die starke Abh√§ngigkeit solcher Tests von vielen externen Faktoren zur√ºckzuf√ºhren.  Tats√§chlich werden die Aktionen des Benutzers emuliert: Dr√ºcken von Tasten, Bewegen des Mauszeigers, Mausklicks usw.  Es gibt viele Dinge, die "schief gehen" k√∂nnen.  Zum Beispiel, wenn w√§hrend des Tests jemand mit einer Tastatur interagiert, die mit dem Testserver verbunden ist.  Au√üerdem reicht die Monitoraufl√∂sung m√∂glicherweise nicht aus, um ein Steuerelement anzuzeigen, und sie wird von der Testumgebung nicht gefunden. <br><br>  Warten: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/57b/2fb/f0757b2fb7075dcfac29b66f81832b69.png" alt="Bild 3"></div><br>  Realit√§t: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/rh/ty/jdrhtyxluox8lhxhab_btiuhjp8.png"></div><br>  Ein unachtsam abgestimmtes (und sp√§ter nicht gefundenes) Schnittstellenkartenelement ist praktisch der Anf√ºhrer des Problemverhaltens.  Wenn Sie beispielsweise ein neues Steuerelement erstellen, verwendet der Assistent f√ºr die Schnittstellenzuordnung von Visual Studio Coded UI Tests die Standardkriterien f√ºr die Suche nach Gleichheit.  Das hei√üt, eine genaue √úbereinstimmung der Eigenschaftsnamen mit den angegebenen Werten ist erforderlich.  Dies funktioniert normalerweise, aber manchmal kann die Stabilit√§t der Testausf√ºhrung erheblich verbessert werden, indem die weniger strengen Suchkriterien "Enth√§lt" anstelle von "Gleich" verwendet werden.  Dies ist nur ein Beispiel f√ºr eine ‚ÄûOptimierung‚Äú, die bei der Arbeit an UI-Tests auftreten kann. <br><br>  Schlie√ülich k√∂nnen einige Ihrer Tests darin bestehen, eine Aktion auszuf√ºhren und weiter auf ein Ergebnis zu warten, was beispielsweise mit der Anzeige eines Fensters verbunden ist.  In diesem Fall werden zum Problem der Suche nach einem Element Fragen zum Einstellen der Wiedergabeverz√∂gerung bis zum Erscheinen des Fensters und zum anschlie√üenden Synchronisieren der Arbeit hinzugef√ºgt.  Einige dieser Probleme k√∂nnen mit Standard-Framework-Methoden ( <i>WaitForControlExist</i> usw.) gel√∂st werden, w√§hrend f√ºr andere die <i>Entwicklung</i> ausgekl√ºgelter Algorithmen erforderlich sein wird. <br><br>  Bei der Arbeit an einem der Tests unseres Plugins hatten wir ein √§hnliches Problem.  Bei diesem Test wird zuerst eine leere Visual Studio-Umgebung ge√∂ffnet, dann wird dort eine bestimmte Testl√∂sung geladen, die mit PVS-Studio vollst√§ndig getestet wird (Men√º ‚ÄûPVS-Studio‚Äú -&gt; ‚ÄûPr√ºfen‚Äú -&gt; ‚ÄûL√∂sung‚Äú).  Das Problem bestand darin, festzustellen, wann die √úberpr√ºfung abgeschlossen sein w√ºrde.  Abh√§ngig von einer Reihe von Bedingungen dauert die √úberpr√ºfung m√∂glicherweise nicht immer dieselbe Zeit, sodass einfache Zeit√ºberschreitungen hier nicht funktionieren.  Sie k√∂nnen auch nicht die Standardmechanismen verwenden, um den Testablauf anzuhalten und auf das Erscheinen (oder Ausblenden) eines Steuerelements zu warten, da nichts zum Anh√§ngen vorhanden ist.  W√§hrend der Pr√ºfung wird ein Fenster mit dem Status der Arbeit angezeigt. Dieses Fenster kann jedoch ausgeblendet werden, und die Pr√ºfung wird fortgesetzt.  Das hei√üt,  Dieses Fenster kann nicht gef√ºhrt werden (au√üerdem hat es die Einstellung ‚ÄûNach Abschluss der Analyse nicht schlie√üen‚Äú).  Und ich wollte den Algorithmus allgemeiner gestalten, um ihn f√ºr verschiedene Tests zu verwenden, die sich auf das √úberpr√ºfen von Projekten und das Warten auf den Abschluss dieses Prozesses beziehen.  Eine L√∂sung wurde gefunden.  Nach dem Start des Tests und bis zu seinem Abschluss ist der Men√ºpunkt ‚ÄûPVS-Studio‚Äú -&gt; ‚ÄûPr√ºfen‚Äú -&gt; ‚ÄûL√∂sung‚Äú inaktiv.  Wir mussten die Eigenschaft "Aktiviert" dieses Men√ºelements nur in einem bestimmten Zeitintervall (√ºber das Schnittstellenzuordnungsobjekt) √ºberpr√ºfen und, wenn festgestellt wurde, dass das Element aktiv geworden war, den Entscheidungs√ºberpr√ºfungsprozess als abgeschlossen betrachten. <br><br>  Daher reicht es beim Testen der Benutzeroberfl√§che nicht aus, nur Tests zu erstellen.  In jedem Fall ist eine subtile und sorgf√§ltige Abstimmung erforderlich.  Es ist notwendig, die gesamte Abfolge der ausgef√ºhrten Aktionen zu verstehen und zu synchronisieren.  Beispielsweise wird der Kontextmen√ºpunkt erst gefunden, wenn dieses Men√º auf dem Bildschirm usw. angezeigt wird.  Eine sorgf√§ltige Vorbereitung der Testumgebung ist ebenfalls erforderlich.  In diesem Fall k√∂nnen Sie sich auf den stabilen Ablauf der Tests und angemessene Ergebnisse verlassen. <br><br>  Ich m√∂chte Sie daran erinnern, dass sich das System der UI-Tests in unserem Unternehmen seit 2010 entwickelt hat.  In dieser Zeit wurden mehrere Dutzend Testsequenzen erstellt und viel Hilfscode geschrieben.  Im Laufe der Zeit wurden den Plugin-Tests eigenst√§ndige Anwendungstests hinzugef√ºgt.  Zu diesem Zeitpunkt hatte der alte Plug-in-Testzweig f√ºr Visual Studio 2010 seine Relevanz verloren und wurde aufgegeben, aber es war einfach unm√∂glich, diesen ‚Äûtoten‚Äú Code aus dem Projekt herauszuschneiden.  Erstens war der Code, wie ich zuvor gezeigt habe, ziemlich tief in die Testmethoden integriert.  Und zweitens geh√∂rte mehr als die H√§lfte der Elemente der vorhandenen Schnittstellenkarte zur alten MSAA-Technologie, wurde jedoch in vielen neuen Tests zusammen mit UIA-Elementen wiederverwendet (statt zu duplizieren) (dies ist aufgrund der Kontinuit√§t der Technologie m√∂glich).  Gleichzeitig wurde die Masse sowohl des automatisch generierten Codes als auch des Inhalts der Testmethoden an die "alten" Elemente gebunden. <br><br>  Bis Herbst 2017 musste das System der UI-Tests verbessert werden.  Im Allgemeinen funktionierten die Tests einwandfrei, aber von Zeit zu Zeit "st√ºrzte" ein Test aus unbekannten Gr√ºnden ab.  Genauer gesagt bestand der Grund normalerweise darin, eine Kontrolle zu finden.  In jedem Fall musste ich den Baum der Schnittstellenzuordnung zu einem bestimmten Element durchgehen und dessen Suchkriterien und andere Einstellungen √ºberpr√ºfen.  Manchmal half ein Software-Reset dieser Einstellungen, bevor der Test ausgef√ºhrt wurde.  Angesichts der Schnittstellenkarte, die durch die Schnittstellenkarte gewachsen ist (und in vielerlei Hinsicht in vielerlei Hinsicht), sowie des Vorhandenseins von "totem" Code war dieser Prozess mit erheblichem Aufwand verbunden. <br><br>  F√ºr einige Zeit wartete die Aufgabe ‚Äûauf ihren Helden‚Äú, bis sie mir schlie√ülich einfiel. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3b/a0e/940/c3ba0e9405d26985a0519cf66544ca36.png" alt="Bild 5"></div><br>  Ich werde Sie nicht mit einer Beschreibung der Nuancen langweilen.  Ich kann nur sagen, dass die Arbeit nicht schwierig war, aber viel Ausdauer und Aufmerksamkeit erforderte.  Alles an allem hat mich ungef√§hr zwei Wochen gekostet.  Die H√§lfte dieser Zeit habe ich damit verbracht, den Code und die Schnittstellenkarten zu √ºberarbeiten.  In der verbleibenden Zeit besch√§ftigte er sich mit der Stabilisierung der Testausf√ºhrung, die sich im Wesentlichen auf eine genauere Abstimmung der Suchkriterien f√ºr visuelle Elemente (Bearbeitung der Schnittstellenkarte) sowie auf eine Optimierung des Codes beschr√§nkte. <br><br>  Infolgedessen konnten wir die Codegr√∂√üe der Testmethoden um etwa 30% reduzieren und die Anzahl der Steuerelemente im Baum der Schnittstellenzuordnung halbieren.  Vor allem aber zeigten UI-Tests eine stabilere Leistung und erforderten weniger Aufmerksamkeit.  Und der R√ºckgang trat h√§ufiger auf, weil Gr√ºnde f√ºr √Ñnderungen an der Funktionalit√§t des Analysators oder beim Erkennen von Inkonsistenzen (Fehlern) auftraten.  F√ºr diese Zwecke ben√∂tigen wir ein System von UI-Tests. <br><br>  Daher weist das System der automatischen Tests der PVS-Studio-Schnittstelle derzeit die folgenden grundlegenden Merkmale auf: <br><br><ul><li>  Visual Studio Coded UI Test </li><li>  45 Szenarien </li><li>  4.095 Codezeilen f√ºr Testmethoden </li><li>  19.889 Zeilen automatisch generierten Codes (ohne die Gr√∂√üe der XML-Datei zum Speichern der UI-Map-Einstellungen) </li><li>  1 Stunde 34 Minuten Ausf√ºhrung (Durchschnittswert gem√§√ü den Ergebnissen der letzten 30 Starts) </li><li>  Arbeiten Sie auf einem dedizierten Server (mit dem Dienstprogramm MSTest.exe) </li><li>  Leistungs√ºberwachung und Leistungsberichtanalyse (Jenkins) </li></ul><br><h2>  Fazit </h2><br>  Abschlie√üend m√∂chte ich eine Liste von Erfolgskriterien f√ºr automatische GUI-Tests geben, die auf einer Analyse unserer Erfahrungen mit dieser Technologie basiert (einige der Kriterien gelten f√ºr andere Testtechnologien, z. B. Unit-Tests). <br><br>  <i>Geeignete Werkzeuge</i> .  W√§hlen Sie die Umgebung zum Erstellen und Ausf√ºhren von CUIT gem√§√ü den Funktionen Ihrer Anwendung sowie der Testumgebung aus.  Bezahlte L√∂sungen sind nicht immer sinnvoll, helfen aber normalerweise, ein Problem sehr effektiv zu l√∂sen. <br><br>  <i>Hochwertige Infrastruktureinrichtung</i> .  Speichern Sie nicht, wenn Sie eine Schnittstellenkarte entwickeln.  Vereinfachen Sie die Arbeit des Frameworks bei der Suche nach Elementen, indem Sie alle Eigenschaften sorgf√§ltig beschreiben und intelligente Suchkriterien festlegen.  Achten Sie auf die M√∂glichkeiten einer weiteren √Ñnderung. <br><br>  <i>Minimierung der Handarbeit</i> .  Verwenden Sie nach M√∂glichkeit automatische Mittel zum Generieren von Code und zum Aufzeichnen von Sequenzen.  So beschleunigen Sie die Entwicklung erheblich und minimieren die Wahrscheinlichkeit von Fehlern (es ist nicht immer einfach, den Grund f√ºr den Absturz des UI-Tests zu finden, insbesondere wenn im Code f√ºr die Arbeit mit dem Framework ein Fehler gemacht wurde). <br><br>  <i>Einfache und unabh√§ngige intelligente Tests</i> .  Je einfacher Ihre Tests sind, desto besser.  Versuchen Sie, einen separaten Test durchzuf√ºhren, um eine bestimmte Kontrolle oder simulierte Situation zu testen.  Stellen Sie au√üerdem sicher, dass die Tests unabh√§ngig voneinander sind.  Der Sturz eines der Tests sollte nicht den gesamten Prozess beeinflussen. <br><br>  <i>Freundliche Namen</i> .  Verwenden Sie Pr√§fixe in den Namen √§hnlicher Tests.  In vielen Umgebungen k√∂nnen Sie Tests ausf√ºhren, indem Sie nach Namen filtern.  Verwenden Sie nach M√∂glichkeit auch die Testgruppierung. <br><br>  <i>Isolierte Laufzeit</i> .  Stellen Sie sicher, dass die Tests auf einem dedizierten Server mit minimalen externen Auswirkungen ausgef√ºhrt werden.  Trennen Sie alle externen Benutzereingabeger√§te, stellen Sie die erforderliche Bildschirmaufl√∂sung f√ºr Ihre Anwendung bereit oder verwenden Sie einen Hardware-Dummy, der eine hochaufl√∂sende Monitorverbindung simuliert.  Stellen Sie sicher, dass w√§hrend des Testlaufs andere Anwendungen, die beispielsweise mit dem Desktop interagieren und Meldungen anzeigen, nicht ausgef√ºhrt werden.  Es ist auch notwendig, die Startzeit zu planen und die maximale Dauer der Tests zu ber√ºcksichtigen. <br><br>  <i>Analyse der herausgegebenen Berichte</i> .  Stellen Sie ein einfaches und klares Formular f√ºr die Berichterstattung √ºber den Fortschritt bereit.  Verwenden Sie kontinuierliche Integrationssysteme, um Tests zu versenden sowie Testergebnisse schnell zu erhalten und zu analysieren. <br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visual Studio Coded UI-Tests: Theorie und Benutzererfahrung unseres Unternehmens</a> <br><br><div class="spoiler">  <b class="spoiler_title">Haben Sie den Artikel gelesen und eine Frage?</b> <div class="spoiler_text">  Oft werden unseren Artikeln die gleichen Fragen gestellt.  Wir haben die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Antworten</a> hier gesammelt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Antworten auf Fragen von Lesern von Artikeln √ºber PVS-Studio, Version 2015</a> .  Bitte beachten Sie die Liste. </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416171/">https://habr.com/ru/post/de416171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416159/index.html">Wie wir beauftragt wurden, einen Igel mit einer Schlange zu vergleichen</a></li>
<li><a href="../de416161/index.html">10 Gr√ºnde, k8s nicht zu verwenden</a></li>
<li><a href="../de416163/index.html">Lerne OpenGL. Lektion 5.6 - Parallaxenzuordnung</a></li>
<li><a href="../de416167/index.html">Peter Norwig: Programmieren lernen in ... 10 Jahren</a></li>
<li><a href="../de416169/index.html">Container f√ºr Erwachsene (Teil 01): Ein praktischer Leitfaden zur Terminologie</a></li>
<li><a href="../de416175/index.html">Ergebnisse des Wettbewerbs junger Entwickler von AR-Anwendungen Epson Moverio BT-300</a></li>
<li><a href="../de416177/index.html">Tupper-Formel und Implementierung des Algorithmus in Python</a></li>
<li><a href="../de416179/index.html">Eine T√ºr, die uns mit Namen begr√º√üt und sich nur f√ºr Abteilungsmitarbeiter √∂ffnet</a></li>
<li><a href="../de416181/index.html">Amplitudenmodulation an den Fingern</a></li>
<li><a href="../de416183/index.html">Datentests: Anforderungen und Ebenen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>