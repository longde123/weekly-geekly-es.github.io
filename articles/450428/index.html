<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§§ ‚õπüèø üöÜ Indizadores en C # debajo del cap√≥: indexaci√≥n mejor que Dow Jones üëæ üìÄ üê±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen dia En este art√≠culo, propongo familiarizarme con los indexadores de varios tipos. Veamos el c√≥digo del lenguaje ensamblador para estos indexador...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizadores en C # debajo del cap√≥: indexaci√≥n mejor que Dow Jones</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450428/">  Buen dia  En este art√≠culo, propongo familiarizarme con los indexadores de varios tipos.  Veamos el c√≥digo del lenguaje ensamblador para estos indexadores y las caracter√≠sticas de cada instrucci√≥n en su velocidad.  Tambi√©n ofrecer√© algunas conclusiones obvias.  Pero qu√© usar exactamente en su situaci√≥n particular depende de usted si sacrifica la conveniencia por la velocidad o viceversa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/22/aw/ng/22awng79cibgcbel1r2v0ahwzc8.png" alt="imagen" width="100%"></div><a name="habracut"></a><br><h3>  M√©tricas </h3><br>  El c√≥digo del lenguaje ensamblador se proporciona para sistemas de 64 bits.  Se eligieron las siguientes m√©tricas como m√©tricas para cada instrucci√≥n: el n√∫mero de microoperaciones fusionadas, el n√∫mero total de microoperaciones, el retraso, el rendimiento y, por supuesto, el n√∫mero de instrucciones.  No di ning√∫n n√∫mero en su conjunto para el indexador, porque  la situaci√≥n puede variar seg√∫n c√≥mo trabaje con el tipo indexado y afectar la memoria cach√© de manera diferente. <br><br>  A continuaci√≥n se muestra un breve resumen de la terminolog√≠a, sin profundizar, solo conceptos conceptuales.  Mi objetivo era describir todo lo m√°s simple posible, para una comprensi√≥n com√∫n. <br><br>  <b>La microoperaci√≥n (uop)</b> es una operaci√≥n determinada en la que consiste cada instrucci√≥n.  El concepto de microoperaciones se utiliza para optimizaciones tales como fusi√≥n, almacenamiento en cach√© y reordenamiento.  Entonces, por ejemplo, la instrucci√≥n MOV consiste en 1 micro-operaci√≥n, mientras que la instrucci√≥n XCHG en dos registros consiste en 3 micro-operaciones (el enfoque es a trav√©s de una "variable temporal", es decir, un registro interno, gracias <i>leotsarev</i> por la actualizaci√≥n), la instrucci√≥n XCHG sobre el registro y la memoria consta de 8 microoperaciones. <br><br>  <b>Microoperaciones fusionadas (Uops fusionadas)</b> : como se mencion√≥ anteriormente, la fusi√≥n de microoperaciones es una de las optimizaciones.  Consiste en reemplazar dos microoperaciones por una m√°s compleja. <br><br>  <b>La latencia</b> es el n√∫mero de medidas despu√©s de las cuales los datos utilizados en esta instrucci√≥n estar√°n disponibles para ser utilizados por otra instrucci√≥n. <br><br>  <b>Rendimiento (rendimiento rec√≠proco)</b> : el n√∫mero de ciclos de reloj necesarios para ejecutar una instrucci√≥n, siempre que se ejecute una secuencia de instrucciones id√©nticas y operen con datos independientes. <br><br>  Seg√∫n estos indicadores, puede evaluar el rendimiento de un conjunto particular de instrucciones.  Tenga en cuenta que solo podemos "evaluar", el rendimiento real depende de muchos factores, como la memoria cach√© de aciertos o errores, la dependencia de datos, etc. <br><br>  Estas cifras son para la arquitectura del procesador Intel Skylake-X.  Esto corresponde a mi procesador Intel Core i7-6700. <br><br>  Tambi√©n vale la pena recordar que fastcall para sistemas de 64 bits proporciona la transferencia de no 2, sino 4 par√°metros en los registros (rcx, rdx, r8, r9). <br><br><h3>  Indizadores en n√∫meros </h3><br><h4>  1. Indizador de matriz </h4><br>  Consideraremos los siguientes m√©todos como ejemplo: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] array</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array[index]; }</code> </pre> <br>  Considere el c√≥digo de idioma del ensamblador para este fragmento. <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+8] 2. jae 00007ff9`07288c78 3. movsxd rax,edx 4. mov eax,dword ptr [r8+rax*4+10h]</code> </pre><br>  La primera l√≠nea verifica si el √≠ndice va m√°s all√° de los l√≠mites de la matriz.  La segunda l√≠nea arroja una excepci√≥n si sale.  A continuaci√≥n, calculamos la posici√≥n del elemento en la matriz.  Los primeros campos de la matriz son informaci√≥n de servicio, por lo que debemos omitirlos (10 h adicionales = 16 bytes). <br><br><div class="spoiler">  <b class="spoiler_title">Informaci√≥n sobre instrucciones:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  No </th><th>  Uops fusionados </th><th>  Uops totales </th><th>  Latencia </th><th>  Rendimiento rec√≠proco </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0.5 0.5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0.25 </td></tr><tr><td>  4 4 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0.5 0.5 </td></tr></tbody></table></div><br></div></div><br><br><h4>  2. Lista de favoritos &lt;&gt; </h4><br>  C√≥digo de tinta: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; list</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list[index]; }</code> </pre><br><br>  C√≥digo de lenguaje ensamblador: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+10h] 2. jae M00_L00 3. mov rax,qword ptr [r8+8] 4. cmp edx,dword ptr [rax+8] 5. jae 00007ff9`07268f56 6. movsxd rdx,edx 7. mov eax,dword ptr [rax+rdx*4+10h] ret M00_L00 call System.ThrowHelper.ThrowArgumentOutOfRange_IndexException()</code> </pre><br>  Claramente hay m√°s instrucciones aqu√≠.  Se ve claramente que el indexador de hoja envuelve el indexador de matriz.  Un punto interesante es que la verificaci√≥n para ir m√°s all√° de los l√≠mites de la matriz se realiza dos veces.  Entonces, la primera instrucci√≥n verifica si el √≠ndice va m√°s all√° de los bordes de la hoja.  Si lo hace, saltamos (instrucci√≥n 2) a una llamada muy obvia, lanzando una excepci√≥n si va m√°s all√° de los l√≠mites de la matriz.  Esta verificaci√≥n de borde utiliza el campo interno de la hoja, que es el segundo en orden (desplazamiento de 10 h (16) bytes desde el comienzo del tipo, 8 al puntero a la tabla de m√©todos y 8 al enlace a la matriz interna, el primer campo).  En la tercera l√≠nea, colocamos en el registro rax la direcci√≥n de la matriz interna: el primer campo (por analog√≠a, un desplazamiento de 8 bytes es un puntero a la tabla de m√©todos).  Esto es seguido por la secci√≥n ya familiar: la referencia de √≠ndice para la matriz (l√≠neas 4 - 7).  Aqu√≠, para verificar los l√≠mites, se utiliza el campo interno de la matriz. <br>  Trat√© de eliminar cosas que no est√°n directamente relacionadas con la indexaci√≥n, pero aqu√≠ vale la pena dejar ret para que no parezca que habr√° una excepci√≥n al final de cada llamada al elemento de hoja: D <br><br>  Por cierto, para no atormentarlo con especulaciones, familiar√≠cese con la implementaci√≥n de la hoja <a href="">por referencia</a> .  La conversi√≥n de tipos a ints sin signo se utiliza para reducir el n√∫mero de comparaciones. <br><br>  Como resultado, obtenemos 7 instrucciones para acceder con √©xito al √≠ndice, que es 3 m√°s que en la matriz. <br><br><div class="spoiler">  <b class="spoiler_title">Informaci√≥n sobre instrucciones:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  No </th><th>  Uops fusionados </th><th>  Uops totales </th><th>  Latencia </th><th>  Rendimiento rec√≠proco </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0.5 0.5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0.5 0.5 </td></tr><tr><td>  4 4 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0.5 0.5 </td></tr><tr><td>  5 5 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  6 6 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0.25 </td></tr><tr><td>  7 7 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0.5 0.5 </td></tr></tbody></table></div><br></div></div><br><h4>  Nuevo - Span &lt;&gt; </h4><br>  Disco: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerSpan</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> span[index]; }</code> </pre><br>  Y en lenguaje ensamblador: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+8] 2. jae 00007ff9`07278f69 3. mov rax,qword ptr [r8] 4. movsxd rdx,edx 5. mov eax,dword ptr [rax+rdx*4]</code> </pre><br>  Cuando se anunciaron los tramos, nos prometieron que se hicieron sabiamente, con el apoyo del tiempo de ejecuci√≥n.  Y no mintieron qu√© decir.  De hecho, difiere de la matriz cl√°sica en una sola instrucci√≥n, un paso adicional para acceder a la direcci√≥n.  A juzgar por este c√≥digo, la direcci√≥n de la ubicaci√≥n de la memoria est√° oculta dentro del intervalo, donde se encuentran los elementos, que obtenemos en la l√≠nea 3. Esta puede ser una direcci√≥n a un lugar espec√≠fico en una matriz, l√≠nea o un trozo de memoria en la pila. <br>  Haga clic aqu√≠ para obtener una introducci√≥n al indexador Span por diversi√≥n.  Puede notar que hay 2 implementaciones diferentes, dependiendo de la variable de entorno.  PROJECTN es el nombre en clave de la primera versi√≥n de .NET Native para UWP.  Por lo tanto, estamos m√°s interesados ‚Äã‚Äãen la segunda versi√≥n del indexador.  Ella est√° etiquetada <a href=""><i>[intr√≠nseca]</i></a> .  Adem√°s, si observa la clase <a href="">insegura</a> est√°tica utilizada en la implementaci√≥n de este indexador, puede encontrar informaci√≥n de que las implementaciones de la mayor√≠a de los m√©todos en este archivo est√°n representadas como <i>intr√≠nsecas</i> . <br><br>  Las llamadas a m√©todos o referencias a campos marcados con el atributo <i>[Intr√≠nseco]</i> tienen soporte desde el tiempo de ejecuci√≥n. <br><br>  En <b>CoreCLR</b> , los cuerpos de dichos m√©todos son reemplazados por EE (motor de ejecuci√≥n) con c√≥digo inseguro (inseguro).  Si necesita m√°s detalles, puede comenzar a cavar con el m√©todo <a href="">getILIntrinsicImplementationForUnsafe</a> . <br><br>  Informaci√≥n sobre c√≥mo funciona esto en <b>CoreRT</b> (que me interesa un poco), <br>  puede comenzar a buscar en <a href="">Internal.IL.Stubs.UnsafeIntrinsics</a> . <br><br>  Dado el apoyo de Raintime, para comprender qu√© suceder√° exactamente detr√°s de escena, tiene sentido mirar las instrucciones en el lenguaje ensamblador, lo cual hicimos. <br><br><div class="spoiler">  <b class="spoiler_title">Informaci√≥n sobre instrucciones:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  No </th><th>  Uops fusionados </th><th>  Uops totales </th><th>  Latencia </th><th>  Rendimiento rec√≠proco </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0.5 0.5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0.5 0.5 </td></tr><tr><td>  4 4 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0.25 </td></tr><tr><td>  5 5 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0.5 0.5 </td></tr></tbody></table></div><br></div></div><br>  Todos los indexadores dependen en gran medida de los datos: las instrucciones utilizan los resultados de los anteriores.  No hay resultados inusuales aqu√≠, y no deber√≠a haberlos.  Pero ahora la sobrecarga que aparece en este o aquel caso es clara.  Algunos hallazgos obvios.  Si el algoritmo involucra accesos muy frecuentes por √≠ndice, entonces tiene sentido pensar en reemplazar la hoja con una matriz.  Si la llamada no es muy frecuente, puede ser m√°s conveniente usar una hoja que proporcione una API muy conveniente y no tenga una sobrecarga tan grande (le recuerdo que controle las extensiones de la matriz interna). <br><br>  Ahora tratemos de ver las diferentes formas con las que podemos especificar una matriz bidimensional: una matriz de matrices (matriz dentada) y una matriz multidimensional (matriz multidimensional). <br><br><h4>  4. Matriz multidimensional </h4><br>  C√≥digo Sharp: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerDimensionalArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] demensionalArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> demensionalArray[index1, index2]; }</code> </pre><br>  Lenguaje ensamblador: <br><br><pre> <code class="plaintext hljs">1. mov eax,edx 2. sub eax,dword ptr [r9+18h] 3. cmp eax,dword ptr [r9+10h] 4. jae 00007ff9`00098fe6 5. mov edx,r8d 6. sub edx,dword ptr [r9+1Ch] 7. cmp edx,dword ptr [r9+14h] 8. jae 00007ff9`00098fe6 9. mov ecx,dword ptr [r9+14h] 10. imul rcx,rax 11. mov rax,rdx 12. add rax,rcx 13. mov eax,dword ptr [r9+rax*4+20h]</code> </pre><br>  En principio, todo es comprensible: 2 verifica los l√≠mites de la matriz, luego calcula el √≠ndice y retrocede.  Esta matriz se almacena en la memoria en un fragmento. <br><br><div class="spoiler">  <b class="spoiler_title">Informaci√≥n sobre instrucciones:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  No </th><th>  Uops fusionados </th><th>  Uops totales </th><th>  Latencia </th><th>  Rendimiento rec√≠proco </th></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0.25 </td></tr><tr><td>  2 </td><td>  1 </td><td>  2 </td><td></td><td>  0.5 0.5 </td></tr><tr><td>  3 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0.5 0.5 </td></tr><tr><td>  4 4 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  5 5 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0.25 </td></tr><tr><td>  6 6 </td><td>  1 </td><td>  2 </td><td></td><td>  0.5 0.5 </td></tr><tr><td>  7 7 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0.5 0.5 </td></tr><tr><td>  8 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  9 9 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0.5 0.5 </td></tr><tr><td>  10 </td><td>  1 </td><td>  1 </td><td>  3 </td><td>  1 </td></tr><tr><td>  11 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0.25 </td></tr><tr><td>  12 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0.25 </td></tr><tr><td>  13 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0.5 0.5 </td></tr></tbody></table></div><br></div></div><br><br><h4>  5. Matriz de matrices (matriz irregular) </h4><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerJaggedArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] jaggedArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jaggedArray[index][index2]; }</code> </pre><br>  Ensamblador: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r9+8] 2. jae 00007ff9`00098f95 3. movsxd rax,edx 4. mov rax,qword ptr [r9+rax*8+10h] 5. cmp r8d,dword ptr [rax+8] 6. jae 00007ff9`00098f95 7. movsxd rdx,r8d 8. mov eax,dword ptr [rax+rdx*4+10h]</code> </pre><br>  Y lo m√°s interesante: tenemos menos instrucciones que con un tipo especialmente dise√±ado para multidimensionalidad. <br><br><div class="spoiler">  <b class="spoiler_title">Informaci√≥n sobre instrucciones:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  No </th><th>  Uops fusionados </th><th>  Uops totales </th><th>  Latencia </th><th>  Rendimiento rec√≠proco </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0.5 0.5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0.25 </td></tr><tr><td>  4 4 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0.5 0.5 </td></tr><tr><td>  5 5 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0.5 0.5 </td></tr><tr><td>  6 6 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  7 7 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0.25 </td></tr><tr><td>  8 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0.5 0.5 </td></tr></tbody></table></div><br></div></div><br>  Pero sobre los √∫ltimos 2 ejemplos, le aconsejo que no se apresure a sacar conclusiones.  Debido al hecho de que una matriz bidimensional es de un solo tipo, que se inicializa 1 vez, la memoria para toda la matriz se asigna en un fragmento grande.  Esto proporcionar√° una mejor memoria cach√©, que puede cambiar fundamentalmente la situaci√≥n.  En una matriz de matrices, la memoria para cada matriz se asignar√° por separado, por lo que es probable que las matrices se asignen en la memoria y se ingresen en los lugares m√°s adecuados para ellas. <br><br>  Sin embargo, quiz√°s para algunos, este comportamiento ser√° m√°s aceptable.  Quiz√°s en algunas situaciones se sabe que la vida √∫til de este esp√©cimen ser√° de corta duraci√≥n.  Y para no caer en un mont√≥n de objetos grandes (que es una especie de segunda generaci√≥n para el recolector de basura), donde existe la posibilidad de permanecer durante mucho tiempo, mucho m√°s de lo que nos gustar√≠a.  O, despu√©s de alg√∫n tiempo, queremos trabajar solo con ciertas l√≠neas, y todo lo dem√°s se puede borrar.  Adem√°s, se planea trabajar con el tipo haciendo referencia a elementos inconsistentes aleatorios, cuando el cach√© no puede funcionar normalmente. <br><br>  Adem√°s, cuando se usa una matriz de matrices, es m√°s probable que no provoque que el recolector de basura se compacte, sino que lo haga con un barrido.  Recordatorio: al fragmentar la memoria, la cantidad total de espacio libre puede ser suficiente para un nuevo objeto, pero no hay un √°rea libre continua de la cantidad requerida.  En este caso, se realiza la compactaci√≥n: mover objetos con el objetivo de desfragmentar.  Si somos capaces de recoger un tramo continuo de memoria libre para un nuevo objeto, simplemente podemos ingresar el objeto en este espacio libre.  Esto se llama barrido. <br><br>  Espero que esta informaci√≥n lo ayude a sacar las conclusiones correctas y a fundamentar su opini√≥n en la discusi√≥n sobre qu√© usar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450428/">https://habr.com/ru/post/450428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450416/index.html">C√≥mo los proveedores de shareware VPN venden sus datos</a></li>
<li><a href="../450418/index.html">El arte de crear modelos 3D org√°nicos: sombreadores subd√©rmicos</a></li>
<li><a href="../450420/index.html">Por qu√© los equipos de ciencia de datos necesitan universales, no especialistas</a></li>
<li><a href="../450422/index.html">Las limitaciones de los algoritmos de reconocimiento de im√°genes.</a></li>
<li><a href="../450426/index.html">2011 vs AM4. Dinosaurios vs Mam√≠feros</a></li>
<li><a href="../450430/index.html">¬øQu√© es un ataque de polvo?</a></li>
<li><a href="../450432/index.html">Bueno, donde esta ella?</a></li>
<li><a href="../450436/index.html">¬øQu√© es un campamento de codificaci√≥n?</a></li>
<li><a href="../450438/index.html">¬øPor qu√© la automatizaci√≥n del centro de contacto ser√≠a una terrible oscuridad sin CRM?</a></li>
<li><a href="../450440/index.html">Sobre piedras del cielo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>